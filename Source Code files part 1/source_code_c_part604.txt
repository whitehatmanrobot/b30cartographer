w type from GetBuffer
    if (m_bUsingMyAllocator) {
        if (S_OK == m_pConnectedPin->QueryAccept(pmt)) {
            hr = S_OK;
        }
    }

    //  Check if we'll be able to make a read-only sample
    if (m_bSamplesAreReadOnly) {
        //  If the pixel format is not OK
        if (!IsSupportedType(&lpDDSurfaceDesc->ddpfPixelFormat)) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        }
    }

    //
    //  If we're stopped then we can attempt to reconnect
    //
    if (S_OK !=  hr && m_FilterState == State_Stopped) {
        AM_MEDIA_TYPE SavedType;
        DDSURFACEDESC ddsdSaved;
        CComPtr<IDirectDrawPalette> pPaletteSaved;
        ddsdSaved.dwSize = sizeof(ddsdSaved);
        ConnectionMediaType(&SavedType);
        GetFormatInternal(&ddsdSaved, &pPaletteSaved, NULL, NULL);
        CComPtr<IPin> pConnected = m_pConnectedPin;
        Disconnect();
        pConnected->Disconnect();
        IPin *ppinIn;
        IPin *ppinOut;
        if (m_Direction == PINDIR_INPUT) {
            ppinIn = this;
            ppinOut = pConnected;
        } else {
            ppinOut = this;
            ppinIn = pConnected;
        }
        HRESULT hrTmp = InternalSetFormat(lpDDSurfaceDesc, pPalette, false);   // Recurse!
        if (SUCCEEDED(hrTmp)) {
            CComQIPtr<IGraphBuilder, &IID_IGraphBuilder>
                pBuilder(m_pFilterGraph);
            hrTmp = pBuilder->Connect(ppinOut, ppinIn);
        }
        if (FAILED(hrTmp)) {
            SetFormat(&ddsdSaved, pPaletteSaved);
            m_pFilterGraph->ConnectDirect(ppinOut, ppinIn, &SavedType);
        } else {
            hr = S_OK;
        }
        CoTaskMemFree(SavedType.pbFormat);
    }
    return hr;
}


HRESULT CDDStream::InternalSetFormat(const DDSURFACEDESC *lpDDSurfaceDesc,
                                     IDirectDrawPalette *pPalette,
                                     bool bFromPin,
                                     bool bQuery)
{
    if (!lpDDSurfaceDesc) {
        return E_POINTER;
    }
    if (lpDDSurfaceDesc->dwSize != sizeof(*lpDDSurfaceDesc)) {
        return DDERR_INVALIDPARAMS;
    }

    DDSURFACEDESC ddsd;
    bool bPaletteAllocated = false;

    Lock();
    DDSURFACEDESC ddsdCopy;
    if (m_pConnectedPin && !bQuery &&
        (bFromPin && !(m_dwForcedFormatFlags & (DDSD_WIDTH | DDSD_HEIGHT)) ||
         !bFromPin && pPalette == NULL &&
             lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 8
        )
       ) {

        /*  See what size the connected pin would like :

            -- If the width and height haven't been specified set them
               to the output pin's preferred values
            -- If no palette is specified try to get one from the output
               pin
        */
        AM_MEDIA_TYPE *pmt;
        IEnumMediaTypes *pEnum;
        HRESULT hr = m_pConnectedPin->EnumMediaTypes(&pEnum);
        if (SUCCEEDED(hr)) {
            ULONG ulGot;
            bool bBreak = false;
            while (!bBreak && S_OK == pEnum->Next(1, &pmt, &ulGot)) {
                if (pmt->formattype == FORMAT_VideoInfo) {
                    VIDEOINFO *pvi = (VIDEOINFO *)pmt->pbFormat;
                    if (bFromPin) {
                        ddsdCopy = *lpDDSurfaceDesc;
                        ddsdCopy.dwWidth = pvi->bmiHeader.biWidth;
                        ddsdCopy.dwHeight = pvi->bmiHeader.biHeight < 0 ?
                                               -pvi->bmiHeader.biHeight :
                                               pvi->bmiHeader.biHeight;
                        lpDDSurfaceDesc = &ddsdCopy;
                        bBreak = true;
                    } else {
                        if (pmt->subtype == MEDIASUBTYPE_RGB8) {
                            DDSURFACEDESC ddsd;
                            _ASSERTE(pPalette == NULL);
                            if (SUCCEEDED(ConvertMediaTypeToSurfaceDesc(
                                    pmt,
                                    m_pDirectDraw,
                                    &pPalette,
                                    &ddsd)) &&
                                pPalette != NULL) {
                                bPaletteAllocated = true;
                            }
                            bBreak = true;
                        }
                    }
                }
                DeleteMediaType(pmt);
            }
            pEnum->Release();
        }
    }
    InitSurfaceDesc(&ddsd);
    ddsd.dwFlags = lpDDSurfaceDesc->dwFlags;
    bool bMatches = true;
    bool bPixelFmtMatches = true;
    BOOL bContradictsForced = FALSE;
    if (ddsd.dwFlags & (DDSD_HEIGHT | DDSD_WIDTH)) {
        if (ddsd.dwHeight != lpDDSurfaceDesc->dwHeight ||
            ddsd.dwWidth !=  lpDDSurfaceDesc->dwWidth) {
            bMatches = false;
            ddsd.dwHeight = lpDDSurfaceDesc->dwHeight;
            ddsd.dwWidth = lpDDSurfaceDesc->dwWidth;
            bContradictsForced |= (m_dwForcedFormatFlags & DDSD_HEIGHT);
        }
    }
    if (ddsd.dwFlags & DDSD_PIXELFORMAT) {
        if (!ComparePixelFormats(&ddsd.ddpfPixelFormat,
                                 &lpDDSurfaceDesc->ddpfPixelFormat)) {
            bMatches = false;
            bPixelFmtMatches = false;
            bContradictsForced |= (m_dwForcedFormatFlags & DDSD_PIXELFORMAT);
        }

        //  Always copy because ComparePixelFormats doesn't check all
        //  the bits but we need to save the correct format for making
        //  more surfaces
        memcpy(&ddsd.ddpfPixelFormat, &lpDDSurfaceDesc->ddpfPixelFormat, sizeof(ddsd.ddpfPixelFormat));
    }

    HRESULT hr;
    if (bMatches) {
        hr = S_OK;
    } else {
        if (bContradictsForced && bFromPin) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            if (m_cAllocated) {
                hr = MS_E_SAMPLEALLOC;
            } else {
                //
                //  If the pin is trying to change its own type via query accept then skip the
                //  renegotiation phase.
                //
                if (bFromPin || bQuery) {
                    // If we're connected then this is from QueryAccept so we'll say OK.  Otherwise, only
                    // accept a ReceiveConnection if the pixel format matches the display pixel format.
                    //
                    // NOTE - aren't we going to return S_OK always here?
                    // During connection m_pConnectedPin is not set anyway
                    // and bQuery already checks for QueryAccept (Robin)
                    hr = (m_pConnectedPin || bPixelFmtMatches) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED;
                } else {
                    _ASSERTE(!bQuery);
                    // Note:  The below call to ConvertSurfaceDescToMediaType should always be done to make
                    // sure that the surface descriptor is valid, EVEN IF WE'RE NOT CONNECTED TO A PIN!
                    AM_MEDIA_TYPE *pmt;
                    hr = ConvertSurfaceDescToMediaType(lpDDSurfaceDesc, pPalette,
                                                       NULL, true, &pmt);
                    if (SUCCEEDED(hr)) {
                        hr = m_pConnectedPin ? RenegotiateMediaType(lpDDSurfaceDesc, pPalette, pmt) : S_OK;
                        DeleteMediaType(pmt);
                    }
                }
            }
        }
    }

    //
    //  Even if we match we may be forcing more format flags and
    //  setting caps flags
    if (S_OK == hr && !bQuery) {

        //  Don't update the pixel format if it was already forced
        if (ddsd.dwFlags & DDSD_PIXELFORMAT) {
            if (!bFromPin || !(m_dwForcedFormatFlags & DDSD_PIXELFORMAT)) {
                memcpy(&m_PixelFormat, &ddsd.ddpfPixelFormat, sizeof(m_PixelFormat));
                m_PixelFormat.dwSize = sizeof(m_PixelFormat);
            }
        }

        if (!bFromPin) {
            m_dwForcedFormatFlags = ddsd.dwFlags &
                (DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT | DDSD_CAPS);
        }
        m_pDirectDrawPalette = pPalette;

        if (ddsd.dwFlags & (DDSD_HEIGHT | DDSD_WIDTH)) {
            m_Height = ddsd.dwHeight;
            m_Width  = ddsd.dwWidth;
        }
    }

    if (bPaletteAllocated) {
        pPalette->Release();
        pPalette = NULL;
    }


    Unlock();
    return hr;
}


STDMETHODIMP CDDStream::GetDirectDraw(IDirectDraw **ppDirectDraw)
{
    TRACEINTERFACE(_T("IDirectDrawStream::GetDirectDraw(0x%8.8X)\n"),
                   ppDirectDraw);
    if (!ppDirectDraw) {
        return E_POINTER;
    }
    Lock();
    *ppDirectDraw = m_pDirectDraw;
    Unlock();
    if (*ppDirectDraw) {
        (*ppDirectDraw)->AddRef();
    }
    return S_OK;
}

STDMETHODIMP CDDStream::SetDirectDraw(IDirectDraw *pDirectDraw)
{
    TRACEINTERFACE(_T("IDirectDrawStream::SetDirectDraw(0x%8.8X)\n"),
                   pDirectDraw);
    HRESULT hr;
    AUTO_CRIT_LOCK;
    if (m_cAllocated) {
        hr = IsSameObject(m_pDirectDraw, pDirectDraw) ? S_OK : MS_E_SAMPLEALLOC;
    } else {
        //
        //  NOTE:  This is important!  We need to release ALL objects that were allocated
        //         by the previous DirectDraw object since they will magically disappear
        //         beneath us.  So far, the only object we hold is the palette so we'll copy
        //         the entries and then create a new object.
        //
        hr = S_OK;
        if (m_pDirectDrawPalette) {
            if (pDirectDraw) {
                PALETTEENTRY aPaletteEntry[256];
                hr = m_pDirectDrawPalette->GetEntries(0, 0, 256, aPaletteEntry);
                if (SUCCEEDED(hr)) {
                    CComPtr <IDirectDrawPalette> pNewPal;
                    hr = pDirectDraw->CreatePalette(DDPCAPS_8BIT | DDPCAPS_ALLOW256, aPaletteEntry, &pNewPal, NULL);
                    if (SUCCEEDED(hr)) {
                        m_pDirectDrawPalette = pNewPal;
                    }
                }
            } else {
                m_pDirectDrawPalette = NULL;    // If no direct draw object then toss the palette.
            }
        }
        if (SUCCEEDED(hr)) {
            m_pDirectDraw = pDirectDraw;
            if (pDirectDraw) {
                m_pDefPixelFormat = GetDefaultPixelFormatPtr(pDirectDraw);
            }
        }
    }
    return hr;
}



//
//  NOTE:  For this function, the caller MUST provide a rect.  The format of the surface
//  and the DirectDraw object are not checked for validity.  They are assumed to be correct.
//
HRESULT CDDStream::InternalCreateSample(IDirectDrawSurface *pSurface, const RECT *pRect,
                                        DWORD dwFlags, bool bIsInternalSample,
                                        IDirectDrawStreamSample **ppSample,
                                        bool bTemp)
{
    HRESULT hr = S_OK;
    *ppSample = NULL;

    AUTO_CRIT_LOCK;
    CDDSample *pSample;

    //  First check the surface format
    {
        DDSURFACEDESC ddsd;

        CComPtr<IDirectDrawPalette> pPalette;
        pSurface->GetPalette(&pPalette);
        ddsd.dwSize = sizeof(ddsd);
        _ASSERTE(pRect != NULL);
        hr = pSurface->GetSurfaceDesc(&ddsd);
        ddsd.dwWidth  = pRect->right - pRect->left;
        ddsd.dwHeight = pRect->bottom - pRect->top;
        if (SUCCEEDED(hr)) {
            hr = SetFormat(&ddsd, pPalette ? pPalette : m_pDirectDrawPalette);
        }
    }

    if (SUCCEEDED(hr)) {
        if (bIsInternalSample) {
            CDDInternalSample *pInternal = new CComObject<CDDInternalSample>;
            if (pInternal != NULL) {
                hr = pInternal->InternalInit();
            }
            pSample = pInternal;
        } else {
            pSample = new CComObject<CDDSample>;
        }
        if (pSample) {
            //
            //  InitSample will increment our m_cAllocated variable if this is not an internal sample....
            //
            if (SUCCEEDED(hr)) {
                hr = pSample->InitSample(this, pSurface, pRect, dwFlags & DDSFF_PROGRESSIVERENDER, bIsInternalSample,
                                         bTemp);
            }
            if (SUCCEEDED(hr)) {
                pSample->GetControllingUnknown()->QueryInterface(IID_IDirectDrawStreamSample, (void **)ppSample);
            } else {
                delete pSample;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

#if 0
    //  Use the real pixel format for subsequent surfaces
    if (SUCCEEDED(hr)) {
        m_PixelFormat.dwFlags = ddsd.ddpfPixelFormat.dwFlags;
    }
#endif

    return hr;
}



STDMETHODIMP CDDStream::CreateSample(IDirectDrawSurface *pSurface, const RECT *pRect, DWORD dwFlags,
                                     IDirectDrawStreamSample **ppSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::CreateSample(0x%8.8X, 0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pSurface, pRect, dwFlags, ppSample);
    HRESULT hr;
    *ppSample = NULL;

    if (dwFlags & (~DDSFF_PROGRESSIVERENDER)) {
        return E_INVALIDARG;
    }

    AUTO_CRIT_LOCK;
    if (pSurface == NULL) {
        if (pRect) {
            hr = E_INVALIDARG;
        } else {
            hr = InternalAllocateSample(dwFlags, false, ppSample);
        }
    } else {
        CComQIPtr <IDirectDrawSurface2, &IID_IDirectDrawSurface2> pSurf2(pSurface);

        //  Work around DDrawEx bug
        IUnknown *pUnk;
        hr = pSurf2->GetDDInterface((void **)&pUnk);
        if (SUCCEEDED(hr)) {
            IDirectDraw *pDD;
            hr = pUnk->QueryInterface(IID_IDirectDraw, (void **)&pDD);
            pUnk->Release();
            if (SUCCEEDED(hr)) {
                hr = SetDirectDraw(pDD);
                pDD->Release();
            }
        }

        if (SUCCEEDED(hr)) {
            DDSURFACEDESC ddsd;
            ddsd.dwSize = sizeof(ddsd);
            hr = pSurface->GetSurfaceDesc(&ddsd);

            if (SUCCEEDED(hr)) {
                RECT SubRect;
                if (pRect) {
                    SubRect = *pRect;
                    if (SubRect.left > SubRect.right || SubRect.right > (LONG)ddsd.dwWidth ||
                        SubRect.top > SubRect.bottom || SubRect.bottom > (LONG)ddsd.dwHeight) {
                        hr = DDERR_INVALIDRECT;
                        goto Exit;
                    }
                    ddsd.dwWidth = SubRect.right - SubRect.left;
                    ddsd.dwHeight = SubRect.bottom - SubRect.top;
                } else {
                    SubRect.top = SubRect.left = 0;
                    SubRect.bottom = ddsd.dwHeight;
                    SubRect.right = ddsd.dwWidth;
                }

                //
                //  We don't set the CAPS flag here so we won't force a particular caps
                //  mode.  I'm not sure if this is the right choice, but it seems more
                //  flexible.
                //
                ddsd.dwFlags &= (DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT);
                CComPtr<IDirectDrawPalette> pPalette;
                pSurface->GetPalette(&pPalette);
                hr = SetFormat(&ddsd, pPalette);
                if (SUCCEEDED(hr)) {
                    hr = InternalCreateSample(pSurface, &SubRect, dwFlags, false, ppSample);
                }
            }
        }
    }
Exit:
    return hr;
}

//  Get the time per frame
//  If we're connected this comes out of the media type, otherwise we
//  don't know
STDMETHODIMP CDDStream::GetTimePerFrame(
        /* [out] */ STREAM_TIME *pFrameTime
)
{
    if (pFrameTime == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    if (m_pConnectedPin) {
        *pFrameTime = ((VIDEOINFO *)m_ConnectedMediaType.pbFormat)->AvgTimePerFrame;
    } else {
        return MS_E_NOSTREAM;
    }
    return S_OK;
}

//
//  IPin implementation
//

STDMETHODIMP CDDStream::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    AUTO_CRIT_LOCK;
    //
    //  This helper function in CStream checks basic parameters for the Pin such as
    //  the connecting pin's direction (we need to check this -- Sometimes the filter
    //  graph will try to connect us to ourselves!) and other errors like already being
    //  connected, etc.
    //
    HRESULT hr = CheckReceiveConnectionPin(pConnector);

    if (hr == NOERROR && pmt->formattype == FORMAT_VideoInfo) {
        //
        //  Check the source accepts negative heights
        //
        VIDEOINFO * const pvi = (VIDEOINFO *)pmt->pbFormat;
        if (pvi->bmiHeader.biHeight > 0) {
            VIDEOINFO vi;
            CopyMemory((PVOID)&vi, (PVOID)pmt->pbFormat,
                       min(pmt->cbFormat, sizeof(vi)));
            AM_MEDIA_TYPE mt = *pmt;
            mt.pbFormat = (PBYTE)&vi;
            vi.bmiHeader.biHeight = - vi.bmiHeader.biHeight;
            if (S_OK != pConnector->QueryAccept(&mt)) {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
    }

    if (hr == NOERROR) {
        DDSURFACEDESC SurfaceDesc;
        SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
        CComPtr <IDirectDrawPalette> pPalette;
        m_pConnectedPin = pConnector;
        if (NOERROR == ConvertMediaTypeToSurfaceDesc(pmt, m_pDirectDraw, &pPalette, &SurfaceDesc) &&
            SUCCEEDED(InternalSetFormat(&SurfaceDesc, pPalette, true))) {
            CopyMediaType(&m_ConnectedMediaType, pmt);
            CopyMediaType(&m_ActualMediaType, pmt);
            hr = NOERROR;
        } else {
            m_pConnectedPin = NULL;
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    if (SUCCEEDED(hr)) {
        pConnector->QueryInterface(IID_IQualityControl, (void **)&m_pQC);
    }

    return hr;
}


STDMETHODIMP CDDStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    AUTO_CRIT_LOCK;

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    DDSURFACEDESC SurfaceDesc;
    SurfaceDesc.dwSize = sizeof(DDSURFACEDESC);
    CComPtr <IDirectDrawPalette> pPalette;
    if (S_OK == ConvertMediaTypeToSurfaceDesc(pmt, m_pDirectDraw, &pPalette, &SurfaceDesc) &&
        SUCCEEDED(InternalSetFormat(&SurfaceDesc, pPalette, true, true)) &&
        ((VIDEOINFOHEADER *)pmt->pbFormat)->bmiHeader.biHeight >= 0) {
        hr = S_OK;
    }
    return hr;
}


STDMETHODIMP CDDStream::Receive(IMediaSample *pMediaSample)
{
    bool bDummySample = false;

    if (m_bFlushing || m_bStopIfNoSamples && m_cAllocated == 0) {
        EndOfStream();
        return S_FALSE;
    }
    HRESULT hr = S_OK;
#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME rtStart, rtStop;
        if (SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            ATLTRACE(_T("AMSTREAM.DLL : Video sample received - start %dms, end %dms, duration %dms\n"),
                     (LONG)(rtStart / 10000), (LONG)(rtStop / 10000),
                     (LONG)((rtStop - rtStart) / 10000));
        }
    }
#endif
    if (m_bUsingMyAllocator) {
        CDDSample *pSrcSample = (CDDSample *)((CMediaSample *)pMediaSample)->m_pSample;
        pSrcSample->ReleaseMediaSampleLock();
        pSrcSample->m_bReceived = true;
        if (!pSrcSample->m_bWaited) {
            //  Wait for render time
            REFERENCE_TIME rtStart, rtStop;
            if (SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
                m_pFilter->WaitUntil(rtStart);
            }
        }
        if (pSrcSample->IsTemp()) {
            bDummySample = true;
        } else {
#ifdef SHOWSURFACES
            ShowSurface(pSrcSample->m_pSurface);
#endif
            //  In this case if the read-only sample has no buddy then
            //  it's a temp sample for the nostall stuff
            if (pSrcSample == m_pMyReadOnlySample &&
                !m_pMyReadOnlySample->HasBuddy()) {
                _ASSERTE(m_bNoStall);
                bDummySample = true;
            }
        }
    } else {
        CDDSample *pDestSample;
        REFERENCE_TIME rtStart, rtEnd;
        pMediaSample->GetTime(&rtStart, &rtEnd);
        hr = AllocDDSampleFromPool(&rtStart, &pDestSample);


        if (SUCCEEDED(hr)) {
            _ASSERTE(!pDestSample->IsTemp());
            Lock();
            // This is a media sample coming from a different allocator.
            AM_MEDIA_TYPE *pNewMediaType;
            if (pMediaSample->GetMediaType(&pNewMediaType) == S_OK) {
                FreeMediaType(m_ActualMediaType);
                //  Note just copying has the effect
                //  of transferring pNewMediaType's format block
                //  and pUnk reference count
                //  Also this way we avoid allocation failures
                m_ActualMediaType = *pNewMediaType;
                CoTaskMemFree((PVOID)pNewMediaType);
            }
            if (SUCCEEDED(hr)) {
                hr = pDestSample->CopyFrom(pMediaSample, &m_ActualMediaType);
#ifdef SHOWSURFACES
                ShowSurface(pDestSample->m_pSurface);
#endif
                hr = pDestSample->SetCompletionStatus(hr);
                // Warning!  The SetCompletionStatus may delete pDestSample.  Don't touch it after this point!
            }
            Unlock();
        } else {
            //  Might be timeout which means we become a zombie
            hr = S_OK;
            bDummySample = true;
        }
    }

    //  Send quality message if clocked
    //  NOTE - we must do this AFTER releasing the media sample lock
    //  or we can deadlock on the win16 lock when querying the clock
    //  because dsound can be running on another thread waiting for
    //  the win16 lock but holding its global mutex
    REFERENCE_TIME CurTime;
    if (S_OK == m_pFilter->GetCurrentStreamTime(&CurTime)) {
        REFERENCE_TIME rtStart, rtStop;
        if (m_pQC && SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = Famine;
            msg.Late = CurTime - rtStart;
            msg.TimeStamp = rtStart;
            if (bDummySample) {
                //  Tell them they're later than they actually are
                msg.Late += 150 * 10000;
            }

            //  Call Notify on our connected pin
            m_pQC->Notify(m_pBaseFilter, msg);

            //ATLTRACE("Late by %dms\n", (LONG)((CurTime - rtStart) / 10000));
        } else {
            //ATLTRACE("No timestamp\n");
        }
    }

#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME CurTime;
        m_pFilter->GetCurrentStreamTime(&CurTime);
        ATLTRACE(_T("AMSTREAM.DLL : Got sample at %dms\n"),
                 (LONG)(CurTime / 10000));
    }
#endif
    return hr;
}


STDMETHODIMP CDDStream::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    if (bReadOnly) {
        //  If the pixel format is not OK
        if (!IsSupportedType(&m_PixelFormat)) {
            return VFW_E_TYPE_NOT_ACCEPTED;
        }
    }
    return CStream::NotifyAllocator(pAllocator, bReadOnly);
}


//
// IMemAllocator implementation
//

//
// IMemAllocator
//
STDMETHODIMP CDDStream::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr;

    AUTO_CRIT_LOCK;
    ZeroMemory(pActual, sizeof(*pActual));
    if (pRequest->cbAlign == 0) {
    	hr = VFW_E_BADALIGN;
    } else {
        if (m_bCommitted == TRUE) {
    	    hr = VFW_E_ALREADY_COMMITTED;
    	} else {
            m_lRequestedBufferCount = pRequest->cBuffers;
            hr = GetProperties(pActual);
    	}
    }
    return hr;
}


STDMETHODIMP CDDStream::GetProperties(ALLOCATOR_PROPERTIES* pProps)
{
    AUTO_CRIT_LOCK;
    AM_MEDIA_TYPE *pMediaType;
    HRESULT hr = GetMediaType(-1, &pMediaType);
    if (SUCCEEDED(hr)) {
        VIDEOINFO *pVideoInfo = (VIDEOINFO *)pMediaType->pbFormat;
        BITMAPINFOHEADER *pbmiHeader = &pVideoInfo->bmiHeader;
        pProps->cbBuffer = pbmiHeader->biSizeImage;
        pProps->cBuffers = m_lRequestedBufferCount ?
                               m_lRequestedBufferCount : 1;
        pProps->cbAlign = 1;
        pProps->cbPrefix = 0;
        DeleteMediaType(pMediaType);
    }
    return hr;
}


STDMETHODIMP CDDStream::Decommit()
{
    AUTO_CRIT_LOCK;
    if (m_pMyReadOnlySample) {
        m_pMyReadOnlySample->Die();
        m_pMyReadOnlySample->GetControllingUnknown()->Release();
        m_pMyReadOnlySample = NULL;
    }
    return CStream::Decommit();
}

//
//  This method assumes the critical section is *NOT* owned!
//

HRESULT CDDStream::GetMyReadOnlySample(CDDSample *pBuddy, CDDSample **ppSample)
{
    *ppSample = NULL;
    CDDInternalSample *pROSample;
    Lock();
    if (!m_pMyReadOnlySample) {
        IDirectDrawStreamSample *pDDSample;
        HRESULT hr = InternalAllocateSample(DDSFF_PROGRESSIVERENDER, true, &pDDSample);
        if (FAILED(hr)) {
            Unlock();
            return hr;
        }
        m_pMyReadOnlySample = (CDDInternalSample *)pDDSample;
    }
    pROSample = m_pMyReadOnlySample;
    pROSample->GetControllingUnknown()->AddRef();
    Unlock();
    //
    //  Must leave our critical section here!  This is very important since JoinToBuddy can fail.
    //
    HRESULT hr;
    if (pBuddy) {
        hr = pROSample->JoinToBuddy(pBuddy);
    } else {
        hr = S_OK;
    }
    if (hr == S_OK) {
        *ppSample = pROSample;
    } else {
        pROSample->GetControllingUnknown()->Release();
    }
    return hr;
}





STDMETHODIMP CDDStream::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime, DWORD dwFlags)
{
    *ppBuffer = NULL;
    if (m_bStopIfNoSamples && m_cAllocated == 0) {
        return E_FAIL;
    }
    CDDSample *pSample;
#ifdef DEBUG
    if (bDbgTraceTimes) {
        ATLTRACE(_T("AMSTREAM.DLL : GetBuffer for %dms\n"),
                 pStartTime ? (LONG)(*pStartTime / 10000)  : 0);
    }
#endif
    HRESULT hr = AllocDDSampleFromPool(pStartTime, &pSample);
    if (SUCCEEDED(hr)) {
        if (CreateInternalSample() && !pSample->m_bProgressiveRender) {
            CDDSample *pMyReadOnlySample;
            hr = GetMyReadOnlySample(pSample, &pMyReadOnlySample);
            if (FAILED(hr)) {
                return pSample->SetCompletionStatus(hr);
            }
            pSample = pMyReadOnlySample;
        }
        Lock();
        pSample->m_pMediaSample->m_dwFlags = dwFlags;
        m_lLastPitch = pSample->LockAndPrepareMediaSample(m_lLastPitch);
        if (m_lLastPitch == 0) {
            hr = pSample->SetCompletionStatus(E_UNEXPECTED);    // Really strange to fail this way!
        } else {
            pSample->m_bReceived = false;
            pSample->m_bModified = true;
            *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
            (*ppBuffer)->AddRef();
        }
        Unlock();
    }
    return hr;
}


//
// Special CStream methods
//
HRESULT CDDStream::GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType)
{
    if (Index != 0 && Index != -1) {
        return S_FALSE;
    }

    DDSURFACEDESC ddsd;
    ddsd.dwSize = sizeof(ddsd);
    CComPtr<IDirectDrawPalette> pPalette;
    GetFormatInternal(&ddsd, &pPalette, NULL, NULL);
    HRESULT hr = ConvertSurfaceDescToMediaType(&ddsd, pPalette, NULL, TRUE, ppMediaType);

    //  Don't offer a type for input - someone might use it!
    if (SUCCEEDED(hr) && m_Direction == PINDIR_INPUT && Index == 0) {
        //  Something impossible - or at least something we'll reject
        //  but something they won't fall over on
        (*ppMediaType)->formattype = GUID_NULL;
    }

    return hr;
}


//  Create a temporary sample in order to throw away the data
HRESULT CDDStream::CreateTempSample(CSample **ppSample)
{
    if (CreateInternalSample()) {
        CDDSample *pDDSample;
        HRESULT hr = GetMyReadOnlySample(NULL, &pDDSample);
        *ppSample = pDDSample;
        return hr;
    }
    //ATLTRACE("Creating temp sample\n");
    IDirectDrawStreamSample *pSample;
    *ppSample = NULL;

    //  This must be allocated as an internal sample otherwise
    //  we wind up AddRef'ing the filter graph and leaking
    //  everything (because the final release is on a filter
    //  thread and the filter graph hangs waiting for the thread
    //  that is actually doing the final release to go away).
    HRESULT hr = InternalAllocateSample(0, true, &pSample, true);
    if (SUCCEEDED(hr)) {
        *ppSample = static_cast<CDDSample *>(pSample);
    } else {
        //ATLTRACE("Failed to create temp sample\n");
    }
    return hr;
}

STDMETHODIMP CDDStream::Initialize(IUnknown *pSourceObject, DWORD dwFlags, REFMSPID PurposeId, const STREAM_TYPE StreamType)
{
    //
    TRACEINTERFACE(_T("IDirectDrawStream::Initialize(0x%8.8X, 0x%8.8X, %s, %d)\n"),
                   pSourceObject, dwFlags, TextFromPurposeId(PurposeId), StreamType);
    //  It is important to call the base class first since if we are creating a peer
    //  stream then the Initalize call from the base class will end up calling SetSameFormat
    //  which will initialize this stream with the same directdraw object as it's peer.
    //  Otherwise, if the pSourceObject is actually a DirectDraw then we'll use that one.
    //
    HRESULT hr = CStream::Initialize(pSourceObject,
                                     dwFlags & ~AMMSF_NOSTALL,
                                     PurposeId,
                                     StreamType);
    if (SUCCEEDED(hr)) {

        if (dwFlags & AMMSF_NOSTALL) {
            m_bNoStall = true;
        }
        IDirectDraw *pDD;
        if (pSourceObject &&
            pSourceObject->QueryInterface(IID_IDirectDraw, (void **)&pDD) == S_OK) {
            SetDirectDraw(pDD);
            pDD->Release();
        } else {
            hr = InitDirectDraw();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\bytestrm.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// bytestrm.h : Declaration of the CByteStream

#ifndef __BYTESTRM_H_
#define __BYTESTRM_H_

class CByteSample;

/////////////////////////////////////////////////////////////////////////////
// CByteStream
class ATL_NO_VTABLE CByteStream :
        public CStream
{
public:

        //
        // METHODS
        //
	CByteStream();

        STDMETHODIMP SetState(
            /* [in] */ FILTER_STATE State
        );

        //
        // IPin
        //
        STDMETHODIMP BeginFlush();
        STDMETHODIMP EndOfStream(void);

        //
        // IMemInputPin
        //
        STDMETHODIMP Receive(IMediaSample *pSample);
        STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

        //
        // IMemAllocator
        //
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);

        //  Fill any samples waiting to be filled
        void FillSamples();

        //  Check if it's time to do the real EndOfStream
        void CheckEndOfStream();

protected:
        /*  Queue of samples */
        CDynamicArray<IMediaSample *, CComPtr<IMediaSample> >
                        m_arSamples;

        /*  Current sample/buffer */
        PBYTE           m_pbData;
        DWORD           m_cbData;
        DWORD           m_dwPosition;

        /*  Track time stamps */
        CTimeStamp      m_TimeStamp;

        /*  Byte rate for time stamp computation */
        LONG  m_lBytesPerSecond;

        /*  End Of Stream pending - it will be delivered when we've
            emptied the last sample off our list
        */
        bool            m_bEOSPending;
};

/////////////////////////////////////////////////////////////////////////////
// CByteStreamSample
class ATL_NO_VTABLE CByteStreamSample :
        public CSample
{
friend class CByteStream;
public:
        CByteStreamSample();

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }

        HRESULT Init(
            IMemoryData *pMemData
        );

        STDMETHODIMP GetInformation(
            /* [out] */ DWORD *pdwLength,
            /* [out] */ BYTE **ppbData,
            /* [out] */ DWORD *pcbActualData
        );

        //  Override to make sure samples get updated
        HRESULT InternalUpdate(
            DWORD dwFlags,
            HANDLE hEvent,
            PAPCFUNC pfnAPC,
            DWORD_PTR dwAPCData
        );


        //
        //  Methods forwarded from MediaSample object.
        //
        HRESULT MSCallback_GetPointer(BYTE ** ppBuffer) { *ppBuffer = m_pbData; return NOERROR; };
        LONG MSCallback_GetSize(void) { return m_cbSize; };
        LONG MSCallback_GetActualDataLength(void) { return m_cbData; };
        HRESULT MSCallback_SetActualDataLength(LONG lActual)
        {
            if ((DWORD)lActual <= m_cbSize) {
                m_cbData = lActual;
                return NOERROR;
            }
            return E_INVALIDARG;
        };

protected:
        PBYTE m_pbData;
        DWORD m_cbSize;
        DWORD m_cbData;
        CComPtr<IMemoryData> m_pMemData;
};

#endif // __BYTESTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\ddstrm.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// ddstrm.h : Declaration of the CDDStream

#ifndef __DDSTRM_H_
#define __DDSTRM_H_

#include "resource.h"       // main symbols

class CDDSample;
class CDDInternalSample;

/////////////////////////////////////////////////////////////////////////////
// CDDStream
class ATL_NO_VTABLE CDDStream :
	public CComCoClass<CDDStream, &CLSID_AMDirectDrawStream>,
        public CStream,
	public IDirectDrawMediaStream,
        public IDirectDrawMediaSampleAllocator  // This interface indicates that our mem
                                                // allocator supports direct draw surfaces
                                                // from the media samples.
{
friend CDDSample;
public:

        //
        // METHODS
        //
	CDDStream();

        //
        // IMediaStream
        //
        // HACK HACK - the first 2 are duplicates but it won't link
        // without
        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream)
        {
            return CStream::GetMultiMediaStream(ppMultiMediaStream);
        }

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType)
        {
            return CStream::GetInformation(pPurposeId, pType);
        }

        STDMETHODIMP SetSameFormat(IMediaStream *pStream, DWORD dwFlags);

        STDMETHODIMP AllocateSample(
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);

        STDMETHODIMP CreateSharedSample(
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);

        STDMETHODIMP SendEndOfStream(DWORD dwFlags)
        {
            return CStream::SendEndOfStream(dwFlags);
        }

        //
        //  IAMMediaStream
        //
        STDMETHODIMP Initialize(IUnknown *pSourceObject, DWORD dwFlags, REFMSPID PurposeId, const STREAM_TYPE StreamType);

        //
        // IDirectDrawMediaStream
        //
        STDMETHODIMP GetFormat(
            /* [optional][out] */ DDSURFACEDESC *pDDSDCurrent,
            /* [optional][out] */ IDirectDrawPalette **ppDirectDrawPalette,
            /* [optional][out] */ DDSURFACEDESC *pDDSDDesired,
            /* [optional][out] */ DWORD *pdwFlags);

        STDMETHODIMP SetFormat(
            /* [in] */ const DDSURFACEDESC *lpDDSurfaceDesc,
            /* [optional][in] */ IDirectDrawPalette *pDirectDrawPalette);

        STDMETHODIMP GetDirectDraw(                     // NOTE == Function also used by IDirectDrawMediaSampleAllocator
            /* [out] */ IDirectDraw **ppDirectDraw);

        STDMETHODIMP SetDirectDraw(
            /* [in] */ IDirectDraw *pDirectDraw);

        STDMETHODIMP CreateSample(
            /* [in] */ IDirectDrawSurface *pSurface,
            /* [optional][in] */ const RECT *pRect,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDirectDrawStreamSample **ppSample);


        STDMETHODIMP GetTimePerFrame(
                /* [out] */ STREAM_TIME *pFrameTime);

        //
        // IPin
        //
        STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);


        //
        // IMemInputPin
        //
        STDMETHODIMP Receive(IMediaSample *pSample);
        STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
        //
        // IMemAllocator
        //
        STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps);
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);
        STDMETHODIMP Decommit();

        //
        // Special CStream methods
        //
        HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);
        HRESULT CreateTempSample(CSample **ppSample);

protected:
        STDMETHODIMP GetFormatInternal(
            DDSURFACEDESC *pDDSDCurrent,
            IDirectDrawPalette **ppDirectDrawPalette,
            DDSURFACEDESC *pDDSDDesired,
            DWORD *pdwFlags);

        HRESULT InitDirectDraw(void);
        void InitSurfaceDesc(LPDDSURFACEDESC);
        HRESULT InternalSetFormat(const DDSURFACEDESC *lpDDSurfaceDesc, IDirectDrawPalette *pPalette, bool bFromPin, bool bQuery = false);
        HRESULT InternalAllocateSample(DWORD dwFlags,
                                       bool bIsInternalSample,
                                       IDirectDrawStreamSample **ppDDSample,
                                       bool bTemp = false);
        HRESULT InternalCreateSample(IDirectDrawSurface *pSurface, const RECT *pRect,
                                     DWORD dwFlags, bool bIsInternalSample,
                                     IDirectDrawStreamSample **ppSample,
                                     bool bTemp = false);
        HRESULT GetMyReadOnlySample(CDDSample *pBuddy, CDDSample **ppSample);
        HRESULT RenegotiateMediaType(const DDSURFACEDESC *lpDDSurfaceDesc, IDirectDrawPalette *pPalette, const AM_MEDIA_TYPE *pmt);
        HRESULT inline CDDStream::AllocDDSampleFromPool(
            const REFERENCE_TIME *rtStart,
            CDDSample **ppDDSample)
        {
            CSample *pSample;
            HRESULT hr = AllocSampleFromPool(rtStart, &pSample);
            *ppDDSample = (CDDSample *)pSample;
            return hr;
        }

        bool CreateInternalSample() const
        {
            return m_bSamplesAreReadOnly &&
                   m_StreamType==STREAMTYPE_READ;
        }

public:
DECLARE_REGISTRY_RESOURCEID(IDR_STREAM)

BEGIN_COM_MAP(CDDStream)
	COM_INTERFACE_ENTRY(IDirectDrawMediaStream)
	COM_INTERFACE_ENTRY(IDirectDrawMediaSampleAllocator)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

protected:
        //
        //  Member variables
        //
        CComPtr<IDirectDraw>            m_pDirectDraw;
        CComPtr<IDirectDrawPalette>     m_pDirectDrawPalette;
        DWORD                           m_dwForcedFormatFlags;
        long                            m_Height;
        long                            m_Width;
        DDPIXELFORMAT                   m_PixelFormat;
        const DDPIXELFORMAT             *m_pDefPixelFormat;
        long                            m_lLastPitch;

        CDDInternalSample               *m_pMyReadOnlySample;
};

#endif // __DDSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\medsampl.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "project.h"

CAMMediaTypeSample::CAMMediaTypeSample() :
    m_pDataPointer(NULL),
    m_lSize(0),
    m_lActualDataLength(0),
    m_bIAllocatedThisBuffer(false)
{};


HRESULT CAMMediaTypeSample::Initialize(CAMMediaTypeStream *pStream, long lSize, BYTE *pData)
{
    HRESULT hr = CSample::InitSample(pStream, false);
    if (SUCCEEDED(hr)) {
        hr = SetPointer(pData, lSize);
    }
    return hr;
}

CAMMediaTypeSample::~CAMMediaTypeSample()
{
    if (m_bIAllocatedThisBuffer) {
        CoTaskMemFree(m_pDataPointer);
    }
}

HRESULT CAMMediaTypeSample::CopyFrom(IMediaSample *pSrcMediaSample)
{
    AUTO_SAMPLE_LOCK;
    CSample::CopyFrom(pSrcMediaSample);
    BYTE * pBytes;
    HRESULT hr = pSrcMediaSample->GetPointer(&pBytes);
    if (SUCCEEDED(hr)) {
        LONG lCopySize = pSrcMediaSample->GetActualDataLength();
        if (lCopySize > m_lSize) {
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            lCopySize = m_lSize;
        }
        memcpy(m_pDataPointer, pBytes, lCopySize);
    }
    return hr;
}


STDMETHODIMP CAMMediaTypeSample::SetPointer(BYTE * pBuffer, LONG lSize)
{
    AUTO_SAMPLE_LOCK;
    HRESULT hr = S_OK;
    if (m_bIAllocatedThisBuffer) {
        CoTaskMemFree(m_pDataPointer);
        m_bIAllocatedThisBuffer = false;
    }
    m_lSize = lSize;
    if (pBuffer) {
        m_pDataPointer = pBuffer;
    } else {
        m_pDataPointer = (BYTE *)CoTaskMemAlloc(lSize);
        if (!m_pDataPointer) {
            hr = E_OUTOFMEMORY;
        } else {
            m_bIAllocatedThisBuffer = true;
        }
    }
    m_lActualDataLength = 0;
    return hr;
}



#define STDMETHOD_FORWARD0(fctn) STDMETHODIMP CAMMediaTypeSample::fctn(void) { return m_pMediaSample->fctn(); }
#define STDMETHOD_FORWARD1(fctn, t1) STDMETHODIMP CAMMediaTypeSample::fctn(t1 p1) { return m_pMediaSample->fctn(p1); }
#define STDMETHOD_FORWARD2(fctn, t1, t2) STDMETHODIMP CAMMediaTypeSample::fctn(t1 p1, t2 p2) { return m_pMediaSample->fctn(p1, p2); }
#define LONG_RET_VAL_FWD(fctn) STDMETHODIMP_(LONG) CAMMediaTypeSample::fctn(void) { return m_pMediaSample->fctn(); }

STDMETHOD_FORWARD1(GetPointer, BYTE **)
LONG_RET_VAL_FWD  (GetSize)
STDMETHOD_FORWARD2(GetTime, REFERENCE_TIME *, REFERENCE_TIME *)
STDMETHOD_FORWARD2(SetTime, REFERENCE_TIME *, REFERENCE_TIME *)
STDMETHOD_FORWARD0(IsSyncPoint)
STDMETHOD_FORWARD1(SetSyncPoint, BOOL)
STDMETHOD_FORWARD0(IsPreroll)
STDMETHOD_FORWARD1(SetPreroll, BOOL)
LONG_RET_VAL_FWD  (GetActualDataLength)
STDMETHOD_FORWARD1(SetActualDataLength, LONG)
STDMETHOD_FORWARD1(GetMediaType, AM_MEDIA_TYPE **)
STDMETHOD_FORWARD1(SetMediaType, AM_MEDIA_TYPE *)
STDMETHOD_FORWARD0(IsDiscontinuity)
STDMETHOD_FORWARD1(SetDiscontinuity, BOOL)
STDMETHOD_FORWARD2(GetMediaTime, LONGLONG *, LONGLONG *)
STDMETHOD_FORWARD2(SetMediaTime, LONGLONG *, LONGLONG *)

HRESULT CAMMediaTypeSample::MSCallback_GetPointer(BYTE **ppBuffer)
{
    *ppBuffer = m_pDataPointer;
    return S_OK;
}

LONG CAMMediaTypeSample::MSCallback_GetSize(void)
{
    return m_lSize;
}

LONG CAMMediaTypeSample::MSCallback_GetActualDataLength(void) {
    return m_lActualDataLength;
}

HRESULT CAMMediaTypeSample::MSCallback_SetActualDataLength(LONG lActual)
{
    if (lActual >= 0 && lActual <= m_lSize) {
        m_lActualDataLength = lActual;
        return S_OK;
    } else {
        return E_INVALIDARG;
    }
}

bool CAMMediaTypeSample::MSCallback_AllowSetMediaTypeOnMediaSample(void)
{
    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\medsampl.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef __MEDIA_STREAM_SAMPLE_H_
#define __MEDIA_STREAM_SAMPLE_H_

class ATL_NO_VTABLE CAMMediaTypeSample :
    public CSample,
    public IAMMediaTypeSample
{
public:
    CAMMediaTypeSample();
    virtual ~CAMMediaTypeSample();

    DECLARE_POLY_AGGREGATABLE(CAMMediaTypeSample);

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream)
        {
            return CSample::GetMediaStream(ppMediaStream);
        }

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime)
        {
            return CSample::GetSampleTimes(
                pStartTime,
                pEndTime,
                pCurrentTime
            );
        }

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime)
        {
            return CSample::SetSampleTimes(pStartTime, pEndTime);
        }

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData)
        {
            return CSample::Update(dwFlags, hEvent, pfnAPC, dwAPCData);
        }

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds)
        {
            return CSample::CompletionStatus(dwFlags, dwMilliseconds);
        }


    //
    //  Extensions to media sample interface.
    //
    STDMETHODIMP SetPointer(BYTE * pBuffer, LONG lSize);

    //
    //  Basic methods all forwarded to the media sample.
    //
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);
    STDMETHODIMP_(LONG) GetSize(void);
    STDMETHODIMP GetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);
    STDMETHODIMP IsDiscontinuity(void);
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);

    //
    //  Methods for this stream samples that will be called by CMediaSample.
    //
    HRESULT MSCallback_GetPointer(BYTE ** ppBuffer);
    LONG MSCallback_GetSize(void);
    LONG MSCallback_GetActualDataLength(void);
    HRESULT MSCallback_SetActualDataLength(LONG lActual);
    bool MSCallback_AllowSetMediaTypeOnMediaSample(void);

    //
    //  Internal functions
    //
    HRESULT Initialize(CAMMediaTypeStream *pStream, long lSize, BYTE *pData);
    HRESULT CopyFrom(IMediaSample *pSrcMediaSample);

BEGIN_COM_MAP(CAMMediaTypeSample)
	COM_INTERFACE_ENTRY(IAMMediaTypeSample)
        COM_INTERFACE_ENTRY_CHAIN(CSample)
END_COM_MAP()

public:
    BYTE *          m_pDataPointer;
    LONG            m_lSize;
    LONG            m_lActualDataLength;
    bool            m_bIAllocatedThisBuffer;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\mss.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// mss.cpp : Implementation of CAMMediaTypeStream
#include "stdafx.h"
#include "project.h"


/////////////////////////////////////////////////////////////////////////////
// CAMMediaTypeStream

CAMMediaTypeStream::CAMMediaTypeStream()
{
    InitMediaType(&m_MediaType);
    m_AllocatorProperties.cBuffers = 1;
    m_AllocatorProperties.cbBuffer = 0x1000;
    m_AllocatorProperties.cbAlign = 1;

    //  We don't require any prefix.  If there is a prefix we don't
    //  need to add it in GetPointer - it's hidden unless we want to
    //  access it.
    m_AllocatorProperties.cbPrefix = 0;
}



STDMETHODIMP CAMMediaTypeStream::AllocateSample(DWORD dwFlags, IStreamSample **ppSample)
{
    TRACEINTERFACE(_T("IDirectDrawStream::AllocateSample(0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, ppSample);
    HRESULT hr;
    if (!ppSample) {
        hr = E_POINTER;
    } else {
        *ppSample = NULL;
        if (dwFlags) {
            hr = E_INVALIDARG;
        } else {
            hr = CreateSample(m_AllocatorProperties.cbBuffer, NULL, 0, NULL,
                              (IAMMediaTypeSample **)ppSample);
        }
    }
    return hr;
}


STDMETHODIMP CAMMediaTypeStream::CreateSharedSample(IStreamSample *pExistingSample,
                                           DWORD dwFlags,
                                           IStreamSample **ppNewSample)
{
    return E_NOTIMPL;   // There really is no way to share data since the actual
                        // size of the data can not be transfered.
}

STDMETHODIMP CAMMediaTypeStream::SetSameFormat(IMediaStream *pStream, DWORD dwFlags)
{
    TRACEINTERFACE(_T("IAMMediaSampleStream::SetSameFormat(0x%8.8X, 0x%8.8X)\n"),
                   pStream, dwFlags);
    CComQIPtr<IAMMediaTypeStream, &IID_IAMMediaTypeStream> pSource(pStream);
    HRESULT hr;
    if (!pSource) {
        hr = MS_E_INCOMPATIBLE;
    } else {
        AM_MEDIA_TYPE MediaType;
        hr = pSource->GetFormat(&MediaType, 0);
        if (SUCCEEDED(hr)) {
            hr = SetFormat(&MediaType, 0);
            FreeMediaType(MediaType);
        }
    }
    return hr;
}



////////////////////////////////////

STDMETHODIMP CAMMediaTypeStream::GetFormat(AM_MEDIA_TYPE *pMediaType, DWORD dwFlags)
{
    AUTO_CRIT_LOCK;
    HRESULT hr = S_OK;

    if (m_pConnectedPin) {
        CopyMediaType(pMediaType, &m_MediaType);
    } else {
        hr = MS_E_NOSTREAM;
    }

    return hr;
}

STDMETHODIMP CAMMediaTypeStream::SetFormat(AM_MEDIA_TYPE *pMediaType, DWORD dwFlags)
{
    AUTO_CRIT_LOCK;
    HRESULT hr = S_OK;
    if (m_cAllocated) {
        if (!IsEqualMediaType(*pMediaType, m_MediaType)) {
            hr = MS_E_SAMPLEALLOC;
        }
    } else {
        FreeMediaType(m_MediaType);
        CopyMediaType(&m_MediaType, pMediaType);
    }
    return hr;
}

STDMETHODIMP CAMMediaTypeStream::CreateSample(long lSampleSize, BYTE * pbBuffer,
                                              DWORD dwFlags,
                                              IUnknown * pUnkOuter,
                                              IAMMediaTypeSample **ppSample)
{
    AUTO_CRIT_LOCK;
    HRESULT hr;
    if (!ppSample) {
        hr = E_POINTER;
    } else {
        *ppSample = NULL;
        CComPolyObject<CAMMediaTypeSample> * pATLSampleObject = new CComPolyObject<CAMMediaTypeSample>(pUnkOuter);
        if (!pATLSampleObject) {
            hr = E_OUTOFMEMORY;
        } else {
            CAMMediaTypeSample *pNewSample = &pATLSampleObject->m_contained;
            hr = pNewSample->Initialize(this, lSampleSize, pbBuffer);
            if (SUCCEEDED(hr)) {
                pNewSample->GetControllingUnknown()->QueryInterface(IID_IAMMediaTypeSample, (void **)ppSample);
            } else {
                delete pATLSampleObject;
            }
        }
    }
    return hr;
}

STDMETHODIMP CAMMediaTypeStream::GetStreamAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    return E_FAIL;
}


STDMETHODIMP CAMMediaTypeStream::SetStreamAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps)
{
    return E_FAIL;
}




//
//  IPin implementation
//

STDMETHODIMP CAMMediaTypeStream::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    // Check the type is accepted and then save the connected pin
    HRESULT hr = QueryAccept(pmt);
    if (FAILED(hr)) {
        return hr;
    }
    AUTO_CRIT_LOCK;
    m_pConnectedPin = pConnector;
    return hr;
}


STDMETHODIMP CAMMediaTypeStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    AUTO_CRIT_LOCK;
    return (IsEqualMediaType(*pmt, m_MediaType) ? S_OK : VFW_E_TYPE_NOT_ACCEPTED);
}


STDMETHODIMP CAMMediaTypeStream::Receive(IMediaSample *pMediaSample)
{
    if (m_bFlushing || m_bStopIfNoSamples && m_cAllocated == 0) {
        EndOfStream();
        return S_FALSE;
    }

    HRESULT hr = S_OK;
    //  Send quality message if clocked
    REFERENCE_TIME CurTime;
    if (S_OK == m_pFilter->GetCurrentStreamTime(&CurTime)) {
        REFERENCE_TIME rtStart, rtStop;
        if (m_pQC && SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = Famine;
            msg.Late = CurTime - rtStart;
            msg.TimeStamp = rtStart;

            //  Call Notify on our connected pin
            m_pQC->Notify(m_pBaseFilter, msg);
        }
    }
#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME rtStart, rtStop;
        if (SUCCEEDED(pMediaSample->GetTime(&rtStart, &rtStop))) {
            ATLTRACE(_T("AMSTREAM.DLL : Video sample received - start %dms, end %dms\n"),
                     (LONG)(rtStart / 10000), (LONG)(rtStop / 10000));
        }
    }
#endif
    if (m_bUsingMyAllocator) {
        CAMMediaTypeSample *pSrcSample = (CAMMediaTypeSample *)((CMediaSample *)pMediaSample)->m_pSample;
        pSrcSample->m_bReceived = true;
    } else {
        CAMMediaTypeSample *pDestSample;
        REFERENCE_TIME rtStart, rtEnd;
        pMediaSample->GetTime(&rtStart, &rtEnd);
        hr = AllocMTSampleFromPool(&rtStart, &pDestSample);
        Lock();
        // This is a media sample coming from a different allocator.
        // Because QueryAccept only accepts our type the format should
        // be compatible
        if (SUCCEEDED(hr)) {
            hr = pDestSample->SetCompletionStatus(pDestSample->CopyFrom(pMediaSample));
            // Warning!  The SetCompletionStatus may delete pDestSample.  Don't touch it after this point!
        }
        Unlock();
    }

#ifdef DEBUG
    if (bDbgTraceTimes) {
        REFERENCE_TIME CurTime;
        m_pFilter->GetCurrentStreamTime(&CurTime);
        ATLTRACE(_T("AMSTREAM.DLL : Got sample at %dms\n"),
                 (LONG)(CurTime / 10000));
    }
#endif
    return hr;
}



//
// IMemAllocator implementation
//

//
// IMemAllocator
//
STDMETHODIMP CAMMediaTypeStream::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr;

    AUTO_CRIT_LOCK;
    ZeroMemory(pActual, sizeof(*pActual));
    if (pRequest->cbAlign == 0) {
    	hr = VFW_E_BADALIGN;
    } else {
        if (m_bCommitted == TRUE) {
    	    hr = VFW_E_ALREADY_COMMITTED;
    	} else {

            m_AllocatorProperties = *pRequest;
            hr = GetProperties(pActual);
    	}
    }
    return hr;
}


STDMETHODIMP CAMMediaTypeStream::GetProperties(ALLOCATOR_PROPERTIES* pProps)
{
    AUTO_CRIT_LOCK;
    CopyMemory(pProps, &m_AllocatorProperties, sizeof(*pProps));
    return S_OK;
}





STDMETHODIMP CAMMediaTypeStream::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                                  REFERENCE_TIME * pEndTime, DWORD dwFlags)
{
    *ppBuffer = NULL;
    CAMMediaTypeSample *pSample;
    if (m_bStopIfNoSamples && m_cAllocated == 0) {
        return E_FAIL;
    }
#ifdef DEBUG
    if (bDbgTraceTimes) {
        ATLTRACE(_T("AMSTREAM.DLL : GetBuffer for %dms\n"),
                 pStartTime ? (LONG)(*pStartTime / 10000)  : 0);
    }
#endif
    HRESULT hr = AllocMTSampleFromPool(pStartTime, &pSample);
    if (SUCCEEDED(hr)) {
        pSample->m_bReceived = false;
        pSample->m_bModified = true;
        *ppBuffer = (IMediaSample *)(pSample->m_pMediaSample);
        (*ppBuffer)->AddRef();
    }
    return hr;
}


//
// Special CStream methods
//
HRESULT CAMMediaTypeStream::GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType)
{
    if (Index != 0) {
        return S_FALSE;
    }

    *ppMediaType = CreateMediaType(&m_MediaType);
    return (*ppMediaType) ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\project.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "strmif.h"
#include "vfwmsgs.h"
#include "Stream.h"
#include "ddstrm.h"
#include "Sample.h"
#include "ddsample.h"
#include "util.h"
#include "mtenum.h"
#include "amvideo.h"
#include "uuids.h"
#include "amutil.h"
#include "bytestrm.h"
#include "austrm.h"
#include "mss.h"
#include "medsampl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\mtenum.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.

#ifndef __MTENUM_H_INC__
#define __MTENUM_H_INC__

class ATL_NO_VTABLE CMediaTypeEnum : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumMediaTypes
{
public:
        // 
        // METHODS
        //
        CMediaTypeEnum();
        ~CMediaTypeEnum();

        DECLARE_GET_CONTROLLING_UNKNOWN()

        void Initialize(CStream *pStream, ULONG cCurPos);

        //
        // IEnumMediaTypes
        //
        STDMETHODIMP Next(ULONG cNumToFetch, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched);
        STDMETHODIMP Skip(ULONG cSkip);
        STDMETHODIMP Reset();
        STDMETHODIMP Clone(IEnumMediaTypes **ppEnumMediaTypes);

BEGIN_COM_MAP(CMediaTypeEnum)
        COM_INTERFACE_ENTRY(IEnumMediaTypes)
END_COM_MAP()

public:
        ULONG           m_cCurrentPos;
        CStream         *m_pStream;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\mtenum.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "project.h"


CMediaTypeEnum::CMediaTypeEnum() :
    m_cCurrentPos(0),
    m_pStream(NULL)
{
}

void CMediaTypeEnum::Initialize(CStream *pStream, ULONG cCurPos)
{
    m_pStream = pStream;
    m_pStream->GetControllingUnknown()->AddRef();
    m_cCurrentPos = cCurPos;
}

CMediaTypeEnum::~CMediaTypeEnum()
{
    m_pStream->GetControllingUnknown()->Release();
}


STDMETHODIMP CMediaTypeEnum::Next(ULONG cNumToFetch, AM_MEDIA_TYPE **ppMediaTypes, ULONG *pcFetched)
{
    if (pcFetched == NULL) {
        return E_POINTER;
    }
    HRESULT hr = S_OK;
    *pcFetched = 0;
    for (; cNumToFetch > 0; ) {
        if (S_OK == hr) {
            hr = m_pStream->GetMediaType(m_cCurrentPos, ppMediaTypes);
            if (S_OK != hr) {
                *ppMediaTypes = NULL;
            } else {
                m_cCurrentPos++;
                (*pcFetched)++;
            }
        }
        ppMediaTypes++;
        cNumToFetch--;
    }
    return hr;
}


STDMETHODIMP CMediaTypeEnum::Skip(ULONG cSkip)
{
    m_cCurrentPos += cSkip;
    return NOERROR;
}

STDMETHODIMP CMediaTypeEnum::Reset()
{
    m_cCurrentPos = 0;
    return NOERROR;
}

STDMETHODIMP CMediaTypeEnum::Clone(IEnumMediaTypes **ppEnumMediaTypes)
{
    HRESULT hr = S_OK;
    CMediaTypeEnum *pNewEnum = new CComObject<CMediaTypeEnum>; 
    if (pNewEnum == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
        pNewEnum->Initialize(m_pStream, m_cCurrentPos);
    }
    pNewEnum->GetControllingUnknown()->QueryInterface(IID_IEnumMediaTypes, (void **)ppEnumMediaTypes);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\pump.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Pump.cpp : Implementation of CStream
#include "stdafx.h"
#include "project.h"


DWORD WINAPI WritePumpThreadStart(void *pvPump)
{
    return ((CPump *)pvPump)->PumpMainLoop();
}


CPump::CPump(CStream *pStream) :
    m_pStream(pStream),
    m_hThread(NULL),
    m_hRunEvent(NULL),
    m_bShutDown(false)
    {}


CPump::~CPump()
{
    if (m_hThread) {
        m_CritSec.Lock();
        m_bShutDown = true;
        Run(true);
        m_CritSec.Unlock();
        WaitForSingleObject(m_hThread, INFINITE);
    }
    if (m_hRunEvent) {
        CloseHandle(m_hRunEvent);
    }
}



HRESULT CPump::CreatePump(CStream *pStream, CPump **ppPump)
{
    CPump *pPump = new CPump(pStream);
    if (pPump) {
        pPump->m_hRunEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (pPump->m_hRunEvent) {
            DWORD dwId;
            pPump->m_hThread = CreateThread(NULL, 0, WritePumpThreadStart, (void *)pPump, 0, &dwId);
            if (pPump->m_hThread) {
                *ppPump = pPump;
                return S_OK;
            }
        }
        delete pPump;
    }
    *ppPump = pPump;
    return E_OUTOFMEMORY;
}


void CPump::Run(bool bRunning)
{
    if (bRunning) {
        SetEvent(m_hRunEvent);
    } else {
        ResetEvent(m_hRunEvent);
    }
}

HRESULT CPump::PumpMainLoop()
{
    while (true) {
        WaitForSingleObject(m_hRunEvent, INFINITE);
        m_CritSec.Lock();
        bool bShutDown = m_bShutDown;
        m_CritSec.Unlock();
        if (bShutDown) {
            return 0;
        }
        IMediaSample *pMediaSample;
        HRESULT hr = m_pStream->GetBuffer(&pMediaSample, NULL, NULL, 0);
        if (SUCCEEDED(hr)) {
            LONG lChopSize = m_pStream->GetChopSize();
            HRESULT hrReceived = S_OK;
            if (lChopSize != 0) {
                //  Send data in smaller batches generating
                //  appropriate timestamps
                CMediaSample *pSample = (CMediaSample *)pMediaSample;
                PBYTE pbStart;
                pMediaSample->GetPointer(&pbStart);

                //  Make these const so we don't accidentally
                //  update them
                PBYTE pbCurrent = pbStart;
                const LONG lLength = pSample->GetActualDataLength();
                const LONG lSize = pSample->GetSize();
                const REFERENCE_TIME rtStart = pSample->m_rtStartTime;
                const REFERENCE_TIME rtStop = pSample->m_rtEndTime;
                LONG lLeft = lLength;
                while (lLeft != 0) {
                    LONG lToSend = min(lLeft, lChopSize);
                    pSample->SetActualDataLength(lToSend);
                    pSample->SetSizeAndPointer(pbCurrent, lToSend, lToSend);
                    pSample->m_rtEndTime =
                        pSample->m_rtStartTime +
                        MulDiv((LONG)(rtStop -
                                      pSample->m_rtStartTime),
                               lToSend,
                               lLeft);
                    hrReceived = m_pStream->m_pConnectedMemInputPin->Receive(pMediaSample);
                    if (S_OK != hrReceived) {
                        break;
                    }
                    pbCurrent += lToSend;
                    pSample->m_rtStartTime = pSample->m_rtEndTime;
                    lLeft -= lToSend;
                }

                //  Put everything back
                pSample->m_rtStartTime = rtStart;
                pSample->m_rtEndTime = rtStop;
                pSample->SetSizeAndPointer(pbStart, lLength, lSize);
            } else {
                hrReceived = m_pStream->m_pConnectedMemInputPin->Receive(pMediaSample);
            }
            CSample *pSample = ((CMediaSample *)pMediaSample)->m_pSample;
            pSample->m_bReceived = true;
            if (hrReceived != S_OK) {
                AtlTrace(_T("Receive returned %i.  Aborting I/O operation/n"), hrReceived);
                pSample->m_MediaSampleIoStatus = E_ABORT;
            }
            pMediaSample->Release();
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\sample.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef __SAMPLE_H_
#define __SAMPLE_H_

#include "resource.h"       // main symbols
#include "stream.h"


//
//  Samples don't use their own critical sections -- They always take the critical section of their
//  stream.  This avoids all sorts of deadlocks, and reduces the number of locks we take.  These
//  macros are helpers.
//
#define LOCK_SAMPLE m_pStream->Lock();
#define UNLOCK_SAMPLE m_pStream->Unlock();
#define AUTO_SAMPLE_LOCK  CAutoObjectLock lck(m_pStream);


class CSample;

class CMediaSample : public IMediaSample
{
public:
    CMediaSample(CSample *pSample);
    virtual ~CMediaSample();

    //
    //  IUnknown
    //
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // IMediaSample
    //
    STDMETHODIMP GetPointer(BYTE ** ppBuffer);
    STDMETHODIMP_(LONG) GetSize(void);
    STDMETHODIMP GetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME * pTimeStart, REFERENCE_TIME * pTimeEnd);
    STDMETHODIMP IsSyncPoint(void);
    STDMETHODIMP SetSyncPoint(BOOL bIsSyncPoint);
    STDMETHODIMP IsPreroll(void);
    STDMETHODIMP SetPreroll(BOOL bIsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength(void);
    STDMETHODIMP SetActualDataLength(LONG lActual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE **ppMediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *pMediaType);
    STDMETHODIMP IsDiscontinuity(void);
    STDMETHODIMP SetDiscontinuity(BOOL bDiscontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd);

    // Set the pointer
    HRESULT SetSizeAndPointer(PBYTE pbData, LONG lActual, LONG lSize);

public:
    CSample        *m_pSample;

    BOOL            m_bIsPreroll;
    DWORD           m_dwFlags;
    long            m_cRef;
    AM_MEDIA_TYPE  *m_pMediaType;

    /// Stream time
    REFERENCE_TIME  m_rtStartTime;
    REFERENCE_TIME  m_rtEndTime;
};





/////////////////////////////////////////////////////////////////////////////
// CSample
class ATL_NO_VTABLE CSample :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IStreamSample
{
public:
        //
        // METHODS
        //
        CSample();
        HRESULT InitSample(CStream *pStream, bool bIsInternalSample);
        virtual ~CSample();

        DECLARE_GET_CONTROLLING_UNKNOWN()

        //
        //  IStreamSample
        //
        STDMETHODIMP GetMediaStream(
            /* [in] */ IMediaStream **ppMediaStream);

        STDMETHODIMP GetSampleTimes(
            /* [optional][out] */ STREAM_TIME *pStartTime,
            /* [optional][out] */ STREAM_TIME *pEndTime,
            /* [optional][out] */ STREAM_TIME *pCurrentTime);

        STDMETHODIMP SetSampleTimes(
            /* [optional][in] */ const STREAM_TIME *pStartTime,
            /* [optional][in] */ const STREAM_TIME *pEndTime);

        STDMETHODIMP Update(
            /* [in] */           DWORD dwFlags,
            /* [optional][in] */ HANDLE hEvent,
            /* [optional][in] */ PAPCFUNC pfnAPC,
            /* [optional][in] */ DWORD_PTR dwAPCData);

        STDMETHODIMP CompletionStatus(
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ DWORD dwMilliseconds);


        //
        //  Forwarding functions for various Media Sample interfaces that can be
        //
        virtual HRESULT MSCallback_GetPointer(BYTE ** ppBuffer) = 0;
        virtual LONG MSCallback_GetSize(void) = 0;
        virtual LONG MSCallback_GetActualDataLength(void) = 0;
        virtual HRESULT MSCallback_SetActualDataLength(LONG lActual) = 0;
        virtual bool MSCallback_AllowSetMediaTypeOnMediaSample(void) {return false;}

        //
        // ATL class methods
        //
        void FinalRelease(void);

        //
        // Internal methods
        //
        virtual void FinalMediaSampleRelease(void);
        virtual HRESULT SetCompletionStatus(HRESULT hrCompletionStatus);
        void CopyFrom(CSample *pSrcSample);
        void CopyFrom(IMediaSample *pSrcMediaSample);
        virtual HRESULT InternalUpdate(
            DWORD dwFlags,
            HANDLE hEvent,
            PAPCFUNC pfnAPC,
            DWORD_PTR dwAPCData);

        //  Temp?
        bool IsTemp() { return m_bTemp; }

        //  Set the pointer?
        virtual HRESULT SetSizeAndPointer(PBYTE pbData, LONG lActual, LONG lSize)
        {
            return E_FAIL;
        }

BEGIN_COM_MAP(CSample)
        COM_INTERFACE_ENTRY(IStreamSample)
END_COM_MAP()

public:
        //
        //  MEMBER VARIABLES
        //
        CMediaSample *                  m_pMediaSample;
        bool                            m_bReceived;
        bool                            m_bWantAbort;
        bool                            m_bContinuous;
        bool                            m_bModified;
        bool                            m_bInternal;
        bool                            m_bTemp;
        bool                            m_bWaited;
        CStream                         *m_pStream;
        CSample                         *m_pNextFree;
        CSample                         *m_pPrevFree;
        HANDLE                          m_hUserHandle;
        PAPCFUNC                        m_UserAPC;
        DWORD_PTR                       m_dwUserAPCData;
        HRESULT                         m_Status;
        HRESULT                         m_MediaSampleIoStatus;
        HANDLE                          m_hCompletionEvent;

};




#endif //__SAMPLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\mss.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// MSS.h : Declaration of the CAMMediaTypeStream

#ifndef __MSS_H_
#define __MSS_H_

#include "resource.h"       // main symbols

class CAMMediaTypeSample;

/////////////////////////////////////////////////////////////////////////////
// CDDStream
class ATL_NO_VTABLE CAMMediaTypeStream :
	public CComCoClass<CAMMediaTypeStream, &CLSID_AMMediaTypeStream>,
        public CStream,
	public IAMMediaTypeStream
{
friend CAMMediaTypeSample;
public:

        //
        // METHODS
        //
	CAMMediaTypeStream();

        //
        // IMediaStream
        //
        // HACK HACK - the first 2 are duplicates but it won't link
        // without
        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream)
        {
            return CStream::GetMultiMediaStream(ppMultiMediaStream);
        }

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType)
        {
            return CStream::GetInformation(pPurposeId, pType);
        }

        STDMETHODIMP SetSameFormat(IMediaStream *pStream, DWORD dwFlags);

        STDMETHODIMP AllocateSample(
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppSample);

        STDMETHODIMP CreateSharedSample(
            /* [in] */ IStreamSample *pExistingSample,
            /* [in] */  DWORD dwFlags,
            /* [out] */ IStreamSample **ppNewSample);

        STDMETHODIMP SendEndOfStream(DWORD dwFlags)
        {
            return CStream::SendEndOfStream(dwFlags);
        }

        //
        //  IAMMediaTypeStream
        //
        STDMETHODIMP GetFormat(
            /* [out] */ AM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ DWORD dwFlags);

        STDMETHODIMP SetFormat(
            /* [in] */ AM_MEDIA_TYPE __RPC_FAR *pMediaType,
            /* [in] */ DWORD dwFlags);

        STDMETHODIMP CreateSample(
            /* [in] */ long lSampleSize,
            /* [optional][in] */ BYTE __RPC_FAR *pbBuffer,
            /* [in] */ DWORD dwFlags,
            /* [optional][in] */ IUnknown *pUnkOuter,
            /* [out] */ IAMMediaTypeSample __RPC_FAR *__RPC_FAR *ppAMMediaTypeSample);

        STDMETHODIMP GetStreamAllocatorRequirements(
            /* [out] */ ALLOCATOR_PROPERTIES __RPC_FAR *pProps);

        STDMETHODIMP SetStreamAllocatorRequirements(
            /* [in] */ ALLOCATOR_PROPERTIES __RPC_FAR *pProps);


        //
        // IPin
        //
        STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);

        //
        // IMemInputPin
        //
        STDMETHODIMP Receive(IMediaSample *pSample);
        //
        // IMemAllocator
        //
        STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps);
        STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME * pStartTime,
                               REFERENCE_TIME * pEndTime, DWORD dwFlags);

        //
        // Special CStream methods
        //
        HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType);

protected:
        HRESULT inline AllocMTSampleFromPool(const REFERENCE_TIME *rtStart, CAMMediaTypeSample **ppMTSample)
        {
            CSample *pSample;
            HRESULT hr = AllocSampleFromPool(rtStart, &pSample);
            *ppMTSample = (CAMMediaTypeSample *)pSample;
            return hr;
        }

public:
DECLARE_REGISTRY_RESOURCEID(IDR_MTSTREAM)

BEGIN_COM_MAP(CAMMediaTypeStream)
	COM_INTERFACE_ENTRY(IAMMediaTypeStream)
        COM_INTERFACE_ENTRY_CHAIN(CStream)
END_COM_MAP()

protected:
        AM_MEDIA_TYPE           m_MediaType;
        ALLOCATOR_PROPERTIES    m_AllocatorProperties;
};

#endif // __MSS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\sample.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Sample.cpp: implementation of the Sample class.
//
//////////////////////////////////////////////////////////////////////


/*
      Overview of handling of sample states
      -------------------------------------


      A sample can be in one of the following states:

      -- Application - Application owned - not updated
      -- Stream owned (in our queue)
      -- Owned by a filter for update

      The state can only change under the protection of the stream
      critical section.

      Stealing a sample occurs on WaitForCompletion with NOUPDATEOK or
      ABORT specified.

      Also, not that WaitForCompletion turns off continuous updates
      if and of the 3 flags are set.


	  Action

Owner            Update    GetBuffer    Receive      Release     Steal
			   completion                            sample
  ---------------------------------------------------------------------------
  Application    Note 3    Impossible   Impossible   Impossible  Application
  ---------------------------------------------------------------------------
  Stream         Invalid   Filter       Impossible   Impossible  Application
  ---------------------------------------------------------------------------
  Filter         Invalid   Impossible   Note 1       Note 2      Filter
  ---------------------------------------------------------------------------

  Notes:
      1.  New owner is
	      Stream for continuous update
	      Application otherwise

      2.  New owner is
	      Application if at end of stream or abort
	      Stream otherwise

      3.  If at end of stream status is MS_S_ENDOFSTREAM


*/

#include "stdafx.h"
#include "project.h"


CSample::CSample() :
    m_pStream(NULL),
    m_pMediaSample(NULL),
    m_hUserHandle(NULL),
    m_UserAPC(NULL),
    m_Status(S_OK),
    m_MediaSampleIoStatus(S_OK),
    m_pNextFree(NULL),
    m_pPrevFree(NULL),
    m_hCompletionEvent(NULL),
    m_bReceived(false),
    m_bTemp(false),
    m_bWaited(true)
{
}

HRESULT CSample::InitSample(CStream *pStream, bool bIsInternalSample)
{
    if (!m_pMediaSample) {
        m_pMediaSample = new CMediaSample(this);
        if (!m_pMediaSample) {
            return E_OUTOFMEMORY;
        }
    }
    m_pStream = pStream;
    m_bInternal = bIsInternalSample;
    if (!bIsInternalSample) {
	pStream->Lock();
	pStream->m_cAllocated++;
	pStream->Unlock();
	//
	//  Hold a strong reference to the stream and the multi media stream.
	//  The pMMStream can not change once we have incremented m_cAllocted on the stream, so we're sure that this
	//  addref and the final release of the multi-media stream won't change.
	//
	pStream->GetControllingUnknown()->AddRef();
        if (pStream->m_pMMStream) {
            pStream->m_pMMStream->AddRef();
        }
    }

    m_hCompletionEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    return m_hCompletionEvent ? S_OK : E_OUTOFMEMORY;
}

void CSample::FinalRelease(void)
{
    m_bWaited = true;
    CompletionStatus(COMPSTAT_WAIT | COMPSTAT_ABORT, INFINITE);
}

CSample::~CSample()
{
    CompletionStatus(COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT, 0);
    if (m_hCompletionEvent) {
	CloseHandle(m_hCompletionEvent);
    }
    if (!m_bInternal) {
	m_pStream->Lock();
        IMultiMediaStream *pMMStream = m_pStream->m_pMMStream;
	m_pStream->m_cAllocated--;
	m_pStream->Unlock();    // Unlock it before we release it!
        if (pMMStream) {
            pMMStream->Release();
            if (m_pStream->m_bStopIfNoSamples && m_pStream->m_cAllocated == 0) {
                if (m_pStream->m_pAllocator) {
                    m_pStream->m_pAllocator->Decommit();
                }
            }
        }
	m_pStream->GetControllingUnknown()->Release();
    }
    if (m_pMediaSample) {
        delete m_pMediaSample;
    }
}

//
// IStreamSample
//
STDMETHODIMP CSample::GetMediaStream(IMediaStream **ppMediaStream)
{
    TRACEINTERFACE(_T("IStreamSample::GetMediaStream(0x%8.8X)\n"),
                   ppMediaStream);
    *ppMediaStream = m_pStream;
    (*ppMediaStream)->AddRef();
    return S_OK;
}

STDMETHODIMP CSample::GetSampleTimes(STREAM_TIME *pStartTime, STREAM_TIME *pEndTime,
				     STREAM_TIME *pCurrentTime)
{
    TRACEINTERFACE(_T("IStreamSample::GetSampleTimes(0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   pStartTime, pEndTime, pCurrentTime);
    // Return media times using NewSegment data
    REFERENCE_TIME rtSegmentStart = m_pStream->m_rtSegmentStart;
    m_pMediaSample->GetTime(pStartTime, pEndTime);
    if (pStartTime) {
	*pStartTime += rtSegmentStart;
    }
    if (pEndTime) {
	*pEndTime += rtSegmentStart;
    }

    //  Get current stream time from the filter
    if (pCurrentTime) {
	m_pStream->m_pFilter->GetCurrentStreamTime(pCurrentTime);
    }
    return S_OK;
}

STDMETHODIMP CSample::SetSampleTimes(const STREAM_TIME *pStartTime, const STREAM_TIME *pEndTime)
{
    TRACEINTERFACE(_T("IStreamSample::SetSampleTimes(0x%8.8X, 0x%8.8X)\n"),
                   pStartTime, pEndTime);
    /*  Only settable for writable streams */
    if (m_pStream->m_StreamType != STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    /*  Since writable streams can't be seeked we don't need to
        compensate here for any seek offsets
    */
    return m_pMediaSample->SetTime((REFERENCE_TIME *)pStartTime, (REFERENCE_TIME *)pEndTime);
}

STDMETHODIMP CSample::Update(DWORD dwFlags, HANDLE hEvent, PAPCFUNC pfnAPC, DWORD_PTR dwAPCData)
{
    TRACEINTERFACE(_T("IStreamSample::Update(0x%8.8X, 0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, hEvent, pfnAPC, dwAPCData);
    LOCK_SAMPLE;
    HRESULT hr = InternalUpdate(dwFlags, hEvent, pfnAPC, dwAPCData);
    UNLOCK_SAMPLE;
    if (S_OK == hr) {
	hr = CompletionStatus(COMPSTAT_WAIT, INFINITE);
    }
    return hr;
}


void CSample::FinalMediaSampleRelease(void)
{
    if (m_bTemp) {
        GetControllingUnknown()->Release();
        return;
    }
    LOCK_SAMPLE;
    HRESULT hrStatus = m_MediaSampleIoStatus;
    if (hrStatus != S_OK) {
	m_MediaSampleIoStatus = S_OK;    // Reset this here so we don't need to reset it every time.
    } else {
	if (!m_bReceived) {
	    if (m_pStream->m_bEndOfStream) {
		hrStatus = MS_S_ENDOFSTREAM;
	    } else {
		if (m_bWantAbort) {
		    m_bWantAbort = false;
		    hrStatus = E_ABORT;
		} else {
		    // Upstream guy just allocated the sample and never used it! -- Keep it pending.
		    hrStatus = MS_S_PENDING;
		}
	    }
	}
    }
    UNLOCK_SAMPLE;
    SetCompletionStatus(hrStatus);
    // DANGER!  Sample may be dead right here
}



//
//  Set the sample's status and signal completion if necessary.
//
//  Note that when the application has been signalled by whatever method
//  the application can immediately turn around on another thread
//  and Release() the sample.  This is most likely when the completion
//  status is set from the quartz thread that's pushing the data.
//
//  Should we actually keep a reference count on the sample ourselves while
//  it's being updated?  Currently we don't.
//
HRESULT CSample::SetCompletionStatus(HRESULT hrStatus)
{
    LOCK_SAMPLE;
    _ASSERTE(m_Status == MS_S_PENDING);
    if (hrStatus == MS_S_PENDING || (hrStatus == S_OK && m_bContinuous)) {
	m_pStream->AddSampleToFreePool(this);
        UNLOCK_SAMPLE;
    } else {
	HANDLE handle = m_hUserHandle;
	PAPCFUNC pfnAPC = m_UserAPC;
	DWORD_PTR dwAPCData = m_dwUserAPCData;
	m_hUserHandle = m_UserAPC = NULL;
	m_dwUserAPCData = 0;
	m_Status = hrStatus;
        HANDLE hCompletionEvent = m_hCompletionEvent;
        UNLOCK_SAMPLE;

        //  DANGER DANGER - sample can go away here
	SetEvent(hCompletionEvent);
	if (pfnAPC) {
	    QueueUserAPC(pfnAPC, handle, dwAPCData);
            BOOL bClose = CloseHandle(handle);
            _ASSERTE(bClose);
	} else {
	    if (handle) {
		SetEvent(handle);
	    }
	}
    }
    return hrStatus;
}


STDMETHODIMP CSample::CompletionStatus(DWORD dwFlags, DWORD dwMilliseconds)
{
    TRACEINTERFACE(_T("IStreamSample::CompletionStatus(0x%8.8X, 0x%8.8X)\n"),
                   dwFlags, dwMilliseconds);
    LOCK_SAMPLE;
    HRESULT hr = m_Status;
    if (hr == MS_S_PENDING) {
	if (dwFlags & (COMPSTAT_NOUPDATEOK | COMPSTAT_ABORT) ||
	    (m_bContinuous && m_bModified && (dwFlags & COMPSTAT_WAIT))) {
	    m_bContinuous = false;
	    if (dwFlags & COMPSTAT_ABORT) {
		m_bWantAbort = true;    // Set this so we won't add it back to the free pool if released
	    }
	    if (m_pStream->StealSampleFromFreePool(this, dwFlags & COMPSTAT_ABORT)) {
		UNLOCK_SAMPLE;
		return SetCompletionStatus(m_bModified ? S_OK : MS_S_NOUPDATE);
	    } // If doesn't work then return MS_S_PENDING unless we're told to wait!
	}
	if (dwFlags & COMPSTAT_WAIT) {
	    m_bContinuous = false;  // Make sure it will complete!
	    UNLOCK_SAMPLE;
	    WaitForSingleObject(m_hCompletionEvent, dwMilliseconds);
	    LOCK_SAMPLE;
	    hr = m_Status;
	}
    }
    UNLOCK_SAMPLE;
    return hr;
}

HRESULT CSample::InternalUpdate(
    DWORD dwFlags,
    HANDLE hEvent,
    PAPCFUNC pfnAPC,
    DWORD_PTR dwAPCData
)
{
    if ((hEvent && pfnAPC) || (dwFlags & (~(SSUPDATE_ASYNC | SSUPDATE_CONTINUOUS)))) {
	return E_INVALIDARG;
    }
    if (m_Status == MS_S_PENDING) {
	return MS_E_BUSY;
    }
    if (NULL != m_pStream->m_pMMStream) {
        STREAM_STATE StreamState;
        m_pStream->m_pMMStream->GetState(&StreamState);
        if (StreamState != STREAMSTATE_RUN) {
    	return MS_E_NOTRUNNING;
        }
    }


    ResetEvent(m_hCompletionEvent);
    m_Status = MS_S_PENDING;
    m_bWantAbort = false;
    m_bModified = false;
    m_bContinuous = (dwFlags & SSUPDATE_CONTINUOUS) != 0;
    m_UserAPC = NULL;
    if (pfnAPC) {
        //
        //  Make a real handle
        //
	if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
		        GetCurrentProcess(), &m_hUserHandle,
		        0, TRUE, DUPLICATE_SAME_ACCESS))
        {
            DWORD dwErr = GetLastError();
            return HRESULT_FROM_WIN32(dwErr);
        }

        m_UserAPC = pfnAPC;
	m_dwUserAPCData = dwAPCData;
    } else {
	m_hUserHandle = hEvent;
	if (hEvent) {
	    ResetEvent(hEvent);
	}
    }

    //
    //  If we're at the end of the stream, wait until this point before punting it
    //  because we need to signal the event or fire the APC.
    //
    if (m_pStream->m_bEndOfStream) {
        //  Because this is called synchronously from Update the
        //  application must have a ref count on the sample until we
        //  return so we don't have to worry about it going away here
        return SetCompletionStatus(MS_S_ENDOFSTREAM);
    }

    SetCompletionStatus(MS_S_PENDING);   // This adds us to the free pool.
    if (hEvent || pfnAPC || (dwFlags & SSUPDATE_ASYNC)) {
	return MS_S_PENDING;
    } else {
	return S_OK;
    }
}

void CSample::CopyFrom(CSample *pSrcSample)
{
    m_bModified = true;
    m_pMediaSample->m_rtStartTime = pSrcSample->m_pMediaSample->m_rtStartTime;
    m_pMediaSample->m_rtEndTime = pSrcSample->m_pMediaSample->m_rtEndTime;
    m_pMediaSample->m_dwFlags = pSrcSample->m_pMediaSample->m_dwFlags;
    m_pMediaSample->m_bIsPreroll = pSrcSample->m_pMediaSample->m_bIsPreroll;
}


void CSample::CopyFrom(IMediaSample *pSrcMediaSample)
{
    m_bModified = true;
    pSrcMediaSample->GetTime(&m_pMediaSample->m_rtStartTime, &m_pMediaSample->m_rtEndTime);
    m_pMediaSample->m_dwFlags = (pSrcMediaSample->IsSyncPoint() == S_OK) ? 0 : AM_GBF_NOTASYNCPOINT;
    m_pMediaSample->m_dwFlags |= (pSrcMediaSample->IsDiscontinuity() == S_OK) ? AM_GBF_PREVFRAMESKIPPED : 0;
    m_pMediaSample->m_bIsPreroll = (pSrcMediaSample->IsPreroll() == S_OK);
}



/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Implementation of IMediaSample
//


CMediaSample::CMediaSample(CSample *pSample) :
    m_pSample(pSample),
    m_cRef(0),
    m_dwFlags(0),
    m_bIsPreroll(FALSE),
    m_pMediaType(NULL),
    m_rtStartTime(0),
    m_rtEndTime(0)
{
}

CMediaSample::~CMediaSample()
{
    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
    }
}



STDMETHODIMP CMediaSample::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid==IID_IUnknown || riid==IID_IMediaSample) {
	*ppv = (IMediaSample *)this;
	AddRef();
	return S_OK;
    }
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CMediaSample::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMediaSample::Release()
{
    long lRef = InterlockedDecrement(&m_cRef);
    if (lRef == 0) {
	m_pSample->FinalMediaSampleRelease();
    }
    return lRef;
}


STDMETHODIMP CMediaSample::GetPointer(BYTE ** ppBuffer)
{
    return m_pSample->MSCallback_GetPointer(ppBuffer);
}

STDMETHODIMP_(LONG) CMediaSample::GetSize(void)
{
    return m_pSample->MSCallback_GetSize();
}


STDMETHODIMP CMediaSample::GetTime(REFERENCE_TIME * pStartTime, REFERENCE_TIME * pEndTime)
{
    if (pStartTime) {
	*pStartTime = m_rtStartTime;
    }
    if (pEndTime) {
	*pEndTime = m_rtEndTime;
    }
    return S_OK;
}

STDMETHODIMP CMediaSample::SetTime(REFERENCE_TIME * pStartTime, REFERENCE_TIME * pEndTime)
{
    // Set stream time
    if (pStartTime) {
	m_rtStartTime = *pStartTime;
    }
    if (pEndTime) {
	m_rtEndTime = *pEndTime;
    }
    return S_OK;
}


STDMETHODIMP CMediaSample::IsSyncPoint(void)
{
    return ((m_dwFlags & AM_GBF_NOTASYNCPOINT) ? S_FALSE : S_OK);
}

STDMETHODIMP CMediaSample::SetSyncPoint(BOOL bIsSyncPoint)
{
    if (bIsSyncPoint) {
	m_dwFlags &= (~AM_GBF_NOTASYNCPOINT);
    } else {
	m_dwFlags |= AM_GBF_NOTASYNCPOINT;
    }
    return NOERROR;
}


STDMETHODIMP CMediaSample::IsPreroll(void)
{
    return (m_bIsPreroll ? S_OK : S_FALSE);
}

STDMETHODIMP CMediaSample::SetPreroll(BOOL bIsPreroll)
{
    m_bIsPreroll = bIsPreroll;
    return S_OK;
}

STDMETHODIMP_(LONG) CMediaSample::GetActualDataLength(void)
{
    return m_pSample->MSCallback_GetActualDataLength();
}

STDMETHODIMP CMediaSample::SetActualDataLength(LONG lActual)
{
    return m_pSample->MSCallback_SetActualDataLength(lActual);
}


STDMETHODIMP CMediaSample::GetMediaType(AM_MEDIA_TYPE **ppMediaType)
{
    if (m_pMediaType) {
	*ppMediaType = CreateMediaType(m_pMediaType);
        if (*ppMediaType) {
	    return NOERROR;
        } else {
            return E_OUTOFMEMORY;
        }
    } else {
	*ppMediaType = NULL;
	return S_FALSE;
    }
}


STDMETHODIMP CMediaSample::SetMediaType(AM_MEDIA_TYPE *pMediaType)
{
    if ((!m_pMediaType && !pMediaType) ||
        (m_pMediaType && pMediaType && IsEqualMediaType(*m_pMediaType, *pMediaType))) {
        return S_OK;
    }
    if (!m_pSample->MSCallback_AllowSetMediaTypeOnMediaSample()) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
    if (m_pMediaType) {
        DeleteMediaType(m_pMediaType);
    }
    m_pMediaType = NULL;
    if (pMediaType) {
        m_pMediaType = CreateMediaType(pMediaType);
        if (!m_pMediaType) {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}


STDMETHODIMP CMediaSample::IsDiscontinuity(void)
{
    return ((m_dwFlags & AM_GBF_PREVFRAMESKIPPED) ? S_OK : S_FALSE);
}

STDMETHODIMP CMediaSample::SetDiscontinuity(BOOL bDiscontinuity)
{
    if (bDiscontinuity) {
	m_dwFlags |= AM_GBF_PREVFRAMESKIPPED;
    } else {
	m_dwFlags &= (~AM_GBF_PREVFRAMESKIPPED);
    }
    return NOERROR;
}

STDMETHODIMP CMediaSample::GetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMediaSample::SetMediaTime(LONGLONG * pTimeStart, LONGLONG * pTimeEnd)
{
    return E_NOTIMPL;
}


HRESULT CMediaSample::SetSizeAndPointer(PBYTE pbData, LONG lActual, LONG lSize)
{
    return m_pSample->SetSizeAndPointer(pbData, lActual, lSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\stream.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Stream.cpp : Implementation of CStream
#include "stdafx.h"
#include "project.h"





/////////////////////////////////////////////////////////////////////////////
// CStream

CStream::CStream() :
    m_bCommitted(false),
    m_lRequestedBufferCount(0),
    m_bFlushing(false),
    m_rtWaiting(0),
    m_lWaiting(0),
    m_hWaitFreeSem(NULL),
    m_pFirstFree(NULL),
    m_pLastFree(NULL),
    m_cAllocated(0),
    m_bEndOfStream(false),
    m_FilterState(State_Stopped),
    m_pFilter(NULL),
    m_pFilterGraph(NULL),
    m_pMMStream(NULL),
    m_pWritePump(NULL),
    m_rtSegmentStart(0),
    m_bNoStall(false),
    m_bStopIfNoSamples(false)
{
    InitMediaType(&m_ConnectedMediaType);
    InitMediaType(&m_ActualMediaType);
    CHECKSAMPLELIST
}

#ifdef DEBUG
bool CStream::CheckSampleList()
{
    if (m_pFirstFree) {
        CSample *pSample = m_pFirstFree;
        if (pSample->m_pPrevFree != NULL) {
            return false;
        }
        while (pSample->m_pNextFree) {
            if (pSample->m_pNextFree->m_pPrevFree != pSample) {
                return false;
            }
            pSample = pSample->m_pNextFree;
        }
        if (pSample != m_pLastFree) {
            return false;
        }
    } else {
        if (m_pLastFree) {
            return false;
        }
    }
    return true;
}
#endif

HRESULT CStream::FinalConstruct(void)
{
    m_hWaitFreeSem = CreateSemaphore(NULL, 0, 0x7FFFFFF, NULL);
    return m_hWaitFreeSem ? S_OK : E_OUTOFMEMORY;
}


CStream::~CStream()
{
    SetState(State_Stopped);        // Make sure we're decommitted and pump is dead
    Disconnect();                   // Free any allocated media types and release held references
    if (m_hWaitFreeSem) {
        CloseHandle(m_hWaitFreeSem);
    }
}

STDMETHODIMP CStream::GetMultiMediaStream(IMultiMediaStream **ppMultiMediaStream)
{
    TRACEINTERFACE(_T("IMediaStream::GetMultiMediaStream(0x%8.8X)\n"),
                   ppMultiMediaStream);
    if (NULL == ppMultiMediaStream) {
	return E_POINTER;
    }

    if (m_pMMStream != NULL) {
    	m_pMMStream->AddRef();
    }

    *ppMultiMediaStream = m_pMMStream;
    return S_OK;
}

STDMETHODIMP CStream::GetInformation(MSPID *pPurposeId, STREAM_TYPE *pType)
{
    TRACEINTERFACE(_T("IMediaStream::GetInformation(0x%8.8X, 0x%8.8X)\n"),
                   pPurposeId, pType);
    if (pPurposeId) {
        *pPurposeId = m_PurposeId;
    }
    if (pType) {
        *pType = m_StreamType;
    }
    return S_OK;
}

STDMETHODIMP CStream::SendEndOfStream(DWORD dwFlags)
{
    TRACEINTERFACE(_T("IMediaStream::SendEndOfStream(0x%8.8X)\n"),
                   dwFlags);
    if (m_StreamType != STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    if (m_pConnectedPin) {
        return m_pConnectedPin->EndOfStream();
    }
    return S_OK;
}


STDMETHODIMP CStream::Initialize(IUnknown *pSourceObject, DWORD dwFlags,
    REFMSPID PurposeId, const STREAM_TYPE StreamType)
{
    TRACEINTERFACE(_T("IMediaStream::Initalize(0x%8.8X, 0x%8.8X, %s, %d)\n"),
                   pSourceObject, dwFlags, TextFromPurposeId(PurposeId), StreamType);
    HRESULT hr = NOERROR;

    if (dwFlags & ~(AMMSF_CREATEPEER | AMMSF_STOPIFNOSAMPLES)) {
        return E_INVALIDARG;
    }
    m_PurposeId = PurposeId;
    m_StreamType = StreamType;
    m_Direction = (StreamType == STREAMTYPE_WRITE) ? PINDIR_OUTPUT : PINDIR_INPUT;
    if (dwFlags & AMMSF_CREATEPEER) {
        if (!pSourceObject) {
            hr = E_INVALIDARG;
        } else {
            CComQIPtr<IMediaStream, &IID_IMediaStream> pMediaStream(pSourceObject);
            if (!pSourceObject) {
                hr = E_INVALIDARG;
            } else {
                hr = SetSameFormat(pMediaStream, 0);
            }
        }
    }
    m_bStopIfNoSamples = dwFlags & AMMSF_STOPIFNOSAMPLES ? true : false;
    return hr;
}

STDMETHODIMP CStream::SetState(FILTER_STATE State)
{
    TRACEINTERFACE(_T("IMediaStream::SetState(%d)\n"),
                   State);
    Lock();
    if (m_pConnectedPin == NULL) {
        Unlock();
        if (State == STREAMSTATE_RUN) {
            EndOfStream();
        }
    } else {
        _ASSERTE(m_pAllocator != NULL);
        FILTER_STATE prevState = m_FilterState;
        m_FilterState = State;
        if (State == State_Stopped) {
            m_pAllocator->Decommit();
            if (!m_bUsingMyAllocator) {
                Decommit();
            }
            CPump *pPump = m_pWritePump;
            m_pWritePump = NULL;
            Unlock();
            delete pPump;
        }  else {
            m_pAllocator->Commit();
            if (!m_bUsingMyAllocator) {
                Commit();
            }
            if( State_Stopped == prevState )
            {   
                // need this in the case of a seek while stopped, since BeginFlush
                // may not be called to reset this flag         
                m_bEndOfStream = false;
            }                
            Unlock();
        }
    }
    return S_OK;
}

STDMETHODIMP CStream::JoinAMMultiMediaStream(IAMMultiMediaStream *pAMMultiMediaStream)
{
    _ASSERTE(pAMMultiMediaStream == NULL || m_pMMStream == NULL);
    AUTO_CRIT_LOCK;
    HRESULT hr;
    if (m_cAllocated) {
        hr = MS_E_SAMPLEALLOC;
    } else {
        m_pMMStream = pAMMultiMediaStream;
    }
    return S_OK;
}

STDMETHODIMP CStream::JoinFilter(IMediaStreamFilter *pMediaStreamFilter)
{
    _ASSERTE(pMediaStreamFilter == NULL || m_pFilter == NULL);
    m_pFilter = pMediaStreamFilter;
    pMediaStreamFilter->QueryInterface(IID_IBaseFilter, (void **)&m_pBaseFilter);
    m_pBaseFilter->Release();
    return S_OK;
}

STDMETHODIMP CStream::JoinFilterGraph(IFilterGraph *pFilterGraph)
{
    _ASSERTE(pFilterGraph == NULL || m_pFilterGraph == NULL);
    m_pFilterGraph = pFilterGraph;
    return S_OK;
}



//
//  IPin Implementation
//

STDMETHODIMP CStream::Disconnect()
{
    m_pConnectedPin = NULL;
    m_pConnectedMemInputPin.Release();  // Magically sets to NULL here
    m_pQC.Release();
    m_pAllocator = NULL;
    m_lRequestedBufferCount = 0;
    FreeMediaType(m_ConnectedMediaType);
    FreeMediaType(m_ActualMediaType);
    return S_OK;
}

STDMETHODIMP CStream::ConnectedTo(IPin **pPin)
{
    *pPin = m_pConnectedPin;
    if (*pPin) {
        (*pPin)->AddRef();
        return S_OK;
    } else {
        return VFW_E_NOT_CONNECTED;
    }
}

STDMETHODIMP CStream::ConnectionMediaType(AM_MEDIA_TYPE *pmt)
{
    if (m_pConnectedPin) {
        CopyMediaType(pmt, &m_ConnectedMediaType);
        return S_OK;
    } else {
        ZeroMemory(pmt, sizeof(*pmt));
        pmt->lSampleSize = 1;
        pmt->bFixedSizeSamples = TRUE;
        return VFW_E_NOT_CONNECTED;
    }
}



void CStream::GetName(LPWSTR pszBuf)
{
    if (m_PurposeId == GUID_NULL) {
        pszBuf[0] = 0;
    } else {
        pszBuf[0] = (m_Direction == PINDIR_INPUT) ? (WCHAR)'I' : (WCHAR)'O';
        WStringFromGUID(&m_PurposeId, &pszBuf[1]);
    }
}


STDMETHODIMP CStream::QueryPinInfo(PIN_INFO * pInfo)
{
    pInfo->dir = m_Direction;
    GetName(pInfo->achName);
    return m_pFilter->QueryInterface(IID_IBaseFilter, (void **)&pInfo->pFilter);
}

STDMETHODIMP CStream::QueryDirection(PIN_DIRECTION * pPinDir)
{
    *pPinDir = m_Direction;
    return S_OK;
}


STDMETHODIMP CStream::QueryId(LPWSTR * Id)
{
    *Id = (LPWSTR)CoTaskMemAlloc(128 * sizeof(WCHAR));
    if (*Id) {
        GetName(*Id);
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}


//
//  Derived classes must override this method
//
STDMETHODIMP CStream::QueryAccept(const AM_MEDIA_TYPE *pmt)
{
    return E_NOTIMPL;
};


STDMETHODIMP CStream::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    //
    //  Returning E_NOTIMPL tells the filter graph manager that all input pins are connected to
    //  all output pins.
    //
    return E_NOTIMPL;
};


STDMETHODIMP CStream::EndOfStream(void)
{
    HRESULT hr = S_OK;
    Lock();
    if (m_bFlushing || m_bEndOfStream) {
        hr = E_FAIL;
    } else {
        m_bEndOfStream = true;
        CSample *pSample = m_pFirstFree;
        m_pFirstFree = m_pLastFree = NULL;              // Out of paranoia, clear these pointers first
        while (pSample) {
            CSample *pNext = pSample->m_pNextFree;
            pSample->SetCompletionStatus(MS_S_ENDOFSTREAM);  // WARNING!  This sample may go away!!!
            pSample = pNext;
        }
        CHECKSAMPLELIST
    }
    if (S_OK == hr) {
        m_pFilter->EndOfStream();
    }
    Unlock();

    return hr;
}


STDMETHODIMP CStream::BeginFlush(void)
{
    HRESULT hr = S_OK;
    Lock();
    const BOOL bCancelEOS = m_bEndOfStream;
    if (m_bFlushing) {
        hr = S_FALSE;
    } else {
        m_bFlushing = true;
        m_bEndOfStream = false;
        Decommit();     // Force everyone to unblock
    }
    if (S_OK == hr) {
        m_pFilter->Flush(bCancelEOS);
    }
    Unlock();

    return hr;
}

STDMETHODIMP CStream::EndFlush(void)
{
    AUTO_CRIT_LOCK;
    m_bFlushing = false;
    _ASSERTE(!m_bEndOfStream);
    Commit();   // Let getbuffer work again
    return S_OK;
}

STDMETHODIMP CStream::NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate)
{
    Lock();
    m_rtSegmentStart = tStart;
    m_bEndOfStream = false;
    Unlock();
    return S_OK;
}

//
// IMemInputPin
//
STDMETHODIMP CStream::GetAllocator(IMemAllocator ** ppAllocator)
{
    return GetControllingUnknown()->QueryInterface(IID_IMemAllocator, (void **)ppAllocator);
}

STDMETHODIMP CStream::NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly)
{
    m_bUsingMyAllocator = IsSameObject(pAllocator, GetControllingUnknown());
    m_bSamplesAreReadOnly = bReadOnly ? true : false;
    HRESULT hr = S_OK;
    if (!m_bUsingMyAllocator) {
        //  Transfer the properties across
        ALLOCATOR_PROPERTIES Props;
        hr = pAllocator->GetProperties(&Props);
        if (FAILED(hr)) {
            return hr;
        }
        ALLOCATOR_PROPERTIES PropsActual;
        hr = SetProperties(&Props, &PropsActual);
    }
    m_pAllocator = pAllocator;
    return hr;
}


STDMETHODIMP CStream::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    // Return E_NOTIMPL to indicate that we don't have any requirement and will not accept someone
    // elses allocator.
    return E_NOTIMPL;
}


STDMETHODIMP CStream::ReceiveMultiple(IMediaSample **pSamples, long nSamples, long *nSamplesProcessed)
{
    HRESULT hr = S_OK;
    *nSamplesProcessed = 0;
    while (nSamples-- > 0) {
        hr = Receive(pSamples[*nSamplesProcessed]);
        if (hr != S_OK) {
            break;
        }
        (*nSamplesProcessed)++;
    }
    return hr;
}

STDMETHODIMP CStream::ReceiveCanBlock()
{
    return S_OK;    // Pin can block if not using our allocator or using read-only samples
}



//
//  This method assumes the critical section is taken.
//
HRESULT CStream::ConnectThisMediaType(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = pReceivePin->ReceiveConnection(this, pmt);
    if (SUCCEEDED(hr)) {
        m_pConnectedMemInputPin = pReceivePin;  // Does a magic QI here!
        if (!m_pConnectedMemInputPin) {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        } else {
            hr = ReceiveConnection(pReceivePin, pmt);
            if (SUCCEEDED(hr)) {
                hr = m_pConnectedMemInputPin->NotifyAllocator(this, TRUE);
            }
            if (SUCCEEDED(hr)) {
                CopyMediaType(&m_ConnectedMediaType, pmt);
            }
            if (SUCCEEDED(hr)) {
                m_pAllocator = this;
                m_bUsingMyAllocator = true;
            } else {
                Disconnect();
            }
        }
    }
    return hr;
}

STDMETHODIMP CStream::Connect(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;
    AUTO_CRIT_LOCK;

    if (pmt) {
        hr = ConnectThisMediaType(pReceivePin, pmt);
    } else {
        AM_MEDIA_TYPE *pCurMediaType;
        hr = GetMediaType(0, &pCurMediaType);
        if (SUCCEEDED(hr)) {
            hr = ConnectThisMediaType(pReceivePin, pCurMediaType);
            DeleteMediaType(pCurMediaType);
        }
    }
    return hr;
}



STDMETHODIMP CStream::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    HRESULT hr = S_OK;
    CMediaTypeEnum *pNewEnum = new CComObject<CMediaTypeEnum>;
    if (pNewEnum == NULL) {
	hr = E_OUTOFMEMORY;
    } else {
        pNewEnum->Initialize(this, 0);
    }
    pNewEnum->GetControllingUnknown()->QueryInterface(IID_IEnumMediaTypes, (void **)ppEnum);
    return hr;
}


STDMETHODIMP CStream::Commit()
{
    AUTO_CRIT_LOCK;
    if (!m_bCommitted) {
        if (m_StreamType == STREAMTYPE_WRITE) {
            if (!m_pWritePump) {
                HRESULT hr = CPump::CreatePump(this, &m_pWritePump);
                if (hr != S_OK) {
                    return hr;
                }
            }
            m_pWritePump->Run(true);
        }
        //
        //  Interesting thing to note here -- Even if we have not been initialized we will still
        //  work correctly on commit.  We will simply set the requested buffer count to 1.
        //
        if (m_lRequestedBufferCount == 0) {
            m_lRequestedBufferCount = 1;
        }
        m_bCommitted = true;
    }
    return S_OK;
}



STDMETHODIMP CStream::Decommit()
{
    HRESULT hr = S_OK;

    AUTO_CRIT_LOCK;
    if (m_bCommitted) {     // If we're already decommitted then just return S_OK.
        m_bCommitted = false;
        if (m_lWaiting > 0) {
            ReleaseSemaphore(m_hWaitFreeSem, m_lWaiting, 0);
            m_lWaiting = 0;
        }
        if (m_pWritePump) {
            m_pWritePump->Run(false);
        }
    }
    return hr;
}


//
//  This method is not supported and never will be!
//
STDMETHODIMP CStream::ReleaseBuffer(IMediaSample *pBuffer)
{
    return E_UNEXPECTED;
};


//
//  The caller holds the reference to the sample after this point.
//
HRESULT CStream::AllocSampleFromPool(
    const REFERENCE_TIME *pStartTime,
    CSample **ppSample
)
{
    CSample *pSample = NULL;
    HRESULT hr = NOERROR;
    bool bWaited = false;
    bool bCreatedTemp = false;

    do {
        LONGLONG llLate = 0;
    	Lock();
        // Check we are committed -- This can happen after we've blocked and then
    	// wake back up due to a decommit.
        if (!m_bCommitted) {
    	    hr = VFW_E_NOT_COMMITTED;
    	    break;
        }
        if (pStartTime) {
            REFERENCE_TIME CurTime;
            if (m_pFilter->GetCurrentStreamTime(&CurTime) == S_OK) {
                llLate = CurTime - *pStartTime;

                /*  Block if more than a millisecond early */
                if (-llLate >= 10000) {
                    m_rtWaiting = *pStartTime;
                    Unlock();
                    m_pFilter->WaitUntil(*pStartTime);
                    Lock();
                    m_rtWaiting = 0;
                    if (!m_bCommitted) {
    	                hr = VFW_E_NOT_COMMITTED;
    	                break;
                    }
                }
            }
        }
        pSample = m_pFirstFree;
        if (bWaited && pSample == NULL) {
            _ASSERTE(m_bNoStall);
            if (!m_bUsingMyAllocator) {
                hr = HRESULT_FROM_WIN32(ERROR_SEM_TIMEOUT);
                break;
            } else {
                //  Try to make one
                CreateTempSample(&pSample);
                if (pSample) {
                    bCreatedTemp = true;
                }
                //  pSample->SetCompletionStatus(MS_S_PENDING);
            }
        }
        if (pSample == NULL) {
            m_lWaiting++;
            Unlock();

            //  Only wait for half a second if non-blocking
            DWORD dwWait = INFINITE;
            if (m_bNoStall) {
                const LONGLONG llLateMs = llLate / 10000;
                const DWORD dwMaxLateMs = 100;
                if (llLateMs > dwMaxLateMs) {
                    dwWait = 0;
                } else {
                    // llLateMs could be negative which means we waited
                    // just above
                    if (llLateMs > 0) {
                        dwWait = dwMaxLateMs - (DWORD)llLateMs;
                    } else {
                        dwWait = dwMaxLateMs;
                    }
                }
            }
            bWaited = WAIT_TIMEOUT == WaitForSingleObject(
                                          m_hWaitFreeSem,
                                          dwWait) ?
                      true : false;
        } else if (!bCreatedTemp) {
            m_pFirstFree = pSample->m_pNextFree;
            if (m_pFirstFree) {
                m_pFirstFree->m_pPrevFree = NULL;
            } else {
                m_pLastFree = NULL;
            }
            pSample->m_pNextFree = NULL;	// Just to be tidy.  We know that m_pPrevFree is null!
            _ASSERTE(pSample->m_Status == MS_S_PENDING);
            CHECKSAMPLELIST
        }
    } while (pSample == NULL);
    Unlock();
    if (pSample) {
        pSample->m_bWaited = pStartTime != 0 ? true : false;
    }
    *ppSample = pSample;
    return hr;
}


void CStream::AddSampleToFreePool(CSample *pSample)
{
    Lock();
    _ASSERTE(pSample->m_pPrevFree == NULL && pSample->m_pNextFree == NULL);
    if (m_pFirstFree) {
        pSample->m_pPrevFree = m_pLastFree;
        m_pLastFree->m_pNextFree = pSample;
    } else {
        pSample->m_pPrevFree = NULL;
        m_pFirstFree = pSample;
    }
    pSample->m_pNextFree = NULL;    // We know that the prev ptr is already null
    m_pLastFree = pSample;
    CHECKSAMPLELIST
    if (m_lWaiting > 0) {
        ReleaseSemaphore(m_hWaitFreeSem, 1, 0);
    	m_lWaiting--;
    }
    Unlock();
}


//
//  The caller holds the reference to the sample after this point!
//
bool CStream::StealSampleFromFreePool(CSample *pSample, BOOL bAbort)
{
    bool bWorked = false;
    Lock();
    if (m_pFirstFree) {
        if (m_pFirstFree == pSample) {
            // We'll only steal the first sample if there's nobody waiting for it right now.
            bool bTakeFirstFree = true;
            if (!bAbort && m_bCommitted) {
                REFERENCE_TIME CurTime;
                if (m_rtWaiting && m_pFilter->GetCurrentStreamTime(&CurTime) == S_OK) {
                    bTakeFirstFree = m_rtWaiting > CurTime;
                }
            }
            if (bTakeFirstFree) {
                m_pFirstFree = pSample->m_pNextFree;
                if (m_pFirstFree) {
                    m_pFirstFree->m_pPrevFree = NULL;
                } else {
                    m_pLastFree = NULL;
                }
                pSample->m_pNextFree = NULL;    // We know the prev ptr is already null!
                _ASSERTE(pSample->m_pPrevFree == NULL);
                bWorked = true;
            }
        } else {
            if (pSample->m_pPrevFree) {
                pSample->m_pPrevFree->m_pNextFree = pSample->m_pNextFree;
                if (pSample->m_pNextFree) {
                    pSample->m_pNextFree->m_pPrevFree = pSample->m_pPrevFree;
                } else {
                    m_pLastFree = pSample->m_pPrevFree;
                }
                pSample->m_pNextFree = pSample->m_pPrevFree = NULL;
                bWorked = true;
            }
        }
        CHECKSAMPLELIST
    }
    Unlock();
    return bWorked;
}


HRESULT CStream::CheckReceiveConnectionPin(IPin * pPin)
{
    HRESULT hr;
    if (!pPin) {
        hr = E_POINTER;
    } else {
        if (m_pConnectedPin != NULL) {
            hr = VFW_E_ALREADY_CONNECTED;
        } else {
            PIN_INFO pinfo;
            hr = pPin->QueryPinInfo(&pinfo);
            if (hr == NOERROR) {
                pinfo.pFilter->Release();
                if (pinfo.dir == m_Direction) {
                    hr = VFW_E_INVALID_DIRECTION;
                }
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\amguids.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#ifndef _AMGUIDS_H_
#define _AMGUIDS_H_
DEFINE_GUID( CLSID_MediaStreamFilter, /* 49c47ce0-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce0,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
#if 0
DEFINE_GUID( , /* 49c47ce6-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce6,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ce7-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce7,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ce8-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce8,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ce9-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ce9,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cea-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cea,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ceb-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ceb,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cec-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cec,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47ced-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47ced,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cee-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cee,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cef-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cef,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf0-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf0,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf1-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf1,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf2-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf2,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf3-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf3,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf4-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf4,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf5-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf5,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf6-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf6,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf7-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf7,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf8-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf8,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cf9-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cf9,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfa-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfa,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfb-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfb,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfc-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfc,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfd-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfd,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cfe-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cfe,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47cff-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47cff,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d00-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d00,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d01-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d01,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d02-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d02,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d03-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d03,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d04-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d04,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d05-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d05,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d06-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d06,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d07-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d07,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d08-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d08,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d09-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d09,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d0f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d0f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d10-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d10,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d11-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d11,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d12-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d12,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d13-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d13,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d14-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d14,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d15-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d15,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d16-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d16,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d17-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d17,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d18-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d18,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d19-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d19,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d1f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d1f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d20-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d20,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d21-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d21,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d22-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d22,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d23-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d23,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d24-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d24,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d25-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d25,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d26-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d26,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d27-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d27,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d28-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d28,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d29-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d29,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d2f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d2f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d30-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d30,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d31-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d31,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d32-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d32,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d33-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d33,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d34-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d34,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d35-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d35,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d36-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d36,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d37-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d37,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d38-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d38,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d39-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d39,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d3f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d3f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d40-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d40,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d41-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d41,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d42-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d42,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d43-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d43,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d44-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d44,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d45-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d45,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d46-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d46,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d47-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d47,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d48-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d48,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d49-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d49,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d4f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d4f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d50-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d50,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d51-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d51,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d52-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d52,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d53-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d53,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d54-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d54,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d55-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d55,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d56-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d56,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d57-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d57,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d58-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d58,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d59-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d59,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d5f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d5f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d60-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d60,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d61-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d61,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d62-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d62,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d63-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d63,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d64-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d64,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d65-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d65,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d66-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d66,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d67-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d67,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d68-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d68,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d69-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d69,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d6f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d6f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d70-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d70,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d71-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d71,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d72-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d72,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d73-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d73,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d74-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d74,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d75-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d75,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d76-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d76,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d77-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d77,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d78-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d78,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d79-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d79,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d7f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d7f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d80-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d80,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d81-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d81,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d82-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d82,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d83-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d83,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d84-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d84,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d85-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d85,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d86-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d86,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d87-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d87,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d88-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d88,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d89-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d89,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d8f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d8f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d90-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d90,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d91-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d91,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d92-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d92,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d93-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d93,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d94-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d94,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d95-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d95,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d96-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d96,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d97-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d97,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d98-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d98,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d99-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d99,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9a-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9a,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9b-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9b,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9c-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9c,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9d-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9d,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9e-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9e,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47d9f-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47d9f,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da0-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da0,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da1-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da1,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da2-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da2,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da3-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da3,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da4-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da4,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da5-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da5,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da6-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da6,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
DEFINE_GUID( , /* 49c47da7-9ba4-11d0-8212-00c04fc32c45 */
    0x49c47da7,
    0x9ba4,
    0x11d0,
    0x82, 0x12, 0x00, 0xc0, 0x4f, 0xc3, 0x2c, 0x45
  );
 #endif

#endif // _AMGUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\util.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef __UTIL_H_INC__
#define __UTIL_H_INC__

bool IsSameObject(IUnknown *pUnk1, IUnknown *pUnk2);

STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf);

#ifdef UNICODE
#define WStringFromGUID TStringFromGUID
#else
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf);
#endif

void InitMediaType(AM_MEDIA_TYPE *pmt);
void DeleteMediaType(AM_MEDIA_TYPE *pmt);
bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2);
void CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
AM_MEDIA_TYPE * CreateMediaType(AM_MEDIA_TYPE *pSrc);
void FreeMediaType(AM_MEDIA_TYPE& mt);


AM_MEDIA_TYPE * WINAPI AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource);
HRESULT ConvertMediaTypeToSurfaceDesc(const AM_MEDIA_TYPE *pmt,
                                      IDirectDraw *pDD,
                                      IDirectDrawPalette **ppPalette,
                                      LPDDSURFACEDESC pSurfaceDesc);

HRESULT ConvertSurfaceDescToMediaType(
    const DDSURFACEDESC *pSurfaceDesc, IDirectDrawPalette *pPalette, const RECT *pRect,
    BOOL bInvertSize, AM_MEDIA_TYPE **ppMediaType,
    AM_MEDIA_TYPE *pmtTemplate = 0 // preserve any type information
    );

const DDPIXELFORMAT * GetDefaultPixelFormatPtr(IDirectDraw *pDirectDraw);
bool VideoSubtypeFromPixelFormat(const DDPIXELFORMAT *pPixelFormat, GUID *pSubType);
bool IsSupportedType(const DDPIXELFORMAT *pPixelFormat);
bool ComparePixelFormats(const DDPIXELFORMAT *pFormat1,
                         const DDPIXELFORMAT *pFormat2);

/*  Class to track timestamps for fixed bitrate data */
class CTimeStamp
{
public:
    CTimeStamp()
    {
        Reset();
    }

    void Reset()
    {
        m_lBytesSinceTimeStamp = 0;
        m_rt = 0;
    }

    void SetTime(REFERENCE_TIME rt)
    {
        m_rt = rt;
        m_lBytesSinceTimeStamp = 0;
    }

    void AccumulateBytes(LONG lBytes)
    {
        m_lBytesSinceTimeStamp += lBytes;
    }

    REFERENCE_TIME TimeStamp(LONG lOffset, LONG lByteRate) const
    {
        _ASSERTE(lByteRate > 0);

        //  Do the conversion
        return m_rt + MulDiv(m_lBytesSinceTimeStamp + lOffset,
                             10000000L,
                             lByteRate);
    }

private:
    LONG           m_lBytesSinceTimeStamp;
    REFERENCE_TIME m_rt;
};
#endif __UTIL_H_INC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\stream.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Stream.h : Declaration of the CStream

#ifndef __STREAM_H_
#define __STREAM_H_

class CSample;
class CPump;

/////////////////////////////////////////////////////////////////////////////
// CStream
class ATL_NO_VTABLE CStream :
	public CComObjectRootEx<CComMultiThreadModel>,
        public IPin,
        public IMemInputPin,
        public IAMMediaStream,
        public IMemAllocator
{
friend CPump;

public:
        typedef CComObjectRootEx<CComMultiThreadModel> _BaseClass;
        DECLARE_GET_CONTROLLING_UNKNOWN()
        //
        // METHODS
        //
	CStream();
        virtual ~CStream();

        //
        // IMediaStream
        //

        STDMETHODIMP GetMultiMediaStream(
            /* [out] */ IMultiMediaStream **ppMultiMediaStream);

        STDMETHODIMP GetInformation(
            /* [optional][out] */ MSPID *pPurposeId,
            /* [optional][out] */ STREAM_TYPE *pType);

        STDMETHODIMP SendEndOfStream(DWORD dwFlags);

        //
        // IAMMediaStream
        //
        STDMETHODIMP Initialize(
            IUnknown *pSourceObject,
            DWORD dwFlags,
            /* [in] */ REFMSPID PurposeId,
            /* [in] */ const STREAM_TYPE StreamType);

        STDMETHODIMP SetState(
            /* [in] */ FILTER_STATE State);

        STDMETHODIMP JoinAMMultiMediaStream(
            /* [in] */ IAMMultiMediaStream *pAMMultiMediaStream);

        STDMETHODIMP JoinFilter(
            /* [in] */ IMediaStreamFilter *pMediaStreamFilter);

        STDMETHODIMP JoinFilterGraph(
            /* [in] */ IFilterGraph *pFilterGraph);


        //
        // IPin
        //
        STDMETHODIMP Disconnect();
        STDMETHODIMP ConnectedTo(IPin **pPin);
        STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryPinInfo(PIN_INFO * pInfo);
        STDMETHODIMP QueryDirection(PIN_DIRECTION * pPinDir);
        STDMETHODIMP QueryId(LPWSTR * Id);
        STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP QueryInternalConnections(IPin* *apPin, ULONG *nPin);
        STDMETHODIMP EndOfStream(void);
        STDMETHODIMP BeginFlush(void);
        STDMETHODIMP EndFlush(void);
        STDMETHODIMP NewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

        //
        // IMemInputPin
        //
        STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
        STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator, BOOL bReadOnly);
        STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);
        STDMETHODIMP ReceiveMultiple(IMediaSample **pSamples, long nSamples, long *nSamplesProcessed);
        STDMETHODIMP ReceiveCanBlock();
        STDMETHODIMP Connect(IPin * pReceivePin, const AM_MEDIA_TYPE *pmt);
        STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

        //
        // IMemAllocator
        //
        STDMETHODIMP Commit();
        STDMETHODIMP Decommit();
        STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);

        // Note that NotifyAllocator calls this so override it
        // if you care.  Audio doesn't care becuase it's not
        // really using this allocator at all.
        STDMETHODIMP SetProperties(
    		ALLOCATOR_PROPERTIES* pRequest,
    		ALLOCATOR_PROPERTIES* pActual)
        {
            return S_OK;
        }
        STDMETHODIMP GetProperties(ALLOCATOR_PROPERTIES* pProps)
        {
            return E_UNEXPECTED;
        }

        //
        // Special CStream methods
        //
        virtual HRESULT GetMediaType(ULONG Index, AM_MEDIA_TYPE **ppMediaType) = 0;

        // Special to make sample to discard stuff into
        virtual HRESULT CreateTempSample(CSample **ppSample)
        {
            return E_FAIL;
        }

        virtual LONG GetChopSize()
        {
            return 0;
        }
public:
        //
        //  Private methods
        //
        void GetName(LPWSTR);
        HRESULT AllocSampleFromPool(const REFERENCE_TIME * pStartTime, CSample **ppSample);
        void AddSampleToFreePool(CSample *pSample);
        bool StealSampleFromFreePool(CSample *pSample, BOOL bAbort);
        HRESULT FinalConstruct(void);
        HRESULT ConnectThisMediaType(IPin *pReceivePin, const AM_MEDIA_TYPE *pmt);
        HRESULT CheckReceiveConnectionPin(IPin * pConnector);
#ifdef DEBUG
        #define CHECKSAMPLELIST _ASSERTE(CheckSampleList());
        bool CheckSampleList();
#else
        #define CHECKSAMPLELIST
#endif

BEGIN_COM_MAP(CStream)
        COM_INTERFACE_ENTRY(IPin)
        COM_INTERFACE_ENTRY(IMemInputPin)
        COM_INTERFACE_ENTRY(IMemAllocator)
        COM_INTERFACE_ENTRY2(IMediaStream, IAMMediaStream)
        COM_INTERFACE_ENTRY(IAMMediaStream)
END_COM_MAP()

        //
        //  MEMBER VARIABLES
        //
public:
        //
        //  These SHOULD NOT BE CCOMPTRS since we hold weak references to both of them
        //  (we never addref them).
        //
        IMediaStreamFilter             *m_pFilter;
        IBaseFilter                    *m_pBaseFilter;
        IFilterGraph                   *m_pFilterGraph;
        IAMMultiMediaStream            *m_pMMStream;

        //  Allocator held during connection
        CComPtr<IMemAllocator>          m_pAllocator;

        //  Writable streams
        CPump                           *m_pWritePump;

        //  Stream configuration
	STREAM_TYPE                     m_StreamType;
        PIN_DIRECTION                   m_Direction;
	MSPID                           m_PurposeId;
        REFERENCE_TIME                  m_rtSegmentStart;

        //  Allocator state information
        bool                            m_bUsingMyAllocator;
        bool                            m_bSamplesAreReadOnly;
        bool                            m_bCommitted;
        long                            m_lRequestedBufferCount;

        //  Sample list and semaphores
        CSample                         *m_pFirstFree;
        CSample                         *m_pLastFree;
        long                            m_cAllocated;
        long                            m_lWaiting;
        HANDLE                          m_hWaitFreeSem;
        REFERENCE_TIME                  m_rtWaiting;

        //  Filter state
        FILTER_STATE                    m_FilterState;

        //  Pin state
        CComPtr<IPin>                   m_pConnectedPin;
        CComPtr<IQualityControl>        m_pQC;
        CComQIPtr<IMemInputPin, &IID_IMemInputPin> m_pConnectedMemInputPin;
        AM_MEDIA_TYPE                   m_ConnectedMediaType;
        AM_MEDIA_TYPE                   m_ActualMediaType;
        bool                            m_bFlushing;
        bool                            m_bEndOfStream;
        bool                            m_bStopIfNoSamples;
        bool                            m_bNoStall;
};


//
//  Pump class used for write streams
//

class CPump
{
public:
    CPump(CStream *pStream);
    ~CPump();

    static HRESULT CreatePump(CStream *pStream, CPump **ppNewPump);
    HRESULT PumpMainLoop(void);
    void Run(bool);


public:
    CStream                 *m_pStream;
    HANDLE                  m_hThread;
    HANDLE                  m_hRunEvent;
    bool                    m_bShutDown;
    CComAutoCriticalSection m_CritSec;
};




#endif //__STREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\ammstrm.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// MMStream.h : Declaration of the CMMStream

#ifndef __AMMSTRM_H_
#define __AMMSTRM_H_

#define _DEBUG 1
#include "resource.h"       // main symbols
#include "atlctl.h"

/////////////////////////////////////////////////////////////////////////////
// CMMStream
class ATL_NO_VTABLE CMMStream :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMMStream, &CLSID_AMMultiMediaStream>,
	public IAMMultiMediaStream,
        public IDispatchImpl<IDirectShowStream, &IID_IDirectShowStream, &LIBID_DirectShowStreamLib>,
        public IPersistPropertyBag,
        public IObjectSafety,
        public IAMClockAdjust
{
public:
	typedef CComObjectRootEx<CComMultiThreadModel> _BaseClass;
	CMMStream();
	HRESULT FinalConstruct();
        ULONG InternalRelease()
        {
            return CComObjectRootEx<CComMultiThreadModel>::InternalRelease();
        }

public:

DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_REGISTRY_RESOURCEID(IDR_MMSTREAM)

BEGIN_COM_MAP(CMMStream)
        COM_INTERFACE_ENTRY2(IMultiMediaStream, IAMMediaStream)
	COM_INTERFACE_ENTRY(IAMMultiMediaStream)
        COM_INTERFACE_ENTRY2(IMultiMediaStream, IAMMultiMediaStream)
        COM_INTERFACE_ENTRY(IDirectShowStream)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistPropertyBag)
        COM_INTERFACE_ENTRY(IObjectSafety)
        COM_INTERFACE_ENTRY(IAMClockAdjust)
END_COM_MAP()


        //  IAMMMStream
        STDMETHODIMP Initialize(
           STREAM_TYPE StreamType,
           DWORD dwFlags,
           IGraphBuilder *pFilterGraph
        );

        STDMETHODIMP GetFilterGraph(
            IGraphBuilder **ppGraphBuilder
        );

        STDMETHODIMP GetFilter(
           IMediaStreamFilter **ppFilter
        );

        STDMETHODIMP AddMediaStream(
           IUnknown *pStreamObject,
           const MSPID *pOptionalPurposeId,
           DWORD dwFlags,
           IMediaStream **ppNewStream
        );

        STDMETHODIMP OpenFile(
           LPCWSTR pszFileName,
           DWORD dwFlags
        );

        STDMETHODIMP OpenMoniker(
           IBindCtx *pCtx,
           IMoniker *pMoniker,
           DWORD dwFlags
        );

        STDMETHODIMP Render(
           DWORD dwFlags
        );

        // IMultiMediaStream

        STDMETHODIMP GetInformation(
           DWORD *pdwFlags,
           STREAM_TYPE *pStreamType
        );

        STDMETHODIMP GetMediaStream(
           REFMSPID idPurpose,
           IMediaStream **ppMediaStream
        );

        STDMETHODIMP EnumMediaStreams(
           long Index,
           IMediaStream **ppMediaStream
        );

        STDMETHODIMP GetState(
            STREAM_STATE *pCurrentState
        );

        STDMETHODIMP SetState(
           STREAM_STATE NewState
        );

        STDMETHODIMP GetTime(
           STREAM_TIME *pCurrentTime
        );

        STDMETHODIMP GetDuration(
           STREAM_TIME *pDuration
        );

        STDMETHODIMP Seek(
           STREAM_TIME SeekTime
        );

        STDMETHODIMP GetEndOfStreamEventHandle(
            HANDLE *phEOS
        );


        //   IAMClockAdjust
        STDMETHODIMP SetClockDelta(REFERENCE_TIME rtAdjust);

        //
        //   IDirectShowStream
        //
        STDMETHODIMP get_FileName(BSTR *pVal);
        STDMETHODIMP put_FileName(BSTR newVal);
        STDMETHODIMP get_Video(OUTPUT_STATE *pVal);
        STDMETHODIMP put_Video(OUTPUT_STATE newVal);
        STDMETHODIMP get_Audio(OUTPUT_STATE *pVal);
        STDMETHODIMP put_Audio(OUTPUT_STATE newVal);


        //
        //  IPersistPropertyBag
        //
        STDMETHODIMP GetClassID(CLSID *pClsId);
        STDMETHODIMP InitNew(void);
        STDMETHODIMP Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog);
        STDMETHODIMP Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);


        //
	// IObjectSafety
	//
	STDMETHODIMP GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
	STDMETHODIMP SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

private:
       HRESULT SetStreamState(REFMSPID, OUTPUT_STATE, OUTPUT_STATE *);
       HRESULT CompleteOpen(IBaseFilter *pSource, DWORD dwFlags);
       HRESULT AddFilter(REFCLSID clsidFilter, IBaseFilter **ppFilter);
       HRESULT AddDefaultRenderer(REFMSPID PurposeId, DWORD dwFlags, IMediaStream **ppNewStream);
       HRESULT AddAMMediaStream(IAMMediaStream *pAMStream, REFMSPID PurposeId, IMediaStream **ppNewStream);
       HRESULT AddDefaultStream(
                 IUnknown *pStreamObject,
                 DWORD dwFlags,
                 REFMSPID PurposeId,
                 IMediaStream **ppNewStream);
       HRESULT GetClsidFromPurposeid(REFMSPID PurposeId, bool bRenderer, CLSID * pclsid);
       void CompleteAddGraph();
       HRESULT CheckGraph();
       void SetSeeking();

   private:

       /*  Be careful of the ordering here
           The first one we declare will be released last
       */

       /*  Can't release this in the constructor because this
           is what holds the object in place
       */
       CComPtr<IGraphBuilder>      m_pGraphBuilder;
       CComPtr<IMediaSeeking>      m_pMediaSeeking;
       CComPtr<IMediaControl>      m_pMediaControl;

       CComPtr<IMediaStreamFilter> m_pMediaStreamFilter;
       CComPtr<IBaseFilter>        m_pBaseFilter;

       /*  Type of stream we've been initialized to */
       STREAM_TYPE                  m_StreamType;
       DWORD                        m_dwInitializeFlags;
       bool                         m_StreamTypeSet;
       bool                         m_bSeekingSet;
       OUTPUT_STATE                 m_VideoState;
       OUTPUT_STATE                 m_AudioState;
       CComBSTR                     m_bstrFileName;

       DWORD                        m_dwIDispSafety;
       DWORD                        m_dwIPropBagSafety;

       /*  List of default filters added */
       CDynamicArray<IBaseFilter *, CComPtr<IBaseFilter> > m_FilterList;

       /*  End of stream handle */
       HANDLE                       m_hEOS;
       STREAM_STATE                 m_MMStreamState;
};


#endif //__AMMSTRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\ddstream\util.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// Util.cpp : Utility functions
//

#include "stdafx.h"
#include "project.h"
#include <fourcc.h>

bool IsSameObject(IUnknown *pUnk1, IUnknown *pUnk2)
{
    if (pUnk1 == pUnk2) {
  	return TRUE;
    }
    //
    // NOTE:  We can't use CComQIPtr here becuase it won't do the QueryInterface!
    //
    IUnknown *pRealUnk1;
    IUnknown *pRealUnk2;
    pUnk1->QueryInterface(IID_IUnknown, (void **)&pRealUnk1);
    pUnk2->QueryInterface(IID_IUnknown, (void **)&pRealUnk2);
    pRealUnk1->Release();
    pRealUnk2->Release();
    return (pRealUnk1 == pRealUnk2);
}


STDAPI_(void) TStringFromGUID(const GUID* pguid, LPTSTR pszBuf)
{
    wsprintf(pszBuf, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), pguid->Data1,
            pguid->Data2, pguid->Data3, pguid->Data4[0], pguid->Data4[1], pguid->Data4[2],
            pguid->Data4[3], pguid->Data4[4], pguid->Data4[5], pguid->Data4[6], pguid->Data4[7]);
}

#ifndef UNICODE
STDAPI_(void) WStringFromGUID(const GUID* pguid, LPWSTR pszBuf)
{
    char szAnsi[40];
    TStringFromGUID(pguid, szAnsi);
    MultiByteToWideChar(CP_ACP, 0, szAnsi, -1, pszBuf, sizeof(szAnsi));
}
#endif


//
//  Media Type helpers
//

void InitMediaType(AM_MEDIA_TYPE * pmt)
{
    ZeroMemory(pmt, sizeof(*pmt));
    pmt->lSampleSize = 1;
    pmt->bFixedSizeSamples = TRUE;
}



bool IsEqualMediaType(AM_MEDIA_TYPE const & mt1, AM_MEDIA_TYPE const & mt2)
{
    return ((IsEqualGUID(mt1.majortype,mt2.majortype) == TRUE) &&
        (IsEqualGUID(mt1.subtype,mt2.subtype) == TRUE) &&
        (IsEqualGUID(mt1.formattype,mt2.formattype) == TRUE) &&
        (mt1.cbFormat == mt2.cbFormat) &&
        ( (mt1.cbFormat == 0) ||
        ( memcmp(mt1.pbFormat, mt2.pbFormat, mt1.cbFormat) == 0)));
}


void CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        _ASSERTE(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

AM_MEDIA_TYPE * CreateMediaType(AM_MEDIA_TYPE *pSrc)
{
    AM_MEDIA_TYPE *pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType ) {
        if (pSrc) {
            CopyMediaType(pMediaType,pSrc);
        } else {
            InitMediaType(pMediaType);
        }
    }
    return pMediaType;
}


void DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    if (pmt) {
        FreeMediaType(*pmt);
	CoTaskMemFree((PVOID)pmt);
    }
}


void FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource)
{
    AM_MEDIA_TYPE *pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (pMediaType) {
	VIDEOINFO *pVideoInfo = (VIDEOINFO *)CoTaskMemAlloc(sizeof(VIDEOINFO));
	if (pVideoInfo) {
	    if (pmtSource) {
		*pMediaType = *pmtSource;
		CopyMemory(pVideoInfo, pmtSource->pbFormat, sizeof(*pVideoInfo));
	    } else {
		ZeroMemory(pMediaType, sizeof(*pMediaType));
		ZeroMemory(pVideoInfo, sizeof(*pVideoInfo));
		pMediaType->majortype = MEDIATYPE_Video;
		pMediaType->cbFormat = sizeof(*pVideoInfo);
                pMediaType->formattype = FORMAT_VideoInfo;
	    }
	    pMediaType->pbFormat = (BYTE *)pVideoInfo;
	} else {
	    CoTaskMemFree((PVOID)pMediaType);
	    pMediaType = NULL;
	}
    }
    return pMediaType;
}


//
//  WARNING:  The order of the entries in these tables is important!  Make sure the
//  pixelformats and mediatypes line up!
//
const GUID * g_aFormats[] =
{
    &MEDIASUBTYPE_RGB8,
    &MEDIASUBTYPE_RGB565,
    &MEDIASUBTYPE_RGB555,
    &MEDIASUBTYPE_RGB24,
    &MEDIASUBTYPE_RGB24,
    &MEDIASUBTYPE_RGB32,
    &MEDIASUBTYPE_RGB32
};

const DDPIXELFORMAT g_aPixelFormats[] =
{
    {sizeof(DDPIXELFORMAT), DDPF_RGB | DDPF_PALETTEINDEXED8, 0, 8, 0, 0, 0, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x0000F800, 0x000007E0, 0x0000001F, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 16, 0x00007C00, 0x000003E0, 0x0000001F, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x00FF0000, 0x0000FF00, 0x000000FF, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 24, 0x000000FF, 0x0000FF00, 0x00FF0000, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x00FF0000, 0x0000FF00, 0x000000FF, 0},
    {sizeof(DDPIXELFORMAT), DDPF_RGB, 0, 32, 0x000000FF, 0x0000FF00, 0x00FF0000, 0}
};



bool VideoSubtypeFromPixelFormat(const DDPIXELFORMAT *pPixelFormat, GUID *pSubType)
{
    for( int i = 0; i < sizeof(g_aPixelFormats)/sizeof(g_aPixelFormats[0]); i++ )
    {
        if (ComparePixelFormats(&g_aPixelFormats[i], pPixelFormat)) {
            *pSubType = *g_aFormats[i];
	    return true;
	}
    }
    //  OK - try just using the fourcc
    if (pPixelFormat->dwFlags & DDPF_FOURCC) {
        *pSubType = FOURCCMap(pPixelFormat->dwFourCC);
        return true;
    }
    return false;
}

bool IsSupportedType(const DDPIXELFORMAT *pPixelFormat)
{
    for( int i = 0; i < sizeof(g_aPixelFormats)/sizeof(g_aPixelFormats[0]); i++ )
    {
        if(ComparePixelFormats(&g_aPixelFormats[i], pPixelFormat)) {
	    return true;
	}
    }
    return false;
}


const DDPIXELFORMAT * GetDefaultPixelFormatPtr(IDirectDraw *pDirectDraw)
{
    if (pDirectDraw) {
        DDSURFACEDESC ddsd;
        ddsd.dwSize = sizeof(ddsd);
        if (SUCCEEDED(pDirectDraw->GetDisplayMode(&ddsd))) {
            for( int i = 0; i < sizeof(g_aPixelFormats)/sizeof(g_aPixelFormats[0]); i++ ) {
                if(memcmp(&g_aPixelFormats[i], &ddsd.ddpfPixelFormat, sizeof(g_aPixelFormats[i])) == 0) {
                    return &g_aPixelFormats[i];
	        }
            }
        }
    }
    return &g_aPixelFormats[0];
}

//
// Helper function converts a DirectDraw surface to a media type.
// The surface description must have:
//  Height
//  Width
//  lPitch -- Only used if DDSD_PITCH is set
//  PixelFormat

// Initialise our output type based on the DirectDraw surface. As DirectDraw
// only deals with top down display devices so we must convert the height of
// the surface returned in the DDSURFACEDESC into a negative height. This is
// because DIBs use a positive height to indicate a bottom up image. We also
// initialise the other VIDEOINFO fields although they're hardly ever needed
//
// pmtTemplate is used to resolve any ambiguous mappings when we don't
// want to change the connection type

HRESULT ConvertSurfaceDescToMediaType(const DDSURFACEDESC *pSurfaceDesc,
                                      IDirectDrawPalette *pPalette,
                                      const RECT *pRect, BOOL bInvertSize, AM_MEDIA_TYPE **ppMediaType,
                                      AM_MEDIA_TYPE *pmtTemplate)
{
    *ppMediaType = NULL;
    AM_MEDIA_TYPE *pMediaType = AllocVideoMediaType(NULL);
    if (pMediaType == NULL) {
	return E_OUTOFMEMORY;
    }
    if (!VideoSubtypeFromPixelFormat(&pSurfaceDesc->ddpfPixelFormat, &pMediaType->subtype)) {
        DeleteMediaType(pMediaType);
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pMediaType->pbFormat;
    BITMAPINFOHEADER *pbmiHeader = &pVideoInfo->bmiHeader;

    // Convert a DDSURFACEDESC into a BITMAPINFOHEADER (see notes later). The
    // bit depth of the surface can be retrieved from the DDPIXELFORMAT field
    // in the DDpSurfaceDesc-> The documentation is a little misleading because
    // it says the field is permutations of DDBD_*'s however in this case the
    // field is initialised by DirectDraw to be the actual surface bit depth

    pbmiHeader->biSize      = sizeof(BITMAPINFOHEADER);
    if (pSurfaceDesc->dwFlags & DDSD_PITCH) {
        pbmiHeader->biWidth = pSurfaceDesc->lPitch;
        // Convert the pitch from a byte count to a pixel count.
        // For some weird reason if the format is not a standard bit depth the
        // width field in the BITMAPINFOHEADER should be set to the number of
        // bytes instead of the width in pixels. This supports odd YUV formats
        // like IF09 which uses 9bpp.
        int bpp = pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
        if (bpp == 8 || bpp == 16 || bpp == 24 || bpp == 32) {
            pbmiHeader->biWidth /= (bpp / 8);   // Divide by number of BYTES per pixel.
        }
    } else {
        pbmiHeader->biWidth = pSurfaceDesc->dwWidth;
        // BUGUBUG -- Do something odd here with strange YUV pixel formats?  Or does it matter?
    }


    pbmiHeader->biHeight    = pSurfaceDesc->dwHeight;
    if (bInvertSize) {
	pbmiHeader->biHeight = -pbmiHeader->biHeight;
    }
    pbmiHeader->biPlanes        = 1;
    pbmiHeader->biBitCount      = (USHORT) pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
    pbmiHeader->biCompression   = pSurfaceDesc->ddpfPixelFormat.dwFourCC;
    //pbmiHeader->biXPelsPerMeter = 0;
    //pbmiHeader->biYPelsPerMeter = 0;
    //pbmiHeader->biClrUsed       = 0;
    //pbmiHeader->biClrImportant  = 0;

    // For true colour RGB formats tell the source there are bit fields
    // unless it's regular RGB555
    //
    // Try to preserve BI_RGB for RGB32 from template in case
    // connection wasn't queried for a BI_BITFIELDS -> BI_RGB switch

    _ASSERTE(!pmtTemplate || pmtTemplate->formattype == FORMAT_VideoInfo);
    DWORD dwSrcComp = pmtTemplate ?
        ((VIDEOINFO *)pmtTemplate->pbFormat)->bmiHeader.biCompression :
        (DWORD)-1;

    if (pbmiHeader->biCompression == BI_RGB) {
        if (pbmiHeader->biBitCount == 16 &&
            pMediaType->subtype != MEDIASUBTYPE_RGB555 ||
	    pbmiHeader->biBitCount == 32 && dwSrcComp == BI_BITFIELDS) {
	    pbmiHeader->biCompression = BI_BITFIELDS;
        }
    }

    if (PALETTISED(pVideoInfo)) {
	pbmiHeader->biClrUsed = 1 << pbmiHeader->biBitCount;
        if (pPalette) {
            pPalette->GetEntries(0, 0, pbmiHeader->biClrUsed, (LPPALETTEENTRY)&pVideoInfo->bmiColors);
            for (unsigned int i = 0; i < pbmiHeader->biClrUsed; i++) {
                BYTE tempRed = pVideoInfo->bmiColors[i].rgbRed;
                pVideoInfo->bmiColors[i].rgbRed = pVideoInfo->bmiColors[i].rgbBlue;
                pVideoInfo->bmiColors[i].rgbBlue = tempRed;
            }
        }
    }

    // The RGB bit fields are in the same place as for YUV formats

    if (pbmiHeader->biCompression != BI_RGB) {
        pVideoInfo->dwBitMasks[0] = pSurfaceDesc->ddpfPixelFormat.dwRBitMask;
        pVideoInfo->dwBitMasks[1] = pSurfaceDesc->ddpfPixelFormat.dwGBitMask;
        pVideoInfo->dwBitMasks[2] = pSurfaceDesc->ddpfPixelFormat.dwBBitMask;
    }

    pbmiHeader->biSizeImage = DIBSIZE(*pbmiHeader);

    // Complete the rest of the VIDEOINFO fields

    //pVideoInfo->dwBitRate = 0;
    //pVideoInfo->dwBitErrorRate = 0;
    //pVideoInfo->AvgTimePerFrame = 0;

    // And finish it off with the other media type fields

    // pMediaType->formattype = FORMAT_VideoInfo;
    pMediaType->lSampleSize = pbmiHeader->biSizeImage;
    pMediaType->bFixedSizeSamples = TRUE;
    //pMediaType->bTemporalCompression = FALSE;

    // Initialise the source and destination rectangles


    if (pRect) {
        pVideoInfo->rcSource.right = pRect->right - pRect->left;
        pVideoInfo->rcSource.bottom = pRect->bottom - pRect->top;
        pVideoInfo->rcTarget = *pRect;
    } else {
        //pVideoInfo->rcTarget.left = pVideoInfo->rcTarget.top = 0;
        pVideoInfo->rcTarget.right = pSurfaceDesc->dwWidth;
        pVideoInfo->rcTarget.bottom = pSurfaceDesc->dwHeight;
        //pVideoInfo->rcSource.left = pVideoInfo->rcSource.top = 0;
        pVideoInfo->rcSource.right = pSurfaceDesc->dwWidth;
        pVideoInfo->rcSource.bottom = pSurfaceDesc->dwHeight;
    }

    *ppMediaType = pMediaType;
    return S_OK;
}


bool PixelFormatFromVideoSubtype(REFGUID refSubType, DDPIXELFORMAT *pPixelFormat)
{
    for( int i = 0; i < sizeof(g_aFormats)/sizeof(g_aFormats[0]); i++ )
    {
	if (*g_aFormats[i] == refSubType)
	{
            *pPixelFormat = g_aPixelFormats[i];
	    return TRUE;
	}
    }
    return FALSE;
}




HRESULT ConvertMediaTypeToSurfaceDesc(const AM_MEDIA_TYPE *pmt,
                                      IDirectDraw *pDD,
                                      IDirectDrawPalette **ppPalette,
                                      LPDDSURFACEDESC pSurfaceDesc)
{
    *ppPalette = NULL;

    if (pmt->majortype != MEDIATYPE_Video ||
        pmt->formattype != FORMAT_VideoInfo) {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    VIDEOINFO *pVideoInfo = (VIDEOINFO *)pmt->pbFormat;
    BITMAPINFOHEADER *pbmiHeader = &pVideoInfo->bmiHeader;

    pSurfaceDesc->dwFlags = DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;

    // Should really look at rcTarget here if it's not empty but there are
    // very few valid cases where it makes sense so rather than risk
    // regressions we're not going to change it.

    pSurfaceDesc->dwHeight = (pbmiHeader->biHeight > 0) ? pbmiHeader->biHeight : -pbmiHeader->biHeight;
    pSurfaceDesc->dwWidth  = pbmiHeader->biWidth;

    if (PixelFormatFromVideoSubtype(pmt->subtype, &pSurfaceDesc->ddpfPixelFormat)) {
        if (pDD && pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount == 8) {
            //
            //  The RGBQUAD and PALETTEENTRY sturctures have Red and Blue swapped so
            //  we can't do a simple memory copy.
            //
            PALETTEENTRY aPaletteEntry[256];
            int iEntries = min(256, pVideoInfo->bmiHeader.biClrUsed);
            if (0 == iEntries && pmt->cbFormat >=
                (DWORD)FIELD_OFFSET(VIDEOINFO, bmiColors[256])) {
                iEntries = 256;
            }
            ZeroMemory(aPaletteEntry, sizeof(aPaletteEntry));
            for (int i = 0; i < iEntries; i++) {
                aPaletteEntry[i].peRed = pVideoInfo->bmiColors[i].rgbRed;
                aPaletteEntry[i].peGreen = pVideoInfo->bmiColors[i].rgbGreen;
                aPaletteEntry[i].peBlue = pVideoInfo->bmiColors[i].rgbBlue;
            }
            return pDD->CreatePalette(DDPCAPS_8BIT | DDPCAPS_ALLOW256, aPaletteEntry, ppPalette, NULL);
        }
        return S_OK;
    } else {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
}


//  Helper to compare pixel formats
bool ComparePixelFormats(const DDPIXELFORMAT *pFormat1,
                         const DDPIXELFORMAT *pFormat2)
{
    //  Compare the flags
    if (pFormat1->dwSize != pFormat2->dwSize) {
        return false;
    }
    if ((pFormat1->dwFlags ^ pFormat2->dwFlags) & (DDPF_RGB |
                                                   DDPF_PALETTEINDEXED8 |
                                                   DDPF_PALETTEINDEXED4 |
                                                   DDPF_PALETTEINDEXED2 |
                                                   DDPF_PALETTEINDEXED1 |
                                                   DDPF_PALETTEINDEXEDTO8 |
                                                   DDPF_YUV)
        ) {
        return false;
    }
    return (0 == memcmp(&pFormat1->dwFourCC, &pFormat2->dwFourCC,
                        FIELD_OFFSET(DDPIXELFORMAT, dwRGBAlphaBitMask) -
                        FIELD_OFFSET(DDPIXELFORMAT, dwFourCC))
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\mmstream.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// MMStream.cpp : Implementation of CMMStream
#include "stdafx.h"
#include <ddraw.h>
#include "strmobjs.h"
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <amutil.h>
#include <ddrawex.h>
#include <util.h>
#include "ammstrm.h"
#include "amguids.h"


/////////////////////////////////////////////////////////////////////////////
// Utilities

#if 0
int
WINAPI
lstrcmpWInternal(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    do {
    WCHAR c1 = *lpString1;
    WCHAR c2 = *lpString2;
    if (c1 != c2)
        return (int) c1 - (int) c2;
    } while (*lpString1++ && *lpString2++);
    return 0;
}
#endif

/*  Helper - get the major type of a pin */
void GetMajorType(IPin *pPin, GUID *pmajortype)
{
    IEnumMediaTypes *pEnum;
    *pmajortype = GUID_NULL;
    if (SUCCEEDED(pPin->EnumMediaTypes(&pEnum))) {
        AM_MEDIA_TYPE *pmt;
        DWORD dwReturned;
        if (S_OK == pEnum->Next(1, &pmt, &dwReturned)) {
            *pmajortype = pmt->majortype;
            DeleteMediaType(pmt);
        }
        pEnum->Release();
    }
}


/*  Hack to try to connect all the pins of a filter up */
HRESULT ConnectToAPin(IGraphBuilder *pBuilder, IPin *pThisPin)
{
    /*  Try and get the pin's type */
    IMediaStream *pStream;
    GUID majortype;
    GetMajorType(pThisPin, &majortype);
    CComPtr<IEnumFilters> pEnumFilters;
    HRESULT hr = pBuilder->EnumFilters(&pEnumFilters);
    if (FAILED(hr)) {
        return hr;
    }
    for (; ; ) {
        ULONG nFilters;
        CComPtr<IBaseFilter> pFilter;
        HRESULT hrNext = pEnumFilters->Next(1, &pFilter, &nFilters);
        if (hrNext == VFW_E_ENUM_OUT_OF_SYNC) {
            pEnumFilters->Reset();
            continue;
        }
        if (S_OK != hrNext) {
            return VFW_E_CANNOT_CONNECT;
        }
        CComPtr<IEnumPins> pEnumPins;
        if (S_OK != pFilter->EnumPins(&pEnumPins)) {
            return VFW_E_CANNOT_CONNECT;
        }
        for (; ; ) {
            ULONG nPins;
            CComPtr<IPin> pPin;
            if (S_OK != pEnumPins->Next(1, &pPin, &nPins)) {
                break;
            }
            /*
                Reject all pins which are not default rendered
            */
            {
                PIN_INFO PinInfo;
                pPin->QueryPinInfo(&PinInfo);
                if (PinInfo.pFilter) {
                    PinInfo.pFilter->Release();
                }
                if (PinInfo.dir != PINDIR_OUTPUT || PinInfo.achName[0] == L'~') {
                    continue;
                }
            }

            /*  Check the type - this is a big HACK to speed things up
                - otherwise we bring in a ton of audio codecs to render
                video!
            */
            GUID majortype2;
            if (majortype != GUID_NULL) {
                GetMajorType(pPin, &majortype2);
                if (majortype != majortype2 && majortype2 != GUID_NULL &&
                    majortype2 != MEDIATYPE_Stream) {
                }
            }

            if (SUCCEEDED(pBuilder->Connect(pPin, pThisPin))) {
                /*  Set the latency */
                IAMBufferNegotiation *pNegotiate;
                if (SUCCEEDED(pPin->QueryInterface(IID_IAMBufferNegotiation,
                                                   (void **)&pNegotiate))) {
                    ALLOCATOR_PROPERTIES prop;
                    prop.cBuffers = 1;    /*  For Audio? */
                    prop.cbBuffer = -1;
                    prop.cbAlign = -1;
                    prop.cbPrefix = -1;
                    pNegotiate->SuggestAllocatorProperties(&prop);
                    pNegotiate->Release();
                }
                return S_OK;
            }
        }
    }
}


HRESULT ConnectFilterPins(IGraphBuilder *pBuilder, IBaseFilter *pFilter)
{
    HRESULT hrTotal = VFW_E_CANNOT_CONNECT;
    /*  For each pin try to connect it up - just once */
    CComPtr<IEnumPins> pEnumPins;
    HRESULT hr = pFilter->EnumPins(&pEnumPins);
    if (FAILED(hr)) {
        return S_OK;
    }
    for (; ; ) {
        ULONG nPins;
        CComPtr<IPin> pPin;
        if (S_OK != pEnumPins->Next(1, &pPin, &nPins)) {
            return hrTotal;
        }
        hr = ConnectToAPin(pBuilder, pPin);
        if (S_OK == hr) {
            hrTotal = hr;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////
// CMMStream


CMMStream::CMMStream() :
    m_StreamTypeSet(false),
    m_bSeekingSet(false),
    m_dwInitializeFlags(0),
    m_StreamType(STREAMTYPE_READ),
    m_hEOS(NULL),
    m_dwIDispSafety(0),
    m_dwIPropBagSafety(0),
    m_AudioState(Disabled),
    m_VideoState(Disabled),
    m_MMStreamState(STREAMSTATE_STOP)
{
}


/*  Create things here */
HRESULT CMMStream::FinalConstruct()
{
    HRESULT hr = _BaseClass::FinalConstruct();
    if (FAILED(hr)) {
        return hr;
    }
    hr = CoCreateInstance(
             CLSID_MediaStreamFilter,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IMediaStreamFilter,
             (void **)&m_pMediaStreamFilter
         );

    EXECUTE_ASSERT(SUCCEEDED(m_pMediaStreamFilter->QueryInterface(
        IID_IBaseFilter,
        (void **)&m_pBaseFilter)));
    return S_OK;
}

//  IAMMMStream
STDMETHODIMP CMMStream::Initialize(
    STREAM_TYPE StreamType,
    DWORD dwFlags,
    IGraphBuilder *pFilterGraph
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::Initialize(%d, 0x%8.8X, 0x%8.8X)\n"),
              StreamType, dwFlags, pFilterGraph);
    AUTO_CRIT_LOCK;
    if (m_StreamTypeSet && StreamType != m_StreamType ||
        (0 != (dwFlags & ~AMMSF_NOGRAPHTHREAD))) {
        return E_INVALIDARG;
    }
    if (m_pGraphBuilder && pFilterGraph != NULL) {
        return E_INVALIDARG;
    }
    m_dwInitializeFlags = dwFlags;
    if (pFilterGraph) {
        m_pGraphBuilder = pFilterGraph;
        CompleteAddGraph();
    }

    m_StreamTypeSet = true;
    m_StreamType = StreamType;
    return S_OK;
}

STDMETHODIMP CMMStream::GetFilter(
    IMediaStreamFilter **ppFilter
)
{
    TRACEINTERFACE(_T("IAMMultiMediaStream::GetFilter(0x%8.8X)\n"), ppFilter);
    if (ppFilter == NULL) {
        return E_POINTER;
    }
    m_pMediaStreamFilter.p->AddRef();
    *ppFilter = m_pMediaStreamFilter;
    return S_OK;
}

STDMETHODIMP CMMStream::GetFilterGraph(IGraphBuilder **ppGraphBuilder)
{
    TRACEINTERFACE(_T("AMIMultiMediaStream::GetFilterGraph(0x%8.8X)\n"), ppGraphBuilder);
    if (ppGraphBuilder == NULL) {
        return E_POINTER;
    }
    if (m_pGraphBuilder) {
        m_pGraphBuilder.p->AddRef();
        *ppGraphBuilder = m_pGraphBuilder;
    } else {
        *ppGraphBuilder = NULL;
    }
    return S_OK;
}


HRESULT CMMStream::AddDefaultRenderer(REFMSPID PurposeId, DWORD dwFlags, IMediaStream **ppNewStream)
{
    TRACEFUNC(_T("IAMMultiMediaStream::AddDefaultRenderer(%s, 0x%8.8X, 0x%8.8X)\n"),
                   TextFromPurposeId(PurposeId), dwFlags, ppNewStream);
    HRESULT hr;
    if (ppNewStream) {
        hr = E_INVALIDARG;
    } else {
        CLSID clsid;
        hr = GetClsidFromPurposeid(PurposeId, true, &clsid);
        if (SUCCEEDED(hr)) {
            hr = AddFilter(clsid, NULL);
        }
    }
    return hr;
}

HRESULT CMMStream::AddAMMediaStream(IAMMediaStream *pAMStream, REFMSPID PurposeId, IMediaStream **ppNewStream)
{
    TRACEFUNC(_T("IMultiMediaStream::AddAMMediaStream(0x%8.8X, %s, 0x%8.8X)\n"),
                   pAMStream, TextFromPurposeId(PurposeId), ppNewStream);
    HRESULT hr;
    MSPID StreamPurposeId;
    EXECUTE_ASSERT(SUCCEEDED(pAMStream->GetInformation(&StreamPurposeId, NULL)));
    if (PurposeId != StreamPurposeId) {
        hr = MS_E_PURPOSEID;
    } else {
        hr = pAMStream->JoinAMMultiMediaStream(this);
        if (SUCCEEDED(hr)) {
            hr = m_pMediaStreamFilter->AddMediaStream(pAMStream);
            if (SUCCEEDED(hr)) {
                if (ppNewStream) {
                    pAMStream->AddRef();
                    *ppNewStream = pAMStream;
                }
            } else {
                pAMStream->JoinAMMultiMediaStream(NULL);
            }
        }
    }
    return hr;
}


HRESULT CMMStream::AddDefaultStream(
                 IUnknown *pStreamObject,
                 DWORD dwFlags,
                 REFMSPID PurposeId,
                 IMediaStream **ppNewStream)
{
    TRACEFUNC(_T("IMultiMediaStream::AddDefaultStream(0x%8.8X, %8.8X, %s, 0x%8.8X)\n"),
                   pStreamObject, dwFlags, TextFromPurposeId(PurposeId), ppNewStream);
    CLSID clsidStreamObject;
    HRESULT hr = GetClsidFromPurposeid(PurposeId, false, &clsidStreamObject);
    if (SUCCEEDED(hr)) {
        IAMMediaStream *pMediaStream;
        hr = CoCreateInstance(
             clsidStreamObject,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IAMMediaStream,
             (void **)&pMediaStream
        );
        if (SUCCEEDED(hr)) {
            hr = pMediaStream->Initialize(pStreamObject, dwFlags, PurposeId, m_StreamType);
            if (SUCCEEDED(hr)) {
                hr = AddAMMediaStream(pMediaStream, PurposeId, ppNewStream);
            }
            pMediaStream->Release();
        }
    }
    return hr;
}




//
//  This call can take on various flavors depending upon the flags and the pStreamObject
//  passed to it.  Basically the algorithm is:
//
//  If flag "add default renderer" then
//      Add renderer associated with purpose ID
//  else
//      If flag "add peer" then
//          (pStreamObject must be an IMediaStream object)
//          if PurposeId != NULL then
//              Create default stream for purpose ID
//          else
//              Get purpose ID of pStreamObject
//              Create default stream for that purpose ID
//          Initialize new stream
//      else
//          If pStreamObject is an IAMMediaStream then
//              Add it to our media stream
//          else
//              Attempt to create an IAMMediaStream by looking up the purpose ID
//
//

STDMETHODIMP CMMStream::AddMediaStream(
    IUnknown *pStreamObject,
    const MSPID *pOptionalPurposeId,
    DWORD dwFlags,
    IMediaStream **ppNewStream
)
{
    if (dwFlags & ~(AMMSF_ADDDEFAULTRENDERER |
                    AMMSF_CREATEPEER |
                    AMMSF_STOPIFNOSAMPLES |
                    AMMSF_NOSTALL)
        ) {
        return E_INVALIDARG;
    }
    TRACEINTERFACE(_T("IAMMultiMediaStream::AddMediaStream(0x%8.8X, %s, %8.8X, 0x%8.8X)\n"),
                   pStreamObject,
                   pOptionalPurposeId ? TextFromPurposeId(*pOptionalPurposeId) : _T("NULL"),
                   dwFlags, ppNewStream);
    AUTO_CRIT_LOCK;
    if (ppNewStream) {
        *ppNewStream = NULL;
    }

    HRESULT hr = CheckGraph();
    CComPtr<IMediaStream> pSourceMediaStream;
    CComPtr<IAMMediaStream> pSourceAMMediaStream;
    if (pStreamObject) {
        pStreamObject->QueryInterface(IID_IMediaStream, (void **)&pSourceMediaStream);
        pStreamObject->QueryInterface(IID_IAMMediaStream, (void **)&pSourceAMMediaStream);
    }

    if (SUCCEEDED(hr)) {
        MSPID PurposeId;
        if (pOptionalPurposeId) {
            PurposeId = *pOptionalPurposeId;
        } else {
            hr = pSourceMediaStream ? pSourceMediaStream->GetInformation(&PurposeId, NULL) : E_INVALIDARG;
        }
        if (SUCCEEDED(hr)) {
            if (dwFlags & AMMSF_ADDDEFAULTRENDERER) {
                hr = AddDefaultRenderer(PurposeId, dwFlags, ppNewStream);
            } else {
                if (pSourceAMMediaStream && ((dwFlags & AMMSF_CREATEPEER) == 0)) {
                    hr = AddAMMediaStream(pSourceAMMediaStream, PurposeId, ppNewStream);
                } else {
                    hr = AddDefaultStream(pStreamObject, dwFlags, PurposeId, ppNewStream);
                }
            }
        }
    }
    return hr;
}





//  Note that backout in this area is extemely tricky
STDMETHODIMP CMMStream::OpenFile(
    LPCWSTR pszFileName,
    DWORD dwFlags
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::OpenFile(%ls, 0x%8.8X)\n"),
                    pszFileName, dwFlags);
    if (m_StreamType == STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    if (pszFileName == NULL) {
        return E_POINTER;
    }
    AUTO_CRIT_LOCK;
    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }

    CComPtr<IBaseFilter> pSource;

    hr = m_pGraphBuilder->AddSourceFilter(
                     pszFileName,
                     L"Source",
                     &pSource
                 );

    if (SUCCEEDED(hr)) {
        hr =  CompleteOpen(pSource, dwFlags);
        if (FAILED(hr)) {
            m_pGraphBuilder->RemoveFilter(pSource);
        }
    }
    return hr;

}

STDMETHODIMP CMMStream::OpenMoniker(
    IBindCtx *pCtx,
    IMoniker *pMoniker,
    DWORD dwFlags
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::OpenMoniker(0x%8.8X, 0x%8.8X, 0x%8.8X)\n"),
                    pCtx, pMoniker, dwFlags);
    if (m_StreamType == STREAMTYPE_WRITE) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    AUTO_CRIT_LOCK;
    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }
    IFilterGraph2 *pGraph2;
    hr = m_pGraphBuilder->QueryInterface(
                     IID_IFilterGraph2,
                     (void **)&pGraph2);
    if (FAILED(hr)) {
        return hr;
    }

    CComPtr<IBaseFilter> pFilter;

    hr = pGraph2->AddSourceFilterForMoniker(
            pMoniker,
            pCtx,
            L"Source",
            &pFilter);

    pGraph2->Release();
    if (FAILED(hr)) {
        return hr;
    }

    if (SUCCEEDED(hr)) {
        hr =  CompleteOpen(pFilter, dwFlags);
        if (FAILED(hr)) {
            m_pGraphBuilder->RemoveFilter(pFilter);
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::Render(
    DWORD dwFlags
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::Render(0x%8.8X)\n"),
                    dwFlags);
    if ((dwFlags & ~AMMSF_NOCLOCK) && m_StreamType == STREAMTYPE_WRITE) {
        return E_INVALIDARG;
    }
    AUTO_CRIT_LOCK;

    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }

    if (m_StreamType == STREAMTYPE_READ) {
        /*  Render all the filters we can find */
        IEnumFilters *pEnum;
        HRESULT hr = m_pGraphBuilder->EnumFilters(&pEnum);
        if (SUCCEEDED(hr)) {
            hr = VFW_E_CANNOT_CONNECT;
            IBaseFilter *pFilter;
            ULONG nFilters;
            for (; ; ) {
                HRESULT hrNext = pEnum->Next(1, &pFilter, &nFilters);
                if (hrNext == VFW_E_ENUM_OUT_OF_SYNC) {
                    pEnum->Reset();
                } else if (hrNext == S_OK) {
                    if (S_OK == CompleteOpen(pFilter, dwFlags)) {
                        hr = S_OK;
                    }
                    pFilter->Release();
                } else {
                    break;
                }
            }
            pEnum->Release();
        }
        return hr;
    }

    for (int iStream = 0; ; iStream++) {
        CComPtr<IMediaStream> pStream;
        hr = EnumMediaStreams(iStream, &pStream);
        if (S_OK == hr) {
            CComQIPtr <IPin, &IID_IPin> pOutputPin(pStream);
            if (pOutputPin) {

                //  Some streams may already have been rendered

                IPin *pConnected;
                if (SUCCEEDED(pOutputPin->ConnectedTo(&pConnected))) {
                    pConnected->Release();
                } else {
                    hr = m_pGraphBuilder->Render(pOutputPin);
                }
                if (FAILED(hr)) {

                    //  Kind of difficult to back out!
                    return hr;
                }
            }
        } else {
            hr = S_OK;
            break;
        }
    }

    if (dwFlags & AMMSF_NOCLOCK) {
        CComPtr<IMediaFilter> pMediaFilter;
        EXECUTE_ASSERT(SUCCEEDED(m_pGraphBuilder->QueryInterface(
                IID_IMediaFilter, (void **)&pMediaFilter)));
        EXECUTE_ASSERT(SUCCEEDED(pMediaFilter->SetSyncSource(NULL)));
    }

    return hr;
}



// IMultiMediaStream

STDMETHODIMP CMMStream::GetInformation(
    DWORD *pdwFlags,
    STREAM_TYPE *pStreamType
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetInformation(0x%8.8X, 0x%8.8X)\n"),
                    pdwFlags, pStreamType);
    AUTO_CRIT_LOCK;
    if (m_pGraphBuilder == NULL) {
        return E_UNEXPECTED;
    }
    DWORD dwFlags = MMSSF_ASYNCHRONOUS;
    IReferenceClock *pClock;
    IMediaFilter *pGraphFilter;
    if (SUCCEEDED(m_pGraphBuilder->QueryInterface(
                      IID_IMediaFilter, (void **)&pGraphFilter))) {
        if (S_OK == pGraphFilter->GetSyncSource(&pClock)) {
            if (pClock) {
                pClock->Release();
            }
            dwFlags |= MMSSF_HASCLOCK;
        }
        pGraphFilter->Release();
    }
    if (m_pMediaSeeking) {
        LONGLONG llDuration;
        if (S_OK == m_pMediaSeeking->GetDuration(&llDuration)) {
            dwFlags |= MMSSF_SUPPORTSEEK;
        }
    }
    if (pdwFlags) {
        *pdwFlags = dwFlags;
    }
    if (pStreamType) {
        *pStreamType = m_StreamType;
    }
    return S_OK;
}

STDMETHODIMP CMMStream::GetMediaStream(
    REFMSPID idPurpose,
    IMediaStream **ppMediaStream
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetMediaStream(%s, 0x%8.8X)\n"),
                    TextFromPurposeId(idPurpose), ppMediaStream);
    return m_pMediaStreamFilter->GetMediaStream(idPurpose, ppMediaStream);
}

STDMETHODIMP CMMStream::EnumMediaStreams(
    long Index,
    IMediaStream **ppMediaStream
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::EnumMediaStreams(%d, 0x%8.8X)\n"),
                    Index, ppMediaStream);
    return m_pMediaStreamFilter->EnumMediaStreams(Index, ppMediaStream);
}

//
//  WARNING!  Do NOT take the cricical section in this function since InternalUpdate
//  from the base sample Update() method calls this.
//
STDMETHODIMP CMMStream::GetState(STREAM_STATE *pCurrentState)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetState(0x%8.8X)\n"),
                    pCurrentState);
    *pCurrentState = m_MMStreamState;
    return S_OK;
}

STDMETHODIMP CMMStream::SetState(
    STREAM_STATE NewState
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::SetState(%d)\n"),
                    NewState);
    HRESULT hr;
    switch (NewState) {
    case STREAMSTATE_STOP:
        hr = m_pMediaControl->Stop();
        break;
    case STREAMSTATE_RUN:
        hr = m_pMediaControl->Pause();
        if (SUCCEEDED(hr)) {
            long state;

            //  Wait 1 second if necessary
            m_pMediaControl->GetState(1000 * 10000, &state);
            hr = m_pMediaControl->Run();
        }
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }
    if (SUCCEEDED(hr)) {
        m_MMStreamState = NewState;
    }
    return hr;
}


STDMETHODIMP CMMStream::GetTime(
    STREAM_TIME *pCurrentTime
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetTime(0x%8.8X)\n"),
                    pCurrentTime);
    //  This is supposed to return the time that matches the
    //  samples so use ISeeking
    HRESULT hr = E_NOTIMPL;
    if (m_pMediaSeeking != NULL) {
        REFERENCE_TIME tStop;

        //  This can return E_NOTIMPL for non-seekable graphs
        hr = m_pMediaSeeking->GetPositions((REFERENCE_TIME *)pCurrentTime,
                                           &tStop);
    }
    if (hr == E_NOTIMPL) {
        if (m_pMediaStreamFilter) {
            hr = m_pMediaStreamFilter->GetCurrentStreamTime(pCurrentTime);
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::GetDuration(
    STREAM_TIME *pDuration
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::GetDuration(0x%8.8X)\n"),
                    pDuration);
    SetSeeking();
    if (m_pMediaSeeking == NULL) {
        return E_NOINTERFACE;
    }
    *pDuration = 0;
    if (m_StreamType != STREAMTYPE_READ) {
        return MS_E_INVALIDSTREAMTYPE;
    }
    return SUCCEEDED(m_pMediaSeeking->GetDuration(pDuration)) ?
        S_OK : S_FALSE;
}

STDMETHODIMP CMMStream::Seek(
    STREAM_TIME SeekTime
)
{
    TRACEINTERFACE(_T("IMultiMediaStream::Seek(%dms)\n"),
                    (LONG)(SeekTime / 10000));
    SetSeeking();
    if (m_pMediaSeeking == NULL) {
        return E_NOINTERFACE;
    }
    return m_pMediaSeeking->SetPositions(
               &SeekTime,
               AM_SEEKING_AbsolutePositioning,
               NULL,
               AM_SEEKING_NoPositioning
           );
}

STDMETHODIMP CMMStream::GetEndOfStreamEventHandle(
    HANDLE *phEOS
)
{
    TRACEINTERFACE(_T("IAMMultiMediaStream::GetEndOfStreamEventHandle(0x%8.8X)\n"),
                    phEOS);
    if (phEOS == NULL) {
        return E_POINTER;
    }
    HRESULT hr = CheckGraph();
    if (FAILED(hr)) {
        return hr;
    }
    _ASSERTE(m_hEOS != NULL);
    *phEOS = m_hEOS;
    return S_OK;
}

STDMETHODIMP CMMStream::SetClockDelta(
    REFERENCE_TIME rtAdjust
)
{
    //  Get the clock and see if it supports it
    IMediaFilter *pGraphFilter;
    HRESULT hr =  m_pGraphBuilder->QueryInterface(
                      IID_IMediaFilter, (void **)&pGraphFilter);
    if (SUCCEEDED(hr)) {
        IReferenceClock *pClock;
        if (S_OK == pGraphFilter->GetSyncSource(&pClock)) {
            if (pClock) {
                IAMClockAdjust *pAdjust;
                hr = pClock->QueryInterface(IID_IAMClockAdjust, (void **)&pAdjust);
                if (SUCCEEDED(hr)) {
                    hr = pAdjust->SetClockDelta(rtAdjust);
                    pAdjust->Release();
                }
                pClock->Release();
            }
        }
        pGraphFilter->Release();
    }
    return hr;
}

HRESULT CMMStream::AddFilter(REFCLSID rclsidFilter, IBaseFilter **ppFilter)
{
    TRACEFUNC(_T("CMMStream::AddFilter(%s, 0x%8.8X)\n"),
                    rclsidFilter, ppFilter);
    IBaseFilter *pFilter;
    _ASSERTE(m_pGraphBuilder != NULL);
    HRESULT hr = CoCreateInstance(
                         rclsidFilter,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IBaseFilter,
                         (void **)&pFilter
                 );
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pGraphBuilder->AddFilter(pFilter, NULL);
    m_FilterList.Add(pFilter);
    if (ppFilter) {
        *ppFilter = pFilter;
    }
    pFilter->Release();
    return hr;
}


//
//  Potential future work -- this could look in the registry
//
HRESULT CMMStream::GetClsidFromPurposeid(REFMSPID PurposeId, bool bRenderer, CLSID * pclsid)
{
    TRACEFUNC(_T("CMMStream::GetClsidFromPurposeid(%s, %d, 0x%8.8X)\n"),
                    TextFromPurposeId(PurposeId), bRenderer, pclsid);
    if (bRenderer) {
        if (PurposeId == MSPID_PrimaryAudio) {
            *pclsid = CLSID_DSoundRender;
        } else {
            return MS_E_PURPOSEID;
        }
    } else {
        if (PurposeId == MSPID_PrimaryVideo) {
            *pclsid = CLSID_AMDirectDrawStream;
        } else {
            if (PurposeId == MSPID_PrimaryAudio) {
                *pclsid = CLSID_AMAudioStream;
            } else {
                return MS_E_PURPOSEID;
            }
        }
    }
    return NOERROR;
}



void CMMStream::CompleteAddGraph()
{
    _ASSERTE(m_pMediaSeeking == NULL);
    m_pGraphBuilder->QueryInterface(IID_IMediaSeeking, (void **)&m_pMediaSeeking);
    m_pGraphBuilder->QueryInterface(IID_IMediaControl, (void **)&m_pMediaControl);

    /*  Add our filter ! */
    m_pGraphBuilder->AddFilter(m_pBaseFilter, L"MediaStreamFilter");

    /*  Get IMediaEvent to get the event handle */
    IMediaEventEx *pEvent;
    HRESULT hr = m_pGraphBuilder->QueryInterface(IID_IMediaEventEx, (void **)&pEvent);
    if (SUCCEEDED(hr)) {
        pEvent->GetEventHandle((OAEVENT *)&m_hEOS);
        pEvent->SetNotifyFlags(AM_MEDIAEVENT_NONOTIFY);
        pEvent->Release();
    }
}

//  Call this after adding the source/sink to the graph
HRESULT CMMStream::CompleteOpen(IBaseFilter *pSource, DWORD dwFlags)
{
    HRESULT hrTotal = VFW_E_CANNOT_CONNECT;
    {
        //  Find the output pin
        CComPtr<IEnumPins> pEnumPins;
        HRESULT hr = pSource->EnumPins(&pEnumPins);
        if (FAILED(hr)) {
            return hr;
        }
        for ( ; ; ) {
            CComPtr<IPin> pPin;
            ULONG nPins = 0;
            if (S_OK != pEnumPins->Next(1, &pPin, &nPins)) {
                break;
            }
            _ASSERTE(nPins == 1);

            switch (dwFlags & AMMSF_RENDERTYPEMASK) {
            case AMMSF_NORENDER:
                break;

            case AMMSF_RENDERTOEXISTING:
            case AMMSF_RENDERALLSTREAMS:


                //  Do it the hard way
                hr = ConnectFilterPins(m_pGraphBuilder, m_pBaseFilter);
                if (SUCCEEDED(hr)) {
                    for (int i = 0; i < m_FilterList.Size(); i++ ) {
                        HRESULT hr =
                            ConnectFilterPins(m_pGraphBuilder,
                                              m_FilterList.Element(i));
                    }
                }
                //  Performance is no good with this
                //  We need to render to existing renderers which is only in
                //  IFilterGraph2
                if (FAILED(hr)) {
                    CComQIPtr<IFilterGraph2, &IID_IFilterGraph2> pGraph2(m_pGraphBuilder);
                    hr = pGraph2->RenderEx(
                        pPin,
                        (dwFlags & AMMSF_RENDERTYPEMASK) ==
                            AMMSF_RENDERALLSTREAMS ?
                            0 : AM_RENDEREX_RENDERTOEXISTINGRENDERERS,
                        NULL);
                }
                if (SUCCEEDED(hr)) {
                    hr = S_OK;
                }
                break;
            }
            if (S_OK == hr) {
                hrTotal = hr;
            }
        }
    }


    if (SUCCEEDED(hrTotal)) {
        m_StreamTypeSet = true;
        if (dwFlags & AMMSF_NOCLOCK) {
            CComPtr<IMediaFilter> pMediaFilter;
            EXECUTE_ASSERT(SUCCEEDED(m_pGraphBuilder->QueryInterface(
                    IID_IMediaFilter, (void **)&pMediaFilter)));
            EXECUTE_ASSERT(SUCCEEDED(pMediaFilter->SetSyncSource(NULL)));
        } else {
            //  Make it have a clock now or we'll get confused later
            m_pGraphBuilder->SetDefaultSyncSource();
        }

        // Make sure seeking is set up
        SetSeeking();
        if (dwFlags & AMMSF_RUN) {
            hrTotal = SetState(STREAMSTATE_RUN);
        }
    }
    return hrTotal;
}

HRESULT CMMStream::CheckGraph()
{
    if (m_MMStreamState != STREAMSTATE_STOP) {
        return MS_E_BUSY;
    }
    if (m_pGraphBuilder == NULL) {
        // Make our own filter graph
        HRESULT hr = CoCreateInstance(
                         m_dwInitializeFlags & AMMSF_NOGRAPHTHREAD ?
                             CLSID_FilterGraphNoThread :
                             CLSID_FilterGraph,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_IGraphBuilder,
                         (void **)&m_pGraphBuilder
                     );
        if (FAILED(hr)) {
            return hr;
        }
        CompleteAddGraph();
    }
    return S_OK;
}

void CMMStream::SetSeeking()
{

    if (!m_bSeekingSet) {
        if (m_StreamType != STREAMTYPE_WRITE && m_pMediaStreamFilter != NULL) {
            m_pMediaStreamFilter->SupportSeeking(m_StreamType == STREAMTYPE_READ);
        }
        m_bSeekingSet = TRUE;
    }
}


STDMETHODIMP CMMStream::get_FileName(BSTR *pVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::get_FileName(0x%8.8X)\n"),
                   pVal);
    *pVal = m_bstrFileName.Copy();
    return S_OK;
}

STDMETHODIMP CMMStream::put_FileName(BSTR newVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::put_FileName(%ls\n"),
                   newVal);
    HRESULT hr = OpenFile(newVal, 0);
    if (SUCCEEDED(hr)) {
        m_bstrFileName = newVal;
    }
    return hr;
}

HRESULT CMMStream::SetStreamState(REFMSPID PurposeId, OUTPUT_STATE NewState, OUTPUT_STATE * pCurVal)
{
    HRESULT hr = S_OK;
    if (*pCurVal != NewState) {
        switch (NewState) {
        case Disabled:
            hr = E_FAIL;    // Currently no way to force this
            break;
        case ReadData:
            hr = AddMediaStream(NULL, &PurposeId, 0, NULL);
            break;
        case RenderData:
            hr = AddMediaStream(NULL, &PurposeId, AMMSF_ADDDEFAULTRENDERER, NULL);
            break;
        default:
            hr = E_INVALIDARG;
        }
        if (SUCCEEDED(hr)) {
            *pCurVal = NewState;
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::get_Video(OUTPUT_STATE *pVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::get_Video(0x%8.8X\n"),
                   pVal);
    *pVal = m_VideoState;
    return S_OK;
}

STDMETHODIMP CMMStream::put_Video(OUTPUT_STATE newVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::put_Video(%d\n"),
                   newVal);
    return SetStreamState(MSPID_PrimaryVideo, newVal, &m_VideoState);
}

STDMETHODIMP CMMStream::get_Audio(OUTPUT_STATE *pVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::get_Audio(0x%8.8X\n"),
                   pVal);
    *pVal = m_AudioState;
    return S_OK;
}

STDMETHODIMP CMMStream::put_Audio(OUTPUT_STATE newVal)
{
    TRACEINTERFACE(_T("IDirectShowStream::put_Audio(%d\n"),
                   newVal);
    return SetStreamState(MSPID_PrimaryAudio, newVal, &m_AudioState);
}



//
//  Property bag goop
//


STDMETHODIMP CMMStream::GetClassID(CLSID *pClsId)
{
    *pClsId = CLSID_AMMultiMediaStream;
    return S_OK;
}

STDMETHODIMP CMMStream::InitNew(void)
{
    return S_OK;    // initialize new property bag goop
}


const WCHAR g_szVideo[] = L"Video";
const WCHAR g_szAudio[] = L"Audio";
const WCHAR g_szFileName[] = L"FileName";

STDMETHODIMP CMMStream::Load(IPropertyBag* pPropBag, IErrorLog* pErrorLog)
{
    TRACEINTERFACE(_T("IPersistPropertyBag::Load"));
    CComVariant var;
    if (pPropBag->Read(g_szVideo, &var, pErrorLog) == S_OK) {
        var.ChangeType(VT_I4);
        put_Video((OUTPUT_STATE)var.lVal);
        var.Clear();
    }
    if (pPropBag->Read(g_szAudio, &var, pErrorLog) == S_OK) {
        var.ChangeType(VT_I4);
        put_Audio((OUTPUT_STATE)var.lVal);
        var.Clear();
    }
    if (pPropBag->Read(g_szFileName, &var, pErrorLog) == S_OK) {
        var.ChangeType(VT_BSTR);
        put_FileName(var.bstrVal);
        var.Clear();
    }
    return S_OK;
}

STDMETHODIMP CMMStream::Save(IPropertyBag* pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    TRACEINTERFACE(_T("IPersistPropertyBag::Save"));
    CComVariant var(m_VideoState);
    HRESULT hr = pPropBag->Write(g_szVideo, &var);
    if (SUCCEEDED(hr)) {
        var = m_AudioState;
        hr = pPropBag->Write(g_szAudio, &var);
        if (SUCCEEDED(hr)) {
            var.ChangeType(VT_BSTR | VT_BYREF);
            var.bstrVal = m_bstrFileName;
            hr = pPropBag->Write(g_szFileName, &var);
        }
    }
    return hr;
}



//
//  IObjectSafety
//
STDMETHODIMP CMMStream::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    TRACEINTERFACE(_T("IObjectSafety::GetInterfaceSafetyOptions"));
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL) {
        return E_POINTER;
    }
    HRESULT hr = S_OK;
    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    if (riid == IID_IDispatch) {
        *pdwEnabledOptions = m_dwIDispSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    } else {
        if (riid == IID_IPersistPropertyBag) {
	    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	    *pdwEnabledOptions = m_dwIPropBagSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
        } else {
	    *pdwSupportedOptions = 0;
	    *pdwEnabledOptions = 0;
	    hr = E_NOINTERFACE;
        }
    }
    return hr;
}

STDMETHODIMP CMMStream::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    TRACEINTERFACE(_T("IObjectSafety::SetInterfaceSafetyOptions"));
    HRESULT hr = S_OK;
    if (riid == IID_IDispatch)
    {
	m_dwIDispSafety = dwEnabledOptions & dwOptionSetMask;
    } else {
        if (riid == IID_IPersistPropertyBag) {
	    m_dwIPropBagSafety = dwEnabledOptions & dwOptionSetMask;
        } else {
            hr = E_NOINTERFACE;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\resource.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by strmobjs.rc
//
#define IDS_PROJNAME                    100
#define IDR_SFILTER                     101
#define IDR_MMSTREAM                    102
#define IDR_STREAM                      103
#define IDR_AUDIOSTREAM                 104
#define IDR_AUDIODATA                   105
#define IDR_MTSTREAM                    106

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\sfilter.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// SFilter.cpp : Implementation of CMediaStreamFilter
#include "stdafx.h"
#include "strmobjs.h"
#include <amstream.h>
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <evcode.h>
#include <vfwmsgs.h>
#include <amutil.h>
#include "amguids.h"
#include "SFilter.h"


//
//   Note on locking of the filter
//
//   The whole object lock is always acquired before the callback
//   lock (m_csCallback) if it is acquired at all.  This 2 level
//   scheme is to prevent deadlocks when the streams call the filter
//   back for:
//
//       Flush
//       EndOfStream
//       WaitUntil
//       GetCurrentStreamTime
//
//   State changes, changes to the list of pins are protected by
//   the whole object lock
//
//   The clock, alarmlist, end of stream and flushing
//   member variables are protected by m_csCallback
//



CAlarm::CAlarm() :
    m_pNext(NULL),
    m_hEvent(NULL),
    m_bKilled(false)
{
}

CAlarm::~CAlarm()
{
    if (m_hEvent) {
        CloseHandle(m_hEvent);
    }
}

HRESULT CAlarm::CreateNewAlarm(CAlarm **ppNewEvent)
{
    *ppNewEvent = NULL;
    CAlarm *pNew = new CAlarm();
    if (pNew) {
        pNew->m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pNew->m_hEvent) {
            *ppNewEvent = pNew;
            return S_OK;
        }
        delete pNew;
    }
    return E_OUTOFMEMORY;
}


/////////////////////////////////////////////////////////////////////////////
// CMediaStreamFilter



/* Constructor */

CMediaStreamFilter::CMediaStreamFilter() :
    m_State(State_Stopped),
    m_pGraph(NULL),
    m_pUnknownSeekAgg(NULL),
    m_rtStart(0),
    m_pFirstFreeAlarm(NULL),
    m_pFirstActiveAlarm(NULL),
    m_nAtEOS(0)
{
}


void CMediaStreamFilter::FinalRelease()
{
    if (m_pUnknownSeekAgg) {
        m_pUnknownSeekAgg->Release();
    }
    _ASSERTE(m_pFirstActiveAlarm == NULL);
    CAlarm *pCurAlarm = m_pFirstFreeAlarm;
    while (pCurAlarm) {
        CAlarm *pNext = pCurAlarm->m_pNext;
        delete pCurAlarm;
        pCurAlarm = pNext;
    }
}

//// IPERSIST

STDMETHODIMP CMediaStreamFilter::GetClassID(CLSID *pClsID)
{
    *pClsID = GetObjectCLSID();
    return NOERROR;
}



/////////////// IBASEFILTER

HRESULT CMediaStreamFilter::SyncSetState(FILTER_STATE State)
{
    AUTO_CRIT_LOCK;
    if (State == m_State) {
        return S_OK;
    }
    const FILTER_STATE fsOld = m_State;
    m_State = State;
    //
    //  We want to stop the streams first so that they will decommit their allocators BEFORE
    //  we kill the timers, which could wake them up out of a GetBuffer call.
    //
    for (int i = 0; i < m_Streams.Size(); i++) {
        m_Streams.Element(i)->SetState(State);
    }
    if (State == State_Stopped) {
        m_nAtEOS = 0;
        FlushTimers();
    } else {
        CheckComplete();
    }
    return S_OK;
}

STDMETHODIMP CMediaStreamFilter::Stop()
{
    return SyncSetState(State_Stopped);
}

STDMETHODIMP CMediaStreamFilter::Pause()
{
    return SyncSetState(State_Paused);
}

STDMETHODIMP CMediaStreamFilter::Run(REFERENCE_TIME tStart)
{
    AUTO_CRIT_LOCK;
    m_rtStart = tStart;
    return SyncSetState(State_Running);
}

STDMETHODIMP CMediaStreamFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    *State = m_State;
    if (m_State == State_Paused) {

        //  Since we don't sending data until we're running for write
        //  streams just say we can't cue
        if (m_Streams.Size() != 0) {
            STREAM_TYPE Type;
            m_Streams.Element(0)->GetInformation(NULL, &Type);
            if (Type == STREAMTYPE_WRITE) {
                return VFW_S_CANT_CUE;
            }
        }
    }
    return S_OK;
}

STDMETHODIMP CMediaStreamFilter::SetSyncSource(IReferenceClock *pClock)
{
    CAutoLock lck(&m_csCallback);
    m_pClock = pClock;
    return NOERROR;
}

STDMETHODIMP CMediaStreamFilter::GetSyncSource(IReferenceClock **pClock)
{
    CAutoLock lck(&m_csCallback);
    if (m_pClock) {
        m_pClock.p->AddRef();
    }
    *pClock = m_pClock;
    return NOERROR;
}

STDMETHODIMP CMediaStreamFilter::EnumPins(IEnumPins ** ppEnum)
{
    if (ppEnum == NULL) {
        return E_POINTER;
    }
    *ppEnum = NULL;

    /* Create a new ref counted enumerator */

    typedef CComObject<CAMEnumInterface<IEnumPins,
                                        &IID_IEnumPins,
                                        IPin
                                       >
                      > _CEnumPins;

    _CEnumPins *pEnum = new _CEnumPins;
    if (pEnum == NULL) {
        return E_OUTOFMEMORY;
    }
    HRESULT hr = pEnum->FinalConstruct();
    if (SUCCEEDED(hr)) {
        for (int i = 0; i < m_Streams.Size(); i++) {
            if (!pEnum->Add((PPIN)CComQIPtr<IPin, &IID_IPin>(m_Streams.Element(i)))) {
                delete pEnum;
                return E_OUTOFMEMORY;
            }
        }
    } else {
        delete pEnum;
        return hr;
    }

    return pEnum->QueryInterface(IID_IEnumPins, (void **)ppEnum);
}

STDMETHODIMP CMediaStreamFilter::FindPin(LPCWSTR Id, IPin ** ppPin)
{
    if (ppPin == NULL) {
        return E_POINTER;
    }

    AUTO_CRIT_LOCK;
    IEnumPins *pEnum;
    HRESULT hr = EnumPins(&pEnum);
    if (FAILED(hr)) {
        return hr;
    }
    IPin *pPin;
    hr = VFW_E_NOT_FOUND;
    for ( ; ; ) {
        ULONG cFetched;
        if (S_OK != pEnum->Next(1, &pPin, &cFetched)) {
            break;
        }
        LPWSTR lpszId;
        if (SUCCEEDED(pPin->QueryId(&lpszId))) {
            if (0 == lstrcmpW(lpszId, Id)) {
                *ppPin = pPin;
                CoTaskMemFree(lpszId);
                hr = S_OK;
                break;
            }
            CoTaskMemFree(lpszId);
        }
        pPin->Release();
    }
    pEnum->Release();
    return hr;
}


STDMETHODIMP CMediaStreamFilter::QueryFilterInfo(FILTER_INFO * pInfo)
{
    AUTO_CRIT_LOCK;
    pInfo->achName[0] = L'\0';
    pInfo->pGraph = m_pGraph;
    if (pInfo->pGraph) {
        pInfo->pGraph->AddRef();
    }
    return NOERROR;
}

STDMETHODIMP CMediaStreamFilter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    AUTO_CRIT_LOCK;
    m_pGraph = pGraph;
    for (int i = 0; i < m_Streams.Size(); i++) {
        //  This will not fail
        m_Streams.Element(i)->JoinFilterGraph(pGraph);
    }
    return NOERROR;
}



///////// IMediaStreamFILTER ///////////////


STDMETHODIMP CMediaStreamFilter::AddMediaStream(IAMMediaStream *pAMMediaStream)
{
    AUTO_CRIT_LOCK;
    IMediaStream *pMediaStream;
    HRESULT hr = pAMMediaStream->QueryInterface(
        IID_IMediaStream, (void **)&pMediaStream);
    if (FAILED(hr)) {
        return hr;
    }
    MSPID PurposeID;
    EXECUTE_ASSERT(SUCCEEDED(pMediaStream->GetInformation(&PurposeID, NULL)));
    IMediaStream *pStreamTemp;

    //  Note - this test covers the case of being passed the same object
    //  twice if you think about it
    if (S_OK == GetMediaStream(PurposeID, &pStreamTemp)) {
        pStreamTemp->Release();
        return MS_E_PURPOSEID;
    }
    pMediaStream->Release();

    hr = pAMMediaStream->JoinFilter(this);
    if (SUCCEEDED(hr)) {
        hr = pAMMediaStream->JoinFilterGraph(m_pGraph);
        if (SUCCEEDED(hr)) {
            /*  Add() will Addref through the copy constructor
                of CComPtr
            */
            if (!m_Streams.Add(pAMMediaStream)) {
                pAMMediaStream->JoinFilterGraph(NULL);
                pAMMediaStream->JoinFilter(NULL);
                hr = E_OUTOFMEMORY;
            }
        } else {
            pAMMediaStream->JoinFilter(NULL);
        }
    }
    return hr;
}

STDMETHODIMP CMediaStreamFilter::EnumMediaStreams(
    long lIndex,
    IMediaStream **ppMediaStream
)
{
    AUTO_CRIT_LOCK;
    if (lIndex < 0 || lIndex >= m_Streams.Size()) {
        return S_FALSE;
    }
    return m_Streams.Element(lIndex)->QueryInterface(
        IID_IMediaStream,
        (void **)ppMediaStream);
}
STDMETHODIMP CMediaStreamFilter::GetMediaStream(REFGUID PurposeId, IMediaStream ** ppMediaStream)
{
    AUTO_CRIT_LOCK;
    if (ppMediaStream == NULL) {
        return E_POINTER;
    }
    int i = 0;
    HRESULT hr = MS_E_NOSTREAM;
    while (i < m_Streams.Size()) { // Does not addref!!!
        IMediaStream *pStream;
        GUID ThisPurpose;
        EXECUTE_ASSERT(SUCCEEDED(m_Streams.Element(i)->
            QueryInterface(IID_IMediaStream, (void **)&pStream)));
        EXECUTE_ASSERT(SUCCEEDED(pStream->GetInformation(&ThisPurpose, NULL)));
        if (ThisPurpose == PurposeId) {
            *ppMediaStream = pStream;
            hr = S_OK;
            break;
        } else {
            pStream->Release();
        }
        i++;
    }
    return hr;
}

STDMETHODIMP CMediaStreamFilter::SupportSeeking(BOOL fRenderer)
{
    // Look for a stream that supports seeking
    HRESULT hrResult = E_NOINTERFACE;
    if (m_pUnknownSeekAgg != NULL) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }
    for (int i = 0; FAILED(hrResult) && i < m_Streams.Size(); i++) {
        IAMMediaStream *pAMMediaStream = m_Streams.Element(i);
        IPin *pPin;
        HRESULT hr = pAMMediaStream->QueryInterface(IID_IPin, (void **)&pPin);
        if (SUCCEEDED(hr)) {

            //  See if it supports GetDuration() so we get a real
            //  seeking pin
            IPin *pConnected;
            hr = pPin->ConnectedTo(&pConnected);
            if (SUCCEEDED(hr)) {
                IMediaSeeking *pSeeking;
                hr = pConnected->QueryInterface(IID_IMediaSeeking, (void **)&pSeeking);
                if (SUCCEEDED(hr)) {
                    LONGLONG llDuration;
                    if (S_OK != pSeeking->GetDuration(&llDuration)) {
                        hr = E_FAIL;
                    }
                    pSeeking->Release();
                }
                pConnected->Release();
            }
            if (SUCCEEDED(hr)) {
                hr = CoCreateInstance(CLSID_SeekingPassThru, GetControllingUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown,
                                      (void **)&m_pUnknownSeekAgg);
            }
            if (SUCCEEDED(hr)) {
                ISeekingPassThru *pSeekingPassThru;
                hr = m_pUnknownSeekAgg->QueryInterface(IID_ISeekingPassThru, (void **)&pSeekingPassThru);
                if (SUCCEEDED(hr)) {
                    hrResult = pSeekingPassThru->Init(fRenderer, pPin);
                    pSeekingPassThru->Release();
                } else {
                    m_pUnknownSeekAgg->Release();
                    m_pUnknownSeekAgg = NULL;
                }
            }
            pPin->Release();
        }
    }
    return hrResult;

}


STDMETHODIMP CMediaStreamFilter::ReferenceTimeToStreamTime(REFERENCE_TIME *pTime)
{
    CAutoLock lck(&m_csCallback);
    if (m_pClock) {
        *pTime -= m_rtStart;
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP CMediaStreamFilter::GetCurrentStreamTime(REFERENCE_TIME *pCurrentStreamTime)
{
    CAutoLock lck(&m_csCallback);
    if (m_pClock && m_State == State_Running) {
        m_pClock->GetTime(pCurrentStreamTime);
        *pCurrentStreamTime -= m_rtStart;
        return S_OK;
    } else {
        *pCurrentStreamTime = 0;
        return S_FALSE;
    }
}


STDMETHODIMP CMediaStreamFilter::WaitUntil(REFERENCE_TIME WaitTime)
{
    HRESULT hr;

    //  OK to lock here because the caller should not lock during a wait
    m_csCallback.Lock();
    if (!m_pClock) {
        hr = E_FAIL;
    } else {
        if (!m_pFirstFreeAlarm) {
            hr = CAlarm::CreateNewAlarm(&m_pFirstFreeAlarm);
            if (FAILED(hr)) {
                m_csCallback.Unlock();
                return hr;
            }
        }
        CAlarm *pAlarm = m_pFirstFreeAlarm;
        ResetEvent(pAlarm->m_hEvent);
        hr = m_pClock->AdviseTime(WaitTime, m_rtStart, (HEVENT)pAlarm->m_hEvent, &pAlarm->m_dwStupidCookie);
        if (SUCCEEDED(hr)) {
            m_pFirstFreeAlarm = pAlarm->m_pNext;
            pAlarm->m_bKilled = false;
            pAlarm->m_pNext = m_pFirstActiveAlarm;
            m_pFirstActiveAlarm = pAlarm;
            m_csCallback.Unlock();
            WaitForSingleObject(pAlarm->m_hEvent, INFINITE);
            m_csCallback.Lock();
            CAlarm **ppCurrent = &m_pFirstActiveAlarm;
            while (*ppCurrent != pAlarm) {
                ppCurrent = &(*ppCurrent)->m_pNext;
                _ASSERTE(*ppCurrent != NULL);
            }
            *ppCurrent = pAlarm->m_pNext;
            pAlarm->m_pNext = m_pFirstFreeAlarm;
            m_pFirstFreeAlarm = pAlarm;
            hr = pAlarm->m_bKilled ? S_FALSE : S_OK;
        }
    }
    m_csCallback.Unlock();
    return hr;
}


STDMETHODIMP CMediaStreamFilter::Flush(BOOL bCancelEOS)
{
    CAutoLock lck(&m_csCallback);

    if (bCancelEOS) {
        m_nAtEOS--;
    }
    _ASSERTE(m_nAtEOS >= 0);
    FlushTimers();
    return S_OK;
}

STDMETHODIMP CMediaStreamFilter::EndOfStream()
{
    CAutoLock lck(&m_csCallback);

    _ASSERTE(m_nAtEOS < m_Streams.Size());
    m_nAtEOS++;
    CheckComplete();
    return S_OK;
}

void CMediaStreamFilter::FlushTimers(void)
{
    CAutoLock lck(&m_csCallback);
    for (CAlarm *pCurAlarm = m_pFirstActiveAlarm; pCurAlarm; pCurAlarm = pCurAlarm->m_pNext) {
        pCurAlarm->m_bKilled = (m_pClock->Unadvise(pCurAlarm->m_dwStupidCookie) == S_OK);
        SetEvent(pCurAlarm->m_hEvent);
    }
}


void CMediaStreamFilter::CheckComplete()
{
    if (m_State == State_Running && m_nAtEOS == m_Streams.Size() &&
        //  Must support IMediaSeeking to be a renderer
        m_pUnknownSeekAgg != NULL
       ) {
        IMediaEventSink *pSink;
        HRESULT hr = m_pGraph->QueryInterface(IID_IMediaEventSink, (void **)&pSink);
        if (SUCCEEDED(hr)) {
            pSink->Notify(EC_COMPLETE, 0, 0);
            pSink->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\stdafx.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#define DO_OUR_GUIDS
#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

//#undef _WINGDI_ // Avoid declaration bug in ATL
#include <atlimpl.cpp>

#if 0
//  HACK to make it build with libcmt.lib
int _CRTAPI1 main(int argc, char *argv[])
{
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\strmobjs.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu Mar 13 14:07:13 1997
 */
/* Compiler settings for strmobjs.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __strmobjs_h__
#define __strmobjs_h__

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

#ifndef __STRMOBJSLib_LIBRARY_DEFINED__
#define __STRMOBJSLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: STRMOBJSLib
 * at Thu Mar 13 14:07:13 1997
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */



EXTERN_C const IID LIBID_STRMOBJSLib;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_SFilter;

class DECLSPEC_UUID("242C8F4F-9AE6-11D0-8212-00C04FC32C45")
SFilter;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_MMStream;

class DECLSPEC_UUID("FF146E02-9AED-11D0-8212-00C04FC32C45")
MMStream;
#endif
#endif /* __STRMOBJSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\sfilter.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// SFilter.h : Declaration of the CMediaStreamFilter

#ifndef __SFILTER_H_
#define __SFILTER_H_

#include "resource.h"       // main symbols

class CMediaStreamFilter;

class CAlarm
{
friend CMediaStreamFilter;
public:
    CAlarm();
    ~CAlarm();
    static HRESULT CreateNewAlarm(CAlarm **ppNewAlarm);
public:
    CAlarm          *m_pNext;
    HANDLE          m_hEvent;
    DWORD_PTR       m_dwStupidCookie;
    bool            m_bKilled;
};


/////////////////////////////////////////////////////////////////////////////
// CMediaStreamFilter
class ATL_NO_VTABLE CMediaStreamFilter :
        public CComObjectRootEx<CComMultiThreadModel>,
        public CComCoClass<CMediaStreamFilter, &CLSID_MediaStreamFilter>,
        public IMediaStreamFilter
{
public:
        DECLARE_GET_CONTROLLING_UNKNOWN()
        CMediaStreamFilter();
#ifdef DEBUG
        ~CMediaStreamFilter() {}
#endif
        void FinalRelease();

        //  IPersist
        STDMETHODIMP GetClassID(CLSID *pClsID);

        //  IBaseFilter
        STDMETHODIMP Stop();
        STDMETHODIMP Pause();
        STDMETHODIMP Run(REFERENCE_TIME tStart);
        STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
        STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
        STDMETHODIMP GetSyncSource(IReferenceClock **pClock);
        STDMETHODIMP EnumPins(IEnumPins ** ppEnum);
        STDMETHODIMP FindPin(LPCWSTR Id, IPin ** ppPin);
        STDMETHODIMP QueryFilterInfo(FILTER_INFO * pInfo);
        STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

        //  We're not a general purpose filter so we don't need this
        STDMETHODIMP QueryVendorInfo(LPWSTR* pVendorInfo) {return E_NOTIMPL;};

        //  IMediaStreamFilter
        STDMETHODIMP AddMediaStream(IAMMediaStream *pMediaStream);
        STDMETHODIMP GetMediaStream(REFGUID PurposeID, IMediaStream ** ppMediaStream);
        STDMETHODIMP EnumMediaStreams(long Index, IMediaStream ** ppMediaStream);
        STDMETHODIMP SupportSeeking(BOOL fRenderer);
        STDMETHODIMP ReferenceTimeToStreamTime(REFERENCE_TIME *pTime);
        STDMETHODIMP GetCurrentStreamTime(REFERENCE_TIME *pCurrentStreamTime);
        STDMETHODIMP WaitUntil(REFERENCE_TIME WaitStreamTime);
        STDMETHODIMP Flush(BOOL bCancelEOS);
        STDMETHODIMP EndOfStream();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_SFILTER)

BEGIN_COM_MAP(CMediaStreamFilter)
        COM_INTERFACE_ENTRY(IMediaStreamFilter)
        COM_INTERFACE_ENTRY2(IMediaFilter, IMediaStreamFilter)
        COM_INTERFACE_ENTRY2(IBaseFilter, IMediaStreamFilter)
        COM_INTERFACE_ENTRY2(IPersist, IMediaStreamFilter)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMediaSeeking, m_pUnknownSeekAgg)
END_COM_MAP()

private:
        void FlushTimers();
        void CheckComplete();
        HRESULT SyncSetState(FILTER_STATE State);

        //  Different lower level lock for being called back from streams
        //  otherwise we deadlock
        //  Also declare this first in case it gets used when the
        //  streams get destroyed
        CCritSec                 m_csCallback;


        CDynamicArray<IAMMediaStream *, CComPtr<IAMMediaStream> > m_Streams;
        FILTER_STATE    	 m_State;

        IFilterGraph    	*m_pGraph;
        CComPtr<IMediaPosition>	 m_pMediaPosition;
        CComPtr<IReferenceClock> m_pClock;
        REFERENCE_TIME          m_rtStart;

        //  Unknown goes first since it is released last
        IUnknown *                m_pUnknownSeekAgg;

        //
        //  Alarm lists
        //
        CAlarm                  *m_pFirstFreeAlarm;
        CAlarm                  *m_pFirstActiveAlarm;

        //  End of stream tracking
        int                      m_nAtEOS;

};

#endif //__SFILTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\strmobjs.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// strmobjs.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f strmobjsps.mk in the project directory.

#define CPP_FUNCTIONS
#include "stdafx.h"
#include <ddraw.h>
#include "resource.h"
#include "strmobjs.h"
//#include "strmobjs_i.c"
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <amutil.h>
#include "stream.h"
#include "ddstrm.h"
#include "sample.h"
#include "util.h"
#include "bytestrm.h"
#include "austrm.h"
#include <initguid.h>
#include "ddrawex.h"
#include "amguids.h"
#include "SFilter.h"
#include "ammstrm.h"
#include "mss.h"
#include "medsampl.h"

CComModule _Module;

//  Debugging
#ifdef DEBUG
BOOL bDbgTraceFunctions;
BOOL bDbgTraceInterfaces;
BOOL bDbgTraceTimes;
#endif

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_MediaStreamFilter, CMediaStreamFilter)
    OBJECT_ENTRY(CLSID_AMMultiMediaStream, CMMStream)
    OBJECT_ENTRY(CLSID_AMDirectDrawStream, CDDStream)
    OBJECT_ENTRY(CLSID_AMAudioStream, CAudioStream)
    OBJECT_ENTRY(CLSID_AMAudioData, CAudioData)
    OBJECT_ENTRY(CLSID_AMMediaTypeStream, CAMMediaTypeStream)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef DEBUG
        bDbgTraceFunctions = GetProfileInt(_T("AMSTREAM"), _T("Functions"), 0);
        bDbgTraceInterfaces = GetProfileInt(_T("AMSTREAM"), _T("Interfaces"), 0);
        bDbgTraceTimes = GetProfileInt(_T("AMSTREAM"), _T("TimeStamps"), 0);
#endif
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();

    TRACEFUNC(_T("DllEntryPoint(0x%8.8X, %d, 0x%8.8X\n)"),
              hInstance, dwReason, 0);
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    TRACEFUNC(_T("DllCanUnloadNow\n"));
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    TRACEFUNC(_T("DllGetClassObject(%s, %s, 0x%8.8X)\n"),
              TextFromGUID(rclsid), TextFromGUID(riid), ppv);
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    TRACEFUNC(_T("DllRegisterServer\n"));
    // registers object, typelib and all interfaces in typelib
    HRESULT hr = _Module.RegisterServer(TRUE);
    // Don't care if the typelib doesn't load on win95 gold
    if (hr == TYPE_E_INVDATAREAD || hr == TYPE_E_CANTLOADLIBRARY) {
        hr = S_OK;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TRACEFUNC(_T("DllUnregisterServer\n"));
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\streams\strmobjs\stdafx.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#define _ATL_STATIC_REGISTRY
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__242C8F45_9AE6_11D0_8212_00C04FC32C45__INCLUDED_)
#define AFX_STDAFX_H__242C8F45_9AE6_11D0_8212_00C04FC32C45__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
//#include "crtfree.h"
#include <atlcom.h>
#include <ddraw.h>
#include <mmstream.h>
#include <ddstream.h>
#include <amstream.h>
#include <austream.h>


//  Debugging
#ifdef DEBUG
extern BOOL bDbgTraceFunctions;
extern BOOL bDbgTraceInterfaces;
extern BOOL bDbgTraceTimes;
LPWSTR inline TextFromGUID(REFGUID guid) {
    WCHAR *pch = (WCHAR *)_alloca((CHARS_IN_GUID + 1) * sizeof(WCHAR));
    StringFromGUID2(guid, pch, (CHARS_IN_GUID + 1) * sizeof(TCHAR));
    return pch;
}
LPTSTR inline TextFromPurposeId(REFMSPID guid) {
    if (guid == MSPID_PrimaryAudio) {
        return _T("MSPID_PrimaryAudio");
    } else
    if (guid == MSPID_PrimaryVideo) {
        return _T("MSPID_PrimaryVideo");
    } else
    {
        return _T("Unrecognized PurposeId");
    }
}
#define TRACEFUNC  if (bDbgTraceFunctions) ATLTRACE(_T("AMSTREAM.DLL : ")), ATLTRACE
#define TRACEINTERFACE if (bDbgTraceFunctions || bDbgTraceInterfaces) ATLTRACE(_T("AMSTREAM.DLL : ")), ATLTRACE
#else
#define TRACEFUNC ATLTRACE
#define TRACEINTERFACE ATLTRACE
#define TextFromGUID(_x_) 0
#define TextFromPurposeId(_x_) 0
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__242C8F45_9AE6_11D0_8212_00C04FC32C45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\bnetvw.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetvw.cpp : defines CBoxNetView
//

#include "stdafx.h"
#include <activecf.h>                   // Quartz clipboard definitions
#include <measure.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBoxNetView, CScrollView)

/////////////////////////////////////////////////////////////////////////////
// construction and destruction


CBoxNetView::CBoxNetView() :
    m_fMouseDrag(FALSE),
    m_fMoveBoxSelPending(FALSE),
    m_fMoveBoxSel(FALSE),
    m_fGhostSelection(FALSE),
    m_fSelectRect(FALSE),
    m_pSelectClockFilter(NULL),
    m_fNewLink(FALSE),
    m_fGhostArrow(FALSE),
    m_psockHilite(NULL)
{
    CString szMeasurePath;
    szMeasurePath.LoadString(IDS_MEASURE_DLL);

    m_hinstPerf = LoadLibrary(szMeasurePath);

}


//
// Destructor
//
CBoxNetView::~CBoxNetView() {
#if 0
// THIS DOES NOT BELONG HERE!!
// THIS HAS TO BE AT THE VERY END OF THE APPLICATION
// THINGS GO ON *AFTER* THIS POINT AND THEY ACCESS VIOLATE WITH THIS HERE
    if (m_hinstPerf) {
        // allow perf library to clean up!
        CString szTerminateProc;
        szTerminateProc.LoadString(IDS_TERMINATE_PROC);

        typedef void WINAPI MSR_TERMINATE_PROC(void);

        MSR_TERMINATE_PROC *TerminateProc;
        TerminateProc =
            (MSR_TERMINATE_PROC *) GetProcAddress(m_hinstPerf, szTerminateProc);

        if (TerminateProc) {
            TerminateProc();
        }
        else {
            AfxMessageBox(IDS_NO_TERMINATE_PROC);
        }

        FreeLibrary(m_hinstPerf);
    }
#endif
}


/////////////////////////////////////////////////////////////////////////////
// diagnostics


#ifdef _DEBUG
void CBoxNetView::AssertValid() const
{
    CScrollView::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CBoxNetView::Dump(CDumpContext& dc) const
{
    CScrollView::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// general public functions

//
// OnInitialUpdate
//
// Set the initial scroll size
void CBoxNetView::OnInitialUpdate(void) {

    SetScrollSizes(MM_TEXT, GetDocument()->GetSize());

    CScrollView::OnInitialUpdate();

    GetDocument()->m_hWndPostMessage = m_hWnd;

    CGraphEdit * pMainFrame = (CGraphEdit*) AfxGetApp( );
    CWnd * pMainWnd = pMainFrame->m_pMainWnd;
    CMainFrame * pF = (CMainFrame*) pMainWnd;

    pF->ToggleSeekBar( 0 );

    // If the seek timer is NOT already running, start it
    pF->m_hwndTimer = m_hWnd;
    if ((!pF->m_nSeekTimerID) && (pF->m_bSeekEnabled))
        pF->m_nSeekTimerID = ::SetTimer( m_hWnd, TIMER_SEEKBAR, 200, NULL );
}


/* OnUpdate()
 *
 * pHint can be a pointer to a CBox, if only that CBox needs to be redrawn.
 */
void CBoxNetView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
    CBox *      pbox;
    CBoxSocket *psock;
    CBoxLink *  plink;
    CRect       rc;

    SetScrollSizes(MM_TEXT, GetDocument()->GetSize());

    switch ((int) lHint)
    {

    case CBoxNetDoc::HINT_DRAW_ALL:

        // repaint entire window
//        TRACE("HINT_DRAW_ALL\n");
        InvalidateRect(NULL, TRUE);
        break;

    case CBoxNetDoc::HINT_CANCEL_VIEWSELECT:

        // cancel any selection maintained by the view
//        TRACE("HINT_CANCEL_VIEWSELECT\n");
        break;

    case CBoxNetDoc::HINT_CANCEL_MODES:

        // cancel modes like select rectangle, drag boxes, etc.
//        TRACE("HINT_CANCEL_MODES\n");
        CancelModes();
        break;

    case CBoxNetDoc::HINT_DRAW_BOX:

        // repaint given box
        pbox = (CBox *) pHint;
        gpboxdraw->GetOrInvalBoundRect(pbox, &rc, FALSE, this);
//        TRACE("HINT_DRAW_BOX: (%d,%d,%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);
        break;

    case CBoxNetDoc::HINT_DRAW_BOXANDLINKS:

        // repaint given box
        pbox = (CBox *) pHint;
        gpboxdraw->GetOrInvalBoundRect(pbox, &rc, TRUE, this);
//        TRACE("HINT_DRAW_BOXANDLINKS: (%d,%d,%d,%d)\n", rc.left, rc.top, rc.right, rc.bottom);
        break;

    case CBoxNetDoc::HINT_DRAW_BOXTAB:

        // repaint given box tab
        psock = (CBoxSocket *) pHint;
        gpboxdraw->DrawTab(psock, &rc, NULL, FALSE, FALSE);
//        TRACE("HINT_DRAW_BOXTAB\n");
        InvalidateRect(&(rc - GetScrollPosition()), TRUE);
        break;

    case CBoxNetDoc::HINT_DRAW_LINK:

        // repaint given link
        plink = (CBoxLink *) pHint;
        gpboxdraw->GetOrInvalLinkRect(plink, &rc, this);
//        TRACE("HINT_DRAW_LINK\n");
        break;



    }
}


void CBoxNetView::OnDraw(CDC* pdc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CRect           rc;

    if (pdc->IsPrinting()) {
        pdc->SetMapMode(MM_ISOTROPIC);

        CSize DocSize = GetDocument()->GetSize();
        CSize PrintSize(pdc->GetDeviceCaps(HORZRES),pdc->GetDeviceCaps(VERTRES));

        if ((DocSize.cx != 0) && (DocSize.cy != 0)) {
            // choose smaller of PrintX/docX or PrintY/DocY as isotropic scale factor
            if (PrintSize.cx * DocSize.cy < PrintSize.cy * DocSize.cx) {
                PrintSize.cy = (DocSize.cy * PrintSize.cx) / DocSize.cx;
                PrintSize.cx = (DocSize.cx * PrintSize.cx) / DocSize.cx;
            }
            else {
                PrintSize.cx = (DocSize.cx * PrintSize.cy) / DocSize.cx;
                PrintSize.cy = (DocSize.cy * PrintSize.cy) / DocSize.cx;
            }
        }

        pdc->SetWindowExt(DocSize);
        pdc->SetViewportExt(PrintSize);
    }
    else {
        pdc->SetMapMode(MM_TEXT);
    }

    // save the clipping region
    pdc->SaveDC();

    // draw all boxes in list that might be within clipping region
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (pdc->RectVisible(pbox->GetRect()))
        {
//            TRACE("draw box 0x%08lx\n", (LONG) (LPCSTR) pbox);
            gpboxdraw->DrawBox(pbox, pdc, m_psockHilite);
        }
    }

    if (!pdc->IsPrinting()) {
        // fill the unpainted portion of the window with background color
        pdc->GetClipBox(&rc);
        CBrush br(gpboxdraw->GetBackgroundColor());
        CBrush *pbrPrev = pdc->SelectObject(&br);
        pdc->PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATCOPY);
        if (pbrPrev != NULL)
            pdc->SelectObject(pbrPrev);
    }

    // restore the clipping region
    pdc->RestoreDC(-1);

    // draw all links that might be within clipping region
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = (CBoxLink *) pdoc->m_lstLinks.GetNext(pos);
        gpboxdraw->GetOrInvalLinkRect(plink, &rc);
        if (pdc->RectVisible(&rc))
        {
//            TRACE("draw link 0x%08lx\n", (LONG) (LPCSTR) plink);
            gpboxdraw->DrawLink(plink, pdc);
        }
    }

    // paint the ghost selection (if it's currently visible)
    if (m_fGhostSelection)
        GhostSelectionDraw(pdc);

    // paint the ghost arrow (if it's currently visible)
    if (m_fGhostArrow)
        GhostArrowDraw(pdc);

    // paint the select-rectangle rectangle (if we're in that mode)
    if (m_fSelectRect)
        SelectRectDraw(pdc);
}


/* eHit = HitTest(pt, ppbox, ptabpos, ppsock, pplink, pptProject, ppbend)
 *
 * See if <pt> hits something in the view.
 *
 * If <pt> hits a link, return the HT_XXX code, and set <**pplink>,
 * <*pptProject>, and/or <*ppbend>, as defined by CBoxDraw::HitTestLink().
 * If not, set <*pplink> to NULL.
 *
 * If <pt> hits a box, return the HT_XXX code, set <*ppbox>, <*ptabpos> and/or
 * <*ppsock>, as defined by CBoxDraw::HitTestBox().  If not, set <*ppbox>
 * to NULL.
 *
 * If <pt> hits nothing, return HT_MISS.
 */
CBoxDraw::EHit CBoxNetView::HitTest(CPoint pt, CBox **ppbox,
    CBoxTabPos *ptabpos, CBoxSocket **ppsock, CBoxLink **pplink,
    CPoint *pptProject)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBoxDraw::EHit  eHit;           // hit-test result code
    POSITION        pos;            // position in linked list

    // these pointers must be NULL if they aren't valid
    *ppbox = NULL;
    *pplink = NULL;

    // adjust for the current scroll position
    pt += CSize(GetDeviceScrollPosition());

    // see if <pt> hits any box
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        *ppbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        eHit = gpboxdraw->HitTestBox(*ppbox, pt, ptabpos, ppsock);
        if (eHit != CBoxDraw::HT_MISS)
            return eHit;
    }
    *ppbox = NULL;

    // see if <pt> hits any link
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        *pplink = (CBoxLink *) pdoc->m_lstLinks.GetNext(pos);
        eHit = gpboxdraw->HitTestLink(*pplink, pt, pptProject);
        if (eHit != CBoxDraw::HT_MISS)
            return eHit;
    }
    *pplink = NULL;

    // hit the background
    return CBoxDraw::HT_MISS;
}



/* CancelModes()
 *
 * Cancel all CBoxNetView modes (e.g. mouse-drag mode, move-selection mode,
 * etc.), including deselecting anything selected in the view (but not
 * including items for which the document maintains the selection state).
 * This is a superset of CancelViewSelection().
 */
void CBoxNetView::CancelModes()
{
    if (m_fMouseDrag)
        MouseDragEnd();
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingEnd(TRUE);
    if (m_fMoveBoxSel)
        MoveBoxSelEnd(TRUE);
    if (m_fGhostSelection)
        GhostSelectionDestroy();
    if (m_fSelectRect)
        SelectRectEnd(TRUE);
    if (m_fNewLink)
        NewLinkEnd(TRUE);
    if (m_fGhostArrow)
        GhostArrowEnd();
    if (m_psockHilite != NULL)
        SetHiliteTab(NULL);
}


/////////////////////////////////////////////////////////////////////////////
// printing support


BOOL CBoxNetView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}


void CBoxNetView::OnBeginPrinting(CDC* /*pdc*/, CPrintInfo* /*pInfo*/)
{
}


void CBoxNetView::OnEndPrinting(CDC* /*pdc*/, CPrintInfo* /*pInfo*/)
{
}


/////////////////////////////////////////////////////////////////////////////
// mouse-drag mode


/* MouseDragBegin(nFlags, pt, pboxMouse)
 *
 * Enter mouse-drag mode.  In this mode, the mouse is captured, and the
 * following information is maintained:
 *   -- <m_fMouseShift>: TRUE if Shift held down when mouse clicked;
 *   -- <m_ptMouseAnchor>: the point at which the click occurred;
 *   -- <m_ptMousePrev>: the previous position of the mouse (as specified
 *      in the previous call to MouseDragBegin() or MouseDragContinue();
 *   -- <m_pboxMouse>: set to <pboxMouse>, which should point to the
 *      initially clicked-on box (or NULL if none);
 *   -- <m_fMouseBoxSel>: TRUE if clicked-on box was initially selected.
 */
void CBoxNetView::MouseDragBegin(UINT nFlags, CPoint pt, CBox *pboxMouse)
{
    m_fMouseDrag = TRUE;
    m_fMouseShift = ((nFlags & MK_SHIFT) != 0);
    m_ptMouseAnchor = m_ptMousePrev = pt;
    m_pboxMouse = pboxMouse;
    m_fMouseBoxSel = (pboxMouse == NULL ? FALSE : pboxMouse->IsSelected());
    SetCapture();
}


/* MouseDragContinue(pt)
 *
 * Continue mouse-drag mode (initiated by MouseDragBegin()), and specify
 * that the current mouse position is at <pt> (which causes <m_ptMousePrev>
 * to be set to this value).
 */
void CBoxNetView::MouseDragContinue(CPoint pt)
{
    m_ptMousePrev = pt;
}


/* MouseDragEnd()
 *
 * End mouse-drag mode (initiated by MouseDragBegin().
 */
void CBoxNetView::MouseDragEnd()
{
    m_fMouseDrag = FALSE;
    if (this == GetCapture())
        ReleaseCapture();
}


/////////////////////////////////////////////////////////////////////////////
// move-selection-pending mode (for use within mouse-drag mode)

/* MoveBoxSelPendingBegin(pt)
 *
 * Enter move-selection-pending mode.  In this mode, if the user waits long
 * enough, or drags the mouse far enough, the user enters move-selection mode
 * (in which the selected boxes and connected links are dragged to a new
 * location).  If not (i.e. if the user releases the mouse button quickly,
 * without dragging far) then if the user shift-clicked on a selected box then
 * the box is deselected.
 *
 * <pt> is the current location of the mouse.
 */
void CBoxNetView::MoveBoxSelPendingBegin(CPoint pt)
{
    m_fMoveBoxSelPending = TRUE;

    // set <m_rcMoveSelPending>; if the mouse leaves this rectangle
    // end move-selection-pending mode and begin move-selection mode
    CSize siz = CSize(GetSystemMetrics(SM_CXDOUBLECLK),
                      GetSystemMetrics(SM_CYDOUBLECLK));
    m_rcMoveSelPending = CRect(pt - siz, siz + siz);

    // set a timer to potentially end move-selection-pending mode
    // and begin move-selection mode
    SetTimer(TIMER_MOVE_SEL_PENDING, GetDoubleClickTime(), NULL);

    MFGBL(SetStatus(IDS_STAT_MOVEBOX));
}


/* MoveBoxSelPendingContinue(pt)
 *
 * Continue move-selection-pending mode.  See if the user dragged the mouse
 * (which is at <pt>) far enough to enter move-selection mode.
 */
void CBoxNetView::MoveBoxSelPendingContinue(CPoint pt)
{
    if (!m_rcMoveSelPending.PtInRect(pt))
    {
        // mouse moved far enough -- end move-selection-pending mode
        MoveBoxSelPendingEnd(FALSE);
    }
}


/* MoveBoxSelPendingEnd(fCancel)
 *
 * End move-selection-pending mode.  If <fCancel> is FALSE, then enter
 * move-selection mode.  If <fCancel> is TRUE, then if the user shift-clicked
 * on a selecte box, deselect it.
 */
void CBoxNetView::MoveBoxSelPendingEnd(BOOL fCancel)
{
    CBoxNetDoc *    pdoc = GetDocument();

    // end move-selection-pending mode
    m_fMoveBoxSelPending = FALSE;
    KillTimer(TIMER_MOVE_SEL_PENDING);

    if (fCancel)
    {
        // if the user shift-clicked a selected box, deselect it
        if (m_fMouseShift && m_fMouseBoxSel)
            pdoc->SelectBox(m_pboxMouse, FALSE);
    }
    else
    {
        // begin move-selection mode
        MoveBoxSelBegin();

        // give the user some feedback immediately (rather than waiting until
        // they move the mouse)
        CPoint pt;
        ::GetCursorPos(&pt);
        ScreenToClient(&pt);
        MoveBoxSelContinue(pt - m_ptMouseAnchor);
    }
}


/////////////////////////////////////////////////////////////////////////////
// move-selection mode


/* MoveBoxSelBegin()
 *
 * Enter into move-selection mode.  While in this mode, the selection is
 * not actually moved (until the mode is ended).  Instead, a ghost selection
 * is moved.
 */
void CBoxNetView::MoveBoxSelBegin()
{
    GhostSelectionCreate();
    m_fMoveBoxSel = TRUE;
    MFGBL(SetStatus(IDS_STAT_MOVEBOX));
}


/* MoveBoxSelContinue(sizOffset)
 *
 * Continue move-selection mode.  Request that the ghost selection (showing
 * where the selection would be moved to if it were dropped right now)
 * move to offset <sizOffset> from the selection location.
 */
void CBoxNetView::MoveBoxSelContinue(CSize sizOffset)
{
    GhostSelectionMove(sizOffset);
}


/* MoveBoxSelEnd(fCancel)
 *
 * End move-selection mode.  If <fCancel> is FALSE, then move the selection
 * to where the ghost selection was moved by calls to MoveBoxSelContinue().
 * If <fCancel> is TRUE, don't move the selection.
 */
void CBoxNetView::MoveBoxSelEnd(BOOL fCancel)
{
    GhostSelectionDestroy();

    m_fMoveBoxSel = FALSE;

    if (!fCancel)
        MoveBoxSelection(m_sizGhostSelOffset);
}


/* MoveBoxSelection(sizOffset)
 *
 * Create and execute a command to move each selected box by <sizOffset>.
 */
void CBoxNetView::MoveBoxSelection(CSize sizOffset)
{
    CBoxNetDoc *    pdoc = GetDocument();

    pdoc->CmdDo(new CCmdMoveBoxes(sizOffset));
}


/* sizOffsetNew = ConstrainMoveBoxSel(sizOffset, fCalcSelBoundRect)
 *
 * Assume you want to move the current selection by <sizOffset>.
 * This function returns the offset that you should actually move the
 * current selection by, if you want to be restricted to being below and
 * to the right of (0,0).
 *
 * If <fCalcSelBoundRect> is TRUE, then set <m_rcSelBound> to the
 * bounding rectangle of the current selection (required in order to
 * constrain the selection).  Otherwise, assume <m_rcSelBound> has already
 * been calculated.
 *
 * We restrict the selection to be moved no further than 0 for top and
 * left and to MAX_DOCUMENT_SIZE for right and bottom.
 *
 * In this function we restrict the user's ability to exceed the maximum
 * size of the ScrollView. Note that Filters are only added to the
 * visible part of the existing ScrollView.
 *
 * The only place where a further check has to be made is in the
 * automatic filter layout. (bnetdoc.cpp CBoxNetDoc::
 *
 */
CSize CBoxNetView::ConstrainMoveBoxSel(CSize sizOffset,
    BOOL fCalcSelBoundRect)
{
    CBoxNetDoc *    pdoc = GetDocument();

    if (fCalcSelBoundRect)
        pdoc->GetBoundingRect(&m_rcSelBound, TRUE);

    // constrain <sizOffset> to be below and to the right of (0,0)
    CRect rc(m_rcSelBound);
    rc.OffsetRect(sizOffset);
    if (rc.left < 0)
        sizOffset.cx -= rc.left;
    if (rc.top < 0)
        sizOffset.cy -= rc.top;
    if (rc.right > MAX_DOCUMENT_SIZE)
        sizOffset.cx -= (rc.right - MAX_DOCUMENT_SIZE);
    if (rc.bottom > MAX_DOCUMENT_SIZE)
        sizOffset.cy -= (rc.bottom - MAX_DOCUMENT_SIZE);

    return sizOffset;
}


/////////////////////////////////////////////////////////////////////////////
// ghost-selection mode


/* GhostSelectionCreate()
 *
 * Create a "ghost selection", which appears to the user as a copy of the
 * current selection, but only drawn in "skeletal form" (e.g. only the
 * outline of boxes), and drawn with pixels inverted.
 *
 * Start the ghost selection at the same location as the current
 * selection.
 */
void CBoxNetView::GhostSelectionCreate()
{
    CBoxNetDoc *    pdoc = GetDocument();
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // draw the ghost selection
    m_sizGhostSelOffset = CSize(0, 0);
    GhostSelectionDraw(&dc);

    // get the bounding rectangle for the box selection
    pdoc->GetBoundingRect(&m_rcSelBound, TRUE);
}


/* GhostSelectionMove(sizOffset)
 *
 * Move the ghost selection (created by GhostSelectionCreate()) to the
 * location of the current selection, but offset by <sizOffset> pixels.
 * The ghost selection will be restricted to being below and to the
 * right of (0,0), and will snap to the current grid setting.
 */
void CBoxNetView::GhostSelectionMove(CSize sizOffset)
{
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // keep below/right of (0,0) and snap to grid
    sizOffset = ConstrainMoveBoxSel(sizOffset, FALSE);

    // erase previous ghost selection
    GhostSelectionDraw(&dc);

    // move and redraw ghost selection
    m_sizGhostSelOffset = sizOffset;
    GhostSelectionDraw(&dc);
}


/* GhostSelectionDestroy()
 *
 * Destroy the ghost selection (created by GhostSelectionCreate()).
 */
void CBoxNetView::GhostSelectionDestroy()
{
    CClientDC       dc(this);       // DC onto window

    CPoint Offset = GetDeviceScrollPosition();
    dc.OffsetViewportOrg(-Offset.x,-Offset.y);

    // erase current ghost selection
    GhostSelectionDraw(&dc);
}


/* GhostSelectionDraw(pdc)
 *
 * Draw the current ghost selection in <pdc>.
 */
void CBoxNetView::GhostSelectionDraw(CDC *pdc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc

    // draw all selected boxes in "ghost form"
    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
            gpboxdraw->DrawBox(pbox, pdc, NULL, &m_sizGhostSelOffset);
    }

    // draw all links to selected boxes in "ghost form"
    for (pos = pdoc->m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = (CBoxLink *) pdoc->m_lstBoxes.GetNext(pos);
        if (plink->m_psockTail->m_pbox->IsSelected() ||
            plink->m_psockHead->m_pbox->IsSelected())
            gpboxdraw->DrawLink(plink, pdc, FALSE, &m_sizGhostSelOffset);
    }
}


/////////////////////////////////////////////////////////////////////////////
// select-rectangle mode


/* SelectRectBegin(pt)
 *
 * Enter into select-rectangle mode.  While in this mode, a rectangle is drawn
 * in the window.  When the mode ends, all boxes that intersect the rectangle
 * will be selected.
 *
 * <pt> defines the anchor point, i.e. the point to use to start drawing the
 * rectangle (i.e. it must be one of the corners of the desired rectangle).
 */
void CBoxNetView::SelectRectBegin(CPoint pt)
{
    CClientDC       dc(this);       // DC onto window

    // exit select-rectangle mode
    m_fSelectRect = TRUE;
    m_ptSelectRectAnchor = m_ptSelectRectPrev = pt;

    // draw the initial selection rectangle
    SelectRectDraw(&dc);

    MFGBL(SetStatus(IDS_STAT_SELECTRECT));
}


/* SelectRectContinue(pt)
 *
 * Continue select-rectangle mode.  Draw the rectangle from the anchor point
 * (specified in SelectRectBegin()) to <pt>.
 */
void CBoxNetView::SelectRectContinue(CPoint pt)
{
    CClientDC       dc(this);       // DC onto window

    // move the selection rectangle
    SelectRectDraw(&dc);
    m_ptSelectRectPrev = pt;
    SelectRectDraw(&dc);
}


/* SelectRectEnd(fCancel)
 *
 * End select-rectangle mode.  If <fCancel> is FALSE, then select all boxes
 * that intersect the rectangle.
 */
void CBoxNetView::SelectRectEnd(BOOL fCancel)
{
    CClientDC       dc(this);       // DC onto window

    // erase the selection rectangle
    SelectRectDraw(&dc);

    // exit select-rectangle mode
    m_fSelectRect = FALSE;

    if (!fCancel)
    {
        // select all boxes intersecting the rectangle
        CRect rc(m_ptSelectRectAnchor.x, m_ptSelectRectAnchor.y,
            m_ptSelectRectPrev.x, m_ptSelectRectPrev.y);
        NormalizeRect(&rc);
        rc.OffsetRect(GetDeviceScrollPosition());
        SelectBoxesIntersectingRect(&rc);
    }
}


/* SelectRectDraw(pdc)
 *
 * Draw the current select-rectangle rectangle (assuming that we are in
 * select-rectangle mode, initiated by SelectRectBegin()).  Calling this
 * function again will erase the rectangle (assuming that <m_ptSelectRectPrev>
 * and <m_ptSelectRectAnchor> haven't changed).
 */
void CBoxNetView::SelectRectDraw(CDC *pdc)
{
    // use DrawFocusRect() to invert the pixels in a rectangle frame
    CRect rc(m_ptSelectRectAnchor.x, m_ptSelectRectAnchor.y,
        m_ptSelectRectPrev.x, m_ptSelectRectPrev.y);
    NormalizeRect(&rc);
    pdc->DrawFocusRect(&rc);
}


/* SelectBoxesIntersectingRect(CRect *prc)
 *
 * Select all boxes that intersect <*prc>.
 */
void CBoxNetView::SelectBoxesIntersectingRect(CRect *prc)
{
    CBoxNetDoc *    pdoc = GetDocument();
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CRect           rcTmp;

    for (pos = pdoc->m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) pdoc->m_lstBoxes.GetNext(pos);
        if (rcTmp.IntersectRect(&pbox->GetRect(), prc))
            pdoc->SelectBox(pbox, TRUE);

    }
}


/////////////////////////////////////////////////////////////////////////////
// new-link mode


/* NewLinkBegin(CPoint pt, CBoxSocket *psock)
 *
 * Enter into new-link mode.  While in this mode, the user is dragging from
 * one socket to another socket to create a link.  A ghost arrow is displayed
 * (from the clicked-on socket to the current mouse location) to give the user
 * feedback.
 *
 * <pt> is the clicked-on point; <psock> is the clicked-on socket.
 */
void CBoxNetView::NewLinkBegin(CPoint pt, CBoxSocket *psock)
{
    CBoxNetDoc *    pdoc = GetDocument();

    GetDocument()->DeselectAll();
    m_fNewLink = TRUE;
    m_psockNewLinkAnchor = psock;
    GhostArrowBegin(pt);
    MFGBL(SetStatus(IDS_STAT_DRAGLINKEND));
}


/* NewLinkContinue(pt)
 *
 * Continue new-link mode.  Draw the ghost arrow from the anchor socket
 * (specified in SelectRectBegin()) to <pt>.
 */
void CBoxNetView::NewLinkContinue(CPoint pt)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // a socket in a box
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CPoint          ptProject;      // point on link line segment nearest <pt>

    GhostArrowContinue(pt);

    // set <psock> to the socket <pt> is over (NULL if none)
    if (HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject)
        != CBoxDraw::HT_TAB)
        psock = NULL;

    // if <pt> is over a socket that is not already connected, highlight it
    if ((psock == NULL) || (psock->m_plink != NULL))
    {
        SetHiliteTab(NULL);
        MFGBL(SetStatus(IDS_STAT_DRAGLINKEND));
    }
    else
    {
        SetHiliteTab(psock);
        MFGBL(SetStatus(IDS_STAT_DROPLINKEND));
    }
}


/* NewLinkEnd(fCancel)
 *
 * End new-link mode.  If <fCancel> is FALSE, then create a link from
 * the anchor socket (specified in NewLinkBegin()) to <m_psockHilite>.
 */
void CBoxNetView::NewLinkEnd(BOOL fCancel)
{
    CBoxNetDoc *    pdoc = GetDocument();

    GhostArrowEnd();

    if (!fCancel)
    {
        // make link between <m_psockNewLinkAnchor> and <m_psockHilite>
        if (m_psockNewLinkAnchor->GetDirection()
             == m_psockHilite->GetDirection()) {
            //
            // We cannot connect pins of same direction
            // (different error messages for two input or output pins
            //
            if (m_psockNewLinkAnchor->GetDirection() == PINDIR_INPUT) {
                AfxMessageBox(IDS_CANTCONNECTINPUTS);
            }
            else {
                AfxMessageBox(IDS_CANTCONNECTOUTPUTS);
            }
        }
        else {
            pdoc->CmdDo(new CCmdConnect(m_psockNewLinkAnchor, m_psockHilite));
        }
    }

    // end new-link mode
    SetHiliteTab(NULL);
    m_fNewLink = FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// ghost-arrow mode


/* GhostArrowBegin(pt)
 *
 * Create a ghost arrow that's initially got its head and tail at <pt>.
 * The ghost arrow appears to float above all boxes.  There can only be
 * one active ghost arrow in CBoxNetView at a time.
 */
void CBoxNetView::GhostArrowBegin(CPoint pt)
{
    CClientDC       dc(this);

    m_fGhostArrow = TRUE;
    m_ptGhostArrowTail = m_ptGhostArrowHead = pt;
    GhostArrowDraw(&dc);
}


/* GhostArrowContinue(pt)
 *
 * Move the head of the ghost arrow (created by GhostArrowCreate()) to <pt>.
 */
void CBoxNetView::GhostArrowContinue(CPoint pt)
{
    CClientDC       dc(this);

    GhostArrowDraw(&dc);
    m_ptGhostArrowHead = pt;
    GhostArrowDraw(&dc);
}


/* GhostArrowEnd()
 *
 * Erase the ghost arrow that was created by GhostArrowCreate().
 */
void CBoxNetView::GhostArrowEnd()
{
    CClientDC       dc(this);

    GhostArrowDraw(&dc);
    m_fGhostArrow = FALSE;
}


/* GhostArrowDraw(pdc)
 *
 * Draw the ghost arrow that was created by GhostArrowCreate().
 */
void CBoxNetView::GhostArrowDraw(CDC *pdc)
{
    gpboxdraw->DrawArrow(pdc, m_ptGhostArrowTail, m_ptGhostArrowHead, TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// highlight-tab mode


/* SetHiliteTab(psock)
 *
 * Set the currently-highlighted box socket tab to be <psock>
 * (NULL if no socket should be highlighted).
 */
void CBoxNetView::SetHiliteTab(CBoxSocket *psock)
{
    if (m_psockHilite == psock)
        return;
    if (m_psockHilite != NULL)
        OnUpdate(this, CBoxNetDoc::HINT_DRAW_BOXTAB, m_psockHilite);
    m_psockHilite = psock;
    if (m_psockHilite != NULL)
        OnUpdate(this, CBoxNetDoc::HINT_DRAW_BOXTAB, m_psockHilite);
}




/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CBoxNetView, CScrollView)
    //{{AFX_MSG_MAP(CBoxNetView)
    ON_WM_SETCURSOR()
    ON_WM_ERASEBKGND()
    ON_WM_LBUTTONDOWN()
    ON_WM_MOUSEMOVE()
    ON_WM_LBUTTONUP()
    ON_WM_TIMER()
    ON_COMMAND(ID_CANCEL_MODES, OnCancelModes)
        ON_WM_RBUTTONDOWN()
        ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
        ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
        ON_UPDATE_COMMAND_UI(IDM_SAVE_PERF_LOG, OnUpdateSavePerfLog)
        ON_COMMAND(IDM_SAVE_PERF_LOG, OnSavePerfLog)
        ON_UPDATE_COMMAND_UI(ID_NEW_PERF_LOG, OnUpdateNewPerfLog)
        ON_COMMAND(ID_NEW_PERF_LOG, OnNewPerfLog)
        ON_COMMAND(ID_FILE_SET_LOG, OnFileSetLog)
        ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_MOUSEWHEEL()
	ON_COMMAND(ID_VIEW_SEEKBAR, OnViewSeekbar)
	//}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)

    ON_COMMAND(ID__PROPERTIES, OnProperties)
    ON_UPDATE_COMMAND_UI(ID__PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID__SELECTCLOCK, OnSelectClock)


//    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateSave)  // Disable Save
//    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE_AS, OnUpdateSave) // Disable Save

    ON_MESSAGE(WM_USER_EC_EVENT, OnUser)   // event notification messages

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback functions


BOOL CBoxNetView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    CBoxNetDoc*     pdoc = GetDocument();
    CPoint          pt;             // point to hit-test
    CBoxDraw::EHit  eHit;           // hit-test result code
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // a socket in a box
    CBoxLink *      plink;          // a link in CBoxNetDoc
    CPoint          ptProject;      // point on link line segment nearest <pt>

    // set <pt> to the location of the cursor
    ::GetCursorPos(&pt);
    ScreenToClient(&pt);

    // hit-test all items in document
    eHit = HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject);

    // set the cursor and/or set status bar text accordingly
    switch(eHit)
    {

    case CBoxDraw::HT_MISS:         // didn't hit anything

        // default message
        MFGBL(SetStatus(AFX_IDS_IDLEMESSAGE));
        break;

    case CBoxDraw::HT_TAB:          // hit a box tab <*ppsock>

        MFGBL(SetStatus(IDS_STAT_BOXTABEMPTY));
        break;

    case CBoxDraw::HT_EDGE:         // hit the edge box (set <*ptabpos> to it)
    case CBoxDraw::HT_BOX:          // hit elsewhere on the box
    case CBoxDraw::HT_BOXLABEL:     // hit the box label
    case CBoxDraw::HT_BOXFILE:      // hit the box filename
    case CBoxDraw::HT_TABLABEL:     // hit box tab label <*ppsock>

        // can drag box to move it
        MFGBL(SetStatus(IDS_STAT_MOVEBOX));
        break;

    case CBoxDraw::HT_LINKLINE:     // hit a link line segment
        MFGBL(SetStatus(AFX_IDS_IDLEMESSAGE));
        break;
    }

    return CScrollView::OnSetCursor(pWnd, nHitTest, message);
}


BOOL CBoxNetView::OnEraseBkgnd(CDC* pdc)
{
    // do nothing -- OnDraw() draws the background
    return TRUE;
}


void CBoxNetView::OnLButtonDown(UINT nFlags, CPoint pt)
{
    CBoxNetDoc *    pdoc = GetDocument();
    CBoxDraw::EHit  eHit;           // hit-test result code
    CBox *          pbox;           // clicked-on box (NULL if none)
    CBoxTabPos      tabpos;         // the position of a socket tab on a box
    CBoxSocket *    psock;          // clicked-on socket tab (if applicable)
    CBoxLink *      plink;          // clicked-on link (if applicable)
    CPoint          ptProject;      // point on link line segment nearest <pt>
    CSize           siz;

    // see what item mouse clicked on
    eHit = HitTest(pt, &pbox, &tabpos, &psock, &plink, &ptProject);

    // enter mouse-drag mode
    MouseDragBegin(nFlags, pt, pbox);

    // figure out what action to take as a result of the click
    switch(eHit)
    {

    case CBoxDraw::HT_BOX:
    case CBoxDraw::HT_BOXLABEL:
    case CBoxDraw::HT_BOXFILE:
    case CBoxDraw::HT_TABLABEL:

        // user clicked on box <pbox>

        if (!pbox->IsSelected()) {      // user clicked on an unselected box

            if (!m_fMouseShift || pdoc->IsSelectionEmpty()) {   // deselect all, select this box

                GetDocument()->DeselectAll();
                pdoc->SelectBox(pbox, TRUE);
            }
            else {      // shift-click -- add box to selection

                pdoc->SelectBox(pbox, TRUE);
            }
        }

        // enter move-selection-pending mode (start moving the selection if
        // the user waits long enough or drags the mouse far enough)
        MoveBoxSelPendingBegin(pt);
        break;

    case CBoxDraw::HT_TAB:

        // user clicked on the box tab of socket <psock>
        if (psock->m_plink == NULL) {
            NewLinkBegin(pt, psock);            // enter new-link mode
        }

        break;

    case CBoxDraw::HT_LINKLINE:

        if (!m_fMouseShift || pdoc->IsSelectionEmpty()) { // deselect all, select this link

            GetDocument()->DeselectAll();
            pdoc->SelectLink(plink, TRUE);
        }
        else {  // shift-click -- add box to link

            pdoc->SelectLink(plink, TRUE);
        }

        break;

    default:

        // didn't click on anything -- deselect all items and enter
        // select-rectangle mode
        GetDocument()->DeselectAll();
        SelectRectBegin(pt);
        break;

    }

    CScrollView::OnLButtonDown(nFlags, pt);
}


void CBoxNetView::OnMouseMove(UINT nFlags, CPoint pt)
{
    // do nothing if not currently in mouse-drag mode
    if (!m_fMouseDrag)
        return;

    // update active modes
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingContinue(pt);
    if (m_fMoveBoxSel)
        MoveBoxSelContinue(pt - m_ptMouseAnchor);
    if (m_fSelectRect)
        SelectRectContinue(pt);
    if (m_fNewLink)
        NewLinkContinue(pt);

    // update drag state
    MouseDragContinue(pt);

    CScrollView::OnMouseMove(nFlags, pt);
}


void CBoxNetView::OnLButtonUp(UINT nFlags, CPoint pt) {

    // do nothing if not currently in mouse-drag mode
    if (!m_fMouseDrag)
        return;

    // update active modes
    if (m_fMoveBoxSelPending)
        MoveBoxSelPendingEnd(TRUE);
    if (m_fMoveBoxSel)
        MoveBoxSelEnd(FALSE);
    if (m_fSelectRect)
        SelectRectEnd(FALSE);
    if (m_fNewLink)
        NewLinkEnd(m_psockHilite == NULL);

    // update drag state
    MouseDragEnd();

    CScrollView::OnLButtonUp(nFlags, pt);
}


void CBoxNetView::OnTimer(UINT nIDEvent)
{
    // dispatch timer to code that created it
    switch (nIDEvent)
    {

    case TIMER_MOVE_SEL_PENDING:
        MoveBoxSelPendingEnd(FALSE);
        break;

    case TIMER_SEEKBAR:
        // In case KillTimer isn't working, check the global timer ID
        if (MFGBL(m_nSeekTimerID))  
            CheckSeekBar( );
        break;

    case TIMER_PENDING_RECONNECT:
        CBoxNetDoc* pDoc = GetDocument();

        HRESULT hr = pDoc->ProcessPendingReconnect();

        // ProcessPendingReconnect() returns S_OK if the output pin was successfully reconnected.
        if( S_OK == hr ) {
            AfxMessageBox( IDS_ASYNC_RECONNECT_SUCCEEDED );
        } else if( FAILED( hr ) ) {
            CString strErrorMessage;

            try
            {
                strErrorMessage.Format( IDS_ASYNC_RECONNECT_FAILED, hr );
                if( 0 == AfxMessageBox( (LPCTSTR)strErrorMessage ) ) {
                    TRACE( TEXT("WARNING: ProcessPendingReconnect() failed but the user could not be notified because AfxMessageBox() also failed.") );
                }

            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                TRACE( TEXT("WARNING: ProcessPendingReconnect() failed but the user could not be notified because a CMemoryException was thrown.") );
            }
        }
   
        break;
    }

    CScrollView::OnTimer(nIDEvent);
}


void CBoxNetView::OnCancelModes() {

    CancelModes();
}


//
// OnRButtonDown
//
// Pop up a context sensitive shortcut menu
void CBoxNetView::OnRButtonDown(UINT nFlags, CPoint point)
{
    CBoxNetDoc      *pdoc = GetDocument();
    CBoxDraw::EHit  eHit;               // hit-test result code
    CBox            *pbox;              // clicked-on box (NULL if none)
    CBoxTabPos      tabpos;             // the position of a socket tab on a box
    CBoxSocket      *psock;             // clicked-on socket tab (if applicable)
    CBoxLink        *plink;             // clicked-on link (if applicable)
    CPoint          ptProject;          // point on link line segment nearest <pt>

    // see what item mouse clicked on
    eHit = HitTest(point, &pbox, &tabpos, &psock, &plink, &ptProject);

    // figure out what action to take as a result of the click
    switch(eHit)
    {

    case CBoxDraw::HT_BOX:
    case CBoxDraw::HT_BOXLABEL:
    case CBoxDraw::HT_BOXFILE:
    case CBoxDraw::HT_TABLABEL: {
            // user clicked on box <pbox>

            pdoc->CurrentPropObject(pbox);

            CMenu       menu;
            menu.LoadMenu(IDR_FILTERMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PrepareFilterMenu(menuPopup, pbox);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    case CBoxDraw::HT_TAB: {
            // user clicked on the box tab of socket <psock>

            pdoc->SelectedSocket(psock);        // set the selected socket, so the ui can be updated correctly
            pdoc->CurrentPropObject(psock);

            CMenu       menu;
            menu.LoadMenu(IDR_PINMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PreparePinMenu(menuPopup);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    case CBoxDraw::HT_LINKLINE: {       // the filter menu (properties) also applies
                                        // to links
            // user clicked on link <plink>

            pdoc->CurrentPropObject(plink);

            CMenu       menu;
            menu.LoadMenu(IDR_LINKMENU);
            CMenu *menuPopup = menu.GetSubMenu(0);

            ASSERT(menuPopup != NULL);

            PrepareLinkMenu(menuPopup);

            // point is relative to our window origin, but we need it relative
            // to the screen origin
            CRect rcWindow;
            GetWindowRect(&rcWindow);
            CPoint ScreenPoint = rcWindow.TopLeft() + CSize(point);

            menuPopup->TrackPopupMenu( TPM_LEFTALIGN | TPM_RIGHTBUTTON
                                     , ScreenPoint.x
                                     , ScreenPoint.y
                                     , this
                                     );
        }
        break;

    default:
        break;

    }

        
    CScrollView::OnRButtonDown(nFlags, point);
}


//
// OnUpdateProperties
//
void CBoxNetView::OnUpdateProperties(CCmdUI* pCmdUI) {

    pCmdUI->Enable(GetDocument()->CurrentPropObject()->CanDisplayProperties());
}

//
// OnProperties
//
// The user wants to  edit/view the properties of the
// selected object
void CBoxNetView::OnProperties() {

    GetDocument()->CurrentPropObject()->CreatePropertyDialog(this);
}

//
// OnUpdateSelectClock
//
//void CBoxNetView::OnUpdateSelectClock(CCmdUI* pCmdUI)
//{
//}

//
// OnSelectClock
//
void CBoxNetView::OnSelectClock()
{
    ASSERT (m_pSelectClockFilter);
    GetDocument()->SetSelectClock(m_pSelectClockFilter);

    m_pSelectClockFilter = NULL;
}


//
// PrepareLinkMenu
//
void CBoxNetView::PrepareLinkMenu(CMenu *menuPopup) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }
}

//
// PrepareFilterMenu
//
// The MFC OnUpdate routing does not get popups right. therefore
// DIY
void CBoxNetView::PrepareFilterMenu(CMenu *menuPopup, CBox *pbox) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }

    //
    // Only enable clock selection if the filter has a clock and it
    // is not yet selected.
    //
    if (pbox->HasClock() && !pbox->HasSelectedClock()) {
        menuPopup->EnableMenuItem(ID__SELECTCLOCK, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__SELECTCLOCK, MF_GRAYED);
    }

    m_pSelectClockFilter = pbox;
}


//
// PreparePinMenu
//
// The MFC OnUpdate routing does not get popups right. therefore
// DIY
void CBoxNetView::PreparePinMenu(CMenu *menuPopup) {

    if (GetDocument()->CurrentPropObject()->CanDisplayProperties()) {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID__PROPERTIES, MF_GRAYED);
    }

    if (CCmdRender::CanDo(GetDocument())) {
        menuPopup->EnableMenuItem(ID_RENDER, MF_ENABLED);
    }
    else {
        menuPopup->EnableMenuItem(ID_RENDER, MF_GRAYED);
    }

    if (CCmdReconnect::CanDo(GetDocument())) {
        menuPopup->EnableMenuItem(ID_RECONNECT, MF_ENABLED);
    } else {
        menuPopup->EnableMenuItem(ID_RECONNECT, MF_GRAYED);
    }
}


void CBoxNetView::OnUpdateEditDelete(CCmdUI* pCmdUI) {
    // Delete is enabled if the selection is not empty
    pCmdUI->Enable( CCmdDeleteSelection::CanDo(GetDocument()) );
        
}


void CBoxNetView::OnEditDelete()  {

    GetDocument()->CmdDo(new CCmdDeleteSelection());

}

//
// OnUpdateSave
//
// Disable Save for BETA 1!
//
// void CBoxNetView::OnUpdateSave(CCmdUI* pCmdUI)
// {
//    pCmdUI->Enable(FALSE);         // Disable Save
// }


//
// --- Performance Logging ---
//
// I dynamically load measure.dll in the CBoxNetView constructor.
// if anyone uses it (staically or dynamically) they will get this
// copy of the dll. I provide access to the dump log procedure.

//
// OnUpdateSavePerfLog
//
// Enable dumping of the log when NOPERF is not defined
void CBoxNetView::OnUpdateSavePerfLog(CCmdUI* pCmdUI) {

    pCmdUI->Enable((m_hinstPerf != NULL));

}


//
// OnSavePerfLog
//
// Dump the performance log to the user specified file
void CBoxNetView::OnSavePerfLog() {

    CString strText;
    CString szDumpProc;
    szDumpProc.LoadString(IDS_DUMP_PROC);

    ASSERT(m_hinstPerf);

    MSR_DUMPPROC *DumpProc;
    DumpProc = (MSR_DUMPPROC *) GetProcAddress(m_hinstPerf, szDumpProc);
    if (DumpProc == NULL) {
        AfxMessageBox(IDS_NO_DUMP_PROC);
        return;
    }

    strText.LoadString( IDS_TEXT_FILES );

    CFileDialog SaveLogDialog(FALSE,
                              ".txt",
                              "PerfLog.txt",
                              0,
                              strText,
                              this);

    if( IDOK == SaveLogDialog.DoModal() ){
        HANDLE hFile = CreateFile(SaveLogDialog.GetPathName(),
                                  GENERIC_WRITE,
                                  0,
                                  NULL,
                                  CREATE_ALWAYS,
                                  0,
                                  NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            AfxMessageBox(IDS_BAD_PERF_LOG);
            return;
        }

        DumpProc(hFile);           // This writes the log out to the file

        CloseHandle(hFile);
    }
                
}


void CBoxNetView::OnFileSetLog( void ){
    CString strText;
    HANDLE hRenderLog;

    strText.LoadString( IDS_TEXT_FILES );

    CFileDialog SaveLogDialog(FALSE
                             ,".txt"
                             ,""
                                         ,0
                                         ,strText
                                         ,this
                             );

    if( IDOK == SaveLogDialog.DoModal() ){
        hRenderLog = CreateFile( SaveLogDialog.GetPathName()
                               , GENERIC_WRITE
                               , 0    // no sharing
                               , NULL // no security
                               , OPEN_ALWAYS
                               , 0    // no attributes, no flags
                               , NULL // no template
                               );

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            // Seek to end of file
            SetFilePointer(hRenderLog, 0, NULL, FILE_END);
            GetDocument()->IGraph()->SetLogFile((DWORD_PTR) hRenderLog);
        }
    }
}

//
// OnUpdateNewPerfLog
//
// Grey the item if measure.dll was not found
void CBoxNetView::OnUpdateNewPerfLog(CCmdUI* pCmdUI) {

    pCmdUI->Enable((m_hinstPerf != NULL));
        
}


//
// OnNewPerfLog
//
// Reset the contents of the one and only performance log.
void CBoxNetView::OnNewPerfLog() {

    CString szControlProc;
    szControlProc.LoadString(IDS_CONTROL_PROC);

    ASSERT(m_hinstPerf);

    MSR_CONTROLPROC *ControlProc;
    ControlProc = (MSR_CONTROLPROC *) GetProcAddress(m_hinstPerf, szControlProc);
    if (ControlProc == NULL) {
        AfxMessageBox(IDS_NO_CONTROL_PROC);
        return;
    }

    ControlProc(MSR_RESET_ALL);
}

// *** Drag and drop functions ***

//
// OnCreate
//
// Register this window as a drop target
int CBoxNetView::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;

    // We can handle CFSTR_VFW_FILTERLIST, the base class provides for
    // file drag and drop.
    m_cfClipFormat = (CLIPFORMAT) RegisterClipboardFormat( CFSTR_VFW_FILTERLIST );
    m_DropTarget.Register( this );
        
    return 0;
}


DROPEFFECT CBoxNetView::OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
    //
    // If the filter graph is not stopped we don't want filters to be
    // dropped onto GraphEdt
    //
    if (!CCmdAddFilter::CanDo(GetDocument())) {
        return(m_DropEffect = DROPEFFECT_NONE);
    }

    // Can we handle this format?
    if( pDataObject->IsDataAvailable( m_cfClipFormat ) )
        return (m_DropEffect = DROPEFFECT_COPY);

    // No, see if the base class can
    m_DropEffect = DROPEFFECT_NONE;
    return CView::OnDragEnter(pDataObject, dwKeyState, point);
}

DROPEFFECT CBoxNetView::OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point)
{
    // Can we handle this format?
    if( m_DropEffect == DROPEFFECT_COPY )
        return m_DropEffect;

    // No, see if the base class can
    return CView::OnDragEnter(pDataObject, dwKeyState, point);
}

//
// OnUser
//
// On event notifications from the filter graph a WM_USER message is
// being posted from a thread which waits for these notifications.
// We just pass the call on to the handler in the document.
//
// We need to return 1 to indicate that the message has been handled
//
afx_msg LRESULT CBoxNetView::OnUser(WPARAM wParam, LPARAM lParam)
{
    //
    // Call the handler on CBoxNetDoc
    //
    GetDocument()->OnWM_USER((NetDocUserMessage *) lParam);

    return(1);
}

void CBoxNetView::ShowSeekBar( )
{
    MFGBL(ToggleSeekBar( ));
}

void CBoxNetView::OnViewSeekbar() 
{
    MFGBL(ToggleSeekBar());
}

void CBoxNetView::CheckSeekBar( )
{
    CGraphEdit * pMainFrame = (CGraphEdit*) AfxGetApp( );
    CWnd * pMainWnd = pMainFrame->m_pMainWnd;
    CMainFrame * pF = (CMainFrame*) pMainWnd;
    CQCOMInt<IMediaSeeking> IMS( IID_IMediaSeeking, GetDocument()->IGraph() );
    if( !IMS )
    {
        return;
    }

    REFERENCE_TIME Duration = 0;
    if(FAILED(IMS->GetDuration( &Duration )) || Duration == 0) {
        return;
    }

    REFERENCE_TIME StartTime;
    REFERENCE_TIME StopTime;
    if( pF->m_wndSeekBar.DidPositionChange( ) )
    {
        double Pos = pF->m_wndSeekBar.GetPosition( );
        StartTime = REFERENCE_TIME( Pos * double( Duration ) );
        IMS->SetPositions( &StartTime, AM_SEEKING_AbsolutePositioning, NULL, AM_SEEKING_NoPositioning );
        if( pF->m_wndSeekBar.IsSeekingRandom( ) )
        {
            CQCOMInt<IMediaControl> IMC( IID_IMediaControl, GetDocument()->IGraph() );
            IMC->Run( );
        }
    }

    StartTime = 0;
    StopTime = 0;
    IMS->GetCurrentPosition( &StartTime );

    pF->m_wndSeekBar.SetPosition( double( StartTime ) / double( Duration ) );

}

void CBoxNetView::OnDestroy() 
{
	CScrollView::OnDestroy();
	
    // Fix Manbugs #33781
    //
    // This call used to live in the ~CBoxNetView destructor.
    // When running with debug MFC libraries, we would get an ASSERT failure
    // in CWnd::KillTimer.  Since the owning window had already been destroyed,
    // the inline ASSERT(::IsWindow(m_hWnd)) call failed.  
    //
    // Fix is to kill the timer during processing of WM_DESTROY, when 
    // the window handle is still valid.

    if (MFGBL(m_nSeekTimerID))  
    {
        int rc = ::KillTimer( MFGBL(m_hwndTimer), MFGBL(m_nSeekTimerID));
        MFGBL(m_nSeekTimerID) = 0;
    }
}


BOOL CBoxNetView::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) 
{
    CBoxNetDoc *pdoc = GetDocument();

    // If it's a CTRL+Mouse wheel, adjust the zoom level
    if (nFlags & MK_CONTROL)
    {
        if (zDelta < 0)
            pdoc->IncreaseZoom();
        else
            pdoc->DecreaseZoom();
    }
    	
	return CScrollView::OnMouseWheel(nFlags, zDelta, pt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\bnetfilt.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
// bnetfilt.cpp : defines random Quartz additions to BoxNet
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static enum Mode { MODE_SOURCE, MODE_SINK, MODE_SINK2 };
static BOOL PromptUser(OLECHAR *oszFileName, Mode mode, UINT nIDTitle, bool *pfTruncate = 0);

//
// AttemptFileOpen
//
// Checks if this filter needs a file opening for it.
// If so, it asks the user for a filename and opens it.
void AttemptFileOpen(IBaseFilter *pFilter)
{
    OLECHAR oszFileName[MAX_PATH];
    HRESULT hr;
    IFileSourceFilter *pIFileSource = NULL;
    hr = pFilter->QueryInterface(IID_IFileSourceFilter, (void**) &pIFileSource);
    if(SUCCEEDED(hr))
    {
        if(PromptUser(oszFileName, MODE_SOURCE, IDS_SOURCE_DIALOG_TITLE))
        {
            hr = pIFileSource->Load(oszFileName, NULL);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
        }
        pIFileSource->Release();
    }

    IFileSinkFilter2 *pIFileSink2 = NULL;
    hr = pFilter->QueryInterface(IID_IFileSinkFilter2, (void**) &pIFileSink2);
    if(SUCCEEDED(hr))
    {
        bool fTruncate;
        if(PromptUser(oszFileName, MODE_SINK2, IDS_SINK_DIALOG_TITLE, &fTruncate))
        {
            hr = pIFileSink2->SetFileName(oszFileName, NULL);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
            hr = pIFileSink2->SetMode(fTruncate ? AM_FILE_OVERWRITE : 0);
            if (FAILED(hr))
                DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
        }
        pIFileSink2->Release();
    }
    else
    {
  
        IFileSinkFilter *pIFileSink = NULL;
        hr = pFilter->QueryInterface(IID_IFileSinkFilter, (void**) &pIFileSink);
        if(SUCCEEDED(hr))
        {
            if(PromptUser(oszFileName, MODE_SINK, IDS_SINK_DIALOG_TITLE))
            {
                hr = pIFileSink->SetFileName(oszFileName, NULL);
                if (FAILED(hr))
                    DisplayQuartzError( IDS_FAILED_FILTER_FILE_LOAD, hr );
            }
            pIFileSink->Release();
        }
    }
}

// handle the custom truncate button in the file-save dialog
UINT_PTR CALLBACK TruncateDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
      case WM_INITDIALOG:
          // Save off the long pointer to the OPENFILENAME structure.
          SetWindowLongPtr(hDlg, DWLP_USER, lParam);

          {
              LPOPENFILENAME lpOFN = (LPOPENFILENAME)lParam;
              DWORD *pfSink2 = (DWORD *)(lpOFN->lCustData);

              if(!(*pfSink2))
              {
                  Edit_Enable(GetDlgItem(hDlg, IDC_TRUNCATE), FALSE);
              }
          }

          break;

      case WM_DESTROY:
      {
          LPOPENFILENAME lpOFN = (LPOPENFILENAME)GetWindowLongPtr(hDlg, DWLP_USER);
          DWORD *pfTruncate = (DWORD *)(lpOFN->lCustData);

          HWND hButtonWnd = ::GetDlgItem(hDlg, IDC_TRUNCATE);
          *pfTruncate = ::SendMessage(hButtonWnd, BM_GETCHECK, 0, 0) == BST_CHECKED;
      }
      break;

      default:
          return FALSE;
    }
    return TRUE;
    
}

// Helper to prompt user for a file name and return it
BOOL PromptUser(OLECHAR* oszFileName, Mode mode, UINT nIDTitle, bool *pfTruncate)
{
    CString strTitle;
    TCHAR tszFile[MAX_PATH];
    tszFile[0] = TEXT('\0');
    DWORD fTruncate;

    OPENFILENAME    ofn;
    ZeroMemory (&ofn, sizeof ofn);	

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = AfxGetMainWnd()->GetSafeHwnd();

    TCHAR tszMediaFileMask[201];

    int iSize = ::LoadString(AfxGetInstanceHandle(), IDS_MEDIA_FILES, tszMediaFileMask, 198);
    ofn.lpstrFilter = tszMediaFileMask;
    // avoid LoadString problems with \0\0
    tszMediaFileMask[iSize] = TEXT('\0');
    tszMediaFileMask[iSize + 1] = TEXT('\0');

    // win95 seems to be confused otherwise
    tszMediaFileMask[iSize + 2] = TEXT('\0');
    
    strTitle.LoadString( nIDTitle );

    ofn.nFilterIndex = 1;
    ofn.lpstrFile = tszFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrTitle = strTitle;

    if(mode == MODE_SOURCE)
    {
        ofn.Flags = OFN_FILEMUSTEXIST;
    }
    else if(mode == MODE_SINK || mode== MODE_SINK2)
    {
        DWORD &fSink2 = fTruncate;
        fSink2 = (mode == MODE_SINK2);
            
        ofn.lCustData         = (LPARAM)&fTruncate;
	ofn.lpfnHook 	       = TruncateDlgProc;
	ofn.lpTemplateName    = MAKEINTRESOURCE(IDD_TRUNCATE);        
        ofn.Flags = OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_HIDEREADONLY ;
        ofn.hInstance = AfxGetInstanceHandle();
    }

    // Get the user's selection

    if (!GetOpenFileName(&ofn)) {
        DWORD dw = CommDlgExtendedError();
        return FALSE;
    }

    if(pfTruncate)
    {
        *pfTruncate = !!fTruncate;
    }

#ifdef UNICODE

    wcscpy(oszFileName, tszFile);
#else

    MultiByteToWideChar(CP_ACP, 0, tszFile, -1, oszFileName, MAX_PATH);
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\bnetdoc.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetdoc.cpp : defines CBoxNetDoc
//

#include "stdafx.h"
#include <wininet.h>
#include "rndrurl.h"
#include "congraph.h"
#include <evcode.h>
#include "filtervw.h"
#include "gstats.h"
#include "DCF.h"
#include <atlimpl.cpp>
#include "Reconfig.h"
#include "GEErrors.h"

#ifndef OATRUE
#define OATRUE (-1)
#define OAFALSE (0)
#endif

#define INITIAL_ZOOM    3   /* 100% zoom */

// !!!! should be in public header!
EXTERN_GUID(IID_IXMLGraphBuilder,
0x1bb05960, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

interface IXMLGraphBuilder : IUnknown
{
    STDMETHOD(BuildFromXML) (IGraphBuilder *pGraph, IXMLElement *pxml) = 0;
    STDMETHOD(SaveToXML) (IGraphBuilder *pGraph, BSTR *pbstrxml) = 0;
    STDMETHOD(BuildFromXMLFile) (IGraphBuilder *pGraph, WCHAR *wszFileName, WCHAR *wszBaseURL) = 0;
};

// CLSID_XMLGraphBuilder
// {1BB05961-5FBF-11d2-A521-44DF07C10000}
EXTERN_GUID(CLSID_XMLGraphBuilder,
0x1bb05961, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);
// !!!!!!!!!!!!!!!
// !!!!!!!!!

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CBoxNetDoc, CDocument)

static BOOL GetErrorText( CString& str, HRESULT hr )
{
    UINT nResource;

    switch( hr ){
    case STG_E_FILENOTFOUND:
        nResource = IDS_FILENOTFOUND;
        break;

    case STG_E_ACCESSDENIED:
        nResource = IDS_ACCESSDENIED;
        break;

    case STG_E_FILEALREADYEXISTS:
        nResource = IDS_NOTSTORAGEOBJECT;;
        break;

    case STG_E_TOOMANYOPENFILES:
        nResource = IDS_TOOMANYOPENFILES;
        break;

    case STG_E_INSUFFICIENTMEMORY:
        nResource = IDS_INSUFFICIENTMEMORY;
        break;

    case STG_E_INVALIDNAME:
        nResource = IDS_INVALIDNAME;
        break;

    case STG_E_SHAREVIOLATION:
    case STG_E_LOCKVIOLATION:
        nResource = IDS_FILE_ALREADY_OPEN;
        break;

    case HRESULT_FROM_WIN32( ERROR_NOT_READY ):
        nResource = IDS_DEVICE_NOT_READY;
        break;

    default:
        return FALSE;
    }

    str.LoadString( nResource );
    return TRUE;

}

static void DisplayErrorMessage( HRESULT hr )
{
    CString str;

    if( GetErrorText( str, hr ) )
        AfxMessageBox( str );
    else
        DisplayQuartzError( IDS_GENERAL_FILE_OPEN, hr );
}

//
// Constructor
//
CBoxNetDoc::CBoxNetDoc()
    : m_pGraph(NULL)
    , m_pMediaEvent(NULL)
    , m_hThread(NULL)
    , m_hWndPostMessage(NULL)
    , m_bNewFilenameRequired(FALSE)
    , m_State(Stopped)
    , m_fUsingClock(FALSE)
    , m_fConnectSmart(TRUE)
    , m_fAutoArrange(TRUE)
    , m_fRegistryChanged(FALSE)
    , m_pMarshalStream(NULL)
    , m_psockSelected(NULL)
    , m_hPendingReconnectBlockEvent(NULL)
    , m_nCurrentSize(INITIAL_ZOOM)
{

    m_phThreadData[0] = NULL;
    m_phThreadData[1] = NULL;
    m_phThreadData[2] = NULL;

    m_tszStgPath[0] = TEXT('\0');
    m_lSourceFilterCount=0;

    //
    // I am assuming that OLECHAR == WCHAR
    //  (which is true for WIN32 && !OLE2ANSI - which is true since MFC40)
    //
    ASSERT(sizeof(OLECHAR) == sizeof(WCHAR));
}

const OLECHAR CBoxNetDoc::m_StreamName[] = L"ActiveMovieGraph"; // DON'T LOCALISE

//
// m_iMaxInsertFilters
//
// the maximum length of the insert menu
// need hard coded restriction for message map
const int CBoxNetDoc::m_iMaxInsertFilters = 1000;


//
// Destructor
//
CBoxNetDoc::~CBoxNetDoc() {
    ASSERT(m_lstUndo.GetCount() == 0);
    ASSERT(m_lstRedo.GetCount() == 0);
    ASSERT(m_lstLinks.GetCount() == 0);
    ASSERT(m_lstBoxes.GetCount() == 0);
    CFilterView::DelFilterView();
    CGraphStats::DelGraphStats();

    ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );
}


//
// OnNewDocument
//
// Instantiate a graph and mapper for this document.
BOOL CBoxNetDoc::OnNewDocument() {

    if (!CDocument::OnNewDocument())
        return FALSE;

    //
    // We don't have a path to the storage anymore
    //
    m_tszStgPath[0] = TEXT('\0');

    if (!CreateGraphAndMapper()) {
        AfxMessageBox(IDS_CANTINITQUARTZ);
        return FALSE;
    }

    m_State = Stopped;

    // saves are allowed even if there is nothing to be saved.
    m_bNewFilenameRequired = FALSE;

    return TRUE;
}

void CBoxNetDoc::OnCloseDocument( )
{
    // We need to close down the thread here as the view window
    // (and thus m_hWndPostMessage) will have been destroyed by the time
    // that CDocument::OnCloseDocument calls DeleteContents.
    CloseDownThread();
    CDocument::OnCloseDocument();
}

//
// DeleteContents
//
// Release the Quartz Graph & mapper
// NB DeleteContents & OnNewDocument are not called symmetrically,
//    so treat the interface pointers with care.
void CBoxNetDoc::DeleteContents(void) {

    ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );

    // !!! why do we think we need to disconnect everything here?
    CloseDownThread();

    // flush the Undo & redo lists, as the graph & mapper interfaces the commands
    // use are about to become invalid.
    m_lstUndo.DeleteRemoveAll();
    m_lstRedo.DeleteRemoveAll();

    //
    // Disconnect each link item and delete it
    //
    while ( m_lstLinks.GetCount() > 0 ) {
        delete m_lstLinks.RemoveHead();
    }

    m_lstBoxes.DeleteRemoveAll();

    delete m_pGraph, m_pGraph = NULL;

    delete m_pMediaEvent, m_pMediaEvent = NULL;
}

//
// CloseDownThread
//
void CBoxNetDoc::CloseDownThread()
{
    //
    // Tell the thread which waits for graph notifications to terminate
    // itself. If it is done, close the handles
    //
    if (m_phThreadData[1] && m_hThread) {
        SetEvent(m_phThreadData[1]);
        WaitForSingleObject(m_hThread, INFINITE);
    }

    //
    // The thread is closed. Remove all remaining WM_USER_EC_EVENT
    // message from the message queue and free the memory we allocated.
    //
    if( m_hWndPostMessage ){
        MSG Msg;
        while ( PeekMessage(&Msg, m_hWndPostMessage, WM_USER_EC_EVENT, WM_USER_EC_EVENT, PM_REMOVE) ) {
            NetDocUserMessage *plParams = (NetDocUserMessage *)Msg.lParam;
            // should call this function, so that filter graph manager can cleanup
            IEvent()->FreeEventParams(plParams->lEventCode, plParams->lParam1, plParams->lParam2);
            delete plParams;
            plParams = NULL;
        }
        m_hWndPostMessage = NULL;
    }


    if (m_hThread) {
        if (!CloseHandle(m_hThread)) {
            TRACE("Closing thread handle failed\n");
        }
        m_hThread = NULL;
    }

    //
    // Don't close m_phThreadData[0], as it is owned by GetEventHandle
    //

    if (m_phThreadData[1] != NULL) {
        if (!CloseHandle(m_phThreadData[1])) {
            TRACE("Closing event handle 1 failed\n");
        }
        m_phThreadData[1] = NULL;
    }
    if (m_phThreadData[2] != NULL) {
        if (!CloseHandle(m_phThreadData[2])) {
            TRACE("Closing event handle 2 failed\n");
        }
        m_phThreadData[2] = NULL;
    }
}

BOOL CBoxNetDoc::AttemptFileRender( LPCTSTR lpszPathName)
{
    if (!OnNewDocument())
        return FALSE;

    CmdDo(new CCmdRenderFile(CString(lpszPathName)) );

    // BUG? What if that failed? We have destroyed our previous graph for nothing

    SetModifiedFlag( FALSE );
    m_State = Stopped;

    m_bNewFilenameRequired = TRUE;

    return TRUE;
}


//
// OnOpenDocument
//
// If this file is a storage, look for a "Graph" stream in it.
// If found, try passing it to the graph as a serialized graph.
// If not found, fail (wrong format file)
// If not a storage, try renderfile'ing it into the current document.
BOOL CBoxNetDoc::OnOpenDocument(LPCTSTR lpszPathName) {

    HRESULT hr;

    if (!CreateGraphAndMapper()) {
        AfxMessageBox(IDS_CANTINITQUARTZ);
        return FALSE;
    }

    WCHAR * pwcFileName;

#ifndef UNICODE
    WCHAR wszPathName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszPathName, -1, wszPathName, MAX_PATH);
    pwcFileName = wszPathName;
#else
    pwcFileName = lpszPathName;
#endif

    if (0 == lstrcmpi(lpszPathName + lstrlen(lpszPathName) - 3, TEXT("xgr"))) {
        BeginWaitCursor();

        IXMLGraphBuilder *pxmlgb;
        HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                      IID_IXMLGraphBuilder, (void**)&pxmlgb);

        if (SUCCEEDED(hr)) {
            DeleteContents();

            if (!CreateGraphAndMapper()) {
                pxmlgb->Release();

                AfxMessageBox(IDS_CANTINITQUARTZ);
                return FALSE;
            }

            hr = pxmlgb->BuildFromXMLFile(IGraph(), pwcFileName, NULL);

            pxmlgb->Release();

            SetModifiedFlag(FALSE);
        }

        UpdateFilters();

        EndWaitCursor();

        if (SUCCEEDED(hr))
            return TRUE;

        DisplayQuartzError( IDS_FAILED_TO_LOAD_GRAPH, hr );

        return FALSE;
    } else if (0 != lstrcmpi(lpszPathName + lstrlen(lpszPathName) - 3, TEXT("grf"))) {
        return AttemptFileRender( lpszPathName );
    }

    CComPtr<IStorage> pStr;

    hr = StgOpenStorage( pwcFileName
                         , NULL
                         ,  STGM_TRANSACTED | STGM_READ
                         , NULL
                         , 0
                         , &pStr
                         );


    // If it is not a storage object. Try render it...
    if( hr == STG_E_FILEALREADYEXISTS ) {
        return AttemptFileRender( lpszPathName );
    }

    // Other error
    if( FAILED( hr ) ){
        DisplayErrorMessage( hr );
        return FALSE;
    }

    // else open must have suceeded.
    DeleteContents();

    try{

        if (!CreateGraphAndMapper()) {
            AfxMessageBox(IDS_CANTINITQUARTZ);
            return FALSE;
        }

        // Get an interface to the graph's IPersistStream and ask it to load
        CQCOMInt<IPersistStream> pips(IID_IPersistStream, IGraph());

        IStream * pStream;

        // Open the filtergraph stream in the file
        hr = pStr->OpenStream( m_StreamName
                                      , NULL
                                      , STGM_READ|STGM_SHARE_EXCLUSIVE
                                      , 0
                                      , &pStream
                                      );

        // Something went wrong. Attempt to render the file
        if( FAILED( hr ) ) {
            return AttemptFileRender( lpszPathName );
        }

        hr = pips->Load(pStream);
        pStream->Release();

        if (SUCCEEDED(hr)) {    // the graph liked it. we're done
            m_State = Stopped;
            UpdateFilters();
            UpdateClockSelection();
            SetModifiedFlag(FALSE);

            //
            // remember the path to this storage
            //
            _tcsncpy(m_tszStgPath, lpszPathName, MAX_PATH);

            return TRUE;
        }

        //
        // Might have been a valid graph, but we are missing the media
        // files used in the graph.
        //
        if ((HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND)
            || (HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND))
        {
            AfxMessageBox(IDS_MISSING_FILE_IN_GRAPH);
        } else {
            DisplayQuartzError( IDS_FAILED_TO_LOAD_GRAPH, hr );
        }

    }
    catch (CHRESULTException) {
        AfxMessageBox(IDS_NOINTERFACE);
    }

    return FALSE;
}


void CBoxNetDoc::OnConnectToGraph()
{
    IUnknown *punkGraph;
#if 0
    // experimental code to connect to garph on other machines....
    COSERVERINFO server;
    server.dwReserved1 = 0;
    server.pwszName = L"\\\\davidmay9";
    server.pAuthInfo = NULL;
    server.dwReserved2 = 0;

    MULTI_QI mqi;
    mqi.pIID = &IID_IUnknown;
    mqi.pItf = NULL;

    HRESULT hr = CoCreateInstanceEx(CLSID_FilterGraph, NULL,
                                    CLSCTX_REMOTE_SERVER, &server,
                                    1, &mqi);

    if (FAILED(hr))
        return;
    punkGraph = mqi.pItf;

#else
#if 0
    {
        const TCHAR szRegKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\FilterGraph");
        const TCHAR szRegName[] = TEXT("Add To ROT on Create");

        HKEY hKey = 0;
        LONG lRet;

        DWORD dwValue = 0;
        DWORD dwDisp;
        lRet = RegCreateKeyEx(HKEY_CURRENT_USER, szRegKey, 0, NULL, REG_OPTION_NON_VOLATILE,
                              MAXIMUM_ALLOWED, NULL, &hKey, &dwDisp);

        if (lRet == ERROR_SUCCESS) {
            DWORD   dwType, dwLen;

            dwLen = sizeof(DWORD);
            RegQueryValueEx(hKey, szRegName, 0L, &dwType, (LPBYTE)&dwValue, &dwLen);
        }
        if (!dwValue) {
            int iChoice = AfxMessageBox(IDS_GRAPHSPY_NOT_ENABLED, MB_YESNO);

            if (iChoice == IDYES) {
                // change registry entry

                dwValue = 1;
                lRet = RegSetValueEx( hKey, szRegName, 0, REG_DWORD,
                                      (unsigned char *)&dwValue, sizeof(dwValue) );

            }

            // in either case, it won't work this time
            return;
        }

        if (hKey) {
            RegCloseKey(hKey);
        }
    }
#endif

    IMoniker *pmk;

    IRunningObjectTable *pirot;
    if (FAILED(GetRunningObjectTable(0, &pirot)))
        return;

    CConGraph dlgConnectToGraph(&pmk, pirot, AfxGetMainWnd());

    if (dlgConnectToGraph.DoModal() != IDOK || pmk == NULL) {
        pirot->Release();
        return;
    }

    HRESULT hr = pirot->GetObject(pmk, &punkGraph);
    pirot->Release();
#endif

    if (SUCCEEDED(hr)) {
        IGraphBuilder *pGraph;

        hr = punkGraph->QueryInterface(IID_IGraphBuilder, (void **) &pGraph);
        punkGraph->Release();

        if (SUCCEEDED(hr)) {
            DeleteContents();

            m_pGraph = new CQCOMInt<IGraphBuilder>(IID_IGraphBuilder, pGraph);
            pGraph->Release();

            // really just create all *but* the graph, of course
            if (!CreateGraphAndMapper()) {
                AfxMessageBox(IDS_CANTINITQUARTZ);
                return;
            }

            m_State = Stopped; // !!! get from graph?
            m_bNewFilenameRequired = TRUE;

            UpdateFilters();
            SetModifiedFlag(FALSE);
        }
    }
}


//
// SaveModified
//
// Only save the document if the filter graph needs saving
BOOL CBoxNetDoc::SaveModified(void) {

    // HRESULT hr = (*m_pPerStorage)->IsDirty();
    HRESULT hr = S_OK;
    if (hr == S_OK) {
// Disable Save
        return CDocument::SaveModified();
    }
    else if (hr == S_FALSE) {
        return TRUE;
    }
    else {
        //
        // We need to return here to allow file.new / file.exit
        // - this can happen after a unsucessful load on a storage
        //   (eg missing media file in the graph)
        return TRUE;
    }
}

// WriteString
//
// Helper function to facilitate writing text to a file
//
void CBoxNetDoc::WriteString(HANDLE hFile, LPCTSTR lptstr, ...)
{
    DWORD cbWritten = 0;
    TCHAR atchBuffer[MAX_STRING_LEN];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, lptstr);

    wvsprintf(atchBuffer, lptstr, va);

    DWORD cbToWrite=lstrlen(atchBuffer)*sizeof(TCHAR);

    if (!WriteFile(hFile, atchBuffer, cbToWrite, &cbWritten, NULL) ||
            (cbWritten != cbToWrite))
        AfxMessageBox(IDS_SAVE_HTML_ERR);
}

// GetNextOutFilter
//
// This function does a linear search and returns in iOutFilter the index of
// first filter in the filter information table  which has zero unconnected
// input pins and atleast one output pin  unconnected.
// Returns FALSE when there are none o.w. returns TRUE
//
BOOL CBoxNetDoc::GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter)
{
    for (int i=0; i < fit.iFilterCount; ++i) {
        if ((fit.Item[i].dwUnconnectedInputPins == 0) &&
                (fit.Item[i].dwUnconnectedOutputPins > 0)) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // then things with more outputs than inputs
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > fit.Item[i].dwUnconnectedInputPins) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // if that doesn't work, find one that at least has unconnected output pins....
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > 0) {
            *iOutFilter=i;
            return TRUE;
        }
    }
    return FALSE;
}

// LocateFilterInFIT
//
// Returns the index into the filter information table corresponding to
// the given IBaseFilter
//
int CBoxNetDoc::LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter)
{
    int iFilter=-1;
    for (int i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].pFilter == pFilter)
            iFilter=i;
    }

    return iFilter;
}

// MakeScriptableFilterName
//
// Replace any spaces and minus signs in the filter name with an underscore.
// If it is a source filtername than it actually is a file path (with the
// possibility of some stuff added at the end for uniqueness), we create a good filter
// name for it here.
//
void CBoxNetDoc::MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter)
{
    if (bSourceFilter) {
        WCHAR awchBuf[MAX_FILTER_NAME];
        BOOL bExtPresentInName=FALSE;
        int iBuf=0;
        for (int i=0; awch[i] != L'\0';++i) {
            if (awch[i]==L'.' && awch[i+1]!=L')') {
                for (int j=1; j <=3; awchBuf[iBuf]=towupper(awch[i+j]),++j,++iBuf);
                awchBuf[iBuf++]=L'_';
                wcscpy(&(awchBuf[iBuf]), L"Source_");
                bExtPresentInName=TRUE;
                break;
            }
        }

        // If we have a filename with no extension than create a suitable name

        if (!bExtPresentInName) {
            wcscpy(awchBuf, L"Source_");
        }

        // make source filter name unique by appending digit always, we don't want to
        // bother to make it unique only if its another instance of the same source
        // filter
        WCHAR awchSrcFilterCnt[10];
        wcscpy(&(awchBuf[wcslen(awchBuf)]),
                _ltow(m_lSourceFilterCount++, awchSrcFilterCnt, 10));
        wcscpy(awch, awchBuf);
    } else {

        for (int i = 0; i < MAX_FILTER_NAME; i++) {
            if (awch[i] == L'\0')
                break;
            else if ((awch[i] == L' ') || (awch[i] == L'-'))
                awch[i] = L'_';
        }
    }
}

// PopulateFIT
//
// Scans through all the filters in the graph, storing the number of input and out
// put pins for each filter, and identifying the source filters in the filter
// inforamtion table. The object tag statements are also printed here
//
void CBoxNetDoc::PopulateFIT(HANDLE hFile, IFilterGraph *pGraph, TCHAR atchBuffer[],
        FILTER_INFO_TABLE *pfit)
{
    HRESULT hr;
    IEnumFilters *penmFilters=NULL;
    if (FAILED(hr=pGraph->EnumFilters(&penmFilters))) {
        WriteString(hFile, TEXT("'Error[%x]:EnumFilters failed!\r\n"), hr);
    }

    IBaseFilter *pFilter;
    ULONG n;
    while (penmFilters && (penmFilters->Next(1, &pFilter, &n) == S_OK)) {
    pfit->Item[pfit->iFilterCount].pFilter = pFilter;

        // Get the input and output pin counts for this filter

        IEnumPins *penmPins=NULL;
        if (FAILED(hr=pFilter->EnumPins(&penmPins))) {
            WriteString(hFile, TEXT("'Error[%x]: EnumPins for Filter Failed !\r\n"), hr);
        }

        IPin *ppin = NULL;
        while (penmPins && (penmPins->Next(1, &ppin, &n) == S_OK)) {
            PIN_DIRECTION pPinDir;
            if (SUCCEEDED(hr=ppin->QueryDirection(&pPinDir))) {
                if (pPinDir == PINDIR_INPUT)
                    pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins++;
                else
                    pfit->Item[pfit->iFilterCount].dwUnconnectedOutputPins++;
            } else {
                WriteString(hFile, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
            }

            ppin->Release();
        }

        if (penmPins)
            penmPins->Release();

        // Mark the source filters, remember at this point any filters that have
        // all input pins connected (or don't have any input pins) must be sources

        if (pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins==0)
            pfit->Item[pfit->iFilterCount].IsSource=TRUE;


    if (FAILED(hr=pFilter->QueryFilterInfo(&pfit->Item[pfit->iFilterCount].finfo))) {
        WriteString(hFile, atchBuffer,TEXT("'Error[%x]: QueryFilterInfo Failed!\r\n"),hr);

    } else {
            if (pfit->Item[pfit->iFilterCount].finfo.pGraph) {
                pfit->Item[pfit->iFilterCount].finfo.pGraph->Release();
            }

            MakeScriptableFilterName(pfit->Item[pfit->iFilterCount].finfo.achName,
                    pfit->Item[pfit->iFilterCount].IsSource);
    }

    pfit->iFilterCount++;
    }

    if (penmFilters)
        penmFilters->Release();
}

void CBoxNetDoc::PrintFilterObjects(HANDLE hFile, TCHAR atchBuffer[], FILTER_INFO_TABLE *pfit)
{
    for (int i=0; i < pfit->iFilterCount; i++) {
        IPersist *pPersist = NULL;

        IBaseFilter *pFilter = pfit->Item[i].pFilter;
        HRESULT hr;

        if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersist, (void**) &pPersist))) {
            CLSID clsid;

            if (SUCCEEDED(hr=pPersist->GetClassID(&clsid))) {
                WCHAR szGUID[100];
                StringFromGUID2(clsid, szGUID, 100);
                szGUID[37] = L'\0';
                WriteString(hFile, TEXT("<OBJECT ID=%ls CLASSID=\"CLSID:%ls\">"
                       "</OBJECT>\r\n"),
                       pfit->Item[i].finfo.achName, szGUID+1);
            } else {
                WriteString(hFile, TEXT("'Error[%x]: GetClassID for Filter Failed !\r\n"), hr);
            }

            pPersist->Release();
        } else {
            WriteString(hFile, TEXT("'Error[%x]: Filter doesn't support IID_IPersist!\r\n"), hr);
        }
    }
}

//
// PrintGraphAsHTML
//
// Writes an HTML page which instantiates the graph and different filters
// using the <OBJECT> tag and VB script methods to add the different filters
// to the graph and make the connections.
//
void CBoxNetDoc::PrintGraphAsHTML(HANDLE hFile)
{
    HRESULT hr;
    ULONG n;
    IFilterGraph *pGraph = IGraph();
    FILTER_INFO_TABLE fit;
    TCHAR atchBuffer[MAX_STRING_LEN];
    atchBuffer[0]=L'\0';
    ZeroMemory(&fit, sizeof(fit));

    // write the initial header tags and instantiate the filter graph
    WriteString(hFile, TEXT("<HTML>\r\n<HEAD>\r\n<TITLE> Saved Graph </TITLE>\r\n"
            "</HEAD>\r\n<BODY>\r\n<OBJECT ID=Graph CLASSID="
            "\"CLSID:E436EBB3-524F-11CE-9F53-0020AF0BA770\"></OBJECT>\r\n"));

    // Fill up the Filter information table and also print the <OBJECT> tag
    // filter instantiations
    PopulateFIT(hFile, pGraph, atchBuffer, &fit);

    PrintFilterObjects(hFile, atchBuffer, &fit);

    WriteString(hFile, TEXT("<SCRIPT language=\"VBScript\">\r\n<!--\r\n"
            "Dim bGraphRendered\r\nbGraphRendered=False\r\n"
            "Sub Window_OnLoad()\r\n"));

    // write the declarations (Dim statement) for the FilterInfo variables
    // which will be returned by AddFilter
    int i;
    for (i = 0; i < fit.iFilterCount; i++) {
        if (fit.Item[i].IsSource) {
            WriteString(hFile, TEXT("\tDim %ls_Info\r\n"), fit.Item[i].finfo.achName);
        }
    }

    // Put the conditional if statement for adding filters and connecting, we don't
    // want to reconnect every the user comes back to this page and Window_OnLoad()
    // gets called
    WriteString(hFile, TEXT("\tif bGraphRendered = False Then\r\n"));

    // write the statements for adding the different filters to the graph, make
    // sure we treat the source filters special since they also will need a
    // a filename
    for (i = fit.iFilterCount-1; i >=0 ; i--) {
        if (fit.Item[i].IsSource) {
            WriteString(hFile, TEXT("\t\tset %ls_Info=Graph.AddFilter(%ls, \"%ls\")\r\n"),
                    fit.Item[i].finfo.achName, fit.Item[i].finfo.achName,
                    fit.Item[i].finfo.achName);

            IFileSourceFilter *pFileSourceFilter=NULL;
            if (FAILED(hr=fit.Item[i].pFilter->QueryInterface(IID_IFileSourceFilter,
                        reinterpret_cast<void **>(&pFileSourceFilter)))) {
                WriteString(hFile, TEXT("'Error[%x]: Couldn't get IFileSourceFilter interface"
                        "from source filter!\r\n"), hr);
            } else {

                LPWSTR lpwstr;
                hr = pFileSourceFilter->GetCurFile(&lpwstr, NULL);
                pFileSourceFilter->Release();

                if (FAILED(hr)) {
                WriteString(hFile,
                            TEXT("'Error[%x]: IFileSourceFilter::GetCurFile failed\r\n"), hr);
                } else {
                    WriteString(hFile, TEXT("\t\t%ls_Info.Filename=\"%ls\"\r\n"),
                            fit.Item[i].finfo.achName, lpwstr);
                    CoTaskMemFree(lpwstr);
                }
            }
        } else {
            WriteString(hFile, TEXT("\t\tcall Graph.AddFilter(%ls, \"%ls\")\r\n"),
                    fit.Item[i].finfo.achName, fit.Item[i].finfo.achName);
        }
    }

    // Find a filter with zero unconnected input pins and > 0 unconnected output pins
    // Connect the output pins and subtract the connections counts for that filter.
    // Quit when there is no such filter left
    for (i=0; i< fit.iFilterCount; i++) {
        int iOutFilter=-1; // index into the fit
        if (!GetNextOutFilter(fit, &iOutFilter))
            break;
        ASSERT(iOutFilter !=-1);
        IEnumPins *penmPins=NULL;
        if (FAILED(hr=fit.Item[iOutFilter].pFilter->EnumPins(&penmPins))) {
            WriteString(hFile, TEXT("'Error[%x]: EnumPins failed for Filter!\r\n"), hr);
        }
        IPin *ppinOut=NULL;
        while (penmPins && (penmPins->Next(1, &ppinOut, &n)==S_OK)) {
            PIN_DIRECTION pPinDir;
            if (FAILED(hr=ppinOut->QueryDirection(&pPinDir))) {
                WriteString(hFile, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
                ppinOut->Release();
                continue;
            }
            if (pPinDir == PINDIR_OUTPUT) {
                LPWSTR pwstrOutPinID;
                LPWSTR pwstrInPinID;
                IPin *ppinIn=NULL;
                PIN_INFO pinfo;
                FILTER_INFO finfo;
                if (FAILED(hr=ppinOut->QueryId(&pwstrOutPinID))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinOut->ConnectedTo(&ppinIn))) {

                    // It is ok if a particular pin is not connected since we allow
                    // a pruned graph to be saved
                    if (hr == VFW_E_NOT_CONNECTED) {
                        fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                    } else {
                        WriteString(hFile, TEXT("'Error[%x]: ConnectedTo Failed! \r\n"), hr);
                    }
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinIn->QueryId(&pwstrInPinID))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                if (FAILED(hr=ppinIn->QueryPinInfo(&pinfo))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryPinInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                ppinIn->Release();
                if (pinfo.pFilter) {
                    pinfo.pFilter->Release();
                }
                int iToFilter = LocateFilterInFIT(fit, pinfo.pFilter);
                ASSERT(iToFilter < fit.iFilterCount);
                if (FAILED(hr=pinfo.pFilter->QueryFilterInfo(&finfo))) {
                    WriteString(hFile, TEXT("'Error[%x]: QueryFilterInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (finfo.pGraph) {
                    finfo.pGraph->Release();
                }
                MakeScriptableFilterName(finfo.achName, fit.Item[iToFilter].IsSource);
                WriteString(hFile, TEXT("\t\tcall Graph.ConnectFilters(%ls,"
                        "\"%ls\", %ls,\"%ls\")\r\n"), fit.Item[iOutFilter].finfo.achName,
                        pwstrOutPinID, finfo.achName, pwstrInPinID);

                CoTaskMemFree(pwstrOutPinID);
                CoTaskMemFree(pwstrInPinID);

                // decrement the count for the unconnected pins for these two filters
                fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                fit.Item[iToFilter].dwUnconnectedInputPins--;
            }
            ppinOut->Release();
        }
        if (penmPins)
            penmPins->Release();
    }

    // Release all the filters in the fit
    for (i = 0; i < fit.iFilterCount; i++)
        fit.Item[i].pFilter->Release();

    WriteString(hFile, TEXT("\t\tbGraphRendered=True\r\n\tend if\r\n"
            "\t'Graph.Control.Run\r\nEnd Sub\r\n"
            "Sub Window_OnUnLoad()\r\n\t'Graph.Control.Stop\r\n"
            "\t'Graph.Position.CurrentPosition=0\r\nEnd Sub\r\n"
            "-->\r\n</SCRIPT>\r\n</BODY>\r\n</HTML>\r\n"));
}


// OnSaveGraphAsHTML
//
// Called when the user selects "Save As HTML" in the File Menu. Puts up
// a Save File dialog, retrieves the filename selected(entered) and opens
// (creates) a file and calls PrintGraphAsHTML for actually saving the graph
// as HTML text.
//
void CBoxNetDoc::OnSaveGraphAsHTML()
{
    CString strExt, strFilter;
    HANDLE hFile;

    strExt.LoadString(IDS_SAVE_HTML_EXT);
    strFilter.LoadString(IDS_SAVE_HTML_FILTER);
    CFileDialog dlgSaveAsHTML(FALSE, strExt, m_strHTMLPath, 0, strFilter,
            AfxGetMainWnd());

    if (dlgSaveAsHTML.DoModal() != IDOK)
        return;

    m_strHTMLPath=dlgSaveAsHTML.GetPathName();

    if ((hFile=CreateFile(m_strHTMLPath, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        AfxMessageBox(IDS_SAVE_HTML_FILE_ERR);
        return;
    }

    m_lSourceFilterCount=0;

    HRESULT hr = SafePrintGraphAsHTML( hFile );

    CloseHandle(hFile);

    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }
}

// OnSaveGraphAsXML
//
// Called when the user selects "Save As XML" in the File Menu. Puts up
// a Save File dialog, retrieves the filename selected(entered) and opens
// (creates) a file and calls PrintGraphAsXML for actually saving the graph
// as XML text.
//
void CBoxNetDoc::OnSaveGraphAsXML()
{
    CString strExt, strFilter;
    HANDLE hFile;

    strExt.LoadString(IDS_SAVE_XML_EXT);
    strFilter.LoadString(IDS_SAVE_XML_FILTER);
    CFileDialog dlgSaveAsXML(FALSE, strExt, m_strXMLPath, OFN_OVERWRITEPROMPT, strFilter,
            AfxGetMainWnd());

    if (dlgSaveAsXML.DoModal() != IDOK)
        return;

    m_strXMLPath=dlgSaveAsXML.GetPathName();

    if ((hFile=CreateFile(m_strXMLPath, GENERIC_WRITE, FILE_SHARE_READ,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    {
        AfxMessageBox(IDS_SAVE_XML_FILE_ERR);
        return;
    }

    IXMLGraphBuilder *pxmlgb;
    HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                  IID_IXMLGraphBuilder, (void**)&pxmlgb);

    if (SUCCEEDED(hr)) {
        BSTR bstrXML;
        hr = pxmlgb->SaveToXML(IGraph(), &bstrXML);

        if (SUCCEEDED(hr)) {
            DWORD cbToWrite = SysStringLen(bstrXML) * 2 + 1;
            char *pszXML = new char[cbToWrite];

            if (pszXML) {
                WideCharToMultiByte(CP_ACP, 0,
                                    bstrXML, -1,
                                    pszXML, cbToWrite,
                                    NULL, NULL);
                cbToWrite = lstrlenA(pszXML);

                DWORD cbWritten;
                if (!WriteFile(hFile, pszXML, cbToWrite, &cbWritten, NULL) ||
                    (cbWritten != cbToWrite)) {

                    hr = E_FAIL;
                }

                delete[] pszXML;
            }

            SysFreeString(bstrXML);
        }
        pxmlgb->Release();
    }

    if (FAILED(hr)) {
        AfxMessageBox(IDS_SAVE_XML_FILE_ERR);
    }

    CloseHandle(hFile);
    return;
}

//
// OnSaveDocument
//
// This method will be called during the SAVE and SAVE AS operations.
//
//
BOOL CBoxNetDoc::OnSaveDocument(LPCTSTR lpszPathName) {


    HRESULT hr;

        //
        // SAVE AS
        //

        LPOLESTR oleszPath;

#ifndef UNICODE
        WCHAR wszPath[MAX_PATH];

        MultiByteToWideChar(CP_ACP, 0, lpszPathName, -1, wszPath, MAX_PATH);

        oleszPath = wszPath;
#else
        oleszPath = (LPOLESTR) lpszPathName;  // cast away const
#endif

    CComPtr<IStorage> pStr = NULL;
    hr = StgCreateDocfile( oleszPath
                           ,  STGM_CREATE
                           | STGM_TRANSACTED
                           | STGM_READWRITE
                           | STGM_SHARE_EXCLUSIVE
                           , 0
                           , &pStr
                           );
    if(FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    IStream * pStream;

    // Open the filtergraph stream in the file
    hr = pStr->CreateStream( m_StreamName
                             , STGM_WRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE
                             , 0
                             , 0
                             , &pStream
                             );
    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    // Get an interface to the graph's IPersistStream
    CQCOMInt<IPersistStream> pips(IID_IPersistStream, IGraph());

    hr = pips->Save(pStream, TRUE);

    pStream->Release();

    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    hr = pStr->Commit(STGC_DEFAULT);
    if (FAILED(hr)) {
        DisplayErrorMessage( hr );
        return (FALSE);
    }

    m_bNewFilenameRequired = FALSE;
    SetModifiedFlag(FALSE);

    return TRUE;
}

void CBoxNetDoc::SetTitle( LPCTSTR lpszTitle )
{
    if( m_bNewFilenameRequired ){
        CString strTitle( lpszTitle );
        CString strUntitled;

        strUntitled.LoadString(AFX_IDS_UNTITLED);

        if( strUntitled != strTitle ){
            CString strReadOnly;

            strReadOnly.LoadString( IDS_READ_ONLY );
            strTitle += strReadOnly;
        }

        CDocument::SetTitle( strTitle );
    }
    else
        CDocument::SetTitle( lpszTitle );

}


/////////////////////////////////////////////////////////////////////////////
// diagnostics


#ifdef _DEBUG
void CBoxNetDoc::AssertValid() const
{
    CDocument::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CBoxNetDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);

    dc << TEXT("IFilterGraph :") << IGraph() << TEXT("\n");
    dc << m_lstLinks;
    dc << m_lstBoxes;

}

void CBoxNetDoc::MyDump(CDumpContext& dc) const
{
    dc << TEXT("========= BNETDOC Dump =============\n");
    dc << TEXT("FilterGraph:  ") << (void *)IGraph() << TEXT("\n");

    //
    // Output box information
    //
    dc << TEXT("-------- Boxes --------------\n");

    POSITION pos = m_lstBoxes.GetHeadPosition();
    while (pos != NULL) {
        CBox * pBox = m_lstBoxes.GetNext(pos);

        pBox->MyDump(dc);
    }

    //
    // Output link informatin
    //
    dc << TEXT("--------- Links ---------------\n");

    pos = m_lstLinks.GetHeadPosition();
    while (pos != NULL) {
        CBoxLink * pLink = m_lstLinks.GetNext(pos);

        pLink->MyDump(dc);
    }

    dc << TEXT("========== (end) ============\n");

}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// general functions


/* ModifiedDoc(pSender, lHint, pHint)
 *
 * Indicates that the document has been modified.  The parameters are passed
 * to UpdateAllViews().
 */
void CBoxNetDoc::ModifiedDoc(CView* pSender, LPARAM lHint, CObject* pHint)
{
    SetModifiedFlag(TRUE);
    UpdateAllViews(pSender, lHint, pHint);
}


/* DeselectAll()
 *
 * Deselect all objects that can be selected, including objects for which
 * the document maintains the selection state and document for which
 * views maintain the selection state.
 */
void CBoxNetDoc::DeselectAll()
{
    UpdateAllViews(NULL, CBoxNetDoc::HINT_CANCEL_VIEWSELECT);
    SelectBox(NULL, FALSE);
    SelectLink(NULL, FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// CBox lists and box selection


/* GetBoundingRect(prc, fBoxSel)
 *
 * Set <*prc> to be the bounding rectangle around all items
 * (if <fBoxSel> is FALSE) or around selected boxes (if <fBoxSel>
 * is TRUE).  If there are no items in the bounding rectangle,
 * the null rectangle (all fields zero) is returned.
 */
void CBoxNetDoc::GetBoundingRect(CRect *prc, BOOL fBoxSel)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    BOOL            fNoBoxFoundYet = TRUE;

    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) m_lstBoxes.GetNext(pos);
        if (!fBoxSel || pbox->IsSelected())
        {
            if (fNoBoxFoundYet)
            {
                *prc = pbox->GetRect();
                fNoBoxFoundYet = FALSE;
            }
            else
                prc->UnionRect(prc, &pbox->GetRect());
        }
    }

    if (fNoBoxFoundYet)
        prc->SetRectEmpty();
}


/* SelectBox(pbox, fSelect)
 *
 * Select <pbox> if <fSelect> is TRUE, deselect if <fSelect> is FALSE.
 * If <pbox> is NULL, do the same for all boxes in the document.
 */
void CBoxNetDoc::SelectBox(CBox *pbox, BOOL fSelect)
{
    if (pbox == NULL)
    {
        POSITION        pos;            // position in linked list

        // enumerate all boxes in document
        for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
        {
            pbox = (CBox *) m_lstBoxes.GetNext(pos);
            SelectBox(pbox, fSelect);
        }

        return;
    }

    // do nothing if box is already selected/deselected as requested
    if (fnorm(fSelect) == fnorm(pbox->IsSelected()))
        return;

    // repaint <pbox>
    pbox->SetSelected(fSelect);
    UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_BOX, pbox);

    if (pbox->IsSelected()) {   // select its links

        CBoxSocket *psock;
        CSocketEnum NextSocket(pbox);
        while ( 0 != (psock = NextSocket())) {

            if (psock->IsConnected()) {
                SelectLink(psock->m_plink, TRUE);
            }
        }
    }

}


//
// SelectLink
//
// do plink->SetSelected(fSelect) iff plink !=NULL
// otherwise SetSelect all links
void CBoxNetDoc::SelectLink(CBoxLink *plink, BOOL fSelect) {

    if (plink == NULL) {    // select all

        POSITION posNext = m_lstLinks.GetHeadPosition();

        while (posNext != NULL) {

             SelectLink(m_lstLinks.GetNext(posNext), fSelect);
        }
        return;
    }

    if (fnorm(fSelect) == fnorm(plink->IsSelected())) {
        return; // already as requested
    }

    plink->SetSelected(fSelect);
    UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);
}


//
// IsBoxSelectionEmpty
//
// Return TRUE if no boxes are selected, FALSE otherwise.
BOOL CBoxNetDoc::IsBoxSelectionEmpty() {

    POSITION pos = m_lstBoxes.GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
            return FALSE;
    }

    // no selected box found
    return TRUE;
}


//
// IsLinkSelectionEmpty
//
// Return TRUE if no links are selected, FALSE otherwise.
BOOL CBoxNetDoc::IsLinkSelectionEmpty() {

    POSITION    pos = m_lstLinks.GetHeadPosition();

    while (pos != NULL) {

        CBoxLink *plink = m_lstLinks.GetNext(pos);
        if (plink->IsSelected()) {
            return FALSE;
        }
    }

    // no selected link found
    return TRUE;
}

/* GetBoxes(plstDst, fSelected)
 *
 * Call RemoveAll() on <plstDst>, then add pointers to each selected CBox
 * (if <fSelected> is TRUE) or each CBox (if <fSelected> is FALSE) in the
 * CBoxNetDoc to <plstDst>.
 */
void CBoxNetDoc::GetBoxes(CBoxList *plstDst, BOOL fSelected)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    plstDst->RemoveAll();
    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = m_lstBoxes.GetNext(pos);
        if (!fSelected || pbox->IsSelected())
            plstDst->AddTail(pbox);
    }
}


/* SetBoxes(plstSrc, fSelected)
 *
 * Set the selection (if <fSelected> is TRUE) or the current list of boxes
 * (if <fSelected> is FALSE) to be the elements in <plstSrc> (which should be
 * a list of CBox pointers).  In the latter case, <plstSrc> is copied, so
 * the caller is responsible for later freeing <plstSrc>.
 */
void CBoxNetDoc::SetBoxes(CBoxList *plstSrc, BOOL fSelected)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    if (fSelected)
    {
        DeselectAll();

        // select all in <plstSrc>
        for (pos = plstSrc->GetHeadPosition(); pos != NULL; )
        {
            pbox = plstSrc->GetNext(pos);
            SelectBox(pbox, TRUE);
        }
    }
    else
    {
        // empty the list of boxes in the document
        m_lstBoxes.RemoveAll();

        // set the list to be a copy of <plstSrc>
        for (pos = plstSrc->GetHeadPosition(); pos != NULL; )
        {
            pbox = plstSrc->GetNext(pos);
            m_lstBoxes.AddTail(pbox);
            pbox->AddToGraph();
            // pins could have changed
            pbox->Refresh();
        }
    }
}


//
// SelectBoxes
//
// Select the boxes in the supplied list
void CBoxNetDoc::SelectBoxes(CList<CBox *, CBox*> *plst) {

    POSITION posNext = plst->GetHeadPosition();

    while (posNext != NULL) {

        CBox *pbox = plst->GetNext(posNext);
        SelectBox(pbox, TRUE);
    }
}


//
// SelectLinks
//
// Select the links on the supplied list
void CBoxNetDoc::SelectLinks(CList<CBoxLink *, CBoxLink *> *plst) {

    POSITION posNext = plst->GetHeadPosition();

    while (posNext != NULL) {

        CBoxLink *plink = plst->GetNext(posNext);
        SelectLink(plink, TRUE);
    }
}


/* InvalidateBoxes(plst)
 *
 * Causes all boxes in <plst> (a list of CBox objects) to be redrawn.
 */
void CBoxNetDoc::InvalidateBoxes(CBoxList *plst)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc

    for (pos = plst->GetHeadPosition(); pos != NULL; )
    {
        pbox = plst->GetNext(pos);
        UpdateAllViews(NULL, CBoxNetDoc::HINT_DRAW_BOX, pbox);
    }
}


/* MoveBoxSelection(sizOffset)
 *
 * Move each selected box by <sizOffset> pixels.
 */
void CBoxNetDoc::MoveBoxSelection(CSize sizOffset)
{
    POSITION        pos;            // position in linked list
    CBox *          pbox;           // a box in CBoxNetDoc
    CBoxLink *      plink;          // a link in CBoxNetDoc

    // move each box by <sizOffset>
    for (pos = m_lstBoxes.GetHeadPosition(); pos != NULL; )
    {
        pbox = (CBox *) m_lstBoxes.GetNext(pos);
        if (pbox->IsSelected())
        {
            // erase box
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOXANDLINKS, pbox);

            // move box
            pbox->Move(sizOffset);

            // draw box in new location
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOXANDLINKS, pbox);
        }
    }

    // move by <sizOffset> each link that connects two selected boxes
    for (pos = m_lstLinks.GetHeadPosition(); pos != NULL; )
    {
        plink = m_lstLinks.GetNext(pos);
        if (plink->m_psockTail->m_pbox->IsSelected() &&
            plink->m_psockHead->m_pbox->IsSelected())
        {
            // erase link
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);

            // draw link in new location
            ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_LINK, plink);
        }
    }
}


//
// --- Command Processing ---
//
// The way the user affects the state of this document

//
// CmdDo(pcmd)
//
// Do command <pcmd>, and add it to the undo stack.  <pcmd> needs to have
// been allocated by the "new" operator.
void CBoxNetDoc::CmdDo(CCmd *pcmd) {

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdDo '%s'\n", (LPCSTR) strCmd);
#endif

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // do command
    pcmd->Do(this);

    if (pcmd->CanUndo(this))
    {
        // command supports Undo, so add it to the undo stack
        pcmd->m_fRedo = FALSE;
        m_lstUndo.AddHead(pcmd);
    }
    else
    {
        // command can't be undone, so disable Undo
        m_lstUndo.DeleteRemoveAll();

    delete pcmd;
    }

    // delete the redo stack
    m_lstRedo.DeleteRemoveAll();
}


//
// CmdUndo()
//
// Undo the last command.
void CBoxNetDoc::CmdUndo() {

    ASSERT(CanUndo());

    CCmd *      pcmd;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // pop the undo stack
    pcmd = (CCmd *) m_lstUndo.RemoveHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdUndo '%s'\n", (LPCSTR) strCmd);
#endif

    // undo the command
    pcmd->Undo(this);

    // add command to the redo stack
    pcmd->m_fRedo = TRUE;
    m_lstRedo.AddHead(pcmd);
}


//
// CanUndo()
//
// Return TRUE iff CmdUndo() can be performed.
BOOL CBoxNetDoc::CanUndo() {

    return !m_lstUndo.IsEmpty();
}


//
// CmdRedo()
//
// Redo the last undone command.  This is only valid if the redo stack
// is not empty.
void CBoxNetDoc::CmdRedo() {

    ASSERT(CanRedo());

    CCmd *      pcmd;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // pop the redo stack
    pcmd = (CCmd *) m_lstRedo.RemoveHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdRedo '%s'\n", (LPCSTR) strCmd);
#endif

    // redo the command
    pcmd->Redo(this);

    // add command to the undo stack
    pcmd->m_fRedo = FALSE;
    m_lstUndo.AddHead(pcmd);
}


//
// CanRedo()
//
// Return TRUE iff CmdRedo() can be performed.
BOOL CBoxNetDoc::CanRedo() {

    return !m_lstRedo.IsEmpty();
}


//
// CmdRepeat()
//
// Repeat the last command.  This is only valid if you can repeat
void CBoxNetDoc::CmdRepeat() {

    ASSERT(CanRepeat());

    CCmd *      pcmd;
    CCmd *      pcmdRepeat;

    // cancel modes in all views
    UpdateAllViews(NULL, HINT_CANCEL_MODES, NULL);

    // get the command at the top of the undo stack
    pcmd = (CCmd *) m_lstUndo.GetHead();

#ifdef _DEBUG
    CString strCmd;
    strCmd.LoadString(pcmd->GetLabel());
    TRACE("CmdRepeat '%s'\n", (LPCSTR) strCmd);
#endif

    // create a duplicate of the command
    pcmdRepeat = pcmd->Repeat(this);

    // do command
    pcmdRepeat->Do(this);

    // add command to the undo stack
    pcmdRepeat->m_fRedo = FALSE;
    m_lstUndo.AddHead(pcmdRepeat);
}


//
// CanRepeat()
//
// Return TRUE iff CmdRepeat() can be performed.
BOOL CBoxNetDoc::CanRepeat() {

    // can't do Repeat if the undo stack is empty (no command to repeat)
    // or the redo stack is empty (can't Repeat after Undo)
    if (m_lstUndo.IsEmpty() || !m_lstRedo.IsEmpty())
        return FALSE;

    // can only repeat commands that support Repeat()
    CCmd *pcmd = (CCmd *) m_lstUndo.GetHead();
    return pcmd->CanRepeat(this);
}


/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CBoxNetDoc, CDocument)
    //{{AFX_MSG_MAP(CBoxNetDoc)
    ON_COMMAND(ID_FILE_RENDER, OnFileRender)
    ON_COMMAND(ID_URL_RENDER, OnURLRender)
    ON_UPDATE_COMMAND_UI(ID_FILE_RENDER, OnUpdateFileRender)
    ON_UPDATE_COMMAND_UI(ID_URL_RENDER, OnUpdateURLRender)
    ON_UPDATE_COMMAND_UI(ID_FILE_SAVE, OnUpdateFileSave)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_COMMAND(ID_EDIT_REDO, OnEditRedo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_REDO, OnUpdateEditRedo)
    ON_COMMAND(ID_EDIT_SELECT_ALL, OnEditSelectAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_SELECT_ALL, OnUpdateEditSelectAll)
    ON_COMMAND(ID_QUARTZ_DISCONNECT, OnQuartzDisconnect)
    ON_COMMAND(ID_QUARTZ_RUN, OnQuartzRun)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_DISCONNECT, OnUpdateQuartzDisconnect)
    ON_COMMAND(ID_WINDOW_REFRESH, OnWindowRefresh)
    ON_COMMAND(ID_WINDOW_ZOOM25, OnWindowZoom25)
    ON_COMMAND(ID_WINDOW_ZOOM50, OnWindowZoom50)
    ON_COMMAND(ID_WINDOW_ZOOM75, OnWindowZoom75)
    ON_COMMAND(ID_WINDOW_ZOOM100, OnWindowZoom100)
    ON_COMMAND(ID_WINDOW_ZOOM150, OnWindowZoom150)
    ON_COMMAND(ID_WINDOW_ZOOM200, OnWindowZoom200)
    ON_COMMAND(ID_INCREASE_ZOOM, IncreaseZoom)
    ON_COMMAND(ID_DECREASE_ZOOM, DecreaseZoom)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_RUN, OnUpdateQuartzRun)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_PAUSE, OnUpdateQuartzPause)
    ON_UPDATE_COMMAND_UI(ID_QUARTZ_STOP, OnUpdateQuartzStop)
    ON_COMMAND(ID_QUARTZ_STOP, OnQuartzStop)
    ON_COMMAND(ID_QUARTZ_PAUSE, OnQuartzPause)
    ON_UPDATE_COMMAND_UI(ID_USE_CLOCK, OnUpdateUseClock)
    ON_COMMAND(ID_USE_CLOCK, OnUseClock)
    ON_UPDATE_COMMAND_UI(ID_CONNECT_SMART, OnUpdateConnectSmart)
    ON_COMMAND(ID_CONNECT_SMART, OnConnectSmart)
    ON_UPDATE_COMMAND_UI(ID_AUTOARRANGE, OnUpdateAutoArrange)
    ON_COMMAND(ID_AUTOARRANGE, OnAutoArrange)
    ON_COMMAND(ID_GRAPH_ADDFILTERTOCACHE, OnGraphAddFilterToCache)
    ON_UPDATE_COMMAND_UI(ID_GRAPH_ADDFILTERTOCACHE, OnUpdateGraphAddFilterToCache)
    ON_COMMAND(ID_GRAPH_ENUMCACHEDFILTERS, OnGraphEnumCachedFilters)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_INSERT_FILTER, OnInsertFilter)
    ON_COMMAND(ID_CONNECT_TO_GRAPH, OnConnectToGraph)
    ON_COMMAND(ID_GRAPH_STATS, OnGraphStats)

    // -- pin properties menu --
    ON_UPDATE_COMMAND_UI(ID_RENDER, OnUpdateQuartzRender)
    ON_COMMAND(ID_RENDER, OnQuartzRender)

    ON_UPDATE_COMMAND_UI(ID_RECONNECT, OnUpdateReconnect)
    ON_COMMAND(ID_RECONNECT, OnReconnect)

    ON_COMMAND(ID_FILE_SAVE_AS_HTML, OnSaveGraphAsHTML)
    ON_COMMAND(ID_FILE_SAVE_AS_XML, OnSaveGraphAsXML)

END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback helper functions


/* UpdateEditUndoRedoRepeat(pCmdUI, fEnable, idStringFmt, plst)
 *
 * Update the menu item UI for the Undo, Redo, and Repeat commands.
 * <pCmdUI> is the CCmdUI for the menu item.  <fEnable> is TRUE iff
 * the command can be enabled.  <idStringFmt> is the ID of the string
 * resource containing the wsprintf() format string to use for the
 * menu item (e.g. "Undo %s").  <plst> is the CCmd list containing the
 * command; the head of this list will be examined to get the name of
 * the command for use in the menu item text (e.g. "Undo Delete Boxes").
 */
void CBoxNetDoc::UpdateEditUndoRedoRepeat(CCmdUI* pCmdUI, BOOL fEnable,
    unsigned idStringFmt, CMaxList *plst)
{
    CString         strCmd;         // command label
    CString         strMenuFmt;     // menu item label (wsprint format)
    char            achMenu[100];   // result menu item label

    // load the string item that represents  the command (e.g. "Delete Boxes")
    // used in the menu item (e.g. "Undo Delete Boxes")
    strMenuFmt.LoadString(idStringFmt);
    if (fEnable)
        strCmd.LoadString(((CCmd *) plst->GetHead())->GetLabel());
    else
        strCmd = "";                // can't undo/redo/repeat
    wsprintf(achMenu, strMenuFmt, (LPCSTR) strCmd);
    pCmdUI->SetText(achMenu);

    // enable/disable the menu item
    pCmdUI->Enable(fEnable);
}


/////////////////////////////////////////////////////////////////////////////
// message callback functions


void CBoxNetDoc::OnEditUndo()
{
    CmdUndo();
}


void CBoxNetDoc::OnUpdateEditUndo(CCmdUI* pCmdUI)
{
    UpdateEditUndoRedoRepeat(pCmdUI, CanUndo(), IDS_MENU_UNDO, &m_lstUndo);
}


void CBoxNetDoc::OnEditRedo()
{
    if( CanRedo() )
        CmdRedo();
    else
        CmdRepeat();
}


void CBoxNetDoc::OnUpdateEditRedo(CCmdUI* pCmdUI)
{
    // The Redo command may be a Repeat command depending on the context
    // The changing of the status bar text is handled by CMainFrame::GetMessageString
    if( CanRedo() )
        UpdateEditUndoRedoRepeat(pCmdUI, CanRedo(), IDS_MENU_REDO, &m_lstRedo);
    else
        UpdateEditUndoRedoRepeat(pCmdUI, CanRepeat(), IDS_MENU_REPEAT, &m_lstUndo);

}

void CBoxNetDoc::OnEditSelectAll()
{
    // deselect all, select all boxes
    // !!!! need to select all links....
    DeselectAll();
    SelectBox(NULL, TRUE);
}


void CBoxNetDoc::OnUpdateEditSelectAll(CCmdUI* pCmdUI)
{
    // check if there are any boxes to select
    pCmdUI->Enable(m_lstBoxes.GetCount() != 0);
}

//
// OnInsertFilter
//
// Display a list view which allows the user to select a filter to insert
// into the graph.
//
void CBoxNetDoc::OnInsertFilter()
{
    //
    // Make sure common controls are available
    //
    InitCommonControls();

    CFilterView::GetFilterView( this, AfxGetMainWnd() );
}

//
// OnGraphStas
//
// Display a list of graph-wide statistics.
//
void CBoxNetDoc::OnGraphStats()
{
    CGraphStats::GetGraphStats( this, AfxGetMainWnd() );
}

//
// OnQuartzDisconnect
//
// user wants everything disconnected
void CBoxNetDoc::OnQuartzDisconnect()
{
    CmdDo(new CCmdDisconnectAll());

}


//
// OnQuartzRun
//
// Play the graph
void CBoxNetDoc::OnQuartzRun (void) {

    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Run();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTPLAY, hr );
            TRACE("Run failed hr = %x\n", hr);

            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }

        return;
        }

        // Calling Run on the filtergraph will have it call Pause if we have
        // not already done so. Calling Pause on the video renderer will make
        // it show its video window because of the auto show property there
        // is in IVideoWindow. Showing the window will send an EC_REPAINT as
        // it needs an image to draw. So if we show the window manually we
        // must do so after calling Run/Pause otherwise we get an EC_REPAINT
        // sent just before we call Run/Pause ourselves which is redundant
        // (because the repaint has the graph stopped and paused all over!)

        CQCOMInt<IVideoWindow> IVW(IID_IVideoWindow, IGraph());
        IVW->SetWindowForeground(OATRUE);
        m_State = Playing;
    }
    catch (CHRESULTException hre) {

        DisplayQuartzError( IDS_CANTPLAY, hre.Reason() );
    }

    return;

}


//
// OnQuartzPause
//
// Change state between play & pause
void CBoxNetDoc::OnQuartzPause (void) {

    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Pause();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTPAUSE, hr );
            TRACE("Pause failed hr = %x\n", hr);

            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }

        return;
        }

        // Calling Run on the filtergraph will have it call Pause if we have
        // not already done so. Calling Pause on the video renderer will make
        // it show its video window because of the auto show property there
        // is in IVideoWindow. Showing the window will send an EC_REPAINT as
        // it needs an image to draw. So if we show the window manually we
        // must do so after calling Run/Pause otherwise we get an EC_REPAINT
        // sent just before we call Run/Pause ourselves which is redundant
        // (because the repaint has the graph stopped and paused all over!)

        CQCOMInt<IVideoWindow> IVW(IID_IVideoWindow, IGraph());
        IVW->SetWindowForeground(OATRUE);
        m_State = Paused;
    }
    catch (CHRESULTException hre) {

        DisplayQuartzError( IDS_CANTPAUSE, hre.Reason() );
    }

    return;
}


//
// OnUpdateQuartzDisconnect
//
// Are there any links to disconnect?
void CBoxNetDoc::OnUpdateQuartzDisconnect(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( CCmdDisconnectAll::CanDo(this) );
}

#ifdef DSHOW_USE_WM_CERT

#include <..\..\..\filters\asf\wmsdk\inc\wmsdkidl.h>

// note: this object is a SEMI-COM object, and can only be created statically.
class CKeyProvider : public IServiceProvider {
public:
    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == IID_IServiceProvider || riid == IID_IUnknown) {
            *ppv = (void *) static_cast<IServiceProvider *>(this);
            return NOERROR;
        }
        return E_NOINTERFACE;
    }


    STDMETHODIMP QueryService(REFIID siid, REFIID riid, void **ppv)
    {
        if (siid == __uuidof(IWMReader) && riid == IID_IUnknown) {

            IUnknown *punkCert;

            HRESULT hr = WMCreateCertificate( &punkCert );
            if (SUCCEEDED(hr)) {
                *ppv = (void *) punkCert;
            }
            return hr;
        }
        return E_NOINTERFACE;
    }

} g_keyprov;

#endif

//
// CreateGraphAndMapper
//
// CoCreates the filtergraph and mapper. Called by new documents
// and loading documents. Can be called multiple times harmlessly.
BOOL CBoxNetDoc::CreateGraphAndMapper(void) {

    if (m_pGraph && m_pMediaEvent) { // already been done.
        return TRUE;
    }

    try {

        HRESULT hr; // return code

        ASSERT(m_pMediaEvent == NULL);

        if (!m_pGraph)
            m_pGraph = new CQCOMInt<IGraphBuilder>(IID_IGraphBuilder, CLSID_FilterGraph);

        m_pMediaEvent = new CQCOMInt<IMediaEvent>(IID_IMediaEvent, IGraph());

        //
        // Creation of a seperate thread which will translate event signals
        // to messages. This is used to avoid busy polling of the event
        // states in the OnIdle method.
        //

        //
        // the event handle that is signalled when event notifications arrive
        // is created by the filter graph, but we can get it ourselves.
        //
        hr = IEvent()->GetEventHandle((OAEVENT*)&m_phThreadData[0]);
        if (FAILED(hr)) {
            TRACE("Failed to get event handle\n");
            throw CHRESULTException();
        }

        ASSERT(m_phThreadData[0]);
        ASSERT(!m_phThreadData[1]);
        ASSERT(!m_phThreadData[2]);

        m_phThreadData[1] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_phThreadData[2] = CreateEvent(NULL, FALSE, FALSE, NULL);
        RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE,
        REG_NOTIFY_CHANGE_LAST_SET, m_phThreadData[2], TRUE);

        if (m_phThreadData[1] == NULL) {
            //
            // Failed to create event - we'll go on anyway but GraphEdt
            // won't respond to EC_ notifications (not a major problem)
            //
        }
        else {
            // Old quartz.dll will hang if we don't support IMarshal
            IMarshal *pMarshal;
            HRESULT hr = IGraph()->QueryInterface(IID_IMarshal, (void **)&pMarshal);
            if (SUCCEEDED(hr)) {
                pMarshal->Release();
                //
                // Start up the thread which just waits for
                // any EC_  notifications and translate them into messages
                // for our message loop.
                //
                CoMarshalInterThreadInterfaceInStream(IID_IMediaEvent, IEvent(), &m_pMarshalStream);
            }
            DWORD dw;
            m_hThread = CreateThread(NULL, 0, NotificationThread,
                                     (LPVOID) this, 0, &dw);
        }
#ifdef DSHOW_USE_WM_CERT
        IObjectWithSite* pObjectWithSite = NULL;
        HRESULT hrKey = IGraph()->QueryInterface(IID_IObjectWithSite, (void**)&pObjectWithSite);
        if (SUCCEEDED(hrKey))
        {
            pObjectWithSite->SetSite((IUnknown *) &g_keyprov);
            pObjectWithSite->Release();
        }
#endif
        UpdateClockSelection();

        ASSERT(m_pGraph != NULL);
        ASSERT(m_pMediaEvent != NULL);
    }
    catch (CHRESULTException) {

        delete m_pGraph, m_pGraph = NULL;

        delete m_pMediaEvent, m_pMediaEvent = NULL;

        return FALSE;
    }

    return TRUE;
}


//
// GetFiltersInGraph
//
// If an 'intelligent' feature is used the graph may add filters without
// telling us. Therefore enumerate the filters and links
// in the graph
HRESULT CBoxNetDoc::GetFiltersInGraph( void )
{
    m_lstLinks.DeleteRemoveAll();

    POSITION posNext;
    CBox *pCurrentBox;
    POSITION posCurrent;

    // We want the list to allocate at least one unit each time
    // a box is added to the list.
    int nListAllocationBlockSize = max( m_lstBoxes.GetCount(), 1 );

    // The list deletes any boxes which are left on the list when the
    // function exists.
    CBoxList lstExistingBoxes( TRUE, nListAllocationBlockSize );

    // Copy the boxes on m_lstBoxes to lstExistingBoxes.
    posNext = m_lstBoxes.GetHeadPosition();

    while( posNext != NULL ) {
        posCurrent = posNext;
        pCurrentBox = m_lstBoxes.GetNext( posNext );

        try {
            lstExistingBoxes.AddHead( pCurrentBox );
        } catch( CMemoryException* pOutOfMemory ) {
            pOutOfMemory->Delete();
            return E_OUTOFMEMORY;
        }

        m_lstBoxes.RemoveAt( posCurrent );

        pCurrentBox = NULL;
    }

    // m_lstBoxes should be empty.
    ASSERT( 0 == m_lstBoxes.GetCount() );

    // Put all the filters in the filter graph on the box list.
    // Each box corresponds to a filter.  The boxes list's order is
    // the same as the filter graph enumerator's order.  The box list
    // must be in this order because SetBoxesHorizontally() will not
    // display the boxes correctly if the box list and the filter graph
    // enumerator have a different order.

    CComPtr<IEnumFilters> pFiltersInGraph;

    HRESULT hr = IGraph()->EnumFilters( &pFiltersInGraph );
    if( FAILED( hr ) ) {
        return hr;
    }

    CBox* pNewBox;
    HRESULT hrNext;
    IBaseFilter* apNextFiler[1];
    CComPtr<IBaseFilter> pNextFilter;

    do
    {
        ULONG ulNumFiltersEnumerated;

        hrNext = pFiltersInGraph->Next( 1, apNextFiler, &ulNumFiltersEnumerated );
        if( FAILED( hrNext ) ) {
            return hrNext;
        }

        // IEnumFilters::Next() only returns two success values: S_OK and S_FALSE.
        ASSERT( (S_OK == hrNext) || (S_FALSE == hrNext) );

        // IEnumFilters::Next() returns S_OK if it has not finished enumerating the
        // filters in the filter graph.
        if( S_OK == hrNext ) {

            pNextFilter.Attach( apNextFiler[0] );
            apNextFiler[0] = NULL;

            try {
                if( !lstExistingBoxes.RemoveBox( pNextFilter, &pNewBox ) ) {
                    // This is a new filter Graph Edit has not previously seen.
                    // CBox::CBox() can throw a CHRESULTException.  new can throw a CMemoryException.
                    pNewBox = new CBox( pNextFilter, this );
                } else {
                    hr = pNewBox->Refresh();
                    if( FAILED( hr ) ) {
                        delete pNewBox;
                        return hr;
                    }
                }

                // AddHead() can throw a CMemoryException.
                m_lstBoxes.AddHead( pNewBox );

                pNewBox = NULL;
                pNextFilter = NULL;

            } catch( CHRESULTException chr ) {
                return chr.Reason();
            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                delete pNewBox;
                return E_OUTOFMEMORY;
            }
        }

    } while( S_OK == hrNext );

    return NOERROR;
}


//
// GetLinksInGraph
//
// For each filter see what its pins are connected to.
// I only check output pins. Each link in the graph _Must_ be between an
// input/output pair, so by checking only output pins I get all the links,
// but see no duplicates.
HRESULT CBoxNetDoc::GetLinksInGraph(void) {

    POSITION posBox = m_lstBoxes.GetHeadPosition();
    while (posBox != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(posBox);

        CSocketEnum NextSocket(pbox, CSocketEnum::Output);
        CBoxSocket *psock;
        while (0 != (psock = NextSocket())) {

            CBoxSocket *psockHead = psock->Peer();

            if (psockHead != NULL) {

                CBoxLink *plink = new CBoxLink(psock, psockHead, TRUE);

                m_lstLinks.AddTail(plink);
            }
        }
    }
    return NOERROR;
}

//
// FilterDisplay
//
// Lines the filters across the screen.
HRESULT CBoxNetDoc::FilterDisplay(void) {

    if (m_fAutoArrange) {

        SetBoxesHorizontally();
        SetBoxesVertically();

        RealiseGrid();      // the filters are currently at 1 pixel spacings.
                            // lay them out allowing for their width.
    }

    return NOERROR;
}

//
// SetBoxesVertically
//
void CBoxNetDoc::SetBoxesVertically(void) {

    CList<CBox *, CBox *>   lstPositionedBoxes;

    POSITION posOld = m_lstBoxes.GetHeadPosition();

    while (posOld != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(posOld);

        pbox->CalcRelativeY();

        POSITION    posNew = lstPositionedBoxes.GetTailPosition();
        POSITION    prev = posNew;
        CBox        *pboxPositioned;

        while (posNew != NULL) {

            prev = posNew;  // store posNew, because GetPrev side effects it.

            pboxPositioned = lstPositionedBoxes.GetPrev(posNew);

            if (pboxPositioned->nzX() < pbox->nzX())
                break;

            //cyclic-looking graphs throw this assert
            //ASSERT(pboxPositioned->nzX() == pbox->nzX());

            if (pboxPositioned->RelativeY() <= pbox->RelativeY())
                break;

            pboxPositioned->Y(pboxPositioned->Y() + 1);
        }

        if (prev == NULL) { // we fell of the head of the list
            pbox->Y(0);
            lstPositionedBoxes.AddHead(pbox);
        }
        else if (pboxPositioned->X() < pbox->X()) {
            pbox->Y(0);
            lstPositionedBoxes.InsertAfter(prev, pbox);
        }
        else {
            pbox->Y(pboxPositioned->Y() + 1);
            lstPositionedBoxes.InsertAfter(prev, pbox);
        }
    }

    m_lstBoxes.RemoveAll();
    m_lstBoxes.AddHead(&lstPositionedBoxes);

}

//
// SetBoxesHorizontally
//
void CBoxNetDoc::SetBoxesHorizontally(void) {

    CList<CBox *, CBox *> lstXPositionedBoxes;

    POSITION    pos = m_lstBoxes.GetHeadPosition();
    while (pos != NULL) {

        CBox *pbox = (CBox *) m_lstBoxes.GetNext(pos);

        pbox->Location(CPoint(0,0));                        // a box starts at the origin

        CSocketEnum NextInput(pbox, CSocketEnum::Input);    // input pin enumerator

        CBoxSocket  *psock;
        int     iX = 0;             // the point this box will be placed at
        int     iXClosestPeer = -1; // the closest box to an input pin on this box
                        //  #a# --------]
                        //              +---#c#
                        //       #b# ---]
                        // ie b is closest peer to c

        while (0 != (psock = NextInput())) {

            if (psock->IsConnected()) { // find out what to.

                CBoxSocket *pPeer = psock->Peer();
                if ( pPeer) {
                    if ( pPeer->pBox()->nzX() > iXClosestPeer ) {
                        iXClosestPeer = pPeer->pBox()->nzX();
                    }
                }
            }
        }

        iX = iXClosestPeer + 1;
        pbox->nzX(iX);

        // insert pbox into the correct place on the sorted list.
        POSITION    posSorted = lstXPositionedBoxes.GetHeadPosition();
        POSITION    prev = posSorted;
        BOOL        fInserted = FALSE;

        while (posSorted != NULL) 
        {
            prev = posSorted;
            CBox *pboxSorted = lstXPositionedBoxes.GetNext(posSorted);

            if (pboxSorted->nzX() >= pbox->nzX()) { // this is where we want to put it
                lstXPositionedBoxes.InsertAfter(prev, pbox);
                fInserted = TRUE;
                break;
            }
        }
        if ((posSorted == NULL) && !fInserted) {    // we fell off the end without adding
            lstXPositionedBoxes.AddTail(pbox);
        }
    }

    m_lstBoxes.RemoveAll();
    m_lstBoxes.AddHead(&lstXPositionedBoxes);
}


//
// RealiseGrid
//
// pre: m_lstBoxes is sorted by X(), then Y() of each box.
//  The boxes are laid out on a grid at 1 pixel intervals
//  The origin is at 0,0 and no positions are negative
//
// post:    m_lstBoxes are laid out so that there are
//      gaps between each box and sufficient room allowed
//      for the biggest box on screen.
//
// Lines up the columns neatly, but not rows. this would require
// another pass over the list.
void CBoxNetDoc::RealiseGrid(void) {

    int iColumnX = 0;   // the left edge of this column
    int iColumnY = 0;   // the top edge of the next box to be placed in
                        // this column.
    int iNextColumnX = 0;   // the left edge of the next column.
    int iCurrentColumn = 0;
    const int iColumnGap = 30;
    const int iRowGap = 15;

    POSITION pos = m_lstBoxes.GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = m_lstBoxes.GetNext(pos);

        if (iCurrentColumn < pbox->nzX()) {   // we've got to the next column
            iColumnY = 0;
            iColumnX = iNextColumnX;
        }

        iCurrentColumn = pbox->nzX();

        //
        // Make sure that the document doesn't exceed the document size.
        // This case will be VERY, VERY rare and thus we don't do any fancy
        // layout, but just pile them on top of each other at the end of
        // the document.
        //
        if ((iColumnX + pbox->Width()) > MAX_DOCUMENT_SIZE ) {
            iColumnX = MAX_DOCUMENT_SIZE - pbox->Width();
        }

        if ((iColumnY + pbox->Height()) > MAX_DOCUMENT_SIZE ) {
            iColumnY = MAX_DOCUMENT_SIZE - pbox->Height();
        }

        // Set the REAL X,Y coordinates (not column indices)
        pbox->X(iColumnX);
        pbox->Y(iColumnY);

        iNextColumnX = max(iNextColumnX, pbox->X() + pbox->Width() + iColumnGap);
        iColumnY += pbox->Height() + iRowGap;
    }
}


//
// UpdateFilters
//
// A quartz operation has just changed the filters in the graph, such that the display
// may not reflect the filters in the graph. May occur, for example, after intelligent
// connect.
// Refreshes the box & link lists and repaints the doc.
HRESULT CBoxNetDoc::UpdateFilters(void)
{
    IGraphConfigCallback* pUpdateFiltersCallback = CUpdateFiltersCallback::CreateInstance();
    if( NULL == pUpdateFiltersCallback ) {
        return E_FAIL;
    }

    HRESULT hr = IfPossiblePreventStateChangesWhileOperationExecutes( IGraph(), pUpdateFiltersCallback, (void*)this );

    pUpdateFiltersCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

void CBoxNetDoc::UpdateFiltersInternal(void) {

    BeginWaitCursor();

    GetFiltersInGraph();
    GetLinksInGraph();
    FilterDisplay();

    ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);

    EndWaitCursor();
}


//
// OnUpdateQuartzRender
//
void CBoxNetDoc::OnUpdateQuartzRender(CCmdUI* pCmdUI) {

    pCmdUI->Enable(CCmdRender::CanDo(this));
}


//
// OnQuartzRender
//
// Attempt to render the pin the user just clicked on.
void CBoxNetDoc::OnQuartzRender() {

    CmdDo(new CCmdRender());

}


//
// OnWindowRefresh
//
// Lay out the filter graph for the user.
void CBoxNetDoc::OnWindowRefresh() {

    UpdateFilters();
}


//
// OnUpdateQuartzRun
//
// Updates the 'Play' menu position
void CBoxNetDoc::OnUpdateQuartzRun(CCmdUI* pCmdUI) {

    if (  (m_State == Paused) || (m_State == Unknown)
        ||(m_State == Stopped)) {
        pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }
}


void CBoxNetDoc::OnUpdateQuartzPause(CCmdUI* pCmdUI)
{
    if (  (m_State == Playing) || (m_State == Unknown)
        ||(m_State == Stopped)) {
    pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }

}

void CBoxNetDoc::OnUpdateQuartzStop(CCmdUI* pCmdUI)
{
    if (  (m_State == Playing) || (m_State == Unknown)
        ||(m_State == Paused)) {
        pCmdUI->Enable(TRUE);
    }
    else {
        pCmdUI->Enable(FALSE);
    }

}


//
// stop the graph, but don't rewind visibly as there has been either
// an error (in which case we shouldn't mess with the graph) or the
// window has been closed.
void CBoxNetDoc::OnQuartzAbortStop()
{
    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());


        hr = IMC->Stop();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTSTOP, hr );
            TRACE("Stop failed hr = %x\n", hr);
        }

        m_State = Stopped;

        IMediaPosition* pMP;
        hr = IMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
        if (SUCCEEDED(hr)) {
            pMP->put_CurrentPosition(0);
            pMP->Release();
        }


    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_CANTSTOP, hre.Reason() );
    }

    return;

}

// Graphedt does not have any notion of seeking so when we stop we do the
// intuitive thing to reset the current position back to the start of the
// stream. If play is to continue from the current position then the user
// can press Pause (and Run). To process the Stop we first Pause then set
// the new start position (while paused) and finally Stop the whole graph

void CBoxNetDoc::OnQuartzStop()
{
    try {

        HRESULT hr;
        CQCOMInt<IMediaControl> IMC(IID_IMediaControl, IGraph());

        hr = IMC->Pause();

        if (SUCCEEDED(hr)) {
            // Reset our position to the start again

            IMediaPosition* pMP;
            hr = IMC->QueryInterface(IID_IMediaPosition, (void**)&pMP);
            if (SUCCEEDED(hr)) {
                pMP->put_CurrentPosition(0);
                pMP->Release();
            }

            // Wait for the Pause to complete. If it does not complete within the
            // specified time we ask the user if (s)he wants to wait a little longer
            // or attempt to stop anyway.
            for(;;){
                const int iTimeout = 10 * 1000;
                OAFilterState state;

                hr = IMC->GetState(iTimeout, &state);
                if( hr == S_OK || hr == VFW_S_CANT_CUE )
                    break;

                if( IDCANCEL == AfxMessageBox( IDS_PAUSE_TIMEOUT, MB_RETRYCANCEL | MB_ICONSTOP ) )
                    break;
            }
        } else
            DisplayQuartzError( IDS_CANTPAUSE, hr );

        // And finally stop the graph

        hr = IMC->Stop();
        if (FAILED(hr)) {
            DisplayQuartzError( IDS_CANTSTOP, hr );
            TRACE("Stop failed hr = %x\n", hr);
            OAFilterState state;
            IMC->GetState(0, &state);
            switch (state) {
            case State_Stopped:
                m_State = Stopped;
                break;
            case State_Paused:
                m_State = Paused;
                break;
            case State_Running:
                m_State = Playing;
                break;
            }
        } else
            m_State = Stopped;
    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_CANTSTOP, hre.Reason() );
    }

    return;

}
//
// GetSize
//
// Use the co-ordinates of the boxes to decide the document
// size needed to lay out this graph.
CSize CBoxNetDoc::GetSize(void) {

    CSize DocSize(0,0);
    POSITION pos;

    pos = m_lstBoxes.GetHeadPosition();

    // Scan the list for the extreme edges.
    while (pos != NULL) {

        CRect rect = m_lstBoxes.GetNext(pos)->GetRect();
        if (rect.right > DocSize.cx) {
            DocSize.cx = rect.right;
        }
        if (rect.bottom > DocSize.cy) {
            DocSize.cy = rect.bottom;
        }
    }

    return DocSize;
}


//
// NotificationThread
//
// This thread just blocks and waits for the event handle from
// IMediaEvent and waits for any events.
//
// There is a second event handle which will be signal as soon as this
// thread should exit.
//
DWORD WINAPI CBoxNetDoc::NotificationThread(LPVOID lpData)
{
    CoInitialize(NULL);

    //  Open a scope to make sure pMediaEvent is released before we call
    //  CoUninitialize
    {
        CBoxNetDoc * pThis = (CBoxNetDoc *) lpData;

        IMediaEvent * pMediaEvent;

        //  Unmarshal our interface
        if (pThis->m_pMarshalStream) {
            CoGetInterfaceAndReleaseStream(
                pThis->m_pMarshalStream, IID_IMediaEvent, (void **)&pMediaEvent);
            pThis->m_pMarshalStream = NULL;
        } else {
            pMediaEvent = pThis->IEvent();
            pMediaEvent->AddRef();
        }

        BOOL fExitOk = FALSE;

        while (!fExitOk) {
            DWORD dwReturn;
            dwReturn = WaitForMultipleObjects(3, pThis->m_phThreadData, FALSE, INFINITE);

            switch (dwReturn) {

            case WAIT_OBJECT_0:
                {
//                    TRACE("Event signaled to Thread\n");

                    //
                    // Get the event now and post a message to our window proc
                    // which will deal with the event. Use post message to
                    // avoid a dead lock once the main thread has decided to
                    // close us down and waits for us to exit.
                    //

                    NetDocUserMessage * pEventParams = new NetDocUserMessage;
                    if (!pEventParams) {
                        // no more memory - let others deal with it.
                        break;
                    }

                    // Must have an IEvent - otherwise signalling of this message
                    // would have been impossible.
                    HRESULT hr;
                    hr = pMediaEvent->GetEvent(&pEventParams->lEventCode, &pEventParams->lParam1, &pEventParams->lParam2, 0);

                    if (FAILED(hr)) {
                        delete pEventParams;
                        break;
                    }

                    BOOL fSuccess = FALSE;
                    if (pThis->m_hWndPostMessage && IsWindow(pThis->m_hWndPostMessage)) {
                        fSuccess =
                            ::PostMessage(pThis->m_hWndPostMessage, WM_USER_EC_EVENT, 0, (LPARAM) pEventParams);
                    }

                    if (!fSuccess) {
                        // should call this function, so that filter graph manager can cleanup
                        pMediaEvent->FreeEventParams(pEventParams->lEventCode, pEventParams->lParam1, pEventParams->lParam2);
                        delete pEventParams;
                    }

                }

                break;

            case (WAIT_OBJECT_0 + 1):
                fExitOk = TRUE;
                break;

            case (WAIT_OBJECT_0 + 2):
            pThis->m_fRegistryChanged = TRUE;

            // reset the registry notification
            RegNotifyChangeKeyValue(HKEY_CLASSES_ROOT, TRUE,
                                        REG_NOTIFY_CHANGE_LAST_SET,
                                        pThis->m_phThreadData[2], TRUE);

            break;

            case (WAIT_FAILED):
                // one of our objects has gone - no need to hang around further
                fExitOk = TRUE;
                break;

            default:
                ASSERT(!"Unexpected return value");
            }
        }
        pMediaEvent->Release();

    }

    CoUninitialize();

    return(0);
}

//
// OnWM_USER
//
void CBoxNetDoc::OnWM_USER(NetDocUserMessage * lParam)
{
    switch (lParam->lEventCode) {
#ifdef DEVICE_REMOVAL
      case EC_DEVICE_LOST:
      {
          IUnknown *punk = (IUnknown *)lParam->lParam1;
          IBaseFilter *pf;
          HRESULT hr = punk->QueryInterface(IID_IBaseFilter, (void **)&pf);
          ASSERT(hr == S_OK);
          FILTER_INFO fi;
          hr = pf->QueryFilterInfo(&fi);
          pf->Release();
          ASSERT(hr == S_OK);
          if(fi.pGraph) {
              fi.pGraph->Release();
          }

          TCHAR szTmp[100];
          wsprintf(szTmp, "device %ls %s.", fi.achName, lParam->lParam2 ?
                   TEXT("arrived") : TEXT("removed"));
          MessageBox(0, szTmp, TEXT("device removal  notification"), 0);
      }
          break;
#endif

    case EC_ERRORABORT:
    DisplayQuartzError( (UINT) IDS_EC_ERROR_ABORT, (HRESULT) lParam->lParam1 );
        /* fall through */

    case EC_USERABORT:
        // stop without the rewind or we will re-show the window
        OnQuartzAbortStop();
        // post dummy message to update the UI (mfc needs this help)
        ::PostMessage( m_hWndPostMessage, WM_NULL, 0, 0);
        break;

    case EC_COMPLETE:
        OnQuartzStop();
        // post dummy message to update the UI (mfc needs this help)
        ::PostMessage( m_hWndPostMessage, WM_NULL, 0, 0);
        break;

    case EC_ERROR_STILLPLAYING:
        {
            int iChoice = AfxMessageBox(IDS_IS_GRAPH_PLAYING, MB_YESNO);
            if (iChoice == IDNO) {
                OnQuartzAbortStop();
            }
        }
        break;

    case EC_CLOCK_CHANGED:
        UpdateClockSelection();
        break;

    case EC_GRAPH_CHANGED:
        UpdateFilters();
        SetModifiedFlag(FALSE);
        break;

    default:
        break;
    }
    // should call this function, so that filter graph manager can cleanup
    IEvent()->FreeEventParams(lParam->lEventCode, lParam->lParam1, lParam->lParam2);
    delete lParam;
}


//
// OnUpdateUseClock
//
void CBoxNetDoc::OnUpdateUseClock(CCmdUI* pCmdUI)  {

    pCmdUI->SetCheck(m_fUsingClock);

}

//
// OnUseClock
//
// if we are using the clock, set no clock.
// if we are not using a clock ask for the default
void CBoxNetDoc::OnUseClock() {

    try {

        CQCOMInt<IMediaFilter> IMF(IID_IMediaFilter, IGraph());

        if (m_fUsingClock) {
            // we don't want to use the clock anymore

            HRESULT hr;

            hr = IMF->SetSyncSource(NULL);
            if (FAILED(hr)) {
                DisplayQuartzError( IDS_CANTSETCLOCK, hr );
                TRACE("SetSyncSource(NULL) failed hr = %x\n", hr);
                return;
            }
        }
        else {
            HRESULT hr = IGraph()->SetDefaultSyncSource();

            if (FAILED(hr)) {
                DisplayQuartzError( IDS_CANTSETCLOCK, hr );
                TRACE("SetDefaultSyncSource failed hr = %x\n", hr);
                return;
            }
        }

        // m_fUsing clock will be updated on the EC_CLOCK_CHANGED notification
    }
    catch (CHRESULTException) {
        // just catch it...
    }
}


//
// OnUpdateConnectSmart
//
void CBoxNetDoc::OnUpdateConnectSmart(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fConnectSmart);
}

//
// OnConnectSmart
//
// Only need to invert the flag. All the magic is done elsewhere.
//
void CBoxNetDoc::OnConnectSmart()
{
    m_fConnectSmart = !m_fConnectSmart;
}

//
// OnUpdateConnectSmart
//
void CBoxNetDoc::OnUpdateAutoArrange(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_fAutoArrange);
}

//
// OnAutoArrange
//
// Toggle automatic graph re-arrangement.
void CBoxNetDoc::OnAutoArrange() {

    m_fAutoArrange = !m_fAutoArrange;
}

//
// OnFileRender
//
void CBoxNetDoc::OnFileRender()
{
    char szNameOfFile[MAX_PATH];
    szNameOfFile[0] = 0;

    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize   = sizeof(OPENFILENAME);
    ofn.hwndOwner     = AfxGetMainWnd()->GetSafeHwnd();

    TCHAR tszMediaFileMask[201];
    int iSize = ::LoadString(AfxGetInstanceHandle(), IDS_MEDIA_FILES, tszMediaFileMask, 198);
    ASSERT(iSize);
    // Load String has problems with the 2nd \0 at the end
    tszMediaFileMask[iSize] = 0;
    tszMediaFileMask[iSize + 1] = 0;
    tszMediaFileMask[iSize + 2] = 0;

    ofn.lpstrFilter   = tszMediaFileMask;

    ofn.nFilterIndex  = 1;
    ofn.lpstrFile     = szNameOfFile;
    ofn.nMaxFile      = MAX_PATH;
    ofn.lpstrTitle    = TEXT("Select a file to be rendered.");
    ofn.Flags         = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    // get users selection
    if (!GetOpenFileName(&ofn)) {
        // no file selected - continue
        return;
    }

    WCHAR szwName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, szNameOfFile, -1, szwName, MAX_PATH);

    CmdDo( new CCmdRenderFile(szwName) );

    SetModifiedFlag();
}

//
// OnURLRender
//
void CBoxNetDoc::OnURLRender()
{
    char szNameOfFile[INTERNET_MAX_URL_LENGTH];
    CRenderURL dlgRenderURL(szNameOfFile, INTERNET_MAX_URL_LENGTH, AfxGetMainWnd());

    if (dlgRenderURL.DoModal() != IDOK)
        return;

    WCHAR szwName[INTERNET_MAX_URL_LENGTH];
    MultiByteToWideChar(CP_ACP, 0, szNameOfFile, -1, szwName, INTERNET_MAX_URL_LENGTH);

    CmdDo( new CCmdRenderFile(szwName) );

    SetModifiedFlag();
}

//
// OnUpdateFileRender
//
void CBoxNetDoc::OnUpdateFileRender(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(m_State == Stopped);
}

//
// OnUpdateURLRender
//
void CBoxNetDoc::OnUpdateURLRender(CCmdUI *pCmdUI)
{
    pCmdUI->Enable(m_State == Stopped);
}

void CBoxNetDoc::OnUpdateFileSave(CCmdUI *pCmdUI)
{
    pCmdUI->Enable( !m_bNewFilenameRequired );
}


//
// SetSelectClock
//
// Sets the Graphs clock to the one found in pBox and removes the dialog
// box if we succeeded.
//
void CBoxNetDoc::SetSelectClock(CBox *pBox)
{
    if (!pBox->HasClock()) {
        AfxMessageBox(IDS_NO_REFCLOCK);
        return;
    }

    try {
        CQCOMInt<IMediaFilter> pMF(IID_IMediaFilter, IGraph());
        CQCOMInt<IReferenceClock> pRC(IID_IReferenceClock, pBox->pIFilter());

        HRESULT hr = pMF->SetSyncSource(pRC);
        if (FAILED(hr)) {
            throw CE_FAIL();
        }

    }
    catch (CHRESULTException hre) {
        DisplayQuartzError( IDS_FAILED_SETSYNC, hre.Reason() );
    }
}


//
// UpdateClockSelection
//
// Sets the CBox::m_fClockSelected flag of the filter that provides the
// current clock to true.
//
void CBoxNetDoc::UpdateClockSelection()
{
    // Get current clock
    CQCOMInt<IMediaFilter> pMF(IID_IMediaFilter, IGraph());

    IReferenceClock * pRefClock;

    if (FAILED(pMF->GetSyncSource(&pRefClock))) {
        pRefClock = NULL;
    }

    m_fUsingClock = (pRefClock != NULL);

    // iterate through all boxes (filters) in the graph
    POSITION pos = m_lstBoxes.GetHeadPosition();
    while (pos) {
        CBox *pbox = m_lstBoxes.GetNext(pos);

        pbox->m_fClockSelected = FALSE;

        if (pbox->HasClock()) {
            try {
                // pbox has a IReferenceClock interface
                CQCOMInt<IReferenceClock> pRC(IID_IReferenceClock, pbox->pIFilter());

                ASSERT(pRC);

                pbox->m_fClockSelected = ((IReferenceClock *) pRC == pRefClock);
            }
            catch (CHRESULTException) {
                // failed to get IReferenceClock
                ASSERT(!pbox->m_fClockSelected);
            }
        }
    }

    if (pRefClock) {
        pRefClock->Release();
    }

    //
    // Redraw the whole filter graph.
    //
    UpdateAllViews(NULL, HINT_DRAW_ALL);
}

#pragma warning(disable:4514)

void CBoxNetDoc::OnGraphAddFilterToCache()
{
    CCmdAddFilterToCache* pCmdAddFilterToCache;

    try
    {
        pCmdAddFilterToCache = new CCmdAddFilterToCache;
    }
    catch( CMemoryException* peOutOfMemory )
    {
        DisplayQuartzError( E_OUTOFMEMORY );
        peOutOfMemory->Delete();
        return;
    }

    CmdDo( pCmdAddFilterToCache );
}

void CBoxNetDoc::OnUpdateGraphAddFilterToCache(CCmdUI* pCmdUI)
{
    pCmdUI->Enable( CCmdAddFilterToCache::CanDo( this ) );
}

void CBoxNetDoc::OnGraphEnumCachedFilters()
{
    HRESULT hr = SafeEnumCachedFilters();
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
    }
}

void CBoxNetDoc::OnGraphEnumCachedFiltersInternal()
{
    IGraphConfig* pGraphConfig;

    HRESULT hr = IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }

    hr = S_OK;
    CDisplayCachedFilters dlgCurrentCachedFilters( pGraphConfig, &hr );
    if( FAILED( hr ) )
    {
        pGraphConfig->Release();
        DisplayQuartzError( hr );
        return;
    }

    INT_PTR nReturnValue = dlgCurrentCachedFilters.DoModal();

    // Handle the return value from DoModal
    switch( nReturnValue )
    {
    case -1:
        // CDialog::DoModal() returns -1 if it cannot create the dialog box.
        AfxMessageBox( IDS_CANT_CREATE_DIALOG );
        break;

    case IDABORT:
        // An error occured while the dialog box was being displayed.
        // CDisplayCachedFilters handles all internal errors.
        break;

    case IDOK:
        // No error occured.  The user finished looking at the dialog box.
        break;

    default:
        // This code should never be executed.
        ASSERT( false );
        break;
    }

    pGraphConfig->Release();
}

void CBoxNetDoc::OnViewSeekBar()
{
   POSITION pos = GetFirstViewPosition();
   while (pos != NULL)
   {
      CBoxNetView * pView = (CBoxNetView*) GetNextView(pos);
      pView->ShowSeekBar( );
   }
}

void CBoxNetDoc::OnUpdateReconnect( CCmdUI* pCmdUI )
{
    pCmdUI->Enable( CCmdReconnect::CanDo(this) );
}

void CBoxNetDoc::OnReconnect( void )
{
    CCmdReconnect* pCmdReconnect;

    try
    {
        pCmdReconnect = new CCmdReconnect;
    }
    catch( CMemoryException* peOutOfMemory )
    {
        DisplayQuartzError( E_OUTOFMEMORY );
        peOutOfMemory->Delete();
        return;
    }

    CmdDo( pCmdReconnect );
}

HRESULT CBoxNetDoc::StartReconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin )
{
    if( AsyncReconnectInProgress() ) {
        return E_FAIL;
    }

    CComPtr<IPinFlowControl> pDynamicOutputPin;

    HRESULT hr = pOutputPin->QueryInterface( IID_IPinFlowControl, (void**)&pDynamicOutputPin );
    if( FAILED( hr ) ) {
        return hr;
    }

    SECURITY_ATTRIBUTES* DEFAULT_SECURITY_ATTRIBUTES = NULL;
    const BOOL AUTOMATIC_RESET = FALSE;
    const BOOL INITIALLY_UNSIGNALED = FALSE;
    const LPCTSTR UNNAMED_EVENT = NULL;

    HANDLE hBlockEvent = ::CreateEvent( DEFAULT_SECURITY_ATTRIBUTES, AUTOMATIC_RESET, INITIALLY_UNSIGNALED, UNNAMED_EVENT );
    if( NULL == hBlockEvent ) {
        DWORD dwLastWin32Error = ::GetLastError();
        return AmHresultFromWin32( dwLastWin32Error );
    }

    hr = pDynamicOutputPin->Block( AM_PIN_FLOW_CONTROL_BLOCK, hBlockEvent );
    if( FAILED( hr ) ) {
        // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
        EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );

        return hr;
    }

    const DWORD PIN_BLOCKED = WAIT_OBJECT_0;

    // There are 200 milliseconds in one fifth of a second.
    const DWORD ONE_FIFTH_OF_A_SECOND = 200;

    DWORD dwReturnValue = ::WaitForSingleObject( hBlockEvent, ONE_FIFTH_OF_A_SECOND );

    if( WAIT_TIMEOUT != dwReturnValue ) {
        if( PIN_BLOCKED != dwReturnValue ) {
            // Block() should not fail because we are unblocking the pin and
            // we are passing in valid arguments.
            EXECUTE_ASSERT( SUCCEEDED( pDynamicOutputPin->Block(0, NULL) ) );
        }

        // This call should not fail because we have access to hBlockEvent
        // and hBlockEvent is a valid event.
        EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );
    }

    switch( dwReturnValue ) {
    case PIN_BLOCKED:
        // EndReconnect() always unblocks the output pin.
        hr = EndReconnect( pFilterGraph, pDynamicOutputPin );
        if( FAILED( hr ) ) {
            return hr;
        }

        return S_OK;

    case WAIT_TIMEOUT:
        {
            const TIMERPROC NO_TIMER_PROCEDURE = NULL;

            // SetTimer() returns 0 if an error occurs.
            if( 0 == ::SetTimer( m_hWndPostMessage, CBoxNetView::TIMER_PENDING_RECONNECT, ONE_FIFTH_OF_A_SECOND, NO_TIMER_PROCEDURE ) ) {
                // Block() should not fail because we are unblocking the pin and
                // we are passing in valid arguments.
                EXECUTE_ASSERT( SUCCEEDED( pDynamicOutputPin->Block(0, NULL) ) );

                // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
                EXECUTE_ASSERT( ::CloseHandle( hBlockEvent ) );

                DWORD dwLastWin32Error = ::GetLastError();
                return AmHresultFromWin32( dwLastWin32Error );
            }
        }

        m_hPendingReconnectBlockEvent = hBlockEvent;
        m_pPendingReconnectOutputPin = pDynamicOutputPin; // CComPtr::operator=() will automatically addref this pin.
        return GE_S_RECONNECT_PENDING;

    case WAIT_FAILED:
        {
            DWORD dwLastWin32Error = ::GetLastError();
            return AmHresultFromWin32( dwLastWin32Error );
        }

    case WAIT_ABANDONED:
    default:
        DbgBreak( "An Unexpected case occured in CBoxNetDoc::StartReconnect()." );
        return E_UNEXPECTED;
    }
}

HRESULT CBoxNetDoc::EndReconnect( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin )
{
    HRESULT hr = EndReconnectInternal( pFilterGraph, pDynamicOutputPin );

    // Unblock the output pin.
    HRESULT hrBlock = pDynamicOutputPin->Block( 0, NULL );

    if( FAILED( hr ) ) {
        return hr;
    } else if( FAILED( hrBlock ) ) {
        return hrBlock;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::EndReconnectInternal( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin )
{
    CComPtr<IGraphConfig> pGraphConfig;

    HRESULT hr = pFilterGraph->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return hr;
    }

    CComPtr<IPin> pOutputPin;

    hr = pDynamicOutputPin->QueryInterface( IID_IPin, (void**)&pOutputPin );
    if( FAILED( hr ) ) {
        return hr;
    }

    hr = pGraphConfig->Reconnect( pOutputPin, NULL, NULL, NULL, NULL, AM_GRAPH_CONFIG_RECONNECT_CACHE_REMOVED_FILTERS );

    UpdateFilters();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::ProcessPendingReconnect( void )
{
    // ::KillTimer() does not remove WM_TIMER messages which have already been posted to a
    // window's message queue.  Therefore, it is possible to receive WM_TIMER messages after
    // the pin has been reconnected.
    if( !AsyncReconnectInProgress() ) {
        return S_FALSE;
    }

    const DWORD DONT_WAIT = 0;
    const DWORD PIN_BLOCKED = WAIT_OBJECT_0;

    DWORD dwReturnValue = ::WaitForSingleObject( m_hPendingReconnectBlockEvent, DONT_WAIT );

    if( (WAIT_TIMEOUT != dwReturnValue) && (PIN_BLOCKED != dwReturnValue) ) {
        ReleaseReconnectResources( ASYNC_RECONNECT_UNBLOCK );
    }

    switch( dwReturnValue ) {
    case WAIT_TIMEOUT:
        return S_FALSE;

    case PIN_BLOCKED:
        {
            HRESULT hr = EndReconnect( IGraph(), m_pPendingReconnectOutputPin );

            ReleaseReconnectResources( ASYNC_RECONNECT_NO_FLAGS );

            if( FAILED( hr ) ) {
                return hr;
            }

            return S_OK;
        }

    case WAIT_FAILED:
        {
            DWORD dwLastWin32Error = ::GetLastError();
            return AmHresultFromWin32( dwLastWin32Error );
        }

    case WAIT_ABANDONED:
    default:
        DbgBreak( "An Unexpected case occured in CBoxNetDoc::ProcessPendingReconnect()." );
        return E_UNEXPECTED;
    }
}

void CBoxNetDoc::ReleaseReconnectResources( ASYNC_RECONNECT_FLAGS arfFlags )
{
    if( !AsyncReconnectInProgress() ) {
        return;
    }

    if( arfFlags & ASYNC_RECONNECT_UNBLOCK ) {
        // Block() should not fail because we are unblocking the pin and
        // we are passing in valid arguments.
        EXECUTE_ASSERT( SUCCEEDED( m_pPendingReconnectOutputPin->Block(0, NULL) ) );
    }

    m_pPendingReconnectOutputPin = NULL; // Release our reference on the output pin.

    // This call should not fail because we have access to hBlockEvent and hBlockEvent is a valid event.
    EXECUTE_ASSERT( ::CloseHandle( m_hPendingReconnectBlockEvent ) );
    m_hPendingReconnectBlockEvent = NULL;

    // Since the timer exists and m_hWndPostMessage is a valid window handle, this function
    // should not fail.
    EXECUTE_ASSERT( ::KillTimer( m_hWndPostMessage, CBoxNetView::TIMER_PENDING_RECONNECT ) );
}

bool CBoxNetDoc::AsyncReconnectInProgress( void ) const
{
    // Make sure the pending reconnect state is consitent.  Either the user is waiting on event
    // m_hPendingReconnectBlockEvent and m_pPendingReconnectOutputPin contains the pin being
    // reconnected or both variables should be unused.
    ASSERT( ( m_pPendingReconnectOutputPin && (NULL != m_hPendingReconnectBlockEvent) ) ||
            ( !m_pPendingReconnectOutputPin && (NULL == m_hPendingReconnectBlockEvent) ) );

    return (m_pPendingReconnectOutputPin && (NULL != m_hPendingReconnectBlockEvent));
}

HRESULT CBoxNetDoc::SafePrintGraphAsHTML( HANDLE hFile )
{
    CPrintGraphAsHTMLCallback::PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL sPrintGraphAsHTMLInternalParameters;

    sPrintGraphAsHTMLInternalParameters.pDocument = this;
    sPrintGraphAsHTMLInternalParameters.hFileHandle = hFile;

    IGraphConfigCallback* pPrintGraphAsHTMLCallback = CPrintGraphAsHTMLCallback::CreateInstance();
    if( NULL == pPrintGraphAsHTMLCallback ) {
        return E_FAIL;
    }

    HRESULT hr = IfPossiblePreventStateChangesWhileOperationExecutes( IGraph(), pPrintGraphAsHTMLCallback, (void*)&sPrintGraphAsHTMLInternalParameters );

    pPrintGraphAsHTMLCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}

HRESULT CBoxNetDoc::SafeEnumCachedFilters( void )
{
    IGraphConfigCallback* pEnumFilterCacheCallback = CEnumerateFilterCacheCallback::CreateInstance();
    if( NULL == pEnumFilterCacheCallback ) {
        return E_FAIL;
    }

    HRESULT hr = PreventStateChangesWhileOperationExecutes( IGraph(), pEnumFilterCacheCallback, (void*)this );

    pEnumFilterCacheCallback->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
}


/* Constants used by zooming code */
const int MAX_ZOOM=6;
const int nItemCount=6;
const int nZoomLevel[nItemCount] = {25, 50, 75, 100, 150, 200};
const UINT nZoomItems[nItemCount] = {ID_WINDOW_ZOOM25,  ID_WINDOW_ZOOM50,  ID_WINDOW_ZOOM75,
                               ID_WINDOW_ZOOM100, ID_WINDOW_ZOOM150, ID_WINDOW_ZOOM200 };

void CBoxNetDoc::IncreaseZoom()
{
    if (m_nCurrentSize < MAX_ZOOM-1)
    {
        OnWindowZoom(nZoomLevel[m_nCurrentSize+1], nZoomItems[m_nCurrentSize+1]);
    }
}

void CBoxNetDoc::DecreaseZoom()
{
    if (m_nCurrentSize > 0)
    {
        OnWindowZoom(nZoomLevel[m_nCurrentSize-1], nZoomItems[m_nCurrentSize-1]);
    }
}

void CBoxNetDoc::OnWindowZoom(int iZoom, UINT iMenuItem)
{
    // Get main window handle
    CWnd* pMain = AfxGetMainWnd();

    if (pMain != NULL)
    {
        // Get the main window's menu
        CMenu* pMainMenu = pMain->GetMenu();

        // Get the handle of the "View" menu
        CMenu *pMenu = pMainMenu->GetSubMenu(2);        

        // Update the zoom check marks.  Check the selection and uncheck all others.
        if (pMenu != NULL)
        {
            // Set/clear checkboxes that indicate the zoom ratio
            for (int i=0; i<nItemCount; i++)
            {
                if (iMenuItem == nZoomItems[i])
                {
                    pMenu->CheckMenuItem(iMenuItem, MF_CHECKED | MF_BYCOMMAND);
                    m_nCurrentSize = i;
                }
                else
                    pMenu->CheckMenuItem(nZoomItems[i], MF_UNCHECKED | MF_BYCOMMAND);
            }
        }   
    }

    // Zoom to the requested ratio
    CBox::SetZoom(iZoom);
    OnWindowRefresh();    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\bnetdoc.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// bnetdoc.h : declares CBoxNetDoc
//


// forward declarations
class CCmd;
class CRegFilter;
class CPropObject;


const int MAX_STRING_LEN=1000;
const int MAXFILTERS = 100;
typedef struct { //fit
    int iFilterCount;
    struct {
        DWORD dwUnconnectedInputPins;
        DWORD dwUnconnectedOutputPins;
        FILTER_INFO finfo;
        IBaseFilter * pFilter;
        bool IsSource;
    } Item[MAXFILTERS];
} FILTER_INFO_TABLE;

// for passing internal messages (see bnetdoc.cpp, search WM_USER_EC_EVENT)
struct NetDocUserMessage
{
    long        lEventCode;
    LONG_PTR    lParam1;
    LONG_PTR    lParam2;
};

// *
// * CBoxNetDoc
// *

// A CBoxNetDoc is intended to reflect the contents of the graph it instantiates
// and allows the user to interact with.
// Therefore it maintains a list of all the filters and connections(links) that are
// currently in the graph.
class CBoxNetDoc : public CDocument {

    DECLARE_DYNCREATE(CBoxNetDoc)

public:

    // <lHint> codes for ModifiedDoc(), UpdateAllViews(), etc.
    enum EHint
    {
        HINT_DRAW_ALL = 0,              // redraw entire view (must be zero!)
        HINT_CANCEL_VIEWSELECT,         // cancel any view-specific selection
        HINT_CANCEL_MODES,              // cancel any current modes
        HINT_DRAW_BOX,                  // draw only specified box
        HINT_DRAW_BOXANDLINKS,          // draw only box and connected links
        HINT_DRAW_BOXTAB,               // draw only specified box tab
        HINT_DRAW_LINK                  // draw only specified box link
    };

public:
    // contents of the document
    CBoxList        m_lstBoxes;         // each CBox in document
    CLinkList       m_lstLinks;         // each CBoxLink in document
    int             m_nCurrentSize;

    CSize       GetSize(void);  // the document's current size (pixels)

protected:
    // undo/redo stacks
    CMaxList        m_lstUndo;          // each CCmd in undo stack
    CMaxList        m_lstRedo;          // each CCmd in redo stack

public:
    // construction and destruction
                 CBoxNetDoc();
    virtual      ~CBoxNetDoc();
    virtual void DeleteContents();  // release quartz mapper & graph
    virtual void OnCloseDocument();

    virtual BOOL OnNewDocument();   // get quartz mapper & graph

    // storage & serialization
    virtual BOOL AttemptFileRender(LPCTSTR lpszPathName);
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);  

    virtual BOOL SaveModified(void);

    static DWORD WINAPI NotificationThread(LPVOID lpData);

private:
    virtual void CloseDownThread();     // close the notification thread

    BOOL m_bNewFilenameRequired;

    // This constant is NOT localisable
    static const OLECHAR m_StreamName[];

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
    void MyDump(CDumpContext& dc) const;
#endif

public:
    // general public functions
    void ModifiedDoc(CView* pSender, LPARAM lHint = 0L,
        CObject* pHint = NULL);
    void DeselectAll();

public:
    // CBox lists and box selection
    void GetBoundingRect(CRect *prc, BOOL fBoxSel);
    void SelectBox(CBox *pbox, BOOL fSelect);
    void SelectLink(CBoxLink *plink, BOOL fSelect);
    BOOL IsSelectionEmpty() { return (IsLinkSelectionEmpty() && IsBoxSelectionEmpty()); }
    BOOL IsBoxSelectionEmpty();
    void GetBoxes(CBoxList *plstDst, BOOL fSelected = FALSE);
    void GetBoxSelection(CBoxList *plstDst)
        { GetBoxes(plstDst, TRUE); }
    void SetBoxes(CBoxList *plstSrc, BOOL fSelected = FALSE);
    void InvalidateBoxes(CBoxList *plst);
    void SetBoxSelection(CBoxList *plstDst)
        { SetBoxes(plstDst, TRUE); }
    void MoveBoxSelection(CSize sizOffset);

    void SelectBoxes(CList<CBox *, CBox*> *plst);
    void SelectLinks(CList<CBoxLink *, CBoxLink *> *plst);
    void OnWindowZoom(int iZoom, UINT iMenuItem);
    void IncreaseZoom();
    void DecreaseZoom();

private:
    BOOL IsLinkSelectionEmpty();

public:
    // command processing
    void CmdDo(CCmd *pcmd);
    void CmdUndo();
    BOOL CanUndo();
    void CmdRedo();
    BOOL CanRedo();
    void CmdRepeat();
    BOOL CanRepeat();

protected:
    // message callback helper functions
    void UpdateEditUndoRedoRepeat(CCmdUI* pCmdUI, BOOL fEnable,
        unsigned idStringFmt, CMaxList *plst);

    virtual void SetTitle( LPCTSTR lpszTitle );

protected:
    void OnQuartzAbortStop();

    // message callback functions
    //{{AFX_MSG(CBoxNetDoc)
    afx_msg void OnFileRender();
    afx_msg void OnURLRender();
    afx_msg void OnUpdateFileRender(CCmdUI*);
    afx_msg void OnUpdateURLRender(CCmdUI *);
    afx_msg void OnUpdateFileSave(CCmdUI*);
    afx_msg void OnEditUndo();
    afx_msg void OnEditRedo();
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
    afx_msg void OnEditSelectAll();
    afx_msg void OnUpdateEditSelectAll(CCmdUI* pCmdUI);
    afx_msg void OnQuartzDisconnect();
    afx_msg void OnQuartzRun();
    afx_msg void OnUpdateQuartzDisconnect(CCmdUI* pCmdUI);
    afx_msg void OnWindowRefresh();
    afx_msg void OnWindowZoom25()  { OnWindowZoom(25,  ID_WINDOW_ZOOM25); }
    afx_msg void OnWindowZoom50()  { OnWindowZoom(50,  ID_WINDOW_ZOOM50); }
    afx_msg void OnWindowZoom75()  { OnWindowZoom(75,  ID_WINDOW_ZOOM75); }
    afx_msg void OnWindowZoom100() { OnWindowZoom(100, ID_WINDOW_ZOOM100); }
    afx_msg void OnWindowZoom150() { OnWindowZoom(150, ID_WINDOW_ZOOM150); }
    afx_msg void OnWindowZoom200() { OnWindowZoom(200, ID_WINDOW_ZOOM200); }
    afx_msg void OnViewSeekBar();
    afx_msg void OnUpdateQuartzRun(CCmdUI* pCmdUI);
    afx_msg void OnUpdateQuartzPause(CCmdUI* pCmdUI);
    afx_msg void OnUpdateQuartzStop(CCmdUI* pCmdUI);
    afx_msg void OnQuartzStop();
    afx_msg void OnQuartzPause();
    afx_msg void OnUpdateUseClock(CCmdUI* pCmdUI);
    afx_msg void OnUseClock();
    afx_msg void OnUpdateConnectSmart(CCmdUI* pCmdUI);
    afx_msg void OnConnectSmart();
    afx_msg void OnUpdateAutoArrange(CCmdUI* pCmdUI);
    afx_msg void OnAutoArrange();
    afx_msg void OnSaveGraphAsHTML();
    afx_msg void OnSaveGraphAsXML();
    afx_msg void OnConnectToGraph();
    afx_msg void OnGraphStats();
    afx_msg void OnGraphAddFilterToCache();
    afx_msg void OnUpdateGraphAddFilterToCache(CCmdUI* pCmdUI);
    afx_msg void OnGraphEnumCachedFilters();
    //}}AFX_MSG

    afx_msg void OnInsertFilter();

    // -- Pin properties menu --
    afx_msg void OnUpdateQuartzRender(CCmdUI* pCmdUI);
    afx_msg void OnQuartzRender();

    afx_msg void OnUpdateReconnect( CCmdUI* pCmdUI );
    afx_msg void OnReconnect( void );

    DECLARE_MESSAGE_MAP()

    // --- Quartz Stuff ---
public:
    void OnGraphEnumCachedFiltersInternal( void );

    IGraphBuilder  *IGraph(void) const {
        ASSERT(m_pGraph);
        return (*m_pGraph).operator IGraphBuilder*();
    }
    IMediaEvent *IEvent(void) const {
        ASSERT(m_pMediaEvent);
        return (*m_pMediaEvent).operator IMediaEvent *();
    }

    void OnWM_USER(NetDocUserMessage *);
    HRESULT UpdateFilters(void);
    void UpdateFiltersInternal(void);
    void      SelectedSocket(CBoxSocket *psock) { m_psockSelected = psock; }
    CBoxSocket    *SelectedSocket(void) { ASSERT_VALID(m_psockSelected); return m_psockSelected; }
    void      CurrentPropObject(CPropObject *pPropObject) { m_pCurrentPropObject = pPropObject; }
    CPropObject   *CurrentPropObject(void) { ASSERT(m_pCurrentPropObject); return m_pCurrentPropObject; }

    // Unknown state used after failure of Play, Pause or Stop. In this
    // case some filters might have changed state while others haven't.
    enum State { Playing, Paused, Stopped, Unknown };


    BOOL      IsStopped(void) { return m_State == Stopped; }
    State     GetState(void) { return m_State; }

    static const int m_iMaxInsertFilters;   // the maximum length of the insert menu
                            // need hard coded restriction for message map
    BOOL        m_fConnectSmart;        // true -> use Connect
                                        // false -> use ConnectDirect
    BOOL        m_fAutoArrange;         // true -> re-arrange graph view on refresh
                                        // false -> don't re-arrange graph view
    BOOL        m_fRegistryChanged;     // true -> registry has changed since last insert filters
                                        // false -> registry hasn't changed
    //
    // Array which holds the three Handles passed to the thread.
    // 1 = event handle for EC_ notifications,
    // 2 = event handle to terminate thread,
    // 3 = event handle to registry change
    //
    HANDLE  m_phThreadData[3];

    // The window our thread posts a message to
    HWND        m_hWndPostMessage;

    void SetSelectClock(CBox *pBox);  // Notification of which clock was selected
    void UpdateClockSelection();


    void ConnectToGraph();

    void PrintGraphAsHTML(HANDLE hFile);

    HRESULT ProcessPendingReconnect( void );
    HRESULT StartReconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin );

private:

    BOOL    CreateGraphAndMapper(void);

    CQCOMInt<IGraphBuilder> *m_pGraph;
    CQCOMInt<IMediaEvent>       *m_pMediaEvent;
    IStream                     *m_pMarshalStream;

    CBoxSocket  *m_psockSelected;   // the socket the user last right clicked on.
    CPropObject *m_pCurrentPropObject;  // the property object the user last right clicked on

    HRESULT GetFiltersInGraph(void);
    HRESULT GetLinksInGraph(void);  
    HRESULT FilterDisplay(void);
    void    SetBoxesHorizontally(void);
    void    SetBoxesVertically(void);
    void    RealiseGrid(void);

    void WriteString(HANDLE hFile, LPCTSTR lpctstr, ...);

    void PrintFilterObjects(HANDLE hFile, TCHAR atchBuffer[], FILTER_INFO_TABLE *pfit);
    void PopulateFIT(HANDLE hFile, IFilterGraph *pGraph, TCHAR atchBuffer[],
            FILTER_INFO_TABLE *pfit);
    BOOL GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter);
    int LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter);
    void MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter);

    HRESULT SafePrintGraphAsHTML( HANDLE hFile );
    HRESULT SafeEnumCachedFilters( void );

    State   m_State;

    // Handle to the thread
    HANDLE      m_hThread;

    BOOL    m_fUsingClock;          // true (default) if using the default clock

    TCHAR m_tszStgPath[MAX_PATH];  // remember the path to our storage
    CString m_strHTMLPath; // remember the last html doc we saved
    CString m_strXMLPath; // remember the last html doc we saved
    long m_lSourceFilterCount; // Append digits to source filter names to make them unique


    // Internal Reconnect Functions.
    enum ASYNC_RECONNECT_FLAGS
    {
        ASYNC_RECONNECT_NO_FLAGS = 0,
        ASYNC_RECONNECT_UNBLOCK = 1
    };

    HRESULT EndReconnect( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin );
    HRESULT EndReconnectInternal( IGraphBuilder* pFilterGraph, IPinFlowControl* pDynamicOutputPin );
    void ReleaseReconnectResources( ASYNC_RECONNECT_FLAGS arfFlags );

public:
    bool AsyncReconnectInProgress( void ) const;

private:
    HANDLE m_hPendingReconnectBlockEvent;
    CComPtr<IPinFlowControl> m_pPendingReconnectOutputPin;
};

// Our message number
#define WM_USER_EC_EVENT WM_USER + 73


// a CRect's width or height must not exceed 0x8000
#define MAX_DOCUMENT_SIZE 32767
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\bnetvw.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// bnetvw.h : declares CBoxNetView
//

/////////////////////////////////////////////////////////////////////////////
// CBoxNetView
//

// forward declaration
class CPropDlg;

class CBoxNetView : public CScrollView
{
    DECLARE_DYNCREATE(CBoxNetView)

public:
    // construction and destruction
    CBoxNetView();
    virtual ~CBoxNetView();

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    // View updatiing, & drawing

    virtual void           OnInitialUpdate(void);
    virtual void           OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    virtual void           OnDraw(CDC* pdc);  // overridden to draw this view

    // What, if anything, is under the point pt?
    virtual CBoxDraw::EHit HitTest(CPoint	pt,
                                   CBox		**ppbox,
                                   CBoxTabPos	*ptabpos,
                                   CBoxSocket	**ppsock,
                                   CBoxLink	**pplink,
                                   CPoint	*pptProject
                                   );

protected:
    // general protected functions
    CBoxNetDoc* CBoxNetView::GetDocument(void) { ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CBoxNetDoc)));
                                                 return (CBoxNetDoc*) m_pDocument;
                                               }
    void CancelModes();

protected:
    // printing support
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pdc, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pdc, CPrintInfo* pInfo);

public:
    // IDs for timers used by view
    enum
    {
        TIMER_MOVE_SEL_PENDING = 1,  // used during move-selection-pending mode
        TIMER_SEEKBAR = 2,
        TIMER_PENDING_RECONNECT = 3
    };

protected:

    // view modes that are cancelled when the mouse button is released
    BOOL        m_fMouseDrag;       // mouse is being dragged in window?
    BOOL        m_fMoveBoxSelPending; // waiting to enter move-sel mode?
    BOOL        m_fMoveBoxSel;      // currently moving selection of boxes?
    BOOL        m_fGhostSelection;  // there is currently a ghost selection?
    BOOL        m_fSelectRect;      // draw a rectangle round boxes to select?
    BOOL        m_fNewLink;         // create a new link?
    BOOL        m_fGhostArrow;      // there is currently a ghost arrow?
    CBoxSocket *m_psockHilite;      // currently-hilited socket tab (or NULL)

private:
    // context menus

    void	PreparePinMenu(CMenu *pmenuPopup);
    void        PrepareLinkMenu(CMenu *pmenuPopup);
    void	PrepareFilterMenu(CMenu *pmenuPopup, CBox *);

protected:
    // state/functions for mouse-drag mode (iff <m_fMouseDrag>)
    BOOL        m_fMouseShift;      // user shift-clicked?
    CPoint      m_ptMouseAnchor;    // where mouse drag began
    CPoint      m_ptMousePrev;      // where mouse was previously
    CBox *      m_pboxMouse;        // box clicked on at start of drag
    BOOL        m_fMouseBoxSel;     // clicked-on box was initally selected?
    void MouseDragBegin(UINT nFlags, CPoint pt, CBox *pboxMouse);
    void MouseDragContinue(CPoint pt);
    void MouseDragEnd();

protected:
    // state/functions for move-selection-pending mode
    // (iff <m_fMoveBoxSelPending>)
    CRect       m_rcMoveSelPending; // start move-selection when outside this
    void MoveBoxSelPendingBegin(CPoint pt);
    void MoveBoxSelPendingContinue(CPoint pt);
    void MoveBoxSelPendingEnd(BOOL fCancel);

protected:
    // state/functions for move-selection mode
    // (iff <m_fMoveBoxSel>)
    void MoveBoxSelBegin();
    void MoveBoxSelContinue(CSize sizOffset);
    void MoveBoxSelEnd(BOOL fCancel);
    void MoveBoxSelection(CSize sizOffset);
    CSize ConstrainMoveBoxSel(CSize sizOffset, BOOL fCalcSelBoundRect);

protected:
    // state/functions for ghost-selection mode
    // (iff <m_fGhostSelection>)
    CSize       m_sizGhostSelOffset; // ghost sel. offset from sel. this much
    CRect       m_rcSelBound;       // bounding rectangle around non-ghost sel.
    void GhostSelectionCreate();
    void GhostSelectionMove(CSize sizOffset);
    void GhostSelectionDestroy(void);
    void GhostSelectionDraw(CDC *pdc);

protected:
    // state/functions for select-rectangle mode
    // (iff <m_fSelectRect>)
    CPoint      m_ptSelectRectAnchor; // where select-rect drag began
    CPoint      m_ptSelectRectPrev; // previous mouse drag location
    void SelectRectBegin(CPoint pt);
    void SelectRectContinue(CPoint pt);
    void SelectRectEnd(BOOL fCancel);
    void SelectRectDraw(CDC *pdc);
    void SelectBoxesIntersectingRect(CRect *prc);

protected:
    // state/functions for new-link mode
    // (iff <m_fNewLink>)
    CBoxSocket *m_psockNewLinkAnchor; // clicked-on socket tab
    void NewLinkBegin(CPoint pt, CBoxSocket *psock);
    void NewLinkContinue(CPoint pt);
    void NewLinkEnd(BOOL fCancel);

protected:
    // state/functions for ghost-arrow mode
    // (iff <m_fGhostArrow>)
    CPoint      m_ptGhostArrowTail; // tail of ghost arrow
    CPoint      m_ptGhostArrowHead; // head of ghost arrow
    void GhostArrowBegin(CPoint pt);
    void GhostArrowContinue(CPoint pt);
    void GhostArrowEnd();
    void GhostArrowDraw(CDC *pdc);

protected:
    // state/functions for highlight-tab mode (iff <m_psockHilite> not NULL)
    void SetHiliteTab(CBoxSocket *psock);

protected:
    // performace logging module handle. NULL if not present
    HINSTANCE	m_hinstPerf;

protected:
    // Drag and drop attributes
    COleDropTarget      m_DropTarget;
    DROPEFFECT          m_DropEffect;
    CLIPFORMAT          m_cfClipFormat;

public:
    // Drag and drop functions
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);

protected:
    // message callback functions
    //{{AFX_MSG(CBoxNetView)
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg BOOL OnEraseBkgnd(CDC* pdc);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnCancelModes();
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
    afx_msg void OnEditDelete();
    afx_msg void OnUpdateSavePerfLog(CCmdUI* pCmdUI);
    afx_msg void OnSavePerfLog();
    afx_msg void OnUpdateNewPerfLog(CCmdUI* pCmdUI);
    afx_msg void OnNewPerfLog();
	afx_msg void OnFileSetLog();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnViewSeekbar();
	//}}AFX_MSG

    afx_msg void OnProperties();
    afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
    afx_msg void OnSelectClock();
    afx_msg LRESULT OnUser(WPARAM, LPARAM);

    DECLARE_MESSAGE_MAP()

    CBox * m_pSelectClockFilter;

public:

    void ShowSeekBar( );
    void CheckSeekBar( );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\box.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// box.cpp : defines CBoxTabPos, CBoxSocket, CBox
//

#include "stdafx.h"
#include <streams.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

int CBox::s_Zoom = 100;

void CBox::SetZoom(int iZoom) {
    s_Zoom = iZoom;
    gpboxdraw->RecreateFonts();
}


// these lines copied from SDK\CLASSES\BASE\FILTER.H
#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();
#define QueryPinInfoReleaseFilter(pi) if ((pi).pFilter) (pi).pFilter->Release();

// *
// * CBoxSocket
// *

//
// 'Copy' Constructor
//
// Duplicate this socket, inc. addref of the IPin
// It only makes sense to copy a socket onto a new box, so
// we need a CBox * as well.
CBoxSocket::CBoxSocket(const CBoxSocket& sock, CBox *pbox)
    : m_pbox(pbox)
    , m_plink(NULL)                     // no links copied.
    , m_stLabel(sock.m_stLabel)
    , m_tabpos(sock.m_tabpos)
    , m_IPin(sock.m_IPin) {

   ASSERT(*m_pbox != *pbox);

   ASSERT_VALID(this);

}


//
// Constructor
//
CBoxSocket::CBoxSocket(CBox *pbox,
                       CString stLabel,
                       CBoxTabPos::EEdge eEdge,
                       unsigned uiVal,          // positon as fraction
                       unsigned uiValMax,       // along edge uiVal/uiValMax
                       IPin *pPin)
    : m_pbox(pbox),
      m_stLabel(stLabel),
      m_tabpos(eEdge, uiVal, uiValMax),
      m_plink(NULL),
      m_IPin(pPin) {

    ASSERT_VALID(this);

}


//
// Destructor
//
CBoxSocket::~CBoxSocket() {

    ASSERT_VALID(this);

}

#ifdef _DEBUG
//
// AssertValid
//
void CBoxSocket::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(m_pbox);

}
#endif // _DEBUG

//
// GetDirection
//
PIN_DIRECTION CBoxSocket::GetDirection(void) {

    HRESULT hr;

    PIN_DIRECTION pd;
    hr = pIPin()->QueryDirection(&pd);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }

    ASSERT( (pd == PINDIR_INPUT) || (pd == PINDIR_OUTPUT) );

    return pd;
}


//
// IsConnected
//
BOOL CBoxSocket::IsConnected(void) {

    HRESULT hr;
    IPin *pConnected;
    hr = pIPin()->ConnectedTo(&pConnected);
    if (FAILED(hr)) {   // not connected.
        ASSERT(m_plink == NULL);
        return FALSE;
    }
    else if (hr == S_OK) {
        pConnected->Release();
        return TRUE;
    }
    else {
        TRACE("ConnectedTo Error\n");
        throw CHRESULTException(hr);
        return FALSE;   // need this to keep the compiler happy...
    }
}


//
// Peer
//
// return the socket this is connected to.
// only valid if connected.
// returns null in error case.
CBoxSocket *CBoxSocket::Peer(void) {

    IPin *pConnected;
    HRESULT hr = pIPin()->ConnectedTo(&pConnected);
    if(FAILED(hr)) {
       return NULL;     // should only fail if not connected
    }

    PIN_INFO piPeer;
    hr = pConnected->QueryPinInfo(&piPeer);
    if (FAILED(hr)) {
        pConnected->Release();
        return NULL;
    }

    CBox *pbox = m_pbox->pDoc()->m_lstBoxes.GetBox(piPeer.pFilter);
    QueryPinInfoReleaseFilter(piPeer);
    if (pbox == NULL) {
        pConnected->Release();
        return NULL;
    }

    CBoxSocket *pSocket = pbox->GetSocket(pConnected);
    pConnected->Release();
    return pSocket;
}


// *
// * CBoxSocketList
// *

//
// GetSocket
//
// Return the socket on this list that manages this pin. Return
// NULL if not present.
CBoxSocket *CBoxSocketList::GetSocket(IPin *pPin) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBoxSocket *psock = GetNext(pos);
        if ( CIPin(pPin) == CIPin(psock->pIPin()) )
            return psock;

    }

    return NULL;
}


// *
// * CBox
// *

//
// Copy Constructor
//
CBox::CBox(const CBox& box)
    : m_fSelected(box.m_fSelected)
    , m_fHasClock(box.m_fHasClock)
    , m_fClockSelected(FALSE)
    , m_IFilter(box.m_IFilter)
    , m_rcBound(box.m_rcBound)
    , m_stLabel(box.m_stLabel)
    , m_pDoc(box.m_pDoc)
    , m_RelativeY(box.m_RelativeY)
    , m_lInputTabPos(box.m_lInputTabPos)
    , m_lOutputTabPos(box.m_lOutputTabPos)
    , m_iTotalInput(box.m_iTotalInput)
    , m_iTotalOutput(box.m_iTotalOutput) {

    POSITION posNext = box.m_lstSockets.GetHeadPosition();

    while (posNext != NULL) {

        CBoxSocket *psock = (CBoxSocket *) box.m_lstSockets.GetNext(posNext);
        CBoxSocket *psockNew = new CBoxSocket(*psock, this);
        m_lstSockets.AddTail(psockNew);
    }
}


//
// CBox::Constructor
//
CBox::CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc, CString *pName, CPoint point)
    : m_IFilter(pFilter)
    , m_fSelected(FALSE)
    , m_fClockSelected(FALSE)
    , m_pDoc(pDoc)
    , m_rcBound(point, CSize(0,0))
    , m_RelativeY(0.0f)
{

    //
    // Do we have a IReferenceClock
    //
    IReferenceClock * pClock;
    HRESULT hr = pIFilter()->QueryInterface(IID_IReferenceClock, (void **) &pClock);
    m_fHasClock = SUCCEEDED(hr);
    if (SUCCEEDED(hr)) {
        pClock->Release();
    }

    m_stFilter = *pName;

    // See if this filter needs a file opening
    // needs a better soln - what about other interfaces?
    AttemptFileOpen(pIFilter());

    GetLabelFromFilter( &m_stLabel );
    UpdateSockets();

    //
    // If point was not (-1, -1) then we can exit now.
    //
    if ((point.x != -1) || (point.y != -1)) {
        return;
    }

    //
    // We need to place the box out of the way from other boxes in the
    // view.
    //

    CWnd *pWnd;
    CScrollView * pScrollView;
    {
        // Get the only view from the document and recast it into a CWnd.
        // the view.
        POSITION pos = pDoc->GetFirstViewPosition();
        ASSERT(pos);

        pScrollView = (CScrollView *) pDoc->GetNextView(pos);
        pWnd = (CWnd *) pScrollView;
        ASSERT(!pos);
    }

    // Get the dimension of the window in device units.
    RECT rectWndSize;
    pWnd->GetClientRect(&rectWndSize);

    // Use the DC to convert from device units to logical units
    CDC * pDC   = pWnd->GetDC();
    pDC->DPtoLP(&rectWndSize);
    pWnd->ReleaseDC(pDC);

    //
    // Place the box at the bottom of the window minus the size of the box
    // minus a bit. Note that the window size equals to the size needed to
    // contain all filters.
    //
    int newPosition = rectWndSize.bottom - Height();

    if (newPosition < 0) {
        newPosition = 0;
    }

    //
    // If there are no filters above us, we can move further up.
    //
    CSize pSize = pScrollView->GetTotalSize();
    CPoint pt = pScrollView->GetScrollPosition();

    if (newPosition > pSize.cy) {
        newPosition = pSize.cy;
    }

    Location(CPoint(pt.x, newPosition));
}

//
// Constructor(IBaseFilter *)
//
CBox::CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc)
    : m_pDoc(pDoc)
    , m_IFilter(pFilter)
    , m_fSelected(FALSE)
    , m_fClockSelected(FALSE)
    , m_rcBound(0,0,0,0)
{

    //
    // Do we have a IReferenceClock
    //
    IReferenceClock * pClock;
    HRESULT hr = pIFilter()->QueryInterface(IID_IReferenceClock, (void **) &pClock);
    m_fHasClock = SUCCEEDED(hr);
    if (SUCCEEDED(hr)) {
        pClock->Release();
    }

    GetLabelFromFilter( &m_stLabel );

    UpdateSockets();
}

// CBox::GetFilterLabel
//
// Get the filters name from the filter or the registry
//
void CBox::GetLabelFromFilter( CString *pstLabel )
{
    // Try and get the filter name
    if (m_stFilter == "") {
        FILTER_INFO fi;
        m_IFilter->QueryFilterInfo( &fi );
        QueryFilterInfoReleaseGraph( fi );

        if ((fi.achName != NULL) && (fi.achName[0] != 0)) {
            // the filter has a name
            m_stFilter = CString( fi.achName );
        }
        else {
            // If that lot failed attempt to get the name from the ClsID
            // get the name through the clsid
            CLSID clsidTemp;
            m_IFilter->GetClassID(&clsidTemp);
            WCHAR szGuid[40];
            StringFromGUID2(clsidTemp, szGuid, 40 );
            m_stFilter = szGuid;
        }
    }

    // Try and get the box label (either the filter name
    // or the filename of the source/sink file)
    if (*pstLabel != m_stFilter) {
        IFileSourceFilter *pIFileSource;
        IFileSinkFilter *pIFileSink;
        BOOL bSource, bSink, bGotLabel = FALSE;
        LPOLESTR poszName;
        AM_MEDIA_TYPE mtNotUsed;

        bSource = SUCCEEDED(m_IFilter->QueryInterface(IID_IFileSourceFilter, (void **) &pIFileSource));
        bSink   = SUCCEEDED(m_IFilter->QueryInterface(IID_IFileSinkFilter, (void **) &pIFileSink));

        ASSERT( bSource || !pIFileSource );
        ASSERT( bSink   || !pIFileSink   );

        // If we have a source but no sink attempt to get the source filename
        if( bSource && !bSink ){
            if (SUCCEEDED(pIFileSource->GetCurFile(&poszName, &mtNotUsed)) && poszName){
                *pstLabel = (LPCWSTR) poszName;
                CoTaskMemFree(poszName);
                bGotLabel = TRUE;
            }
        } else if( bSink && !bSource ){
            // Else if we have a sink but no ssource attempt to get the sink filename
                if (SUCCEEDED(pIFileSink->GetCurFile(&poszName, &mtNotUsed)) &&
                    poszName){
                *pstLabel = (LPCWSTR) poszName;
                CoTaskMemFree(poszName);
                bGotLabel = TRUE;
            }
        }

        // If a label was set, remove the path of the source/sink filename
        if (bGotLabel)
        {
            CString str(*pstLabel);   // Copy the label
            TCHAR ch=TEXT('\\');

            str.MakeReverse();        // Reverse string
            int nSlash = str.Find(ch);// Look for '\' path character
            if (nSlash != -1)
            {
                ch = TEXT('\0');
                str.SetAt(nSlash, ch);  // Null-terminate
               
                str.MakeReverse();      // Return to original order
                int nLength = str.GetLength();
                str.Delete(nSlash, nLength - nSlash);

                *pstLabel = str;        // Copy new string to original
                pstLabel->FreeExtra();
            }
        }

        if( pIFileSource ) pIFileSource->Release();
        if( pIFileSink   ) pIFileSink  ->Release();

        if (!bGotLabel) {
            *pstLabel = m_stFilter;
        }
    }
}


//
// Destructor
//
CBox::~CBox() {

    //
    // Remove all Sockets from out box
    //
    while ( NULL != m_lstSockets.GetHeadPosition() ) {
        RemoveSocket( m_lstSockets.GetHeadPosition(), TRUE );
    }

    HideDialog();

    TRACE("~CBox: %x\n", this);

}


//
// Refresh
//
// re-calculate the sockets we need if the pins have changed
HRESULT CBox::Refresh(void) {

    // update box's label (properties may have changed it)
    GetLabelFromFilter(&m_stLabel);

    try {

        UpdateSockets();
    }
    catch (CHRESULTException chr) {
        return chr.Reason();
    }

    return NOERROR;
}


//
// CBox::operator==
//
BOOL CBox::operator==(const CBox& box) const {

    ASSERT_VALID(&box);
    ASSERT_VALID(this);

    // need to make a meaningful descision about socket list
    // equality.

    return (  (m_rcBound       == box.m_rcBound)
            &&(m_IFilter       == (IUnknown *)box.m_IFilter)
            &&(m_stLabel       == box.m_stLabel)
            &&(m_lInputTabPos  == box.m_lInputTabPos)
            &&(m_lOutputTabPos == box.m_lOutputTabPos)
            &&(m_pDoc          == box.m_pDoc)
           );
}


//
// AddToGraph
//
// Adds this filter to the graph
HRESULT CBox::AddToGraph(void) {

    ASSERT(m_pDoc);
    ASSERT(pIFilter());

    TRACE("Adding filter (@: %x)\n", pIFilter());

    // Add the filter. Use it's own name (not our label) as its name
#ifdef _UNICODE
    HRESULT hr = m_pDoc->IGraph()->AddFilter(pIFilter(), (LPCTSTR) m_stFilter);
#else
    WCHAR wszName[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, (LPCSTR) m_stFilter, -1, wszName, MAX_PATH);

    HRESULT hr = m_pDoc->IGraph()->AddFilter(pIFilter(), wszName);
#endif

    if (FAILED(hr)) {
        TRACE("Failed to add filter (@: %x)\n", pIFilter());
        return hr;
    }

    return NOERROR;
}


//
// RemoveFromGraph
//
// Removes filter from graph
HRESULT CBox::RemoveFromGraph(void) {

    TRACE("Removing Filter (@: %x)\n", pIFilter());

    ASSERT(m_pDoc);
    ASSERT(pIFilter());

    return m_pDoc->IGraph()->RemoveFilter(pIFilter());

}


//
// CalcTabPos
//
// Decide how many socket positions to have on box edge
void CBox::CalcTabPos(void) {

    PIN_INFO   pi;              // Information about each pin
    IPin      *pPin;            // Holds next pin obtained
    CPinEnum  NextInput(pIFilter(), CPinEnum::Input);   // Pin enumerator

    int iMaxOutputLabel = 0;  // biggest size of output pin names
    int iMaxInputLabel = 0;   // biggest size of input pin names

    m_iTotalInput = m_iTotalOutput = 0;
    m_lInputTabPos = m_lOutputTabPos = 0;

    while (0 != (pPin = NextInput())) {
        m_iTotalInput++;

        if (!FAILED(pPin->QueryPinInfo(&pi))) {
            iMaxInputLabel = max(iMaxInputLabel, (int) wcslen(pi.achName));
            QueryPinInfoReleaseFilter(pi);
        }

        pPin->Release();
    }

    CPinEnum  NextOutput(pIFilter(), CPinEnum::Output); // Pin enumerator
    while (0 != (pPin = NextOutput())) {
        m_iTotalOutput++;

        if (!FAILED(pPin->QueryPinInfo(&pi))) {
            iMaxOutputLabel = max(iMaxOutputLabel, (int) wcslen(pi.achName));
            QueryPinInfoReleaseFilter(pi);
        }

        pPin->Release();
    }

    m_lInputTabPos = m_iTotalInput;
    m_lOutputTabPos = m_iTotalOutput;

    // looks better if there are an even no of pin positions....
    if (m_lInputTabPos % 2 == 1)
        m_lInputTabPos++;

    if (m_lOutputTabPos % 2 == 1)
        m_lOutputTabPos++;

    // set the box size appropriately
    // inflate the rectangle by the differnce between the old height
    // and width and the new dimentions.

    // X should be at least 100 and be able to hold the name of the box
    // and the names of all pins.
    //
    // Note + 20 and + 30 are gaps, so that the labels don't glue to the
    // border.
    //
    int iNewXSize = max ((iMaxOutputLabel + iMaxInputLabel) * 6 + 20, 100);
    iNewXSize = max (iNewXSize, 10*m_stLabel.GetLength() + 30);

    int IncreaseXBy = iNewXSize - m_rcBound.Width();
    int IncreaseYBy = 60 + 20 * max(m_lInputTabPos, m_lOutputTabPos) - m_rcBound.Height();

    CPoint NewBottomRight(m_rcBound.BottomRight().x + IncreaseXBy,
                          m_rcBound.BottomRight().y + IncreaseYBy);

    m_rcBound.SetRect( m_rcBound.TopLeft().x
                     , m_rcBound.TopLeft().y
                     , NewBottomRight.x
                     , NewBottomRight.y
                     );
}


//
// UpdateSockets
//
// Updates the set of sockets to match the pins on this filter
void CBox::UpdateSockets(void) {

    CalcTabPos();

    //
    // Pins might be removed from the filter due to some other deletions.
    // The sockets associated to pins that disappeared must also be removed.
    //
    // We can only determine which pins are still present by enumerating
    // all and comparing them with our sockets. Because of efficiency we
    // don't want to enumerate all pins for each socket we need to verify.
    //
    // We therefore delete all sockets that represent unconnected pins.
    // Note that there might still be a link associated to the socket and
    // those links are removed as well (since they are obsolete).
    //
    // In the second phase we enumerate all pins and if they don't have
    // already a socket, add their socket to the box.
    //

    //
    // Remove all sockets with unconnected pins.
    //
    POSITION posSocket = m_lstSockets.GetHeadPosition();

    while (posSocket) {
        //
        // Remember the current item, then get the next one
        // then delete the current one.
        // We need to do it this way, because we have to get
        // the next item before we delete the current one.
        //
        POSITION posTemp = posSocket;

        m_lstSockets.GetNext(posSocket);
        RemoveSocket(posTemp); // will only be removed if unconnected pin
    }

    //
    // Now we enumerate all pins of the filter and add sockets for
    // those pins which don't have sockets in this box.
    //
    // Note that pin's of new sockets might be connected, but we
    // are not going to add the links till all boxes have been updated.
    //

    CPinEnum    Next(pIFilter());
    IPin        *pPin;
    int         nInputNow = 0, nOutputNow = 0;

    while (0 != (pPin = Next())) {

        HRESULT hr;
        PIN_INFO pi;
        hr = pPin->QueryPinInfo(&pi);

        if (FAILED(hr)) {
            pPin->Release();
            throw CHRESULTException(hr);
        }
        QueryPinInfoReleaseFilter(pi);

        //
        // We need to increment the input or ouput pin counter even
        // if we don't add the socket.
        //
        if (pi.dir == PINDIR_INPUT) {
            nInputNow++;
        }
        else {
            nOutputNow++;
        }

        //
        // If the pin has already a socket, update its tab.
        // (the box might have changed in size).
        //
        // If there is no socket, then add a new socket.
        //
        if (m_lstSockets.IsIn(pPin)) {
            //
            // Update the position of the pins on the filter.
            //
            CBoxSocket * pSocket = m_lstSockets.GetSocket(pPin);

            if (pi.dir == PINDIR_INPUT) {
                pSocket->m_tabpos.SetPos(nInputNow, 1 + m_lInputTabPos);
            }
            else {
                pSocket->m_tabpos.SetPos(nOutputNow, 1 + m_lOutputTabPos);
            }
        }
        else {
            //
            // we need a new socket
            //
            char achName[100];
            WideCharToMultiByte(CP_ACP, 0,
                                pi.achName, -1,
                                achName, sizeof(achName),
                                NULL, NULL);
        
            if (pi.dir == PINDIR_INPUT) {
                AddSocket(achName,
                          CBoxTabPos::LEFT_EDGE,
                          nInputNow,
                          1 + m_lInputTabPos,
                          pPin);
            }
            else {
                AddSocket(achName,
                          CBoxTabPos::RIGHT_EDGE,
                          nOutputNow,
                          1 + m_lOutputTabPos,
                          pPin);
            }
        }

        pPin->Release();
    }
}


//
// CalcRelativeY
//
// the Y position a box has relative to its upstream connections
void CBox::CalcRelativeY(void) {

    CSocketEnum NextInput(this, CSocketEnum::Input);
    CBoxSocket  *psock;

    m_RelativeY = 0.0f;

    while (0 !=(psock = NextInput())) {

        // !!! still broken
        CBoxSocket *pPeer;
        if (psock->IsConnected() && (pPeer = psock->Peer()) != NULL) {
            m_RelativeY += (pPeer->pBox()->Y() / m_iTotalInput);

            // adjust slightly based on which output pin the connection
            // attaches to on the other side, to avoid crossings
            CSocketEnum NextOutput(pPeer->pBox(), CSocketEnum::Output);
            int         socketNum = 0;
            CBoxSocket *psock2;
            while (0 != (psock2 = NextOutput())) {
                if (psock2 == pPeer) {
                    m_RelativeY += 0.01f * socketNum;
                }
                socketNum++;
            }
        }
    }
}


#ifdef _DEBUG

void CBox::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(pIFilter());
    ASSERT(m_pDoc);

    ASSERT(m_rcBound.Width() > 0);
    ASSERT(m_rcBound.Height() > 0);
}

void CBox::Dump(CDumpContext& dc) const {

    CPropObject::Dump(dc);

    dc << TEXT("x = ") << X() << TEXT(", y = ") << Y() << TEXT("\n");

    dc << TEXT("Name: ") << m_stLabel << TEXT("\n");
    dc << TEXT("IFilter :") << pIFilter() << TEXT("\n");
    dc << m_lstSockets;
}

void CBox::MyDump(CDumpContext& dc) const
{
    dc << TEXT("*** Box ***\n");
    dc << TEXT("    Location: ") << (void *) this << TEXT("\n");
    dc << TEXT("    Name    : ") << m_stLabel << TEXT("\n");
    dc << TEXT("    IBaseFilter : ") << (void *) pIFilter() << TEXT("\n");
    dc << TEXT("    ----- Sockets / Pins -----\n");

    POSITION pos = m_lstSockets.GetHeadPosition();
    while (pos) {
        CBoxSocket * pSocket = m_lstSockets.GetNext(pos);
        pSocket->MyDump(dc);
    }
    dc << TEXT("    ----- (end) ---------------\n");
}

void CBoxSocket::MyDump(CDumpContext& dc) const
{
    dc << TEXT("        Socket at ") << (void *) this    << TEXT("\n");
    dc << TEXT("           - Pin  ") << (void *) pIPin() << TEXT("\n");
    dc << TEXT("           - Link ") << (void *) m_plink << TEXT("\n");
    dc << TEXT("           - Box  ") << (void *) m_pbox  << TEXT("\n");
}

#endif // _DEBUG

//
// RemoveSocket
//
// Remove the socket from the boxes list of sockets.
// Only sockets which have an unconnected pin are allowed to be
// removed. We will also remove any existing link.
//
// If parameter <bForceIt> is true, any connection of the socket's pin
// will be disconnected.
//
// returns:
//  S_OK - Socket was removed
//  S_FALSE - Pin of socket was still connected therefore no removal.
//
HRESULT CBox::RemoveSocket(POSITION posSocket, BOOL bForceIt)
{
    CBoxSocket *pSocket = m_lstSockets.GetAt(posSocket);

    //
    // Test whether the socket's pin is unconnected.
    //
    IPin *pTempPin;
    pSocket->pIPin()->ConnectedTo(&pTempPin);

    if (NULL != pTempPin) {
        //
        // Pin is still connected.
        //

        if (!bForceIt) {
            // we are not allowed to disconnect it.
            pTempPin->Release();

            return(S_FALSE);
        }

        POSITION posTemp = pDoc()->m_lstLinks.Find(pSocket->m_plink);
        if (posTemp != NULL) {
            //
            // We need to check for posTemp != NULL here because
            // if we get called during DeleteContents, all links might
            // have been deleted - no matter of successfully disconnected
            // or not.
            //
            pDoc()->m_lstLinks.RemoveAt(posTemp);

            pSocket->m_plink->Disconnect();

            delete pSocket->m_plink;
            pSocket->m_plink = NULL;
        }

        pTempPin->Release();
    }

    //
    // Remove any links
    //
    if (pSocket->m_plink) {
        //
        // Need to remove the link from the CBoxNetDoc's <m_lstLinks> list.
        //
        POSITION posDelete = pDoc()->m_lstLinks.Find(pSocket->m_plink);
        pDoc()->m_lstLinks.RemoveAt(posDelete);

        // The destructor sets the head and tail socket's pointers to the link
        // to NULL.

        delete pSocket->m_plink;  // no disconnect needed
    }

    //
    // Remove the socket from m_lstSockets and delete it
    //
    m_lstSockets.RemoveAt(posSocket);
    delete pSocket;

    return(S_OK);
}

//
// AddSocket
//
void CBox::AddSocket(CString stLabel,
                     CBoxTabPos::EEdge eEdge,
                     unsigned uiVal,
                     unsigned uiValMax,
                     IPin *pPin) {

    CBoxSocket * pSocket;
    pSocket = new CBoxSocket(this, stLabel, eEdge, uiVal, uiValMax, pPin);

    m_lstSockets.AddTail(pSocket);
}


//
// ShowDialog
//
// Show our own dialog, and pass the request on to our sockets
void CBox::ShowDialog(void) {

    CPropObject::ShowDialog();

    CSocketEnum Next(this);
    CBoxSocket  *psock;
    while (0 != (psock = Next())) {

        psock->ShowDialog();
    }
}


//
// HideDialog
//
// Hide our dialog and pass the request to our sockets
void CBox::HideDialog(void) {

    CPropObject::HideDialog();

    CSocketEnum Next(this);
    CBoxSocket  *psock;
    while (0 != (psock = Next())) {

        psock->HideDialog();
    }
}


// *
// * CBoxList
// *

// A CList, with the ability to query the list for partiular _filters_


//
// IsIn
//
// Is this filter in this list?
BOOL CBoxList::IsIn(IBaseFilter *pFilter) const {

    if (GetBox(pFilter) != NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


//
// GetBox
//
// Return the box that manages this filter. NULL if not present.
CBox *CBoxList::GetBox(IBaseFilter *pFilter) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = GetNext(pos);

        if (CQCOMInt<IBaseFilter>(pFilter) == (IUnknown *)CQCOMInt<IBaseFilter>(pbox->pIFilter())) {
            return pbox;
        }
    }

    return NULL;
}


//
// GetBox
//
// Return the box managing the filter with the supplied clsid
CBox *CBoxList::GetBox(CLSID clsid) const {

    POSITION pos = GetHeadPosition();

    while (pos != NULL) {

        CBox *pbox = GetNext(pos);
        CQCOMInt<IPersist> IPer(IID_IPersist, pbox->pIFilter());

        CLSID clsidThis;
        IPer->GetClassID(&clsidThis);

        if (clsidThis == clsid) {
            return pbox;
        }
    }

    return NULL;
}


BOOL CBoxList::RemoveBox( IBaseFilter* pFilter, CBox** ppBox )
{
    POSITION posNext;
    CBox* pCurrentBox;
    POSITION posCurrent;

    // Prevent the caller from accessing random memory.
    *ppBox = NULL;

    posNext = GetHeadPosition();

    while( NULL != posNext ) {
        posCurrent = posNext;

        pCurrentBox = GetNext( posNext );
    
        if( IsEqualObject( pCurrentBox->pIFilter(), pFilter ) ) {
            RemoveAt( posCurrent );
            *ppBox = pCurrentBox;
            return TRUE;
        } 
    }

    return FALSE;
}

#ifdef _DEBUG
//
// Dump
//
void CBoxList::Dump( CDumpContext& dc ) const {

    CDeleteList<CBox *, CBox *>::Dump(dc);

}
#endif // _DEBUG

// *
// * CSocketEnum
// *

//
// CSocketEnum::Constructor
//
CSocketEnum::CSocketEnum(CBox *pbox, DirType Type)
    : m_Type(Type),
      m_pbox(pbox) {

    ASSERT(pbox);

    m_pos =  m_pbox->m_lstSockets.GetHeadPosition();

    if (m_Type == Input)
        m_EnumDir = ::PINDIR_INPUT;
    else if (m_Type == Output)
        m_EnumDir = ::PINDIR_OUTPUT;
}


//
// operator()
//
// return the next socket of the requested sense, NULL if no more.
CBoxSocket *CSocketEnum::operator() (void) {

    CBoxSocket *psock;

    do {
        if (m_pos != NULL) {
            psock = m_pbox->m_lstSockets.GetNext(m_pos);
        }
        else {  // no more sockets
            return NULL;
        }

        ASSERT(psock);

    } while (   (m_Type != All)
             && (psock->GetDirection() != m_EnumDir)
            );

    return psock;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\congraph.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// congraph.h

#ifndef __CONN_GRAPH__
#define __CONN_GRAPH__

class CConGraph : public CDialog
{
public:
    ~CConGraph();
    CConGraph(IMoniker **ppmk, IRunningObjectTable *pirot, CWnd * pParent = NULL );

protected:

    BOOL OnInitDialog();
    void OnDestroy();
    void DoDataExchange(CDataExchange* pDX);

    void ClearList();
    void OnRefreshList();

    virtual void OnOK();
    virtual void OnDblclkGraphList();

    DECLARE_MESSAGE_MAP()

private:
    CListBox m_ListBox;

    IMoniker **m_ppmk;
    IRunningObjectTable *m_pirot;
};

#endif // __CONN_GRAPH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\boxdraw.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// boxdraw.cpp : defines CBoxDraw
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Global (shared) CBoxDraw object

CBoxDraw * gpboxdraw;


/////////////////////////////////////////////////////////////////////////////
// CBoxDraw constants


// background color of boxes and container
const COLORREF  CBoxDraw::m_crBkgnd(RGB(192, 192, 192));

// margins (left/right, top/bottom) around box labels and box tab labels
const CSize     CBoxDraw::m_sizLabelMargins(2, 0);

// hit test: "close enough" if this many pixels away
const int       CBoxDraw::m_iHotZone(3);

// box tab labels: font face, height (pixels) for box labels and box tab labels
const CString   CBoxDraw::m_stBoxFontFace("Arial");
const int       CBoxDraw::m_iBoxLabelHeight(16);
const int       CBoxDraw::m_iBoxTabLabelHeight(14);

// color of unhighlighted links and highlighted links
const COLORREF  CBoxDraw::m_crLinkNoHilite(RGB(0, 0, 0));
const COLORREF  CBoxDraw::m_crLinkHilite(RGB(0, 0, 255));

// radius of circle used to highlight bends
const int       CBoxDraw::m_iHiliteBendsRadius(3);



/////////////////////////////////////////////////////////////////////////////
// CBoxDraw construction and destruction


CBoxDraw::CBoxDraw() {
}


/* Init()
 *
 * Initialize the object.  May throw an exception, so don't call from
 * a constructor.
 */
void CBoxDraw::Init()
{
    // load composite bitmaps
    if (!m_abmEdges[FALSE].LoadBitmap(IDB_EDGES) ||
        !m_abmEdges[TRUE].LoadBitmap(IDB_EDGES_HILITE) ||
        !m_abmTabs[FALSE].LoadBitmap(IDB_TABS) ||
        !m_abmTabs[TRUE].LoadBitmap(IDB_TABS_HILITE) ||
        !m_abmClocks[FALSE].LoadBitmap(IDB_CLOCK) ||
        !m_abmClocks[TRUE].LoadBitmap(IDB_CLOCK_SELECT))
            AfxThrowResourceException();

    // get the size of each bitmap (just look at the unhighlighted versions
    // since unhighlighted and highlighted versions are the same size)
    // and compute the size of a single "tile" within the composite bitmap
    BITMAP bm;
    m_abmEdges[FALSE].GetObject(sizeof(bm), &bm);
    m_sizEdgesTile.cx = bm.bmWidth / 3;
    m_sizEdgesTile.cy = bm.bmHeight / 3;
    m_abmTabs[FALSE].GetObject(sizeof(bm), &bm);
    m_sizTabsTile.cx = bm.bmWidth / 3;
    m_sizTabsTile.cy = bm.bmHeight / 3;
    m_abmClocks[FALSE].GetObject(sizeof(bm), &bm);
    m_sizClock.cx = bm.bmWidth;
    m_sizClock.cy = bm.bmHeight;

    // create the brushes and pens for drawing links
    m_abrLink[FALSE].CreateSolidBrush(m_crLinkNoHilite);
    m_abrLink[TRUE].CreateSolidBrush(m_crLinkHilite);
    m_apenLink[FALSE].CreatePen(PS_SOLID, 1, m_crLinkNoHilite);
    m_apenLink[TRUE].CreatePen(PS_SOLID, 1, m_crLinkHilite);

    RecreateFonts();
}

void CBoxDraw::RecreateFonts()
{
    // create the font for box labels
    if (!m_fontBoxLabel.CreateFont(m_iBoxLabelHeight * CBox::s_Zoom / 100, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS,
            CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_SWISS, m_stBoxFontFace))
        AfxThrowResourceException();

    // create the font for tab labels
    if (!m_fontTabLabel.CreateFont(m_iBoxTabLabelHeight * CBox::s_Zoom / 100, 0, 0, 0, FW_NORMAL,
            FALSE, FALSE, FALSE, ANSI_CHARSET, OUT_TT_PRECIS,
            CLIP_DEFAULT_PRECIS, PROOF_QUALITY, FF_SWISS, m_stBoxFontFace))
        AfxThrowResourceException();
}

/* Exit()
 *
 * Free the resources held by the object.
 */
void CBoxDraw::Exit() {

}



/////////////////////////////////////////////////////////////////////////////
// box drawing


/* GetOrInvalBoundRect(pbox, prc, [fLinks], [pwnd])
 *
 * Set <*prc> to be a bounding rectangle around <pbox>.  If <fLinks> is TRUE
 * then include the bounding rectangles of the links to/from <pbox>.
 *
 * If <pwnd> is not NULL, then invalidate the area covering <pbox> (and the
 * links to/from <pbox>, if <fLinks> is TRUE).  This is usually more efficient
 * than invalidating all of <pwnd>, for links that have at least one bend.
 */
void CBoxDraw::GetOrInvalBoundRect(CBox *pbox, CRect *prc, BOOL fLinks,
    CScrollView *pScroll)
{
    CRect               rc;

    // get the bounding rect of <pbox>; invalidate if requested
    *prc = pbox->GetRect();
    if (pScroll != NULL)
        pScroll->InvalidateRect(&(*prc - pScroll->GetScrollPosition()), TRUE);

    if (fLinks)
    {
        // include the bounding rect of each link; invalidate if requested
	CSocketEnum Next(pbox);
	CBoxSocket *psock;

	while (0 != (psock = Next()))
	{
            if (psock->m_plink != NULL)
            {
                // socket is connected via a link
                GetOrInvalLinkRect(psock->m_plink, &rc, pScroll);
                prc->UnionRect(prc, &rc);
            }
        }
    }
}


/* DrawCompositeFrame(hdcDst, xDst, yDst, cxDst, cyDst,
 *  hdcSrc, cxTile, cyTile, fMiddle)
 *
 * Draw a <cxDst> by <cyDst> pixel "frame" (as specified below) at (xDst,yDst)
 * in <hdcDst>.
 *
 * Assume <hdcSrc> is a DC onto a bitmap that contains a 3x3 grid of "tiles"
 * that each is <cxTile> pixels wide and <cyTile> pixels high.  The corner
 * tiles contain images of the corners.  The center top, bottom, left, and
 * right tiles contain images that are stretched to compose the corresponding
 * sides of the frame.
 *
 * If <fMiddle> is TRUE then the middle tile is stretched to fill the middle
 * of the frame, otherwise the middle of the frame is left undrawn.
 */
void NEAR PASCAL
DrawCompositeFrame(HDC hdcDst, int xDst, int yDst, int cxDst, int cyDst,
    HDC hdcSrc, int cxTile, int cyTile, BOOL fMiddle)
{
    // draw upper-left, upper-right, lower-left, lower-right corners
    BitBlt(hdcDst, xDst + 0, yDst + 0,
        cxTile, cyTile,
        hdcSrc, cxTile * 0, cyTile * 0, SRCCOPY);
    BitBlt(hdcDst, xDst + cxDst - cxTile, yDst + 0,
        cxTile, cyTile,
        hdcSrc, cxTile * 2, cyTile * 0, SRCCOPY);
    BitBlt(hdcDst, xDst + 0, yDst + cyDst - cyTile,
        cxTile, cyTile,
        hdcSrc, cxTile * 0, cyTile * 2, SRCCOPY);
    BitBlt(hdcDst, xDst + cxDst - cxTile, yDst + cyDst - cyTile,
        cxTile, cyTile,
        hdcSrc, cxTile * 2, cyTile * 2, SRCCOPY);

    // draw left, right, top, and bottom edges
    SetStretchBltMode(hdcDst, COLORONCOLOR);
    StretchBlt(hdcDst, xDst + 0, yDst + cyTile * 1,
        cxTile, cyDst - cyTile - cyTile,
        hdcSrc, cxTile * 0, cyTile * 1,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxDst - cxTile, yDst + cyTile * 1,
        cxTile, cyDst - cyTile - cyTile,
        hdcSrc, cxTile * 2, cyTile * 1,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxTile * 1, yDst + 0,
        cxDst - cxTile - cxTile, cyTile,
        hdcSrc, cxTile * 1, cyTile * 0,
        cxTile, cyTile, SRCCOPY);
    StretchBlt(hdcDst, xDst + cxTile * 1, yDst + cyDst - cyTile,
        cxDst - cxTile - cxTile, cyTile,
        hdcSrc, cxTile * 1, cyTile * 2,
        cxTile, cyTile, SRCCOPY);

    if (fMiddle)
    {
        // draw middle tile
        StretchBlt(hdcDst, xDst + cxTile * 1, yDst + cyTile * 1,
            cxDst - cxTile - cxTile,
            cyDst - cyTile - cyTile,
            hdcSrc, cxTile * 1, cyTile * 1,
            cxTile, cyTile, SRCCOPY);
    }
}


/* DrawFrame(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the frame of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the frame.  In this case, <pdc> must be a
 * DC onto the window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> is ignored.
 */
void CBoxDraw::DrawFrame(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CDC         dcBitmap;

    GetFrameRect(pbox, prc);

    if (fDraw)
    {
        dcBitmap.CreateCompatibleDC(NULL);
        dcBitmap.SelectObject(&m_abmEdges[fnorm(pbox->IsSelected())]);
        DrawCompositeFrame(pdc->m_hDC, prc->left, prc->top,
            prc->Width(), prc->Height(),
            dcBitmap.m_hDC, m_sizEdgesTile.cx, m_sizEdgesTile.cy, FALSE);
    }
}


/* DrawBoxLabel(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box label of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the box label -- note that this will also
 * cause the *entire* box to be filled with the background color, not just the
 * bounding rectangle of the box.  In this case, <pdc> must be a DC onto the
 * window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 *
 * Also deals with the clock icon.
 */
void CBoxDraw::DrawBoxLabel(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontBoxLabel);

    // set <*prc> to be the bounding rectangle of the box label
    GetInsideRect(pbox, &rcBox);

    // calculate how much space we need for label and clock icon
    CSize sizeLabel = pdc->GetTextExtent(pbox->m_stLabel, pbox->m_stLabel.GetLength());

    INT iDiff = 0;

    if (pbox->HasClock()) {
        // increase label size by clock width + small gap
        sizeLabel.cx += m_sizClock.cx + 5;

        // make sure label height is at least clock height high
        if (m_sizClock.cy > sizeLabel.cy) {
            iDiff = m_sizClock.cy - sizeLabel.cy;
            sizeLabel.cy = m_sizClock.cy;
        }
    }

    *prc = CRect(rcBox.TopLeft(), sizeLabel);
    CSize siz = rcBox.Size() - prc->Size();
    prc->OffsetRect(siz.cx / 2, siz.cy / 2);

    if (fDraw)
    {
        // draw the box label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, rcBox,
            pbox->m_stLabel, pbox->m_stLabel.GetLength(), NULL);

        if (pbox->HasClock()) {
            // draw clock behind filter name
            CDC dcBitmap;
            dcBitmap.CreateCompatibleDC(NULL);

            // select the appropriate bitmap
            if (pbox->HasSelectedClock())
                dcBitmap.SelectObject(&m_abmClocks[1]);
            else
                dcBitmap.SelectObject(&m_abmClocks[0]);

            pdc->BitBlt(prc->left + sizeLabel.cx - m_sizClock.cx,
                        prc->top + iDiff / 2,
                        m_sizClock.cx, m_sizClock.cy,
                        &dcBitmap, 0, 0, SRCCOPY);
        }
    }
}

/* DrawBoxFile(pbox, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box label of <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the box label -- note that this will also
 * cause the *entire* box to be filled with the background color, not just the
 * bounding rectangle of the box.  In this case, <pdc> must be a DC onto the
 * window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 */
/*void CBoxDraw::DrawBoxFile(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontBoxLabel);

    // set <*prc> to be the bounding rectangle of the box label
    GetInsideRect(pbox, &rcBox);

    *prc = CRect(rcBox.TopLeft(), pdc->GetTextExtent(pbox->m_stFilename, pbox->m_stFilename.GetLength()));
    CSize siz = rcBox.Size() - prc->Size();
    prc->OffsetRect(siz.cx / 2, siz.cy * 3 / 4);

    if (fDraw)
    {
        // draw the box label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, rcBox,
            pbox->m_stFilename, pbox->m_stFilename.GetLength(), NULL);
    }
}
*/

/* DrawTabLabel(pbox, psock, prc, pdc, fDraw)
 *
 * Set <*prc> to be the bounding rectangle around the box tab label of
 * socket <psock> of box <pbox>.
 *
 * Then, if <fDraw> is TRUE, draw the tab label.  In this case, <pdc> must
 * be a DC onto the window containing the box network.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> may be any
 * screen DC.
 */
void CBoxDraw::DrawTabLabel(CBox *pbox, CBoxSocket *psock, CRect *prc, CDC *pdc,
    BOOL fDraw)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    CPoint      pt;             // point on edge of <pbox> corresp. to <psock>

    // select the font used to draw the box label
    pdc->SelectObject(&m_fontTabLabel);

    // set <*prc> to be the bounding rectangle of the tab label
    GetInsideRect(pbox, &rcBox);
    pt = BoxTabPosToPoint(pbox, psock->m_tabpos);
    *prc = CRect(pt,
        pdc->GetTextExtent(psock->m_stLabel, psock->m_stLabel.GetLength()));
    if (psock->m_tabpos.m_fLeftRight)
    {
        // center label vertically beside <pt>, set flush to box left or right
        // (adjusting for margins)
        prc->OffsetRect((psock->m_tabpos.m_fLeftTop ? m_sizLabelMargins.cx
                        : -(prc->Width() + m_sizLabelMargins.cx)),
            -prc->Height() / 2);
    }
    else
    {
        // center label horizontally beside <pt>, set flush to box top or bottom
        // (adjusting for margins)
        prc->OffsetRect(-prc->Width() / 2,
            (psock->m_tabpos.m_fLeftTop ? m_sizLabelMargins.cy
             : -(prc->Height() + m_sizLabelMargins.cy)));
    }

    if (fDraw)
    {
        // draw the tab label
        pdc->SetBkColor(m_crBkgnd);
        pdc->ExtTextOut(prc->left, prc->top, ETO_OPAQUE, prc,
            psock->m_stLabel, psock->m_stLabel.GetLength(), NULL);
    }
}


/* DrawTab(psock, prc, pdc, fDraw, fHilite)
 *
 * Set <*prc> to be the bounding rectangle around the box tab <psock>.
 *
 * Then, if <fDraw> is TRUE, draw the tab.  In this case, <pdc> must
 * be a DC onto the window containing the box network.
 *
 * If <fHilite> is TRUE, then the tab is drawn in a hilited state.
 *
 * If <fDraw> is FALSE, then only set <*prc>.  In this case, <pdc> is unused.
 */
void CBoxDraw::DrawTab(CBoxSocket *psock, CRect *prc, CDC *pdc,
    BOOL fDraw, BOOL fHilite)
{
    CRect       rcBox;          // inside rectangle of <psock->m_pbox>
    CPoint      pt;             // point on edge of box corresp. to <psock>

    // set <*prc> to be the bounding rectangle of the tab
    GetInsideRect(psock->m_pbox, &rcBox);
    pt = BoxTabPosToPoint(psock->m_pbox, psock->m_tabpos);
    *prc = CRect(pt, m_sizTabsTile);
    if (psock->m_tabpos.m_fLeftRight)
    {
        // center tab vertically beside <pt>, set flush to box left or right
        prc->OffsetRect((psock->m_tabpos.m_fLeftTop ? -m_sizTabsTile.cx : 0),
            -prc->Height() / 2);
    }
    else
    {
        // center tab horizontally beside <pt>, set flush to box top or bottom
        prc->OffsetRect(-prc->Width() / 2,
            (psock->m_tabpos.m_fLeftTop ? -m_sizTabsTile.cy : 0));
    }

    if (fDraw)
    {
        // set <rcTile> to the rectangle in the bitmap containing the tile;
        // note that, in the 3x3 tiled bitmap, only 4 of the 9 tiles are used:
        //
        //      unused  top     unused
        //      left    unused  right
        //      unused  bottom  unused
        //
        CRect rcTile(CPoint(0, 0), m_sizTabsTile);
        if (psock->m_tabpos.m_fLeftRight)
        {
            // tile is on left or right side of bitmap
            rcTile.OffsetRect(0, m_sizTabsTile.cy);
            if (!psock->m_tabpos.m_fLeftTop)
                rcTile.OffsetRect(2 * m_sizTabsTile.cx, 0);
        }
        else
        {
            // tile is on top or bottom of bitmap
            rcTile.OffsetRect(m_sizTabsTile.cx, 0);
            if (!psock->m_tabpos.m_fLeftTop)
                rcTile.OffsetRect(0, 2 * m_sizTabsTile.cy);
        }

        // draw the tab
        CDC dcBitmap;
        dcBitmap.CreateCompatibleDC(NULL);
        dcBitmap.SelectObject(&m_abmTabs[fnorm(fHilite)]);
        pdc->BitBlt(prc->left, prc->top, prc->Width(), prc->Height(),
            &dcBitmap, rcTile.left, rcTile.top, SRCCOPY);
    }
}


/* pt = GetTabCenter(psock)
 *
 * Return the coordinates of the center of the box tab <psock>.
 */
CPoint CBoxDraw::GetTabCenter(CBoxSocket *psock)
{
    CRect           rc;         // bounding rectangle of tab

    DrawTab(psock, &rc, NULL, FALSE, FALSE);
    return CPoint((rc.left + rc.right) / 2, (rc.top + rc.bottom) / 2);
}


/* tabpos = BoxTabPosFromPoint(pbox, pt, piError)
 *
 * Figure out which edge of <pbox> <pt> is closest to, and return the
 * CBoxTabPos position that represents the point on that edge closest
 * to <pt>, and set <*piError> to the distance between that point and <pt>.
 */
CBoxTabPos CBoxDraw::BoxTabPosFromPoint(CBox *pbox, CPoint pt, LPINT piError)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    int         dxLeft, dxRight, dyTop, dyBottom;
    CBoxTabPos  tabpos;

    // CTabPos::GetPos() values are relative to the height or width
    // of the inside of the box
    GetInsideRect(pbox, &rcBox);

    // calculate the distance to each edge
    dxLeft = iabs(pt.x - rcBox.left);
    dxRight = iabs(pt.x - rcBox.right);
    dyTop = iabs(pt.y - rcBox.top);
    dyBottom = iabs(pt.y - rcBox.bottom);

    // figure out which edge <pt> is closest to
    if (imin(dxLeft, dxRight) < imin(dyTop, dyBottom))
    {
        tabpos.m_fLeftRight = TRUE;
        // <pt> is closest to the left or right edge
        tabpos.SetPos(ibound(pt.y, rcBox.top, rcBox.bottom) - rcBox.top,
            rcBox.Height());
        if (dxLeft < dxRight)
        {
            tabpos.m_fLeftTop = TRUE;
            *piError = dxLeft;
        }
        else
        {
            tabpos.m_fLeftTop = FALSE;
            *piError = dxRight;
        }
        *piError = max(*piError, ioutbound(pt.y, rcBox.top, rcBox.bottom));
    }
    else
    {
        tabpos.m_fLeftRight = FALSE;
        // <pt> is closest to the top or bottom edge
        tabpos.SetPos(ibound(pt.x, rcBox.left, rcBox.right) - rcBox.left,
            rcBox.Width());
        if (dyTop < dyBottom)
        {
            tabpos.m_fLeftTop = TRUE;
            *piError = dyTop;
        }
        else
        {
            tabpos.m_fLeftTop = FALSE;
            *piError = dyBottom;
        }
        *piError = max(*piError, ioutbound(pt.x, rcBox.left, rcBox.right));
    }

    return tabpos;
}


/* pt = BoxTabPosToPoint(pbox, tabpos)
 *
 * Convert <tabpos>, a box tab position on <pbox>, to a point that's
 * on one of the inside edges of <pbox>, and return the point.
 */
CPoint CBoxDraw::BoxTabPosToPoint(const CBox *pbox, CBoxTabPos tabpos)
{
    CRect       rcBox;          // inside rectangle of <pbox>
    CPoint      pt;

    // CTabPos::GetPos() values are relative to the height or width
    // of the inside of the box
    GetInsideRect(pbox, &rcBox);

    pt = rcBox.TopLeft();
    if (tabpos.m_fLeftRight)
    {
        // tab is on left or right edge
        pt.y += tabpos.GetPos(rcBox.Height());
        if (!tabpos.m_fLeftTop)
            pt.x = rcBox.right;
    }
    else
    {
        // tab is on top or bottom edge
        pt.x += tabpos.GetPos(rcBox.Width());
        if (!tabpos.m_fLeftTop)
            pt.y = rcBox.bottom;
    }

    return pt;
}


/* DrawBox(pbox, pdc, [psockHilite], [psizGhostOffset])
 *
 * Draw the box <pbox> in <pdc> (a DC onto the window containing the box
 * network), and then exclude the portion that was painted from the
 * clipping region of <pdc>.
 *
 * If <psockHilite> is not NULL, then highlight socket tab <psockHilite>
 * if <pbox> contains it.
 *
 * If <psizGhostOffset> not NULL then, instead of drawing the box, draw a
 * "ghost" version of the box, offset by <*psizGhostOffset>, by inverting
 * destination pixels; calling DrawBox() again with the same value of
 * <psizGhostOffset> will invert the same pixels again and return <pdc>
 * to its original state.
 */
void CBoxDraw::DrawBox(CBox *pbox, CDC *pdc, CBoxSocket *psockHilite,
    CSize *psizGhostOffset)
{
    CRect       rc;

    /* if <psizGhostOffset> specified, just invert the pixels between the
     * frame and the inside of the box (all offset by <psizGhostOffset>)
     */
    if (psizGhostOffset)
    {
        CRect rcFrame, rcInside;
        GetFrameRect(pbox, &rcFrame);
        rcFrame.OffsetRect(*psizGhostOffset);
        GetInsideRect(pbox, &rcInside);
        rcInside.OffsetRect(*psizGhostOffset);
        InvertFrame(pdc, &rcFrame, &rcInside);
        return;
    }

    CSocketEnum Next(pbox);
    CBoxSocket *psock;
    // draw each socket's tab and tab label
    while (0 != (psock = Next()))
    {
        DrawTab(psock, &rc, pdc, TRUE, (psock == psockHilite));
        pdc->ExcludeClipRect(&rc);
        DrawTabLabel(pbox, psock, &rc, pdc, TRUE);
	// TBD: don't invalidate the clip rect here if printing
	// (or printer drops box label later)
	if (!pdc->IsPrinting())
	    pdc->ExcludeClipRect(&rc);
    }

    // draw the box filename
//    DrawBoxFile(pbox, &rc, pdc, TRUE);
//    pdc->ExcludeClipRect(&rc);

    // draw the box label
    DrawBoxLabel(pbox, &rc, pdc, TRUE);
    pdc->ExcludeClipRect(&rc);

    // draw the box frame
    DrawFrame(pbox, &rc, pdc, TRUE);
    pdc->ExcludeClipRect(&rc);
}


/* eHit = HitTestBox(pbox, pt, ptabpos, ppsock)
 *
 * See if <pt> hits some part of <pbox>.  Return the following hit-test code:
 *
 *   HT_MISS        didn't hit anything
 *   HT_TAB         hit a box tab (set <*ppsock> to it)
 *   HT_EDGE        hit the edge of the box (set <*ptabpos> to it)
 *   HT_TABLABEL    hit a box tab label (set <*ppsock> to it)
 *   HT_BOXLABEL    hit the box label
 *   HT_BOXFILE     hit the box filename
 *   HT_BOX         hit elsewhere on the box
 */
CBoxDraw::EHit CBoxDraw::HitTestBox(CBox *pbox, CPoint pt,
    CBoxTabPos *ptabpos, CBoxSocket **ppsock)
{
    CClientDC       dc(CWnd::GetDesktopWindow()); // to get label sizes etc.
    int             iError;
    CRect           rc;

    // for efficiency, before continuing further, first check if <pt> is even
    // in the bounding rectangle of the box
    if (!pbox->GetRect().PtInRect(pt))
        return HT_MISS;

    // see if <pt> is in a tab or tab label
    CSocketEnum Next(pbox);
    while (0 != (*ppsock = Next())) {

        DrawTab(*ppsock, &rc, &dc, FALSE, FALSE);
	rc.InflateRect(1,1);	// give users more chance of hitting tabs.
        if (rc.PtInRect(pt))
            return HT_TAB;
        DrawTabLabel(pbox, *ppsock, &rc, &dc, FALSE);
        if (rc.PtInRect(pt))
            return HT_TABLABEL;
    }

    // see if <pt> is in the box label
    DrawBoxLabel(pbox, &rc, &dc, FALSE);
    if (rc.PtInRect(pt))
        return HT_BOXLABEL;

    // see if <pt> is in the box label
//    DrawBoxFile(pbox, &rc, &dc, FALSE);
//    if (rc.PtInRect(pt))
//        return HT_BOXFILE;

    // see if <pt> is near the edge of the box
    *ptabpos = BoxTabPosFromPoint(pbox, pt, &iError);
    if (iError <= 3/*close-enough-zone*/)
        return HT_EDGE;

    // see if <pt> is anywhere else in the box
    DrawFrame(pbox, &rc, &dc, FALSE);
    if (rc.PtInRect(pt))
        return HT_BOX;

    return HT_MISS;
}


/////////////////////////////////////////////////////////////////////////////
// Link drawing and hit testing


/* An arrow is drawn as a pie (a slice of a circle) of radius ARROW_RADIUS.
 * The angle of the arrow pie slice is twice the slope "rise/run", where
 * "rise" is ARROW_SLOPERISE and "run" is ARROW_SLOPERUN.
 */


#define ARROW_RADIUS        12  // radius of pie for 1-wide line arrow
#define ARROW_SLOPERISE     3   // "rise" of arrow angle
#define ARROW_SLOPERUN      8   // "run" of arrow angle


/* DrawArrowHead(hdc, ptTip, ptTail, fPixel)
 *
 * Imagine a line drawn from <ptTip> to <ptTail>, with an arrowhead with its
 * tip at <ptTip>.  Draw this arrowhead.
 *
 * If <fPixel> is TRUE, then the arrowhead points to the pixel at <ptTip>
 * i.e. the rectangle (ptTip.x,ptTip.y, ptTip.x+1,ptTip.y+1); a one-pixel-wide
 * horizontal or vertical line drawn to <ptTip> should line up with this
 * rectangle, and the arrowhead should not obscure this rectangle.
 *
 * If <fPixel> is FALSE, then the arrowhead points to the gridline intersection
 * at <ptTip>, not the pixel at <ptTip>.  (One implication of this is that the
 * pixel at <ptTip>, will be obscured by the arrowhead when the tail of the
 * arrow is to the right and below the tip.)
 *
 * In order for DrawArrowHead() to function correctly, the current pen
 * must be non-null and one unit thick.
 */
void NEAR PASCAL
DrawArrowHead(HDC hdc, POINT ptTip, POINT ptTail, BOOL fPixel)
{
    int     dxLine, dyLine;     // delta from tip to end of line
    POINT   ptBoundA, ptBoundB; // ends of boundary lines
    int     dxBound, dyBound;

    // adjust for the way Windows draws pies
    if (ptTail.x >= ptTip.x)
        ptTip.x++;
    if (ptTail.y >= ptTip.y)
        ptTip.y++;
    if (fPixel)
    {
        if (ptTail.x > ptTip.x)
            ptTip.x++;
        if (ptTail.y > ptTip.y)
            ptTip.y++;
    }

    // calculate the extent of the line
    dxLine = ptTip.x - ptTail.x;
    dyLine = ptTip.y - ptTail.y;

    if ((iabs(dxLine) < ARROW_RADIUS) && (iabs(dyLine) < ARROW_RADIUS))
        return;         // line too short to draw arrow

    // calculate <ptBoundA> and <ptBoundB>; if you draw a line from
    // <ptTip> to <ptBoundA>, that line will touch one side of the
    // arrow; if you draw a line from <ptTip> to <ptBoundB>, that line
    // will touch the other side of the arrow; the first line will
    // always come before the second line if you orbit <ptTip>
    // counterclockwise (like Pie() does)
    dxBound = ((2 * dyLine * ARROW_SLOPERISE + ARROW_SLOPERUN)
        / ARROW_SLOPERUN) / 2;
    dyBound = ((2 * dxLine * ARROW_SLOPERISE + ARROW_SLOPERUN)
        / ARROW_SLOPERUN) / 2;
    ptBoundA.x = ptTail.x + dxBound;
    ptBoundA.y = ptTail.y - dyBound;
    ptBoundB.x = ptTail.x - dxBound;
    ptBoundB.y = ptTail.y + dyBound;

    // draw the arrowhead
    Pie(hdc, ptTip.x - ARROW_RADIUS, ptTip.y - ARROW_RADIUS,
             ptTip.x + ARROW_RADIUS, ptTip.y + ARROW_RADIUS,
         ptBoundA.x, ptBoundA.y, ptBoundB.x, ptBoundB.y);
}


/* GetOrInvalLinkRect(plink, prc, [pwnd])
 *
 * Set <*prc> to be a bounding rectangle around <plink>.  If <pwnd> is not
 * NULL, then invalidate the area covering at least <plink> in <pwnd>.
 * (This is usually more efficient than invalidating all of <pwnd>,
 * for links that have at least one bend.)
 */
void CBoxDraw::GetOrInvalLinkRect(CBoxLink *plink, CRect *prc, CScrollView *pScroll)
{
    CPoint          ptPrev, ptCur;  // endpoints of current line segment
    int             iSeg = 0;       // current line segment (0, 1, 2, ...)
    CRect           rc;
    const int       iLineWidth = 1;

    // enumerate the line segments of the link, starting at the arrowtail
    ptPrev = GetTabCenter(plink->m_psockTail);
    ptCur = GetTabCenter(plink->m_psockHead);

    // set <rc> to be the rectangle with corners at <ptPrev> and <ptCur>
    rc.TopLeft() = ptPrev;
    rc.BottomRight() = ptCur;
    NormalizeRect(&rc);

    // inflate <rc> to account for arrowheads, line width, and hilited bends
    const int iInflate = max(ARROW_SLOPERISE, m_iHiliteBendsRadius) + 1;
    rc.InflateRect(iInflate, iInflate);

    // enlarge <prc> as necessary to include <rc>
    if (iSeg++ == 0)
        *prc = rc;
    else
        prc->UnionRect(prc, &rc);

    // invalidate <rc> if requested
    if (pScroll != NULL)
        pScroll->InvalidateRect(&(rc - pScroll->GetScrollPosition()), TRUE);

    ptPrev = ptCur;
}


/* SelectLinkBrushAndPen(pdc, fHilite)
 *
 * Select the brush and pen used to draw links into <pdc>.  If <fHilite>,
 * select the brush and pen used to draw highlighted links.
 */
void CBoxDraw::SelectLinkBrushAndPen(CDC *pdc, BOOL fHilite)
{
    pdc->SelectObject(&m_abrLink[fnorm(fHilite)]);
    pdc->SelectObject(&m_apenLink[fnorm(fHilite)]);
}


/* DrawArrow(pdc, ptTail, ptHead, [fGhost], [fArrowhead], [fHilite])
 *
 * Draw an arrow from <ptTail> to <ptHead>.  If <fGhost> is FALSE, draw in
 * the normal color for links (if <fHilite> is FALSE) or the highlight color
 * for links (if <fHilite> is TRUE).  Otherwise, draw by inverting destination
 * pixels so that calling DrawGhostArrow() again with the same parameters will
 * return <pdc> to its original state.
 *
 * If <fArrowhead>, draw the arrowhead.  Otherwise, just draw a line with
 * no arrowhead.
 */
void CBoxDraw::DrawArrow(CDC *pdc, CPoint ptTail, CPoint ptHead, BOOL fGhost,
    BOOL fArrowhead, BOOL fHilite)
{
    // draw in "xor" mode if <fGhost>, black otherwise
    int iPrevROP = pdc->SetROP2(fGhost ? R2_NOT : R2_COPYPEN);

    // select brush and pen
    SelectLinkBrushAndPen(pdc, fHilite);

    // draw line
    pdc->MoveTo(ptTail);
    pdc->LineTo(ptHead);

    // draw arrowhead (if requested)
    if (fArrowhead)
        DrawArrowHead(pdc->m_hDC, ptHead, ptTail, FALSE);

    // revert to previous raster operation
    pdc->SetROP2(iPrevROP);
}


/* DrawLink(plink, pdc, [fHilite], [psizGhostOffset])
 *
 * Draw the link <plink> in <pdc> (a DC onto the window containing the box
 * network), using the normal color for links (if <fHilite> is FALSE) or
 * the using the highlight color for links (if <fHilite> is TRUE). and also draw
 * the head and tail the same way.
 *
 * If <psizGhostOffset> not NULL then, instead of drawing the link, draw a
 * "ghost" version of the link, offset by <*psizGhostOffset>, by inverting
 * destination pixels; calling DrawLink() again with the same value of
 * <psizGhostOffset> will invert the same pixels again and return <pdc>
 * to its original state.  Special case: if <psizeGhostOffset> is not NULL,
 * then for each end of the link (arrowtail and arrowhead), if that end
 * is connected to a box that is not selected, don't offset that end
 * (so that, during a box-move operation, links to boxes that aren't selected
 * are shown still connected to those boxes).
 */
void CBoxDraw::DrawLink(CBoxLink *plink, CDC *pdc, BOOL fHilite, CSize *psizGhostOffset)
{
    CSize           sizOffset;      // amount to offset vertices by
    CPoint          pt1, pt2;

    if (psizGhostOffset == NULL) {	// reflect true state, unless drawing ghost
        fHilite = plink->IsSelected();	//!!! override paramter!
    }

    // set <sizOffset> to the amount to offset link drawing by
    if (psizGhostOffset != NULL)
        sizOffset = *psizGhostOffset;
    else
        sizOffset = CSize(0, 0);

    // draw all line segments, except for the line segment containing the
    // arrowhead, starting from the tail end of the link
    CPoint pt = GetTabCenter(plink->m_psockTail);
    BOOL fMovingBothEnds = (plink->m_psockTail->m_pbox->IsSelected() &&
                            plink->m_psockHead->m_pbox->IsSelected());

    // draw the line segment that includes the arrowhead
    CPoint ptHead = GetTabCenter(plink->m_psockHead);
    pt1 = pt + (plink->m_psockTail->m_pbox->IsSelected()
                    ? sizOffset : CSize(0, 0));
    pt2 = ptHead + (plink->m_psockHead->m_pbox->IsSelected()
                    ? sizOffset : CSize(0, 0));

    DrawArrow(pdc, pt1, pt2, (psizGhostOffset != NULL), TRUE, fHilite);
}


/* iNew = RestrictRange(i, i1, i2)
 *
 * If <i> is between <i1> or <i2> (or equal to <i1> or <i2>), return <i>.
 * Otherwise, return whichever of <i1> or <i2> that <i> is closest to.
 */
int NEAR PASCAL
RestrictRange(int i, int i1, int i2)
{
    if (i1 < i2)
        return ibound(i, i1, i2);
    else
        return ibound(i, i2, i1);

    return i;
}


/* lSq = Square(l)
 *
 * Return the sqare of <l>.
 */
inline long Square(long l)
{
    return l * l;
}


/* iSqDist = SquareDistance(pt1, pt2)
 *
 * Return the square of the distance between <pt1> and <pt2>.
 */
inline long SquareDistance(POINT pt1, POINT pt2)
{
    return Square(pt1.x - pt2.x) + Square(pt1.y - pt2.y);
}


/* ptProject = ProjectPointToLineSeg(pt1, pt2, pt3)
 *
 * Return the point nearest to <pt3> that lies on the line segment between
 * <pt1> and <pt2>.  This is equivalent to projecting <pt3> onto line <pt1pt2>,
 * except that if the projected point lies on <pt1pt2> but not between <pt1>
 * and <pt2> then return whichever of <pt1> or <pt3> that the projected point
 * is nearest to.
 */
POINT NEAR PASCAL
ProjectPointToLineSeg(POINT pt1, POINT pt2, POINT pt3)
{
    POINT       ptProject;  // <pt3> projected on <pt1pt2>

    // calculate <l12s>, <l13s>, and <l23s> (the square of the distance
    // between <pt1> and <pt2>, <pt1> and <pt3>, and <pt2> and pt3>,
    // respectively), using the Pythagorean Theorem
    long l12s = SquareDistance(pt1, pt2);
    long l13s = SquareDistance(pt1, pt3);
    long l23s = SquareDistance(pt2, pt3);

    // Based on the Pythagorean Theorm, and using the fact that
    // triangles <pt1pt3> and <pt2pt3> have a right angle at vertex
    // <ptProject>, the distance <pt1ptProject> is:
    //
    //     (l12s + l13s - l23s) / (2 * square_root(l12s))
    //
    // This value is needed to compute <ptProject> below, but by doing
    // some substitution below it turns out we only need the numerator
    // <lNum> of this expression:
    long lNum = l12s + l13s - l23s;

    // special case: if line is zero-length, then return either end
    if (l12s == 0)
        return pt1;

    // calculate <ptProject.x> based on similar triangles pt1ptProjectptQ
    // and pt1pt2ptR, where points <ptQ> and <ptR> are projections of
    // points <ptProject> and <pt2>, respectively, onto the x axis;
    // calculate <ptProject.y> similarly
    ptProject.x = (int) (((pt2.x - pt1.x) * lNum) / (2 * l12s) + pt1.x);
    ptProject.y = (int) (((pt2.y - pt1.y) * lNum) / (2 * l12s) + pt1.y);

    // <ptProject> is on the line <pt1pt2>; now see if <ptProject> is
    // on the line segment <pt1pt2> (i.e. between <pt1> and <pt2>);
    // if not, return whichever of <pt1> or <pt2> <ptProject> is closest to
    ptProject.x = RestrictRange(ptProject.x, pt1.x, pt2.x);
    ptProject.y = RestrictRange(ptProject.y, pt1.y, pt2.y);

    return ptProject;
}


/* eHit = HitTestLink(plink, pt, pptProject, ppbend)
 *
 * See if <pt> hits some part of <plink>.  Return the following hit-test code:
 *
 *   HT_MISS        didn't hit anything
 *   HT_LINKLINE    hit test: hit a link line (set <*pplink> to it; set
 *                  <*ppbend> to the bend at the end of the line segment
 *                  toward the arrowhead, or to NULL if it's the line segment
 *                  with the arrowhead)
 *   HT_LINKBEND    hit test: hit a bend in the link (set <*ppbend> to it;
 *                  set <*pplink> to the link)
 *
 * If something other than HT_MISS is returned, <*pptProject> is set to
 * the point nearest to <pt> on a line segment of the link.
 */
CBoxDraw::EHit CBoxDraw::HitTestLink(CBoxLink *plink, CPoint pt, CPoint *pptProject)
{
    CPoint          ptPrev, ptCur;  // endpoints of current line segment
    CPoint          ptProject;      // <pt> projected onto a line segment

    // these variables keep track of the closest line segment to <pt>
    long            lSqDistSeg;
    long            lSqDistSegMin = 0x7fffffff;
    CPoint          ptProjectSeg;

    // these variables keep track of the closest bend point to <pt>
    CPoint          ptProjectBend;

    // enumerate the line segments of the link, starting at the arrowtail
    ptPrev = GetTabCenter(plink->m_psockTail);

    ptCur = GetTabCenter(plink->m_psockHead);
    // see how close <pt> is to line segment (ptPrev,ptCur)
    ptProject = ProjectPointToLineSeg(ptPrev, ptCur, pt);
    lSqDistSeg = SquareDistance(ptProject, pt);
    if (lSqDistSegMin > lSqDistSeg) {
        lSqDistSegMin = lSqDistSeg;
        ptProjectSeg = ptProject;
    }

    ptPrev = ptCur;

    // see if <pt> was close enough to the closest line segment
    if (lSqDistSegMin <= Square(m_iHotZone))
    {
        *pptProject = ptProjectSeg;
        return HT_LINKLINE;
    }

    return HT_MISS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\boxdraw.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// boxdraw.h : declares CBoxDraw
//

/////////////////////////////////////////////////////////////////////////////
// CBoxDraw
//
// A CBoxDraw object maintains resources etc. used to draw and hit-test
// boxes and links.  Note that CBoxDraw is not a view of a box or link --
// it is a collection of pens, brushes, bitmaps, and functions to draw
// boxes and links.
//
// This application maintains a single, global CBoxDraw object, <gpboxdraw>.
//

class CBoxDraw
{

protected:
    // private constants (see definition in .cpp file for more information)
    static const COLORREF   m_crBkgnd;
    static const CSize      m_sizLabelMargins;
    static const int        m_iHotZone;
    static const CString    m_stBoxFontFace;
    static const int        m_iBoxLabelHeight;
    static const int        m_iBoxTabLabelHeight;
    static const COLORREF   m_crLinkNoHilite;
    static const COLORREF   m_crLinkHilite;
    static const int        m_iHiliteBendsRadius;

public:
    // constants returned by hit-test functions
    enum EHit
    {
        HT_MISS,                    // didn't hit anything
        HT_TAB,                     // hit a box tab
        HT_EDGE,                    // hit the edge of the box
        HT_TABLABEL,                // hit a box tab label
        HT_BOXLABEL,                // hit the box label
        HT_BOXFILE,                 // hit the box filename
        HT_BOX,                     // hit elsewhere on the box
        HT_LINKLINE,                // hit a link line segment
    };

protected:
    // <m_abmEdges> and <m_abmTabs> are two bitmaps (element 0 for
    // unhighlighted, element 1 for highlighted state) that each
    // contain 3x3 tiles used to draw boxes (see DrawCompositeFrame())
    CBitmap         m_abmEdges[2];  // composite bm. for drawing box edges
    CBitmap         m_abmTabs[2];   // composite bm. for drawing box tabs
    CBitmap         m_abmClocks[2]; // clock icon to show IReferenceClock filters
    SIZE            m_sizEdgesTile; // size of one of the tiles
    SIZE            m_sizTabsTile;  // size of one of the tiles
    SIZE            m_sizClock;     // size of the clock bitmap

protected:
    // fonts used to draw box labels and box tab labels
    CFont           m_fontBoxLabel; // font for box label
    CFont           m_fontTabLabel; // font for box tabs

protected:
    // brushes and pens used to draw links (element 0 for unhighlighted,
    // element 1 for highlighted state)
    CBrush          m_abrLink[2];   // brushes used to draw links
    CPen            m_apenLink[2];  // pens used to draw links

public:
    // construction and destruction
    CBoxDraw();
    ~CBoxDraw() { Exit(); };
    void Init();
    void RecreateFonts();
    void Exit();

public:
    // general functions
    COLORREF GetBackgroundColor()
        { return m_crBkgnd; }

public:
    // functions for box drawing and hit testing
    void GetInsideRect(const CBox *pbox, CRect *prc)
        { *prc = pbox->GetRect();
          prc->InflateRect(-m_sizTabsTile.cx, -m_sizTabsTile.cy); }

    void GetFrameRect(CBox *pbox, CRect *prc)
        { GetInsideRect(pbox, prc);
          prc->InflateRect(m_sizEdgesTile.cx, m_sizEdgesTile.cy); }

    void GetOrInvalBoundRect(CBox *pbox, CRect *prc, BOOL fLinks=FALSE,
        CScrollView *pScroll=NULL);

    void DrawFrame(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

    void DrawBoxLabel(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

//    void DrawBoxFile(CBox *pbox, CRect *prc, CDC *pdc, BOOL fDraw);

    void DrawTabLabel(CBox *pbox, CBoxSocket *psock, CRect *prc,
        CDC *pdc, BOOL fDraw);

    void DrawTab(CBoxSocket *psock, CRect *prc, CDC *pdc,
        BOOL fDraw, BOOL fHilite);

    void InvalidateBoundRect(CBox *pbox, CWnd *pwnd)
        { pwnd->InvalidateRect(&pbox->GetRect(), TRUE); }

    CPoint GetTabCenter(CBoxSocket *psock);

    CBoxTabPos BoxTabPosFromPoint(CBox *pbox, CPoint pt, LPINT piError);

    CPoint BoxTabPosToPoint(const CBox *pbox, CBoxTabPos tabpos);

    void DrawBox(CBox *pbox, CDC *pdc,  CBoxSocket *psockHilite=NULL,
        CSize *psizGhostOffset=NULL);

    EHit HitTestBox(CBox *pbox, CPoint pt, CBoxTabPos *ptabpos,
        CBoxSocket **ppsock);

public:
    // functions for link drawing and hit testing

    void GetOrInvalLinkRect(CBoxLink *plink, CRect *prc, CScrollView *pScroll=NULL);

    void SelectLinkBrushAndPen(CDC *pdc, BOOL fHilite);

    void DrawArrow(CDC *pdc, CPoint ptTail, CPoint ptHead, BOOL fGhost=FALSE,
        BOOL fArrowhead=TRUE, BOOL fHilite=FALSE);

    void DrawLink(CBoxLink *plink, CDC *pdc, BOOL fHilite=FALSE, CSize *psizGhostOffset=NULL);

    EHit HitTestLink(CBoxLink *plink, CPoint pt, CPoint *pptProject);
};


/////////////////////////////////////////////////////////////////////////////
// Global (shared) CBoxDraw object

extern CBoxDraw * gpboxdraw;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\congraph.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "congraph.h"

BEGIN_MESSAGE_MAP(CConGraph, CDialog)
    ON_COMMAND(IDC_REFRESH, OnRefreshList)
    ON_LBN_DBLCLK(IDC_LIST1, OnDblclkGraphList)
    ON_WM_DESTROY()
END_MESSAGE_MAP()

//
// Constructor
//
CConGraph::CConGraph(IMoniker **ppmk, IRunningObjectTable *pirot, CWnd * pParent):
    CDialog(IDD_CONNECTTOGRAPH, pParent)
{
    m_ppmk = ppmk;
    *ppmk = 0;
    m_pirot = pirot;
}

CConGraph::~CConGraph()
{
}

void CConGraph::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFontPropPage)
        DDX_Control(pDX, IDC_LIST1, m_ListBox);
    //}}AFX_DATA_MAP
}

void CConGraph::ClearList()
{
    int i = m_ListBox.GetCount();
    while (i--) {
        IMoniker *pmkr = (IMoniker *) m_ListBox.GetItemData(i);

        pmkr->Release();
    }

    m_ListBox.ResetContent();
}

void CConGraph::OnRefreshList()
{
    ClearList();

    LPBINDCTX lpbc;

    CreateBindCtx(0, &lpbc);

    IEnumMoniker *pEnum;
    if (SUCCEEDED(m_pirot->EnumRunning(&pEnum))) {
        while (1) {
            IMoniker *pmkr;
            DWORD dwFetched = 0;
            pEnum->Next(1,&pmkr,&dwFetched);
            if (dwFetched != 1) {
                break;
            }

            // !!! need a bind context?
            WCHAR *lpwszName;
            if (SUCCEEDED(pmkr->GetDisplayName(lpbc, NULL, &lpwszName))) {
                TCHAR szName[MAX_PATH];
                WideCharToMultiByte(CP_ACP, 0, lpwszName, -1,
                                    szName, sizeof(szName), 0, 0);
                CoTaskMemFree(lpwszName);

//                if (0 == strncmp(szTestString, szName, lstrlenA(szTestString))) {
                    // !!! need to make sure we're not looking at GraphEdit's graph!

                DWORD dw, dwPID;
                if (2 == sscanf(szName, "!FilterGraph %x  pid %x", &dw, &dwPID) && dwPID != GetCurrentProcessId()) {
                    wsprintf(szName, "pid 0x%x (%d)  IFilterGraph = %08x", dwPID, dwPID, dw);
                    int item = m_ListBox.AddString(szName);
                    m_ListBox.SetItemData(item, (DWORD_PTR) pmkr);
                    pmkr->AddRef();  // hold moniker for later
                }
            }
            pmkr->Release();
        }
        pEnum->Release();
    }
    lpbc->Release();
}

void CConGraph::OnDestroy()
{
    ClearList();
}

BOOL CConGraph::OnInitDialog()
{
    CDialog::OnInitDialog();

    OnRefreshList();
    m_ListBox.SetFocus();

    return(0); // we set the focus our selves
}

void CConGraph::OnOK()
{
    // get the string in the edit box
    int curSel = m_ListBox.GetCurSel();

    if (curSel != LB_ERR) {
        *m_ppmk = (IMoniker *) m_ListBox.GetItemData(curSel);
        (*m_ppmk)->AddRef();
    }

    CDialog::OnOK();
}

void CConGraph::OnDblclkGraphList() 
{
    OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\cmd.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// cmd.cpp : defines CCmd and the CCmdXXX classes based on it
//
// See cmd.h for a description of CCmd, the abstract class upon which
// all CCmdXXX classes are defined.
//

#include "stdafx.h"
#include "ReConfig.h"
#include "GEErrors.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static void MonGetName(IMoniker *pMon, CString *pStr)
{
    *pStr = "";
    IPropertyBag *pPropBag;
    HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {
        VARIANT var;
        var.vt = VT_BSTR;
        hr = pPropBag->Read(L"FriendlyName", &var, 0);
        if(SUCCEEDED(hr))
        {
            *pStr = var.bstrVal;
            SysFreeString(var.bstrVal);
        }

        pPropBag->Release();
    }
}



//
// --- CCmdAddFilter ---
//
// Add a filter to the document.
// provide either a CLSID and the command will create
// the necessary UI element.


//
// Constructor
//
// CoCreate the filter and create its UI element
CCmdAddFilter::CCmdAddFilter(IMoniker *pMon, CBoxNetDoc *pdoc, CPoint point)
   :  m_pdoc(pdoc)
    , m_fAdded(FALSE)
    , m_pMoniker(pMon)
{
    {
        IBaseFilter *pFilter;
        HRESULT hr = pMon->BindToObject(0, 0, IID_IBaseFilter, (void **)&pFilter);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }

        CString szDevName;
        MonGetName(pMon, &szDevName);
        
        m_pbox = new CBox(pFilter, pdoc, &szDevName, point);
        pFilter->Release();
        if(m_pbox == 0) {       // !!! redundant?
            throw CHRESULTException(E_OUTOFMEMORY);
        }
    }
            
    
    m_pMoniker = pMon;          // addref automatic

    m_stLabel = m_pbox->Label();
}

//
// CanDo
//
// We can only add a filter if the filter graph is stopped
BOOL CCmdAddFilter::CanDo(CBoxNetDoc *pdoc)
{
    ASSERT(pdoc);

    return(pdoc->IsStopped());
}

//
// Do
//
// Add the box to the document, and add the filter to the graph
void CCmdAddFilter::Do(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    pdoc->DeselectAll();

    // select the box being added
    m_pbox->SetSelected(TRUE);

    HRESULT hr = m_pbox->AddToGraph();
    if (FAILED(hr)) {
        DisplayQuartzError( IDS_CANT_ADD_FILTER, hr );
	m_fAdded = FALSE;
	return;
    }
    // pins may have changed
    hr = m_pbox->Refresh();

    m_pbox->ShowDialog();	// show any property dialog

    // add the box to the document and update the view
    pdoc->m_lstBoxes.AddHead(m_pbox);
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOX, m_pbox);

    m_fAdded = TRUE;

}


//
// Undo
//
void CCmdAddFilter::Undo(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    if (!m_fAdded) {
        return;		// the box was never added
    }

    // remove the box from the document and update the view
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_BOX, m_pbox);

    pdoc->m_lstBoxes.RemoveHead();

    m_pbox->RemoveFromGraph();
    m_pbox->HideDialog();	// hide any property dialog
}


//
// Redo
//
void CCmdAddFilter::Redo(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    Do(pdoc);

}


//
// Repeat
//
// Construct an AddFilter command that adds the same filter
// to this document.
CCmd *CCmdAddFilter::Repeat(CBoxNetDoc *pdoc) {

    ASSERT(m_pdoc == pdoc);

    return new CCmdAddFilter(m_pMoniker, pdoc);
}


//
// Destructor
//
// delete m_pbox we are on the redo stack or if it was not added.
CCmdAddFilter::~CCmdAddFilter() {

    TRACE("~CCmdAddFilter() m_fRedo=%d\n", m_fRedo);

    if (m_fRedo) {	// on redo stack

        delete m_pbox;
    }
    else if (!m_fAdded) {	// on undo stack, but filter was not added

        delete m_pbox;
    }
}


//
// --- CCmdDeleteSelection ---
//


//
// CanDo
//
// Only possible if boxes are selected and the graph is stopped
BOOL CCmdDeleteSelection::CanDo(CBoxNetDoc *pdoc) {

    return ( !pdoc->IsSelectionEmpty() && pdoc->IsStopped() );
}


//
// Do
//
// 2 phases - Delete links, so that the neccessary connections are broken
//	    - Delete the filters. These are now unconnected, so safe to remove from the graph
void CCmdDeleteSelection::Do(CBoxNetDoc *pdoc) {

    DeleteLinks(pdoc);
    DeleteFilters(pdoc);

    //
    // Redraw the whole graph
    //
    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);
}


//
// DeleteLinks
//
// Remove the selected links from the document & disconnect them
//
void CCmdDeleteSelection::DeleteLinks(CBoxNetDoc *pdoc) {

    POSITION posNext = pdoc->m_lstLinks.GetHeadPosition();

    while (posNext != NULL) {

        POSITION posCurrent = posNext;
        CBoxLink *plink = (CBoxLink *) pdoc->m_lstLinks.GetNext(posNext);
	    if (plink->IsSelected()) {
	
    	    pdoc->m_lstLinks.RemoveAt(posCurrent);

            plink->Disconnect();

            delete plink;

            //
            // There might be links which where removed in the
            // Disconnect operation. We need to start from the beginning.
            //
            posNext = pdoc->m_lstLinks.GetHeadPosition();
	    }
    }
}


//
// DeleteFilters
//
// Remove the selected filters from the document & filtergraph
void CCmdDeleteSelection::DeleteFilters(CBoxNetDoc *pdoc) {

    POSITION posNext = pdoc->m_lstBoxes.GetHeadPosition();

    while (posNext != NULL) {

        POSITION posCurrent = posNext;
        CBox *pbox = pdoc->m_lstBoxes.GetNext(posNext);
        if (pbox->IsSelected()) {

	        pdoc->m_lstBoxes.RemoveAt(posCurrent);

	        pbox->RemoveFromGraph();
	        pbox->HideDialog();	// hide any property dialog on display

            delete pbox;
        }
    }
}


//
// Repeat
//
// Return a new DeleteSelection command
CCmd *CCmdDeleteSelection::Repeat(CBoxNetDoc *pdoc) {

    return (new CCmdDeleteSelection());
}


//
// CanRepeat
//
// If there is a selection this command is repeatable
BOOL CCmdDeleteSelection::CanRepeat(CBoxNetDoc *pdoc) {

    return CanDo(pdoc);
}


//
// --- CCmdMoveBoxes ---
//
// CCmdMoveBoxes(sizOffset) constructs a command to move the currently
// selected  boxes by <sizOffset> pixels.
//
// Member variables:
//  CSize           m_sizOffset;        // how much selection is offset by
//  CObList         m_lstBoxes;         // list containing each CBox to move
//
// <m_sizOffset> is the number of pixels the selection is to be offset by
// (in the x- and y-direction).  <m_lstBoxes> contains the list of boxes
// that will be moved.
//


BOOL CCmdMoveBoxes::CanDo(CBoxNetDoc *pdoc) {

    // can only move boxes if one or more boxes are selected
    return !pdoc->IsBoxSelectionEmpty();
}


unsigned CCmdMoveBoxes::GetLabel() {

    if (m_lstBoxes.GetCount() == 1)
        return IDS_CMD_MOVEBOX;             // singular form
    else
        return IDS_CMD_MOVEBOXES;           // plural form
}


CCmdMoveBoxes::CCmdMoveBoxes(CSize sizOffset)
    : m_lstBoxes(FALSE)		// don't want the boxes deleted with the command
    , m_sizOffset(sizOffset) {

}


void CCmdMoveBoxes::Do(CBoxNetDoc *pdoc) {

    // make a list of pointers to boxes that will be moved
    pdoc->GetBoxSelection(&m_lstBoxes);

    // move the boxes and update all views
    pdoc->MoveBoxSelection(m_sizOffset);
}


void CCmdMoveBoxes::Undo(CBoxNetDoc *pdoc) {

    // restore the original selection
    pdoc->SetBoxSelection(&m_lstBoxes);

    // move the boxes back to where they were and update all views
    pdoc->MoveBoxSelection(NegateSize(m_sizOffset));
}


void CCmdMoveBoxes::Redo(CBoxNetDoc *pdoc) {

    // restore the original selection
    pdoc->SetBoxSelection(&m_lstBoxes);

    // move the boxes and update all views
    pdoc->MoveBoxSelection(m_sizOffset);
}


CCmd * CCmdMoveBoxes::Repeat(CBoxNetDoc *pdoc) {

    return new CCmdMoveBoxes(m_sizOffset);
}


BOOL CCmdMoveBoxes::CanRepeat(CBoxNetDoc *pdoc) {

    return CanDo(pdoc);
}


CCmdMoveBoxes::~CCmdMoveBoxes() {

    TRACE("~CCmdMoveBoxes (%d,%d)\n", m_sizOffset.cx, m_sizOffset.cy);
}


//
// --- CCmdConnect ---
//
// Connect the two sockets. Construct the link with the arrow
// in the correct sense (connections always are output->input)
//
// If we connect intelligently the graph & doc will be updated, so
// we must delete this link.


//
// Constructor
//
// Construct the link with the correct direction sense
CCmdConnect::CCmdConnect(CBoxSocket *psock1, CBoxSocket *psock2)
{

    PIN_DIRECTION dir = psock1->GetDirection();

    if (dir == PINDIR_OUTPUT) {
        ASSERT((psock2->GetDirection()) == PINDIR_INPUT);

        m_plink = new CBoxLink(psock1, psock2);
    }
    else {
        ASSERT((psock1->GetDirection()) == PINDIR_INPUT);
        ASSERT((psock2->GetDirection()) == PINDIR_OUTPUT);

        m_plink = new CBoxLink(psock2, psock1);
    }
}


//
// Do
//
void CCmdConnect::Do(CBoxNetDoc *pdoc) {

    pdoc->BeginWaitCursor();

    // m_plink is our pointer to a _temporary_ link. Connect calls
    // DirectConnect and IntelligentConnect which, if sucessful, call
    // UpdateFilter. This calls GetLinksInGraph which will create
    // the permanent link
    HRESULT hr = m_plink->Connect();

    // We need to null these values out to avoid the link's destructor
    // nulling the connecting filters' pointers to the permanent link
    m_plink->m_psockHead = NULL;
    m_plink->m_psockTail = NULL;

    // And remove the temporary link
    delete m_plink;
    m_plink = NULL;

    if (FAILED(hr)) {

        DisplayQuartzError( IDS_CANTCONNECT, hr );

        // update all views, as link will dissapear
        pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);

    }

    pdoc->EndWaitCursor();

}


//
// --- DisconnectAll ---
//
// Remove all connections from this graph


//
// Constructor
//
CCmdDisconnectAll::CCmdDisconnectAll()
{}


//
// Destructor
//
CCmdDisconnectAll::~CCmdDisconnectAll() {
    TRACE("~CCmdDisconnectAll() m_fRedo=%d\n", m_fRedo);
}


//
// CanDo
//
// This is only possible if there are links and we are stopped.
BOOL CCmdDisconnectAll::CanDo(CBoxNetDoc *pdoc) {

    return (  (pdoc->m_lstLinks.GetCount() > 0)
            && (pdoc->IsStopped())
           );
}


//
// Do
//
// Remove all the links from the document
void CCmdDisconnectAll::Do(CBoxNetDoc *pdoc) {

    ASSERT(pdoc->IsStopped());

    while (pdoc->m_lstLinks.GetCount() > 0) {
        CBoxLink *plink = pdoc->m_lstLinks.RemoveHead();
        plink->Disconnect();
        delete plink;
    }

    pdoc->ModifiedDoc(NULL, CBoxNetDoc::HINT_DRAW_ALL, NULL);
}


//
// Redo
//
void CCmdDisconnectAll::Redo(CBoxNetDoc *pdoc) {
    Do(pdoc);
}


//
// --- CmdRender ---
//
// render this pin. Add whatever the filtergraph decides it needs to the document


//
// CanDo
//
BOOL CCmdRender::CanDo(CBoxNetDoc *pdoc) {

    return (   (pdoc->SelectedSocket()->GetDirection() == PINDIR_OUTPUT)
    	    && !(pdoc->SelectedSocket()->IsConnected())
            && (pdoc->IsStopped())
	   );
}


//
// Do
//
void CCmdRender::Do(CBoxNetDoc *pdoc) {

    pdoc->BeginWaitCursor();

    CBoxSocket *psock = pdoc->SelectedSocket();

    HRESULT hr = pdoc->IGraph()->Render(psock->pIPin());

    if (FAILED(hr)) {
        DisplayQuartzError( IDS_CANT_RENDER, hr );
    	pdoc->RestoreWaitCursor();
    }
    else {
        pdoc->UpdateFilters();
    }

    pdoc->EndWaitCursor();
}

//
// --- CCmdRenderFile ---
//
// Construct the graph to render this file

//
// Do
//
void CCmdRenderFile::Do(CBoxNetDoc *pdoc) {


    pdoc->BeginWaitCursor();

    HRESULT hr = pdoc->IGraph()->RenderFile( CMultiByteStr(m_FileName), NULL);
                                              // use default play list
    if (FAILED(hr)) {
        pdoc->EndWaitCursor();

        DisplayQuartzError( IDS_CANT_RENDER_FILE, hr );
        return;
    } else if( hr != NOERROR )
        DisplayQuartzError( hr );

    pdoc->UpdateFilters();

    pdoc->EndWaitCursor();
}

/******************************************************************************

CCmdAddFilterToCache

    This command adds a filter to the filter cache.  For more information on
the filter cache, see the IGraphConfig documentation in the Direct Show SDK.

******************************************************************************/
unsigned CCmdAddFilterToCache::GetLabel()
{
    return IDS_CMD_ADD_FILTER_TO_CACHE;
}

BOOL CCmdAddFilterToCache::CanDo( CBoxNetDoc *pdoc )
{
    return !pdoc->IsBoxSelectionEmpty();
}

void CCmdAddFilterToCache::Do( CBoxNetDoc *pdoc )
{
    CBox *pCurrentBox;

    IGraphConfig* pGraphConfig;

    HRESULT hr = pdoc->IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        return;
    }

    POSITION posNext = pdoc->m_lstBoxes.GetHeadPosition();
    POSITION posCurrent;

    while( posNext != NULL ) {
        posCurrent = posNext;
        pCurrentBox = pdoc->m_lstBoxes.GetNext( posNext );

        if( pCurrentBox->IsSelected() ) {
            hr = pGraphConfig->AddFilterToCache( pCurrentBox->pIFilter() );
            if( FAILED( hr ) ) {
                DisplayQuartzError( hr );
            }
        }
    }

    pdoc->UpdateFilters();

    pGraphConfig->Release();
}

/******************************************************************************

CCmdReconnect

    This command reconnects an output pin.  It works even if the filter graph
is running or paused.

******************************************************************************/
unsigned CCmdReconnect::GetLabel()
{
    return IDS_CMD_RECONNECT;
}

BOOL CCmdReconnect::CanDo( CBoxNetDoc* pDoc )
{
    if( pDoc->AsyncReconnectInProgress() ) {
        return FALSE;
    }

    CBoxSocket* pSelectedSocket = pDoc->SelectedSocket();
    if( NULL == pSelectedSocket ) {
        return FALSE;
    }

    if( pSelectedSocket->GetDirection() != PINDIR_OUTPUT ) {
        return FALSE;
    }

    if( !pSelectedSocket->IsConnected() ) {
        return FALSE;
    }

    CComPtr<IGraphConfig> pGraphConfig;

    HRESULT hr = pDoc->IGraph()->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return FALSE;
    }

    IPin* pSelectedPin = pSelectedSocket->pIPin();
    CComPtr<IPinFlowControl> pOutputPin;
    
    hr = pSelectedPin->QueryInterface( IID_IPinFlowControl, (void**)&pOutputPin );
    if( FAILED( hr ) ) {
        return FALSE;
    }

    return TRUE;
}

void CCmdReconnect::Do( CBoxNetDoc* pDoc )
{
    pDoc->BeginWaitCursor();    

    CBoxSocket* pSelectedSocket = pDoc->SelectedSocket();
    if( NULL == pSelectedSocket ) {
        pDoc->EndWaitCursor();
        DisplayQuartzError( E_POINTER );  // TBD - Define GE_E_SELECTED_SOCKET_DOES_NOT_EXIST.
        return;
    }

    IPin* pSelectedPin = pSelectedSocket->pIPin();

    // A socket should always be assocaited with a valid pin.
    ASSERT( NULL != pSelectedPin );    

    HRESULT hr = pDoc->StartReconnect( pDoc->IGraph(), pSelectedPin );
    if( GE_S_RECONNECT_PENDING == hr ) {
        // AfxMessageBox() returns 0 if an error occurs.
        if( 0 == AfxMessageBox( IDS_RECONNECT_PENDING ) ) {
            TRACE( TEXT("WARNING: CBoxNetDoc::StartReconnect() returned GE_S_RECONNECT_PENDING but the user could not be notified because AfxMessageBox() failed.") );
        }
    } else if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
    }

    pDoc->EndWaitCursor();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\cmd.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// cmd.h : declares CCmd and the CCmdXXX classes based on it
//


/////////////////////////////////////////////////////////////////////////////
// CCmd
//
// CCmd is a virtual class that implements an interface to commands performed
// on a CBoxNetDoc.
//
// A CCmd represents a command given to a CBoxNetDoc.  To perform a command,
// allocate a CCmdXXX structure and submit it to CBoxNetDoc::CmdDo(), which
// will call the Do() memeber function.  The Undo() and Redo() member functions
// get called when the user performs an Undo or Redo action, respectively.
// Repeat() should create a duplicate of the command, to perform a Repeat
// action; if this is not possible, return FALSE from CanRepeat().
// The destructor gets called when there is no chance the command will be
// undone or redone; at this time, <fRedo> will be TRUE if the command is on
// the redo stack (so e.g. the CBox in a CCmdNewBox command should be freed)
// or FALSE if the command is on the undo stack (so e.g. the CBox in a
// CCmdNewBox command should not be freed since it is currently in use by
// the document).
//
// CanUndo() returns TRUE iff Undo() is implemented.  CanRepeat() returns
// TRUE iff Repeat() can be called at that time (e.g. some commands depend
// on there being something selected at that time).
//
// Some subclasses of CCmd implement a static CanDo() method which returns
// TRUE if a command of that class can be created and Do() can be called at
// that time.
//

class CCmd : public CObject {
public:
    BOOL       m_fRedo;            // command is sitting in the Redo stack

public:

    CCmd(void) : m_fRedo(FALSE) {;}
    virtual ~CCmd() {;}
    virtual unsigned GetLabel() = 0;

    // Perform the command on this document
    virtual void Do(CBoxNetDoc *pdoc) = 0;

    // If CanUndo() then Undo & redo can be called
    virtual BOOL CanUndo(CBoxNetDoc *pdoc)	{ return FALSE; }
    virtual void Undo(CBoxNetDoc *pdoc)		{;}
    virtual void Redo(CBoxNetDoc *pdoc)		{;}

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc)	{ return FALSE; }
    virtual CCmd *Repeat(CBoxNetDoc *pdoc)	{ return NULL; }
};


//
// --- CCmdAddFilter ---
//
class CCmdAddFilter : public CCmd {
protected:
    CBox        *m_pbox;        // box being created
    CBoxNetDoc  *m_pdoc;	// document to add it to
    BOOL	m_fAdded;	// TRUE iff filter added to graph

    CQCOMInt<IMoniker> m_pMoniker; // keep moniker so we can repeat
    CString	m_stLabel;	// keep label for repeat

public:
    virtual unsigned GetLabel(void)	{ return IDS_CMD_ADDFILTER; }
    CCmdAddFilter(IMoniker *pMon, CBoxNetDoc *pdoc, CPoint point = CPoint(-1, -1));
    virtual ~CCmdAddFilter();

    virtual void Do(CBoxNetDoc *pdoc);

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual BOOL CanUndo(CBoxNetDoc *pdoc)	{ return TRUE; }
    virtual void Undo(CBoxNetDoc *pdoc);
    virtual void Redo(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc) { return TRUE; }
    virtual CCmd *Repeat(CBoxNetDoc *pdoc);
};


//
// --- CCmdDeleteSelection ---
//
class CCmdDeleteSelection : public CCmd {

public:
    virtual unsigned GetLabel(void) { return IDS_CMD_DELETE; }

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual void Do(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc);
    virtual CCmd * Repeat(CBoxNetDoc *pdoc);

private:

    void DeleteFilters(CBoxNetDoc *pdoc);
    void DeleteLinks(CBoxNetDoc *pdoc);
};


//
// --- CCmdMoveBoxes ---
//
class CCmdMoveBoxes : public CCmd {
protected:
    CSize           m_sizOffset;        // how much selection is offset by
    CBoxList        m_lstBoxes;         // list containing each CBox to move

public:

    virtual unsigned GetLabel();
    CCmdMoveBoxes(CSize sizOffset);
    virtual ~CCmdMoveBoxes();

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual void Do(CBoxNetDoc *pdoc);

    virtual BOOL CanUndo(CBoxNetDoc *pdoc) { return TRUE; }
    virtual void Undo(CBoxNetDoc *pdoc);
    virtual void Redo(CBoxNetDoc *pdoc);

    virtual BOOL CanRepeat(CBoxNetDoc *pdoc);
    virtual CCmd * Repeat(CBoxNetDoc *pdoc);
};


//
// --- CCmdConnect ---
//
class CCmdConnect : public CCmd {
protected:
    CBoxLink *      m_plink;            // link being created

public:
    virtual unsigned GetLabel(void) { return IDS_CMD_CONNECT; }
    CCmdConnect(CBoxSocket *psockTail, CBoxSocket *psockHead);

    virtual void Do(CBoxNetDoc *pdoc);
};


//
// --- CCmdDisconnectAll ---
//
class CCmdDisconnectAll : public CCmd {

public:

    CCmdDisconnectAll();
    virtual ~CCmdDisconnectAll();

    static BOOL CanDo(CBoxNetDoc *pdoc);
    virtual unsigned GetLabel(void) { return IDS_CMD_DISCONNECTALL; }
    virtual void Do(CBoxNetDoc *pdoc);

    virtual void Redo(CBoxNetDoc *pdoc);
};


//
// --- CCmdRender ---
//
class CCmdRender : public CCmd {

public:

    static BOOL		CanDo( CBoxNetDoc *pdoc );
    virtual unsigned	GetLabel() { return IDS_CMD_RENDER; }
    virtual void	Do(CBoxNetDoc *pdoc);

};


//
// --- CCmdRenderFile ---
//
class CCmdRenderFile : public CCmd {

public:

    CCmdRenderFile(CString FileName) : m_FileName(FileName) {}

    static BOOL		CanDo(void) { return TRUE; }
    virtual unsigned	GetLabel() { return IDS_CMD_RENDERFILE; }

    virtual void	Do(CBoxNetDoc *pdoc);

private:

    CString m_FileName;
};

class CCmdAddFilterToCache : public CCmd
{
public:
    unsigned GetLabel();

    static BOOL CanDo( CBoxNetDoc *pdoc );
    void Do( CBoxNetDoc *pdoc );

private:
    HRESULT IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter );

};

class CCmdReconnect : public CCmd
{
public:
    unsigned CCmdReconnect::GetLabel();
    static BOOL CanDo( CBoxNetDoc* pDoc );
    void Do( CBoxNetDoc* pDoc );

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\box.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// box.h : declares CBoxTabPos, CBoxSocket, CBox
//

// forward declarations
class CBox;
class CBoxLink;
class CBoxNetDoc;

extern void AttemptFileOpen(IBaseFilter *m_pFilter);


/////////////////////////////////////////////////////////////////////////////
// CBoxTabPos
//
// A value of this class represents the position of a box tab along the edge
// of a box.  (A box tab is the graphical representation of a box network
// socket.)  The position is represented as a fraction of the length of the
// edge, so that resizing the box will retain the tab's relative position.
//
// To use CBoxTabPos:
//   -- <m_fLeftRight> is set to TRUE if the tab is on the left or right edge
//      of the box, FALSE if the tab is on the top or the bottom edge.
//   -- <m_fLeftTop> is set to TRUE if the tab is on the left or top edge
//      of the box, FALSE if the tab is on the right or bottom edge.
//   -- SetPos(uiVal, uiValMax) sets the position of the tab to be the fraction
//      (uiVal/uiValMax) of the way along the edge.
//   -- GetPos(uiValMax) returns a value <uiVal> such that the tab is
//      (uiVal/uiValMax) of the way along the edge.
//   -- Package() packages a CBoxTabPos into a form acceptable to the CArchive
//      << and >> operators.
// Internally, a CBoxTabPos is represented as two flags plus a CBTP_BITS-bit
// number that represents the tab position along the inside edge of the box,
// scaled to be in the range 0 to 1<<CBTP_BITS, (inclusive -- to allow 1.0
// to be representable).
//
// A simple way to create a CBoxTabPos is via a constructor, e.g.
//      CBoxTabPos pos(CBoxTabPos::TOP_EDGE, 2, 3); // 2/3rds across top edge
//

class CBoxTabPos
{

protected:
    // private constants
    enum {CBTP_BITS = 13};      // no. bits of precision in <m_ulPos>

public:
    // identify a box edge
    enum EEdge
    {
        BOTTOM_EDGE = 0, // m_fLeftRight=FALSE, m_fLeftTop=FALSE
        TOP_EDGE    = 1, // m_fLeftRight=FALSE, m_fLeftTop=TRUE
        RIGHT_EDGE  = 2, // m_fLeftRight=TRUE,  m_fLeftTop=FALSE
        LEFT_EDGE   = 3 // m_fLeftRight=TRUE,  m_fLeftTop=TRUE
    };

public:
    // which side of box is tab on?
    BOOL        m_fLeftRight:1; // tab is on left or right edge of box
    BOOL        m_fLeftTop:1;   // tab is on left or top edge of box

protected:
    // how far along the edge is the tab?
    unsigned    m_ulPos:CBTP_BITS+1; // position along edge (0 == top/left end)

public:
    // construction
    CBoxTabPos() {};
    CBoxTabPos(EEdge eEdge, unsigned uiVal, unsigned uiValMax)
        { m_fLeftRight = fnorm(eEdge & 2);
          m_fLeftTop = fnorm(eEdge & 1);
          SetPos(uiVal, uiValMax); }

public:
    // operations
    void SetPos(unsigned uiVal, unsigned uiValMax)
        { m_ulPos = (unsigned) (((long) uiVal << CBTP_BITS) / uiValMax); }
    unsigned GetPos(unsigned uiValMax)
        { return (int) (((long) m_ulPos * uiValMax) >> CBTP_BITS); }

public:
    // convert object to a WORD reference (for easier serialization)
    WORD & Package() { return (WORD &) *this; }

#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const {
        dc << "Left: " <<  m_fLeftTop  << "m_ulPos: " << m_ulPos << "\n";
    }

#endif // _DEBUG
};


/////////////////////////////////////////////////////////////////////////////
// CBoxSocket
//
// Logically, a socket is a place on a CBox that you can connect a link to.
// (A link connects a socket on one box to a socket on another box.)
//
//
// A CBoxSocket object contains a pointer <m_pbox> back to the parent box,
// and a pointer <m_plink> to the link that connects the socket to another
// socket (or NULL if the socket is not currently linked).  <m_stLabel> is
// a string label, and <m_tabpos> indicates where on the box the tab
// (the visual reprentation of the socket) and the label should be placed.
//

class CBoxSocket : public CPropObject {

public:
    // pointer back to parent box, pointer to connected link (if any)
    CBox	*m_pbox;             // box that contains socket
    CBoxLink	*m_plink;            // link connected to the socket (or NULL)

    CBox *pBox(void) const { return m_pbox; };

public:
    // socket user interface
    CString     m_stLabel;          // socket label

    CString	Label(void) const { return m_stLabel; }
    void	Label(CString st) { m_stLabel = st; }

    CBoxTabPos  m_tabpos;           // socket tab position along an edge

    // -- Quartz --


    IPin	*pIPin(void) const { return m_IPin; }	// NB not addref'd
    IUnknown	*pUnknown(void) const { return m_IPin; }	// NB not addref'd
    CBoxSocket	*Peer(void);
    BOOL	IsConnected(void);
    PIN_DIRECTION	GetDirection(void);

private:

    CQCOMInt<IPin>	m_IPin;		// The pin this socket minds.

    friend class CBox;

public:
    // construction
    CBoxSocket(const CBoxSocket& sock, CBox *pbox);
    CBoxSocket( CBox *pbox
              , CString stLabel
              , CBoxTabPos::EEdge eEdge
              , unsigned uiVal
              , unsigned uiValMax
              , IPin *pPin);
    ~CBoxSocket();

public:

    #ifdef _DEBUG
    
    // diagnostics
    virtual void Dump(CDumpContext& dc) const
    {
        CPropObject::Dump(dc);
        dc << m_stLabel << "\n";

        m_tabpos.Dump(dc);
    }

    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;
    
    #endif // _DEBUG

private:
    CBoxSocket(const CBoxSocket&); // the plain copy constructor is not allowed
};


// *
// * CBoxSocketList
// *

// Provides a way of getting a socket via an IPin

class CBoxSocketList : public CDeleteList<CBoxSocket *, CBoxSocket *> {
public:

    CBoxSocket *GetSocket(IPin *pPin) const;
    BOOL	IsIn(IPin *pPin) const { return (GetSocket(pPin) != NULL); }
};


/////////////////////////////////////////////////////////////////////////////
// CBox
//
// A box is a node in a box network.  Boxes contain sockets (CBoxSocket
// objects); sockets of different boxes may be connected using a CBoxLink.
//
// A CBox object contains a list <m_lstSockets> of CBoxSocket objects,
// a bounding rectangle <m_rcBound> which locates the box in its container,
// and a string label.
//
// A box also contains a flag <m_fSelected> indicating whether or not the
// box is selected.  This implies that box selection is an attribute of a
// document (containing boxes), not an attribute of a view onto such a
// document.
//
// A box manages a single Quartz Filter.

class CBox : public CPropObject {

    // -- box user interface --
    CRect       m_rcBound;          // box bounding rectangle

//#define ZOOM(x) ((x) * s_Zoom / 100)    
//#define UNZOOM(x) ((x) * 100 / s_Zoom)
    
#define ZOOM(x) ((int) ((float) (x) * (float) s_Zoom / 100.0))    
#define UNZOOM(x) ((int) ((float) (x) * 100.0 / (float) s_Zoom))


public:
    static int s_Zoom;

    static void SetZoom(int iZoom);
    
    CRect   GetRect() const { return CRect(ZOOM(m_rcBound.left),  ZOOM(m_rcBound.top),
                                           ZOOM(m_rcBound.right), ZOOM(m_rcBound.bottom)); }
 
    CPoint	Location(void) const { return CPoint(ZOOM(m_rcBound.left), ZOOM(m_rcBound.top)); }
    void	Location(CPoint pt) { X(pt.x); Y(pt.y); }

    int		nzX(void) const { return m_rcBound.left; }
    void	nzX(int x) { m_rcBound.SetRect(x, m_rcBound.top, m_rcBound.Width() + x, m_rcBound.bottom); }

    int		X(void) const { return ZOOM(m_rcBound.left); }
    int		Y(void) const { return ZOOM(m_rcBound.top); }

    void	X(int x) { m_rcBound.SetRect(UNZOOM(x), m_rcBound.top, m_rcBound.Width() + UNZOOM(x), m_rcBound.bottom);  }
    void	Y(int y) { m_rcBound.SetRect(m_rcBound.left, UNZOOM(y), m_rcBound.right, m_rcBound.Height() + UNZOOM(y)); }


    void    Move(CSize siz) { m_rcBound.OffsetRect(UNZOOM(siz.cx), UNZOOM(siz.cy)); }
    int		Width(void) const { return ZOOM(m_rcBound.Width()); }
    int		Height(void) const { return ZOOM(m_rcBound.Height()); }

    CString     m_stLabel;          // box label
    CString     m_stFilter;         // filter name

    void	Label(CString st) { m_stLabel = st; }
    CString	Label(void) const { return m_stLabel; }

    void	SetSelected(BOOL fSelected) { m_fSelected = fSelected; }
    BOOL	IsSelected(void) { return m_fSelected; }

    // CPropObject overrides - distribute requests to our sockets
    virtual void ShowDialog();
    virtual void HideDialog();

    BOOL        HasClock() { return m_fHasClock; }
    BOOL        HasSelectedClock() { return m_fClockSelected; }

private:
    BOOL        m_fSelected;        // box is selected?
    BOOL        m_fHasClock;
    BOOL        m_fClockSelected; // this filters clock is the current one


    // -- Automatic layout helpers --
public:
    void	CalcRelativeY(void);	// y position relative to input peers
    float	RelativeY(void) const { return m_RelativeY; }

private:

    float	m_RelativeY;


    // -- Quartz --
public:

    CBoxNetDoc	*pDoc(void) const {ASSERT(m_pDoc); return m_pDoc;}
    IBaseFilter	*pIFilter(void) const { return m_IFilter; } 	// NB not addref'd
    IUnknown	*pUnknown(void) const { return m_IFilter; }	// NB not addref'd

    HRESULT	Refresh(void);

    HRESULT	AddToGraph(void);
    HRESULT	RemoveFromGraph(void);

private:

    CQCOMInt<IBaseFilter>	m_IFilter;	    // While this box exists the filter is instantiated
    LONG		m_lInputTabPos;
    LONG		m_lOutputTabPos;
    int			m_iTotalInput;
    int			m_iTotalOutput;
    CBoxNetDoc		*m_pDoc;

    void CalcTabPos(void);
    void UpdateSockets(void);


    // -- construction and destruction --
public:

    CBox(const CBox& box);    // copy constructor
    CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc);
    CBox(IBaseFilter *pFilter, CBoxNetDoc *pDoc, CString *pName, CPoint point = CPoint(-1, -1));
    ~CBox();


    // -- operations --
public:

    void AddSocket(CString stLabel, CBoxTabPos::EEdge eEdge,
        unsigned uiVal, unsigned uiValMax, IPin *pPin);
    HRESULT RemoveSocket(POSITION, BOOL bForceIt = FALSE);

    BOOL operator==(const CBox& box) const;
    BOOL operator!=(const CBox& box) const { return !(*this == box); }

    // return the socket managing this pin
    CBoxSocket *GetSocket(IPin *pPin) { return m_lstSockets.GetSocket(pPin); }

    void GetLabelFromFilter( CString *pstLabel );


    // -- Diagnostics --
public:
#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;
#endif // _DEBUG

private:
    // sockets to hold connections to other boxes
    CBoxSocketList   m_lstSockets;       // list of CBoxSocket objects

    friend class CSocketEnum;	// iterates each socket in turn
    friend class CBoxNetDoc;    // to update m_fClockSelected
};



// *
// * CBoxList
// *

// A list where you can find elements by IBaseFilter
class CBoxList : public CDeleteList<CBox *, CBox *> {

public:

    CBoxList(BOOL bDestructDelete = TRUE) : CDeleteList<CBox *, CBox *>(bDestructDelete) {}
    CBoxList(BOOL bDestructDelete, int nBlockSize) : CDeleteList<CBox *, CBox *>(bDestructDelete, nBlockSize) {}

    BOOL IsIn(IBaseFilter *pFilter) const;	// is one of the boxes in this list managing
    					// this filter?
    CBox *GetBox(IBaseFilter *pFilter) const;
    CBox *GetBox(CLSID clsid) const;

    BOOL RemoveBox( IBaseFilter* pFilter, CBox** ppBox );

#ifdef _DEBUG
    virtual void Dump(CDumpContext& dc) const;
#endif // _DEBUG

};


// *
// * CSocketEnum
// *

// Returns each socket on this box, one by one. returns NULL
// when there are no more sockets.
// Can return a specific direction (input or output)
class CSocketEnum {
public:

    enum DirType {Input, Output, All};

    CSocketEnum(CBox *pbox, DirType Type = All);
    ~CSocketEnum() {};

    CBoxSocket *operator() (void);

private:

    CBox	*m_pbox;
    POSITION	m_pos;
    DirType	m_Type;
    PIN_DIRECTION	m_EnumDir;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\dcf.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <streams.h>
#include "DCF.h"
#include "FLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CDisplayCachedFilters, CDialog)
	//{{AFX_MSG_MAP(CDisplayCachedFilters)
	ON_LBN_ERRSPACE(IDC_CACHED_FILTERS, OnErrSpaceCachedFilters)
	ON_BN_CLICKED(ID_REMOVE_FILTER, OnRemoveFilter)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDisplayCachedFilters::CDisplayCachedFilters
    (
    IGraphConfig* pFilterCache,
    HRESULT* phr,
    CWnd* pParent /*=NULL*/
    )
	: CDialog(CDisplayCachedFilters::IDD, pParent),
    m_pFilterCache(NULL),
    m_plbCachedFiltersList(NULL)
{
	//{{AFX_DATA_INIT(CDisplayCachedFilters)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    // This dialog box will not work correctly if a NULL pointer is passed in.
    ASSERT( NULL != pFilterCache );

    try
    {   
        m_plbCachedFiltersList = new CFilterListBox( phr );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        m_plbCachedFiltersList = NULL;

        pOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }  
 
    if( FAILED( *phr ) )
    {
        delete m_plbCachedFiltersList;
        m_plbCachedFiltersList = NULL;
        return;
    }

    m_pFilterCache = pFilterCache;
    m_pFilterCache->AddRef();
}

CDisplayCachedFilters::~CDisplayCachedFilters()
{
    delete m_plbCachedFiltersList;
    if( NULL != m_pFilterCache )
    {
        m_pFilterCache->Release();
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDisplayCachedFilters message handlers

void CDisplayCachedFilters::OnErrSpaceCachedFilters() 
{
    DisplayQuartzError( E_OUTOFMEMORY );

    EndDialog( IDABORT );
}

BOOL CDisplayCachedFilters::OnInitDialog() 
{
    CDialog::OnInitDialog();

    HRESULT hr = AddCachedFilterNamesToListBox();
    if( FAILED( hr ) ) {
        DisplayQuartzError( hr );
        EndDialog( IDABORT );
        return TRUE;
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDisplayCachedFilters::DoDataExchange(CDataExchange* pDX) 
{
    // This function exepects m_plbCachedFiltersList to be allocated.
    ASSERT( NULL != m_plbCachedFiltersList );

	CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDisplayCachedFilters)
	DDX_Control(pDX, IDC_CACHED_FILTERS, *m_plbCachedFiltersList);
	//}}AFX_DATA_MAP
}

void CDisplayCachedFilters::OnRemoveFilter() 
{
    IBaseFilter* pSelectedFilter;

    HRESULT hr = m_plbCachedFiltersList->GetSelectedFilter( &pSelectedFilter );
    if( FAILED( hr ) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    }

    hr = m_plbCachedFiltersList->RemoveSelectedFilter();
    if( FAILED( hr ) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    } 

    hr = m_pFilterCache->RemoveFilterFromCache( pSelectedFilter );
    if( FAILED( hr ) || (S_FALSE == hr) )
    {
        ::MessageBeep( MB_ICONASTERISK );
        return;
    }
    pSelectedFilter->Release(); // Release the filter cache's reference.    
}

HRESULT CDisplayCachedFilters::AddCachedFilterNamesToListBox( void )
{
    HRESULT hr;
    
    IBaseFilter* pCurrentFilter;
    IEnumFilters* pFilterCacheEnum;
    
    hr = m_pFilterCache->EnumCacheFilter( &pFilterCacheEnum );
    if( FAILED( hr ) ) {
        return hr;
    }

    HRESULT hrEnum;

    do
    {
        hrEnum = pFilterCacheEnum->Next( 1, &pCurrentFilter, NULL );
        if( FAILED( hrEnum ) ) {
            pFilterCacheEnum->Release();
            return hrEnum;
        }
        
        if( S_OK == hrEnum ) {
            // This is a sanity check used to makesure the filter cache
            // is in a valid state.
            ASSERT( S_OK == IsCached( m_pFilterCache, pCurrentFilter ) );

            hr = m_plbCachedFiltersList->AddFilter( pCurrentFilter );
    
            pCurrentFilter->Release();
            pCurrentFilter = NULL;

            if( FAILED( hr ) )
            {
                pFilterCacheEnum->Release();
                return hr;
            }
        }
    } while( S_OK == hrEnum );

    pFilterCacheEnum->Release();

    return S_OK;
}

#ifdef _DEBUG
HRESULT CDisplayCachedFilters::IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter )
{
    // This function does not handle NULL parameters.
    ASSERT( (NULL != pFilterCache) && (NULL != pFilter) );

    bool fFoundFilterInCache;
    IBaseFilter* pCurrentFilter;
    IEnumFilters* pCachedFiltersEnum;

    #ifdef _DEBUG
    DWORD dwNumFiltersCompared = 0;
    #endif // _DEBUG

    HRESULT hr = pFilterCache->EnumCacheFilter( &pCachedFiltersEnum );
    if( FAILED( hr ) ) {
        return hr;   
    }

    fFoundFilterInCache = false;

    do
    {
        hr = pCachedFiltersEnum->Next( 1, &pCurrentFilter, NULL );
        switch( hr )
        {
        case S_OK:
            if( ::IsEqualObject( pCurrentFilter, pFilter ) ) {
                fFoundFilterInCache = true;
            } else {
                fFoundFilterInCache = false;
            }
            
            #ifdef _DEBUG
            {
                dwNumFiltersCompared++;

                HRESULT hrDebug = TestTheFilterCachesIEnumFiltersInterface( pCachedFiltersEnum, pCurrentFilter, dwNumFiltersCompared );
    
                // Since this code in TestTheFilterCachesIEnumFiltersInterface() is only used to debug
                // the system, it does not affect the operation of this function.  Therefore, all failures
                // can be safely ignored (however, they SHOULD be investigated.
                ASSERT( SUCCEEDED( hrDebug ) || (VFW_E_ENUM_OUT_OF_SYNC == hrDebug) );
            }
            #endif // _DEBUG

            pCurrentFilter->Release();

            break;

        case S_FALSE:
            break;

        case VFW_E_ENUM_OUT_OF_SYNC:
            hr = pCachedFiltersEnum->Reset();

            #ifdef _DEBUG
            dwNumFiltersCompared = 0;
            #endif // _DEBUG

            break;

        default:
            // IEnumXXXX interface can only return two success codes,
            // S_OK and S_FALSE.
            ASSERT( FAILED( hr ) );
        }
            
    } while( SUCCEEDED( hr ) && (hr != S_FALSE) && !fFoundFilterInCache );

    pCachedFiltersEnum->Release();

    if( FAILED( hr ) ) {
        return hr;
    }
    
    if( fFoundFilterInCache ) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

HRESULT CDisplayCachedFilters::TestTheFilterCachesIEnumFiltersInterface( IEnumFilters* pCachedFiltersEnum, IBaseFilter* pCurrentFilter, DWORD dwNumFiltersExamended )
{
    IEnumFilters* pCloanedCachedFiltersEnum = NULL;
    IEnumFilters* pAnotherCloanedCachedFiltersEnum = NULL;
    IEnumFilters* pQueriedCachedFiltersInterface = NULL;

    HRESULT hr = pCachedFiltersEnum->QueryInterface( IID_IEnumFilters, (void**)&pQueriedCachedFiltersInterface );
    if( FAILED( hr ) )
    {
        return hr;
    }

    pQueriedCachedFiltersInterface->Release();
    pQueriedCachedFiltersInterface = NULL;

    hr = pCachedFiltersEnum->Clone( &pCloanedCachedFiltersEnum );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pCloanedCachedFiltersEnum->Clone( &pAnotherCloanedCachedFiltersEnum );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        return hr;
    }    

    hr = pCloanedCachedFiltersEnum->Reset();
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }    

    if( (dwNumFiltersExamended - 1) > 0 )
    {
        hr = pCloanedCachedFiltersEnum->Skip( dwNumFiltersExamended - 1 );
        if( FAILED( hr ) )
        {
            pCloanedCachedFiltersEnum->Release();
            pAnotherCloanedCachedFiltersEnum->Release();
            return hr;
        }
    }

    DWORD dwNumFiltersRetrieved;
    IBaseFilter* aCurrentFilter[1];

    hr = pCloanedCachedFiltersEnum->Next( 1, aCurrentFilter, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should not be S_FALSE because the cache contains at least
    // dwNumFiltersExamended filtes.
    ASSERT( S_FALSE != hr );

    // IEnumFilters::Next() should return exactly one filter because 
    // that is all we asked for.
    ASSERT( 1 == dwNumFiltersRetrieved );    

    // The preceding code should get the same filter as the current filter.    
    ASSERT( ::IsEqualObject( pCurrentFilter, aCurrentFilter[0] ) );

    aCurrentFilter[0]->Release();
    aCurrentFilter[0] = NULL;

    const DWORD HUGE_NUMBER = 0x7FFFFFFF;

    hr = pCloanedCachedFiltersEnum->Skip( HUGE_NUMBER );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should be S_FALSE because the usually does not contain
    // HUGE_NUMBER of filters.  Ignore this ASSERT if you have at least
    // HUGE_NUMBER + dwNumFiltersExamended of filters in the cache.
    ASSERT( S_FALSE == hr );

    hr = pCloanedCachedFiltersEnum->Reset();
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }  

    IBaseFilter** ppCachedFilters;

    try
    {
        ppCachedFilters = new IBaseFilter*[dwNumFiltersExamended];
    }
    catch( CMemoryException* peOutOfMemory )
    {
        peOutOfMemory->Delete();

        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return E_OUTOFMEMORY;
    }

    hr = pCloanedCachedFiltersEnum->Next( dwNumFiltersExamended, ppCachedFilters, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        delete [] ppCachedFilters;
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    // This should not be S_FALSE because the cache contains at least
    // dwNumFiltersExamended filtes.
    ASSERT( S_FALSE != hr );

    // IEnumFilters::Next() should return exactly dwNumFiltersExamended filters because 
    // that is all we asked for.
    ASSERT( dwNumFiltersExamended == dwNumFiltersRetrieved );
    
    // The last filter in the array should be the same as the current filter.
    ASSERT( ::IsEqualObject( pCurrentFilter, ppCachedFilters[dwNumFiltersExamended-1] ) );

    for( DWORD dwCurrentFilter = 0; dwCurrentFilter < dwNumFiltersRetrieved; dwCurrentFilter++ )
    {
        ppCachedFilters[dwCurrentFilter]->Release();
        ppCachedFilters[dwCurrentFilter] = NULL;
    }

    delete [] ppCachedFilters;
    ppCachedFilters = NULL;

    hr = pCloanedCachedFiltersEnum->Next( 1, aCurrentFilter, &dwNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        return hr;
    }

    DWORD dwAnotherNumFiltersRetrieved;
    IBaseFilter* aAnotherCurrentFilter[1];
    aAnotherCurrentFilter[0] = NULL;

    HRESULT hrAnother = pAnotherCloanedCachedFiltersEnum->Next( 1, aAnotherCurrentFilter, &dwAnotherNumFiltersRetrieved );
    if( FAILED( hr ) )
    {
        pCloanedCachedFiltersEnum->Release();
        pAnotherCloanedCachedFiltersEnum->Release();
        aCurrentFilter[0]->Release();
        return hr;
    }

    pCloanedCachedFiltersEnum->Release();
    pAnotherCloanedCachedFiltersEnum->Release();

    // Ensure the returned values are legal.
    ASSERT( (1 == dwAnotherNumFiltersRetrieved) || (0 == dwAnotherNumFiltersRetrieved) );
    ASSERT( (1 == dwNumFiltersRetrieved) || (0 == dwNumFiltersRetrieved) );
    ASSERT( ((hr == S_OK) && (1 == dwNumFiltersRetrieved)) ||
            ((hr == S_FALSE) && (0 == dwNumFiltersRetrieved)) );
    ASSERT( ((hrAnother == S_OK) && (1 == dwAnotherNumFiltersRetrieved)) ||
            ((hrAnother == S_FALSE) && (0 == dwAnotherNumFiltersRetrieved)) );

    // Since both enums should be in the exact same state, then every thing should be
    // equal.    
    ASSERT( hr == hrAnother );
    ASSERT( dwNumFiltersRetrieved == dwAnotherNumFiltersRetrieved );

    if( (1 == dwNumFiltersRetrieved) && (1 == dwAnotherNumFiltersRetrieved) )
    {
        ASSERT( ::IsEqualObject( aCurrentFilter[0], aAnotherCurrentFilter[0] ) );
    }

    if( S_OK == hr )
    {
        aCurrentFilter[0]->Release();
    }

    if( S_OK == hr )
    {
        aAnotherCurrentFilter[0]->Release();
    }

    return S_OK;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\dcf.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_)
#define AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CDisplayCachedFilters dialog

#define DCF_OUT_OF_MEMORY       -1;

class CFilterListBox;

class CDisplayCachedFilters : public CDialog
{
// Construction
public:
    CDisplayCachedFilters::CDisplayCachedFilters
        (
        IGraphConfig* pFilterCache,
        HRESULT* phr,
        CWnd* pParent = NULL
        );
    ~CDisplayCachedFilters();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDisplayCachedFilters)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CDisplayCachedFilters)
    virtual BOOL OnInitDialog();
    virtual void OnErrSpaceCachedFilters();
    afx_msg void OnRemoveFilter();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    HRESULT AddCachedFilterNamesToListBox( void );

    #ifdef _DEBUG
    static HRESULT IsCached( IGraphConfig* pFilterCache, IBaseFilter* pFilter );
    static HRESULT TestTheFilterCachesIEnumFiltersInterface( IEnumFilters* pCachedFiltersEnum, IBaseFilter* pCurrentFilter, DWORD dwNumFiltersExamended );
    #endif // _DEBUG

    IGraphConfig* m_pFilterCache;
    CFilterListBox* m_plbCachedFiltersList;

// Dialog Data
    //{{AFX_DATA(CDisplayCachedFilters)
    enum { IDD = IDD_CACHED_FILTERS };
    //}}AFX_DATA
};

#endif // !defined(AFX_DCF_H__845A3484_250D_11D3_A03B_006097DBEC02__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\filtervw.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// Dialog to display all filters
//

#include "stdafx.h"
#include "filtervw.h"

#define SHOWTYPES 1
#ifdef SHOWTYPES

#include <malloc.h>
#include <assert.h>
#include <streams.h>
#include <aviriff.h>
#ifdef COLORCODED_FILTERS
#include <dmodshow.h>
#endif
#endif
#include <initguid.h>
#include <dmoreg.h>

BEGIN_MESSAGE_MAP(CFilterView, CDialog)
    ON_NOTIFY(TVN_ITEMEXPANDING, IDC_FILTER_TREE, OnItemExpanding)
#ifdef COLORCODED_FILTERS
    ON_NOTIFY(NM_CUSTOMDRAW, IDC_FILTER_TREE, OnCustomDraw)
#endif
    ON_COMMAND(ID_ADDFILTER, OnInsert)
#ifdef FILTER_FAVORITES
    ON_COMMAND(ID_ADDTOFAV, OnAddToFav)
#endif
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
END_MESSAGE_MAP()

CFilterView* CFilterView::m_pThis = 0;
WNDPROC CFilterView::m_pfnOldDialogProc;

// list of categories in registry ActiveMovie might care about
static const TCHAR szRegCategoryPath[] = "ActiveMovie Filter Categories";

struct _EXTRA_CATEGORY {
    const GUID  * pclsid;
    const TCHAR * pszCat;
};

//
// Extra categories that we'd like to enumerate from GraphEdt...
//
// Please use this for categories that you'd like to see in GraphEdt but that don't
// need to be enumerated for default runtime graph building.
//
static const _EXTRA_CATEGORY g_AppEnumeratedCategories[] = 
{
        { &DMOCATEGORY_AUDIO_EFFECT,         TEXT("DMO Audio Effects") },
        { &DMOCATEGORY_AUDIO_CAPTURE_EFFECT, TEXT("DMO Audio Capture Effects") },
        { &DMOCATEGORY_VIDEO_EFFECT,         TEXT("DMO Video Effects") },
        // NULL entry needed to flag end
        { NULL,                              TEXT("") }
};


//
// Constructor
//
CFilterView::CFilterView(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)

 :
   m_pBoxNet(pBoxNet)
 , m_hImgList(NULL)
 , m_bHadInitDialog( FALSE )
{
    //
    // There can only be one filter view dialog at a time. Thus
    // the initialisation in the constructor is ok (even desired).
    //
    ASSERT( m_pThis == 0 );
    m_pThis = this;
    m_pfnOldDialogProc = NULL;
    Create(IDD_FILTER_VIEW, pParent);
    ShowWindow( SW_SHOW );
}

CFilterView::~CFilterView()
{
    // Windows will automatically delete m_hImgList when the dialog
    // box is destroyed.
    m_pThis = 0;
}

CFilterView * CFilterView::GetFilterView(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)
{
    if (!m_pThis)
    {
        m_pThis = new CFilterView(pBoxNet, pParent);
    }
    else
    {
    	if (pBoxNet->m_fRegistryChanged) {
    	    pBoxNet->m_fRegistryChanged = FALSE;
    	    m_pThis->RedoList();
	}
        m_pThis->ShowWindow( SW_RESTORE );
    }
    return m_pThis;

}

void CFilterView::DelFilterView()
{
    if (m_pThis)
    {
        delete m_pThis;
        m_pThis = 0;
    }
}

static LONG
TreeView_GetSelectedItemData(HWND hwndTV)
{
    HTREEITEM       hItem;
    TV_ITEM         tvItem;

    if(!(hItem = TreeView_GetSelection(hwndTV)))
        return -1;

    tvItem.mask = TVIF_PARAM;
    tvItem.hItem = hItem;
    TreeView_GetItem(hwndTV, &tvItem);

    return (LONG) tvItem.lParam;
}

void CFilterView::OnInsert()
{
    BOOL fAnySuccess = FALSE;
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);
    LONG iItem = TreeView_GetSelectedItemData(hWndTree);
    if(iItem >= 0)
    {
        POSITION pos = m_lMoniker.GetHeadPosition();
        while(pos != 0 && iItem-- > 0)
        {
            m_lMoniker.GetNext(pos);
        }
        if(pos)
        {

            IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd

            try {
                m_pBoxNet->CmdDo(new CCmdAddFilter( pMon, m_pBoxNet));

                fAnySuccess = TRUE;
            }
            catch (CHRESULTException hre) {
                // Give accurate information on each failed insertion
                DisplayQuartzError( IDS_CANTCREATEFILTER, hre.Reason() );
            }
        }
    }

    //
    // Change the text of the IDCANCEL button to "close" if we added at
    // least one filter.
    //
    if (fAnySuccess) {
        CString stClose;
        stClose.LoadString(IDS_CLOSE);

        ::SetDlgItemText(m_hWnd, IDCANCEL, stClose);
    }
}

#ifdef FILTER_FAVORITES

extern const TCHAR *g_szRegFav;

HRESULT AddFavToReg(const TCHAR *szFilter, const TCHAR *szMonikerName)
{
    HKEY hk;
    LONG lResult = RegCreateKeyEx(
        HKEY_CURRENT_USER,
        g_szRegFav,
        0,                      // reserved
        0,                      // class string
        0,                      // options
        KEY_WRITE,
        0,                      // security
        &hk,
        0);                     // disposition
    if(lResult == ERROR_SUCCESS)
    {
        lResult = RegSetValueEx(
            hk,
            szFilter,
            0,                  // reserved
            REG_SZ,
            (BYTE *)szMonikerName,
            sizeof(TCHAR) * (lstrlen(szMonikerName) + 1));

        RegCloseKey(hk);
    }

    return S_OK;
}

void CFilterView::OnAddToFav()
{
    BOOL fAnySuccess = FALSE;
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);
    LONG iItem = TreeView_GetSelectedItemData(hWndTree);
    if(iItem >= 0)
    {
        POSITION pos = m_lMoniker.GetHeadPosition();
        while(pos != 0 && iItem-- > 0)
        {
            m_lMoniker.GetNext(pos);
        }
        if(pos)
        {

            IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd

            WCHAR *wszDisplayName;
            HRESULT hr= pMon->GetDisplayName(0, 0, &wszDisplayName);
            if(SUCCEEDED(hr))
            {

                CComVariant var;

                IPropertyBag *pPropBag;
                hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    hr = pPropBag->Read(L"FriendlyName", &var, 0);
                    if(FAILED(hr )) {
                        printf("failed to get FriendlyName: %08x\n", hr);
                    }

                    pPropBag->Release();
                }

                if(SUCCEEDED(hr))
                {
                    CString szFilterName(var.bstrVal);
                    CString szDisplayName(wszDisplayName);

                    AddFavToReg(szFilterName, szDisplayName);
                }


                CoTaskMemFree(wszDisplayName);
            }


            if(FAILED(hr)) {
                DisplayQuartzError( IDS_CANTCREATEFILTER, CHRESULTException(hr).Reason() );
            }
        }
    }
}

#endif


BOOL CFilterView::OnInitDialog()
{
    BOOL fResult = CDialog::OnInitDialog();

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);

    // Subclass the tree view so we can handle double clicks.
    m_pfnOldDialogProc = (WNDPROC)
        ::SetWindowLongPtr(hWndTree, GWLP_WNDPROC, (LONG_PTR) DialogProc);

    //
    // Create the image list for the list view
    //
    m_hImgList = ImageList_Create(
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
        ILC_COLOR, 1, 1);

    ASSERT(m_hImgList);

    HICON hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_FILTER));
    m_iIcon = ImageList_AddIcon(m_hImgList, hIcon);

//     ::SendMessage(hWndTree, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) m_hImgList);

    RedoList();

    return( fResult );
}

#ifdef SHOWTYPES

#define CNV_GUID(clsid) GuidToEnglish((clsid), (char *)_alloca(1024))

struct NamedGuid
{
    const GUID *pguid;
    const char *psz;
};

static const NamedGuid rgng[] =
{
    {&AMPROPSETID_Pin, "AMPROPSETID_Pin"},
    {&AM_INTERFACESETID_Standard, "AM_INTERFACESETID_Standard"},
    {&AM_KSCATEGORY_AUDIO, "AM_KSCATEGORY_AUDIO"},
    {&AM_KSCATEGORY_CAPTURE, "AM_KSCATEGORY_CAPTURE"},
    {&AM_KSCATEGORY_CROSSBAR, "AM_KSCATEGORY_CROSSBAR"},
    {&AM_KSCATEGORY_DATACOMPRESSOR, "AM_KSCATEGORY_DATACOMPRESSOR"},
    {&AM_KSCATEGORY_RENDER, "AM_KSCATEGORY_RENDER"},
    {&AM_KSCATEGORY_TVAUDIO, "AM_KSCATEGORY_TVAUDIO"},
    {&AM_KSCATEGORY_TVTUNER, "AM_KSCATEGORY_TVTUNER"},
    {&AM_KSCATEGORY_VIDEO, "AM_KSCATEGORY_VIDEO"},
    {&AM_KSPROPSETID_AC3, "AM_KSPROPSETID_AC3"},
    {&AM_KSPROPSETID_CopyProt, "AM_KSPROPSETID_CopyProt"},
    {&AM_KSPROPSETID_DvdSubPic, "AM_KSPROPSETID_DvdSubPic"},
    {&AM_KSPROPSETID_TSRateChange, "AM_KSPROPSETID_TSRateChange"},
    {&CLSID_ACMWrapper, "CLSID_ACMWrapper"},
    {&CLSID_AVICo, "CLSID_AVICo"},
    {&CLSID_AVIDec, "CLSID_AVIDec"},
    {&CLSID_AVIDoc, "CLSID_AVIDoc"},
    {&CLSID_AVIDraw, "CLSID_AVIDraw"},
    {&CLSID_AVIMIDIRender, "CLSID_AVIMIDIRender"},
    {&CLSID_ActiveMovieCategories, "CLSID_ActiveMovieCategories"},
    {&CLSID_AnalogVideoDecoderPropertyPage, "CLSID_AnalogVideoDecoderPropertyPage"},
    {&CLSID_WMAsfReader, "CLSID_WMAsfReader"},
    {&CLSID_WMAsfWriter, "CLSID_WMAsfWriter"},
    {&CLSID_AsyncReader, "CLSID_AsyncReader"},
    {&CLSID_AudioCompressorCategory, "CLSID_AudioCompressorCategory"},
    {&CLSID_AudioInputDeviceCategory, "CLSID_AudioInputDeviceCategory"},
    {&CLSID_AudioProperties, "CLSID_AudioProperties"},
    {&CLSID_AudioRecord, "CLSID_AudioRecord"},
    {&CLSID_AudioRender, "CLSID_AudioRender"},
    {&CLSID_AudioRendererCategory, "CLSID_AudioRendererCategory"},
    {&CLSID_AviDest, "CLSID_AviDest"},
    {&CLSID_AviMuxProptyPage, "CLSID_AviMuxProptyPage"},
    {&CLSID_AviMuxProptyPage1, "CLSID_AviMuxProptyPage1"},
    {&CLSID_AviReader, "CLSID_AviReader"},
    {&CLSID_AviSplitter, "CLSID_AviSplitter"},
    {&CLSID_CAcmCoClassManager, "CLSID_CAcmCoClassManager"},
    {&CLSID_CDeviceMoniker, "CLSID_CDeviceMoniker"},
    {&CLSID_CIcmCoClassManager, "CLSID_CIcmCoClassManager"},
    {&CLSID_CMidiOutClassManager, "CLSID_CMidiOutClassManager"},
    {&CLSID_CMpegAudioCodec, "CLSID_CMpegAudioCodec"},
    {&CLSID_CMpegVideoCodec, "CLSID_CMpegVideoCodec"},
    {&CLSID_CQzFilterClassManager, "CLSID_CQzFilterClassManager"},
    {&CLSID_CVidCapClassManager, "CLSID_CVidCapClassManager"},
    {&CLSID_CWaveOutClassManager, "CLSID_CWaveOutClassManager"},
    {&CLSID_CWaveinClassManager, "CLSID_CWaveinClassManager"},
    {&CLSID_CameraControlPropertyPage, "CLSID_CameraControlPropertyPage"},
    {&CLSID_CaptureGraphBuilder, "CLSID_CaptureGraphBuilder"},
    {&CLSID_CaptureProperties, "CLSID_CaptureProperties"},
    {&CLSID_Colour, "CLSID_Colour"},
    {&CLSID_CrossbarFilterPropertyPage, "CLSID_CrossbarFilterPropertyPage"},
    {&CLSID_DSoundRender, "CLSID_DSoundRender"},
    {&CLSID_DVDHWDecodersCategory, "CLSID_DVDHWDecodersCategory"},
    {&CLSID_DVDNavigator, "CLSID_DVDNavigator"},
    {&CLSID_DVDecPropertiesPage, "CLSID_DVDecPropertiesPage"},
    {&CLSID_DVEncPropertiesPage, "CLSID_DVEncPropertiesPage"},
    {&CLSID_DVMux, "CLSID_DVMux"},
    {&CLSID_DVMuxPropertyPage, "CLSID_DVMuxPropertyPage"},
    {&CLSID_DVSplitter, "CLSID_DVSplitter"},
    {&CLSID_DVVideoCodec, "CLSID_DVVideoCodec"},
    {&CLSID_DVVideoEnc, "CLSID_DVVideoEnc"},
    {&CLSID_DirectDraw, "CLSID_DirectDraw"},
    {&CLSID_DirectDrawClipper, "CLSID_DirectDrawClipper"},
    {&CLSID_DirectDrawProperties, "CLSID_DirectDrawProperties"},
    {&CLSID_Dither, "CLSID_Dither"},
    {&CLSID_DvdGraphBuilder, "CLSID_DvdGraphBuilder"},
    {&CLSID_FGControl, "CLSID_FGControl"},
    {&CLSID_FileSource, "CLSID_FileSource"},
    {&CLSID_FileWriter, "CLSID_FileWriter"},
    {&CLSID_FilterGraph, "CLSID_FilterGraph"},
    {&CLSID_FilterGraphNoThread, "CLSID_FilterGraphNoThread"},
    {&CLSID_FilterMapper, "CLSID_FilterMapper"},
    {&CLSID_FilterMapper2, "CLSID_FilterMapper2"},
    {&CLSID_InfTee, "CLSID_InfTee"},
    {&CLSID_LegacyAmFilterCategory, "CLSID_LegacyAmFilterCategory"},
    {&CLSID_Line21Decoder, "CLSID_Line21Decoder"},
    {&CLSID_MOVReader, "CLSID_MOVReader"},
    {&CLSID_MPEG1Doc, "CLSID_MPEG1Doc"},
    {&CLSID_MPEG1PacketPlayer, "CLSID_MPEG1PacketPlayer"},
    {&CLSID_MPEG1Splitter, "CLSID_MPEG1Splitter"},
    {&CLSID_MediaPropertyBag, "CLSID_MediaPropertyBag"},
    {&CLSID_MemoryAllocator, "CLSID_MemoryAllocator"},
    {&CLSID_MidiRendererCategory, "CLSID_MidiRendererCategory"},
    {&CLSID_ModexProperties, "CLSID_ModexProperties"},
    {&CLSID_ModexRenderer, "CLSID_ModexRenderer"},
    {&CLSID_OverlayMixer, "CLSID_OverlayMixer"},
    {&CLSID_PerformanceProperties, "CLSID_PerformanceProperties"},
    {&CLSID_PersistMonikerPID, "CLSID_PersistMonikerPID"},
    {&CLSID_ProtoFilterGraph, "CLSID_ProtoFilterGraph"},
    {&CLSID_QualityProperties, "CLSID_QualityProperties"},
    {&CLSID_SeekingPassThru, "CLSID_SeekingPassThru"},
    {&CLSID_SmartTee, "CLSID_SmartTee"},
    {&CLSID_SystemClock, "CLSID_SystemClock"},
    {&CLSID_SystemDeviceEnum, "CLSID_SystemDeviceEnum"},
    {&CLSID_TVAudioFilterPropertyPage, "CLSID_TVAudioFilterPropertyPage"},
    {&CLSID_TVTunerFilterPropertyPage, "CLSID_TVTunerFilterPropertyPage"},
    {&CLSID_TextRender, "CLSID_TextRender"},
    {&CLSID_URLReader, "CLSID_URLReader"},
    {&CLSID_VBISurfaces, "CLSID_VBISurfaces"},
    {&CLSID_VPObject, "CLSID_VPObject"},
    {&CLSID_VPVBIObject, "CLSID_VPVBIObject"},
    {&CLSID_VfwCapture, "CLSID_VfwCapture"},
    {&CLSID_VideoCompressorCategory, "CLSID_VideoCompressorCategory"},
    {&CLSID_VideoInputDeviceCategory, "CLSID_VideoInputDeviceCategory"},
    {&CLSID_VideoProcAmpPropertyPage, "CLSID_VideoProcAmpPropertyPage"},
    {&CLSID_VideoRenderer, "CLSID_VideoRenderer"},
    {&CLSID_VideoStreamConfigPropertyPage, "CLSID_VideoStreamConfigPropertyPage"},
    {&FORMAT_AnalogVideo, "FORMAT_AnalogVideo"},
    {&FORMAT_DVD_LPCMAudio, "FORMAT_DVD_LPCMAudio"},
    {&FORMAT_DolbyAC3, "FORMAT_DolbyAC3"},
    {&FORMAT_DvInfo, "FORMAT_DvInfo"},
    {&FORMAT_MPEG2Audio, "FORMAT_MPEG2Audio"},
    {&FORMAT_MPEG2Video, "FORMAT_MPEG2Video"},
    {&FORMAT_MPEG2_VIDEO, "FORMAT_MPEG2_VIDEO"},
    {&FORMAT_MPEGStreams, "FORMAT_MPEGStreams"},
    {&FORMAT_MPEGVideo, "FORMAT_MPEGVideo"},
    {&FORMAT_None, "FORMAT_None"},
    {&FORMAT_VIDEOINFO2, "FORMAT_VIDEOINFO2"},
    {&FORMAT_VideoInfo, "FORMAT_VideoInfo"},
    {&FORMAT_VideoInfo2, "FORMAT_VideoInfo2"},
    {&FORMAT_WaveFormatEx, "FORMAT_WaveFormatEx"},
    {&IID_IAMDirectSound, "IID_IAMDirectSound"},
    {&IID_IAMLine21Decoder, "IID_IAMLine21Decoder"},
    {&IID_IBaseVideoMixer, "IID_IBaseVideoMixer"},
    {&IID_IDDVideoPortContainer, "IID_IDDVideoPortContainer"},
    {&IID_IDirectDraw, "IID_IDirectDraw"},
    {&IID_IDirectDraw2, "IID_IDirectDraw2"},
    {&IID_IDirectDrawClipper, "IID_IDirectDrawClipper"},
    {&IID_IDirectDrawColorControl, "IID_IDirectDrawColorControl"},
    {&IID_IDirectDrawKernel, "IID_IDirectDrawKernel"},
    {&IID_IDirectDrawPalette, "IID_IDirectDrawPalette"},
    {&IID_IDirectDrawSurface, "IID_IDirectDrawSurface"},
    {&IID_IDirectDrawSurface2, "IID_IDirectDrawSurface2"},
    {&IID_IDirectDrawSurface3, "IID_IDirectDrawSurface3"},
    {&IID_IDirectDrawSurfaceKernel, "IID_IDirectDrawSurfaceKernel"},
    {&IID_IDirectDrawVideo, "IID_IDirectDrawVideo"},
    {&IID_IFullScreenVideo, "IID_IFullScreenVideo"},
    {&IID_IFullScreenVideoEx, "IID_IFullScreenVideoEx"},
    {&IID_IKsDataTypeHandler, "IID_IKsDataTypeHandler"},
    {&IID_IKsInterfaceHandler, "IID_IKsInterfaceHandler"},
    {&IID_IKsPin, "IID_IKsPin"},
    {&IID_IMixerPinConfig, "IID_IMixerPinConfig"},
    {&IID_IMixerPinConfig2, "IID_IMixerPinConfig2"},
    {&IID_IMpegAudioDecoder, "IID_IMpegAudioDecoder"},
    {&IID_IQualProp, "IID_IQualProp"},
    {&IID_IVPConfig, "IID_IVPConfig"},
    {&IID_IVPControl, "IID_IVPControl"},
    {&IID_IVPNotify, "IID_IVPNotify"},
    {&IID_IVPNotify2, "IID_IVPNotify2"},
    {&IID_IVPObject, "IID_IVPObject"},
    {&IID_IVPVBIConfig, "IID_IVPVBIConfig"},
    {&IID_IVPVBINotify, "IID_IVPVBINotify"},
    {&IID_IVPVBIObject, "IID_IVPVBIObject"},
    {&LOOK_DOWNSTREAM_ONLY, "LOOK_DOWNSTREAM_ONLY"},
    {&LOOK_UPSTREAM_ONLY, "LOOK_UPSTREAM_ONLY"},
    {&MEDIASUBTYPE_AIFF, "MEDIASUBTYPE_AIFF"},
    {&MEDIASUBTYPE_AU, "MEDIASUBTYPE_AU"},
    {&MEDIASUBTYPE_AnalogVideo_NTSC_M, "MEDIASUBTYPE_AnalogVideo_NTSC_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_B, "MEDIASUBTYPE_AnalogVideo_PAL_B"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_D, "MEDIASUBTYPE_AnalogVideo_PAL_D"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_G, "MEDIASUBTYPE_AnalogVideo_PAL_G"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_H, "MEDIASUBTYPE_AnalogVideo_PAL_H"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_I, "MEDIASUBTYPE_AnalogVideo_PAL_I"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_M, "MEDIASUBTYPE_AnalogVideo_PAL_M"},
    {&MEDIASUBTYPE_AnalogVideo_PAL_N, "MEDIASUBTYPE_AnalogVideo_PAL_N"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_B, "MEDIASUBTYPE_AnalogVideo_SECAM_B"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_D, "MEDIASUBTYPE_AnalogVideo_SECAM_D"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_G, "MEDIASUBTYPE_AnalogVideo_SECAM_G"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_H, "MEDIASUBTYPE_AnalogVideo_SECAM_H"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K, "MEDIASUBTYPE_AnalogVideo_SECAM_K"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_K1, "MEDIASUBTYPE_AnalogVideo_SECAM_K1"},
    {&MEDIASUBTYPE_AnalogVideo_SECAM_L, "MEDIASUBTYPE_AnalogVideo_SECAM_L"},
    {&MEDIASUBTYPE_Asf, "MEDIASUBTYPE_Asf"},
    {&MEDIASUBTYPE_Avi, "MEDIASUBTYPE_Avi"},
    {&MEDIASUBTYPE_CFCC, "MEDIASUBTYPE_CFCC"},
    {&MEDIASUBTYPE_CLJR, "MEDIASUBTYPE_CLJR"},
    {&MEDIASUBTYPE_CPLA, "MEDIASUBTYPE_CPLA"},
    {&MEDIASUBTYPE_DOLBY_AC3, "MEDIASUBTYPE_DOLBY_AC3"},
    {&MEDIASUBTYPE_DVCS, "MEDIASUBTYPE_DVCS"},
    {&MEDIASUBTYPE_DVD_LPCM_AUDIO, "MEDIASUBTYPE_DVD_LPCM_AUDIO"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_DSI, "MEDIASUBTYPE_DVD_NAVIGATION_DSI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PCI, "MEDIASUBTYPE_DVD_NAVIGATION_PCI"},
    {&MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER, "MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER"},
    {&MEDIASUBTYPE_DVD_SUBPICTURE, "MEDIASUBTYPE_DVD_SUBPICTURE"},
    {&MEDIASUBTYPE_DVSD, "MEDIASUBTYPE_DVSD"},
    {&MEDIASUBTYPE_DssAudio, "MEDIASUBTYPE_DssAudio"},
    {&MEDIASUBTYPE_DssVideo, "MEDIASUBTYPE_DssVideo"},
    {&MEDIASUBTYPE_IF09, "MEDIASUBTYPE_IF09"},
    {&MEDIASUBTYPE_IJPG, "MEDIASUBTYPE_IJPG"},
    {&MEDIASUBTYPE_Line21_BytePair, "MEDIASUBTYPE_Line21_BytePair"},
    {&MEDIASUBTYPE_Line21_GOPPacket, "MEDIASUBTYPE_Line21_GOPPacket"},
    {&MEDIASUBTYPE_Line21_VBIRawData, "MEDIASUBTYPE_Line21_VBIRawData"},
    {&MEDIASUBTYPE_MDVF, "MEDIASUBTYPE_MDVF"},
    {&MEDIASUBTYPE_MJPG, "MEDIASUBTYPE_MJPG"},
    {&MEDIASUBTYPE_MPEG1Audio, "MEDIASUBTYPE_MPEG1Audio"},
    {&MEDIASUBTYPE_MPEG1AudioPayload, "MEDIASUBTYPE_MPEG1AudioPayload"},
    {&MEDIASUBTYPE_MPEG1Packet, "MEDIASUBTYPE_MPEG1Packet"},
    {&MEDIASUBTYPE_MPEG1Payload, "MEDIASUBTYPE_MPEG1Payload"},
    {&MEDIASUBTYPE_MPEG1System, "MEDIASUBTYPE_MPEG1System"},
    {&MEDIASUBTYPE_MPEG1Video, "MEDIASUBTYPE_MPEG1Video"},
    {&MEDIASUBTYPE_MPEG1VideoCD, "MEDIASUBTYPE_MPEG1VideoCD"},
    {&MEDIASUBTYPE_MPEG2_AUDIO, "MEDIASUBTYPE_MPEG2_AUDIO"},
    {&MEDIASUBTYPE_MPEG2_PROGRAM, "MEDIASUBTYPE_MPEG2_PROGRAM"},
    {&MEDIASUBTYPE_MPEG2_TRANSPORT, "MEDIASUBTYPE_MPEG2_TRANSPORT"},
    {&MEDIASUBTYPE_MPEG2_VIDEO, "MEDIASUBTYPE_MPEG2_VIDEO"},
    {&MEDIASUBTYPE_None, "MEDIASUBTYPE_None"},
    {&MEDIASUBTYPE_Overlay, "MEDIASUBTYPE_Overlay"},
    {&MEDIASUBTYPE_PCM, "MEDIASUBTYPE_PCM"},
    {&MEDIASUBTYPE_PCMAudio_Obsolete, "MEDIASUBTYPE_PCMAudio_Obsolete"},
    {&MEDIASUBTYPE_Plum, "MEDIASUBTYPE_Plum"},
    {&MEDIASUBTYPE_QTJpeg, "MEDIASUBTYPE_QTJpeg"},
    {&MEDIASUBTYPE_QTMovie, "MEDIASUBTYPE_QTMovie"},
    {&MEDIASUBTYPE_QTRle, "MEDIASUBTYPE_QTRle"},
    {&MEDIASUBTYPE_QTRpza, "MEDIASUBTYPE_QTRpza"},
    {&MEDIASUBTYPE_QTSmc, "MEDIASUBTYPE_QTSmc"},
    {&MEDIASUBTYPE_RGB1, "MEDIASUBTYPE_RGB1"},
    {&MEDIASUBTYPE_RGB24, "MEDIASUBTYPE_RGB24"},
    {&MEDIASUBTYPE_RGB32, "MEDIASUBTYPE_RGB32"},
    {&MEDIASUBTYPE_RGB4, "MEDIASUBTYPE_RGB4"},
    {&MEDIASUBTYPE_RGB555, "MEDIASUBTYPE_RGB555"},
    {&MEDIASUBTYPE_RGB565, "MEDIASUBTYPE_RGB565"},
    {&MEDIASUBTYPE_RGB8, "MEDIASUBTYPE_RGB8"},
    {&MEDIASUBTYPE_TVMJ, "MEDIASUBTYPE_TVMJ"},
    {&MEDIASUBTYPE_UYVY, "MEDIASUBTYPE_UYVY"},
    {&MEDIASUBTYPE_VPVBI, "MEDIASUBTYPE_VPVBI"},
    {&MEDIASUBTYPE_VPVideo, "MEDIASUBTYPE_VPVideo"},
    {&MEDIASUBTYPE_WAKE, "MEDIASUBTYPE_WAKE"},
    {&MEDIASUBTYPE_WAVE, "MEDIASUBTYPE_WAVE"},
    {&MEDIASUBTYPE_Y211, "MEDIASUBTYPE_Y211"},
    {&MEDIASUBTYPE_Y411, "MEDIASUBTYPE_Y411"},
    {&MEDIASUBTYPE_Y41P, "MEDIASUBTYPE_Y41P"},
    {&MEDIASUBTYPE_YUY2, "MEDIASUBTYPE_YUY2"},
    {&MEDIASUBTYPE_YV12, "MEDIASUBTYPE_YV12"},
    {&MEDIASUBTYPE_YVU9, "MEDIASUBTYPE_YVU9"},
    {&MEDIASUBTYPE_YVYU, "MEDIASUBTYPE_YVYU"},
    {&MEDIASUBTYPE_dvhd, "MEDIASUBTYPE_dvhd"},
    {&MEDIASUBTYPE_dvsd, "MEDIASUBTYPE_dvsd"},
    {&MEDIASUBTYPE_dvsl, "MEDIASUBTYPE_dvsl"},
    {&MEDIATYPE_AUXLine21Data, "MEDIATYPE_AUXLine21Data"},
    {&MEDIATYPE_AnalogAudio, "MEDIATYPE_AnalogAudio"},
    {&MEDIATYPE_AnalogVideo, "MEDIATYPE_AnalogVideo"},
    {&MEDIATYPE_Audio, "MEDIATYPE_Audio"},
    {&MEDIATYPE_DVD_ENCRYPTED_PACK, "MEDIATYPE_DVD_ENCRYPTED_PACK"},
    {&MEDIATYPE_DVD_NAVIGATION, "MEDIATYPE_DVD_NAVIGATION"},
    {&MEDIATYPE_File, "MEDIATYPE_File"},
    {&MEDIATYPE_Interleaved, "MEDIATYPE_Interleaved"},
    {&MEDIATYPE_LMRT, "MEDIATYPE_LMRT"},
    {&MEDIATYPE_MPEG1SystemStream, "MEDIATYPE_MPEG1SystemStream"},
    {&MEDIATYPE_MPEG2_PES, "MEDIATYPE_MPEG2_PES"},
    {&MEDIATYPE_Midi, "MEDIATYPE_Midi"},
    {&MEDIATYPE_ScriptCommand, "MEDIATYPE_ScriptCommand"},
    {&MEDIATYPE_Stream, "MEDIATYPE_Stream"},
    {&MEDIATYPE_Text, "MEDIATYPE_Text"},
    {&MEDIATYPE_Timecode, "MEDIATYPE_Timecode"},
    {&MEDIATYPE_URL_STREAM, "MEDIATYPE_URL_STREAM"},
    {&MEDIATYPE_Video, "MEDIATYPE_Video"},
    {&PIN_CATEGORY_ANALOGVIDEOIN, "PIN_CATEGORY_ANALOGVIDEOIN"},
    {&PIN_CATEGORY_CAPTURE, "PIN_CATEGORY_CAPTURE"},
    {&PIN_CATEGORY_CC, "PIN_CATEGORY_CC"},
    {&PIN_CATEGORY_EDS, "PIN_CATEGORY_EDS"},
    {&PIN_CATEGORY_NABTS, "PIN_CATEGORY_NABTS"},
    {&PIN_CATEGORY_PREVIEW, "PIN_CATEGORY_PREVIEW"},
    {&PIN_CATEGORY_STILL, "PIN_CATEGORY_STILL"},
    {&PIN_CATEGORY_TELETEXT, "PIN_CATEGORY_TELETEXT"},
    {&PIN_CATEGORY_TIMECODE, "PIN_CATEGORY_TIMECODE"},
    {&PIN_CATEGORY_VBI, "PIN_CATEGORY_VBI"},
    {&PIN_CATEGORY_VIDEOPORT, "PIN_CATEGORY_VIDEOPORT"},
    {&PIN_CATEGORY_VIDEOPORT_VBI, "PIN_CATEGORY_VIDEOPORT_VBI"},
    {&TIME_FORMAT_BYTE, "TIME_FORMAT_BYTE"},
    {&TIME_FORMAT_FIELD, "TIME_FORMAT_FIELD"},
    {&TIME_FORMAT_FRAME, "TIME_FORMAT_FRAME"},
    {&TIME_FORMAT_MEDIA_TIME, "TIME_FORMAT_MEDIA_TIME"},
    {&TIME_FORMAT_NONE, "TIME_FORMAT_NONE"},
    {&TIME_FORMAT_SAMPLE, "TIME_FORMAT_SAMPLE"},
};

char * GuidToEnglish(const CLSID *const pclsid, char *buf)
{
    WCHAR szGuid[39];
    StringFromGUID2(pclsid ? *pclsid : GUID_NULL, szGuid, 39);

    if(pclsid == 0)
    {
        wsprintf(buf, "%S", szGuid);
        return buf;
    }

    for(int i = 0; i < NUMELMS(rgng); i++)
    {
        if(*pclsid == *(rgng[i].pguid))
        {
            wsprintf(buf, "%s %S", rgng[i].psz, szGuid);
            return buf;
        }
    }
    if(FOURCCMap(pclsid->Data1) == *pclsid)
    {
        if(pclsid->Data1 > 0xffff)
        {
            wsprintf(buf, "fourcc (%08x) %c%c%c%c %S",
                     pclsid->Data1,
                     ((char *)pclsid)[0],
                     ((char *)pclsid)[1],
                     ((char *)pclsid)[2],
                     ((char *)pclsid)[3],
                     szGuid);
        }
        else
        {
            wsprintf(buf, "fourcc (%08x) %S",
                     pclsid->Data1,
                     szGuid);
        }
        return buf;
    }
    else
    {
        wsprintf(buf, "(%S)", szGuid);
        return buf;
    }

}

#include "fil_data.h"
#include "fil_data_i.c"
void DoFilterInfo(HWND hWndTree, HTREEITEM hti, IMoniker *pMon, IAMFilterData *pafd)
{

    HRESULT hr;
    LONG lRc;

    IPropertyBag *pPropBag;
    hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
    if(SUCCEEDED(hr))
    {

        VARIANT varFilData;
        varFilData.vt = VT_UI1 | VT_ARRAY;
        varFilData.parray = 0; // docs say zero this

        BYTE *pbFilterData = 0; // 0 if not read
        DWORD dwcbFilterDAta = 0; // 0 if not read
        hr = pPropBag->Read(L"FilterData", &varFilData, 0);
        if(SUCCEEDED(hr))
        {
            ASSERT(varFilData.vt == (VT_UI1 | VT_ARRAY));
            dwcbFilterDAta = varFilData.parray->rgsabound[0].cElements;

            HRESULT hrTmp = SafeArrayAccessData(varFilData.parray, (void **)&pbFilterData);
            ASSERT(hrTmp == S_OK);

            // used to determine whether to free varFilData
            ASSERT(pbFilterData);
        }
        else
        {
            ASSERT(dwcbFilterDAta == 0 && pbFilterData == 0);
        }


        if(SUCCEEDED(hr))
        {

            BYTE *pb;
            hr = pafd->ParseFilterData(pbFilterData, dwcbFilterDAta, &pb);
            if(SUCCEEDED(hr))
            {
                REGFILTER2 *pFil = ((REGFILTER2 **)pb)[0];

                if(pbFilterData)
                {
                    HRESULT hrTmp = SafeArrayUnaccessData(varFilData.parray);
                    ASSERT(hrTmp == S_OK);

                    hrTmp = VariantClear(&varFilData);
                    ASSERT(hrTmp == S_OK);
                }
                ASSERT(pFil->dwVersion == 2);

                char szTxt[1024];
                wsprintf(szTxt, "Merit: %08x", pFil->dwMerit);

                TV_INSERTSTRUCT tvis;
                tvis.hParent = hti;
                tvis.hInsertAfter = TVI_SORT;
                tvis.item.pszText = szTxt;
                tvis.item.lParam = -1;
                tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

                //TreeView_InsertItem(hWndTree, &tvis);
                HTREEITEM htiMerit = (HTREEITEM)::SendMessage(
                    hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));


                wsprintf(szTxt, "Version: %d", pFil->dwVersion);

                HTREEITEM htiVersion = (HTREEITEM)::SendMessage(
                    hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                WCHAR *wszName;
                if(pMon->GetDisplayName(0, 0, &wszName) == S_OK)
                {

                    wsprintf(szTxt, "DisplayName: %S", wszName);

                    HTREEITEM htiVersion = (HTREEITEM)::SendMessage(
                        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    CoTaskMemFree(wszName);
                }

                //
                // Display the filter's filename
                //
                //            
                // Read filter's CLSID from property bag.  This CLSID string will be
                // used to find the filter's filename in the registry.
                VARIANT varFilterClsid;
                varFilterClsid.vt = VT_BSTR;

                hr = pPropBag->Read(L"CLSID", &varFilterClsid, 0);
                if(SUCCEEDED(hr))
                {
                    TCHAR szKey[512];

                    // Convert BSTR to string and free variant storage
                    CString strQuery(varFilterClsid.bstrVal);
                    SysFreeString(varFilterClsid.bstrVal);

                    // Create key name for reading filename registry
                    wsprintf(szKey, TEXT("Software\\Classes\\CLSID\\%s\\InprocServer32\0"),
                             strQuery);

                    // Variables needed for registry query
                    HKEY hkeyFilter=0;
                    DWORD dwSize=MAX_PATH;
                    BYTE szFilename[MAX_PATH];
                    int rc=0;

                    // Open the CLSID key that contains information about the filter
                    rc = RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hkeyFilter);
                    if (rc == ERROR_SUCCESS)
                    {
                        rc = RegQueryValueEx(hkeyFilter, NULL,  // Read (Default) value
                                             NULL, NULL, szFilename, &dwSize);

                        if (rc == ERROR_SUCCESS)
                        {
                            // Add filename string to tree node
                            wsprintf(szTxt, "Filename: %s", szFilename);

                            HTREEITEM htiFilename = (HTREEITEM)::SendMessage(
                                hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
                        }

                        rc = RegCloseKey(hkeyFilter);
                    }
                }
       

                for(UINT iPin = 0; iPin < pFil->cPins; iPin++)
                {
                    wsprintf(szTxt, "pin %02d:", iPin);

                    tvis.hParent = hti;

                    HTREEITEM htiPin = (HTREEITEM)::SendMessage(
                        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    tvis.hParent = htiPin;

                    wsprintf(szTxt, "bRendered: %d ", !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_RENDERER));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bOutput: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_OUTPUT));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bMany: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_MANY));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    wsprintf(szTxt, "bZero: %d ",  !!(pFil->rgPins2[iPin].dwFlags & REG_PINFLAG_B_ZERO));
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    WCHAR szGuid[39];
                    StringFromGUID2(pFil->rgPins2[iPin].clsPinCategory ? *pFil->rgPins2[iPin].clsPinCategory : GUID_NULL, szGuid, 39);
                    wsprintf(szTxt, "ClsPinCategory: %S ", szGuid );
                    ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    for(UINT iType = 0; iType < pFil->rgPins2[iPin].nMediaTypes; iType++)
                    {
                        tvis.hParent = htiPin;
                        wsprintf(szTxt, "type %02d", iType);
                        HTREEITEM htiType = (HTREEITEM)::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        tvis.hParent = htiType;

                        wsprintf(szTxt, "major type: %s", CNV_GUID(pFil->rgPins2[iPin].lpMediaType[iType].clsMajorType));
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        wsprintf(szTxt, "subtype: %s", CNV_GUID(pFil->rgPins2[iPin].lpMediaType[iType].clsMinorType));
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    }

                    for(UINT iMed = 0; iMed < pFil->rgPins2[iPin].nMediums; iMed++)
                    {
                        tvis.hParent = htiPin;
                        wsprintf(szTxt, "Medium %02d", iMed);
                        HTREEITEM htiType = (HTREEITEM)::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        tvis.hParent = htiType;
                        WCHAR szGuid[39];

                        StringFromGUID2(pFil->rgPins2[iPin].lpMedium[iMed].clsMedium, szGuid, 39);
                        wsprintf(szTxt, "medium clsid: %S", szGuid);
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                        wsprintf(szTxt, "Data1 Data2: %08x %08x", pFil->rgPins2[iPin].lpMedium[iMed].dw1, pFil->rgPins2[iPin].lpMedium[iMed].dw2);
                        ::SendMessage(hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

                    }
                }

                CoTaskMemFree((BYTE *)pFil);
                lRc = ERROR_SUCCESS;
            }
        }

        pPropBag->Release();
    }
}

#endif // SHOWTYPES

void CFilterView::DoOneCategory(
    const TCHAR *szCatDesc,
    HWND hWndTree,
    const GUID *pCatGuid,
    ICreateDevEnum *pCreateDevEnum)
{

    // !!! leaked.
    CLSID *pclsid = new CLSID;
    *pclsid = *pCatGuid;

    // enumerator returns S_FALSE if the category is empty
    TV_INSERTSTRUCT tvis;
    tvis.hParent = TVI_ROOT;
    tvis.hInsertAfter = TVI_SORT ;
    tvis.item.pszText = (char *)szCatDesc; // !!! can be wide
    tvis.item.lParam = (DWORD_PTR)pclsid;
    tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

    //TreeView_InsertItem(hWndTree, &tvis);
    HTREEITEM htiParent = (HTREEITEM)::SendMessage(
        hWndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));

    {

        TV_INSERTSTRUCT tvis;
        tvis.hParent = htiParent;
        tvis.hInsertAfter = TVI_SORT;
        tvis.item.pszText = "dummy";
        tvis.item.lParam = 0;
        tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

        //TreeView_InsertItem(hWndTree, &tvis);
        HTREEITEM htx = (HTREEITEM)::SendMessage((hWndTree), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
    }

    return;
}

void CFilterView::RedoList()
{
    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);
    ASSERT(hWndTree);

    m_lMoniker.DeleteRemoveAll();

    //
    // Add all filters to the list view
    //
    //TreeView_DeleteAllItems(hWndTree);
    ::SendMessage((hWndTree), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);

    //
    //
    //
    ICreateDevEnum *pCreateDevEnum;

    HRESULT hr;

    // !!! try getting mapper from graph instead of fresh....
    IFilterMapper3 *pMapper = NULL;

    // if we can, get the pCreateDevEnum from the graph, which may be remote
    m_pBoxNet->IGraph()->QueryInterface(IID_IFilterMapper3, (void **) &pMapper);

    if (pMapper) {
        hr = pMapper->GetICreateDevEnum(&pCreateDevEnum);
        pMapper->Release();
    } else {
        hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    }


    if(SUCCEEDED(hr))
    {
        IEnumMoniker *pEmCat = 0;
        hr = pCreateDevEnum->CreateClassEnumerator(
            CLSID_ActiveMovieCategories,
            &pEmCat,
            0);

        if(hr == S_OK)
        {
            IMoniker *pMCat;
            ULONG cFetched;
            while(hr = pEmCat->Next(1, &pMCat, &cFetched),
                  hr == S_OK)
            {
                IPropertyBag *pPropBag;
                hr = pMCat->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    VARIANT varCatClsid;
                    varCatClsid.vt = VT_BSTR;
                    hr = pPropBag->Read(L"CLSID", &varCatClsid, 0);
                    if(SUCCEEDED(hr))
                    {
                        CLSID clsidCat;
                        if(CLSIDFromString(varCatClsid.bstrVal, &clsidCat) == S_OK)
                        {
                            // use the guid if we can't get the name
                            WCHAR *wszTmpName;

                            VARIANT varCatName;
                            varCatName.vt = VT_BSTR;
                            hr = pPropBag->Read(L"FriendlyName", &varCatName, 0);
                            if(SUCCEEDED(hr))
                            {
                                wszTmpName = varCatName.bstrVal;
                            }
                            else
                            {
                                wszTmpName = varCatClsid.bstrVal;
                            }

                            TCHAR szCatDesc[MAX_PATH];

                            WideCharToMultiByte(
                                CP_ACP, 0, wszTmpName, -1,
                                szCatDesc, sizeof(szCatDesc), 0, 0);

                            if(SUCCEEDED(hr))
                            {
                                SysFreeString(varCatName.bstrVal);
                            }

                            DoOneCategory(
                                szCatDesc,
                                hWndTree,
                                &clsidCat,
                                pCreateDevEnum);

                        }

                        SysFreeString(varCatClsid.bstrVal);
                    }

                    pPropBag->Release();
                }
                else
                {
                    break;
                }

                pMCat->Release();
            } // for loop

            pEmCat->Release();
        }
        
        if( SUCCEEDED( hr ) )
        {
            // show any custom categories we'd like to see from GraphEdt...
            for( int i = 0; g_AppEnumeratedCategories[i].pclsid; i ++ )
            {    
                 DoOneCategory(
                     g_AppEnumeratedCategories[i].pszCat,
                     hWndTree,
                     g_AppEnumeratedCategories[i].pclsid,
                     pCreateDevEnum);
            }
        }

        pCreateDevEnum->Release();
    }
    
    // For resizing... All of our controls will be created by now so it is safe to
    // process OnSize messages.
    m_bHadInitDialog = TRUE;

    // Save our current size.
    CRect rcDialog;
    GetClientRect( &rcDialog );
    m_LastDialogSize = rcDialog.Size();

    // Work out that minimum size == dialog box with no list view object
    CRect rcTreeView;
    CWnd *pwndTreeView = GetDlgItem( IDC_FILTER_TREE );

    ASSERT( pwndTreeView );
    GetWindowRect( &rcDialog );
    pwndTreeView->GetWindowRect( &rcTreeView );

    m_MinDialogSize.cx = rcDialog.Width() - rcTreeView.Width();
    m_MinDialogSize.cy = rcDialog.Height() - rcTreeView.Height();
}

void CFilterView::OnSize( UINT nType, int cx, int cy )
{
    if( SIZE_RESTORED == nType ){
        if( m_bHadInitDialog ){
            CRect rcCancelButton, rcInsertButton, rcDialog, rcTreeView;

            CWnd *pwndCancelButton = GetDlgItem( IDCANCEL );
            CWnd *pwndInsertButton = GetDlgItem( ID_ADDFILTER );
            CWnd *pwndTreeView = GetDlgItem( IDC_FILTER_TREE );

            ASSERT( pwndCancelButton );
            ASSERT( pwndInsertButton );
            ASSERT( pwndTreeView );

            GetClientRect( &rcDialog );
            pwndCancelButton->GetWindowRect( &rcCancelButton );
            pwndInsertButton->GetWindowRect( &rcInsertButton );
            pwndTreeView->GetWindowRect( &rcTreeView );

            ScreenToClient( &rcCancelButton );
            ScreenToClient( &rcInsertButton );
            ScreenToClient( &rcTreeView );

            int iXInc = cx - m_LastDialogSize.cx;
            int iYInc = cy - m_LastDialogSize.cy;

            rcCancelButton.left += iXInc;
            rcCancelButton.right += iXInc;
            rcInsertButton.left += iXInc;
            rcInsertButton.right += iXInc;
            rcTreeView.right += iXInc;
            rcTreeView.bottom += iYInc;

            pwndCancelButton->MoveWindow( rcCancelButton );
            pwndInsertButton->MoveWindow( rcInsertButton );
            pwndTreeView->MoveWindow( rcTreeView );
        }

        m_LastDialogSize = CSize( cx, cy );
    }
}

void CFilterView::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
    if( m_bHadInitDialog )
        lpMMI->ptMinTrackSize = *((POINT*)&m_MinDialogSize);
}

//
// DialogProc
//
INT_PTR CFilterView::DialogProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(m_pThis);

    if (msg == WM_LBUTTONDBLCLK) {
        //
        // The double click has selected the filter we want to insert.
        // Do the same as if we had pressed the insert button
        //
        m_pThis->OnInsert();

        // Don't return here - just fall through to the default handler.
        // This will allow the tree view control to handle the case where
        // we're double-clicking on a category name instead of a filter.
        // Returning here disables that default functionality.
    }


    return ::CallWindowProc(m_pfnOldDialogProc, hWnd, msg, wParam, lParam);
}

#ifdef COLORCODED_FILTERS
void CFilterView::OnCustomDraw (LPNMHDR lpn, LRESULT *pl)
{
    *pl = CDRF_DODEFAULT;
    LPNMLVCUSTOMDRAW lpCD = (LPNMLVCUSTOMDRAW)lpn;

    switch (lpCD->nmcd.dwDrawStage)
    {

      case CDDS_PREPAINT :
          *pl =  CDRF_NOTIFYITEMDRAW;
          return;

      case CDDS_ITEMPREPAINT:
      {
          LV_DISPINFO *pnmv = (LV_DISPINFO *) lpn;
          int iItem = (int)( pnmv->item.lParam );

          POSITION pos = m_lMoniker.GetHeadPosition();
          while(pos != 0 && iItem-- > 0)
          {
              m_lMoniker.GetNext(pos);
          }
          if(pos)
          {

              IMoniker *pMon = *m_lMoniker.GetAt(pos); // not addrefd
              if(pMon)
              {
                  IPropertyBag *pPropBag;
                  HRESULT hr = pMon->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                  if(SUCCEEDED(hr))
                  {
                      VARIANT var;
                      var.vt = VT_BSTR;
                      hr = pPropBag->Read(L"CLSID", &var, 0);
                      if(SUCCEEDED(hr))
                      {
                        CLSID clsidFil;
                        if(CLSIDFromString(var.bstrVal, &clsidFil) == S_OK)
                        {
                            static CLSID CLSID_Proxy = {
                                0x17CCA71B, 0xECD7, 0x11D0,
                                {0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96}
                            } ;

                            if(clsidFil == CLSID_Proxy) {
                                lpCD->clrText = RGB(255,128,128);
                            }

                        }
                          SysFreeString(var.bstrVal);

                      }
                      pPropBag->Release();

                      // dmo's don't have a CLSID value!???

                      WCHAR *wszName;
                      if(pMon->GetDisplayName(0, 0, &wszName) == S_OK)
                      {
                          if(wszName[0] == L'@' &&
                             wszName[1] == L'd' &&
                             wszName[2] == L'e' &&
                             wszName[3] == L'v' &&
                             wszName[4] == L'i' &&
                             wszName[5] == L'c' &&
                             wszName[6] == L'e' &&
                             wszName[7] == L':' &&
                             wszName[8] == L'd' &&
                             wszName[9] == L'm' &&
                             wszName[10] == L'o')
                          {

                              lpCD->clrText = RGB(0,128,0);
                          }
                          CoTaskMemFree(wszName);
                      }

                  }
              }

          }
      }
    }
}
#endif // COLORCODED_FILTERS

void CFilterView::OnItemExpanding (NMHDR* pnmh, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pnmh;

    if(pnmtv->itemNew.state & TVIS_EXPANDEDONCE) {
        return;
    }

    HWND hWndTree = ::GetDlgItem(m_hWnd, IDC_FILTER_TREE);


    HTREEITEM htiParent = pnmtv->itemNew.hItem;

    HTREEITEM htiOwner = (HTREEITEM)::SendMessage((hWndTree), TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)htiParent);
    if(htiOwner != 0) {
        return;
    }

    // remove dummy node
    HTREEITEM htiChild = (HTREEITEM)::SendMessage((hWndTree), TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)htiParent);
    ::SendMessage((hWndTree), TVM_DELETEITEM, 0, (LPARAM)htiChild);

    CLSID *pCatGuid = (CLSID *)pnmtv->itemNew.lParam;

    // !!! try getting mapper from graph instead of fresh....
    IFilterMapper3 *pMapper = NULL;

    // if we can, get the pCreateDevEnum from the graph, which may be remote
    m_pBoxNet->IGraph()->QueryInterface(IID_IFilterMapper3, (void **) &pMapper);

    HRESULT hr;

    ICreateDevEnum *pCreateDevEnum;
    if (pMapper) {
        hr = pMapper->GetICreateDevEnum(&pCreateDevEnum);
        pMapper->Release();
    } else {
        hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    }
    if(SUCCEEDED(hr))
    {

        IEnumMoniker *pEm;
        hr = pCreateDevEnum->CreateClassEnumerator(
            *pCatGuid,
            &pEm,
            0);
        if(SUCCEEDED(hr))
        {
            // remember hr is S_FALSE if pEm is null because there
            // would've been zero elements.
            //
            if(htiParent != 0 && pEm)
            {
                ULONG cFetched;
                IMoniker *pM;
                while(hr = pEm->Next(1, &pM, &cFetched),
                      hr == S_OK)
                {
                    IPropertyBag *pPropBag;
                    hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_BSTR;
                        hr = pPropBag->Read(L"FriendlyName", &var, 0);
                        if(SUCCEEDED(hr))
                        {
                            TCHAR szString[MAX_PATH];
                            WideCharToMultiByte(
                                CP_ACP, 0, var.bstrVal, -1,
                                szString, sizeof(szString), 0, 0);

                            TV_INSERTSTRUCT tvis;
                            tvis.hParent = htiParent;
                            tvis.hInsertAfter = TVI_SORT;
                            tvis.item.pszText = szString; // !!! can be wide
                            tvis.item.lParam = m_lMoniker.GetCount(); // use POS?
                            tvis.item.mask = TVIF_TEXT | TVIF_PARAM;

                            //TreeView_InsertItem(hWndTree, &tvis);
                            HTREEITEM htx = (HTREEITEM)::SendMessage((hWndTree), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(&tvis));
                            m_lMoniker.AddTail(new CQCOMInt<IMoniker>(pM));

#ifdef SHOWTYPES
                            // !!! aggregation broken -- cannot qi
                            // graph or mapper for IAMFilterData
                            IAMFilterData *pfd;
                            hr = CoCreateInstance(
                                CLSID_FilterMapper,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IAMFilterData,
                                (void **)&pfd);
                            if(SUCCEEDED(hr))
                            {
                                DoFilterInfo(hWndTree, htx, pM, pfd);
                                pfd->Release();
                            }
#endif

                            SysFreeString(var.bstrVal);
                        }
                        pPropBag->Release();
                    }

                    pM->Release();
                }

            }
            if(pEm) {
                pEm->Release();
            }
        }
        pCreateDevEnum->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\flb.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#if !defined(AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_)
#define AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// This error is returned if no filters are currently selected in the list box.
//#define GE_E_NO_FILTERS_ARE_SELECTED        MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0xFFFF )

class CFilterNameDictionary;

class CFilterListBox : public CListBox
{
public:
    CFilterListBox( HRESULT* phr );
    ~CFilterListBox();

    HRESULT AddFilter( IBaseFilter* pFilter );
    HRESULT GetSelectedFilter( IBaseFilter** ppSelectedFilter );
    HRESULT RemoveSelectedFilter( void );

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFilterListBox)
    //}}AFX_VIRTUAL

private:
    HRESULT GetSelectedFilter( IBaseFilter** ppSelectedFilter, int* pnSelectedFilterIndex );

    CFilterNameDictionary* m_pfndFilterDictionary;
    CList<IBaseFilter*, IBaseFilter*>* m_pListedFilters;

    //{{AFX_MSG(CFilterListBox)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

#endif // !defined(AFX_FILTERLISTBOX_H__45C6C059_F447_40B6_82F1_C954CB94596D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\enum.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// enum.cpp
//
// A set of wrappers for COM enumerators.

#include "stdafx.h"

// *
// * CFilterEnum
// *

//
// CFilterEnum::Constructor
//
CFilterEnum::CFilterEnum(IFilterGraph *pGraph) {

    ASSERT(pGraph);

    HRESULT hr = pGraph->EnumFilters(&m_pEnum);
    if (FAILED(hr))
        throw CHRESULTException(hr);

}


//
// CFilterEnum::Destructor
//
CFilterEnum::~CFilterEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
// Use to get next filter
// !!!Does this return AddRef()'d pointers?
IBaseFilter *CFilterEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    IBaseFilter	*aFilter[1];

    HRESULT hr = m_pEnum->Next(1, aFilter, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0) )	// no more filters
        return NULL;
    else if (FAILED(hr) || (ulActual != 1) )	// some unexpected problem occured
        throw CE_FAIL();

    return aFilter[0];
}


// *
// * CPinEnum
// *

// Enumerates a filters pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CPinEnum::CPinEnum(IBaseFilter *pFilter, DirType Type)
    : m_Type(Type) {

    if (Type == Input) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (Type == Output) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }
}


//
// CPinEnum::Destructor
//
CPinEnum::~CPinEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
IPin *CPinEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    IPin	*aPin[1];
    PIN_DIRECTION pd;

    for (;;) {

        HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
        if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
            return NULL;
        }
        else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
            throw CE_FAIL();
        }

        hr = aPin[0]->QueryDirection(&pd);
        if (FAILED(hr)) {
	    aPin[0]->Release();
            throw CHRESULTException(hr);
        }

        // if m_Type == All return the first pin we find
        // otherwise return the first of the correct sense

        if (m_Type == All || pd == m_EnumDir) {
            return aPin[0];
        } else {
            aPin[0]->Release();
        }
    }
}


// *
// * CRegFilterEnum
// *

//
// Constructor
//
// Query the supplied mapper for an enumerator for the
// requested filters.
CRegFilterEnum::CRegFilterEnum(IFilterMapper	*pMapper,
                   		DWORD	dwMerit,		// See IFilterMapper->EnumMatchingFilters
                   		BOOL	bInputNeeded,	// for the meanings of these parameters.
                   		CLSID	clsInMaj,	// the defaults will give you all
                   		CLSID	clsInSub,	// filters
                   		BOOL	bRender,
                   		BOOL	bOutputNeeded,
                   		CLSID	clsOutMaj,
                   		CLSID	clsOutSub) {

    HRESULT hr = pMapper->EnumMatchingFilters(&m_pEnum,
                                              dwMerit,
                                              bInputNeeded,
                                              clsInMaj,
                                              clsInSub,
                                              bRender,
                                              bOutputNeeded,
                                              clsOutMaj,
                                              clsOutSub);
    if (FAILED(hr)) {
        throw CHRESULTException(hr);
    }
}


//
// Destructor
//
CRegFilterEnum::~CRegFilterEnum(void) {

    ASSERT(m_pEnum);

    m_pEnum->Release();
}


//
// operator()
//
CRegFilter *CRegFilterEnum::operator() (void) {

    ASSERT(m_pEnum);

    ULONG	ulActual;
    REGFILTER	*arf[1];

    HRESULT hr = m_pEnum->Next(1, arf, &ulActual);
    if (SUCCEEDED(hr) && (ulActual == 0)) {
        return NULL;
    }
    else if (FAILED(hr) || (ulActual != 1)) {
        throw CE_FAIL();
    }

    // transfer from TaskMem to 'new' mem

    CRegFilter *prf = new CRegFilter(arf[0]);
    if (prf == NULL) {
        throw CE_OUTOFMEMORY();
    }

    CoTaskMemFree(arf[0]);

    return prf;
}


// *
// * CRegFilter
// *


//
// Constructor
//
CRegFilter::CRegFilter(REGFILTER *prf)
    : m_Name(prf->Name),
      m_clsid(prf->Clsid) {
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\filtervw.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
class CFilterView : public CDialog
{
public:
    static void DelFilterView();
    static CFilterView * GetFilterView(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );

protected:
    ~CFilterView();
    CFilterView(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );


    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );

    afx_msg void OnInsert();
#ifdef FILTER_FAVORITES
    afx_msg void OnAddToFav();
#endif
    afx_msg void OnItemExpanding(NMHDR* pnmh, LRESULT* pResult);
#ifdef COLORCODED_FILTERS
    afx_msg void OnCustomDraw(NMHDR* pnmh, LRESULT* pResult);
#endif
    
    BOOL OnInitDialog();
    void RedoList();
    void DoOneCategory(
        const TCHAR *szCatDesc,
        HWND hWndTree,
        const GUID *pCatGuid,
        ICreateDevEnum *pCreateDevEnum);
    
    int m_iIcon;

    // can't get count without enumerating everything. so use list.
    CDeleteList<CQCOMInt<IMoniker>*, CQCOMInt<IMoniker>* > m_lMoniker;

    CBoxNetDoc * m_pBoxNet;
    HIMAGELIST m_hImgList;

    static CFilterView * m_pThis;
    static WNDPROC m_pfnOldDialogProc;
    static INT_PTR CALLBACK DialogProc(HWND, UINT, WPARAM, LPARAM);

    BOOL m_bHadInitDialog;         // Received OnInitDialog message?
    CSize m_LastDialogSize;        // Last known size of our dialog box
    CSize m_MinDialogSize;         // Minimum size of the dialog box

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\flb.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "FND.h"
#include "FLB.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CFilterListBox, CListBox)
    //{{AFX_MSG_MAP(CFilterListBox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CFilterListBox::CFilterListBox( HRESULT* phr )
    : m_pfndFilterDictionary(NULL),
      m_pListedFilters(NULL)
{
    try
    {
        m_pListedFilters = new CList<IBaseFilter*, IBaseFilter*>;
        m_pfndFilterDictionary = new CFilterNameDictionary( phr );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        delete m_pListedFilters;
        delete m_pfndFilterDictionary;
        m_pListedFilters = NULL;
        m_pfndFilterDictionary = NULL;

        pOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }
}

CFilterListBox::~CFilterListBox()
{
    IBaseFilter* pCurrentFilter;

    if( NULL != m_pListedFilters )
    {
        while( !m_pListedFilters->IsEmpty() )
        {
            pCurrentFilter = m_pListedFilters->GetHead();
            pCurrentFilter->Release();
            m_pListedFilters->RemoveAt( m_pListedFilters->GetHeadPosition() );
        }
    }

    delete m_pListedFilters;
    delete m_pfndFilterDictionary;
}

HRESULT CFilterListBox::AddFilter( IBaseFilter* pFilter )
{
    // This function assumes pFilter is a valid pointer.
    ASSERT( NULL != pFilter );

    WCHAR szCurrentFilterName[MAX_FILTER_NAME];

    HRESULT hr = m_pfndFilterDictionary->GetFilterName( pFilter, szCurrentFilterName );
    if( FAILED( hr ) )
    {
        return hr;
    }

    #ifdef _UNICODE
    int nNewItemIndex = AddString( szCurrentFilterName );
    #else // multibyte or ANSI.
    TCHAR szMultiByteFilterName[1024];

    // The filter's name must always fit in the szMultiByteFilterName buffer.
    ASSERT( sizeof(szCurrentFilterName) <= sizeof(szMultiByteFilterName) );

    int nNumBytesWritten = ::WideCharToMultiByte( CP_ACP,
                                                  0,
                                                  szCurrentFilterName,
                                                  -1, // WideCharToMultiByte() automatically calculates the 
                                                      // length of fiCurrentFilter.achName if this parameter equals -1.
                                                  szMultiByteFilterName,
                                                  sizeof(szMultiByteFilterName), 
                                                  NULL,
                                                  NULL ); 

    // An error occured if data was written off the end of the buffer.
    ASSERT( nNumBytesWritten <= sizeof(szMultiByteFilterName) );

    // ::WideCharToMultiByte() returns 0 if an error occurs.
    if( 0 == nNumBytesWritten ) {
        DWORD dwLastWin32Error = ::GetLastError();
        return MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, dwLastWin32Error );
    }

    int nNewItemIndex = AddString( szMultiByteFilterName );
    #endif // _UNICODE

    if( (LB_ERR == nNewItemIndex) || (LB_ERRSPACE == nNewItemIndex) ) {
        return E_FAIL;
    }

    int nReturnValue = SetItemDataPtr( nNewItemIndex, pFilter );
    if( LB_ERR == nReturnValue )
    {
        nReturnValue = DeleteString( nNewItemIndex );

        // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
        // invalid item index.  See the MFC 4.2 documentation for more information.
        ASSERT( LB_ERR != nReturnValue );
        return E_FAIL;
    }

    try
    {
        m_pListedFilters->AddHead( pFilter );
    }
    catch( CMemoryException* pOutOfMemory )
    {
        nReturnValue = DeleteString( nNewItemIndex );

        // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
        // invalid item index.  See the MFC 4.2 documentation for more information.
        ASSERT( LB_ERR != nReturnValue );

        pOutOfMemory->Delete();
        return E_OUTOFMEMORY;
    }

    pFilter->AddRef();

    return S_OK;
}

HRESULT CFilterListBox::GetSelectedFilter( IBaseFilter** ppSelectedFilter )
{
    return GetSelectedFilter( ppSelectedFilter, NULL );
}

HRESULT CFilterListBox::GetSelectedFilter( IBaseFilter** ppSelectedFilter, int* pnSelectedFilterIndex )
{
    // This function assumes ppSelectedFilter is a valid pointer.
    ASSERT( NULL != ppSelectedFilter );

    *ppSelectedFilter = NULL;

    int nSelectedFilterIndex = GetCurSel();

    // CListBox::GetCurSel() returns LB_ERR if no items are selected.
    if( LB_ERR == nSelectedFilterIndex )
    {
        return E_FAIL; // GE_E_NO_FILTERS_ARE_SELECTED;
    }

    void* pSelectedFilter = GetItemDataPtr( nSelectedFilterIndex );

    // CListBox::GetItemDatePtr() returns LB_ERR if an error occurs.
    if( LB_ERR == (INT_PTR)pSelectedFilter )
    {
        return E_FAIL;
    }

    *ppSelectedFilter = (IBaseFilter*)pSelectedFilter;

    if( NULL != pnSelectedFilterIndex )
    {
        *pnSelectedFilterIndex = nSelectedFilterIndex;
    }

    return S_OK;
}

HRESULT CFilterListBox::RemoveSelectedFilter( void )
{
    int nSelectedFilterIndex;
    IBaseFilter* pSelectedFilter;

    HRESULT hr = GetSelectedFilter( &pSelectedFilter, &nSelectedFilterIndex );
    if( FAILED( hr ) )
    {
        return hr;
    }

    int nReturnValue = DeleteString( nSelectedFilterIndex );
    // CListBox::DeleteString() only returns LB_ERR if nNewItemIndex is an
    // invalid item index.  See the MFC 4.2 documentation for more information.
    ASSERT( LB_ERR != nReturnValue );

    POSITION posSelectedFilter = m_pListedFilters->Find( pSelectedFilter );

    // CList::Find() only returns NULL if it cannot find the filter.
    // It should always find the filter since all filters added to
    // the list box are also added to the m_pListedFilters list.
    // See CFilterListBox::AddFilter() for more information.
    ASSERT( NULL != posSelectedFilter );

    m_pListedFilters->RemoveAt( posSelectedFilter );

    pSelectedFilter->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\fnd.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <streams.h>
#include "FND.h"

template<> inline UINT AFXAPI HashKey<CLSID&>( CLSID& clsidKey )
{
	return ((UINT) *((BYTE*)&clsidKey));
}

CFilterNameDictionary::CFilterNameDictionary( HRESULT* phr )
{
    try
    {
        m_pFilterNames = new CMap<CLSID, CLSID&, WCHAR*, WCHAR*>;
    }
    catch( CMemoryException* eOutOfMemory )
    {
        m_pFilterNames = NULL;
        eOutOfMemory->Delete();
        *phr = E_OUTOFMEMORY;
        return;
    }
    
    HRESULT hr = BuildFilterNameTable();
    if( FAILED( hr ) )
    {
        DestroyFilterNameTable();
        *phr = hr;
        return;
    }
}

CFilterNameDictionary::~CFilterNameDictionary()
{
    DestroyFilterNameTable();
}

void CFilterNameDictionary::DestroyFilterNameTable( void )
{
    CLSID clsidCurrent;
    WCHAR* pszCurrentName;

    if( NULL != m_pFilterNames )
    {
        if( !m_pFilterNames->IsEmpty() )
        {
            POSITION posCurrent = m_pFilterNames->GetStartPosition();

            while( posCurrent != NULL )
            {
                m_pFilterNames->GetNextAssoc( posCurrent, clsidCurrent, pszCurrentName );
                delete [] pszCurrentName;
            }
        }

        m_pFilterNames->RemoveAll();

        delete m_pFilterNames;
        m_pFilterNames = NULL;
    }
}

HRESULT CFilterNameDictionary::GetFilterName( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] ) 
{
    HRESULT hr = GetNameFromFilter( pFilter, szFilterName );
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }

    hr = GetNameFromFilterNameTable( pFilter, szFilterName );
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }
    
    hr = GetNameFromInterfacePointer( pFilter, szFilterName ); 
    if( SUCCEEDED( hr ) )
    {
        return S_OK;
    }

    return E_FAIL;
}

HRESULT CFilterNameDictionary::GetNameFromFilter( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    FILTER_INFO fiFilterInfo;

    HRESULT hr = pFilter->QueryFilterInfo( &fiFilterInfo );
    if( FAILED( hr ) ) {
        return hr;
    }

    if( NULL != fiFilterInfo.pGraph ) {
        fiFilterInfo.pGraph->Release();
        fiFilterInfo.pGraph = NULL;
    }

    // Check so see if the filter's name is empty.
    if( '\0' == fiFilterInfo.achName[0] )
    {
        return E_FAIL;         
    }   

    ::lstrcpynW( szFilterName, fiFilterInfo.achName, MAX_FILTER_NAME );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    return S_OK;
}

HRESULT CFilterNameDictionary::GetNameFromFilterNameTable( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    CLSID clsidFilter;

    HRESULT hr = GetFilterCLSID( pFilter, &clsidFilter );
    if( FAILED( hr ) )
    {
        return hr;
    }

    WCHAR* pszFilterNameInTable;

    if( !m_pFilterNames->Lookup( clsidFilter, pszFilterNameInTable ) )
    {
        return E_FAIL;
    }

    ::lstrcpynW( szFilterName, pszFilterNameInTable, MAX_FILTER_NAME );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    return S_OK;
}

HRESULT CFilterNameDictionary::GetNameFromInterfacePointer( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] )
{
    IUnknown* pUnknown;

    HRESULT hr = pFilter->QueryInterface( IID_IUnknown, (void**)&pUnknown );
    if( FAILED( hr ) )
    {
        return hr;  
    }

    _snwprintf( szFilterName, MAX_FILTER_NAME, L"Filter's IUnkown Pointer: 0x%p", pUnknown );

    // Ensure that the filter name is ALWAYS null terminated.
    szFilterName[MAX_FILTER_NAME - 1] = '\0';

    pUnknown->Release();

    return S_OK;
}

HRESULT CFilterNameDictionary::BuildFilterNameTable( void )
{
    // This is the lowest possible merit.
    const DWORD MERIT_ANY_FILTER = 0x00000000;

    IFilterMapper2* pFilterMapper2;

    HRESULT hr = CoCreateInstance( CLSID_FilterMapper2,
                                   NULL, // This object will NOT be agregated.
                                   CLSCTX_INPROC_SERVER,  
                                   IID_IFilterMapper2,
                                   (void**)&pFilterMapper2 );
    if( FAILED( hr ) )
    {
        return hr;
    }

    IEnumMoniker* pAllRegisteredFilters;

    hr = pFilterMapper2->EnumMatchingFilters( &pAllRegisteredFilters,
                                              0, // No Flags
                                              FALSE, // No exact match
                                              MERIT_ANY_FILTER, 
                                              FALSE, // We do not care if the filter has any input pins.
                                              0,  
                                              NULL, // Since we don't care if the filter has an input pin, we accept any type.
                                              NULL, // We can use any input medium
                                              NULL, // We want pins from any category.
                                              FALSE, // The filter does not have to render the input.
                                              FALSE, // The filter does not need an output pin.
                                              0,
                                              NULL, // Since we don't care if the filter has an output pin, we accept any type.
                                              NULL, // We can use any output medium
                                              NULL ); // We want pins from any category.
    pFilterMapper2->Release();

    if( FAILED( hr ) )
    {
        return hr;
    }

    HRESULT hrEnum;
    CLSID clsidCurrentFilter;
    IMoniker* aCurrentFilterMoniker[1];

    do
    {
        hrEnum = pAllRegisteredFilters->Next( 1, &aCurrentFilterMoniker[0], NULL );
        if( FAILED( hrEnum ) )
        {
            pAllRegisteredFilters->Release();
            return hrEnum;
        }

        // IEnumMoniker::Next() returns S_OK if it successfully obtained the next moniker.
        if( S_OK == hrEnum )
        {
            WCHAR* pszFilterName;

            try
            {
                pszFilterName = new WCHAR[MAX_FILTER_NAME];
            }
            catch( CMemoryException* eOutOfMemory )
            {
                eOutOfMemory->Delete();
                aCurrentFilterMoniker[0]->Release();            
                pAllRegisteredFilters->Release();
                return E_OUTOFMEMORY;
            }

            hr = GetFiltersNameAndCLSID( aCurrentFilterMoniker[0],
                                         &clsidCurrentFilter,
                                         pszFilterName,
                                         MAX_FILTER_NAME );

            aCurrentFilterMoniker[0]->Release();            
    
            // GetFiltersNameAndCLSID() may fail because the filter can not be created.
            if( FAILED( hr ) )
            {
                delete [] pszFilterName;
                pszFilterName = NULL;
                continue;
            }

            hr = AddNameToTable( clsidCurrentFilter, pszFilterName );
            if( S_FALSE == hr )
            {
                delete [] pszFilterName;
                pszFilterName = NULL;
            }
            else if( FAILED( hr ) )
            {
                pAllRegisteredFilters->Release();
                delete [] pszFilterName;
                return hr;
            }
        }
    } while( S_OK == hrEnum );

    pAllRegisteredFilters->Release();
    
    return S_OK;
}


HRESULT CFilterNameDictionary::GetFiltersNameAndCLSID
    (
    IMoniker* pFiltersMoniker,
    CLSID* pclsidFilter,
    WCHAR* pszFiltersName,
    DWORD dwMaxFilterNameLength
    )
{
    CComPtr<IBindCtx> pBindContext;

    HRESULT hr = ::CreateBindCtx( 0, &pBindContext );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // Get the filter's name.
    CComPtr<IPropertyBag> pFilterPropertyBag;

    hr = pFiltersMoniker->BindToStorage( pBindContext,
                                         NULL,
                                         IID_IPropertyBag,
                                         (void**)&pFilterPropertyBag );
    if( FAILED( hr ) )
    {
        return hr;
    }

    VARIANT varFilterName;

    ::VariantInit( &varFilterName );
    varFilterName.vt = VT_BSTR;
    varFilterName.bstrVal = ::SysAllocString(NULL);

    hr = pFilterPropertyBag->Read( L"FriendlyName", &varFilterName, NULL );

    if( FAILED( hr ) )
    {
        ::VariantClear( &varFilterName );
        return hr;
    }

    VARIANT varFilterCLSID;

    ::VariantInit( &varFilterCLSID );
    varFilterCLSID.vt = VT_BSTR;
    varFilterCLSID.bstrVal = ::SysAllocString(NULL);

    hr = pFilterPropertyBag->Read( L"CLSID", &varFilterCLSID, NULL );

    if( FAILED( hr ) )
    {
        ::VariantClear( &varFilterName );
        ::VariantClear( &varFilterCLSID ); 
        return hr;
    }

    CLSID clsidFilter;

    hr = CLSIDFromString( varFilterCLSID.bstrVal, &clsidFilter );

    ::VariantClear( &varFilterCLSID ); 

    if( FAILED( hr ) ) {
        ::VariantClear( &varFilterName );
        return hr;
    }

    // The SysStringLen() length returned by SysStringLen() does not include the null
    // terminating character.
    DWORD dwFilterNameLength = ::SysStringLen( varFilterName.bstrVal ) + 1;
    
    // If this ASSERT fires, then the filter's name will be truncated.
    ASSERT( dwFilterNameLength < MAX_FILTER_NAME );

    ::lstrcpynW( pszFiltersName, varFilterName.bstrVal, min( dwFilterNameLength, dwMaxFilterNameLength ) );

    *pclsidFilter = clsidFilter;

    ::VariantClear( &varFilterName );

    return S_OK;
}

HRESULT CFilterNameDictionary::AddNameToTable( CLSID& clsid, WCHAR* pszName )
{
    WCHAR* pszStoredName; 
   
    // There should never be two names with the same CLSID.
    if( m_pFilterNames->Lookup( clsid, pszStoredName ) )
    {
        DbgLog(( LOG_TRACE, 0, "WARNING: Found two names with the same CLSID: %40ls  %40ls", pszStoredName, pszName ));
        return S_FALSE;
    }

    try
    {
        m_pFilterNames->SetAt( clsid, pszName );
    }
    catch( CMemoryException* eOutOfMemory )
    {
        eOutOfMemory->Delete();
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CFilterNameDictionary::GetFilterCLSID( IBaseFilter* pFilter, CLSID* pFilterCLSID )
{
    IPersist* pFilterID;

    HRESULT hr = pFilter->QueryInterface( IID_IPersist, (void**)&pFilterID );

    if( FAILED( hr ) )
    {
        return hr;
    }

    CLSID clsidFilter;

    hr = pFilterID->GetClassID( &clsidFilter );

    pFilterID->Release();

    if( FAILED( hr ) )
    {
        return hr;
    }

    *pFilterCLSID = clsidFilter;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\enum.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// Filter enumerator
//

// Rather than throwing exceptions I could make the class fail silently...
class CFilterEnum {

public:

    CFilterEnum(IFilterGraph *pGraph);
    ~CFilterEnum();

    // returns the next filter, or NULL if there are no more.
    IBaseFilter * operator() (void);

private:

    IEnumFilters	*m_pEnum;
};


//
// Pin Enumerator.
//
// Can enumerate all pins, or just one direction (input or output)
class CPinEnum {

public:

    enum DirType {Input, Output, All};

    CPinEnum(IBaseFilter *pFilter, DirType Type = All);
    ~CPinEnum();

    // the returned interface is addref'd
    IPin *operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType	m_Type;

    IEnumPins	*m_pEnum;
};


//
// CRegFilter
//
// The object you are passed back from operator() in
// CRegFilterEnum
class CRegFilter {
public:

    CRegFilter(REGFILTER *);	// copies what it needs from the
    				// supplied regfilter *


    CString Name(void) { return m_Name; }
    CLSID   Clsid(void) { return m_clsid; }

private:

    CString m_Name;
    CLSID   m_clsid;
};


//
// CRegFilterEnum
//
// Enumerates registered filters supplied by the mapper
class CRegFilterEnum {
public:

    CRegFilterEnum(IFilterMapper	*pMapper,
                   DWORD	dwMerit		= 0,		// See IFilterMapper->EnumMatchingFilters
                   BOOL		bInputNeeded	= FALSE,	// for the meanings of these parameters.
                   CLSID	clsInMaj	= CLSID_NULL,	// the defaults will give you all
                   CLSID	clsInSub	= CLSID_NULL,	// filters
                   BOOL		bRender		= FALSE,
                   BOOL		bOututNeeded	= FALSE,
                   CLSID	clsOutMaj	= CLSID_NULL,
                   CLSID	clsOutSub	= CLSID_NULL);
    ~CRegFilterEnum();

    // returns a pointer to a regfilter, that the caller
    // is responsible for freeing with delete
    CRegFilter *operator() (void);

private:

    IEnumRegFilters *m_pEnum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\fnd.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef CFilterNameDictionary_h
#define CFilterNameDictionary_h

class CFilterNameDictionary
{
public:
    CFilterNameDictionary( HRESULT* phr );
    ~CFilterNameDictionary();

    HRESULT GetFilterName( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );

private:
    HRESULT GetNameFromFilter( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );
    HRESULT GetNameFromFilterNameTable( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );
    HRESULT GetNameFromInterfacePointer( IBaseFilter* pFilter, WCHAR szFilterName[MAX_FILTER_NAME] );

    static HRESULT GetFiltersNameAndCLSID
        (
        IMoniker* pFiltersMoniker,
        CLSID* pclsidFilter,
        WCHAR* pszFiltersName,
        DWORD dwMaxFilterNameLength
        );

    HRESULT BuildFilterNameTable( void );
    HRESULT AddNameToTable( CLSID& clsid, WCHAR* pszName );
    void DestroyFilterNameTable( void );

    static HRESULT GetFilterCLSID( IBaseFilter* pFilter, CLSID* pFilterCLSID );

    CMap<CLSID, CLSID&, WCHAR*, WCHAR*>* m_pFilterNames;

};

#endif // CFilterNameDictionary_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\gstats.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// Dialog to display all filters
//

#include "stdafx.h"
#include "gstats.h"

BEGIN_MESSAGE_MAP(CGraphStats, CDialog)
    ON_WM_SIZE()
    ON_WM_GETMINMAXINFO()
    ON_COMMAND(IDC_REFRESH, RedoList)
    ON_COMMAND(IDC_RESET, ResetStats)
END_MESSAGE_MAP()

CGraphStats* CGraphStats::m_pThis = 0;
//
// Constructor
//
CGraphStats::CGraphStats(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)

 : 
   m_pBoxNet(pBoxNet)
 , m_bHadInitDialog( FALSE )
{
    //
    // There can only be one filter view dialog at a time. Thus
    // the initialisation in the constructor is ok (even desired).
    //
    ASSERT( m_pThis == 0 );
    m_pThis = this;
    Create(IDD_STATS, pParent);
    ShowWindow( SW_SHOW );
}

CGraphStats::~CGraphStats()
{
    // Windows will automatically delete m_hImgList when the dialog
    // box is destroyed.
    m_pThis = 0;
}

CGraphStats * CGraphStats::GetGraphStats(
    CBoxNetDoc * pBoxNet,
    CWnd * pParent)
{
    if (!m_pThis) 
    {
        m_pThis = new CGraphStats(pBoxNet, pParent);
    }
    else
    {
        m_pThis->RedoList();
        m_pThis->ShowWindow( SW_RESTORE );
    }
    return m_pThis;

}

void CGraphStats::DelGraphStats()
{
    if (m_pThis)
    {
        delete m_pThis;
        m_pThis = 0;
    }
}

BOOL CGraphStats::OnInitDialog()
{
    BOOL fResult = CDialog::OnInitDialog();

    RedoList();

    return( fResult );
}


void CGraphStats::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);    

    //{{AFX_DATA_MAP(CGraphStats)
        DDX_Control(pDX, IDC_LIST1, m_ListBox);
    //}}AFX_DATA_MAP
}


void CGraphStats::RedoList()
{
    IAMStats *pStats;

    if (FAILED(m_pBoxNet->IGraph()->QueryInterface(IID_IAMStats, (void **) &pStats)))
        return;

    m_ListBox.ResetContent();

    int tabs[] = {250, 300, 350, 400, 450, 500 };

    m_ListBox.SetTabStops(sizeof(tabs) / sizeof(tabs[0]), tabs);

    m_ListBox.AddString("Statistic\t   Count\t   Last\t   Average\t   StdDev\t   Min\t   Max");
    m_ListBox.AddString("---------\t   -----\t   ----\t   -------\t   ------\t   ---\t   ---");
    LONG lStats;
    if (SUCCEEDED(pStats->get_Count(&lStats))) {
        for (long lIndex = 0; lIndex < lStats; lIndex++) {
            BSTR szName;
            long lCount;
            double dLast;
            double dAverage;
            double dStdDev;
            double dMin;
            double dMax;

            if (FAILED(pStats->GetValueByIndex(lIndex, &szName, &lCount, &dLast,
                                               &dAverage, &dStdDev, &dMin, &dMax)))
                break;


            char achTemp[256];
#define FRAC(d)  ((int) (1000 * (d - (int) d)))
            wsprintf(achTemp, "%ls\t%5d\t%5d.%03d\t%5d.%03d\t%5d.%03d\t%5d.%03d\t%5d.%03d",
                     szName, lCount, (int) dLast, FRAC(dLast), (int) dAverage, FRAC(dAverage),
                     (int) dStdDev, FRAC(dStdDev), (int) dMin, FRAC(dMin), (int) dMax, FRAC(dMax));
            m_ListBox.AddString(achTemp);

            SysFreeString(szName);
        }
    }
    
    pStats->Release();
}

void CGraphStats::ResetStats()
{
    IAMStats *pStats;

    if (FAILED(m_pBoxNet->IGraph()->QueryInterface(IID_IAMStats, (void **) &pStats)))
        return;

    pStats->Reset();
    pStats->Release();

    RedoList();
}

void CGraphStats::OnSize( UINT nType, int cx, int cy )
{
    if( SIZE_RESTORED == nType ){
        if( m_bHadInitDialog ){
        }
    }
}

void CGraphStats::OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI )
{
    if( m_bHadInitDialog ) {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\grftmpl.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// CGraphDocTemplate
//

#include "stdafx.h"

// A CSingleDocTemplate derived class that provides the custom
// behaviour required for renderfile.


//
// OpenDocumentFile
//
// A direct Cut & Paste of CSingleDocTemplate::OpenDocumentFile
// with the ability (by removing #ifdef _MAC) to set the
// modified flag to keep an untitled document. ie I want the
// same behaviour for RenderFile as a mac Stationery pad
CDocument *CGraphDocTemplate::OpenDocumentFile( LPCTSTR lpszPathName
                                              , BOOL bMakeVisible) {

    // if lpszPathName == NULL => create new file of this type
    CDocument *pDocument    = NULL;
    CFrameWnd *pFrame       = NULL;
    BOOL       bCreated     = FALSE;      // => doc and frame created
    BOOL       bWasModified = FALSE;

    if (m_pOnlyDoc != NULL) {
	
	// already have a document - reinit it
	pDocument = m_pOnlyDoc;
	if (!pDocument->SaveModified()) {
	    return NULL;        // leave the original one
	}

	pFrame = (CFrameWnd*)AfxGetMainWnd();
	ASSERT(pFrame != NULL);
	ASSERT(pFrame->IsKindOf(RUNTIME_CLASS(CFrameWnd)));
	ASSERT_VALID(pFrame);
    }
    else {
        // create a new document
        pDocument = CreateNewDocument();
        ASSERT(pFrame == NULL);     // will be created below
        bCreated = TRUE;
    }

    if (pDocument == NULL) {

        AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
        return NULL;
    }
    ASSERT(pDocument == m_pOnlyDoc);

    if (pFrame == NULL) {

        ASSERT(bCreated);

	// create frame - set as main document frame
	BOOL bAutoDelete = pDocument->m_bAutoDelete;
	pDocument->m_bAutoDelete = FALSE;
					// don't destroy if something goes wrong
	pFrame = CreateNewFrame(pDocument, NULL);
	pDocument->m_bAutoDelete = bAutoDelete;
	if (pFrame == NULL) {
			
	    AfxMessageBox(AFX_IDP_FAILED_TO_CREATE_DOC);
	    delete pDocument;       // explicit delete on error
	    return NULL;
	}
    }

    // all docs have the default title. this will be overriden if a real graph is opened.
    SetDefaultTitle(pDocument);

    if (lpszPathName == NULL) {
		
        // create a new document

        // avoid creating temporary compound file when starting up invisible
        if (!bMakeVisible) {
            pDocument->m_bEmbedded = TRUE;
	}

	if (!pDocument->OnNewDocument()) {

	    // user has been alerted to what failed in OnNewDocument
	    TRACE0("CDocument::OnNewDocument returned FALSE.\n");
	    if (bCreated) {
	        pFrame->DestroyWindow();    // will destroy document
	    }
	    return NULL;
	}
    }
    else {

	BeginWaitCursor();

	// open an existing document
	bWasModified = pDocument->IsModified();
	pDocument->SetModifiedFlag(FALSE);  // not dirty for open

	if (!pDocument->OnOpenDocument(lpszPathName)) {

	    // user has been alerted to what failed in OnOpenDocument
	    TRACE0("CDocument::OnOpenDocument returned FALSE.\n");
	    if (bCreated) {
	        pFrame->DestroyWindow();    // will destroy document
	    }
	    else if (!pDocument->IsModified()) {
		
	        // original document is untouched
	        pDocument->SetModifiedFlag(bWasModified);
	    }
	    else {
		
	        // we corrupted the original document
	        SetDefaultTitle(pDocument);

	        if (!pDocument->OnNewDocument()) {
			
	            TRACE0("Error: OnNewDocument failed after trying to open a document - trying to continue.\n");
		    // assume we can continue
		}
            }
		
	    EndWaitCursor();
	    return NULL;        // open failed
        }

	// if the document is dirty, we must have called RenderFile - don't
	// change the pathname because we want to treat the document as untitled
	if (!pDocument->IsModified()) {
	    pDocument->SetPathName(lpszPathName);
	}

	EndWaitCursor();
    }

    if (bCreated && AfxGetMainWnd() == NULL) {

        // set as main frame (InitialUpdateFrame will show the window)
        AfxGetThread()->m_pMainWnd = pFrame;
    }
    InitialUpdateFrame(pFrame, pDocument, bMakeVisible);

    return pDocument;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\geerrors.h ===
#ifndef GraphEditErrors_h
#define GraphEditErrors_h

#define GE_S_RECONNECT_PENDING          MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ITF, 0xFFFF )

#endif // GraphEditErrors_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\grftmpl.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// CGraphDocTemplate
//

// A CSingleDocTemplate derived class that provides the custom
// behaviour required for renderfile.

class CGraphDocTemplate : public CSingleDocTemplate {

public:

    CGraphDocTemplate( UINT nIDResource
                     , CRuntimeClass* pDocClass
                     , CRuntimeClass* pFrameClass
                     , CRuntimeClass* pViewClass)
	: CSingleDocTemplate(nIDResource, pDocClass, pFrameClass, pViewClass) {}

    ~CGraphDocTemplate() {}

    virtual CDocument* OpenDocumentFile( LPCTSTR lpszPathName
                                       , BOOL bMakeVisible = TRUE);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\gstats.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
class CGraphStats : public CDialog
{
public:
    static void DelGraphStats();
    static CGraphStats * GetGraphStats(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );

protected:
    ~CGraphStats();
    CGraphStats(
        CBoxNetDoc * pBoxNet,
        CWnd * pParent = NULL );


    afx_msg void OnSize( UINT nType, int cx, int cy );
    afx_msg void OnGetMinMaxInfo( MINMAXINFO FAR* lpMMI );

    BOOL OnInitDialog();
    void RedoList();
    void ResetStats();

    CBoxNetDoc * m_pBoxNet;

    static CGraphStats * m_pThis;

    void DoDataExchange(CDataExchange* pDX);
    CListBox m_ListBox;

    BOOL m_bHadInitDialog;         // Received OnInitDialog message?

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\graphedt.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// graphedt.h : declares CGraphEdit
//

/////////////////////////////////////////////////////////////////////////////
// CGraphEdit
//


class CGraphEdit : public CWinApp
{

public:
    // construction, initialization, termination
    CGraphEdit();
    virtual BOOL InitInstance();
    virtual int ExitInstance();


protected:
    // message callback functions
    //{{AFX_MSG(CGraphEdit)
    afx_msg void OnAppAbout();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// application-global macros

// GBL(x) accesses member <x> of the global CGraphEdit
#define GBL(x) (((CGraphEdit *) AfxGetApp())->x)

// MFGBL(x) accesses member <x> of the global CMainFrame
#define MFGBL(x) (((CMainFrame *) GBL(m_pMainWnd))->x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\graphedt.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// boxnet.cpp : defines CAboutDlg, CGraphEdit
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//
// the one and only CGraphEdit object
//
CGraphEdit theApp;

//
// CAboutDlg dialog used for App About
//
class CAboutDlg : public CDialog {

public:
    // construction
    CAboutDlg();
    virtual BOOL OnInitDialog();
};

//
// Constructor
//
CAboutDlg::CAboutDlg() : CDialog(IDD_ABOUTBOX)
{}

//
// OnInitDialog
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
BOOL CAboutDlg::OnInitDialog()
{
    //
    // first call base method so we can return on errors
    //
    BOOL Result = CDialog::OnInitDialog();

    //
    // Find the version of this binary
    //
    TCHAR achFileName[128];
    if ( !GetModuleFileName(AfxGetInstanceHandle() , achFileName, sizeof(achFileName)) )
        return(Result);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return(Result);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return(Result);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return(Result);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return( Result );
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        CFileStatus fsFileStatus;
        if (CFile::GetStatus( achFileName, fsFileStatus)) {
            // put build date into string in YYMMDD format
            char szBuildDate[20];
            CTime * pTime = &fsFileStatus.m_mtime;

            sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
                    pTime->GetYear() % 100, pTime->GetMonth(), pTime->GetDay());
                    strcat((LPSTR) lpvValue, szBuildDate);
        }

        SetDlgItemText(IDS_VERSION, (LPSTR)lpvValue);
    }

    LocalUnlock(hTemp);
    LocalFree(hTemp);

    return(Result);
}

// *
// * CGraphEdit
// *

//
// Constructor
//
CGraphEdit::CGraphEdit()
{
    // place all significant initialization in InitInstance
}


//
// InitInstance
//
BOOL CGraphEdit::InitInstance() {
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    SetDialogBkColor();        // set dialog background color to gray
    LoadStdProfileSettings(8);  // Load standard INI file options (including MRU)

    // get MFCANS32 to wrap the Quartz interfaces also
    //HRESULT hr = Ole2AnsiSetFlags(  OLE2ANSI_WRAPCUSTOM
    //                              | OLE2ANSI_AGGREGATION
    //                             , NULL);
    //if (FAILED(hr)) {
    //    return FALSE;
    //}

    // Initialize OLE 2.0 libraries
    if (!AfxOleInit()) {
        return FALSE;
    }
	
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    AddDocTemplate(new CGraphDocTemplate( IDR_GRAPH
                                        , RUNTIME_CLASS(CBoxNetDoc)
		                        , RUNTIME_CLASS(CMainFrame)
		                        , RUNTIME_CLASS(CBoxNetView)
		                        )
		  );

    // enable file manager drag/drop and DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes();

    // initialize box drawing code
    try {
        gpboxdraw = new CBoxDraw;
        gpboxdraw->Init();
    }
    catch(CException *e) {
        delete gpboxdraw, gpboxdraw = NULL;
 	    e->Delete();
	    return FALSE;
    }

    // simple command line parsing
    if (m_lpCmdLine[0] == '\0') {
	    // create a new (empty) document
	    OnFileNew();
    }
    else {
        //
        // command line string always seems to have a ' ' in front
        // parse over it and go back afterwards
        //

        UINT iBackup = 0;
        while ((*m_lpCmdLine) == TEXT(' ')) {
            m_lpCmdLine++;
            iBackup++;
        }

        if (   (m_lpCmdLine[0] == TEXT('-') || m_lpCmdLine[0] == TEXT('/'))
             && (m_lpCmdLine[1] == TEXT('e') || m_lpCmdLine[1] == TEXT('E'))
            ) {
        	// program launched embedded - wait for DDE or OLE open
        }
        else {
    	    // open an existing document
            OpenDocumentFile(m_lpCmdLine);
        }

        // reset pointer to command line string
        m_lpCmdLine -= iBackup;
    }

    return TRUE;
}



//
// ExitInstance
//
int CGraphEdit::ExitInstance() {

    if (gpboxdraw != NULL) {
        delete gpboxdraw, gpboxdraw = NULL;
    }
    AfxOleTerm();
	
    return CWinApp::ExitInstance();
}


//
// CGraphEdit generated message map
//
BEGIN_MESSAGE_MAP(CGraphEdit, CWinApp)
	//{{AFX_MSG_MAP(CGraphEdit)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()


//
// CGraphEdit callback functions
//

//
// OnAppAbout
//
// Display the modal about dialog
void CGraphEdit::OnAppAbout() {

    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\gutil.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// util.cpp
//
// Defines utility functions not specific to this application.
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/* NormalizeRect(prc)
 *
 * Swap the left and right edges of <prc>, and the top and bottom edges,
 * as required in order to make <prc->left> be less than <prc->right>
 * and <prc->top> to be less than <prc->bottom>.
 */
void FAR PASCAL
NormalizeRect(CRect *prc)
{
    if (prc->left > prc->right)
        iswap(&prc->left, &prc->right);
    if (prc->top > prc->bottom)
        iswap(&prc->top, &prc->bottom);
}


/* InvertFrame(pdc, prcOuter, prcInner)
 *
 * Invert the color of the pixels in <pdc> that are contained in <*prcOuter>
 * but that are not contained in <*prcInner>.
 */
void FAR PASCAL
InvertFrame(CDC *pdc, CRect *prcOuter, CRect *prcInner)
{
    pdc->PatBlt(prcOuter->left, prcOuter->top,
        prcOuter->Width(), prcInner->top - prcOuter->top, DSTINVERT);
    pdc->PatBlt(prcOuter->left, prcInner->bottom,
        prcOuter->Width(), prcOuter->bottom - prcInner->bottom, DSTINVERT);
    pdc->PatBlt(prcOuter->left, prcInner->top,
        prcInner->left - prcOuter->left, prcInner->Height(), DSTINVERT);
    pdc->PatBlt(prcInner->right, prcInner->top,
        prcOuter->right - prcInner->right, prcInner->Height(), DSTINVERT);
}


//
// --- Quartz Stuff ---
//

//
// CIPin
//


BOOL EqualPins(IPin *pFirst, IPin *pSecond)
{
    /*  Different objects can't have the same interface pointer for
        any interface
    */
    if (pFirst == pSecond) {
        return TRUE;
    }
    /*  OK - do it the hard way - check if they have the same
        IUnknown pointers - a single object can only have one of these
    */
    LPUNKNOWN pUnknown1;     // Retrieve the IUnknown interface
    LPUNKNOWN pUnknown2;     // Retrieve the other IUnknown interface
    HRESULT hr;              // General OLE return code

    ASSERT(pFirst);
    ASSERT(pSecond);

    /* See if the IUnknown pointers match */

    hr = pFirst->QueryInterface(IID_IUnknown,(void **) &pUnknown1);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown1);

    hr = pSecond->QueryInterface(IID_IUnknown,(void **) &pUnknown2);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pUnknown2);

    /* Release the extra interfaces we hold */

    pUnknown1->Release();
    pUnknown2->Release();
    return (pUnknown1 == pUnknown2);
}

//
// operator ==
//
// Test for equality. Pins are equal if they are on the same filter and have the
// same name. (case insensitive)
BOOL CIPin::operator== (CIPin& pin) {

    return EqualPins((*this), pin);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\link.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// link.h : declares CBoxLink
//

// forward declaration
class CBoxNetDoc;

/////////////////////////////////////////////////////////////////////////////
// CBoxLink -- defines a link between two box sockets

class CBoxLink : public CPropObject {

public:
    // pointers to the box sockets that this link connects
    CBoxSocket     *m_psockHead;        // head end of the link
    CBoxSocket     *m_psockTail;        // tail end of the link
    CBoxNetDoc 	   *m_pDoc;		// The document we belong to

public:
    // CBoxLink user interface

    void	    SetSelected(BOOL fSelected) { m_fSelected = fSelected; }
    BOOL	    IsSelected(void) { return m_fSelected; }

public:
    // CPropObject Overrides

    // As I always have an IPin I can always display properties
    virtual BOOL CanDisplayProperties(void) { return TRUE; }

    virtual CString Label(void) const { return CString("Link"); }

    // return Iunknown from one of our pins. it doesnt matter which.
    virtual IUnknown *pUnknown(void) const { ASSERT(m_psockHead); return m_psockHead->pUnknown(); }

private:

    BOOL	m_fSelected;	// Is this link selected?

    // construction and destruction
public:
    CBoxLink(CBoxSocket *psockTail, CBoxSocket *psockHead, BOOL fConnected = FALSE);
    ~CBoxLink();

public:

    #ifdef _DEBUG

    // diagnostics
    void Dump(CDumpContext& dc) const {
        CPropObject::Dump(dc);
    }
    void MyDump(CDumpContext& dc) const;

    virtual void AssertValid(void) const;

    #endif  _DEBUG

public:

    // -- Quartz --

    HRESULT Connect(void);
    HRESULT IntelligentConnect(void);
    HRESULT DirectConnect(void);
    HRESULT Disconnect(BOOL fRefresh = TRUE);

    BOOL    m_fConnected;
};


// *
// * CLinkList
// *
// A list of CBoxLinks
class CLinkList : public CDeleteList<CBoxLink *, CBoxLink *> {

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\link.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
// link.cpp : defines CBoxLinkBend, CBoxLink
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;


void CBoxLink::MyDump(CDumpContext& dc) const
{
    dc << TEXT("*** Link ***\n");
    dc << TEXT("   Location:    ") << (void *) this << TEXT("\n");
    dc << TEXT("   Head Socket: ") << (void *) m_psockHead << TEXT("\n");
    dc << TEXT("   Tail Socket: ") << (void *) m_psockTail << TEXT("\n");
}


#endif



//
// CBoxLink::Constructor
//
// set fConnected (default FALSE) to true if constructing a
// link for an already connected pair of sockets.
CBoxLink::CBoxLink(CBoxSocket *psockTail, CBoxSocket *psockHead, BOOL fConnected)
    : m_psockTail(psockTail)
    , m_psockHead(psockHead)
    , m_fConnected(fConnected)
    , m_fSelected(  (psockTail->m_pbox->IsSelected())
                  ||(psockHead->m_pbox->IsSelected()))	// if either box is selected, then so is the link
    , m_pDoc(psockTail->m_pbox->pDoc()) {

    ASSERT(m_psockTail);
    ASSERT(m_psockHead);

    if (fConnected) {
        m_psockTail->m_plink = this;
        m_psockHead->m_plink = this;
    }

    ASSERT(m_pDoc);
	
    ASSERT(m_pDoc == psockHead->m_pbox->pDoc());
}


//
// CBoxLink::Destructor
//
// The link has a head and tail socket. We remove any references
// from the sockets to the link during deletion.
//
CBoxLink::~CBoxLink() {
    HideDialog();

    if (m_psockHead)
        m_psockHead->m_plink = NULL;

    if (m_psockTail)
        m_psockTail->m_plink = NULL;
}


//
// Connect
//
// Ask the filter graph to connect the filters at each end of this link
// Returns S_OK if directly connected
//         S_FALSE if indirectly (intelligently) connected
//         E_XXX in error cases.
HRESULT CBoxLink::Connect() {

    ASSERT_VALID(this);

    HRESULT hr = S_OK;

    if (!m_fConnected) {


	hr = DirectConnect();
	if (SUCCEEDED(hr)) {
	    return S_OK;
	}

        if (m_pDoc->m_fConnectSmart) {
            hr = IntelligentConnect();
            if (SUCCEEDED(hr)) {
                return S_FALSE;
            }
        }
    }

    return hr;	// may have been set to failure code by IntelligentConnect
}


//
// DirectConnect
//
// Connect this link to its sockets. Fail if a direct connection
// is not possible
HRESULT CBoxLink::DirectConnect(void) {

    ASSERT_VALID(this);

    if (!m_fConnected) {

        HRESULT hr;

	hr = m_pDoc->IGraph()->ConnectDirect(m_psockTail->pIPin(),	// i/p
					     m_psockHead->pIPin(),      // o/p
                                             NULL);
        if (FAILED(hr)) {
	    return hr;
	}

        // Even a direct connect can add extra connections from the deferred list.

#ifdef JoergsOldVersion
	m_psockHead->m_pbox->Refresh(); // refresh the box after a connection
	m_psockTail->m_pbox->Refresh(); // refresh the box after a connection

        // make the newly-connected sockets point to the link object
        m_psockTail->m_plink = this;
        m_psockHead->m_plink = this;
#endif
        m_pDoc->UpdateFilters();

        ASSERT(SUCCEEDED(hr));
	m_fConnected = TRUE;
    }

    return NOERROR;
}


//
// IntelligentConnect
//
// Ask the filter graph to connect the filters at each end of
// this link, using 'Intelligent connection'. If this suceeds you
// should delete this link, as the doc has had anything it needs added to it.
HRESULT CBoxLink::IntelligentConnect(void) {

    ASSERT_VALID(this);

    if (!m_fConnected) {

        TRACE("Trying intelligent connect\n");

        HRESULT hr = m_pDoc->IGraph()->Connect(m_psockTail->pIPin(),		// i/p
  				       m_psockHead->pIPin());
        if (FAILED(hr)) {
	    m_fConnected = FALSE;
	    TRACE("Error Connecting Filters\n");
	    return hr;
	}

        ASSERT(SUCCEEDED(hr));
	m_fConnected = FALSE;	// we have connected this link, but
				// it is about to be replaced by the stuff
				// the filtergraph added, so it is now 'hanging'

	m_pDoc->UpdateFilters();
    }

    return S_OK;
}


//
// Disconnect
//
// Ask the filter graph to disconnect the filters at each end of this link
//
// Only refreshes the boxes if fRefresh is TRUE.
//
HRESULT CBoxLink::Disconnect(BOOL fRefresh)
{

    ASSERT_VALID(this);

    HRESULT hr;

    //
    // m_psockHead & m_psockTail are both NULL or both non-NULL.
    //
    if (NULL == m_psockTail) {
        ASSERT(!m_psockHead);
        return(S_OK);
    }
    ASSERT(m_psockHead);

    hr = m_pDoc->IGraph()->Disconnect(m_psockTail->pIPin());
    ASSERT(SUCCEEDED(hr));

    hr = m_pDoc->IGraph()->Disconnect(m_psockHead->pIPin());
    ASSERT(SUCCEEDED(hr));

    m_psockHead->m_plink = NULL;
    m_psockTail->m_plink = NULL;

    if (fRefresh) {
        m_psockHead->m_pbox->Refresh(); // refresh the sockets after disconnect
        m_psockTail->m_pbox->Refresh(); // refresh the sockets after disconnect
    }

    m_psockHead = NULL;
    m_psockTail = NULL;

    m_fConnected = FALSE;

    return NOERROR;
}


#ifdef _DEBUG
void CBoxLink::AssertValid(void) const {

    CPropObject::AssertValid();

    ASSERT(m_pDoc);
    ASSERT(m_psockTail);
    ASSERT(m_psockHead);

    if (m_fConnected) {
        ASSERT(m_psockHead->m_plink == this);
	ASSERT(m_psockTail->m_plink == this);
    }
    else {
        ASSERT(m_psockHead->m_plink == NULL);
	ASSERT(m_psockTail->m_plink == NULL);
    }
}
#endif // _DEBUG

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\mainfrm.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// mainfrm.h : declares CMainFrame
//

class CSeekDialog : public CDialogBar
{
    BOOL m_bDirty;

public:
    CSeekDialog( );
    ~CSeekDialog( );

   // overrides

   // Generated message map functions
   //{{AFX_MSG(CSeekDialog)
   virtual void OnCancel( );
   virtual void OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar );
   virtual void OnTimer( UINT nTimer );
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

public:

   BOOL DidPositionChange( );
   double GetPosition( );
   void SetPosition( double pos );
   BOOL IsSeekingRandom( );
};

class CMainFrame : public CFrameWnd
{
    DECLARE_DYNCREATE(CMainFrame)

protected:
    // control bar embedded members
    CStatusBar      m_wndStatusBar;
    CToolBar        m_wndToolBar;
    CToolTipCtrl   *m_pToolTip;

    BOOL PreTranslateMessage(MSG* pMsg);
    BOOL InitializeTooltips();

public:

    CSeekDialog  m_wndSeekBar;
    bool m_bSeekInit;
    bool m_bSeekEnabled;
    int  m_nSeekTimerID;
    HWND m_hwndTimer;
    virtual void ToggleSeekBar( BOOL NoReset = TRUE );

public:
    // construction and destruction
    CMainFrame();
    virtual ~CMainFrame();

public:
    // diagnostics
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

public:
    // operations
    virtual void SetStatus(unsigned idString);
    virtual void GetMessageString( UINT nID, CString& rMessage ) const;

protected:
    // generated message map
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnClose();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    afx_msg void MyOnHelpIndex();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\propobj.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// propobj.cpp
//

// Implementation of CPropObject. See propobj.h


#include "stdafx.h"

// *
// * CPropObject
// *

IMPLEMENT_DYNAMIC(CPropObject, CObject)

//
// Constructor
//
CPropObject::CPropObject()
    : m_pDlg(NULL) {
}


//
// Destructor
//
CPropObject::~CPropObject() {

    DestroyPropertyDialog();

}


#ifdef _DEBUG
//
// AssertValid
//
void CPropObject::AssertValid(void) const {

    CObject::AssertValid();

}

//
// Dump
//
// Output this object to the supplied dump context
void CPropObject::Dump(CDumpContext& dc) const {

    CObject::Dump(dc);

    if (m_pDlg != NULL) {
        dc << CString("Dialog exists");
    }
    else {
        dc << CString("No dialog exists");
    }
}
#endif // _DEBUG


//
// CanDisplayProperties
//
// returns true if this object has at least one of IPin,
// IFileSourceFilter, ISpecifyPropertyPages, and IFileSinkFilter
//
// !!! this function tends to throw a lot of exceptions. I think using
// CQCOMInt may be inapropriate, or perhaps needs a 'do you support
// this?' function.
BOOL CPropObject::CanDisplayProperties(void) {

    try {

        CQCOMInt<ISpecifyPropertyPages> Interface(IID_ISpecifyPropertyPages, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    // we can display a page for each filters pin
    try {

        CQCOMInt<IBaseFilter> IFilt(IID_IBaseFilter, pUnknown());
        CPinEnum Next(IFilt);

        IPin *pPin;
	if (0 != (pPin = Next())) { // at least one pin
	    pPin->Release();
	    return TRUE;
	}
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IFileSourceFilter> Interface(IID_IFileSourceFilter, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IFileSourceFilter> Interface(IID_IFileSinkFilter, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    try {

        CQCOMInt<IPin> Interface(IID_IPin, pUnknown());
	return TRUE;
    }
    catch (CHRESULTException) {
        // probably E_NOINTERFACE. Eat it and try the next...
    }

    return FALSE;
}


//
// CreatePropertyDialog
//
// create & display the property dialog
// if called when the dialog exists, it shows the existing dialog
void CPropObject::CreatePropertyDialog(CWnd *pParent) {

    try {

        if (m_pDlg->GetSafeHwnd() == NULL) {

            CString szCaption = Label();
	    szCaption += CString(" Properties");

            delete m_pDlg;
            m_pDlg = new CVfWPropertySheet(pUnknown(), szCaption, pParent);

        }

    }
    catch (CHRESULTException) {

        AfxMessageBox(IDS_CANTDISPLAYPROPERTIES);
    }

    ShowDialog();

}


//
// DestroyPropertyDialog
//
// hide and destroy the property dialog
// Nul-op if the dialog does not exist
void CPropObject::DestroyPropertyDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {
        m_pDlg->DestroyWindow();
    }

    delete m_pDlg;
    m_pDlg = NULL;
}


//
// ShowDialog
//
// show the dialog in screen. nul-op if already on screen
void CPropObject::ShowDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {

        m_pDlg->ShowWindow(SW_SHOW);
	m_pDlg->SetForegroundWindow();
    }
}


//
// HideDialog
//
// hide the dialog. nul-op if already hidden
void CPropObject::HideDialog(void) {

    if (m_pDlg->GetSafeHwnd() != NULL) {

        m_pDlg->ShowWindow(SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\mainfrm.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// mainfrm.h : defines CMainFrame
//

#include "stdafx.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


//IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)
IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars


// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
    // same order as in the bitmap 'toolbar.bmp'
    ID_FILE_NEW,
    ID_FILE_OPEN,
    ID_FILE_SAVE,
        ID_SEPARATOR,
    ID_FILE_PRINT,
        ID_SEPARATOR,
    ID_EDIT_CUT,
    ID_EDIT_COPY,
    ID_EDIT_PASTE,
        ID_SEPARATOR,
    ID_QUARTZ_RUN,
    ID_QUARTZ_PAUSE,
    ID_QUARTZ_STOP,
        ID_SEPARATOR,
    ID_INSERT_FILTER,
    ID_QUARTZ_DISCONNECT,
        ID_SEPARATOR,    
    ID_CONNECT_TO_GRAPH,
//    ID_FILE_NEW,
        ID_SEPARATOR,    
    ID_WINDOW_REFRESH,
        ID_SEPARATOR,
    ID_APP_ABOUT,
};

#define NUM_BUTTONS  (sizeof(buttons) / sizeof(buttons[0]))


// indicators
static UINT BASED_CODE indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};


/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction


CMainFrame::CMainFrame()
{
}


CMainFrame::~CMainFrame()
{
}


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics


#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}
#endif //_DEBUG


#ifdef _DEBUG
void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// operations


/* SetStatus(idString)
 *
 * Set the status bar text to the string resource <idString>.
 */
void CMainFrame::SetStatus(unsigned idString)
{
    CString     str;

    try
    {
        str.LoadString(idString);
        m_wndStatusBar.SetPaneText(0, str);
    }
    catch (CException *e)
    {
        m_wndStatusBar.SetPaneText(0, "Warning: almost out of memory!", TRUE);
	e->Delete();
    }
}

void CMainFrame::GetMessageString( UINT nID, CString& rMessage ) const
{
    // The text displayed in the status bar when Edit..Redo is highlighted
    // depends on whether we are allowing a redo or a repeat.
    if( nID == ID_EDIT_REDO ){
        CBoxNetDoc *pDoc = (CBoxNetDoc *) ((CFrameWnd *)this)->GetActiveDocument();

        if( pDoc->CanRedo() )
            rMessage.LoadString( ID_EDIT_REDO );
        else
            rMessage.LoadString( ID_EDIT_REPEAT );
    } else
        CFrameWnd::GetMessageString( nID, rMessage );
}

        
        

/////////////////////////////////////////////////////////////////////////////
// generated message map

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_HELP_INDEX, CMainFrame::MyOnHelpIndex)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// message callback functions


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{

    EnableDocking(CBRS_FLOAT_MULTI);

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.Create(this) ||
        !m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
        !m_wndToolBar.SetButtons(buttons, sizeof(buttons)/sizeof(UINT)))
    {
        TRACE("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE("Failed to create status bar\n");
        return -1;      // fail to create
    }

    DragAcceptFiles();

    m_bSeekInit = false;
    m_bSeekEnabled = true;
    m_nSeekTimerID = 0;

    InitializeTooltips();
    return 0;
}

BOOL CMainFrame::InitializeTooltips()
{
    int rc;

    // Create the tooltip control
    m_pToolTip = new CToolTipCtrl;
    if(!m_pToolTip->Create(this, TTS_ALWAYSTIP))
    {
       TRACE(TEXT("Unable To create ToolTip\n"));
       return FALSE;
    }

    // Set some tooltip defaults
    m_pToolTip->SetDelayTime(TTDT_AUTOPOP, 5000);  /* 5s  */
    m_pToolTip->SetDelayTime(TTDT_INITIAL, 1000);  /* 1s */

    // Add tooltip strings for the toolbar controls
    RECT rect;
    int ID[NUM_BUTTONS] = {
        ID_FILE_NEW,
        ID_FILE_OPEN,
        ID_FILE_SAVE,
            ID_SEPARATOR,
        ID_FILE_PRINT,
            ID_SEPARATOR,
        ID_EDIT_CUT,
        ID_EDIT_COPY,
        ID_EDIT_PASTE,
            ID_SEPARATOR,
        ID_QUARTZ_RUN,
        ID_QUARTZ_PAUSE,
        ID_QUARTZ_STOP,
            ID_SEPARATOR,
        ID_INSERT_FILTER,
        ID_QUARTZ_DISCONNECT,
            ID_SEPARATOR,    
        ID_CONNECT_TO_GRAPH,
            ID_SEPARATOR,    
        ID_WINDOW_REFRESH,
            ID_SEPARATOR,
        ID_APP_ABOUT,
    };

    // Loop through the toolbar buttons and add a tooltip for each
    for (int i=0; i<NUM_BUTTONS; i++)
    {
        // Don't add tooltips for separator items
        if (ID[i] == ID_SEPARATOR)
            continue;

        // Get the bounding rect for this button
        m_wndToolBar.GetItemRect(i, &rect);

        // Add a tooltip for this button, using its text ID, 
        // bounding rect, and resource ID
        rc = m_pToolTip->AddTool(&m_wndToolBar, ID[i], &rect, ID[i]); 
    }

    // Activate the tooltip control
    m_pToolTip->Activate(TRUE);
    return TRUE;
}

BOOL CMainFrame::PreTranslateMessage(MSG* pMsg) 
{
    // Let the tooltip process the message, if appropriate
    if (m_pToolTip)
        m_pToolTip->RelayEvent(pMsg);
	
    // Pass along all messages untouched
	return CFrameWnd::PreTranslateMessage(pMsg);
}


afx_msg void CMainFrame::MyOnHelpIndex()
{
    // get path to graphedt.exe and keep just the directory name
    TCHAR szHelpPath[MAX_PATH];
    GetModuleFileName(0, szHelpPath, MAX_PATH);
    *_tcsrchr(szHelpPath, TEXT('\\')) = 0;

    // note: if you change the name of the help file, change
    // IDS_CANT_LOAD_HELP in graphedt.rc to match
    
    HINSTANCE h = ShellExecute(NULL, // hwnd
                               NULL, // verb (usually defaults to "open")
                               TEXT("graphedit.chm"),
                               NULL, // arguments
                               szHelpPath,
                               SW_SHOWNORMAL);

    if(h <= (HINSTANCE)32)
    {
        // docs say ShellExecute doesn't set the last error (but the
        // complicated -Ex version does), so just report some generic
        // rather than trying to decode the SE_ errors

        CString strMessage;
        strMessage.LoadString( IDS_CANT_LOAD_HELP );
        AfxMessageBox( strMessage );
    }
}


void CMainFrame::OnClose() 
{
    // Disable and destroy the tooltip control
    if (m_pToolTip)
    {
        m_pToolTip->Activate(FALSE);
        delete m_pToolTip;
        m_pToolTip = 0;
    }
	
	CFrameWnd::OnClose();
}


void CMainFrame::ToggleSeekBar( BOOL bNoReset )
{
    // Create the seek bar the first time through
    if( !m_bSeekInit )
    {
        m_bSeekInit = true;
        m_wndSeekBar.Create( this, IDD_SEEKBAR, CBRS_TOP, IDD_SEEKBAR );

        HWND h = ::GetDlgItem( m_wndSeekBar.m_hWnd, IDC_SEEKSLIDER );
        m_wndSeekBar.ShowWindow( SW_SHOW );
        m_wndSeekBar.EnableDocking( 0 );

        ::SendMessage( h, TBM_SETRANGE, 0, MAKELONG( 0, 10000 ) );
        ::SendMessage( h, TBM_SETPAGESIZE, 0, 500 );

        return;
    }

    if( !bNoReset )
    {
        m_wndSeekBar.ShowWindow( SW_SHOW );
        return;
    }

    if( m_bSeekEnabled == true )
    {
        // Use the global ::Kill/::Set timer functions to avoid confusion
        // between CFrameWnd and CBoxNetDoc methods & handles
        int nKilled = ::KillTimer( m_hwndTimer, m_nSeekTimerID );
        m_nSeekTimerID = 0;
        m_wndSeekBar.EnableWindow(FALSE);
        m_bSeekEnabled = false;
    }
    else
    {
        m_bSeekEnabled = true;
        m_wndSeekBar.EnableWindow(TRUE);

        // If the seek timer is NOT already running, start it
        if (!m_nSeekTimerID)
            m_nSeekTimerID = ::SetTimer( m_hwndTimer, CBoxNetView::TIMER_SEEKBAR, 200, NULL );
    }

    // Get the handle of the "View" menu
    CMenu *pMainMenu = GetMenu();
    CMenu *pMenu = pMainMenu->GetSubMenu(2);        

    // Update the seekbar check mark
    if (pMenu != NULL)
    {
        if (m_bSeekEnabled)
            pMenu->CheckMenuItem(ID_VIEW_SEEKBAR, MF_CHECKED | MF_BYCOMMAND);
        else
            pMenu->CheckMenuItem(ID_VIEW_SEEKBAR, MF_UNCHECKED | MF_BYCOMMAND);
    }
}

BEGIN_MESSAGE_MAP(CSeekDialog, CDialogBar)
   //{{AFX_MSG_MAP(CSeekDialog)
    ON_WM_HSCROLL()
    ON_WM_TIMER()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSeekDialog::CSeekDialog()
: CDialogBar( )
{
    m_bDirty = FALSE;
}

CSeekDialog::~CSeekDialog( )
{
}

void CSeekDialog::OnCancel( )
{
    ShowWindow( FALSE );
}

BOOL CSeekDialog::DidPositionChange( )
{
    if( m_bDirty )
    {
        m_bDirty = false;
        return true;
    }
    return false;
}

double CSeekDialog::GetPosition( )
{
    HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
    if( !h )
    {
        return 0.0;
    }

    LRESULT Pos = ::SendMessage( h, TBM_GETPOS, 0, 0 );
    return double( Pos ) / 10000.0;
}

void CSeekDialog::SetPosition( double pos )
{
    HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
    if( !h )
    {
        long e = GetLastError( );
        return;
    }
    ::SendMessage( h, TBM_SETSEL, (WPARAM)(BOOL) TRUE, (LPARAM)MAKELONG( 0, pos * 10000 ) );
}

void CSeekDialog::OnHScroll( UINT nSBCode, UINT nPos, CScrollBar* pScrollBar )
{
    m_bDirty = true;
}

void CSeekDialog::OnTimer( UINT TimerID )
{
    static long counter = 0;
    counter++;
    if( counter < 30 )
    {
        return;
    }

    counter = 0;

    if( IsDlgButtonChecked( IDC_RANDOM ) )
    {
        long Pos = rand( ) % 10000;
        HWND h = ::GetDlgItem( m_hWnd, IDC_SEEKSLIDER );
        ::SendMessage( h, TBM_SETPOS, TRUE, Pos );
        m_bDirty = true;
    }
}

BOOL CSeekDialog::IsSeekingRandom( )
{
    return ::IsDlgButtonChecked( m_hWnd, IDC_RANDOM );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\gutil.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// gutil.h
//
// Defines utility functions not specific to this application.
//

/////////////////////////////////////////////////////////////////////////////
// Utility integer and boolean functions:
//
// imin(i, j) returns the minimum of i and j.
// imax(i, j) returns the maximum of i and j.
// iabs(i) returns the absolute value of i.
// ibound(i, iLower, iUpper) returns i restricted to the range [iLower,iUpper].
// ioutbound(i, iLower, iUpper) returns 0 if i is in the range [iLower,iUpper],
//      or the amount by which i is outside that range otherwise.
// isnap(i, iGrid) returns multiple of iGrid nearest to i
// iswap(pi, pj) swaps <*pi> with <*pj>
// fnorm(f) "normalizes" BOOL value f, i.e. turns nonzero values into 1.
//

inline int imin(int i1 , int i2)
{
    if (i1 < i2)
        return i1;
    else
        return i2;
}

inline int imax(int i1 , int i2)
{
    if (i1 > i2)
        return i1;
    else
        return i2;
}

inline int iabs(int i)
{
    if (i < 0)
        return -i;
    else
        return i;
}

inline int ibound(int i, int iLower, int iUpper)
{
    if (i < iLower)
        i = iLower;
    else
    if (i > iUpper)
        i = iUpper;

    return i;
}

inline int ioutbound(int i, int iLower, int iUpper)
{
    if (i < iLower)
        return iLower - i;
    else
    if (i > iUpper)
        return i - iUpper;
    else
        return 0;
}

inline int isnap(int i, int iGrid)
{
    BOOL fNeg = (i < 0);                    // "%" isn't reliable for i < 0
    int j = (fNeg ? -i : i) + iGrid / 2;    // add half of <iGrid>
    int k = j - j % iGrid;                  // round down
    return (fNeg ? -k : k);
}

inline void iswap(long *pi, long *pj)
{
    long        iTmp;

    iTmp = *pi;
    *pi = *pj;
    *pj = iTmp;
}

inline BOOL fnorm(BOOL f)
{
    if (f)
        return 1;
    else
        return 0;
}


/////////////////////////////////////////////////////////////////////////////
// other utility functions
//


CSize inline PASCAL NegateSize(CSize siz)
{
    return CSize(-siz.cx, -siz.cy);
}


void FAR PASCAL NormalizeRect(CRect *prc);
void FAR PASCAL InvertFrame(CDC *pdc, CRect *prcOuter, CRect *prcInner);


//
// CDeleteList
//
// A CList that will optionally delete the objects it is
// storing in its destructor. Construct with parameter TRUE (the default)
// if you want objects deleted, use FALSE otherwise.
// Also provides a member to do delete & remove each item on the list
template<class TYPE, class ARG_TYPE>
class CDeleteList : public CList<TYPE, ARG_TYPE> {

public:

    CDeleteList(BOOL DestructDelete = TRUE) : m_DestructDelete(DestructDelete) {}
    CDeleteList(BOOL DestructDelete, int nBlockSize) : CList<TYPE, ARG_TYPE>(nBlockSize),
                                                       m_DestructDelete(DestructDelete) {}


    ~CDeleteList() {

        if (m_DestructDelete) {
            FreeAll();
        }
    }

    void DeleteRemoveAll(void) {  FreeAll(); }

protected:

    BOOL m_DestructDelete;

    void FreeAll(void) {

        while(GetCount() > 0) {
            delete RemoveHead();
        }
    }
};


//
// CFreeList
//
// A CObject version of a CDeleteList. Deletes its stored objects
// on destruction
class CFreeList : public CDeleteList<CObject *, CObject *> {

};


//
// CMaxList
//
// A CFreeList that is restricted to at most m_cObjMax objects.
// It deletes any surplus _at the next call_ that adds something.
// therefore the list can be temporarily longer.
class CMaxList : public CFreeList {
public:

    CMaxList(int nBlockSize = 3) : m_cObjMax(nBlockSize) {}

    POSITION AddHead(CObject* pobj) {
        RestrictLength();
        return CFreeList::AddHead(pobj);
    }

    POSITION AddTail(CObject* pobj) {
        RestrictLength();
        return CFreeList::AddTail(pobj);
    }

    void AddHead(CObList* pNewList) {
        RestrictLength();
        CFreeList::AddHead(pNewList);
    }

    void AddTail(CObList* pNewList) {
        RestrictLength();
        CFreeList::AddTail(pNewList);
    }

    POSITION InsertBefore(POSITION pos, CObject* pobj) {
        RestrictLength();
        return CFreeList::InsertBefore(pos, pobj);
    }

    POSITION InsertAfter(POSITION pos, CObject* pobj) {
        RestrictLength();
        return CFreeList::InsertAfter(pos, pobj);
    }

private:

    const int   m_cObjMax;      // max. number of objects in list

    void RestrictLength(void) {

        while (GetCount() >= m_cObjMax) {

            TRACE(TEXT("restrict length\n"));
            delete RemoveTail();
        }
    }

};


//
// --- Quartz Utilities ---
//
typedef HRESULT STDAPICALLTYPE OLECOCREATEPROC(REFCLSID,LPUNKNOWN,DWORD,REFIID,LPVOID *);

//
// CQCOMInt
//
// CCOMInt style class that uses the _real_, UNICODE, version of CoCreateInstance
// so that I can hack around MFCANS32 (wonderful tool that it is)
template<class I>
class CQCOMInt {

public:

    // -- Constructors --

    // CoCreate
    CQCOMInt<I>( REFIID    riid					// get this interface
               , REFCLSID  rclsid				// get the interface
    								// from this object
	       , LPUNKNOWN pUnkOuter    = NULL			// controlling unknown
               , DWORD     dwClsContext = CLSCTX_INPROC_SERVER	// CoCreate options
               							// default is suitable
               							// for dll servers
               ) {

        //
        // Library will be FreeLibrary'ed in the destructor. We don't unload
        // before to avoid unnecessary load / unloads of the library.
        //
	m_hLibrary = LoadLibrary("OLE32.dll");

	OLECOCREATEPROC *CoCreate = (OLECOCREATEPROC *) GetProcAddress(m_hLibrary, "CoCreateInstance");

        HRESULT hr = CoCreate( rclsid
	                     , pUnkOuter
                             , dwClsContext
                             , riid
                             , (void **) &m_pInt
                             );
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // QueryInterface
    CQCOMInt<I>( REFIID   riid	// get this interface
              , IUnknown *punk	// from this interface
              ) {
	m_hLibrary = 0;
        HRESULT hr = punk->QueryInterface(riid, (void **) &m_pInt);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }

    // copy
    CQCOMInt<I>(const CQCOMInt<I> &com) {
	m_hLibrary = 0;
         m_pInt = com;
         (*this)->AddRef();

    }

    // existing pointer.
    CQCOMInt<I>(I *pInt) {
	m_hLibrary = 0;
        if (pInt == NULL) {
            throw CHRESULTException(E_NOINTERFACE);
        }

        m_pInt = pInt;

	(*this)->AddRef();
    }


    // assignment operator
    virtual CQCOMInt<I>& operator = (const CQCOMInt<I> &com) {

        if (this != &com) { 	// not i = i

	    (*this)->Release();
            m_pInt = com;
            (*this)->AddRef();
	}

        return *this;
    }


    // destructor
    virtual ~CQCOMInt<I>() {
        m_pInt->Release();

	if (m_hLibrary)
            FreeLibrary(m_hLibrary);
    }


    // -- comparison operators --
    virtual BOOL operator == (IUnknown *punk) const {

        CQCOMInt<IUnknown> IUnk1(IID_IUnknown, punk);
        CQCOMInt<IUnknown> IUnk2(IID_IUnknown, *this);

        return ( ((IUnknown *)IUnk1) == ((IUnknown *)IUnk2) );
    }

    virtual BOOL operator != (IUnknown *punk) const {

        return !(*this == punk);
    }


    // cast to interface pointer
    virtual operator I *() const { return m_pInt; }


    // dereference
    virtual I *operator->() { return m_pInt; }

    virtual I &operator*() { return *m_pInt; }

private:

    I *m_pInt;

    HINSTANCE m_hLibrary;    // remember the handle to the library for FreeLibrary

    // array dereferencing seems to make no sense.
    I &operator[] (int i) { throw CHRESULTException(); return *m_pInt; }
};


//
// CIPin
//
// Wrapper for the IPin interface
class CIPin : public CQCOMInt<IPin> {

public:

    CIPin(IPin *pIPin) : CQCOMInt<IPin>(pIPin) {}
    virtual ~CIPin() {}

    BOOL  operator == (CIPin& pin);	// tests the names to be equal.
    BOOL  operator != (CIPin& pin) { return !(pin == *this); }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\propobj.h ===
// Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
//
// propobj.h
//

class CVfWPropertySheet;

//
// CPropObject
//
// A CObject derived class for objects that can display
// property page dialogs. classes such as CBoxLink, CBox &
// CBoxSocket are derived from this.
class CPropObject : public CObject {
protected:

    CPropObject();
    virtual ~CPropObject();

public:

#ifdef _DEBUG
    // -- CObject Derived diagnostics --
    virtual void AssertValid(void) const;
    virtual void Dump(CDumpContext& dc) const;
#endif

    // -- Property Dialog support --

    // true if a property dialog can be created for display
    virtual BOOL CanDisplayProperties(void);

    // create & display the property dialog
    // if called when the dialog exists, it shows the existing dialog
    // if pParent is null then the apps main window is the parent
    virtual void CreatePropertyDialog(CWnd *pParent = NULL);

    // hide and destroy the property dialog
    // Nul-op if the dialog does not exist
    virtual void DestroyPropertyDialog(void);

    // show the dialog in screen. nul-op if already on screen
    virtual void ShowDialog(void);

    // hide the dialog. nul-op if already hidden
    virtual void HideDialog(void);

public:
    // -- required helper functions --
    // these should be defined in a superclass, but they are not...

    virtual CString Label(void) const = 0;
    virtual IUnknown *pUnknown(void) const = 0;

    DECLARE_DYNAMIC(CPropObject)

private:

    CVfWPropertySheet *m_pDlg;	// the property sheet for all property pages
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\qerror.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// qerror.cpp

#include "stdafx.h"


void DisplayQuartzError( HRESULT hr )
{
    /* Message example
     *  <Error returned by AMGetErrorText>
     *
     */
    TCHAR szQMessage[MAX_ERROR_TEXT_LEN];

    if( AMGetErrorText( hr, szQMessage, MAX_ERROR_TEXT_LEN) > 0 ){
        AfxMessageBox( szQMessage );
    }

}

void DisplayQuartzError( UINT nID, HRESULT hr )
{
    /* Message example
     *  Unable to stop graph
     *
     *  Unspecified error (0x80004005)
     */
    CString strMessage;
    CString strCode;
    CString strCodeMessage;
    TCHAR szQMessage[MAX_ERROR_TEXT_LEN];

    strMessage.LoadString( nID );
    strCode.FormatMessage( IDS_RETURN_CODE, hr );

    if( AMGetErrorText( hr, szQMessage, MAX_ERROR_TEXT_LEN) > 0 ){
        strCodeMessage = szQMessage + CString(" ");
    }

    strMessage += "\n\n" + strCodeMessage + strCode;

    AfxMessageBox( strMessage );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\qerror.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// qerror.h

void DisplayQuartzError( HRESULT hr );
void DisplayQuartzError( UINT nID, HRESULT hr );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\propsite.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
#ifndef _PROPSITE_H_
#define _PROPSITE_H_

//
// CPropertySite
//
// This class implements the individual property sites for each
// IPropertyPage we have got. Ie. it manages the OLE control property page
// object for the overall property pages frame.
//
// The IPropertyPage talks through this class' IPropertySite interface
// to the PropertySheet, the overall frame of all property pages.
//
// The base class of CPropertySite is CPropertyPage. This class is a
// MFC class and should not be confused with the IPropertyPage interface.
//
//      IPropertyPage = Interface of some objects whose property page we
//                      want to display.
//
//      CPropertyPage = MFC class which helps us to implement the wrapper
//                      around the IPropertyPage interface.
//
// Note that the property page of IPropertyPage is implemented at a different
// location and will differ for each object. We only know that it supports
// the IPropertyPage interface through which we communicate with these objects.
//

class CPropertySite : public CPropertyPage, public IPropertyPageSite {

public:

    //
    // IPropertySite interface
    //
    STDMETHODIMP OnStatusChange(DWORD flags);
    STDMETHODIMP GetLocaleID(LCID *pLocaleID);
    STDMETHODIMP GetPageContainer(IUnknown **ppUnknown);
    STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

    //
    // IUnknown interface
    //
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // CPropertyPage overides
    //
    BOOL OnSetActive();     // This property page gains the focus.
    BOOL OnKillActive();    // This property page loses focus.
                            // Validate all data and return FALSE if an
                            // error occurs.
                            // Note, this does not commit the data!!

    int OnCreate(LPCREATESTRUCT);
    void OnDestroy();

    // Allow the size to be retrieved.
    SIZE GetSize( ){ return m_PropPageInfo.size; }

    //
    // OnOK and OnCancel are methods specified by CPropertyPage.
    // For modal property pages/sheets they get called from CPropertySheet.
    // Since we work with a modeless property sheet, they are of no use
    // for us. All OK and Cancel operations are managed by CPropertySheet
    //
    void OnOK() {}
    void OnCancel() {}

    //
    // CPropertySite methods
    //
    CPropertySite(CVfWPropertySheet *, const CLSID *);
    ~CPropertySite();

    HRESULT Initialise(ULONG, IUnknown **);       // must be called immeadetly after construction
    void InitialiseSize(SIZE size); // must be called before creating page
    
    void UpdateButtons();
    HRESULT CleanUp();

    void OnHelp();      // Called after the help button has been pressed.
    void OnSiteApply();     // Called after the apply button has been pressed.
    BOOL IsPageDirty();
    BOOL PreTranslateMessage(MSG *); // Called from CVfWPropertySheet.

protected:

    void HelpDirFromCLSID(const CLSID* clsID, LPTSTR pszPath, DWORD dwPathSize);

    CVfWPropertySheet * m_pPropSheet;  // pointer to the overall frame of all
                                // property sheets.

    //
    // Intelligent pointer to IPropertyPage. Creates the property page
    // object from a CLSID and Releases it on destruction.
    //
    CQCOMInt<IPropertyPage> m_pIPropPage;


    PROPPAGEINFO m_PropPageInfo; // Information on the property page we wrap

    //
    // m_hrDirtyPage indicates whether the page is dirty or clean
    //  -> (IPropertyPage::IsPageDirty == S_FALSE).
    // The state of this flag also specifies the appearance of the Apply
    // button. (S_FALSE = disabled, S_OK = enabled)
    //
    HRESULT m_hrDirtyPage;

    //
    // m_fHelp indicates whether the help button should be enabled.
    // This will be determined from the value of pszHelpFile in the
    // PROPPAGEINFO structure obtained from IPropertyPage::GetPageInfo
    //
    BOOL m_fHelp;

    //
    // Reference counter for IUnknown
    //
    ULONG m_cRef;

    // Rectangle of our site
    CRect m_rcRect;

    BOOL m_fShowHelp;     // True if we called WinHelp for this page

    // Flag whether this page is active - used to avoid duplicate calls
    // to IPropertyPage::Activate() (MFC calls OnSetActive twice).
    BOOL m_fPageIsActive;

    const CLSID* m_CLSID;

    // holds DLGTEMPLATE so we don't have to allocate it. dword
    // aligned.
    DWORD m_pbDlgTemplate[30];  

    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\propsht.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// propsht.cpp
//

#include "stdafx.h"

//
// Define the GUIDs for the property pages and their interfaces
//
#include <initguid.h>
#include <propguid.h>

BEGIN_MESSAGE_MAP(CVfWPropertySheet, CPropertySheet)

    ON_WM_CREATE()

    ON_COMMAND(IDOK, OnOK)
    ON_COMMAND(IDCANCEL, OnCancel)
    ON_COMMAND(IDC_APPLY, OnApply)
    ON_COMMAND(IDC_PROP_HELP, OnHelp)

END_MESSAGE_MAP()

//
// Constructor
//
// Through the IUnknown pointer passed to us we might be able to
// get:
//
//   IBaseFilter, IPin, IFileSourceFilter, IFileSinkFilter or ISpecifyPropertyPages
//
// each of these has at least one IPropertyPage interface for us.
// (the ones for IBaseFilter, IPin, IFileSinkFilter and IFileSourceFilter
// are provided by proppage.dll )
//
CVfWPropertySheet::CVfWPropertySheet(IUnknown *pUnknown, CString szCaption, CWnd * wnd)
  : m_butOK(NULL)
  , m_fButtonsCreated(FALSE)
  , m_butApply(NULL)
  , m_butCancel(NULL)
  , m_butHelp(NULL)
  , m_fAnyChanges(FALSE)
  , CPropertySheet(szCaption, wnd)
{
    UINT iPages = 0;

    try {
        //
        // Create the four buttons
        //
        m_butOK     = new CButton();
        m_butCancel = new CButton();
        m_butApply  = new CButton();
        m_butHelp   = new CButton();

        //
        // First check whether this is a connected pin to make sure 
        // that we search both pins for SpecificPages
        //
        try {
            CQCOMInt<IPin> pPin(IID_IPin, pUnknown);

            IPin * pConnected = NULL;
            HRESULT hr = pPin->ConnectedTo( &pConnected );
            if( SUCCEEDED( hr ) )
            {
                // handle the connected pin first
                iPages += AddSpecificPages(pConnected);
                pConnected->Release();
            }                
        }
        catch (CHRESULTException) {
            // do nothing
        }

        iPages += AddSpecificPages(pUnknown);
        iPages += AddFilePage(pUnknown);
        iPages += AddPinPages(pUnknown);

        if (0 == iPages) {
            throw CE_FAIL();
        }


        // compute dimensions large enough to hold largest
        // proppage. tell all proppages.
        // 
        SIZE sizeMax = {0, 0};
        CPropertyPage *ppTmp;
        for(int iPage = 0; iPage < GetPageCount() && (ppTmp = GetPage(iPage)); iPage++)
        {
            CPropertySite *pcps = (CPropertySite *)ppTmp;
            SIZE size = pcps->GetSize();
            sizeMax.cx = max(sizeMax.cx, size.cx);
            sizeMax.cy = max(sizeMax.cy, size.cy);
        }
        for(iPage = 0; iPage < GetPageCount() && (ppTmp = GetPage(iPage)); iPage++)
        {
            CPropertySite *pcps = (CPropertySite *)ppTmp;
            pcps->InitialiseSize(sizeMax);
        }



        // create the property sheet but leave it invisible as we
        // will have to add the buttons to it
        if (!Create(wnd, WS_SYSMENU | WS_POPUP | WS_CAPTION | DS_MODALFRAME)) {
            throw CE_FAIL();
        }

		ASSERT( GetActivePage() );
		ASSERT( GetActivePage()->m_hWnd );

        CRect rcBoxSize(0, 0, 50, 14);
        GetActivePage()->MapDialogRect(&rcBoxSize);

        CString szTemp;

        szTemp.LoadString(IDS_OK);
        m_butOK->Create(szTemp,
                        BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                        | WS_TABSTOP | WS_GROUP,
                        rcBoxSize, this, IDOK);

        szTemp.LoadString(IDS_CLOSE);
        m_butCancel->Create(szTemp,
                            BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                            | WS_TABSTOP | WS_GROUP,
                            rcBoxSize, this, IDCANCEL);

        szTemp.LoadString(IDS_APPLY);
        m_butApply->Create(szTemp,
                           BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                           | WS_TABSTOP | WS_GROUP | WS_DISABLED,
                           rcBoxSize, this, IDC_APPLY);

        szTemp.LoadString(IDS_HELP);
        m_butHelp->Create(szTemp,
                          BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE
                          | WS_TABSTOP | WS_GROUP | WS_DISABLED,
                          rcBoxSize, this, IDC_PROP_HELP);


        //
        // Position the buttons on the property sheet
        //
        // The buttons are in the order Ok, Cancel, Apply and Help.
        //
        // The y-coordinate is 2 dialog units + the buttons size from the
        // bottom of the client area.
        //
        // On the x-coordinate there is a gap of 4 dialog units before each
        // button. Thus the x-ths button has a gap of
        //
        //    x * iSpacing + (x-1) * ButtonWidth
        //
        // between itself and the lefthand corner.
        //
        CRect rc, rcClient;
        GetWindowRect(&rc);
        GetClientRect(&rcClient);

        CRect rcSpacing(4, 2, 0, 0);
        GetActivePage()->MapDialogRect(&rcSpacing);
        const int iXSpacing = rcSpacing.left;
        const int iYSpacing = rcSpacing.top;

        // Make sure that the property page is wide enough for the buttons
		int iRight = rcClient.left + ( rcBoxSize.Width() + iXSpacing) * 4;

        if( rcClient.right < iRight )
            rc.right += rcClient.left + (iRight - rcClient.right);

        // increase the property sheet so there is space for our
        // buttons
        rc.bottom += rcBoxSize.Height() + iYSpacing * 2;

		MoveWindow( &rc );

        // to position the buttons we need the client rect (window - title)
        GetClientRect( &rc );

        m_butOK->MoveWindow( iXSpacing,
                                rc.Height() - rcBoxSize.Height() - iYSpacing,
                                rcBoxSize.Width(),
                                rcBoxSize.Height(),
                                SWP_SHOWWINDOW );

        m_butCancel->MoveWindow( 2 * iXSpacing + rcBoxSize.Width(),
                                 rc.Height() - rcBoxSize.Height() - iYSpacing,
                                 rcBoxSize.Width(),
                                 rcBoxSize.Height());

        m_butApply->MoveWindow( 3* iXSpacing + 2 * rcBoxSize.Width(),
                                rc.Height() - rcBoxSize.Height() - iYSpacing,
                                rcBoxSize.Width(),
                                rcBoxSize.Height());

        m_butHelp->MoveWindow( 4* iXSpacing + 3 * rcBoxSize.Width(),
                               rc.Height() - rcBoxSize.Height() - iYSpacing,
                               rcBoxSize.Width(),
                               rcBoxSize.Height());

        m_fButtonsCreated = TRUE;

        GetActiveSite()->UpdateButtons();

        ShowWindow( SW_SHOW );

    }
    catch (CHRESULTException) {
        Cleanup();
        throw;
    }

}


//
// Destructor
//
// Call Cleanup again - might have been missed.
//
CVfWPropertySheet::~CVfWPropertySheet()
{
    Cleanup();
}


//
// AddSpecificPages
//
// Given an IUnknown pointer we try to obtain a ISpecifyPropertyPages inter-
// face.
//
// If successful, a CPropertySite object is created for each IPropertyPage
// interface we obtain and added to the property pages of CPropertySheet.
//
UINT CVfWPropertySheet::AddSpecificPages(IUnknown *pUnknown)
{
    UINT iPages = 0;

    CAUUID cauuid;

    try {
        HRESULT hr;

        CQCOMInt<ISpecifyPropertyPages> IPages(IID_ISpecifyPropertyPages, pUnknown);

        hr = IPages->GetPages(&cauuid);
        if (FAILED(hr)) {
            throw CHRESULTException(hr);
        }
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet (only place we get called from)
        return(0);  // no pages created
    }

    //
    // Get the array of GUIDs for the property pages this object supports.
    //
    // Try to create as many as possible.
    //

    for (UINT count = 0; count < cauuid.cElems; count++) {

        try {
            CPropertySite* pPropSite;

            try {
                pPropSite = new CPropertySite( this, &cauuid.pElems[count] );
            } catch( CMemoryException* pOutOfMemory ) {
                pOutOfMemory->Delete();
                continue;
            }

            // AddRef the site now else something in Initialise
            // might cause the site to delete itself
            pPropSite->AddRef();

            if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
                pPropSite->CleanUp();
                pPropSite->Release();
                continue;
            }

            try {
                AddPage(pPropSite);
            } catch( CMemoryException* pOutOfMemory ) {
                pPropSite->CleanUp();
                pPropSite->Release();
                pOutOfMemory->Delete();
                continue;
            }

            iPages++;
        }
        catch (CHRESULTException) {
            // continue with next iteration
        }
    }
    
    // Free the memory allocated in ISpecifyPropertyPages::GetPages().
    ::CoTaskMemFree( cauuid.pElems );

    return(iPages);
}


//
// AddFilePage
//
// Queries IUnknown on whether it supports IFileSourceFilter. If this is
// the case add a file property page (from proppage.dll)
//
UINT CVfWPropertySheet::AddFilePage(IUnknown * pUnknown)
{
    UINT iPage = 0;

    try {
        CQCOMInt<IFileSourceFilter> IFileSource(IID_IFileSourceFilter, pUnknown);


        CPropertySite * pPropSite =
            new CPropertySite(this, &CLSID_FileSourcePropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        pPropSite->AddRef();

        if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPage++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    try {
        CQCOMInt<IFileSinkFilter> IFileSink(IID_IFileSinkFilter, pUnknown);


        CPropertySite * pPropSite =
            new CPropertySite(this, &CLSID_FileSinkPropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        pPropSite->AddRef();

        if (FAILED(pPropSite->Initialise(1, &pUnknown))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPage++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    return(iPage);
}

//
// AddPinPages
//
// Try to obtain IBaseFilter or IPin from IUnknown.
//
// For IBaseFilter, enumerate all pins and add for each a media type property
// page (provided by proppage.dll)
//
// For IPin, provide just one media type property page.
//
UINT CVfWPropertySheet::AddPinPages(IUnknown * pUnknown)
{
    UINT iPages = 0;
    IPin *pPin = NULL;

    //
    // First try to obtain the IBaseFilter interface
    //
    try {
        CQCOMInt<IBaseFilter> pFilter(IID_IBaseFilter, pUnknown);

        for (CPinEnum Next(pFilter); 0 != (pPin = Next()); iPages++) {

            CPropertySite *pPropSite =
                new CPropertySite(this, &CLSID_MediaTypePropertyPage);

            if (pPropSite == NULL) {
                throw CE_OUTOFMEMORY();
            }

            pPropSite->AddRef();
            if (FAILED(pPropSite->Initialise(1, (IUnknown **) &pPin))) {
                pPropSite->CleanUp();
                pPropSite->Release();
                throw CE_FAIL();
            }

            AddPage(pPropSite);
            iPages++;

            pPin->Release();
            pPin = NULL;
        }
    }
    catch (CHRESULTException) {
        if (pPin) {
            pPin->Release();
            pPin = NULL;
        }
    }

    //
    // Now try for IPin
    //
    try {
        CQCOMInt<IPin> pPin(IID_IPin, pUnknown);

        CPropertySite *pPropSite =
            new CPropertySite(this, &CLSID_MediaTypePropertyPage);

        if (pPropSite == NULL) {
            throw CE_OUTOFMEMORY();
        }

        IPin * pIPin;   // temporary pointer to get proper (IUnknown **)

        pIPin = (IPin *) pPin;

        pPropSite->AddRef();
        if (FAILED(pPropSite->Initialise(1, (IUnknown **) &pIPin))) {
            pPropSite->CleanUp();
            pPropSite->Release();
            throw CE_FAIL();
        }

        AddPage(pPropSite);
        iPages++;
    }
    catch (CHRESULTException) {
        // clean up in CVfWPropertySheet::CVfWPropertySheet
    }

    return(iPages);
}

//
// OnCreate
//
int CVfWPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CPropertySheet::OnCreate(lpCreateStruct) != 0) {
        return -1;
    }

	// DO NOT add buttons here! Changes made to the window's size are
	// reset after this call

    return 0;
}

//
// Cleanup
//
// Cleanup deletes all created buttons and removes all CPropertySites from
// the CPropertySheet.
//
// This method can be run multiple times.
//
void CVfWPropertySheet::Cleanup()
{
    //
    // Delete all page sites. Note, we don't use delete, since the page
    // sites will be deleted automatically through the Release method
    // of their IUnknown interface.
    //
    while (GetPageCount() > 0) {
        CPropertySite * pPropSite = (CPropertySite *) GetPage(0);

        //
        // NOTE NOTE NOTE
        //
        // Suspected MFC bug.
        //
        // Intended code:
        //
        //   RemovePage(0);
        //
        // This asserts for every iteration. I believe that in mfc\src\dlgprop.cpp
        // in CPropertySheet::RemovePage(int), the following change is necessary:
        //    ASSERT(m_nCurPage != nPage); -> ASSERT(m_hWnd == NULL || m_nCurPage != nPage);
        //
        // Until this is fixed I am deleting the page by myself. This uses
        // the knowlegde that CPropertySheet is storing its CPropertyPages
        // in the pointer array m_pages.
        //
        //
        // <start hack>
        m_pages.RemoveAt(0);      // replace with "RemovePage(0);" once bug is fixed.
        // <end hack>

        pPropSite->CleanUp();
        pPropSite->Release();
    }

    //
    // Delete the buttons
    //
    delete m_butOK, m_butOK = NULL;
    delete m_butCancel, m_butCancel = NULL;
    delete m_butApply, m_butApply = NULL;
    delete m_butHelp, m_butHelp = NULL;
}

//////////////////////////////////////////////////////////////////////////
//
// Button handlers
//
//////////////////////////////////////////////////////////////////////////

//
// OnOK
//
// We need to call IPropertyPage::Apply for the property page of each
// CPropertySite. If all return with S_OK we can close our property sheet.
// Otherwise we cannot close the sheet, since some changes might not been
// applied.
//
void CVfWPropertySheet::OnOK()
{
    UINT iPages = GetPageCount();
    BOOL fCanQuit = TRUE;

    //
    // Apply this site first, so we can stay on it if the data is not
    // valid.
    //
    GetActiveSite()->OnSiteApply();
    if (GetActiveSite()->IsPageDirty()) {
        //
        // Data on current page is not valid.
        // The page stays active.
        //

        return;
    }

    //
    // Apply each property page and verify that none remains dirty
    // after the apply.
    // If a page remains dirty we know that the data validation failed.
    //
    for (UINT count = 0; count < iPages; count++) {

        ((CPropertySite *) GetPage(count))->OnSiteApply();
        if (((CPropertySite *) GetPage(count))->IsPageDirty()) {
            fCanQuit = FALSE;
        }
    }

    if (fCanQuit) {
        //
        // All pages have been applied. We can destroy our pages by calling
        // the OnCancel method.
        //
        OnCancel();

        return;
    }
}

//
// OnCancel
//
// Just close the sheet. All changes since the last Apply() will not
// propagate to the objects.
//
void CVfWPropertySheet::OnCancel()
{
    //
    //
    //

    // don't use EndDialog, which is for modal dialog boxes
    DestroyWindow();

    // Do cleanup here, because in an OnDestroy method, we cannot
    // remove all property pages, since the last one requires
    // m_hWnd of CPropertySheet to be NULL.
    Cleanup();
}

//
// OnApply
//
// Only apply changes of present visible property page to object.
//
void CVfWPropertySheet::OnApply()
{
    //
    // Apply the changes
    //
    GetActiveSite()->OnSiteApply();

    //
    // Are there any pages left which are dirty? Set the m_fAnyChanges
    // flag accordingly.
    //
    m_fAnyChanges = FALSE;

    UINT iPages = GetPageCount();
    for (UINT count = 0; count < iPages; count++) {
        if ( ((CPropertySite *) GetPage(count))->IsPageDirty() ) {
            m_fAnyChanges = TRUE;
        }
    }
}

//
// OnHelp
//
// Delegate the call to CPropertySite::OnHelp
//
void CVfWPropertySheet::OnHelp()
{
    GetActiveSite()->OnHelp();
}


//
// UpdateButtons
//
void CVfWPropertySheet::UpdateButtons(HRESULT hrIsDirty, BOOL fSupportHelp)
{
    ASSERT(m_butApply && m_butCancel && m_butHelp);

    if (!m_fButtonsCreated) {
        return;
    }

    //
    // We can use this method to obtain notifications of dirty pages.
    //
    if (hrIsDirty == S_OK) {
        m_fAnyChanges = TRUE;
    }

    //
    // Update Apply button
    //
    if (hrIsDirty == S_OK) {
        // we have a dirty page - enable apply button
        m_butApply->EnableWindow();
    }
    else {
        m_butApply->EnableWindow(FALSE);
    }

    //
    // Update Cancel/Close button
    //
    CString szLabel;

    if (m_fAnyChanges) {
        szLabel.LoadString(IDS_CANCEL);
    }
    else {
        szLabel.LoadString(IDS_CLOSE);
    }

    m_butCancel->SetWindowText(szLabel);

    //
    // Update Help button
    //
    if (fSupportHelp) {
        m_butHelp->EnableWindow();
    }
    else {
        m_butHelp->EnableWindow(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\propsite.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// Implementation of the CPropertySite class
//

#include "stdafx.h"

//
// CPropertySite Message Map
//

BEGIN_MESSAGE_MAP(CPropertySite, CPropertyPage)

    ON_WM_CREATE()
    ON_WM_DESTROY()

END_MESSAGE_MAP()


//
// Constructor
//
CPropertySite::CPropertySite
  (
    CVfWPropertySheet *pPropSheet,    // The class providing the frame dialog
    const CLSID *clsid         // CLSID of object providing IPropertyPage
  )
  : m_hrDirtyPage(S_FALSE)
  , m_fHelp(FALSE)
  , m_pPropSheet(pPropSheet)
  , m_pIPropPage(IID_IPropertyPage, *clsid)
  , m_cRef(0)
  , m_fShowHelp(FALSE)
  , m_fPageIsActive(FALSE)
  , m_CLSID(clsid)
  , CPropertyPage()
{
      ASSERT(pPropSheet);

      m_PropPageInfo.pszTitle = NULL;
      m_PropPageInfo.pszDocString = NULL;
      m_PropPageInfo.pszHelpFile = NULL;
}

// size in pixels
void CPropertySite::InitialiseSize(SIZE size)
{
    DLGTEMPLATE *pdt = (DLGTEMPLATE *)m_pbDlgTemplate;

    pdt->style           = WS_CHILD | WS_VISIBLE | WS_DISABLED | WS_CAPTION;
    pdt->dwExtendedStyle = 0L;
    pdt->cdit            = 0;
    pdt->x               = 0;
    pdt->y               = 0;

    // even though we're using a system font, this doesn't work. don't
    // know why. The CPropertyPage does change the font to match the
    // property sheet, so perhaps that's why. The property sheet
    // hasn't been created yet, so not sure how to go about finding
    // out its font
    
//      DWORD dwBaseUnits;
//      SIZE sizeBaseUnit;
//      dwBaseUnits = GetDialogBaseUnits();
//      sizeBaseUnit.cx = LOWORD(dwBaseUnits);
//      sizeBaseUnit.cy = HIWORD(dwBaseUnits);

//      pdt->cx              = (short)(size.cx * 4 / sizeBaseUnit.cx);
//      pdt->cy              = (short)(size.cy * 8 / sizeBaseUnit.cy);
    
    pdt->cx              = (short)size.cx * 2 /3 ;
    pdt->cy              = (short)size.cy * 2 /3;


      // Add menu array, class array, dlg title
    WORD* pw = (WORD*)(pdt + 1);
    *pw++ = 0;                // Menu array 
    *pw++ = 0;                // Class array
    *pw++ = 0;                // Dlgtitle

    // check we didn't go over the end of m_pbDlgTemplate.
    ASSERT((BYTE*)pw <= ((BYTE*)m_pbDlgTemplate + sizeof(m_pbDlgTemplate)));

    m_psp.pResource = pdt;
    m_psp.dwFlags |= PSP_DLGINDIRECT;
    
}

//
// Initialise
//
// Performs initialisation for IPropertyPage which can fail.
// Not in constructor, since constructor should not fail.
//
// Arguments as for IPropertyPage::SetObjects.
//
HRESULT CPropertySite::Initialise(ULONG cObjects, IUnknown **pUnknown)
{
    HRESULT hr;

    //
    // Pointer should be AddRef'ed in IPropertyPage::SetPageSite and
    // any existing pointer should be released.
    //
    hr = m_pIPropPage->SetPageSite( (IPropertyPageSite *) this );
    if (FAILED(hr)) {
        return(hr);
    }

    hr = m_pIPropPage->SetObjects(cObjects, pUnknown);
    if (FAILED(hr)) {
        return(hr);
    }

    hr = m_pIPropPage->GetPageInfo(&m_PropPageInfo);
    if (FAILED(hr)) {
        return(hr);
    }

    //
    // Set flag for help button
    //
    m_fHelp = (m_PropPageInfo.pszHelpFile != NULL);

    //
    // Set the caption of the dialog to the information found in
    // m_PropPageInfo. (the tab string)
    //
    WideCharToMultiByte( CP_ACP, 0, (LPCWSTR) m_PropPageInfo.pszTitle, -1,
                         m_strCaption.GetBufferSetLength(300), 300, NULL, NULL);

#ifndef USE_MSVC20
    m_psp.pszTitle = m_strCaption;
    m_psp.dwFlags |= PSP_USETITLE;
#endif

    return(hr);
}

//
// CleanUp
//
// This method notifies the IPropertyPage to release all pointers to us.
// This cannot be done in the destructor since the destructor will not
// be called unless we are released by the IPropertyPage.
//
HRESULT CPropertySite::CleanUp()
{
    m_pIPropPage->SetObjects(0,NULL);
    m_pIPropPage->SetPageSite(NULL);

    return( NOERROR );
}

//
// Destructor
//
CPropertySite::~CPropertySite()
{
    //
    // Have we displayed a help file?
    //
    if (m_fShowHelp) {
        ::WinHelp(GetSafeHwnd(), NULL, HELP_QUIT, 0);
    }

    //
    // Need to CoTaskMemFree all strings in the page info structure
    //
    if (m_PropPageInfo.pszTitle) {
        CoTaskMemFree(m_PropPageInfo.pszTitle);
    }

    if (m_PropPageInfo.pszDocString){
        CoTaskMemFree(m_PropPageInfo.pszDocString);
    }

    if (m_PropPageInfo.pszHelpFile) {
        CoTaskMemFree(m_PropPageInfo.pszHelpFile);
    }

    ASSERT(m_cRef == 0);
}

//
// OnSiteApply
//
// Called from CVfWPropertySheet when the apply button has been pressed.
//
void CPropertySite::OnSiteApply()
{
    //
    // Call the property page's apply function
    //
    m_pIPropPage->Apply();

    //
    // Update our m_hrDirtyPage flag
    //
    m_hrDirtyPage = m_pIPropPage->IsPageDirty();

    m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
}

//
// OnHelp
//
// Called from CVfWPropertySheet when the help button has been pressed.
// First see if the IPropertyPage objects wants to handle the help
// itself, otherwise provide help with the help file specified in
// PROPERTYPAGEINFO.
//
void CPropertySite::OnHelp()
{
    TCHAR pszHelpPath[200];

    HelpDirFromCLSID( m_CLSID, pszHelpPath, sizeof(pszHelpPath));

    //
    // Let IPropertyPage deal with help first.
    //

    OLECHAR * polecHelpPath;

#ifndef UNICODE
    WCHAR cHelpPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pszHelpPath, -1, cHelpPath, MAX_PATH);

    polecHelpPath = cHelpPath;
#else
    polecHelpPath = pszHelpPath;
#endif

    if (!FAILED(m_pIPropPage->Help( polecHelpPath ))) {
        m_fShowHelp = TRUE;

        return;
    }

    //
    // We have to provide help
    //

    //
    // Need to convert from OLECHAR (WCHAR) to TCHAR for WinHelp
    //
    TCHAR * ptchHelpFile;

#ifdef UNICODE
    ptchHelpFile = m_PropPageInfo.pszHelpFile;
#else
    char cHelpFile[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, m_PropPageInfo.pszHelpFile, -1, cHelpFile, MAX_PATH, NULL, NULL);

    ptchHelpFile = cHelpFile;
#endif

    m_fShowHelp = m_fShowHelp ||
        ::WinHelp(GetSafeHwnd(), ptchHelpFile, HELP_CONTEXT, 0);
}

//
// IsPageDirty
//
// Updates the m_hrDirtyPage variable and returns its new value
//
BOOL CPropertySite::IsPageDirty()
{
    m_hrDirtyPage = m_pIPropPage->IsPageDirty();

    return((m_hrDirtyPage == S_OK) ? TRUE : FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// IUnknown methods
//
//////////////////////////////////////////////////////////////////////////

//
// AddRef
//
ULONG CPropertySite::AddRef()
{
    return ++m_cRef;
}

//
// Release
//
ULONG CPropertySite::Release()
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef == 0) {
        delete this;

        // don't return m_cRef, because the object doesn't exist anymore
        return((ULONG) 0);
    }

    return(m_cRef);
}

//
// QueryInterface
//
// We only support IUnknown and IPropertyPageSite
//
HRESULT CPropertySite::QueryInterface(REFIID riid, void ** ppv)
{
    if ((riid != IID_IUnknown) && (riid != IID_IPropertyPageSite)) {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    *ppv = (void *) this;

    //
    // We have to addref ourself
    //
    AddRef();

    return(NOERROR);
}

//////////////////////////////////////////////////////////////////////////
//
// IPropertyPageSite methods
//
//////////////////////////////////////////////////////////////////////////

//
// OnStatusChange
//
HRESULT CPropertySite::OnStatusChange(DWORD flags)
{
    HRESULT hr;
    BOOL bDirty = FALSE, bHandled = FALSE;

    // atl sends us VALIDATE OR'd with DIRTY
    if( PROPPAGESTATUS_VALIDATE & flags )
    {
        m_pIPropPage->Apply();
        bDirty = TRUE;
        bHandled = TRUE;
    }
            
    if( PROPPAGESTATUS_DIRTY & flags || bDirty )
    {
        //
        // Update the Site's flags for apply and cancel button
        // and call the property sheets OnStatusChange function
        //
        hr = m_pIPropPage->IsPageDirty();
        if (FAILED(hr)) {
            return(hr);
        }

        m_hrDirtyPage = m_pIPropPage->IsPageDirty();
        m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
        bHandled = TRUE;
    }
    
    return( bHandled ? S_OK : E_INVALIDARG );
}

//
// GetLocaleID
//
HRESULT CPropertySite::GetLocaleID(LCID *pLocaleID)
{
    if (pLocaleID == NULL) {
        return(E_POINTER);
    }

    *pLocaleID = GetThreadLocale();

    return(S_OK);
}

//
// GetPageContainer
//
// Function must fail by definition of IPropertyPageSite
//
HRESULT CPropertySite::GetPageContainer(IUnknown **ppUnknown)
{
    return(E_NOTIMPL);
}

//
// TranslateAccelerator
//
// We don't process the message, therefore we return S_FALSE.
//
HRESULT CPropertySite::TranslateAccelerator(LPMSG pMsg)
{
    return(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
// CPropertySite overrides
//
//////////////////////////////////////////////////////////////////////////

//
// OnSetActive
//
// Gets called from CVfWPropertySheet when our PropertyPage gains the focus.
// We call CPropertyPage::OnSetActive which will create a window for the
// page if not previously created.
//
// return:
//   Non-zero if the page was successfully set active.
//
BOOL CPropertySite::OnSetActive()
{
    if (!CPropertyPage::OnSetActive()) {
        return(FALSE);
    }

    if (!m_fPageIsActive) {
        if (FAILED(m_pIPropPage->Activate(GetSafeHwnd(), &m_rcRect, FALSE))) {
            return (FALSE);
        }
        if (FAILED(m_pIPropPage->Show(SW_SHOW))) {
            return (FALSE);
        }
    }

    m_fPageIsActive = TRUE;

    //
    // Also need to update the buttons
    //
    m_pPropSheet->UpdateButtons( m_hrDirtyPage, m_fHelp);

    return(TRUE);
}

//
// OnKillActive
//
// Called whenever our page loses the focus. At this point data verification
// should be made.
//
// return:
//   TRUE  - it is ok to lose focus
//   FALSE - keep the focus on our page
//
BOOL CPropertySite::OnKillActive()
{
    if (m_fPageIsActive) {
        HRESULT hr = m_pIPropPage->Deactivate();

        if (S_OK != hr) {
            return (FALSE);
        }
    }

    m_fPageIsActive = FALSE;

    return(CPropertyPage::OnKillActive());
}

//
// OnCreate
//
int CPropertySite::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    int iReturn = CPropertyPage::OnCreate(lpCreateStruct);
    if ( iReturn != 0) {
        return(iReturn);
    }

    GetClientRect(&m_rcRect);

    //
    // Leave space for a border
    //
    m_rcRect.InflateRect(-3, -2);

    return(0);
}

//
// OnDestroy
//
void CPropertySite::OnDestroy()
{
    CPropertyPage::OnDestroy();
}

//
// PreTranslateMessage
//
// Give IPropertyPage a chance to use the message. If not it has to pass
// it on to IPropertyPageSite (our interface), from where
// CPropertyPage::PreTranslateMessage is called.
//
// Conversions between HRESULT and BOOL and HRESULT have to be made.
//
// We expect as return value from IPropertyPage::TranslateAccelerator
//    S_OK - Message has been used.
//    S_FALSE - Message has not been used.
//    FAILED(hr) - Message has not been used.
//
// If the message has been used we return TRUE, otherwise FALSE.
// (our return value will determine whether this messages should still be
//  dispatched after we are finished with it).
//
BOOL CPropertySite::PreTranslateMessage(MSG *pMsg)
{
    if ( S_OK == m_pIPropPage->TranslateAccelerator(pMsg) ) {
        return(TRUE);
    }
    else {
        return( CPropertyPage::PreTranslateMessage(pMsg) );
    }
}


//
// HelpDirFromCLSID
//
// Get the help directory from the registry. First we look under
// "CLSID\<clsid>\HelpDir" if this is not given we will get the
// entry under "CLSID\<clsid>\InProcServer32" and remove the
// server file name.
//
// (this code is based on an example in MSDN, July 1995 - search for
// HelpDirFromCLSID in Title and Text)
//
// Note that dwPathSize should be given in Bytes.
//
void CPropertySite::HelpDirFromCLSID
 (
    const CLSID* clsID,
    LPTSTR pszPath,
    DWORD dwPathSize
 )

{
    TCHAR       szCLSID[80];
    TCHAR       szKey[512];
    HKEY        hKey;
    DWORD       dwLength;      // size of szCLSID in bytes and later
                               // temporary storage for dwPathSize
    long lReturn;

    //
    // Initialise pszPath
    //
    if (NULL==pszPath)
        return;

    *pszPath=0;

    //
    // Convert CLSID into a string
    //
    dwLength = sizeof(szCLSID) / sizeof(TCHAR);

#ifdef UNICODE
    StringFromGUID2(*clsID, szCLSID, dwLength);

#else
    WCHAR wszCLSID[128];
    StringFromGUID2(*clsID, wszCLSID, 128);

    WideCharToMultiByte(CP_ACP, 0, wszCLSID, -1, szCLSID, dwLength, NULL, NULL);
#endif

    //
    // Get handle to the HelpDir key.
    //
    wsprintf(szKey, TEXT("CLSID\\%s\\HelpDir"), szCLSID);

    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == lReturn) {

        //
        // Get the value from the HelpDir key.
        //
        dwLength = dwPathSize;
        lReturn = RegQueryValueEx(hKey, NULL, NULL, NULL,
                                  (LPBYTE) pszPath, &dwLength);

        RegCloseKey(hKey);

        if (ERROR_SUCCESS == lReturn) {
            return;
        }
    }

    //
    // Failure - need to get the path from the InProcServer32 entry
    //
    // Get handle to the Inproc key.
    //
    wsprintf(szKey, TEXT("CLSID\\%s\\InprocServer32"), szCLSID);

    lReturn = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS != lReturn) {
        // we failed to get any path - return an emtpy string
        pszPath[0] = 0;
        return;
    }

    //
    // Get value of Inproc key.
    //
    dwLength = dwPathSize;
    lReturn = RegQueryValueEx(hKey, NULL, NULL, NULL,
                              (LPBYTE) pszPath, &dwLength);

    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lReturn) {
        // we failed to get any path - return an empty string
        pszPath[0] = 0;
        return;
    }

    //
    // We need to strip of the server filename from the path.
    //
    // The filename extends from the end to the first '\\' or ':' or
    // the beginning of the string. We can therefore just
    // go to the end of the pszPath and then step backwards as long
    // as we are not in the beginning of pszPath or the char in front of us
    // is not a ':' or a '\\'.
    //

    //
    // Find end of pszPath (ie find the terminating '\0')
    //
    TCHAR * pNewEnd = pszPath;

    while (0 != *pNewEnd) {
        pNewEnd++;
    }

    //
    // Now go backwards as long as we are not at the beginning of the
    // string or we don't have a '\\' or ':' before us.
    //
    while ((pszPath != pNewEnd) &&
           (*(pNewEnd - 1) != TEXT(':')) &&
           (*(pNewEnd - 1) != TEXT('\\')) ) {
        pNewEnd--;
    }

    //
    // pNewEnd now points to the new end of the string the path without the
    // filename.
    //
    *pNewEnd = 0;

    return;
}

//
// UpdateButtons
//
// Called from the property sheet to notify us to call the sheet's
// UpdateButtons method with our parameters.
//
void CPropertySite::UpdateButtons()
{
    m_pPropSheet->UpdateButtons(m_hrDirtyPage, m_fHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\propsht.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef _PROPSHT_H_
#define _PROPSHT_H_

//
// CVfWPropertySheet
//
// Modification of CPropertySheet to allow for OK, Cancel, Apply and Help
// buttons for modeless property sheets.
//
class CPropertySite;

class CVfWPropertySheet : public CPropertySheet {

public:
    // Pass IUnknown of the object we want the property sheet for.
    // CString holds the title of the property sheet and
    // CWnd indicates the parent window (NULL = the application window).
    CVfWPropertySheet(IUnknown *, CString, CWnd * = NULL);
    virtual ~CVfWPropertySheet();

    // CPropertySheet methods
    INT_PTR DoModal() { ASSERT(!TEXT("No modal mode supported")); return 0; }

    // CVfWPropertySheet methods
    void UpdateButtons(HRESULT hrIsDirty, BOOL fSupportHelp);

protected:

    // OK, Cancel, Apply and Help buttons
    CButton *m_butOK;
    CButton *m_butCancel;
    CButton *m_butApply;
    CButton *m_butHelp;

    // Flags on the state of all property pages.
    BOOL m_fAnyChanges;      // TRUE = some property page is dirty

    // Message handlers for the buttons
    void OnOK();
    void OnCancel();
    void OnApply();
    void OnHelp();

    // Helper methods to obtain property pages from IUnknown passed in
    // constructor.
    UINT AddSpecificPages(IUnknown *);
    UINT AddFilePage(IUnknown *);
    UINT AddPinPages(IUnknown *);

    // Return the active site
    CPropertySite * GetActiveSite() {
        return((CPropertySite *) GetActivePage());
    }

    // Free all memory of buttons and property sites.
    void Cleanup();

    // Add our own buttons
    afx_msg int OnCreate(LPCREATESTRUCT);
    afx_msg void OnDestroy();

    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fButtonsCreated;    // flag to indicate whether we can enable/disable
                               // the buttons yet.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\reconfig.cpp ===
#include "stdafx.h"
#include "ReConfig.h"

/******************************************************************************
    Internal Constants
******************************************************************************/
static const DWORD RECONFIGURE_NO_FLAGS = 0;
static const HANDLE RECONFIGURE_NO_ABORT_EVENT = NULL;

/******************************************************************************
    Internal Declarations
******************************************************************************/
static HRESULT Reconnect( IGraphBuilder* pFilterGraph, IPin* pOutputPin );

template<class T> T* _CreateInstance( void )
{
    try
    {
        T* pNewObject = new T;
        pNewObject->AddRef();
        return pNewObject;
    } 
    catch( CMemoryException* pOutOfMemory )
    {
        pOutOfMemory->Delete();
        return NULL;
    }
}

/******************************************************************************
    Reconfigure Helper Functions
******************************************************************************/

/******************************************************************************

PreventStateChangesWhileOperationExecutes

    PreventStateChangesWhileOperationExecutes() ensures that other threads do 
not change the filter graph's state while IGraphConfigCallback::Reconfigure() 
executes.  If the current version of Direct Show does not support Dynamic Graph
Building, then this function fails.

Parameters:
- pGraphBuilder [in]
    The filter graph which WILL be locked.  Other threads cannot modify the
filter graph's state while it's locked.

- pCallback [in]
    The callback which will be called to preform a user defined operation.

- pReconfigureParameter [in]
    The pvConext parameters IGraphConfigCallback::Reconfigure() receives when
it's called.

Return Value:
    An HRESULT. S_OK if no error occur.  Otherwise, an error HRESULT.

******************************************************************************/
extern HRESULT PreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    )
{
    // The user should pass a valid IGraphBuilder object and a
    // valid IGraphConfigCallback object.
    ASSERT( (NULL != pGraphBuilder) && (NULL != pCallback) );

    IGraphConfig* pGraphConfig;

    // Does Direct Show supports Dynamic Graph Building?
    HRESULT hr = pGraphBuilder->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( FAILED( hr ) ) {
        return hr; 
    }

    hr = pGraphConfig->Reconfigure( pCallback,
                                    (void*)pReconfigureParameter,
                                    RECONFIGURE_NO_FLAGS,
                                    RECONFIGURE_NO_ABORT_EVENT );
    pGraphConfig->Release();

    if( FAILED( hr ) ) {
        return hr;
    }

    return S_OK;
} 

/******************************************************************************

IfPossiblePreventStateChangesWhileOperationExecutes

    If the current version of Direct Show supports Dynamic Graph Building, 
IfPossiblePreventStateChangesWhileOperationExecutes() ensures that other 
threads do not change the filter graph's state while 
IGraphConfigCallback::Reconfigure() executes.  If the current version of Direct
Show does not support Dynamic Graph Building, then the filter graph state 
should not change unless this thread changes it.  

Parameters:
- pGraphBuilder [in]
    The filter graph which MAY be locked.  Other threads cannot modify the
filter graph's state while it's locked.

- pCallback [in]
    The callback which will be called to preform a user defined operation.

- pReconfigureParameter [in]
    The pvConext parameters IGraphConfigCallback::Reconfigure() receives when
it's called.

Return Value:
    An HRESULT. S_OK if no error occur.  Otherwise, an error HRESULT.

******************************************************************************/
extern HRESULT IfPossiblePreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    )
{
    // The user should pass a valid IGraphBuilder object and a
    // valid IGraphConfigCallback object.
    ASSERT( (NULL != pGraphBuilder) && (NULL != pCallback) );

    IGraphConfig* pGraphConfig;

    // Does Direct Show supports Dynamic Graph Building?
    HRESULT hr = pGraphBuilder->QueryInterface( IID_IGraphConfig, (void**)&pGraphConfig );
    if( SUCCEEDED( hr ) ) {
        // Dynamic Graph Building supported.
        hr = pGraphConfig->Reconfigure( pCallback,
                                        pReconfigureParameter,
                                        RECONFIGURE_NO_FLAGS,
                                        RECONFIGURE_NO_ABORT_EVENT );
        pGraphConfig->Release();
    
        if( FAILED( hr ) ) {
            return hr;
        }

    } else if( E_NOINTERFACE == hr ) {
        // Dynamic Graph Building is not supported.
        hr = pCallback->Reconfigure( pReconfigureParameter, RECONFIGURE_NO_FLAGS );
        if( FAILED( hr ) ) {
            return hr;
        }
       
    } else {
        return hr;
    }

    return S_OK;
}

/******************************************************************************
    CReconfigure Public Methods
******************************************************************************/

CGraphConfigCallback::CGraphConfigCallback( const TCHAR* pName, LPUNKNOWN pUnk ) :
    CUnknown( pName, pUnk )
{
}

STDMETHODIMP CGraphConfigCallback::NonDelegatingQueryInterface( REFIID riid, void** ppv )
{
    if( IID_IGraphConfigCallback == riid ) {
        return GetInterface( this, ppv );
    } else {
        return CUnknown::NonDelegatingQueryInterface( riid, ppv );
    }
}

/******************************************************************************
    CPrintGraphAsHTMLCallback Public Methods
******************************************************************************/
CPrintGraphAsHTMLCallback::CPrintGraphAsHTMLCallback() :
    CGraphConfigCallback( NAME("CPrintGraphAsHTMLCallback"), NULL )
{
}

STDMETHODIMP CPrintGraphAsHTMLCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL* pParameters = (PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL*)pvContext;
       
    CBoxNetDoc* pDoc = pParameters->pDocument;

    pDoc->PrintGraphAsHTML( pParameters->hFileHandle );

    return S_OK;
}

IGraphConfigCallback* CPrintGraphAsHTMLCallback::CreateInstance( void )
{
    return _CreateInstance<CPrintGraphAsHTMLCallback>();
}

/******************************************************************************
    CUpdateFiltersCallback Public Methods
******************************************************************************/
CUpdateFiltersCallback::CUpdateFiltersCallback() :
    CGraphConfigCallback( NAME("CUpdateFiltersCallback"), NULL )
{
}

STDMETHODIMP CUpdateFiltersCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    CBoxNetDoc* pDoc = (CBoxNetDoc*)pvContext;

    pDoc->UpdateFiltersInternal();

    return S_OK;
}

IGraphConfigCallback* CUpdateFiltersCallback::CreateInstance( void )
{
    return _CreateInstance<CUpdateFiltersCallback>();
}

/******************************************************************************
    CEnumerateFilterCacheCallback Public Methods
******************************************************************************/
CEnumerateFilterCacheCallback::CEnumerateFilterCacheCallback() :
    CGraphConfigCallback( NAME("CEnumerateFilterCacheCallback"), NULL )
{
}

STDMETHODIMP CEnumerateFilterCacheCallback::Reconfigure( PVOID pvContext, DWORD dwFlags )
{
    // No valid flags have been defined.  Therefore, this parameter should be 0.
    ASSERT( 0 == dwFlags );

    CBoxNetDoc* pDoc = (CBoxNetDoc*)pvContext;

    pDoc->OnGraphEnumCachedFiltersInternal();

    return S_OK;
}

IGraphConfigCallback* CEnumerateFilterCacheCallback::CreateInstance( void )
{
    return _CreateInstance<CEnumerateFilterCacheCallback>();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\rndrurl.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
// rndrurl.h

#ifndef __RENDER_URL__
#define __RENDER_URL__

#define URL_LIST_SIZE 6

typedef char URLSTRING[INTERNET_MAX_URL_LENGTH];
class CRenderURL : public CDialog
{
public:
    ~CRenderURL();
    CRenderURL(char *szFileName, int cb, CWnd * pParent = NULL );

protected:

    BOOL OnInitDialog();
    void DoDataExchange(CDataExchange* pDX);

    virtual void OnOK();


    DECLARE_MESSAGE_MAP()

private:
    CComboBox m_ComboBox;
    int m_iURLListLength;
    int m_iCurrentSel;
    char *m_psz;
    int m_cb;
    URLSTRING m_rgszURL[URL_LIST_SIZE];
};

#endif // __RENDER_URL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\stdafx.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h
//
// Include file for standard system include files, or project specific include
// files that are used frequently, but are changed infrequently.
//

#include <afxwin.h>             // MFC core and standard components
#include <afxext.h>             // MFC extensions (including VB)
#include <afxole.h>             // MFC OLE2
#include <afxcmn.h>

#include <objbase.h>
#include <afxtempl.h>

#include <atlbase.h>

#include <strmif.h>
#include <windowsx.h>
#include <control.h>
#include <evcode.h>
#include <uuids.h>
#include <vfwmsgs.h>
#include <errors.h>

#include <hrExcept.h>           // Exception classes
#include <comint.h>             // COM interface helper
#include <multistr.h>           // MultiByteToWideChar Helper

#include <olectl.h>

#include "resource.h"

#include "grftmpl.h"
#include "mainfrm.h"
#include "gutil.h"              // general utilities, list classes etc
#include "enum.h"               // IEnumXXX wrappers

#include "propobj.h"            // Objects which support property browsing
#include "propsht.h"        // Property Sheet class
#include "propsite.h"       // Property Site class
#include "box.h"                // filter & box objects
#include "link.h"               // connection/link objects
#include "cmd.h"
#include "bnetdoc.h"
#include "boxdraw.h"
#include "bnetvw.h"

#include "graphedt.h"

#include "qerror.h"         // Error handling
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\reconfig.h ===
#ifndef Reconfigure_h
#define Reconfigure_h

#include <streams.h>

class CBoxNetDoc;

HRESULT PreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    );
HRESULT IfPossiblePreventStateChangesWhileOperationExecutes
    (
    IGraphBuilder* pGraphBuilder,
    IGraphConfigCallback* pCallback,
    void* pReconfigureParameter
    );

class CGraphConfigCallback : public CUnknown,
                             public IGraphConfigCallback
{
public:
    CGraphConfigCallback( const TCHAR* pName, LPUNKNOWN pUnk );

    DECLARE_IUNKNOWN;
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void** ppv );

private:
};

class CPrintGraphAsHTMLCallback : public CGraphConfigCallback 
{
public:
    CPrintGraphAsHTMLCallback();

    void SafePrintGraphAsHTML( HANDLE hFile );
    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );

    struct PARAMETERS_FOR_PRINTGRAPHASHTMLINTERNAL 
    {
        CBoxNetDoc* pDocument;
        HANDLE hFileHandle;
    };
};

class CUpdateFiltersCallback : public CGraphConfigCallback
{
public:
    CUpdateFiltersCallback();

    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );
};

class CEnumerateFilterCacheCallback : public CGraphConfigCallback
{
public:
    CEnumerateFilterCacheCallback();

    STDMETHODIMP Reconfigure( PVOID pvContext, DWORD dwFlags );

    static IGraphConfigCallback* CreateInstance( void );
};

#endif // Reconfigure_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\mp2res.h ===
#define IDS_MPG2SPLT_PROP_PINS_TITLE            1201
#define IDS_MPG2SPLT_PROP_PID_MAP_TITLE         1202
#define IDS_MPG2SPLT_PROP_STREAMID_MAP_TITLE    1203
#define IDD_MPG2SPLT_PROP_PINS                  1204
#define IDD_MPG2SPLT_PROP_STREAM_MAP            1205
#define IDC_MPG2SPLT_OUTPUT_PINS                1206
#define IDC_MPG2SPLT_DATA_OFFSET                1207
#define IDC_MPG2SPLT_FILTER_VALUE               1208
#define IDC_MPG2SPLT_CREATE_PIN                 1209
#define IDC_MPG2SPLT_DELETE_PIN                 1210
#define IDC_MPG2SPLT_PIN_NAME                   1211
#define IDC_MPG2SPLT_PIN_TYPE                   1212
#define IDC_MPG2SPLT_STREAMS                    1213
#define IDC_MPG2SPLT_MAP_STREAM                 1214
#define IDC_MPG2SPLT_UNMAP_STREAM               1215
#define IDC_MPG2SPLT_STREAM_MAPPINGS            1216
#define IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT       1217
#define IDC_MPG2SPLT_STREAMID_NAME              1218
#define IDC_MPG2SPLT_DATA_OFFSET_LABEL          1219
#define IDC_MPG2SPLT_FILTER_VALUE_LABEL         1220
#define IDC_MPG2SPLT_SUBSTREAM_FRAME            1221
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\mp2prop.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        mp2prop.cpp

    Abstract:

        This module contains the property page implementations.

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created

    Notes:

--*/

#include <streams.h>
#include <commctrl.h>       //  for the property pages
#include <tchar.h>
#include <mmreg.h>
#include <limits.h>
#include <bdaiface.h>
#include <ks.h>             //  for ksmedia.h
#include <ksmedia.h>        //  for bdamedia.h
#include <bdamedia.h>       //  for KSDATAFORMAT_TYPE_MPEG2_SECTIONS
#include "mp2res.h"
#include <initguid.h>
#include "mp2prop.h"
#include "uictrl.h"

//  XXXX
//  for swprintf () call ..
#include <stdio.h>

#define GOTO_NE(v,c,l)              if ((v) != (c)) { goto l ; }
#define RELEASE_AND_CLEAR(punk)     if (punk) { (punk)->Release(); (punk) = NULL; }

//  ---------------------------------------------------------------------------

//  define various contents of controls that appear in the properties
//  ---------------------------------------------------------------------------

static TCHAR g_szPID []         =   __TEXT("PID") ;
static TCHAR g_szStreamId []    =   __TEXT("stream_id") ;

#define DISTINCT_PID_COUNT      (1 << 13)
#define MAX_PID_VALUE           (DISTINCT_PID_COUNT - 1)
#define STREAM_ID_MIN           0xBA
#define STREAM_ID_MAX           0xFF

//static GUID g_MediaTypeMpeg2Sections = KSDATAFORMAT_TYPE_MPEG2_SECTIONS ;

typedef
struct {
    WCHAR * szTitle ;
    DWORD   dwWidth ;
} COL_DETAIL ;

#define LV_COL(title, width)  { L#title, (width) }

//  output pin listview for output pin & PID map property defined here

static
enum {
    PIN_COL_PIN,
    PIN_COL_COUNT
} ;

static
COL_DETAIL
g_OutputPinColumns [] = {
    LV_COL (Pin,     70),
} ;

//  ============================================================================
//  PID map enum listview for PID map property listview control defined here

static
enum {
    PID_COL_PID,
    PIN_COL_PID,
    MEDIA_SAMPLE_CONTENT_PID,
    PID_PIN_COL_COUNT           //  always last
} ;

static
COL_DETAIL
g_PIDMapColumns [] = {
    LV_COL (PID,        50),
    LV_COL (Pin,        60),
    LV_COL (Content,    180),
} ;
//  ============================================================================


//  ============================================================================
//  PID map enum listview for PID map property listview control defined here

static
enum {
    STREAM_ID_COL_STREAM,
    PIN_COL_STREAM,
    MEDIA_SAMPLE_CONTENT_STREAM,
    FILTER_COL_STREAM,
    OFFSET_COL_STREAM,
    STREAM_ID_PIN_COL_COUNT     //  always last
} ;

static
COL_DETAIL
g_StreamIdMapColumns [] = {
    LV_COL (stream_id,  60),
    LV_COL (Pin,        40),
    LV_COL (Content,    130),
    LV_COL (Filter,     40),
    LV_COL (Offset,     40),
} ;
//  ============================================================================

//  MEDIA_SAMPLE_CONTENT ids and descriptions
typedef
struct {
    LPWSTR  pszDescription ;
    DWORD   MediaSampleContent ;
} MEDIA_SAMPLE_CONTENT_DESC ;

//  !! NOTE !!  MediaSampleContent value (cast to an int) is used as an index, so
//  keep the order
static
MEDIA_SAMPLE_CONTENT_DESC
g_TransportMediaSampleContentDesc [] = {
    {
        L"Transport Packet (complete)",
        (DWORD) MEDIA_TRANSPORT_PACKET
    },
    {
        L"Elementary Stream (A/V only)",
        (DWORD) MEDIA_ELEMENTARY_STREAM
    },
    {
        L"MPEG2 PSI Sections",
        (DWORD) MEDIA_MPEG2_PSI
    },
    {
        L"Transport Packet Payload",
        (DWORD) MEDIA_TRANSPORT_PAYLOAD
    }
} ;

//  !! NOTE !!  MediaSampleContent value (cast to an int) is used as an index, so
//  keep the order
static
MEDIA_SAMPLE_CONTENT_DESC
g_ProgramMediaSampleContentDesc [] = {
    {
        L"Program Stream Map",
        (DWORD) MPEG2_PROGRAM_STREAM_MAP
    },
    {
        L"Elementary Stream (A/V only)",
        (DWORD) MPEG2_PROGRAM_ELEMENTARY_STREAM
    },
    {
        L"Directory PES Packet",
        (DWORD) MPEG2_PROGRAM_DIRECTORY_PES_PACKET
    },
    {
        L"Pack Header",
        (DWORD) MPEG2_PROGRAM_PACK_HEADER
    },
    {
        L"System Header",
        (DWORD) MPEG2_PROGRAM_SYSTEM_HEADER
    },
    {
        L"PES Stream",
        (DWORD) MPEG2_PROGRAM_PES_STREAM
    }
} ;

//  format blocks for the canned types

//  ac-3
static
WAVEFORMATEX
g_AC3WaveFormatEx = {
    WAVE_FORMAT_UNKNOWN,    //  wFormatTag
    2,                      //  nChannels
    48000,                  //  nSamplesPerSec (others: 96000)
    0,                      //  nAvgBytesPerSec
    0,                      //  nBlockAlign
    16,                     //  wBitsPerSample (others: 20, 24, 0)
    0                       //  cbSize
} ;

//  WaveFormatEx format block; generated with the following settings:
//
//  fwHeadFlags         = 0x1c;
//  wHeadEmphasis       = 1;
//  fwHeadModeExt       = 1;
//  fwHeadMode          = 1;
//  dwHeadBitrate       = 0x3e800;
//  fwHeadLayer         = 0x2;
//  wfx.cbSize          = 0x16;
//  wfx.wBitsPerSample  = 0;
//  wfx.nBlockAlign     = 0x300;
//  wfx.nAvgBytesPerSec = 0x7d00;
//  wfx.nSamplesPerSec  = 0xbb80;
//  wfx.nChannels       = 2;
//  wfx.wFormatTag      = 0x50;
//  dwPTSLow            = 0;
//  dwPTSHigh           = 0;
static
BYTE
g_MPEG1AudioFormat [] = {
    0x50, 0x00, 0x02, 0x00, 0x80, 0xBB, 0x00, 0x00,
    0x00, 0x7D, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
    0x16, 0x00, 0x02, 0x00, 0x00, 0xE8, 0x03, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x1C, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
} ;

static
BYTE
g_Mpeg2ProgramVideo [] = {
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.top               = 0x00000000
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.rcSource.right             = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.rcSource.bottom            = 0x000001e0
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.top               = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.right             = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.bottom            = 0x00000000
    0x00, 0x09, 0x3D, 0x00,                         //  .hdr.dwBitRate                  = 0x003d0900
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwBitErrorRate             = 0x00000000
    0x63, 0x17, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, //  .hdr.AvgTimePerFrame            = 0x0000000000051763
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwInterlaceFlags           = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwCopyProtectFlags         = 0x00000000
    0x04, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioX         = 0x00000004
    0x03, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioY         = 0x00000003
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved1                = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved2                = 0x00000000
    0x28, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSize           = 0x00000028
    0xD0, 0x02, 0x00, 0x00,                         //  .hdr.bmiHeader.biWidth          = 0x000002d0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.bmiHeader.biHeight         = 0x00000000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biPlanes         = 0x0000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biBitCount       = 0x0000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biCompression    = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSizeImage      = 0x00000000
    0xD0, 0x07, 0x00, 0x00,                         //  .hdr.bmiHeader.biXPelsPerMeter  = 0x000007d0
    0x27, 0xCF, 0x00, 0x00,                         //  .hdr.bmiHeader.biYPelsPerMeter  = 0x0000cf27
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrUsed        = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrImportant   = 0x00000000
    0x98, 0xF4, 0x06, 0x00,                         //  .dwStartTimeCode                = 0x0006f498
    0x56, 0x00, 0x00, 0x00,                         //  .cbSequenceHeader               = 0x00000056
    0x02, 0x00, 0x00, 0x00,                         //  .dwProfile                      = 0x00000002
    0x02, 0x00, 0x00, 0x00,                         //  .dwLevel                        = 0x00000002
    0x00, 0x00, 0x00, 0x00,                         //  .Flags                          = 0x00000000
                                                    //  .dwSequenceHeader [1]
    0x00, 0x00, 0x01, 0xB3, 0x2D, 0x01, 0xE0, 0x24,
    0x09, 0xC4, 0x23, 0x81, 0x10, 0x11, 0x11, 0x12,
    0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19,
    0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B,
    0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
    0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x01, 0xB5,
    0x14, 0x82, 0x00, 0x01, 0x00, 0x00
} ;

static
BYTE
g_ATSCVideoFormat [] = {
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcSource.top               = 0x00000000
    0xC0, 0x02, 0x00, 0x00,                         //  .hdr.rcSource.right             = 0x000002c0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.rcSource.bottom            = 0x000001e0
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.left              = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.top               = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.right             = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.rcTarget.bottom            = 0x00000000
    0x00, 0x1B, 0xB7, 0x00,                         //  .hdr.dwBitRate                  = 0x00b71b00
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwBitErrorRate             = 0x00000000
    0xB1, 0x8B, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, //  .hdr.AvgTimePerFrame            = 0x0000000000028bb1
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwInterlaceFlags           = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwCopyProtectFlags         = 0x00000000
    0x10, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioX         = 0x00000010
    0x09, 0x00, 0x00, 0x00,                         //  .hdr.dwPictAspectRatioY         = 0x00000009
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved1                = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.dwReserved2                = 0x00000000
    0x28, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSize           = 0x00000028
    0xC0, 0x02, 0x00, 0x00,                         //  .hdr.bmiHeader.biWidth          = 0x000002c0
    0xE0, 0x01, 0x00, 0x00,                         //  .hdr.bmiHeader.biHeight         = 0x000001e0
    0x00, 0x00,                                     //  .hdr.bmiHeader.biPlanes         = 0x0000
    0x00, 0x00,                                     //  .hdr.bmiHeader.biBitCount       = 0x0000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biCompression    = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biSizeImage      = 0x00000000
    0xD0, 0x07, 0x00, 0x00,                         //  .hdr.bmiHeader.biXPelsPerMeter  = 0x000007d0
    0x42, 0xD8, 0x00, 0x00,                         //  .hdr.bmiHeader.biYPelsPerMeter  = 0x0000d842
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrUsed        = 0x00000000
    0x00, 0x00, 0x00, 0x00,                         //  .hdr.bmiHeader.biClrImportant   = 0x00000000
    0xC0, 0x27, 0xC8, 0x00,                         //  .dwStartTimeCode                = 0x00c827c0
    0x4C, 0x00, 0x00, 0x00,                         //  .cbSequenceHeader               = 0x0000004c
    0xFF, 0xFF, 0xFF, 0xFF,                         //  .dwProfile                      = 0xffffffff
    0xFF, 0xFF, 0xFF, 0xFF,                         //  .dwLevel                        = 0xffffffff
    0x00, 0x00, 0x00, 0x00,                         //  .Flags                          = 0x00000000
                                                    //  .dwSequenceHeader [1]
    0x00, 0x00, 0x01, 0xB3, 0x2C, 0x01, 0xE0, 0x37,
    0x1D, 0x4C, 0x23, 0x81, 0x10, 0x11, 0x11, 0x12,
    0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
    0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x16,
    0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17,
    0x18, 0x18, 0x18, 0x19, 0x18, 0x18, 0x18, 0x19,
    0x1A, 0x1A, 0x1A, 0x1A, 0x19, 0x1B, 0x1B, 0x1B,
    0x1B, 0x1B, 0x1C, 0x1C, 0x1C, 0x1C, 0x1E, 0x1E,
    0x1E, 0x1F, 0x1F, 0x21, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
} ;

//  canned types we support via the property page

//  order is important !  Keep these in the same order as the
//  detail declarations in g_CannedType.
static
enum {
    PIN_TYPE_ATSC_VIDEO,
    PIN_TYPE_MPEG2_PROGRAM_VIDEO,
    PIN_TYPE_MPEG1_AUDIO,
    PIN_TYPE_MPEG2_AUDIO,
    PIN_TYPE_ATSC_AUDIO,
    PIN_TYPE_DATA,
    PIN_TYPE_TRANSPORT_STREAM,
    PIN_TYPE_MPE,
    PIN_TYPE_MPEG2_PSI,
    NUM_CANNED_TYPE                     //  always last
} ;

//  keep these in the same order as the enum'd types above
static
struct {
    WCHAR * szDescription ;

    struct {
        const GUID *    pMajorType ;
        const GUID *    pSubType ;
        BOOL            bFixedSizeSamples ;
        const GUID *    pFormatType ;
        int             cbFormat ;
        BYTE *          pbFormat ;
    } MediaType ;

} g_CannedType [] = {

    //  PIN_TYPE_ATSC_VIDEO
    {
        L"ATSC Video",
        {
            & MEDIATYPE_Video,                  //  majortype
            & MEDIASUBTYPE_MPEG2_VIDEO,         //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_MPEG2Video,                //  formattype
            sizeof g_ATSCVideoFormat,           //  cbFormat
            g_ATSCVideoFormat                   //  pbFormat
        }
    },

    //  PIN_TYPE_MPEG2_PROGRAM_VIDEO
    {
        L"MPEG2 Program Video",
        {
            & MEDIATYPE_Video,                  //  majortype
            & MEDIASUBTYPE_MPEG2_VIDEO,         //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_MPEG2Video,                //  formattype
            sizeof g_Mpeg2ProgramVideo,         //  cbFormat
            g_Mpeg2ProgramVideo                 //  pbFormat
        }
    },

    //  PIN_TYPE_MPEG1_AUDIO
    {
        L"MPEG-1 Audio",
        {
            & MEDIATYPE_Audio,                  //  majortype
            & MEDIASUBTYPE_MPEG1Payload,        //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_WaveFormatEx,              //  formattype
            sizeof g_MPEG1AudioFormat,          //  cbFormat
            g_MPEG1AudioFormat                  //  pbFormat
        }
    },

    //  PIN_TYPE_MPEG2_AUDIO
    {
        L"MPEG-2 Audio",
        {
            & MEDIATYPE_Audio,                  //  majortype
            & MEDIASUBTYPE_MPEG2_AUDIO,         //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_WaveFormatEx,              //  formattype
            sizeof g_MPEG1AudioFormat,          //  cbFormat
            g_MPEG1AudioFormat                  //  pbFormat
        }
    },

    //  PIN_TYPE_ATSC_AUDIO
    {
        L"ATSC Audio (AC3)",
        {
            & MEDIATYPE_Audio,                  //  majortype
            & MEDIASUBTYPE_DOLBY_AC3,           //  subtype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_WaveFormatEx,              //  formattype
            sizeof g_AC3WaveFormatEx,           //  cbFormat
            (BYTE *) & g_AC3WaveFormatEx        //  pbFormat
        }
    },

    //  PIN_TYPE_DATA
    {
        L"Transport Payload",
        {
            & MEDIATYPE_NULL,                   //  majortype
            & MEDIASUBTYPE_NULL,                //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },

    //  PIN_TYPE_TRANSPORT_STREAM
    {
        L"Transport Stream",
        {
            & MEDIATYPE_Stream,                 //  majortype
            & MEDIASUBTYPE_MPEG2_TRANSPORT,     //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },

    //  PIN_TYPE_MPE
    {
        L"DVB MPE",
        {
            & KSDATAFORMAT_TYPE_MPEG2_SECTIONS, //  majortype
            & MEDIASUBTYPE_None,                //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },
    //  PIN_TYPE_MPEG2_PSI
    {
        L"MPEG-2 PSI",
        {
            & KSDATAFORMAT_TYPE_MPEG2_SECTIONS, //  majortype
            & MEDIASUBTYPE_None,                //  minortype
            TRUE,                               //  bFixedSizeSamples
            & FORMAT_None,                      //  formattype
            0,                                  //  cbFormat
            NULL                                //  pbFormat
        }
    },
} ;

//  TRUE / FALSE for YES / NO
static
BOOL
MessageBoxQuestion (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    return MessageBox (NULL, achbuffer, title, MB_YESNO | MB_ICONQUESTION) == IDYES ;
}

//  error conditions
static
void
MessageBoxError (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK | MB_ICONEXCLAMATION) ;
}

//  variable param
static
void
MessageBoxVar (
    IN  TCHAR * title,
    IN  TCHAR * szfmt,
    ...
    )
{
    TCHAR   achbuffer [256] ;
    va_list va ;

    va_start (va, szfmt) ;
    wvsprintf (achbuffer, szfmt, va) ;

    MessageBox (NULL, achbuffer, title, MB_OK) ;
}

//  ---------------------------------------------------------------------------
//      CMPEG2PropOutputPins
//  ---------------------------------------------------------------------------

CMPEG2PropOutputPins::CMPEG2PropOutputPins (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage       (
            pClassName,
            pIUnknown,
            IDD_MPG2SPLT_PROP_PINS,
            IDS_MPG2SPLT_PROP_PINS_TITLE
            ),
        m_hwnd                  (NULL),
        m_pIMpeg2Demultiplexer  (NULL)
{
    (* pHr) = S_OK ;
}

HRESULT
CMPEG2PropOutputPins::RefreshPinList_ (
    )
{
    CListview       OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    ULONG           cFetched ;
    IBaseFilter *   pIBaseFilter ;
    IEnumPins *     pIEnumPins ;
    IPin *          pIPin ;
    HRESULT         hr ;
    PIN_INFO        PinInfo ;
    int             row ;

    hr = S_OK ;

    pIBaseFilter    = NULL ;
    pIEnumPins      = NULL ;
    pIPin           = NULL ;
    PinInfo.pFilter = NULL ;

    if (m_pIMpeg2Demultiplexer) {

        ASSERT (m_hwnd) ;

        //  obtain our pin enumeration interface
        hr = m_pIMpeg2Demultiplexer -> QueryInterface (
                    IID_IBaseFilter,
                    (void **) & pIBaseFilter
                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIBaseFilter) ;
        hr = pIBaseFilter -> EnumPins (
                                    & pIEnumPins
                                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        //  clear out the existing list
        hr = TearDownPinList_ () ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIEnumPins) ;
        for (;;) {
            hr = pIEnumPins -> Next (1, & pIPin, & cFetched) ;

            if (FAILED (hr)     ||
                hr == S_FALSE   ||
                cFetched == 0) {

                //  yuck ! set this to the lowest common denominator
                hr = hr == S_FALSE ? S_OK : hr ;
                pIPin = NULL ;

                break ;
            }

            ASSERT (pIPin) ;

            ZeroMemory (& PinInfo, sizeof PinInfo) ;

            //  retrieve our pin information
            hr = pIPin -> QueryPinInfo (
                                & PinInfo
                                ) ;
            GOTO_NE (hr, S_OK, cleanup) ;

            //  this assert checks that things are setup properly in the
            //  filter code
            ASSERT (PinInfo.pFilter == pIBaseFilter) ;

            //  we only care about output pins
            if (PinInfo.dir == PINDIR_OUTPUT) {

                //  populate the list view

                row = OutputPins.InsertRowTextW (PinInfo.achName, 0) ;

                //  if we succeeded, stash off the pIPin interface pointer in
                //  the listview, otherwise release it
                if (row != -1) {
                    pIPin -> AddRef () ;
                    OutputPins.SetData ((DWORD_PTR) pIPin, row) ;
                }
            }

            RELEASE_AND_CLEAR (pIPin) ;
            RELEASE_AND_CLEAR (PinInfo.pFilter) ;
        }
    }

    cleanup :

    RELEASE_AND_CLEAR (pIBaseFilter) ;
    RELEASE_AND_CLEAR (pIEnumPins) ;
    RELEASE_AND_CLEAR (PinInfo.pFilter) ;
    RELEASE_AND_CLEAR (pIPin) ;

    return hr ;
}

HRESULT
CMPEG2PropOutputPins::TearDownPinList_ (
    )
{
    CListview   OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    IPin *      pIPin ;

    if (m_hwnd) {
        //  walk the list view, retrieving the IPin interface
        //  pointers and releasing them; we delete the rows at
        //  the same time, so always grab the 0th row
        while (OutputPins.GetItemCount () > 0) {

            pIPin = (IPin *) OutputPins.GetData (0) ;
            if (pIPin) {
                pIPin -> Release () ;
            }
            else {
                //  prefix bugfix
                return E_FAIL ;
            }

            if (!OutputPins.DeleteRow (0)) {
                return E_FAIL ;
            }
        }
    }

    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::PopulateComboBoxes_ (
    )
{
    CCombobox   PinType                 (m_hwnd, IDC_MPG2SPLT_PIN_TYPE) ;
    int         row ;
    int         i ;
    WCHAR       ach [32] ;

    if  (m_hwnd) {
        //  pin types
        for (i = 0; i < NUM_CANNED_TYPE; i++) {
            row = PinType.AppendW (g_CannedType [i].szDescription) ;
            if (row != CB_ERR) {

                //  i corresponds to the canned type enumeration and is used
                //  used later to index into the g_CannedType array to retrieve
                //  pin type information
                PinType.SetItemData (i, row) ;
            }
        }
        PinType.Focus (0) ;
    }

    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnCreatePin_ (
    )
{
    CCombobox       PinType     (m_hwnd, IDC_MPG2SPLT_PIN_TYPE) ;
    CListview       OutputPins  (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    CEditControl    PinName     (m_hwnd, IDC_MPG2SPLT_PIN_NAME) ;
    HRESULT         hr ;
    AM_MEDIA_TYPE   MediaType = {0} ;
    int             r ;
    DWORD           dw ;
    WCHAR           pszPinID [128] ;    //  128 = size of achName array in PIN_INFO
    DWORD_PTR       iCannedType ;
    DWORD_PTR       dwp ;
    IPin *          pIPin ;

    ASSERT (m_hwnd) ;

    hr = E_FAIL ;

    if (m_pIMpeg2Demultiplexer) {

        dwp = PinType.GetCurrentItemData (& iCannedType) ;
        if (dwp == CB_ERR) {
            return E_FAIL ;
        }

        ASSERT (iCannedType < NUM_CANNED_TYPE) ;

        //  setup the media type
        MediaType.majortype         = * g_CannedType [iCannedType].MediaType.pMajorType ;
        MediaType.subtype           = * g_CannedType [iCannedType].MediaType.pSubType ;
        MediaType.bFixedSizeSamples =   g_CannedType [iCannedType].MediaType.bFixedSizeSamples ;
        MediaType.formattype        = * g_CannedType [iCannedType].MediaType.pFormatType ;
        MediaType.cbFormat          =   g_CannedType [iCannedType].MediaType.cbFormat ;
        MediaType.pbFormat          =   g_CannedType [iCannedType].MediaType.pbFormat ;

        //  get the pin name
        PinName.GetTextW (pszPinID, 128) ;

        hr = m_pIMpeg2Demultiplexer -> CreateOutputPin (
                    & MediaType,
                    pszPinID,
                    & pIPin
                    ) ;

        if (SUCCEEDED (hr)) {
            ASSERT (pIPin) ;
            pIPin -> Release () ;
        }
        else {
            return hr ;
        }

        //  finally, we update the pin list in the properties
        hr = RefreshPinList_ () ;
    }

    return hr ;
}

void
CMPEG2PropOutputPins::SetDirty_ (
    IN  BOOL    fDirty
    )
{
    m_bDirty = fDirty ;

    if (m_pPageSite) {
        m_pPageSite -> OnStatusChange (fDirty ? PROPPAGESTATUS_DIRTY : PROPPAGESTATUS_CLEAN) ;
    }

}

//  always called after WM_INITDIALOG so we have a valid hwnd
HRESULT
CMPEG2PropOutputPins::OnActivate (
    )
{
    CListview   OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    HRESULT     hr ;

    if (m_hwnd) {
        //  create the columns
        for (int i = 0; i < PIN_COL_COUNT; i++) {
            OutputPins.InsertColumnW (
                            g_OutputPinColumns [i].szTitle,
                            g_OutputPinColumns [i].dwWidth,
                            i
                            ) ;
        }


        hr = RefreshPinList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        return PopulateComboBoxes_ () ;
    }

    return E_FAIL ;
}

HRESULT
CMPEG2PropOutputPins::OnDeactivate (
    )
{
    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnApplyChanges (
    )
{
    ASSERT (m_hwnd) ;
    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    HRESULT hr ;

    ASSERT (pIUnknown) ;

    hr = pIUnknown -> QueryInterface (
                            IID_IMpeg2Demultiplexer,
                            (void **) & m_pIMpeg2Demultiplexer
                            ) ;

    return hr ;
}

HRESULT
CMPEG2PropOutputPins::OnDisconnect (
    )
{
    RELEASE_AND_CLEAR (m_pIMpeg2Demultiplexer) ;
    return S_OK ;
}

HRESULT
CMPEG2PropOutputPins::OnDeletePin_ (
    )
{
    CListview   Pins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    int         iRow ;
    WCHAR       achPinName [128] ;          //  128 from PIN_INFO.achName
    HRESULT     hr ;

    iRow = Pins.GetSelectedRow () ;
    if (iRow == -1) {
        MessageBoxError (TEXT ("Output Pin Deletion"), TEXT ("No pin is selected.")) ;
        return E_FAIL ;
    }

    //  now the Pin name
    achPinName [0] = L'\0' ;
    Pins.GetRowTextW (iRow, 0, 128, achPinName) ;

    ASSERT (wcslen (achPinName) > 0) ;
    ASSERT (m_pIMpeg2Demultiplexer) ;

    hr = m_pIMpeg2Demultiplexer -> DeleteOutputPin (achPinName) ;

    if (SUCCEEDED (hr)) {
        hr = RefreshPinList_ () ;
    }
    else {
        MessageBoxError (TEXT (""), TEXT ("failed to delete selected output pin; hr = %08xh"), hr) ;
    }

    return hr ;
}

INT_PTR
CMPEG2PropOutputPins::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT (m_hwnd == NULL) ;
            m_hwnd = hwnd ;
            return TRUE ;
        }

        case WM_DESTROY :
        {
            TearDownPinList_ () ;
            m_hwnd = NULL ;
            break ;
        }

        case WM_COMMAND:
        {
            switch (LOWORD (wParam)) {
                case IDC_MPG2SPLT_CREATE_PIN :
                    OnCreatePin_ () ;
                    break ;

                case IDC_MPG2SPLT_PIN_TYPE :

                    switch (HIWORD (wParam)) {

                        case CBN_SELCHANGE :
                            break ;
                    } ;
                    break ;

                //case EN_CHANGE :
                //    SetDirty () ;

                case IDC_MPG2SPLT_DELETE_PIN :
                    OnDeletePin_ () ;
                    break ;
            } ;

            return TRUE ;
        }

    }
    return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

//  static
CUnknown *
WINAPI
CMPEG2PropOutputPins::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CMPEG2PropOutputPins *  pProp ;

    pProp = new CMPEG2PropOutputPins (
                        NAME ("CMPEG2PropOutputPins"),
                        pIUnknown,
                        CLSID_MPEG2DemuxPropOutputPins,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}

//  ---------------------------------------------------------------------------
//      CMpeg2PropStreamMap
//  ---------------------------------------------------------------------------

CMpeg2PropStreamMap::CMpeg2PropStreamMap (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    IN  int         iTitleStringResource,
    OUT HRESULT *   pHr
    ) : CBasePropertyPage (
            pClassName,
            pIUnknown,
            IDD_MPG2SPLT_PROP_STREAM_MAP,
            iTitleStringResource
            ),
        m_hwnd          (NULL),
        m_pIUnknown     (NULL)
{
    * pHr = S_OK ;
}

HRESULT
CMpeg2PropStreamMap::TearDownPinList_ (
    )
{
    CCombobox   OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    IPin *      pIPin ;

    if (m_hwnd) {
        //  walk the list view, retrieving the IPin interface
        //  pointers and releasing them; we delete the rows at
        //  the same time, so always grab the 0th row
        while (OutputPins.GetItemCount () > 0) {

            OutputPins.GetItemData ((DWORD_PTR *) & pIPin, 0) ;
            ASSERT (pIPin) ;
            pIPin -> Release () ;

            if (!OutputPins.DeleteRow (0)) {
                return E_FAIL ;
            }
        }
    }

    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::PopulatePinList_ (
    )
{
    CCombobox       OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    ULONG           cFetched ;
    IBaseFilter *   pIBaseFilter ;
    IEnumPins *     pIEnumPins ;
    IPin *          pIPin ;
    HRESULT         hr ;
    PIN_INFO        PinInfo ;
    int             row ;
    int             i ;

    hr = S_OK ;

    pIBaseFilter    = NULL ;
    pIEnumPins      = NULL ;
    pIPin           = NULL ;
    PinInfo.pFilter = NULL ;

    if (m_pIUnknown) {

        ASSERT (m_hwnd) ;

        //  obtain our pin enumeration interface
        hr = m_pIUnknown -> QueryInterface (
                                    IID_IBaseFilter,
                                    (void **) & pIBaseFilter
                                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIBaseFilter) ;
        hr = pIBaseFilter -> EnumPins (
                                    & pIEnumPins
                                    ) ;
        GOTO_NE (hr, S_OK, cleanup) ;

        ASSERT (pIEnumPins) ;
        for (;;) {
            hr = pIEnumPins -> Next (1, & pIPin, & cFetched) ;

            if (FAILED (hr)     ||
                hr == S_FALSE   ||
                cFetched == 0) {

                //  yuck !
                hr = hr == S_FALSE ? S_OK : hr ;
                pIPin = NULL ;

                break ;
            }

            ASSERT (pIPin) ;

            ZeroMemory (& PinInfo, sizeof PinInfo) ;

            //  retrieve our pin information
            hr = pIPin -> QueryPinInfo (
                                & PinInfo
                                ) ;
            GOTO_NE (hr, S_OK, cleanup) ;

            //  this assert checks that things are setup properly in the
            //  filter code
            ASSERT (PinInfo.pFilter == pIBaseFilter) ;

            //  we only care about output pins
            if (PinInfo.dir == PINDIR_OUTPUT) {

                //  populate the combo box
                row = OutputPins.AppendW (PinInfo.achName) ;

                //  associate the pin interface
                if (row == CB_ERR) {
                    RELEASE_AND_CLEAR (pIPin) ;
                    RELEASE_AND_CLEAR (PinInfo.pFilter) ;

                    //  break if there was an error
                    break ;
                }

                //  store the pin's interface
                i = OutputPins.SetItemData ((DWORD_PTR) pIPin, row) ;
                if (i == CB_ERR) {
                    //  delete the row (does not contain a valid tuple)
                    OutputPins.DeleteRow (row) ;

                    RELEASE_AND_CLEAR (pIPin) ;
                    RELEASE_AND_CLEAR (PinInfo.pFilter) ;

                    //  break if there was an error
                    break ;
                }
            }
            else {
                //  input pin is not stashed
                RELEASE_AND_CLEAR (pIPin) ;
            }

            RELEASE_AND_CLEAR (PinInfo.pFilter) ;
        }

        OutputPins.Focus (0) ;
    }

    cleanup :

    RELEASE_AND_CLEAR (pIBaseFilter) ;
    RELEASE_AND_CLEAR (pIEnumPins) ;
    RELEASE_AND_CLEAR (PinInfo.pFilter) ;
    RELEASE_AND_CLEAR (pIPin) ;

    return hr ;
}

void
CMpeg2PropStreamMap::SetDirty (
    IN  BOOL    fDirty
    )
{
    m_bDirty = fDirty ;

    if (m_pPageSite) {
        m_pPageSite -> OnStatusChange (fDirty ? PROPPAGESTATUS_DIRTY : PROPPAGESTATUS_CLEAN) ;
    }

}

//  always called after WM_INITDIALOG so we have a valid hwnd
HRESULT
CMpeg2PropStreamMap::OnActivate (
    )
{
    HRESULT     hr ;
    CListview   StreamMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    int         iColumnCount ;

    hr = E_FAIL ;

    if (m_hwnd) {

        iColumnCount = GetStreamMapColCount () ;

        //  stream map table
        for (int i = 0 ; i < iColumnCount ; i++) {
            StreamMap.InsertColumnW (
                            GetStreamMapColTitle (i),
                            GetStreamMapColWidth (i),
                            i
                            ) ;
        }

        //  pin list
        hr = PopulatePinList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        //  possible streams list
        hr = PopulateStreamList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        //  media sample content list
        hr = PopulateMediaSampleContentList_ () ;
        if (FAILED (hr)) {
            return hr ;
        }

        RefreshStreamMap_ () ;
    }

    return hr ;
}

HRESULT
CMpeg2PropStreamMap::OnDeactivate (
    )
/*++
    don't do the opposite of ::OnActivate() here because this method
    is not always called.  This method is only called when the property
    page is tabbed away.  It's not called when the user destroys the
    window.  Since we refcount IPin in ::OnActivate() (when we store it
    in a list), depending on this method to be called and Release'ing
    those refcounts doesn't work.  Instead, we tear down the pin list
    and Release each pin when a WM_DESTROY message is posted to the
    wndproc.  This happens when the user tabs away and when the property
    page is destroyed.
--*/
{
    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::OnApplyChanges (
    )
{
    ASSERT (m_hwnd) ;
    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::OnConnect (
    IN  IUnknown *  pIUnknown
    )
{
    ASSERT (pIUnknown) ;

    m_pIUnknown = pIUnknown ;

    //  our ref
    m_pIUnknown -> AddRef () ;

    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::OnDisconnect (
    )
{
    RELEASE_AND_CLEAR (m_pIUnknown) ;
    return S_OK ;
}

HRESULT
CMpeg2PropStreamMap::RefreshStreamMap_ (
    )
{
    CListview       StreamMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    CCombobox       OutputPins (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    IPin *          pIPin ;
    HRESULT         hr ;
    DWORD           dwPinCount ;
    DWORD           i ;

    hr = S_OK ;

    if (m_hwnd) {

        TearDownStreamMap_ () ;

        dwPinCount = OutputPins.GetItemCount () ;
        for (i = 0; i < dwPinCount && SUCCEEDED (hr); i++) {

            OutputPins.GetItemData ((DWORD_PTR *) & pIPin, i) ;
            ASSERT (pIPin) ;

            hr = AppendStreamMaps (pIPin, & StreamMap) ;
        }
    }

    return hr ;
}

INT_PTR
CMpeg2PropStreamMap::OnReceiveMessage (
    IN  HWND    hwnd,
    IN  UINT    uMsg,
    IN  WPARAM  wParam,
    IN  LPARAM  lParam
    )
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ASSERT (m_hwnd == NULL) ;
            m_hwnd = hwnd ;
            DialogInit_ () ;
            return TRUE ;
        }

        //  see ::OnDeactivate()'s comment block
        case WM_DESTROY :
        {
            TearDownPinList_ () ;
            TearDownStreamMap_ () ;
            m_hwnd = NULL ;
            break ;
        }

        case WM_COMMAND:
        {
            switch (LOWORD (wParam)) {
                case IDC_MPG2SPLT_MAP_STREAM :
                    OnMapStream_ () ;
                    break ;

                case IDC_MPG2SPLT_UNMAP_STREAM :
                    OnUnmapStream_ () ;
                    break ;
            } ;

            return TRUE ;
        }

    }
    return CBasePropertyPage::OnReceiveMessage (
                                hwnd,
                                uMsg,
                                wParam,
                                lParam
                                ) ;
}

//  ---------------------------------------------------------------------------
//      CMPEG2PropPIDMap
//  ---------------------------------------------------------------------------

CMPEG2PropPIDMap::CMPEG2PropPIDMap (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CMpeg2PropStreamMap (
            pClassName,
            pIUnknown,
            rclsid,
            IDS_MPG2SPLT_PROP_PID_MAP_TITLE,
            pHr
            ) {}

void
CMPEG2PropPIDMap::DialogInit_ (
    )
{
    SetWindowText (GetDlgItem (m_hwnd, IDC_MPG2SPLT_STREAMID_NAME), g_szPID) ;
}

HRESULT
CMPEG2PropPIDMap::PopulateStreamList_ (
    )
{
    HRESULT     hr ;
    CCombobox   PIDList (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    int         i ;
    int         row ;
    WCHAR       achbuffer [32] ;

    //  populate the PID list
    for (i = 0; i <= MAX_PID_VALUE; i++) {
        swprintf (achbuffer, L"0x%04x", i) ;
        row = PIDList.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            PIDList.SetItemData (i, row) ;
        }
    }
    PIDList.Focus (0) ;

    return S_OK ;
}

HRESULT
CMPEG2PropPIDMap::TearDownStreamMap_ (
    )
{
    CListview   PIDMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    int         i ;
    int         iPIDMapCount ;
    IPin *      pIPin ;

    iPIDMapCount = PIDMap.GetItemCount () ;

    for (i = 0; i < iPIDMapCount; i++) {
        pIPin = reinterpret_cast <IPin *> (PIDMap.GetData (i)) ;
        ASSERT (pIPin) ;
        pIPin -> Release () ;
    }

    PIDMap.ResetContent () ;

    return S_OK ;
}

HRESULT
CMPEG2PropPIDMap::AppendStreamMaps (
    IN  IPin *      pIPin,
    IN  CListview * plv
    )
{
    IEnumPIDMap *   pIEnumPIDMap ;
    HRESULT         hr ;
    IMPEG2PIDMap *  pIPinPIDMap ;
    OLECHAR *       pszPinID ;
    WCHAR           achbuffer [32] ;
    int             row ;
    PID_MAP         PIDMap ;
    DWORD           dwGot ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2PIDMap,
            (void **) & pIPinPIDMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIPinPIDMap -> EnumPIDMap (
                & pIEnumPIDMap
                ) ;

        if (SUCCEEDED (hr)) {
            hr = pIPin -> QueryId (& pszPinID) ;

            if (SUCCEEDED (hr)) {

                for (;;) {
                    hr = pIEnumPIDMap -> Next (
                            1,
                            & PIDMap,
                            & dwGot
                            ) ;
                    if (hr == S_FALSE ||
                        dwGot == 0) {

                        //  not a true failure of the call
                        hr = S_OK ;
                        break ;
                    }

                    if (FAILED (hr)) {
                        //  true failure
                        break ;
                    }

                    row = plv -> InsertRowValue (
                            reinterpret_cast <DWORD_PTR> (pIPin)
                            ) ;
                    if (row == -1) {
                        hr = E_FAIL ;
                        break ;
                    }

                    //  listview's ref
                    pIPin -> AddRef () ;

                    //  PID
                    swprintf (achbuffer, L"0x%04x", PIDMap.ulPID) ;
                    plv -> SetTextW (
                        achbuffer,
                        row,
                        PID_COL_PID
                        ) ;

                    //  pin
                    plv -> SetTextW (
                        pszPinID,
                        row,
                        PIN_COL_PID
                        ) ;

                    //  PID map content
                    ASSERT (PIDMap.MediaSampleContent <= MEDIA_TRANSPORT_PAYLOAD) ;
                    plv -> SetTextW (
                        g_TransportMediaSampleContentDesc [PIDMap.MediaSampleContent].pszDescription,
                        row,
                        MEDIA_SAMPLE_CONTENT_PID
                        ) ;
                }

                CoTaskMemFree (pszPinID) ;
            }

            pIEnumPIDMap -> Release () ;
        }

        pIPinPIDMap -> Release () ;
    }

    return hr ;
}

HRESULT
CMPEG2PropPIDMap::OnMapStream_ (
    )
{
    HRESULT                 hr ;
    CCombobox               PID             (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    CCombobox               MediaContent    (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    CCombobox               OutputPins      (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    DWORD                   dwPID ;
    WCHAR                   achPin [128] ;              //  128 is PIN_INFO.achName length
    MEDIA_SAMPLE_CONTENT    MediaSampleContent ;
    DWORD_PTR               dwptr ;
    IMPEG2PIDMap *          pIMpeg2PIDMap ;
    IPin *                  pIPin ;

    //  gather the data

    MediaContent.GetCurrentItemData (& dwptr) ;
    MediaSampleContent = (MEDIA_SAMPLE_CONTENT) dwptr ;        //  safe cast

    PID.GetCurrentItemData (& dwptr) ;
    dwPID = (DWORD) dwptr ;                                 //  safe cast

    OutputPins.GetCurrentItemData (& dwptr) ;
    if (dwptr == CB_ERR) {
        return E_FAIL ;
    }

    pIPin = reinterpret_cast <IPin *> (dwptr) ;
    ASSERT (pIPin) ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2PIDMap,
            (void **) & pIMpeg2PIDMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIMpeg2PIDMap -> MapPID (
                1,
                & dwPID,
                MediaSampleContent
                ) ;

        pIMpeg2PIDMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("PID Map"), TEXT("Could not map PID %04x; %08xh"), dwPID, hr) ;
    }

    return hr ;
}

HRESULT
CMPEG2PropPIDMap::OnUnmapStream_ (
    )
{
    HRESULT         hr ;
    CListview       PIDMaps (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    DWORD           dwPID ;
    int             iRow ;
    WCHAR           achPinName [128] ;      //  128 from PIN_INFO.achName
    IMPEG2PIDMap *  pIMpeg2PIDMap ;
    IPin *          pIPin ;
    WCHAR           achbuffer [32] ;

    iRow = PIDMaps.GetSelectedRow () ;
    if (iRow == -1) {
        MessageBoxError (TEXT ("PID Map Deletion"), TEXT ("No PID mapping is selected.")) ;
        return E_FAIL ;
    }

    //  get the PID
    achbuffer [0] = L'\0' ;
    if (PIDMaps.GetRowTextW (iRow, PID_COL_PID, 32, achbuffer) > 0) {
        if (swscanf (achbuffer, L"0x%04x", & dwPID) == 0) {
            //  PREFIX fix
            return E_FAIL ;
        }
    }
    else {
        //  prefix bugfix
        return E_FAIL ;
    }

    //  dwPID now contains a valid PID

    //  and the pin to which it is mapped
    pIPin = reinterpret_cast <IPin *> (PIDMaps.GetData (iRow)) ;
    ASSERT (pIPin) ;

    //  the interface we're going to use
    hr = pIPin -> QueryInterface (
            IID_IMPEG2PIDMap,
            (void **) & pIMpeg2PIDMap
            ) ;
    if (SUCCEEDED (hr)) {
        //  unmap
        hr = pIMpeg2PIDMap -> UnmapPID (
                1,
                & dwPID
                ) ;

        pIMpeg2PIDMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("PID Unmap"), TEXT("Could not unmap PID %04x; %08xh"), dwPID, hr) ;
    }

    return hr ;
}

WCHAR *
CMPEG2PropPIDMap::GetStreamMapColTitle (
    IN  int iCol
    )
{
    return g_PIDMapColumns [iCol].szTitle ;
}

int
CMPEG2PropPIDMap::GetStreamMapColCount (
    )
{
    return PID_PIN_COL_COUNT ;
}

int
CMPEG2PropPIDMap::GetStreamMapColWidth (
    IN  int iCol
    )
{
    return g_PIDMapColumns [iCol].dwWidth ;
}

HRESULT
CMPEG2PropPIDMap::PopulateMediaSampleContentList_ (
    )
{
    HRESULT     hr ;
    CCombobox   MediaSampleContent  (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    int         row ;
    int         k, i ;
    WCHAR       achbuffer [32] ;

    //  populate the media sample content choices
    k = sizeof g_TransportMediaSampleContentDesc / sizeof MEDIA_SAMPLE_CONTENT_DESC ;
    for (i = 0; i < k; i++) {
        row = MediaSampleContent.AppendW (g_TransportMediaSampleContentDesc [i].pszDescription) ;
        if (row != CB_ERR) {
            MediaSampleContent.SetItemData (g_TransportMediaSampleContentDesc [i].MediaSampleContent, row) ;
        }
        else {
            return E_FAIL ;
        }
    }
    MediaSampleContent.Focus (0) ;

    return S_OK ;
}

//  static
CUnknown *
WINAPI
CMPEG2PropPIDMap::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CMpeg2PropStreamMap *  pProp ;

    pProp = new CMPEG2PropPIDMap (
                        NAME ("CMPEG2PropPIDMap"),
                        pIUnknown,
                        CLSID_MPEG2DemuxPropPIDMap,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}

//  ---------------------------------------------------------------------------
//      CMPEG2PropStreamIdMap
//  ---------------------------------------------------------------------------

CMPEG2PropStreamIdMap::CMPEG2PropStreamIdMap (
    IN  TCHAR *     pClassName,
    IN  IUnknown *  pIUnknown,
    IN  REFCLSID    rclsid,
    OUT HRESULT *   pHr
    ) : CMpeg2PropStreamMap (
            pClassName,
            pIUnknown,
            rclsid,
            IDS_MPG2SPLT_PROP_STREAMID_MAP_TITLE,
            pHr
            ) {}

void
CMPEG2PropStreamIdMap::DialogInit_ (
    )
{
    int         i, k ;
    WCHAR       achbuffer [32] ;
    CCombobox   DataOffset (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET) ;
    CCombobox   FilterValue (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE) ;
    int         row, rowDefault ;

    SetWindowText (GetDlgItem (m_hwnd, IDC_MPG2SPLT_STREAMID_NAME), g_szStreamId) ;

    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE),          SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE_LABEL),    SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET),           SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET_LABEL),     SW_SHOW) ;
    ShowWindow (GetDlgItem (m_hwnd, IDC_MPG2SPLT_SUBSTREAM_FRAME),       SW_SHOW) ;

    //  populate the controls as well
    for (i = 0; i < 11; i++) {
        swprintf (achbuffer, L"%d", i) ;
        row = DataOffset.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            DataOffset.SetItemData (i, row) ;
        }
    }
    DataOffset.Focus (0) ;

    //  filter value

    swprintf (achbuffer, L"none") ;
    rowDefault = FilterValue.AppendW (achbuffer) ;
    if (rowDefault != CB_ERR) {
        FilterValue.SetItemData (SUBSTREAM_FILTER_VAL_NONE, rowDefault) ;
    }

    for (k = 0; k < 8; k++) {
        swprintf (achbuffer, L"0x%02x", 0x80 + k) ;
        row = FilterValue.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            FilterValue.SetItemData (0x80 + k, row) ;
        }
    }
    FilterValue.Focus (rowDefault) ;
}

HRESULT
CMPEG2PropStreamIdMap::PopulateStreamList_ (
    )
{
    HRESULT     hr ;
    CCombobox   StreamIdList (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    int         i ;
    int         row ;
    WCHAR       achbuffer [32] ;

    //  populate the PID list
    for (i = STREAM_ID_MIN; i <= STREAM_ID_MAX; i++) {
        swprintf (achbuffer, L"0x%02X", i) ;
        row = StreamIdList.AppendW (achbuffer) ;
        if (row != CB_ERR) {
            StreamIdList.SetItemData (i, row) ;
        }
    }
    StreamIdList.Focus (0) ;

    return S_OK ;
}

HRESULT
CMPEG2PropStreamIdMap::TearDownStreamMap_ (
    )
{
    CListview   StreamMap (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    int         i ;
    int         iStreamMapCount ;
    IPin *      pIPin ;

    iStreamMapCount = StreamMap.GetItemCount () ;

    for (i = 0; i < iStreamMapCount; i++) {
        pIPin = reinterpret_cast <IPin *> (StreamMap.GetData (i)) ;
        ASSERT (pIPin) ;
        pIPin -> Release () ;
    }

    StreamMap.ResetContent () ;

    return S_OK ;
}

HRESULT
CMPEG2PropStreamIdMap::AppendStreamMaps (
    IN  IPin *      pIPin,
    IN  CListview * plv
    )
{
    IEnumStreamIdMap *  pIEnumStreamIdMap ;
    HRESULT             hr ;
    IMPEG2StreamIdMap * pIPinStreamIdMap ;
    OLECHAR *           pszPinID ;
    WCHAR               achbuffer [32] ;
    int                 row ;
    STREAM_ID_MAP       StreamIdMap ;
    DWORD               dwGot ;

    //  media sample content is used as a 0-based index, so we assume the
    //  first is 0
    ASSERT (MPEG2_PROGRAM_STREAM_MAP == 0) ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2StreamIdMap,
            (void **) & pIPinStreamIdMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIPinStreamIdMap -> EnumStreamIdMap (
                & pIEnumStreamIdMap
                ) ;

        if (SUCCEEDED (hr)) {
            hr = pIPin -> QueryId (& pszPinID) ;

            if (SUCCEEDED (hr)) {

                for (;;) {
                    hr = pIEnumStreamIdMap -> Next (
                            1,
                            & StreamIdMap,
                            & dwGot
                            ) ;
                    if (hr == S_FALSE ||
                        dwGot == 0) {

                        //  not a true failure of the call
                        hr = S_OK ;
                        break ;
                    }

                    if (FAILED (hr)) {
                        //  true failure
                        break ;
                    }

                    row = plv -> InsertRowValue (
                            reinterpret_cast <DWORD_PTR> (pIPin)
                            ) ;
                    if (row == -1) {
                        hr = E_FAIL ;
                        break ;
                    }

                    //  listview's ref
                    pIPin -> AddRef () ;

                    //  stream_id
                    swprintf (achbuffer, L"0x%02X", StreamIdMap.stream_id) ;
                    plv -> SetTextW (
                        achbuffer,
                        row,
                        STREAM_ID_COL_STREAM
                        ) ;

                    //  pin
                    plv -> SetTextW (
                        pszPinID,
                        row,
                        PIN_COL_STREAM
                        ) ;

                    //  stream id map content
                    ASSERT (StreamIdMap.dwMediaSampleContent <= MPEG2_PROGRAM_ELEMENTARY_STREAM) ;
                    plv -> SetTextW (
                        g_ProgramMediaSampleContentDesc [StreamIdMap.dwMediaSampleContent].pszDescription,
                        row,
                        MEDIA_SAMPLE_CONTENT_STREAM
                        ) ;

                    //  filter

                    if (StreamIdMap.ulSubstreamFilterValue != SUBSTREAM_FILTER_VAL_NONE) {
                        swprintf (achbuffer, L"0x%02x", StreamIdMap.ulSubstreamFilterValue) ;
                    }
                    else {
                        swprintf (achbuffer, L"none") ;
                    }

                    plv -> SetTextW (
                        achbuffer,
                        row,
                        FILTER_COL_STREAM
                        ) ;

                    //  offset

                    swprintf (achbuffer, L"%d", StreamIdMap.iDataOffset) ;
                    plv -> SetTextW (
                        achbuffer,
                        row,
                        OFFSET_COL_STREAM
                        ) ;
                }

                CoTaskMemFree (pszPinID) ;
            }

            pIEnumStreamIdMap -> Release () ;
        }

        pIPinStreamIdMap -> Release () ;
    }

    return hr ;
}

HRESULT
CMPEG2PropStreamIdMap::OnMapStream_ (
    )
{
    HRESULT             hr ;
    CCombobox           StreamId        (m_hwnd, IDC_MPG2SPLT_STREAMS) ;
    CCombobox           MediaContent    (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    CCombobox           OutputPins      (m_hwnd, IDC_MPG2SPLT_OUTPUT_PINS) ;
    CCombobox           DataOffset      (m_hwnd, IDC_MPG2SPLT_DATA_OFFSET) ;
    CCombobox           FilterValue     (m_hwnd, IDC_MPG2SPLT_FILTER_VALUE) ;
    DWORD               dwStreamId ;
    WCHAR               achPin [128] ;              //  128 is PIN_INFO.achName length
    DWORD               MediaSampleContent ;
    DWORD_PTR           dwptr ;
    IMPEG2StreamIdMap * pIMpeg2StreamIdMap ;
    IPin *              pIPin ;
    DWORD               dwFilterVal ;
    int                 iDataOffset ;

    //  gather the data

    MediaContent.GetCurrentItemData (& dwptr) ;
    MediaSampleContent = (DWORD) dwptr ;     //  safe cast

    StreamId.GetCurrentItemData (& dwptr) ;
    dwStreamId = (DWORD) dwptr ;                                    //  safe cast

    OutputPins.GetCurrentItemData (& dwptr) ;
    if (dwptr == CB_ERR) {
        return E_FAIL ;
    }

    pIPin = reinterpret_cast <IPin *> (dwptr) ;
    ASSERT (pIPin) ;

    DataOffset.GetCurrentItemData (& dwptr) ;
    iDataOffset = (int) dwptr ;

    FilterValue.GetCurrentItemData (& dwptr) ;
    dwFilterVal = (DWORD) dwptr ;

    hr = pIPin -> QueryInterface (
            IID_IMPEG2StreamIdMap,
            (void **) & pIMpeg2StreamIdMap
            ) ;
    if (SUCCEEDED (hr)) {
        hr = pIMpeg2StreamIdMap -> MapStreamId (
                dwStreamId,
                MediaSampleContent,
                dwFilterVal,
                iDataOffset
                ) ;

        pIMpeg2StreamIdMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("StreamId Map"), TEXT("Could not map stream_id %02x; %08xh"), dwStreamId, hr) ;
    }

    return hr ;
}

HRESULT
CMPEG2PropStreamIdMap::OnUnmapStream_ (
    )
{
    HRESULT             hr ;
    CListview           StreamMaps (m_hwnd, IDC_MPG2SPLT_STREAM_MAPPINGS) ;
    DWORD               dwStreamId ;
    int                 iRow ;
    WCHAR               achPinName [128] ;      //  128 from PIN_INFO.achName
    IMPEG2StreamIdMap * pIMpeg2StreamIdMap ;
    IPin *              pIPin ;
    WCHAR               achbuffer [32] ;

    iRow = StreamMaps.GetSelectedRow () ;
    if (iRow == -1) {
        MessageBoxError (TEXT ("Stream Map Deletion"), TEXT ("No stream mapping is selected.")) ;
        return E_FAIL ;
    }

    //  get the stream_id
    achbuffer [0] = L'\0' ;
    if (StreamMaps.GetRowTextW (iRow, STREAM_ID_COL_STREAM, 32, achbuffer) > 0) {
        if (swscanf (achbuffer, L"0x%04x", & dwStreamId) == 0) {
            //  PREFIX fix
            return E_FAIL ;
        }
    }
    else {
        //  PREFIX fix
        return E_FAIL ;
    }

    //  dwStreamId now contains a valid value

    //  and the pin to which it is mapped
    pIPin = reinterpret_cast <IPin *> (StreamMaps.GetData (iRow)) ;
    ASSERT (pIPin) ;

    //  the interface we're going to use
    hr = pIPin -> QueryInterface (
            IID_IMPEG2StreamIdMap,
            (void **) & pIMpeg2StreamIdMap
            ) ;
    if (SUCCEEDED (hr)) {
        //  unmap
        hr = pIMpeg2StreamIdMap -> UnmapStreamId (
                1,
                & dwStreamId
                ) ;

        pIMpeg2StreamIdMap -> Release () ;
    }

    if (SUCCEEDED (hr)) {
        RefreshStreamMap_ () ;
    }
    else {
        MessageBoxError (TEXT("PID Unmap"), TEXT("Could not unmap stream %04x; %08xh"), dwStreamId, hr) ;
    }

    return hr ;
}

int
CMPEG2PropStreamIdMap::GetStreamMapColCount (
    )
{
    return STREAM_ID_PIN_COL_COUNT ;
}


WCHAR *
CMPEG2PropStreamIdMap::GetStreamMapColTitle (
    IN  int iCol
    )
{
    return g_StreamIdMapColumns [iCol].szTitle ;
}

int
CMPEG2PropStreamIdMap::GetStreamMapColWidth (
    IN  int iCol
    )
{
    return g_StreamIdMapColumns [iCol].dwWidth ;
}

HRESULT
CMPEG2PropStreamIdMap::PopulateMediaSampleContentList_ (
    )
{
    HRESULT     hr ;
    CCombobox   MediaSampleContent  (m_hwnd, IDC_MPG2SPLT_MEDIA_SAMPLE_CONTENT) ;
    int         row ;
    int         k, i ;
    WCHAR       achbuffer [32] ;

    //  populate the media sample content choices
    k = sizeof g_ProgramMediaSampleContentDesc / sizeof MEDIA_SAMPLE_CONTENT_DESC ;
    for (i = 0; i < k; i++) {
        row = MediaSampleContent.AppendW (g_ProgramMediaSampleContentDesc [i].pszDescription) ;
        if (row != CB_ERR) {
            MediaSampleContent.SetItemData (g_ProgramMediaSampleContentDesc [i].MediaSampleContent, row) ;
        }
        else {
            return E_FAIL ;
        }
    }
    MediaSampleContent.Focus (0) ;

    return S_OK ;
}

//  static
CUnknown *
WINAPI
CMPEG2PropStreamIdMap::CreateInstance (
    IN  IUnknown *  pIUnknown,
    IN  HRESULT *   pHr
    )
{
    CMpeg2PropStreamMap *  pProp ;

    pProp = new CMPEG2PropStreamIdMap (
                        NAME ("CMPEG2PropStreamIdMap"),
                        pIUnknown,
                        CLSID_MPEG2DemuxPropStreamIdMap,
                        pHr
                        ) ;

    if (pProp == NULL) {
        * pHr = E_OUTOFMEMORY ;
    }

    return pProp ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by graphedt.rc
//
#define VERSION_RES_BLD_MAJOR           00
#define VER_DEBUG                       0
#define IDR_MAINFRAME                   2
#define VERSION_RES_VER_MINOR           02
#define IDR_GRAPH                       3
#define ID_REMOVE_FILTER                4
#define VERSION_RES_VER_MAJOR           4
#define IDS_STAT_DRAGLINKEND            11
#define IDS_STAT_DROPLINKEND            12
#define IDS_STAT_MOVEBOX                15
#define IDS_STAT_BOXTABEMPTY            17
#define IDS_STAT_SELECTRECT             19
#define IDD_ABOUTBOX                    100
#define IDC_APPLY                       101
#define ID_PROPBUTTONS                  102
#define IDB_EDGES                       103
#define IDC_PROP_HELP                   104
#define IDC_TRUNCATE                    105
#define IDB_TABS                        106
#define IDB_EDGES_HILITE                107
#define IDB_TABS_HILITE                 108
#define IDI_FILTER                      109
#define IDC_LIST1                       110
#define IDC_REFRESH                     111
#define IDR_PINMENU                     112
#define IDR_FILTERMENU                  113
#define IDR_LINKMENU                    114
#define IDI_DOC                         116
#define IDS_VERSION                     118
#define ID__SELECTCLOCK                 119
#define IDB_CLOCK                       120
#define IDB_CLOCK_SELECT                121
#define IDS_MISSING_FILE_IN_GRAPH       122
#define IDC_FILTER_TREE                 123
#define IDD_FILTER_VIEW                 124
#define ID_ADDFILTER                    125
#define IDD_CONNECTTOGRAPH              126
#define IDS_FILENOTFOUND                127
#define IDS_ACCESSDENIED                128
#define IDS_NOTSTORAGEOBJECT            129
#define IDS_TOOMANYOPENFILES            130
#define IDS_INSUFFICIENTMEMORY          131
#define IDS_INVALIDNAME                 132
#define IDS_GENERAL_FILE_OPEN           133
#define IDS_FILE_ALREADY_OPEN           134
#define IDS_READ_ONLY                   135
#define IDS_PAUSE_TIMEOUT               136
#define IDS_DEVICE_NOT_READY            137
#define IDD_RENDER_URL                  138
#define IDC_URL_LIST                    139
#define IDC_CACHED_FILTERS              140
#define IDD_CACHED_FILTERS              141
#define IDD_STATS                       142
#define IDC_RESET                       143
#define IDD_TRUNCATE                    144
#define IDC_RESET2                      145
#define IDS_FAILED_TO_LOAD_GRAPH        146
#define IDD_SEEKBAR                     147
#define IDC_SEEKSLIDER                  148
#define IDC_RANDOM                      150
#define IDS_CMD_RECONNECT               151
#define ID_RECONNECT                    152
#define IDS_ASYNC_RECONNECT_SUCCEEDED   153
#define IDS_ASYNC_RECONNECT_FAILED      154
#define IDS_RECONNECT_PENDING           155
#define ID_INCREASE_ZOOM                200
#define ID_DECREASE_ZOOM                201
#define VER_PRODUCTBUILD                500
#define IDS_CMD_MOVEBOX                 1000
#define IDS_CMD_MOVEBOXES               1001
#define IDS_CMD_ADDFILTER               1002
#define IDS_CMD_DELETE                  1003
#define IDS_CMD_CONNECT                 1005
#define IDS_CMD_ADD_FILTER_TO_CACHE     1006
#define VERSION_RES_LANGUAGE            0x409
#define stc32                           0x045f
#define VERSION_RES_CHARSET             1252
#define IDS_MENU_UNDO                   2000
#define IDS_MENU_REDO                   2001
#define IDS_MENU_REPEAT                 2002
#define IDS_MEDIA_FILES                 2003
#define IDS_TEXT_FILES                  2004
#define IDS_SOURCE_DIALOG_TITLE         2005
#define IDS_SINK_DIALOG_TITLE           2006
#define IDS_UNCATEGORIZED_FILTERS       2007
#define ID_CANCEL_MODES                 32769
#define ID_FILE_RENDER                  32770
#define ID_FILE_SET_LOG                 32771
#define ID_EDIT_DELETE                  32778
#define ID_QUARTZ_DISCONNECT            32783
#define ID_QUARTZ_PAUSE                 32785
#define ID_QUARTZ_RUN                   32786
#define IDM_RENDER_PIN                  32787
#define ID_RENDER                       32789
#define ID_AUTOARRANGE                  32800
#define ID_WINDOW_REFRESH               32801
#define ID__PROPERTIES                  32803
#define IDM_SAVE_PERF_LOG               32805
#define ID_QUARTZ_STOP                  32807
#define ID_USE_CLOCK                    32808
#define ID_NEW_PERF_LOG                 32809
#define ID_CONNECT_SMART                32810
#define ID_SELECT_CLOCK                 32811
#define ID_INSERT_FILTER                32812
#define ID_FILE_SAVE_AS_HTML            32813
#define ID_URL_RENDER                   32814
#define ID_FILE_SAVE_AS_XML             32815
#define ID_WINDOW_ZOOM25                32816
#define ID_WINDOW_ZOOM50                32817
#define ID_WINDOW_ZOOM100               32818
#define ID_WINDOW_ZOOM200               32819
#define ID_CONNECT_TO_GRAPH             32820
#define ID_GRAPH_STATS                  32821
#define ID_GRAPH_ADDFILTERTOCACHE       32822
#define ID_GRAPH_ENUMCACHEDFILTERS      32823
#define ID_BUTTON32825                  32825
#define ID_BUTTON32826                  32826
#define ID_BUTTON32827                  32827
#define ID_BUTTON32828                  32828
#define ID_BUTTON32829                  32829
#define ID_BUTTON32830                  32830
#define ID_BUTTON32831                  32831
#define ID_BUTTON32832                  32832
#define ID_BUTTON32833                  32833
#define ID_BUTTON32834                  32834
#define ID_BUTTON32835                  32835
#define ID_BUTTON32836                  32836
#define ID_BUTTON32837                  32837
#define ID_BUTTON32838                  32838
#define ID_BUTTON32839                  32839
#define ID_BUTTON32840                  32840
#define ID_WINDOW_ZOOM75                32841
#define ID_WINDOW_ZOOM150               32842
#define ID_BUTTON32843                  32843
#define ID_DISCONNECT_FROM_GRAPH        32844
#define ID_VIEW_SEEKBAR                 32847
#define IDS_CANTCONNECT                 61216
#define IDS_CANTINITQUARTZ              61217
#define IDS_CANTCREATEFILTER            61218
#define IDS_CANT_RENDER                 61219
#define IDS_CANT_RENDER_FILE            61220
#define IDS_CANT_ADD_SOURCE_FILE        61221
#define IDS_CANTCREATESOMEFILTER        61222
#define IDS_CANTPLAY                    61224
#define IDS_CANTPAUSE                   61225
#define IDS_CANTSTOP                    61226
#define IDS_CANTDISPLAYPROPERTIES       61227
#define IDS_CMD_DISCONNECTALL           61228
#define IDS_CMD_RENDER                  61229
#define IDS_CMD_RENDERFILE              61231
#define IDS_PINS_FAILED_TO_RENDER       61232
#define IDS_SAVE_PERF_LOG               61233
#define IDS_BAD_PERF_LOG                61234
#define IDS_EC_ERROR_ABORT              61235
#define IDS_IS_GRAPH_PLAYING            61236
#define IDS_NOINTERFACE                 61237
#define IDS_CLOSE                       61238
#define IDS_CANCEL                      61239
#define IDS_NO_DUMP_PROC                61240
#define IDS_DUMP_PROC                   61241
#define IDS_MEASURE_DLL                 61242
#define IDS_CANTSETCLOCK                61243
#define IDS_CONTROL_PROC                61244
#define IDS_NO_CONTROL_PROC             61245
#define IDS_CANT_ADD_FILTER             61246
#define IDS_CANTCONNECTINPUTS           61247
#define IDS_CANTCONNECTOUTPUTS          61248
#define IDS_OK                          61249
#define IDS_APPLY                       61250
#define IDS_HELP                        61251
#define IDS_NO_REFCLOCK                 61252
#define IDS_FAILED_SETSYNC              61253
#define IDS_FAILED_FILTER_FILE_LOAD     61254
#define IDS_FILE_SAVE_FAILED            61255
#define IDS_NO_TERMINATE_PROC           61256
#define IDS_TERMINATE_PROC              61257
#define IDS_RETURN_CODE                 61259
#define IDS_SAVE_HTML_EXT               61260
#define IDS_SAVE_HTML_FILTER            61261
#define IDS_SAVE_HTML_FILE_ERR          61262
#define IDS_SAVE_HTML_GRAPH_ERR         61263
#define IDS_SAVE_HTML_ERR               61264
#define IDS_SAVE_XML_EXT                61265
#define IDS_SAVE_XML_FILTER             61266
#define IDS_SAVE_XML_FILE_ERR           61267
#define IDS_SAVE_XML_GRAPH_ERR          61268
#define IDS_SAVE_XML_ERR                61269
#define IDS_CANT_CREATE_DIALOG          61270
#define IDS_GRAPHSPY_NOT_ENABLED        61273
#define IDS_CANT_LOAD_HELP              61274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        157
#define _APS_NEXT_COMMAND_VALUE         32848
#define _APS_NEXT_CONTROL_VALUE         156
#define _APS_NEXT_SYMED_VALUE           156
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\graphedt\rndrurl.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <wininet.h>
#include "rndrurl.h"

char gszPersistPath[]="Software\\Microsoft\\ActiveMovie\\GraphEdit\\URLPersistList";

BEGIN_MESSAGE_MAP(CRenderURL, CDialog)
END_MESSAGE_MAP()

//
// Constructor
//
CRenderURL::CRenderURL(char *szURLName, int cb, CWnd * pParent): 
    CDialog(IDD_RENDER_URL, pParent) 
{
    m_iCurrentSel=0;
    m_iURLListLength=0;
    m_psz=szURLName;
    m_psz[0]='\0';
    m_cb = cb;
}

CRenderURL::~CRenderURL()
{
}

void CRenderURL::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);    

    //{{AFX_DATA_MAP(CFontPropPage)
        DDX_Control(pDX, IDC_URL_LIST, m_ComboBox);
    //}}AFX_DATA_MAP
}

BOOL CRenderURL::OnInitDialog()
{
    CDialog::OnInitDialog();

    //pre-allocate storage for the list box for efficiency
    m_ComboBox.InitStorage(URL_LIST_SIZE, INTERNET_MAX_URL_LENGTH);

    //set the max number of chars that will go in the edit box
    m_ComboBox.LimitText(sizeof(URLSTRING));

    // retrieve the persisted URL names from the registry
    HKEY hkey=NULL;
    DWORD dwaction=0;
    DWORD dwresult = RegCreateKeyEx(HKEY_CURRENT_USER, gszPersistPath,
    			0,
    			NULL, //class of the object type
    			REG_OPTION_NON_VOLATILE,
    			KEY_QUERY_VALUE,
    			NULL, // security attributes
    			&hkey,
    			&dwaction) ;
    if ( dwresult != ERROR_SUCCESS ) {
       AfxMessageBox("Failed to open/create registry key");
    }

    int i;
    for (i=0; i < URL_LIST_SIZE; ++i) {
        char szFile[10];
        char szFileNum[10];
        long lError;
        wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));
        DWORD cb=INTERNET_MAX_URL_LENGTH;
        lError = RegQueryValueEx(hkey, szFile, NULL, NULL, reinterpret_cast<BYTE *>(m_rgszURL[i]), &cb);
        // We never have a break in the sequence of URL names, if there are fewer
        // names than URL_LIST_SIZE we must be done
        if (lError != ERROR_SUCCESS)
            break;
    }

    RegCloseKey(hkey);

    m_iURLListLength=i;

    // fill the list of the combo box with the persisted URLs, fill the most recent
    // as the first entry in the list
    for (i=m_iURLListLength-1; i >=0; --i)  {
        int iPos=m_ComboBox.InsertString(m_iURLListLength-1-i, m_rgszURL[i]);
        ASSERT(iPos == m_iURLListLength-1-i);
    }

    // show the most recent URL in the edit box set the initial focus on the
    // combo box

    if (m_iURLListLength)
        m_ComboBox.SetWindowText(m_rgszURL[m_iURLListLength-1]);

    m_ComboBox.SetFocus();

    return(0); // we set the focus our selves
}

void CRenderURL::OnOK()
{
    // get the string in the edit box
    m_ComboBox.GetWindowText(m_psz, m_cb);
    if (strlen(m_psz) == 0)
        return;

    //if this string is in the combo box list, then there is nothing new to
    // persist
    if (m_ComboBox.FindStringExact(0, m_psz) != CB_ERR) {         
        CDialog::OnOK();
        return;
    }

    // otherwise save this URL path in the registry URL list
    HKEY hkey=NULL;
    DWORD dwaction=0;
    DWORD dwresult = RegCreateKeyEx(HKEY_CURRENT_USER, gszPersistPath,
    			0,
    			NULL, //class of the object type
    			REG_OPTION_NON_VOLATILE,
    			KEY_SET_VALUE,
    			NULL, // security attributes
    			&hkey,
    			&dwaction) ;
    if ( dwresult != ERROR_SUCCESS ) {
       AfxMessageBox("Failed to open/create registry key");
       return;
    }

    // if we have a full list, we will follow MRU and throw away the oldest added
    // URL
    int iList = (m_iURLListLength == URL_LIST_SIZE) ? m_iURLListLength-1 : m_iURLListLength;
    char szFile[10];
    char szFileNum[10];
    long lError;
    for (int i=0; i < iList; ++i) {
        wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));

        // if we have a full list, we will follow MRU and throw away the oldest added
        // URL
        if (m_iURLListLength == URL_LIST_SIZE)            
            lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
                reinterpret_cast<BYTE *>(m_rgszURL[i+1]), sizeof(m_rgszURL[i+1]));
        else 
            lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
                reinterpret_cast<BYTE *>(m_rgszURL[i]), sizeof(m_rgszURL[i]));

        if (lError != ERROR_SUCCESS) {
            AfxMessageBox("Failed to write to a registry key");
            RegCloseKey(hkey);
            return;
        }
    }

    // add the new URL to the list
    wsprintf(szFile, "URL%s", _itoa(i, szFileNum, 10));
    lError= RegSetValueEx(hkey, szFile, NULL, REG_SZ,
            reinterpret_cast<BYTE *>(m_psz), m_cb);

    RegCloseKey(hkey);

    if (lError != ERROR_SUCCESS) {
        AfxMessageBox("Failed to write to a registry key");
        return;
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\mp2prop.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        mp2prop.h

    Abstract:

        This module contains the class declarations for the filter
        properties

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created

--*/

#ifndef _mp2demux__prop_h
#define _mp2demux__prop_h

//  forward declarations
class CMPEG2PropOutputPins ;
class CMPEG2PropPIDMap ;
class CListview ;

//  ---------------------------------------------------------------------------
//      property page GUIDs
//  ---------------------------------------------------------------------------

//  output pin manipulation
// {960F051B-A25C-4ac4-8D30-050CD47A814F}
DEFINE_GUID (CLSID_MPEG2DemuxPropOutputPins,
0x960f051b, 0xa25c, 0x4ac4, 0x8d, 0x30, 0x5, 0xc, 0xd4, 0x7a, 0x81, 0x4f) ;

//  PID mappings
// {ae83f13d-51b5-4a85-8c3a-ecc9f50c557a}
DEFINE_GUID (CLSID_MPEG2DemuxPropPIDMap,
0xae83f13d, 0x51b5, 0x4a85, 0x8c, 0x3a, 0xec, 0xc9, 0xf5, 0xc, 0x55, 0x7a) ;

//  stream_id mappings
// {E04BBB8F-CB77-499e-B815-468B1C3ED88F}
DEFINE_GUID(CLSID_MPEG2DemuxPropStreamIdMap,
0xe04bbb8f, 0xcb77, 0x499e, 0xb8, 0x15, 0x46, 0x8b, 0x1c, 0x3e, 0xd8, 0x8f) ;

//  ---------------------------------------------------------------------------
//      class declarations
//  ---------------------------------------------------------------------------

//  output pin manipulation property page
class CMPEG2PropOutputPins :
    public CBasePropertyPage
{
    IMpeg2Demultiplexer *   m_pIMpeg2Demultiplexer ;
    HWND                    m_hwnd ;

    HRESULT
    RefreshPinList_ (
        ) ;

    HRESULT
    PopulateComboBoxes_ (
        ) ;

    HRESULT
    TearDownPinList_ (
        ) ;

    HRESULT
    OnCreatePin_ (
        ) ;

    HRESULT
    OnDeletePin_ (
        ) ;

    void
    SetDirty_ (
        IN  BOOL    fDirty = TRUE
        ) ;

    public :

        CMPEG2PropOutputPins (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

//  PID mappings property page
class CMpeg2PropStreamMap :
    public CBasePropertyPage
{
    HRESULT
    PopulatePinList_ (
        ) ;

    HRESULT
    TearDownPinList_ (
        ) ;

    protected :

        HRESULT
        RefreshStreamMap_ (
            );

        virtual
        HRESULT
        PopulateStreamList_ (
            ) = 0 ;

        virtual
        HRESULT
        PopulateMediaSampleContentList_ (
            ) = 0 ;

        virtual
        HRESULT
        OnMapStream_ (
            ) = 0 ;

        virtual
        HRESULT
        OnUnmapStream_ (
            ) = 0 ;

        virtual
        HRESULT
        TearDownStreamMap_ (
            ) = 0 ;

        virtual
        HRESULT
        AppendStreamMaps (
            IN  IPin *      pIPin,
            IN  CListview * plv
            ) = 0 ;

        virtual
        int
        GetStreamMapColCount (
            ) = 0 ;

        virtual
        WCHAR *
        GetStreamMapColTitle (
            IN  int iCol
            ) = 0 ;

        virtual
        int
        GetStreamMapColWidth (
            IN  int iCol
            ) = 0 ;

        virtual
        void
        DialogInit_ (
            ) = 0 ;

        HWND        m_hwnd ;
        IUnknown *  m_pIUnknown ;

    public :

        CMpeg2PropStreamMap (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            IN  int         iTitleStringResource,
            OUT HRESULT *   pHr
            ) ;

        void
        SetDirty (
            IN  BOOL    fDirty = TRUE
            ) ;

        HRESULT
        OnActivate (
            ) ;

        HRESULT
        OnApplyChanges (
            ) ;

        HRESULT
        OnConnect (
            IN  IUnknown *  pIUnknown
            ) ;

        HRESULT
        OnDeactivate (
            ) ;

        HRESULT
        OnDisconnect (
            ) ;

        INT_PTR
        OnReceiveMessage (
            IN  HWND    hwnd,
            IN  UINT    uMsg,
            IN  WPARAM  wParam,
            IN  LPARAM  lParam
            ) ;
} ;

class CMPEG2PropPIDMap :
    public CMpeg2PropStreamMap
{
    virtual
    HRESULT
    PopulateStreamList_ (
        ) ;

    virtual
    HRESULT
    TearDownStreamMap_ (
        ) ;

    virtual
    HRESULT
    PopulateMediaSampleContentList_ (
        ) ;

    virtual
    HRESULT
    OnMapStream_ (
        ) ;

    virtual
    HRESULT
    OnUnmapStream_ (
        ) ;

    virtual
    HRESULT
    AppendStreamMaps (
        IN  IPin *      pIPin,
        IN  CListview * plv
        ) ;

    virtual
    int
    GetStreamMapColCount (
        ) ;

    virtual
    WCHAR *
    GetStreamMapColTitle (
        IN  int iCol
        ) ;

    virtual
    int
    GetStreamMapColWidth (
        IN  int iCol
        ) ;

    virtual
    void
    DialogInit_ (
        ) ;

    public :

        CMPEG2PropPIDMap (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

class CMPEG2PropStreamIdMap :
    public CMpeg2PropStreamMap
{
    virtual
    HRESULT
    PopulateStreamList_ (
        ) ;

    virtual
    HRESULT
    TearDownStreamMap_ (
        ) ;

    virtual
    HRESULT
    PopulateMediaSampleContentList_ (
        ) ;

    virtual
    HRESULT
    OnMapStream_ (
        ) ;

    virtual
    HRESULT
    OnUnmapStream_ (
        ) ;

    virtual
    HRESULT
    AppendStreamMaps (
        IN  IPin *      pIPin,
        IN  CListview * plv
        ) ;

    virtual
    WCHAR *
    GetStreamMapColTitle (
        IN  int iCol
        ) ;

    virtual
    int
    GetStreamMapColCount (
        ) ;

    virtual
    int
    GetStreamMapColWidth (
        IN  int iCol
        ) ;

    virtual
    void
    DialogInit_ (
        ) ;

    public :

        CMPEG2PropStreamIdMap (
            IN  TCHAR *     pClassName,
            IN  IUnknown *  pIUnknown,
            IN  REFCLSID    rclsid,
            OUT HRESULT *   pHr
            ) ;

        DECLARE_IUNKNOWN ;

        static
        CUnknown *
        WINAPI
        CreateInstance (
            IN  IUnknown *  pIUnknown,
            IN  HRESULT *   pHr
            ) ;
} ;

#endif  //  _mp2demux__prop_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\atscproppage.cpp ===
// ATSCPropPage.cpp : Implementation of CATSCPropPage
#include "stdafx.h"
#include "NPPropPage.h"
#include "ATSCPropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCPropPage

void
CATSCPropPage::FillControlsFromLocator (
	IATSCLocator* pATSCLocator
	)
{
	if (!pATSCLocator)
		return;

	USES_CONVERSION;
	TCHAR	szText[MAX_PATH];
	CComBSTR genericString;
	long lGenericValue;
	HWND hwndControl;

	HRESULT hr = pATSCLocator->get_PhysicalChannel (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_PHYSICAL_CHANNEL);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pATSCLocator->get_CarrierFrequency (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_CARRIER_FREQUENCY);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pATSCLocator->get_SymbolRate (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_SYMBOL_RATE);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pATSCLocator->get_TSID (&lGenericValue);
	if (SUCCEEDED (hr))
	{
		hwndControl = GetDlgItem (IDC_EDIT_TSID);
		wsprintf (szText, _T("%ld"), lGenericValue);
		::SetWindowText (hwndControl,  szText);
	}
	
	hwndControl = GetDlgItem (IDC_EDIT_MODULATION);
	::SetWindowText (hwndControl,  _T ("BDA_MOD_8VSB"));
}

void
CATSCPropPage::FillControlsFromTuneRequest (
	IATSCChannelTuneRequest* pTuneRequest
	)
{
	if (!pTuneRequest)
		return;
	
	//USES_CONVERSION;
	TCHAR	szText[MAX_PATH];
	long lChannel;
	HRESULT hr = pTuneRequest->get_Channel (&lChannel);
	//BUGBUG - add some error code stuff here
	if (SUCCEEDED (hr))
	{
		HWND hwndControl = GetDlgItem (IDC_EDIT_MAJOR_CHANNEL);
		wsprintf (szText, _T("%ld"), lChannel);
		::SetWindowText (hwndControl,  szText);
	}
	hr = pTuneRequest->get_MinorChannel (&lChannel);
	//BUGBUG - add some error code stuff here
	if (SUCCEEDED (hr))
	{
		HWND hwndControl = GetDlgItem (IDC_EDIT_MINOR_CHANNEL);
		wsprintf (szText, _T("%ld"), lChannel);
		::SetWindowText (hwndControl,  szText);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\atscproppage.h ===
// ATSCPropPage.h : Declaration of the CATSCPropPage

#ifndef __ATSCPROPPAGE_H_
#define __ATSCPROPPAGE_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_ATSCPropPage;
#include "misccell.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCPropPage
class ATL_NO_VTABLE CATSCPropPage :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCPropPage, &CLSID_ATSCPropPage>,
	public IPropertyPageImpl<CATSCPropPage>,
	public CDialogImpl<CATSCPropPage>,
    public IBroadcastEvent
{
public:
	CATSCPropPage():
	  m_bFirstTime (true)
	{
		m_dwTitleID = IDS_TITLEATSCPropPage;
		m_dwHelpFileID = IDS_HELPFILEATSCPropPage;
		m_dwDocStringID = IDS_DOCSTRINGATSCPropPage;
	}

	enum {IDD = IDD_ATSCPROPPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_ATSCPROPPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATSCPropPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
END_COM_MAP()

BEGIN_MSG_MAP(CATSCPropPage)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_HANDLER(IDC_BUTTON_VALIDATE, BN_CLICKED, OnValidateTuneRequest)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_TUNE_REQUEST, BN_CLICKED, OnSubmitTuneRequest)
	CHAIN_MSG_MAP(IPropertyPageImpl<CATSCPropPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    typedef IPropertyPageImpl<CATSCPropPage> PPGBaseClass;

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
	{
		// If we don't have any objects, this method should not be called
		// Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
		if (!m_ppUnk)
			return E_UNEXPECTED;

		// Use Activate to update the property page's UI with information
		// obtained from the objects in the m_ppUnk array

		// We update the page to display the Name and ReadOnly properties of the document

		// Call the base class
		HRESULT hr = PPGBaseClass::Activate(hWndParent, prc, bModal);

        if (!m_ppUnk[0])
            return E_UNEXPECTED;

        //if already advised, unadvise
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            if (pConPoint)
                pConPoint->Unadvise (m_dwEventCookie);
            m_pBroadcastEventService.Release ();
        }

        IBroadcastEvent* pEvent = NULL;
        //register for events
        hr = CBDAMiscellaneous::RegisterForEvents (
            m_ppUnk[0], 
            static_cast<IBroadcastEvent*>(this),
            &pEvent, 
            m_dwEventCookie
            );
        if (SUCCEEDED (hr))
            m_pBroadcastEventService.Attach (pEvent);

		m_pTuner = m_ppUnk[0];
        if (!m_pTuner)
            return E_FAIL;

        return Refresh ();
	}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CNP_CommonPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}
	
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		USES_CONVERSION;
		//set the spins
		HWND hwndSpin = GetDlgItem (IDC_SPIN_PHYSICAL_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_MINOR_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_MAJOR_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		return 0;
	}

private:
	CComQIPtr   <IScanningTuner>			m_pTuner;
	CComQIPtr   <IATSCChannelTuneRequest>	m_pCurrentTuneRequest;
	CComQIPtr   <IMediaEventEx>			    m_pEventInterface;
    CComPtr     <IBroadcastEvent>           m_pBroadcastEventService;
	bool								    m_bFirstTime;
    DWORD                                   m_dwEventCookie;

	void
	FillControlsFromLocator (
		IATSCLocator* pATSCLocator
		);

	void
	FillControlsFromTuneRequest (
		IATSCChannelTuneRequest* pTuneRequest
		);

	HRESULT
	UpdateTuneRequest ()
	{
		if (!m_pCurrentTuneRequest)
			return E_FAIL;

		USES_CONVERSION;
		
		LONG lMinorChannel = GetDlgItemInt (IDC_EDIT_MINOR_CHANNEL);
		LONG lMajorChannel = GetDlgItemInt (IDC_EDIT_MAJOR_CHANNEL);
		LONG lPhysicalChannel = GetDlgItemInt (IDC_EDIT_PHYSICAL_CHANNEL);
		if (FAILED (m_pCurrentTuneRequest->put_Channel (lMajorChannel)))
		{
            MESSAGEBOX (this, IDS_PUT_CHANNEL);
			return S_OK;
		}
		if (FAILED (m_pCurrentTuneRequest->put_MinorChannel (lMinorChannel)))
		{
			MESSAGEBOX (this, IDS_PUT_MINOR_CHANNEL);
			return S_OK;
		}
		CComPtr <ILocator> pLocator;
		m_pCurrentTuneRequest->get_Locator (&pLocator);
		CComQIPtr <IATSCLocator> pATSCLocator (pLocator);
		if (!pATSCLocator)
		{
			MESSAGEBOX (this, IDS_CANNOT_IATSCLOCATOR);
			return S_OK;
		}
		if (FAILED (pATSCLocator->put_PhysicalChannel (lPhysicalChannel)))
		{
			MESSAGEBOX (this, IDS_PUT_PHYSICAL);
			return S_OK;
		}

		return S_OK;
	}

	LRESULT OnValidateTuneRequest(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (SUCCEEDED (UpdateTuneRequest ()))
		{
			if (FAILED(m_pTuner->Validate (m_pCurrentTuneRequest)))
			{
				MESSAGEBOX (this, IDS_NOT_VALID_TUNE_REQUEST);
				return S_OK;
			}
		}
				
		return S_OK;
	}

	LRESULT OnSubmitTuneRequest(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (SUCCEEDED (UpdateTuneRequest ()))
		{
			if (FAILED(m_pTuner->put_TuneRequest (m_pCurrentTuneRequest)))
			{
				MESSAGEBOX (this, IDS_CANNOT_SUBMIT_TUNE_REQUEST);
				return S_OK;
			}
		}
				
		return S_OK;
	}	

    STDMETHOD(Fire)(GUID EventID)
    {
#ifdef DEBUG
        TCHAR szInfo[MAX_PATH];
        CComBSTR bstrEventID;
        USES_CONVERSION;
        StringFromCLSID (EventID, &bstrEventID);
        wsprintf (szInfo, _T("Notification received for %s"), OLE2T (bstrEventID));
        ATLTRACE (szInfo);
#endif
        if (EventID == EVENTID_TuningChanged)
        {
            ATLTRACE ("Starting to refresh");
            Refresh ();        
        }
        return S_OK;
    }

    HRESULT Refresh ()
    {
		//get the tunning spaces
		//1. get the current tuning space
		CComPtr <ITuningSpace> pTuneSpace;
		CComPtr <ITuneRequest> pTuneRequest;

		HRESULT hr = m_pTuner->get_TuneRequest (&pTuneRequest);
		if ((FAILED (hr)) || (!pTuneRequest))
			return E_FAIL;

		if (m_pCurrentTuneRequest)
			m_pCurrentTuneRequest.Release ();
		m_pCurrentTuneRequest = pTuneRequest;
		if (!m_pCurrentTuneRequest)
            //could be just the first tune request, we will get notification again..
			return S_OK;
		FillControlsFromTuneRequest (m_pCurrentTuneRequest);
		CComPtr <ILocator> pLocator;
		m_pCurrentTuneRequest->get_Locator (&pLocator);
		CComQIPtr <IATSCLocator> pATSCLocator(pLocator);
		if (!pATSCLocator)
			return E_FAIL;
		FillControlsFromLocator (pATSCLocator);
        return S_OK;
    }

    virtual void OnFinalMessage( HWND hWnd )
    {
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            pConPoint->Unadvise (m_dwEventCookie);
        }
    }
};

#endif //__ATSCPROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\uictrl.cpp ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        uictrl.cpp

    Abstract:

        This module contains the class implementations for thin win32
        control wrappers which are used on the property pages

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created

--*/

#include <streams.h>
#include <commctrl.h>
#include <tchar.h>
#include "uictrl.h"

static
LPWSTR
AnsiToUnicode (
    IN  LPCSTR  string,
    OUT LPWSTR  buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = L'\0';
	MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);

	return buffer;
}

static
LPSTR
UnicodeToAnsi (
    IN  LPCWSTR string,
    OUT LPSTR   buffer,
    IN  DWORD   buffer_len
    )
{
	buffer [0] = '\0';
	WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len, NULL, FALSE);

	return buffer;
}

/*++
        C C o n t r o l B a s e
--*/

CControlBase::CControlBase (
    HWND    hwnd,
    DWORD   id
    )
{
    ASSERT (hwnd) ;

    m_hwnd = GetDlgItem (hwnd, id) ;
    m_id = id ;

#ifndef UNICODE
    m_pchScratch = & m_achBuffer [0] ;
    m_pchScratchMaxString = MAX_STRING ;
#endif  //  UNICODE
}

TCHAR *
CControlBase::ConvertToUIString_ (
    IN     WCHAR *  szIn
    )
{
    //  we convert or not based on what the UI is.  If UNICODE is defined
    //  the UI is unicode, and thus is compatible with the sz parameter.
    //  If UNICODE is not defined, then the UI is ansi and a conversion
    //  must be made.

#ifdef UNICODE
    return szIn ;         //  the easy case - UI is UNICODE
#else   //  ansi

    int     len ;
    char *  szOut ;

    //  compute required length and get a scratch buffer
    len = wcslen (szIn) + 1 ;           //  include null-terminator
    szOut = GetScratch_ (& len) ;

    //  we'll get _something_ via the above call
    ASSERT (szOut) ;

    return UnicodeToAnsi (
                szIn,
                szOut,
                len
                ) ;
#endif  //  UNICODE
}

//  called to obtain a UI-compatible buffer
TCHAR *
CControlBase::GetUICompatibleBuffer_ (
    IN  WCHAR *     sz,
    IN OUT int *    pLen
    )
{
#ifdef UNICODE  //  easy case
    return sz ;
#else   //  ansi
    return GetScratch_ (pLen) ;
#endif  //  UNICODE
}

//  called with a UI-filled buffer; ensures that szUnicode has what sz
//  points to; obtain sz via GetUICompatibleBuffer_ to minimize
//  string operations i.e. sz may be szUnicode
WCHAR *
CControlBase::ConvertToUnicodeString_ (
    IN  TCHAR * sz,             //  buffer to convert; null-terminated
    IN  WCHAR * szUnicode,      //  requested buffer
    IN  int     MaxLen          //  max length of szUnicode buffer
    )
{
#ifdef UNICODE
    //  assert assumes that sz was obtained via call to GetUICompatibleBuffer_ ()
    ASSERT (sz == szUnicode) ;
    return sz ;
#else   //  ansi
    //  assert assumes that sz was obtained via call to GetUICompatibleBuffer_ ()
    ASSERT ((LPVOID) & sz [0] != (LPVOID) & szUnicode [0]) ;
    return AnsiToUnicode (sz, szUnicode, MaxLen) ;
#endif  //  UNICODE
}

HWND
CControlBase::GetHwnd (
    )
{
    return m_hwnd ;
}

DWORD
CControlBase::GetId (
    )
{
    return m_id ;
}

/*++
        C E d i t C o n t r o l
--*/

CEditControl::CEditControl (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
    ASSERT (hwnd) ;
}

void
CEditControl::SetTextW (
    WCHAR * szText
    )
{
    ASSERT (szText) ;

    SetWindowText (m_hwnd, ConvertToUIString_ (szText)) ;
}

void
CEditControl::SetTextW (
    INT val
    )
{
    WCHAR achbuffer [32] ;
    SetTextW (_itow (val, achbuffer, 10)) ;
}

int
CEditControl::GetTextW (
    INT *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 31)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CEditControl::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    TCHAR * szUI ;
    int     len ;
    int     r ;

    //  get our UI compatible buffer
    len = MaxChars ;
    szUI = GetUICompatibleBuffer_ (ach, & len) ;

    ASSERT (szUI) ;
    ASSERT (len <= MaxChars) ;

    //  get the text (include null-terminator in length)
    r = GetWindowText (m_hwnd, szUI, len) ;

    //  make sure we have it in our UNICODE buffer
    //  include room for the null-terminator
    ConvertToUnicodeString_ (szUI, ach, r + 1) ;

    return r ;
}

LRESULT
CEditControl::ResetContent ()
{
    return SendMessage (m_hwnd, WM_CLEAR, 0, 0) ;
}

/*++
        C C o m b o b o x
--*/

CCombobox::CCombobox (
    HWND    hwnd,
    DWORD   id
    ) : CControlBase (hwnd, id)
{
}

int
CCombobox::AppendW (
    WCHAR *  sz
    )
{
    return (int) SendMessage (m_hwnd, CB_ADDSTRING, 0, (LPARAM) ConvertToUIString_ (sz)) ;
}

int
CCombobox::AppendW (
    INT val
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return AppendW (_itow (val, achbuffer, 10)) ;
}

int
CCombobox::InsertW (
    WCHAR * sz,
    int     index)
{
    return (int) SendMessage (m_hwnd, CB_INSERTSTRING, (WPARAM) index, (LPARAM) ConvertToUIString_ (sz)) ;
}

int
CCombobox::InsertW (
    INT val,
    int index
    )
{
    WCHAR   achbuffer [32] ;        //  no numbers are longer

    return InsertW (_itow (val, achbuffer, 10), index) ;
}

BOOL
CCombobox::DeleteRow (
    int iRow
    )
{
    return (SendMessage (m_hwnd, CB_DELETESTRING, (WPARAM) iRow, 0) != CB_ERR) ;
}

int
CCombobox::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCOUNT, 0, 0) ;
}

int
CCombobox::GetTextW (
    WCHAR * ach,
    int     MaxChars
    )
{
    int     index ;
    int     count ;
    int     len ;
    TCHAR * szUI ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        //  might be that it's not a dropdown list - in which case we get;
        //  try to get just the edit control's text; if that fails, return
        //  a failure, otherwise we're ok

        //  first get a UI compatible buffer
        len = MaxChars ;
        szUI = GetUICompatibleBuffer_ (ach, & len) ;
        ASSERT (szUI) ;

        count = GetWindowText (m_hwnd, szUI, len) ;
        if (count == 0) {
            return CB_ERR ;
        }

        ASSERT (count <= len) ;
        ASSERT (len <= MaxChars) ;

        //  now convert back to UNICODE (include null-terminator)
        ConvertToUnicodeString_ (szUI, ach, count + 1) ;

        return count ;
    }

    //  make sure it will fit
    if (SendMessage (m_hwnd, CB_GETLBTEXTLEN, (WPARAM) index, 0) + 1 > MaxChars) {
        return CB_ERR ;
    }

    //  get a UI compatible buffer
    len = MaxChars ;
    szUI = GetUICompatibleBuffer_ (ach, & len) ;
    ASSERT (szUI) ;

    count = (int) SendMessage (m_hwnd, CB_GETLBTEXT, (WPARAM) index, (LPARAM) szUI) ;

    ASSERT (count < len) ;
    ASSERT (len <= MaxChars) ;

    //  include NULL terminator
    ConvertToUnicodeString_ (szUI, ach, count + 1) ;

    return count ;
}

int
CCombobox::GetTextW (
    int * val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetTextW (achbuffer, 32)) {
        * val = _wtoi (achbuffer) ;
    }

    return * val ;
}

int
CCombobox::Focus (
    int index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETCURSEL, (WPARAM) index, 0) ;
}

LRESULT
CCombobox::ResetContent (
    )
{
    return SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0) ;
}

int
CCombobox::SetItemData (
    DWORD_PTR   val,
    int         index
    )
{
    return (int) SendMessage (m_hwnd, CB_SETITEMDATA, (WPARAM) index, (LPARAM) val) ;
}

int
CCombobox::GetCurrentItemIndex (
    )
{
    return (int) SendMessage (m_hwnd, CB_GETCURSEL, 0, 0) ;
}

DWORD_PTR
CCombobox::GetItemData (
    DWORD_PTR * pval,
    int         index
    )
{
    DWORD_PTR   dwp ;

    ASSERT (pval) ;

    dwp = SendMessage (m_hwnd, CB_GETITEMDATA, (WPARAM) index, 0) ;
    (* pval) = dwp ;

    return dwp ;
}

DWORD_PTR
CCombobox::GetCurrentItemData (
    DWORD_PTR * pval
    )
{
    int index ;

    index = GetCurrentItemIndex () ;
    if (index == CB_ERR) {
        (* pval) = CB_ERR ;
        return CB_ERR ;
    }

    return GetItemData (pval, index) ;
}


/*++
        C L i s t v i e w
--*/

CListview::CListview (
    HWND hwnd,
    DWORD id
    ) : CControlBase (hwnd, id),
        m_cColumns (0)
{
}

LRESULT
CListview::ResetContent (
    )
{
    return SendMessage (m_hwnd, LVM_DELETEALLITEMS, 0, 0) ;
}

BOOL
CListview::SetData (
    DWORD_PTR   dwData,
    int         iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.lParam   = (LPARAM) dwData ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::SetTextW (
    WCHAR * sz,
    int iRow,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = ConvertToUIString_ (sz) ;

    return ListView_SetItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowIcon (
    int iIcon
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_IMAGE ;
    lvItem.iImage   = iIcon ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowValue (
    DWORD_PTR dwp
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.lParam   = (LPARAM) dwp ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

int
CListview::InsertRowNumber (
    int i,
    int iCol
    )
{
    WCHAR achbuffer [16] ;

    return InsertRowTextW (
                    _itow (i, achbuffer, 10),
                    iCol
                    ) ;
}

int
CListview::InsertRowTextW (
    WCHAR * sz,
    int iCol
    )
{
    LVITEM  lvItem = {0} ;

    ASSERT (sz) ;

    lvItem.mask     = LVIF_TEXT ;
    lvItem.iSubItem = iCol ;
    lvItem.pszText  = ConvertToUIString_ (sz) ;

    return ListView_InsertItem (m_hwnd, & lvItem) ;
}

BOOL
CListview::DeleteRow (
    int iRow
    )
{
    return ListView_DeleteItem (m_hwnd, iRow) ;
}

int
CListview::GetSelectedCount (
    )
{
    return ListView_GetSelectedCount (m_hwnd) ;
}

int
CListview::GetSelectedRow (
    int iStartRow
    )
{
    return ListView_GetNextItem (m_hwnd, iStartRow, LVNI_SELECTED) ;
}

DWORD_PTR
CListview::GetData (
    int iRow
    )
{
    LVITEM  lvItem = {0} ;

    lvItem.mask     = LVIF_PARAM ;
    lvItem.iItem    = iRow ;
    lvItem.iSubItem = m_cColumns ;

    return ListView_GetItem (m_hwnd, & lvItem) ? lvItem.lParam : NULL ;
}

DWORD_PTR
CListview::GetData (
    )
{
    int iRow ;

    iRow = ListView_GetNextItem (m_hwnd, -1, LVNI_SELECTED) ;

    if (iRow == -1) {
        return NULL ;
    }

    return GetData (iRow) ;
}

DWORD
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    IN  int     cMax,
    OUT WCHAR * psz
    )
{
    int     len ;
    TCHAR * szUI ;

    len = cMax ;
    szUI = GetUICompatibleBuffer_ (psz, & len) ;
    ASSERT (szUI) ;

    //  leave room for the null-terminator
    ListView_GetItemText (m_hwnd, iRow, iCol, szUI, len - 1) ;

    ASSERT (len <= cMax) ;

    ConvertToUnicodeString_ (szUI, psz, len) ;

    return wcslen (psz) ;
}

int
CListview::GetRowTextW (
    IN  int     iRow,
    IN  int     iCol,       //  0-based
    OUT int *   val
    )
{
    WCHAR   achbuffer [32] ;

    ASSERT (val) ;
    * val = 0 ;

    if (GetRowTextW (iRow, iCol, 32, achbuffer)) {
        * val = _wtoi (achbuffer) ;
    }

    return (* val) ;
}

int
CListview::InsertColumnW (
    WCHAR * szColumnName,
    int ColumnWidth,
    int iCol
    )
{
    LVCOLUMN    lvColumn = {0} ;
    int         r ;

    ASSERT (szColumnName) ;

    lvColumn.mask       = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvColumn.fmt        = LVCFMT_LEFT;
    lvColumn.cx         = ColumnWidth ;
    lvColumn.pszText    = ConvertToUIString_ (szColumnName) ;

    r = ListView_InsertColumn (m_hwnd, iCol, & lvColumn) ;

    if (r != -1) {
        m_cColumns++ ;
    }

    return r ;
}

HIMAGELIST
CListview::SetImageList_ (
    HIMAGELIST  imgList,
    int         List
    )
{
    return ListView_SetImageList (m_hwnd, imgList, List) ;
}

HIMAGELIST
CListview::SetImageList_SmallIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_SMALL) ;
}

HIMAGELIST
CListview::SetImageList_NormalIcons (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_NORMAL) ;
}

HIMAGELIST
CListview::SetImageList_State (
    IN  HIMAGELIST  imgList
    )
{
    return SetImageList_ (imgList, LVSIL_STATE) ;
}

BOOL
CListview::SetState (
    int Index,
    int Row
    )
{
    //  setting or clearing ?
    if (Index > 0) {
        ListView_SetItemState (
                m_hwnd,
                Row,
                INDEXTOSTATEIMAGEMASK(Index),
                LVIS_STATEIMAGEMASK
                ) ;
    }
    else {
        ListView_SetItemState (m_hwnd, Row, 0, LVIS_STATEIMAGEMASK) ;
        ListView_RedrawItems (m_hwnd, Row, Row) ;
    }

    return TRUE ;
}

int
CListview::GetItemCount (
    )
{
    return (int) SendMessage (m_hwnd, LVM_GETITEMCOUNT, 0, 0) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstunerequestpage.cpp ===
// DVBSTuneRequestPage.cpp : Implementation of CDVBSTuneRequestPage
#include "stdafx.h"
#include "NPPropPage.h"
#include "DVBSTuneRequestPage.h"
#include <comdef.h>
#include "misccell.h"


/////////////////////////////////////////////////////////////////////////////
// CDVBSTuneRequestPage

HRESULT
CDVBSTuneRequestPage::FillControlsFromTuneRequest (
    IDVBTuneRequest* pDVBSTuneRequest
    )
{
    HRESULT hr = S_OK;
    LONG lValue;
    hr = pDVBSTuneRequest->get_ONID (&lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_FAILED_GET_ONID);
        return E_FAIL;
    }
    SetDlgItemInt (IDC_EDIT_ONID, lValue);
    
    hr = pDVBSTuneRequest->get_SID (&lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_FAILED_GET_SID);
        return E_FAIL;
    }
    SetDlgItemInt (IDC_EDIT_SID, lValue);
    
    hr = pDVBSTuneRequest->get_TSID (&lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_FAILED_GET_TSID);
        return E_FAIL;
    }
    SetDlgItemInt (IDC_EDIT_TSID, lValue);
    
    return hr;
}


HRESULT
CDVBSTuneRequestPage::FillControlFromLocator (
      IDVBSLocator* pLocator
      )
{
    //fill the combos
    FECMethod method;
    HRESULT hr = pLocator->get_InnerFEC (&method);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_INNER_FEC, m_misc.ConvertFECMethodToString (method));
    hr = pLocator->get_InnerFEC (&method);
    BinaryConvolutionCodeRate binaryConv;
    hr = pLocator->get_InnerFECRate (&binaryConv);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
    ModulationType modulation;
    hr = pLocator->get_Modulation (&modulation);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_MODULATION, m_misc.ConvertModulationToString(modulation));
    hr = pLocator->get_OuterFEC (&method);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_OUTER_FEC, m_misc.ConvertFECMethodToString (method));
    hr = pLocator->get_OuterFECRate (&binaryConv);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_OUTER_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
    Polarisation polarisation;
    hr = pLocator->get_SignalPolarisation (&polarisation);
    if (SUCCEEDED (hr))
        SelectComboBoxFromString (IDC_COMBO_OUTER_SIGNAL_POLARISATION, m_misc.ConvertPolarisationToString(polarisation));
    //fill the edit boxes
    
    LONG lGeneric;
    hr = pLocator->get_CarrierFrequency (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, lGeneric);
    hr = pLocator->get_SymbolRate (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_SYMBOL_RATE, lGeneric);
    hr = pLocator->get_Azimuth (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_AZIMUTH, lGeneric);
    hr = pLocator->get_Elevation (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_ELEVATION, lGeneric);
    hr = pLocator->get_OrbitalPosition (&lGeneric);
    if (SUCCEEDED (hr))
        SetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, lGeneric);
    //and finally the west position
    _variant_t var;
    var.vt = VT_BOOL;
    hr = pLocator->get_WestPosition (&var.boolVal);
    if (var.vt == VT_BOOL)
    {
        //weird - seems that -1 == TRUE
        CheckDlgButton (IDC_CHECK_WEST_POSITION, (var.boolVal == -1)?BST_CHECKED:BST_UNCHECKED);
    }
    return hr;
}

int 
CDVBSTuneRequestPage::AddItemToListBox (
    CComBSTR	strItem, 
    IDVBSTuningSpace* const dwData
    )
{
    USES_CONVERSION;
    HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
    int nIndex = ::SendMessage(
        hwndListBox, 
        LB_ADDSTRING, 
        0, 
        reinterpret_cast <LPARAM> (W2T(strItem))
        );
    ::SendMessage(
        hwndListBox, 
        LB_SETITEMDATA, 
        nIndex, 
        reinterpret_cast <LPARAM> (dwData)
        );
    //if we succeesfully inserted in the list
    if (nIndex != LB_ERR)
    {
        m_tunigSpaceList.push_back (dwData);
    }
    else
    {
        //seems that smtg went wrong
        ASSERT (FALSE);
        dwData->Release ();
    }
    return nIndex;
}

void
CDVBSTuneRequestPage::SelectComboBoxFromString (
    UINT nID, 
    CComBSTR strToFind
    )
{
    USES_CONVERSION;
    HWND hwndControl = GetDlgItem (nID);
    int nIndex = ::SendMessage (
        hwndControl,
        CB_FINDSTRING,
        -1,
        reinterpret_cast <LPARAM> (W2T(strToFind))
        );
    
    ::SendMessage (
        hwndControl,
        CB_SETCURSEL,
        nIndex,
        0
        );
}

CComBSTR 
CDVBSTuneRequestPage::GetComboText (
    UINT nID
    )
{
    HWND hwndControl = GetDlgItem (nID);
    int nIndex = ::SendMessage (
        hwndControl,
        CB_GETCURSEL,
        0,
        0
        );
    
    TCHAR	szText[MAX_PATH];
    ::SendMessage (
        hwndControl,
        CB_GETLBTEXT,
        nIndex,
        reinterpret_cast <LPARAM> (szText)
        );
    return CComBSTR (szText);
}

HRESULT
CDVBSTuneRequestPage::FillLocatorFromControls (
    IDVBSLocator* pLocator
    )
{
    USES_CONVERSION;
    //fill the combos
    CComBSTR genericString;
    genericString = GetComboText (IDC_COMBO_INNER_FEC);
    HRESULT hr = pLocator->put_InnerFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_INNERFEC);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_FEC_RATE);
    hr = pLocator->put_InnerFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_INNERFECRATE);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_MODULATION);
    hr = pLocator->put_Modulation (m_misc.ConvertStringToModulation (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_MODULATION);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_OUTER_FEC);
    hr = pLocator->put_OuterFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFEC);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_OUTER_FEC_RATE);
    hr = pLocator->put_OuterFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFECRATE);
        return E_FAIL;
    }
    genericString = GetComboText (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
    hr = pLocator->put_SignalPolarisation (m_misc.ConvertStringToPolarisation (W2A(genericString.m_str)));
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_SIGNALPOLARISATION);
        return E_FAIL;
    }
    
    //edit boxes
    //cannot use C++ casts here
    LONG lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY)));
    hr = pLocator->put_CarrierFrequency (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_CARRIERFREQUENCY);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_SYMBOL_RATE)));
    hr = pLocator->put_SymbolRate (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_SYMBOLRATE);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_AZIMUTH)));
    hr = pLocator->put_Azimuth (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_AZIMUTH);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ELEVATION)));
    hr = pLocator->put_Elevation (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_ELEVATION);
        return E_FAIL;
    }
    lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ORBITAL_POSITION)));
    hr = pLocator->put_OrbitalPosition (lValue);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_ORBITALPOSITION);
        return E_FAIL;
    }
    
    int nCheckState = IsDlgButtonChecked (IDC_CHECK_WEST_POSITION);
    _variant_t var;
    var.vt = VT_BOOL;
    var.boolVal = (nCheckState == BST_CHECKED)?TRUE:FALSE;
    hr = pLocator->put_WestPosition (var.boolVal);
    if (FAILED (hr))
    {
        MESSAGEBOX (this, IDS_CANNOT_SET_WESTPOSITION );
        return E_FAIL;
    }
    return hr;
}

HRESULT
CDVBSTuneRequestPage::FillTuneRequestFromControls (
   IDVBTuneRequest* pTuneRequest
   )
{
   HRESULT hr = S_OK;
   LONG lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ONID)));
   hr = pTuneRequest->put_ONID (lValue);
   if (FAILED (hr))
   {
       MESSAGEBOX (this, IDS_CANNOT_SET_ONID);
       return E_FAIL;
   }
   lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_TSID)));
   hr = pTuneRequest->put_TSID (lValue);
   if (FAILED (hr))
   {
       MESSAGEBOX (this, IDS_CANNOT_SET_TSID);
       return E_FAIL;
   }
   lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_SID)));
   hr = pTuneRequest->put_SID (lValue);
   if (FAILED (hr))
   {
       MESSAGEBOX (this, IDS_CANNOT_SET_SID);
       return E_FAIL;
   }
   return hr;
}

void
CDVBSTuneRequestPage::ReleaseTuningSpaces ()
{
   TUNING_SPACES::iterator it;
   for (it = m_tunigSpaceList.begin (); it != m_tunigSpaceList.end ();)
   {
       (*it)->Release ();
       m_tunigSpaceList.erase (it);
       it = m_tunigSpaceList.begin ();
   }
}

void 
CDVBSTuneRequestPage::EnableControls (
   BOOL bValue
   )
{
    ::EnableWindow (GetDlgItem (IDC_EDIT_ONID), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_ONID), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_TSID), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_TSID), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_SID), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_SID), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_CARRIER_FREQUENCY), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_CARRIER), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_SYMBOL_RATE), bValue); 
    ::EnableWindow (GetDlgItem (IDC_SPIN_SYMBOL_RATE), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_AZIMUTH), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_AZIMUTH), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_ELEVATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_ELEVATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_EDIT_ORBITAL_POSITION), bValue);
    ::EnableWindow (GetDlgItem (IDC_SPIN_ORBITAL_POSITION), bValue);
    ::EnableWindow (GetDlgItem (IDC_CHECK_WEST_POSITION), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_INNER_FEC), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_FEC_RATE), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_MODULATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_OUTER_FEC), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_OUTER_FEC_RATE), bValue);
    ::EnableWindow (GetDlgItem (IDC_COMBO_OUTER_SIGNAL_POLARISATION), bValue);
    ::EnableWindow (GetDlgItem (IDC_BUTTON_SUBMIT_TUNE_REQUEST), bValue);
    ::EnableWindow (GetDlgItem (IDC_BUTTON_REST_TO_DEFAULT_LOCATOR), bValue);
    ::EnableWindow (GetDlgItem (IDC_LIST_TUNING_SPACES), bValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\mp2demux\uictrl.h ===
/*++

    Copyright (c) 1999 Microsoft Corporation

    Module Name:

        uictrl.h

    Abstract:

        This module contains the class declarations for thin win32
        control wrappers which are used on the property pages

        MP2DEMUX is all unicode internally.  The COM interface string
        parameters are all unicode, so the only place where we may not
        be handling unicode strings is in the UI i.e. the property
        pages.  Consequently, we isolate the ansi <-> unicode functionality
        in these classes only.

        All calls into these classes are with UNICODE parameters.

        These classes are not thread-safe !!

    Author:

        Matthijs Gates  (mgates)

    Revision History:

        06-Jul-1999     created 

--*/

#ifndef _mp2demux__uictrl_h
#define _mp2demux__uictrl_h

class CControlBase ;
class CEditControl ;
class CCombobox ;
class CListview ;

class AM_NOVTABLE CControlBase
{
    protected :

        HWND    m_hwnd ;
        DWORD   m_id ;

        //  include this only if we're ansi
#ifndef UNICODE     //  -------------------------------------------------------

        enum {
            MAX_STRING = 128        //  128 = max PIN_INFO.achName length
        } ;

        char    m_achBuffer [MAX_STRING] ;
        char *  m_pchScratch ;
        int     m_pchScratchMaxString ;

        char *
        GetScratch_ (
            IN OUT  int * pLen
            )
        /*++
            Fetches a scratch buffer.

            pLen
                IN      char count requested
                OUT     char count obtained
        --*/
        {
            //  the easy case
            if (* pLen <= m_pchScratchMaxString) {
                return m_pchScratch ;
            }
            //  a longer string than is currently available is requested
            else {
                ASSERT (* pLen > MAX_STRING) ;

                //  first free up m_pchScratch if it points to a 
                //  heap-allocated memory
                if (m_pchScratch != & m_achBuffer [0]) {
                    ASSERT (m_pchScratch != NULL) ;
                    delete [] m_pchScratch ;
                }

                //  allocate
                m_pchScratch = new char [* pLen] ;

                //  if the above call failed, we failover to the stack-
                //  allocated buffer
                if (m_pchScratch == NULL) {
                    m_pchScratch = & m_achBuffer [0] ;
                    * pLen = MAX_STRING ;
                }

                ASSERT (m_pchScratch != NULL) ;
                ASSERT (* pLen >= MAX_STRING) ;

                return m_pchScratch ;
            }
        }

#endif  //  UNICODE  ----------------------------------------------------------

        //  called when converting to UI char set
        TCHAR *
        ConvertToUIString_ (
            IN  WCHAR * sz
            ) ;

        //  called to obtain a UI-compatible buffer of the specified length
        TCHAR *
        GetUICompatibleBuffer_ (
            IN  WCHAR *     sz,
            IN OUT int *    pLen
            ) ;

        //  called with a UI-filled buffer; ensures that szUnicode has what sz
        //  points to; obtain sz via GetUICompatibleBuffer_ 
        WCHAR *
        ConvertToUnicodeString_ (
            IN  TCHAR * sz,             //  buffer to convert; null-terminated
            IN  WCHAR * szUnicode,      //  requested buffer
            IN  int     MaxLen          //  max length of szUnicode buffer
            ) ;

    public :

        CControlBase (
            HWND    hwnd, 
            DWORD   id
            ) ;

#ifndef UNICODE
        CControlBase::~CControlBase (
            )
        {
            //  if m_pchScratch points to heap-allocated memory, free it now
            if (m_pchScratch != & m_achBuffer [0]) {
                ASSERT (m_pchScratch != NULL) ;
                delete [] m_pchScratch ;
            }
        }
#endif  //  UNICODE

        HWND 
        GetHwnd (
            ) ;

        DWORD 
        GetId (
            ) ;

        virtual 
        LRESULT 
        ResetContent (
            ) = 0 ;
} ;

class CEditControl : 
    public CControlBase
{
    public :

        CEditControl (
            HWND    hwnd, 
            DWORD   id
            ) ;

        void
        SetTextW (
            WCHAR *
            ) ;

        void
        SetTextW (
            INT val
            ) ;

        int
        GetTextW (
            WCHAR *, 
            int MaxChars
            ) ;

        int
        GetTextW (
            INT *   val
            ) ;

        LRESULT
        ResetContent (
            ) ;
} ;

class CCombobox : 
    public CControlBase
{
    public :

        CCombobox (
            HWND    hwnd, 
            DWORD   id) ;

        int
        AppendW (
            WCHAR *
            ) ;

        int
        AppendW (
            INT val
            ) ;

        int
        InsertW (
            WCHAR *, 
            int index = 0
            ) ;

        int
        InsertW (
            INT val, 
            int index = 0
            ) ;

        BOOL
        DeleteRow (
            int 
            ) ;

        int
        GetItemCount (
            ) ;

        int
        GetTextW (
            WCHAR *, 
            int MaxChars
            ) ;

        int
        GetTextW (
            int *
            ) ;

        LRESULT
        ResetContent (
            ) ;

        int
        Focus (
            int index = 0
            ) ;

        int
        SetItemData (
            DWORD_PTR val, 
            int index
            ) ;

        DWORD_PTR
        GetCurrentItemData (
            DWORD_PTR *
            ) ;

        DWORD_PTR
        GetItemData (
            DWORD_PTR *, 
            int index
            ) ;

        int
        GetCurrentItemIndex (
            ) ;
} ;

class CListview : 
    public CControlBase
{
    int m_cColumns ;

    HIMAGELIST
    SetImageList_ (
        HIMAGELIST,
        int
        ) ;

    public :

        CListview (
            HWND hwnd, 
            DWORD id
            ) ;

        LRESULT
        ResetContent (
            ) ;

        HIMAGELIST
        SetImageList_SmallIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_NormalIcons (
            HIMAGELIST
            ) ;

        HIMAGELIST
        SetImageList_State (
            HIMAGELIST
            ) ;

        int
        GetItemCount (
            ) ;

        BOOL
        SetState (
            int Index,      //  1-based; if 0, clears
            int Row
            ) ;

        int 
        InsertColumnW (
            WCHAR *, 
            int ColumnWidth, 
            int iCol = 0
            ) ;

        int
        InsertRowIcon (
            int
            ) ;

        int
        InsertRowTextW (
            WCHAR *, 
            int iCol = 1
            ) ;

        //  inserts a row, but converts the number to a string first
        int
        InsertRowNumber (
            int i,
            int iCol = 1
            ) ;

        int
        InsertRowValue (
            DWORD_PTR
            ) ;

        BOOL
        DeleteRow (
            int 
            ) ;

        BOOL
        SetData (
            DWORD_PTR   dwData, 
            int         iRow
            ) ;

        BOOL
        SetTextW (
            WCHAR *,
            int iRow, 
            int iCol
            ) ;

        int
        GetSelectedCount (
            ) ;

        int
        GetSelectedRow (
            int iStartRow = -1
            ) ;

        DWORD_PTR
        GetData (
            int iRow
            ) ;

        DWORD_PTR
        GetData (
            ) ;

        DWORD
        GetRowTextW (
            IN  int iRow,
            IN  int iCol,       //  0-based
            IN  int cMax,
            OUT WCHAR *
            ) ;

        int
        GetRowTextW (
            IN  int     iRow,
            IN  int     iCol,
            OUT int *   val
            ) ;
} ;


#endif  // _mp2demux__uictrl_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstunerequestpage.h ===
// DVBSTuneRequestPage.h : Declaration of the CDVBSTuneRequestPage

#ifndef __DVBSTUNEREQUESTPAGE_H_
#define __DVBSTUNEREQUESTPAGE_H_

#include "resource.h"       // main symbols
#include "misccell.h"
#include <list>

EXTERN_C const CLSID CLSID_DVBSTuneRequestPage;

/////////////////////////////////////////////////////////////////////////////
// CDVBSTuneRequestPage
class ATL_NO_VTABLE CDVBSTuneRequestPage :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSTuneRequestPage, &CLSID_DVBSTuneRequestPage>,
	public IPropertyPageImpl<CDVBSTuneRequestPage>,
	public CDialogImpl<CDVBSTuneRequestPage>,
    public IBroadcastEvent
{
public:
	CDVBSTuneRequestPage() 
	{
		m_dwTitleID = IDS_TITLEDVBSTuneRequestPage;
		m_dwHelpFileID = IDS_HELPFILEDVBSTuneRequestPage;
		m_dwDocStringID = IDS_DOCSTRINGDVBSTuneRequestPage;
	}

	~CDVBSTuneRequestPage ()
	{
		ReleaseTuningSpaces ();
	}

	enum {IDD = IDD_DVBSTUNEREQUESTPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_DVBSTUNEREQUESTPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSTuneRequestPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
END_COM_MAP()

BEGIN_MSG_MAP(CDVBSTuneRequestPage)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDVBSTuneRequestPage>)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_HANDLER(IDC_BUTTON_REST_TO_DEFAULT_LOCATOR, BN_CLICKED, OnClickedButton_rest_to_default_locator)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_TUNE_REQUEST, BN_CLICKED, OnClickedButton_submit_tune_request)
	COMMAND_HANDLER(IDC_LIST_TUNING_SPACES, LBN_SELCHANGE, OnSelchangeList_tuning_spaces)
END_MSG_MAP()

    typedef IPropertyPageImpl<CDVBSTuneRequestPage> PPGBaseClass;

	void
	ReleaseTuningSpaces ();

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
    STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
    {
        // If we don't have any objects, this method should not be called
        // Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
        if (!m_ppUnk)
            return E_UNEXPECTED;
        
        // Use Activate to update the property page's UI with information
        // obtained from the objects in the m_ppUnk array
        
        // We update the page to display the Name and ReadOnly properties of the document
        
        // Call the base class
        HRESULT hr = PPGBaseClass::Activate(hWndParent, prc, bModal);
        
        if (!m_ppUnk[0])
            return E_UNEXPECTED;

        //if already advised, unadvise
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            if (pConPoint)
                pConPoint->Unadvise (m_dwEventCookie);
            m_pBroadcastEventService.Release ();
        }

        IBroadcastEvent* pEvent = NULL;
        //register for events
        hr = CBDAMiscellaneous::RegisterForEvents (
            m_ppUnk[0], 
            static_cast<IBroadcastEvent*>(this),
            &pEvent, 
            m_dwEventCookie
            );
        if (SUCCEEDED (hr))
            m_pBroadcastEventService.Attach (pEvent);

		m_pTuner = m_ppUnk[0];
        if (!m_pTuner)
            return E_FAIL;
        
        ReleaseTuningSpaces ();
        HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
        ::SendMessage (hwndListBox, LB_RESETCONTENT, NULL, NULL);
        
        //get the tunning spaces
        CComPtr <IEnumTuningSpaces> pTuneSpaces;
        hr = m_pTuner->EnumTuningSpaces (&pTuneSpaces);
        bool bFound = false;
        if (SUCCEEDED (hr) && (pTuneSpaces))
        {
            ITuningSpace* pTuneSpace = NULL;
            IDVBSTuningSpace* pDVBSTuningSpace;
            while (pTuneSpaces->Next (1, &pTuneSpace, 0) == S_OK)
            {
                hr = pTuneSpace->QueryInterface(__uuidof (IDVBSTuningSpace), reinterpret_cast <void**> (&pDVBSTuningSpace));
                if (FAILED (hr) || (!pDVBSTuningSpace))
                {
                    ASSERT (FALSE);
                    continue;
                }
                CComBSTR uniqueName;
                hr = pDVBSTuningSpace->get_UniqueName (&uniqueName.m_str);
                if (FAILED (hr))
                    continue;
                //don't bother to release the DVBSTuningSpace pointers
                //they will be added to a list that will be released later
                AddItemToListBox (uniqueName, pDVBSTuningSpace);//we will identify the items from the name
                bFound = true;
            }
        }
        if (!bFound)
        {
            //no available tuning space so just disable all controls
            EnableControls (FALSE);
            return S_OK;
        }
        
        if (!m_pTuneRequest)
        {
            //Now, let's see if there is any current tunerequest we can get
            CComPtr <ITuneRequest> pTuneRequest;
            hr = m_pTuner->get_TuneRequest (&pTuneRequest);
            m_pTuneRequest = pTuneRequest;
        }
        
        CComPtr <ILocator>	pLocator;
        if (m_pTuneRequest)
        {
            hr = m_pTuneRequest->get_Locator (&pLocator);
            if (FAILED (hr) || (!pLocator))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComQIPtr <IDVBSLocator>	pDVBSLocator (pLocator);
            if (!pDVBSLocator)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            FillControlFromLocator (pDVBSLocator);
            
            //try to find the coresponding tuning space from the list
            CComPtr <ITuningSpace> pReferenceTuneSpace;
            hr = m_pTuneRequest->get_TuningSpace (&pReferenceTuneSpace);
            if (FAILED (hr) || (!pReferenceTuneSpace))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComQIPtr <IDVBSTuningSpace> pDVBSReferenceTuningSpace (pReferenceTuneSpace);
            if (!pDVBSReferenceTuningSpace)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComBSTR refUniqueName;
            hr = pDVBSReferenceTuningSpace->get_UniqueName (&refUniqueName.m_str);
            if (FAILED (hr))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            TUNING_SPACES::iterator it = m_tunigSpaceList.begin ();
            CComBSTR uniqueName;
            int nCount = 0;
            while (it != m_tunigSpaceList.end ())
            {
                //BUGBUG - should check for all properties not only for UniqueName
                hr = (*it)->get_UniqueName (&uniqueName.m_str);
                if (FAILED (hr))
                {
                    ASSERT (FALSE);
                    EnableControls (FALSE);
                    return S_OK;
                }
                if (uniqueName == refUniqueName)
                {
                    //we found it, so select the proper tuning space from the list
                    HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
                    ::SendMessage (hwndListBox, LB_SETCURSEL, nCount, NULL);
                    break;
                }
                ++it;
                ++nCount;
            }
            FillControlsFromTuneRequest (m_pTuneRequest);
        }
        else
        {
            //no tune request so get the first tuning space from the list
            HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
            ::SendMessage (hwndListBox, LB_SETCURSEL, 0, NULL);
            LRESULT dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, 0, NULL);
            if (dwData == LB_ERR)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            IDVBSTuningSpace* pSelTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
            if (!pSelTuningSpace)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            hr = pSelTuningSpace->get_DefaultLocator (&pLocator);
            if (FAILED (hr) || (!pLocator))
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            CComQIPtr <IDVBSLocator>	pDVBSLocator (pLocator);
            if (!pDVBSLocator)
            {
                ASSERT (FALSE);
                EnableControls (FALSE);
                return S_OK;
            }
            FillControlFromLocator (pDVBSLocator);
            SetDlgItemInt (IDC_EDIT_ONID, -1);
            SetDlgItemInt (IDC_EDIT_TSID, -1);
            SetDlgItemInt (IDC_EDIT_SID, -1);
        }
        
        //if everything went fine
        EnableControls (true);
        return S_OK;
}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CDVBS_TuneRequest::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}

private:
	CComQIPtr <IScanningTuner>			m_pTuner;
	CComQIPtr <IMediaEventEx>			m_pEventInterface;
	CBDAMiscellaneous					m_misc;
	CComQIPtr <IDVBTuneRequest>			m_pTuneRequest;
    CComPtr     <IBroadcastEvent>       m_pBroadcastEventService;
    DWORD                               m_dwEventCookie;
	bool								m_fFirstTime;
	typedef	std::list <IDVBSTuningSpace*> TUNING_SPACES;
	TUNING_SPACES						m_tunigSpaceList;//mantaing a list of available tuning spaces 
														//so we can access them easier


	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		USES_CONVERSION;
		//set the spins
		HWND hwndSpin = GetDlgItem (IDC_SPIN_SID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ONID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_CARRIER);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_SYMBOL_RATE);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_TSID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_AZIMUTH);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ELEVATION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ORBITAL_POSITION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);

		//fill the combos
		HWND hwndCombo = GetDlgItem (IDC_COMBO_INNER_FEC);
		int nIndex = 0;
		MAP_FECMethod::iterator it;
		for (it = m_misc.m_FECMethodMap.begin ();it != m_misc.m_FECMethodMap.end ();it++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it2;
		for (it2 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it2 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it2++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it2).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it2).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_MODULATION);
		nIndex = 0;
		MAP_ModulationType::iterator it3;
		for (it3 = m_misc.m_ModulationTypeMap.begin ();it3 != m_misc.m_ModulationTypeMap.end ();it3++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it3).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it3).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC);
		nIndex = 0;
		MAP_FECMethod::iterator it4;
		for (it4 = m_misc.m_FECMethodMap.begin ();it4 != m_misc.m_FECMethodMap.end ();it4++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it4).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it4).second
				);
			++nIndex;
		}		
		
		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it5;
		for (it5 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it5 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it5++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it5).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it5).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
		nIndex = 0;
		MAP_Polarisation::iterator it6;
		for (it6 = m_misc.m_PolarisationMap.begin ();it6 != m_misc.m_PolarisationMap.end ();it6++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it6).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it6).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_SPECTRAL_INVERSION);
		nIndex = 0;
		MAP_SpectralInversion::iterator it7;
		for (it7 = m_misc.m_SpectralInversionMap.begin ();it7 != m_misc.m_SpectralInversionMap.end ();it7++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it7).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it7).second
				);
			++nIndex;
		}
		
		//SetModifiedFlag (false);
		return 0;
	}

	void
	SetModifiedFlag (bool fValue)
	{
		//this will also set the m_bDirty flag
		SetDirty (fValue);
		HWND hwndSubmit = GetDlgItem (IDC_BUTTON_SUBMIT_TUNE_REQUEST);
		::EnableWindow (hwndSubmit, fValue);
	}

	HRESULT
	FillControlFromLocator (
		IDVBSLocator* pLocator
		);

	HRESULT
	FillControlsFromTuneRequest (
		IDVBTuneRequest* pDVBSTuneRequest
		);

	HRESULT
	FillLocatorFromControls (
		IDVBSLocator* pLocator
		);

	HRESULT
	FillTuneRequestFromControls (IDVBTuneRequest* pTuneRequest);

	int 
	AddItemToListBox (
		CComBSTR	strItem, 
		IDVBSTuningSpace* const dwData
		);

	void
	SelectComboBoxFromString (
		UINT nID, 
		CComBSTR strToFind
		);

	CComBSTR 
	GetComboText (
		UINT nID
		);

	void 
	EnableControls (
		BOOL bValue
		);

	HRESULT
	GetSelectedTuningSpace (IDVBSTuningSpace** pTuneSpace)
	{
		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		int nSelIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
		if (nSelIndex == LB_ERR)
		{
			ASSERT (FALSE);
			return E_FAIL;
		}
		LRESULT dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, nSelIndex, NULL);
		if (dwData == LB_ERR)
		{
			ASSERT (FALSE);
			return E_FAIL;
		}

		IDVBSTuningSpace* pSelTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
		if (!pSelTuningSpace)
		{
			ASSERT (FALSE);
			return E_FAIL;
		}
		*pTuneSpace = pSelTuningSpace;
		(*pTuneSpace)->AddRef ();
		return S_OK;
	}

	HRESULT
	GetDVBSLocatorFromTuningSpace (IDVBSTuningSpace* pTuneSpace, IDVBSLocator** pDVBSLoc)
	{
		CComPtr <ILocator>	pLocator;
		HRESULT hr = pTuneSpace->get_DefaultLocator (&pLocator);
		if (FAILED (hr) || (!pLocator))
		{
			MESSAGEBOX (this, IDS_CANNOT_GET_DEFLOC);
			return E_FAIL;
		}
		CComQIPtr <IDVBSLocator> pDVBSLocator (pLocator);
		if (!pDVBSLocator)
		{
			MESSAGEBOX (this, IDS_CANNOT_GET_DEF_DVBSLOCATOR);
			return E_FAIL;
		}
		*pDVBSLoc = pDVBSLocator;
		(*pDVBSLoc)->AddRef ();
		return S_OK;
	}

	LRESULT OnClickedButton_rest_to_default_locator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CComPtr <IDVBSTuningSpace> pTuneSpace;
		HRESULT  hr =  GetSelectedTuningSpace (&pTuneSpace);
		if (FAILED (hr) || (!pTuneSpace))
		{
			ASSERT (FALSE);
			return 0;
		}

		CComPtr <IDVBSLocator> pDVBSLocator;
		GetDVBSLocatorFromTuningSpace (pTuneSpace, &pDVBSLocator);
		//no error
		FillControlFromLocator (pDVBSLocator);
		return 0;
	}

	LRESULT OnClickedButton_submit_tune_request(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CComPtr <IDVBSTuningSpace> pTuneSpace;
		HRESULT hr = GetSelectedTuningSpace (&pTuneSpace);
		if (FAILED (hr) || (!pTuneSpace))
		{
			ASSERT (FALSE);
			return 0;
		}

		CComPtr <IDVBSLocator> pSelDVBSLocator;
		hr = GetDVBSLocatorFromTuningSpace (pTuneSpace, &pSelDVBSLocator);
		if (FAILED (hr) || (!pSelDVBSLocator))
		{
			ASSERT (FALSE);
			return 0;
		}

		hr = FillLocatorFromControls (pSelDVBSLocator);
		if (FAILED (hr))
		{
			ASSERT (FALSE);
			return 0;
		}

		ASSERT (m_pTuner);
		CComPtr <ITuneRequest> pTuneRequest;
		hr = pTuneSpace->CreateTuneRequest (&pTuneRequest);
		if (FAILED (hr) || (!pTuneRequest))
		{
			MESSAGEBOX (this, IDS_CANNOT_CREATE_NEW_TUNEREQUEST);
			return 0;
		}
		CComQIPtr <IDVBTuneRequest> pDVBSTuneRequest (pTuneRequest);
		if (!pDVBSTuneRequest)
		{
			MESSAGEBOX (this, IDS_CANNOT_RETRIEVE_DVBSTUNEREQUEST);
			return 0;
		}
		hr = pDVBSTuneRequest->put_Locator (pSelDVBSLocator);
		if (FAILED (hr))
		{
			MESSAGEBOX (this, IDS_CANNOT_SET_LOCATOR_FOR_TUNEREQUEST);
			return 0;
		}
		hr = FillTuneRequestFromControls (pDVBSTuneRequest);
		if (FAILED (hr))
		{
			//already pop-up a message error dialog box
			return 0;
		}
		hr = m_pTuner->put_TuneRequest (pDVBSTuneRequest);
		if (FAILED (hr))
		{
			MESSAGEBOX (this, IDS_CANNOT_PUT_TUNE_REQUEST);
			return 0;
		}

		return 0;
	}
	LRESULT OnSelchangeList_tuning_spaces(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		CComPtr <IDVBSTuningSpace> pTuneSpace;
		HRESULT  hr =  GetSelectedTuningSpace (&pTuneSpace);
		if (FAILED (hr) || (!pTuneSpace))
		{
			ASSERT (FALSE);
			return 0;
		}

		CComPtr <IDVBSLocator> pDVBSLocator;
		GetDVBSLocatorFromTuningSpace (pTuneSpace, &pDVBSLocator);
		//no error
		FillControlFromLocator (pDVBSLocator);		
		return 0;
	}

    STDMETHOD(Fire)(GUID EventID)
    {
#ifdef DEBUG
        TCHAR szInfo[MAX_PATH];
        CComBSTR bstrEventID;
        USES_CONVERSION;
        StringFromCLSID (EventID, &bstrEventID);
        wsprintf (szInfo, _T("Notification received for %s"), OLE2T (bstrEventID));
        ATLTRACE (szInfo);
#endif
        if (EventID == EVENTID_TuningChanged)
        {
            ATLTRACE ("Starting to refresh");
            Refresh ();        
        }
        return S_OK;
    }

    HRESULT Refresh ()
    {
        //get the tunning spaces
        //1. get the current tuning space
        CComPtr <ITuningSpace> pTuneSpace;
        CComPtr <ITuneRequest> pTuneRequest;
        
        HRESULT hr = m_pTuner->get_TuneRequest (&pTuneRequest);
        if ((FAILED (hr)) || (!pTuneRequest))
            return E_FAIL;
        
        if (m_pTuneRequest)
            m_pTuneRequest.Release ();
        m_pTuneRequest = pTuneRequest;
        if (!m_pTuneRequest)
            //could be just the first tune request, we will get notification again..
            return S_OK;
        FillControlsFromTuneRequest (m_pTuneRequest);
        return S_OK;
    }

    virtual void OnFinalMessage( HWND hWnd )
    {
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            pConPoint->Unadvise (m_dwEventCookie);
        }
    }
};

#endif //__DVBSTUNEREQUESTPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstuningspaces.cpp ===
// DVBSTuningSpaces.cpp : Implementation of CDVBSTuningSpaces
#include "stdafx.h"
#include "NPPropPage.h"
#include "DVBSTuningSpaces.h"
#include <comdef.h>

/////////////////////////////////////////////////////////////////////////////
// CDVBSTuningSpaces

HRESULT
CDVBSTuningSpaces::FillControlsFromTuningSpace (
	IDVBSTuningSpace* pTuningSpace
	)
{
	HRESULT hr = S_OK;
	USES_CONVERSION;
	CComBSTR	genericName;
	hr = pTuningSpace->get_UniqueName (&genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_UNIQUENAME);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_UNIQUE_NAME , W2T (genericName));
	CComBSTR	FriendlyName;
	hr = pTuningSpace->get_FriendlyName (&FriendlyName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_FRIENDLYNAME);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_FRIENDLY_NAME, W2T (FriendlyName));

	CComBSTR FrequencyMapping;
	hr = pTuningSpace->get_FrequencyMapping (&FrequencyMapping);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_FREQUENCYMAPPING);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_FREQUENCY_MAPPING, W2T (FrequencyMapping));
	LONG lGeneric;
	hr = pTuningSpace->get_NetworkID (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_NETWORKID);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_NETWORKID, lGeneric);
	hr = pTuningSpace->get_HighOscillator (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_HIGHOSCILATOR);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_HIGH_OSCILLATOR, lGeneric);
	hr = pTuningSpace->get_LNBSwitch (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_LNBSWITCH);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_LNBSwitch, lGeneric);
	CComBSTR inputRange;
	hr = pTuningSpace->get_InputRange (&inputRange);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_INPUTRANGE);
		return E_FAIL;
	}
	SetDlgItemText (IDC_EDIT_INPUT_RANGE, W2T(inputRange));
	hr = pTuningSpace->get_LowOscillator (&lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_LOWOSCILLATOR);
		return E_FAIL;
	}
	SetDlgItemInt (IDC_EDIT_LOW_OSCILATOR, lGeneric);	

	SpectralInversion	spectralInv;
	hr = pTuningSpace->get_SpectralInversion (&spectralInv);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_SPECTRALINVERSION);
		return E_FAIL;
	}
	SelectComboBoxFromString (IDC_COMBO_SPECTRAL_INVERSION, m_misc.ConvertSpectralInversionToString (spectralInv));

	CComQIPtr <ILocator>	pLocator;
	CComQIPtr <IDVBSLocator>	pDVBSLocator;
	hr = pTuningSpace->get_DefaultLocator (&pLocator);
	if (FAILED (hr) || !pLocator)
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_ILOCATOR);
		return E_FAIL;
	}
	pDVBSLocator = pLocator;
	if (!pDVBSLocator)
	{
		MESSAGEBOX (this, IDS_CANNOT_GET_DVBSLOCATOR);
		return E_FAIL;
	}
	FillControlFromLocator (pDVBSLocator);
	return hr;
}

HRESULT
CDVBSTuningSpaces::FillControlFromLocator (IDVBSLocator* pLocator)
{
	//fill the combos
	FECMethod method;
	HRESULT hr = pLocator->get_InnerFEC (&method);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_INNER_FEC, m_misc.ConvertFECMethodToString (method));
	hr = pLocator->get_InnerFEC (&method);
	BinaryConvolutionCodeRate binaryConv;
	hr = pLocator->get_InnerFECRate (&binaryConv);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
	ModulationType modulation;
	hr = pLocator->get_Modulation (&modulation);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_MODULATION, m_misc.ConvertModulationToString(modulation));
	hr = pLocator->get_OuterFEC (&method);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_OUTER_FEC, m_misc.ConvertFECMethodToString (method));
	hr = pLocator->get_OuterFECRate (&binaryConv);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_OUTER_FEC_RATE, m_misc.ConvertInnerFECRateToString (binaryConv));
	Polarisation polarisation;
	hr = pLocator->get_SignalPolarisation (&polarisation);
	if (SUCCEEDED (hr))
		SelectComboBoxFromString (IDC_COMBO_OUTER_SIGNAL_POLARISATION, m_misc.ConvertPolarisationToString(polarisation));
	//fill the edit boxes

	LONG lGeneric;
	hr = pLocator->get_CarrierFrequency (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, lGeneric);
	hr = pLocator->get_SymbolRate (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_SYMBOL_RATE, lGeneric);
	hr = pLocator->get_Azimuth (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_AZIMUTH, lGeneric);
	hr = pLocator->get_Elevation (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_ELEVATION, lGeneric);
	hr = pLocator->get_OrbitalPosition (&lGeneric);
	if (SUCCEEDED (hr))
		SetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, lGeneric);
	//and finally the west position
	_variant_t var;
	var.vt = VT_BOOL;
	hr = pLocator->get_WestPosition (&var.boolVal);
	if (var.vt == VT_BOOL)
	{
		//weird - seems that -1 == TRUE
		CheckDlgButton (IDC_CHECK_WEST_POSITION, (var.boolVal == -1)?BST_CHECKED:BST_UNCHECKED);
	}
	return hr;
}


int 
CDVBSTuningSpaces::AddItemToListBox (
	CComBSTR	strItem, 
	IDVBSTuningSpace* const dwData
	)
{
	USES_CONVERSION;
	HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
	int nIndex = ::SendMessage(
		hwndListBox, 
		LB_ADDSTRING, 
		0, 
		reinterpret_cast <LPARAM> (W2T(strItem))
		);
	::SendMessage(
		hwndListBox, 
		LB_SETITEMDATA, 
		nIndex, 
		reinterpret_cast <LPARAM> (dwData)
		);
	//if we succeesfully inserted in the list
	if (nIndex != LB_ERR)
	{
		m_tunigSpaceList.push_back (dwData);
	}
	else
	{
		//seems that smtg went wrong
		ASSERT (FALSE);
		dwData->Release ();
	}
	return nIndex;
}

void
CDVBSTuningSpaces::SelectComboBoxFromString (
	UINT nID, 
	CComBSTR strToFind
	)
{
	USES_CONVERSION;
	HWND hwndControl = GetDlgItem (nID);
	int nIndex = ::SendMessage (
		hwndControl,
		CB_FINDSTRING,
		-1,
		reinterpret_cast <LPARAM> (W2T(strToFind))
		);
		
	::SendMessage (
		hwndControl,
		CB_SETCURSEL,
		nIndex,
		0
		);
}

CComBSTR 
CDVBSTuningSpaces::GetComboText (
	UINT nID
	)
{
	HWND hwndControl = GetDlgItem (nID);
	int nIndex = ::SendMessage (
		hwndControl,
		CB_GETCURSEL,
		0,
		0
		);
		
	TCHAR	szText[MAX_PATH];
	::SendMessage (
		hwndControl,
		CB_GETLBTEXT,
		nIndex,
		reinterpret_cast <LPARAM> (szText)
		);
	return CComBSTR (szText);
}

HRESULT
CDVBSTuningSpaces::FillLocatorFromControls (
	IDVBSLocator* pLocator
	)
{
	USES_CONVERSION;
	//fill the combos
	CComBSTR genericString;
	genericString = GetComboText (IDC_COMBO_INNER_FEC);
	HRESULT hr = pLocator->put_InnerFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_INNERFEC);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_FEC_RATE);
	hr = pLocator->put_InnerFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_INNERFECRATE);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_MODULATION);
	hr = pLocator->put_Modulation (m_misc.ConvertStringToModulation (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_MODULATION);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_OUTER_FEC);
	hr = pLocator->put_OuterFEC (m_misc.ConvertStringToFECMethod (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFEC);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_OUTER_FEC_RATE);
	hr = pLocator->put_OuterFECRate (m_misc.ConvertStringToBinConvol (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_OUTERFECRATE);
		return E_FAIL;
	}
	genericString = GetComboText (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
	hr = pLocator->put_SignalPolarisation (m_misc.ConvertStringToPolarisation (W2A(genericString.m_str)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_SIGNALPOLARISATION);
		return E_FAIL;
	}

	//edit boxes
	//cannot use C++ casts here
    BOOL bTrans;
	LONG lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_CarrierFrequency (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_CARRIERFREQUENCY);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_SYMBOL_RATE, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_SymbolRate (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_SYMBOLRATE);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_AZIMUTH, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_Azimuth (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_AZIMUTH);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ELEVATION, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_Elevation (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_ELEVATION);
		return E_FAIL;
	}
	lValue = (LONG)((int)(GetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, &bTrans)));
    if (!bTrans)
        lValue = -1;
	hr = pLocator->put_OrbitalPosition (lValue);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_ORBITALPOSITION);
		return E_FAIL;
	}
		
	int nCheckState = IsDlgButtonChecked (IDC_CHECK_WEST_POSITION);
	_variant_t var;
	var.vt = VT_BOOL;
	var.boolVal = (nCheckState == BST_CHECKED)?-1:0;
	hr = pLocator->put_WestPosition (var.boolVal);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_WESTPOSITION);
		return E_FAIL;
	}
	return hr;
}

HRESULT
CDVBSTuningSpaces::FillTuningSpaceFromControls (
	IDVBSTuningSpace* pTuningSpace
	)
{
	HRESULT hr = S_OK;
	USES_CONVERSION;
	CComBSTR	genericName;
	GetDlgItemText (IDC_EDIT_UNIQUE_NAME , genericName.m_str);
	hr = pTuningSpace->put_UniqueName (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_UNIQUENAME);
		return E_FAIL;
	}
	
	GetDlgItemText (IDC_EDIT_FRIENDLY_NAME, genericName.m_str);
	hr = pTuningSpace->put_FriendlyName (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_FRIENDLYNAME);
		return E_FAIL;
	}

	GetDlgItemText (IDC_EDIT_FREQUENCY_MAPPING, genericName.m_str);
    if (genericName.Length () == 0)
        genericName = L"-1";
	hr = pTuningSpace->put_FrequencyMapping (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_FREQUENCYMAPPING);
		return E_FAIL;
	}

	LONG lGeneric;
    BOOL bTrans;
	lGeneric = GetDlgItemInt (IDC_EDIT_NETWORKID, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_NetworkID (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_NETWORKID);
		return E_FAIL;
	}
	lGeneric = GetDlgItemInt (IDC_EDIT_HIGH_OSCILLATOR, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_HighOscillator (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_HIGHOSCILATOR);
		return E_FAIL;
	}
	lGeneric = GetDlgItemInt (IDC_EDIT_LNBSwitch, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_LNBSwitch (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_LNBSWITCH);
		return E_FAIL;
	}
	GetDlgItemText (IDC_EDIT_INPUT_RANGE, genericName.m_str);
    if (genericName.Length () == 0)
        genericName = L"-1";
	hr = pTuningSpace->put_InputRange (genericName);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_INPUTRANGE);
		return E_FAIL;
	}
	lGeneric = GetDlgItemInt (IDC_EDIT_LOW_OSCILATOR, &bTrans);
    if (!bTrans)
        lGeneric = -1;
	hr = pTuningSpace->put_LowOscillator (lGeneric);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_LOWOSCILLATOR);
		return E_FAIL;
	}

	genericName = GetComboText (IDC_COMBO_SPECTRAL_INVERSION);
	hr = pTuningSpace->put_SpectralInversion (m_misc.ConvertStringToSpectralInversion (W2A(genericName)));
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_SPECTRALINVERSION);
		return E_FAIL;
	}

	hr = pTuningSpace->put_NetworkType (m_bstrNetworkType);
	if (FAILED (hr))
	{
		MESSAGEBOX (this, IDS_CANNOT_SET_NETWORKTYPE);
		return E_FAIL;
	}
	return hr;
}

void
CDVBSTuningSpaces::FillDefaultControls ()
{
    //locator first
	SelectComboBoxFromString (IDC_COMBO_INNER_FEC, m_misc.ConvertFECMethodToString (BDA_FEC_METHOD_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_FEC_RATE, m_misc.ConvertInnerFECRateToString (BDA_BCC_RATE_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_MODULATION, m_misc.ConvertModulationToString(BDA_MOD_NOT_SET));
    SelectComboBoxFromString (IDC_COMBO_OUTER_FEC, m_misc.ConvertFECMethodToString (BDA_FEC_METHOD_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_OUTER_FEC_RATE, m_misc.ConvertInnerFECRateToString (BDA_BCC_RATE_NOT_SET));
	SelectComboBoxFromString (IDC_COMBO_OUTER_SIGNAL_POLARISATION, m_misc.ConvertPolarisationToString(BDA_POLARISATION_NOT_SET));
	//fill the edit boxes

	SetDlgItemInt (IDC_EDIT_CARRIER_FREQUENCY, -1);
	SetDlgItemInt (IDC_EDIT_SYMBOL_RATE, -1);
	SetDlgItemInt (IDC_EDIT_AZIMUTH, -1);
	SetDlgItemInt (IDC_EDIT_ELEVATION, -1);
	SetDlgItemInt (IDC_EDIT_ORBITAL_POSITION, -1);
    //fill the tuning space now...
	SetDlgItemInt (IDC_EDIT_NETWORKID, -1);
	SetDlgItemInt (IDC_EDIT_HIGH_OSCILLATOR, -1);
	SetDlgItemInt (IDC_EDIT_LNBSwitch, -1);
	SetDlgItemInt (IDC_EDIT_LOW_OSCILATOR, -1);
	SelectComboBoxFromString (IDC_COMBO_SPECTRAL_INVERSION, m_misc.ConvertSpectralInversionToString (BDA_SPECTRAL_INVERSION_NOT_SET));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\dvbstuningspaces.h ===
// DVBSTuningSpaces.h : Declaration of the CDVBSTuningSpaces

#ifndef __DVBSTUNINGSPACES_H_
#define __DVBSTUNINGSPACES_H_

#include "resource.h"       // main symbols
#include "misccell.h"
#include <list>

EXTERN_C const CLSID CLSID_DVBSTuningSpaces;

/////////////////////////////////////////////////////////////////////////////
// CDVBSTuningSpaces
class ATL_NO_VTABLE CDVBSTuningSpaces :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDVBSTuningSpaces, &CLSID_DVBSTuningSpaces>,
	public IPropertyPageImpl<CDVBSTuningSpaces>,
	public CDialogImpl<CDVBSTuningSpaces>
{
public:
	CDVBSTuningSpaces()
	{
		m_dwTitleID = IDS_TITLEDVBSTuningSpaces;
		m_dwHelpFileID = IDS_HELPFILEDVBSTuningSpaces;
		m_dwDocStringID = IDS_DOCSTRINGDVBSTuningSpaces;
		m_bstrNetworkType = L"{FA4B375A-45B4-4d45-8440-263957B11623}";//DVBS Network Type
	}

	~CDVBSTuningSpaces()
	{
		ReleaseTuningSpaces ();
	}


	enum {IDD = IDD_DVBSTUNINGSPACES};

DECLARE_REGISTRY_RESOURCEID(IDR_DVBSTUNINGSPACES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDVBSTuningSpaces) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CDVBSTuningSpaces)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	CHAIN_MSG_MAP(IPropertyPageImpl<CDVBSTuningSpaces>)
	COMMAND_HANDLER(IDC_BUTTON_NEW_TUNING_SPACE, BN_CLICKED, OnClickedButton_new_tuning_space)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_TUNING_SPACE, BN_CLICKED, OnClickedButton_submit_tuning_space)
	COMMAND_HANDLER(IDC_LIST_TUNING_SPACES, LBN_SELCHANGE, OnSelchangeList_tuning_spaces)
	COMMAND_HANDLER(IDC_CHECK_WEST_POSITION, BN_CLICKED, OnClickedCheck_west_position)
	COMMAND_HANDLER(IDC_COMBO_FEC_RATE, CBN_SELCHANGE, OnSelchangeCombo_fec_rate)
	COMMAND_HANDLER(IDC_COMBO_INNER_FEC, CBN_SELCHANGE, OnSelchangeCombo_inner_fec)
	COMMAND_HANDLER(IDC_COMBO_MODULATION, CBN_SELCHANGE, OnSelchangeCombo_modulation)
	COMMAND_HANDLER(IDC_COMBO_OUTER_FEC, CBN_SELCHANGE, OnSelchangeCombo_outer_fec)
	COMMAND_HANDLER(IDC_COMBO_OUTER_FEC_RATE, CBN_SELCHANGE, OnSelchangeCombo_outer_fec_rate)
	COMMAND_HANDLER(IDC_COMBO_OUTER_SIGNAL_POLARISATION, CBN_SELCHANGE, OnSelchangeCombo_outer_signal_polarisation)
	COMMAND_HANDLER(IDC_COMBO_SPECTRAL_INVERSION, CBN_SELCHANGE, OnSelchangeCombo_spectral_inversion)
	COMMAND_HANDLER(IDC_EDIT_AZIMUTH, EN_CHANGE, OnChangeEdit_azimuth)
	COMMAND_HANDLER(IDC_EDIT_CARRIER_FREQUENCY, EN_CHANGE, OnChangeEdit_carrier_frequency)
	COMMAND_HANDLER(IDC_EDIT_ELEVATION, EN_CHANGE, OnChangeEdit_elevation)
	COMMAND_HANDLER(IDC_EDIT_FREQUENCY_MAPPING, EN_CHANGE, OnChangeEdit_frequency_mapping)
	COMMAND_HANDLER(IDC_EDIT_FRIENDLY_NAME, EN_CHANGE, OnChangeEdit_friendly_name)
	COMMAND_HANDLER(IDC_EDIT_HIGH_OSCILLATOR, EN_CHANGE, OnChangeEdit_high_oscillator)
	COMMAND_HANDLER(IDC_EDIT_INPUT_RANGE, EN_CHANGE, OnChangeEdit_input_range)
	COMMAND_HANDLER(IDC_EDIT_LNBSwitch, EN_CHANGE, OnChangeEdit_lnbswitch)
	COMMAND_HANDLER(IDC_EDIT_LOW_OSCILATOR, EN_CHANGE, OnChangeEdit_low_oscilator)
	COMMAND_HANDLER(IDC_EDIT_NETWORKID, EN_CHANGE, OnChangeEdit_networkid)
	COMMAND_HANDLER(IDC_EDIT_ORBITAL_POSITION, EN_CHANGE, OnChangeEdit_orbital_position)
	COMMAND_HANDLER(IDC_EDIT_SYMBOL_RATE, EN_CHANGE, OnChangeEdit_symbol_rate)
	COMMAND_HANDLER(IDC_EDIT_UNIQUE_NAME, EN_CHANGE, OnChangeEdit_unique_name)
    MESSAGE_HANDLER(WM_VKEYTOITEM, OnListKeyItem)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    typedef IPropertyPageImpl<CDVBSTuningSpaces> PPGBaseClass;

	void
	ReleaseTuningSpaces ()
	{
		TUNING_SPACES::iterator it;
		for (it = m_tunigSpaceList.begin (); it != m_tunigSpaceList.end ();)
		{
			(*it)->Release ();
			m_tunigSpaceList.erase (it);
			it = m_tunigSpaceList.begin ();
		}
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
	{
		// If we don't have any objects, this method should not be called
		// Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
		if (!m_ppUnk)
			return E_UNEXPECTED;

		// Use Activate to update the property page's UI with information
		// obtained from the objects in the m_ppUnk array

		// We update the page to display the Name and ReadOnly properties of the document

		// Call the base class
		HRESULT hr = S_OK;
		if (!this->m_hWnd)
			hr = PPGBaseClass::Activate(hWndParent, prc, bModal);
		
		//if already been through this skip it
		if (m_pTuner)
			return S_OK;
		
		if (!m_ppUnk[0])
			return E_UNEXPECTED;

		m_pTuner = m_ppUnk[0];
		if (!m_pTuner)
			return E_FAIL;
				
		//clear the tuning spaces both from the list and memory
		ReleaseTuningSpaces ();
		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		::SendMessage (hwndListBox, LB_RESETCONTENT, NULL, NULL);

		//get the tunning spaces
		CComPtr <IEnumTuningSpaces> pTuneSpaces;
		hr = m_pTuner->EnumTuningSpaces (&pTuneSpaces);
		IDVBSTuningSpace* pDVBSTuningSpace = NULL;
		if (SUCCEEDED (hr) && (pTuneSpaces))
		{
			ITuningSpace* pTuneSpace = NULL;
			while (pTuneSpaces->Next (1, &pTuneSpace, 0) == S_OK)
			{
				hr = pTuneSpace->QueryInterface(__uuidof (IDVBSTuningSpace), reinterpret_cast <void**> (&pDVBSTuningSpace));
				if (FAILED (hr) || (!pDVBSTuningSpace))
				{
					ASSERT (FALSE);
					continue;
				}
				CComBSTR uniqueName;
				hr = pDVBSTuningSpace->get_UniqueName (&uniqueName.m_str);
				if (FAILED (hr))
					continue;
				//don't bother to release the DVBSTuningSpace pointers
				//they will be added to a list that will be released later
				AddItemToListBox (uniqueName, pDVBSTuningSpace);//we will identify the items from the name
			}
		}

		if (pDVBSTuningSpace)
		{
			//if there is any existing tuning space available,
			//select the last one

			//select the last tuning space
			int nCount = ::SendMessage (hwndListBox, LB_GETCOUNT , NULL, NULL);
			::SendMessage (hwndListBox, LB_SETCURSEL, nCount-1, NULL);

			//fill with the last tuning space we got
			FillControlsFromTuningSpace (pDVBSTuningSpace);
		}
        else
        {
            //fill with default values
            FillDefaultControls ();
        }

		SetModifiedFlag (false);
		return S_OK;
	}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CNP_CommonPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}
	
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		USES_CONVERSION;
		//set the spins
		HWND hwndSpin = GetDlgItem (IDC_SPIN_NETWORKID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_MINMINOR_CHANNEL);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000); 
		hwndSpin = GetDlgItem (IDC_SPIN_HIGH_OSCILLATOR);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_LNBSwitch);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_LOW_OSCILATOR);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_CARRIER);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_SYMBOL_RATE);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_TSID);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_AZIMUTH);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ELEVATION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);
		hwndSpin = GetDlgItem (IDC_SPIN_ORBITAL_POSITION);
		::SendMessage(hwndSpin, UDM_SETRANGE32, -1, 1000000000);

		//fill the combos
		HWND hwndCombo = GetDlgItem (IDC_COMBO_INNER_FEC);
		int nIndex = 0;
		MAP_FECMethod::iterator it;
		for (it = m_misc.m_FECMethodMap.begin ();it != m_misc.m_FECMethodMap.end ();it++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it).first.c_str()))) 
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it2;
		for (it2 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it2 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it2++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it2).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it2).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_MODULATION);
		nIndex = 0;
		MAP_ModulationType::iterator it3;
		for (it3 = m_misc.m_ModulationTypeMap.begin ();it3 != m_misc.m_ModulationTypeMap.end ();it3++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it3).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it3).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC);
		nIndex = 0;
		MAP_FECMethod::iterator it4;
		for (it4 = m_misc.m_FECMethodMap.begin ();it4 != m_misc.m_FECMethodMap.end ();it4++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it4).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it4).second
				);
			++nIndex;
		}		
		
		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_FEC_RATE);
		nIndex = 0;
		MAP_BinaryConvolutionCodeRate::iterator it5;
		for (it5 = m_misc.m_BinaryConvolutionCodeRateMap.begin ();it5 != m_misc.m_BinaryConvolutionCodeRateMap.end ();it5++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it5).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it5).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_OUTER_SIGNAL_POLARISATION);
		nIndex = 0;
		MAP_Polarisation::iterator it6;
		for (it6 = m_misc.m_PolarisationMap.begin ();it6 != m_misc.m_PolarisationMap.end ();it6++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it6).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it6).second
				);
			++nIndex;
		}

		hwndCombo = GetDlgItem (IDC_COMBO_SPECTRAL_INVERSION);
		nIndex = 0;
		MAP_SpectralInversion::iterator it7;
		for (it7 = m_misc.m_SpectralInversionMap.begin ();it7 != m_misc.m_SpectralInversionMap.end ();it7++)
		{
			nIndex  = ::SendMessage (
				hwndCombo, 
				CB_INSERTSTRING, 
				nIndex, 
				reinterpret_cast <LPARAM> (A2T(const_cast <char*>((*it7).first.c_str())))
				);
			//set the associated data
			::SendMessage (
				hwndCombo, 
				CB_SETITEMDATA, 
				nIndex, 
				(*it7).second
				);
			++nIndex;
		}
		
		SetModifiedFlag (false);
		return 0;
	}

	STDMETHOD(Deactivate)( )
	{
		//overwrite the default behavior that was destroying the window
		//all the time
		return S_OK;
	}

private:
	CComQIPtr <IScanningTuner>			m_pTuner;
	CComQIPtr <IMediaEventEx>			m_pEventInterface;
	CBDAMiscellaneous					m_misc;
	bool								m_fFirstTime;
	typedef	std::list <IDVBSTuningSpace*> TUNING_SPACES;
	TUNING_SPACES						m_tunigSpaceList;//mantaing a list of available tuning spaces 
														//so we can access them easier
	CComBSTR							m_bstrNetworkType;

	static UINT m_NotifyMessage;

    void
    FillDefaultControls ();

	int
	AddItemToListBox (
		CComBSTR	strItem, 
		IDVBSTuningSpace* const dwData
		);

	void
	SelectComboBoxFromString (
		UINT nID, 
		CComBSTR strToFind
		);

	CComBSTR 
	GetComboText (
		UINT nID
		);

	HRESULT
	FillControlsFromTuningSpace (IDVBSTuningSpace* pTuningSpace);

	HRESULT
	FillControlFromLocator (IDVBSLocator* pLocator);

	HRESULT
	FillLocatorFromControls (IDVBSLocator* pLocator);

	HRESULT
	FillTuningSpaceFromControls (IDVBSTuningSpace* pTuningSpace);

	void
	SetModifiedFlag (bool fValue)
	{
		//this will also set the m_bDirty flag
		SetDirty (fValue);
		HWND hwndSubmit = GetDlgItem (IDC_BUTTON_SUBMIT_TUNING_SPACE);
		::EnableWindow (hwndSubmit, fValue);
	}

	LRESULT OnClickedButton_new_tuning_space(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		//let's clear all fields
        HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
        int nSelIndex = ::SendMessage (hwndListBox, LB_GETCURSEL , NULL, NULL);
        if (nSelIndex >= 0)
        {//we already have a selection, so try a clone
            SetDlgItemText (IDC_EDIT_UNIQUE_NAME, _T(""));
        }
        else
        {
            FillDefaultControls ();
        }
		
        //clear the current selection so the user will not be confused
		int nVal = ::SendMessage (hwndListBox, LB_SETCURSEL , -1, NULL);
		SetModifiedFlag (true);
		return 0;
	}

	LRESULT OnClickedButton_submit_tuning_space(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        HRESULT hr = S_OK;
        bool bIsNew = false;
        CComPtr <IDVBSTuningSpace> pTuningSpace;
		CComQIPtr <IDVBSLocator> pDVBSLocator;
        //try to get a tuning space, either from the list, either creating a new one
        HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		int nTunIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
        if (nTunIndex == LB_ERR)
            bIsNew = true;

        //just create a tuning space so we can check if it's unique or not
        hr = CoCreateInstance (
			CLSID_DVBSTuningSpace, 
			NULL, 
			CLSCTX_INPROC_SERVER, 
			__uuidof (IDVBSTuningSpace),
			reinterpret_cast <PVOID*> (&pTuningSpace)
			);
		if (FAILED (hr) || (!pTuningSpace))
		{
			MESSAGEBOX (this, IDS_CANNOT_INSTANTIATE_DVBSTUNE);
			return 0;
		}
		hr = CoCreateInstance (
			CLSID_DVBSLocator, 
			NULL, 
			CLSCTX_INPROC_SERVER, 
			__uuidof (IDVBSLocator),
			reinterpret_cast <PVOID*> (&pDVBSLocator)
			);
		if (!pDVBSLocator)
		{
			MESSAGEBOX (this, IDS_CANNOT_GET_IDVBSLOCATOR);
			return 0;
		}

		if (FAILED (FillLocatorFromControls (pDVBSLocator)))
			return 0;
		pTuningSpace->put_DefaultLocator (pDVBSLocator);
		//fill the tuningSpace
		hr = FillTuningSpaceFromControls (pTuningSpace);
		if (FAILED (hr))
			return 0;
     	hr = pTuningSpace->put_SystemType (DVB_Satellite);

		//create the tuning space container so we can find the tuning space
		CComPtr <ITuningSpaceContainer> pTuningSpaceContainer;
		hr = CoCreateInstance (
						CLSID_SystemTuningSpaces, 
						NULL, 
						CLSCTX_INPROC_SERVER, 
						__uuidof (ITuningSpaceContainer),
						reinterpret_cast <PVOID*> (&pTuningSpaceContainer)
						);
		if (FAILED (hr) || (!pTuningSpaceContainer))
		{
			MESSAGEBOX (this, IDS_CANNOT_INSTANTIATE_TUNECONTAINER);
			return 0;
		}
		LONG lID;
		hr = pTuningSpaceContainer->FindID (pTuningSpace, &lID);
		if (FAILED (hr))
		{
            //looks like a new item
			int nIndex = 0;
			CComVariant varIndex (nIndex);
			hr = pTuningSpaceContainer->Add (pTuningSpace, &varIndex);
			if (SUCCEEDED (hr))
			{
				CComBSTR genericName;
				hr = pTuningSpace->get_UniqueName (&genericName.m_str);
				if (SUCCEEDED (hr))
				{
					int nTunIndex = AddItemToListBox (genericName, pTuningSpace);
					HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
					::SendMessage (hwndListBox, LB_SETCURSEL, nTunIndex, NULL);
					(*pTuningSpace).AddRef ();//need to addref since is a smart pointer
				}
			}
		}
        else
        {
            if (bIsNew)
            {
                MESSAGEBOX (this, IDS_ENTER_UNIQUE_NAME);
				return 0;
            }
            else
            {
                //looks like we can sumbmit this EXISTING item
                //release the old tuning space
                pTuningSpace.Release ();
                pTuningSpace = NULL;

                pTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (
                    ::SendMessage (hwndListBox, LB_GETITEMDATA, nTunIndex, NULL));
                ASSERT (pTuningSpace);
                if (!pTuningSpace)
                    return NULL;
                CComPtr <ILocator> pLocator;
                pTuningSpace->get_DefaultLocator (&pLocator);
                pDVBSLocator = pLocator;
                if (!pDVBSLocator)
                {
                    ASSERT (FALSE);
                    return NULL;
                }
                CComBSTR uniqueName;
                hr = pTuningSpace->get_UniqueName (&uniqueName.m_str);
                if (FAILED(hr))
                {
			        MESSAGEBOX (this, IDS_CANNOT_RETRIEVE_UNIQUENAME);
			        return 0;
                }
                if (FAILED (FillLocatorFromControls (pDVBSLocator)))
                    return 0;
                pTuningSpace->put_DefaultLocator (pDVBSLocator);
                //fill the tuningSpace
                hr = FillTuningSpaceFromControls (pTuningSpace);
                if (FAILED (hr))
                    return 0;
                //replace with old name
                hr = pTuningSpace->put_UniqueName (uniqueName);
                if (FAILED(hr))
                {
			        MESSAGEBOX (this, IDS_CANNOT_SET_UNIQUE);
			        return 0;
                }
		        CComVariant varIndex (lID);
		        hr = pTuningSpaceContainer->put_Item (varIndex, pTuningSpace);
		        if (FAILED (hr))
		        {
			        MESSAGEBOX (this, IDS_CANNOT_SUBMIT_TUNE);
			        return 0;
		        }
            }
        }

        //disable the submit button
        ::EnableWindow (GetDlgItem (IDC_BUTTON_SUBMIT_TUNING_SPACE), FALSE);
        RefreshAll ();
		return 0;
	}

    void RefreshAll ()
    {
		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
		int nIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
		if (nIndex == LB_ERR)
		{
			ASSERT (FALSE);
			return;
		}
		
		LRESULT dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, nIndex, NULL);
		if (dwData == LB_ERR)
		{
			ASSERT (FALSE);
			return;
		}
		IDVBSTuningSpace* pTuningSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
		ASSERT (pTuningSpace);
		FillControlsFromTuningSpace (pTuningSpace);
    }

	LRESULT OnSelchangeList_tuning_spaces(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
        RefreshAll ();
        //disable the submit button
        ::EnableWindow (GetDlgItem (IDC_BUTTON_SUBMIT_TUNING_SPACE), FALSE);
        return 0; 
	}

	//standard 'dirty' messages
	LRESULT OnClickedCheck_west_position(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_fec_rate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_inner_fec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_modulation(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_outer_fec(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_outer_fec_rate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_outer_signal_polarisation(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnSelchangeCombo_spectral_inversion(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}

	LRESULT OnChangeEdit_azimuth(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_carrier_frequency(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_elevation(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_frequency_mapping(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_friendly_name(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_high_oscillator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_input_range(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_lnbswitch(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_low_oscilator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_networkid(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_orbital_position(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}
	LRESULT OnChangeEdit_symbol_rate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}

	LRESULT OnChangeEdit_unique_name(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		SetModifiedFlag (true);
		return 0;
	}

   	LRESULT OnListKeyItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (LOWORD(wParam) == VK_DELETE)
        {
    		HWND hwndListBox = GetDlgItem (IDC_LIST_TUNING_SPACES);
            int nIndex = ::SendMessage (hwndListBox, LB_GETCURSEL, NULL, NULL);
            if (nIndex != LB_ERR)
            {
                DWORD_PTR dwData = ::SendMessage (hwndListBox, LB_GETITEMDATA, nIndex, NULL);
                IDVBSTuningSpace* pTunSpace = reinterpret_cast <IDVBSTuningSpace*> (dwData);
		        TUNING_SPACES::iterator it;
		        for (it = m_tunigSpaceList.begin (); it != m_tunigSpaceList.end ();it++)
		        {
                    if (pTunSpace == *it)
                    {
		                CComPtr <ITuningSpaceContainer> pTuningSpaceContainer;
		                HRESULT hr = CoCreateInstance (
						                CLSID_SystemTuningSpaces, 
						                NULL, 
						                CLSCTX_INPROC_SERVER, 
						                __uuidof (ITuningSpaceContainer),
						                reinterpret_cast <PVOID*> (&pTuningSpaceContainer)
						                );
		                if (FAILED (hr) || (!pTuningSpaceContainer))
		                {
			                MESSAGEBOX (this, IDS_CANNOT_INSTANTIATE_TUNECONTAINER);
			                return 0;
		                }
		                LONG lID;
		                hr = pTuningSpaceContainer->FindID (pTunSpace, &lID);
		                if (FAILED (hr))
		                {
			                MESSAGEBOX (this, IDS_CANNOT_FIND_TUNE_IN_CONTAINER);
                            return 0;
                        }
			            CComVariant varIndex (lID);
			            hr = pTuningSpaceContainer->Remove (varIndex);
			            if (FAILED (hr))
			            {
			                MESSAGEBOX (this, IDS_CANNOT_REMOVE_TUNINGSPACE);
			                return 0;
                        }
			            (*it)->Release ();
			            m_tunigSpaceList.erase (it);
                        ::SendMessage (hwndListBox, LB_DELETESTRING, nIndex, NULL);
                        //looks like the list is empty//try to select the first item from the list
                        if (::SendMessage (hwndListBox, LB_SETCURSEL, 0, NULL) == LB_ERR)
                        {
                            //looks like the list is empty
                            FillDefaultControls ();
                            //set the unique name to an empty string so the user will enter it's own
                            SetDlgItemText (IDC_EDIT_UNIQUE_NAME, _T(""));
                        }
                        break;
                    }
		        }
            }
        }
		return 0;
	}

};

#endif //__DVBSTUNINGSPACES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\lasterrorwin.cpp ===
// LastErrorWin.cpp: implementation of the CLastErrorWin class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "LastErrorWin.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLastErrorWin::CLastErrorWin()
{

}

CLastErrorWin::~CLastErrorWin()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\lasterrorwin.h ===
// LastErrorWin.h: interface for the CLastErrorWin class.
//	Implements the subclassed static control for the common prop page
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LASTERRORWIN_H__A23AB1D9_684C_48D4_A9D1_FD3DCEBD9D5B__INCLUDED_)
#define AFX_LASTERRORWIN_H__A23AB1D9_684C_48D4_A9D1_FD3DCEBD9D5B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "resource.h"       // main symbols

class CLastErrorWin : 
	public CWindowImpl<CLastErrorWin>
{
public:
	CLastErrorWin();
	virtual ~CLastErrorWin();
	BEGIN_MSG_MAP(CLastErrorWin)
		MESSAGE_HANDLER( OCM_CTLCOLORSTATIC, OnCtlColor )
		DEFAULT_REFLECTION_HANDLER ()
	END_MSG_MAP()	

	LRESULT OnCtlColor( UINT, WPARAM wParam, LPARAM, BOOL& ) 
	{
      // notify bit must be set to get STN_* notifications
      ModifyStyle( 0, SS_NOTIFY );
	  LOGBRUSH lb = 
	  {
			BS_SOLID,//style
			GetSysColor (COLOR_3DFACE),//color
			0//hatch
	  };
	  //make sure we're not leaking the process resources
      static HBRUSH hBrNormal = CreateBrushIndirect (&lb);
	  HDC dc = reinterpret_cast <HDC> (wParam);
	  SetTextColor (dc, RGB(255, 0, 0));
	  SetBkColor (dc, GetSysColor (COLOR_3DFACE));
      return reinterpret_cast <LRESULT> (hBrNormal);
   }

};

#endif // !defined(AFX_LASTERRORWIN_H__A23AB1D9_684C_48D4_A9D1_FD3DCEBD9D5B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\misccell.h ===
#ifndef __MISCCELL_H__
#define __MISCCELL_H__

#include <map>
#include <string>
using namespace std;

	typedef map <string, FECMethod> MAP_FECMethod;
	typedef map <string, BinaryConvolutionCodeRate> MAP_BinaryConvolutionCodeRate;
	typedef map <string, ModulationType> MAP_ModulationType;
	typedef map <string, TunerInputType> MAP_TunerInputType;
	typedef map <string, Polarisation> MAP_Polarisation;
	typedef map <string, SpectralInversion> MAP_SpectralInversion;


class CBDAMiscellaneous
{
public:
	CBDAMiscellaneous ();


	MAP_FECMethod					m_FECMethodMap;
	MAP_BinaryConvolutionCodeRate	m_BinaryConvolutionCodeRateMap;
	MAP_ModulationType				m_ModulationTypeMap;
	MAP_TunerInputType				m_TunerInputTypeMap;
	MAP_Polarisation				m_PolarisationMap;
	MAP_SpectralInversion			m_SpectralInversionMap;

	static string m_FECMethodString[];
	static string m_BinaryConvolutionCodeRateString[];
	static string m_ModulationTypeString[];
	static string m_TunerInputTypeString[];
	static string m_PolarisationString[];
	static string m_SpectralInversionString[];

	static FECMethod				m_FECMethodValues[];
	static BinaryConvolutionCodeRate m_BinaryConvolutionCodeRateValues[];
	static ModulationType			m_ModulationTypeValues[];
	static TunerInputType			m_TunerInputTypeValues[];
	static Polarisation				m_PolarisationValues[];
	static SpectralInversion		m_SpectralInversionValues[];

	CComBSTR 
	ConvertFECMethodToString (FECMethod	method);

	CComBSTR
	ConvertInnerFECRateToString (BinaryConvolutionCodeRate	method);

	CComBSTR
	ConvertModulationToString (ModulationType	method);

	CComBSTR
	ConvertTunerInputTypeToString (TunerInputType	method);

	CComBSTR
	ConvertPolarisationToString (Polarisation	method);

	CComBSTR
	ConvertSpectralInversionToString (SpectralInversion	method);

	//and the map methods
	FECMethod 
	ConvertStringToFECMethod (string str);

	BinaryConvolutionCodeRate
	ConvertStringToBinConvol (string str);

	ModulationType
	ConvertStringToModulation (string str);

	TunerInputType
	ConvertStringToTunerInputType (string str);

	Polarisation
	ConvertStringToPolarisation (string str);

	SpectralInversion
	ConvertStringToSpectralInversion (string str);

    static HRESULT
    RegisterForEvents (
        IUnknown* pUnk,                         //IBaseFilter
        IBroadcastEvent*    pImplementation,    //current implementation
        IBroadcastEvent**   pBroadcastService,  //[out]
        DWORD& dwPublicCookie                   //[out]
        )
    {
        static CCritSec cssLockMe;
        HRESULT hr;
        DWORD dwCookie = 0;
        dwPublicCookie = 0;
        //register for events
        FILTER_INFO filterInfo;
        CComQIPtr <IBaseFilter> pFilter (pUnk);
        CComPtr <IBroadcastEvent> pBroadcastEventService;
        if (!pFilter)
        {
            return E_FAIL;
        }
        if (FAILED(pFilter->QueryFilterInfo (&filterInfo)))
        {
            return E_FAIL;
        }
        CComQIPtr <IServiceProvider> sp(filterInfo.pGraph);
        filterInfo.pGraph->Release ();
        if (!sp)
        {
            return E_FAIL;
        }
        {
            CAutoLock lockMe (&cssLockMe);
            hr = sp->QueryService(SID_SBroadcastEventService, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&pBroadcastEventService));
            if (FAILED(hr) || !pBroadcastEventService) 
            {
                hr = pBroadcastEventService.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
                if (FAILED(hr)) 
                {
                    ATLTRACE ("Cannot create the event service");
                    return E_FAIL;
                }
                CComQIPtr <IRegisterServiceProvider> rsp(sp);
                if (!rsp) 
                {
                    ATLTRACE ("Cannot get the IRegisterServiceProvider");
                    return E_FAIL;
                }
                hr = rsp->RegisterService(SID_SBroadcastEventService, pBroadcastEventService);
                if (FAILED(hr)) 
                {
                    ATLTRACE ("Cannot register service");
    		        return E_FAIL;
                }
            }
        }
        ATLASSERT (pBroadcastEventService);
        CComQIPtr <IConnectionPoint> pConPoint(pBroadcastEventService);
        if (!pConPoint)
        {
            ATLTRACE ("Cannot retrieve IConnectionPoint");
            return E_FAIL;
        }
        hr = pConPoint->Advise(
            pImplementation,
            &dwCookie
            );
        if (FAILED(hr)) 
        {
            ATLTRACE ("Unable to advise");
            return E_FAIL;
        }
        hr = pBroadcastEventService->QueryInterface (__uuidof (IBroadcastEvent), 
            reinterpret_cast <PVOID*> (pBroadcastService));
        if (FAILED (hr))
            return E_FAIL;
        dwPublicCookie = dwCookie;
        return S_OK;
    }

};
#endif //__MISCCELL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\np_commonpage.cpp ===
// NP_CommonPage.cpp : Implementation of CNP_CommonPage
#include "stdafx.h"
#include "NPPropPage.h"
#include "NP_CommonPage.h"

/////////////////////////////////////////////////////////////////////////////
// CNP_CommonPage

UINT CNP_CommonPage::m_NotifyMessage = RegisterWindowMessage (_T ("CommonPageEventMessasge"));

//==================================================================
//	Returns a handle to the tree window
//	If there is no window will return NULL
//
//==================================================================
HWND 
CNP_CommonPage::GetSafeTreeHWND ()
{
	HWND	hwndTree = GetDlgItem (IDC_TREE_TUNING_SPACES);
	if (!::IsWindow (hwndTree))
	{
		ASSERT (FALSE);
		return NULL;
	}
	return hwndTree;
}

HWND 
CNP_CommonPage::GetSafeLastErrorHWND ()
{
	HWND	hwndTree = GetDlgItem (IDC_STATIC_HRESULT);
	if (!::IsWindow (hwndTree))
	{
		ASSERT (FALSE);
		return NULL;
	}
	return hwndTree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\miscell.cpp ===
#include "stdafx.h"
#include "misccell.h"

using namespace std;

string	CBDAMiscellaneous::m_FECMethodString[] = {
	"METHOD_NOT_SET",
    "METHOD_NOT_DEFINED",
    "VITERBI", // FEC is a Viterbi Binary Convolution.
    "RS_204_188",  // The FEC is Reed-Solomon 204/188 (outer FEC).
    "MAX"
};

string CBDAMiscellaneous::m_BinaryConvolutionCodeRateString[] = {
    "NOT_SET",
    "NOT_DEFINED",
    "1/2",
    "2/3",
    "3/4",
    "3/5",
    "4/5",
    "5/6",
    "5/11",
    "7/8",
    "BDA_BCC_RATE_MAX"
};


string CBDAMiscellaneous::m_ModulationTypeString[] = {
    "NOT_SET",
    "NOT_DEFINED",
    "16QAM",
    "32QAM",
    "64QAM",
    "80QAM",
    "96QAM",
    "112QAM",
    "128QAM",
    "160QAM",
    "192QAM",
    "224QAM",
    "256QAM",
    "320QAM",
    "384QAM",
    "448QAM",
    "512QAM",
    "640QAM",
    "768QAM",
    "896QAM",
    "1024QAM",
    "QPSK",
    "BPSK",
    "OQPSK",
    "8VSB",
    "16VSB",
    "ANALOG_AMPLITUDE",
    "ANALOG_FREQUENCY",
    "MAX"
} ;

string CBDAMiscellaneous::m_TunerInputTypeString[] = {
	"TunerInputCable",
    "TunerInputAntenna"
};

string CBDAMiscellaneous::m_PolarisationString[] = {
	"NOT_SET",
    "NOT_DEFINED",
    "LINEAR_H",
    "LINEAR_V",
    "CIRCULAR_L",
    "CIRCULAR_R",
    "MAX"
};
	
string CBDAMiscellaneous::m_SpectralInversionString[] = {
	"NOT_SET",// = -1,
    "NOT_DEFINED",// = 0,
    "AUTOMATIC",// = 1,
    "NORMAL",
    "INVERTED",
    "MAX"
};


//and the values
FECMethod CBDAMiscellaneous::m_FECMethodValues [] = {
    BDA_FEC_METHOD_NOT_SET,// = -1,
    BDA_FEC_METHOD_NOT_DEFINED,// = 0,
    BDA_FEC_VITERBI,// = 1, // FEC is a Viterbi Binary Convolution.
    BDA_FEC_RS_204_188,//The FEC is Reed-Solomon 204/188 (outer FEC).
    BDA_FEC_MAX
};

BinaryConvolutionCodeRate CBDAMiscellaneous::m_BinaryConvolutionCodeRateValues[] = {
	BDA_BCC_RATE_NOT_SET,// = -1,
    BDA_BCC_RATE_NOT_DEFINED,// = 0,
    BDA_BCC_RATE_1_2,// = 1,
    BDA_BCC_RATE_2_3,// = 2,
    BDA_BCC_RATE_3_4,// = 3,
    BDA_BCC_RATE_3_5,// = 4,
    BDA_BCC_RATE_4_5,// = 5,
    BDA_BCC_RATE_5_6,// = 6,
    BDA_BCC_RATE_5_11,// = 7,
    BDA_BCC_RATE_7_8,// = 8,
    BDA_BCC_RATE_MAX// = 9
};

ModulationType CBDAMiscellaneous::m_ModulationTypeValues[] = {
	BDA_MOD_NOT_SET,// = -1,
    BDA_MOD_NOT_DEFINED,// = 0,
    BDA_MOD_16QAM,// = 1,
    BDA_MOD_32QAM,// = 2,
    BDA_MOD_64QAM,// = 3,
    BDA_MOD_80QAM,// = 4,
    BDA_MOD_96QAM,// = 5,
    BDA_MOD_112QAM,// = 6,
    BDA_MOD_128QAM,// = 7,
    BDA_MOD_160QAM,// = 8,
    BDA_MOD_192QAM,// = 9,
    BDA_MOD_224QAM,// = 10,
    BDA_MOD_256QAM,// = 11,
    BDA_MOD_320QAM,// = 12,
    BDA_MOD_384QAM,// = 13,
    BDA_MOD_448QAM,// = 14,
    BDA_MOD_512QAM,// = 15,
    BDA_MOD_640QAM,// = 16,
    BDA_MOD_768QAM,// = 17,
    BDA_MOD_896QAM,// = 18,
    BDA_MOD_1024QAM,// = 19,
    BDA_MOD_QPSK,// = 20,
    BDA_MOD_BPSK,// = 21,
    BDA_MOD_OQPSK,// = 22,
    BDA_MOD_8VSB,// = 23,
    BDA_MOD_16VSB,// = 24,
    BDA_MOD_ANALOG_AMPLITUDE,// = 25,
    BDA_MOD_ANALOG_FREQUENCY,// = 26,
    BDA_MOD_MAX// = 27
};

TunerInputType CBDAMiscellaneous::m_TunerInputTypeValues[] = {
	TunerInputCable,
    TunerInputAntenna
};

Polarisation CBDAMiscellaneous::m_PolarisationValues[] = {
	BDA_POLARISATION_NOT_SET,// = -1,
    BDA_POLARISATION_NOT_DEFINED,// = 0,
    BDA_POLARISATION_LINEAR_H,// = 1,
    BDA_POLARISATION_LINEAR_V,// = 2,
    BDA_POLARISATION_CIRCULAR_L,// = 3,
    BDA_POLARISATION_CIRCULAR_R,// = 4,
    BDA_POLARISATION_MAX// = 5
};

SpectralInversion	CBDAMiscellaneous::m_SpectralInversionValues[] = {
	BDA_SPECTRAL_INVERSION_NOT_SET, // = -1,
    BDA_SPECTRAL_INVERSION_NOT_DEFINED, // = 0,
    BDA_SPECTRAL_INVERSION_AUTOMATIC, // = 1,
    BDA_SPECTRAL_INVERSION_NORMAL,
    BDA_SPECTRAL_INVERSION_INVERTED,
    BDA_SPECTRAL_INVERSION_MAX
};


CBDAMiscellaneous::CBDAMiscellaneous ()
{
	//let's build the maps
	int nLen = sizeof (m_FECMethodValues)/sizeof (m_FECMethodValues[0]);
	for (int i=0;i<nLen;i++)
		m_FECMethodMap.insert (
			MAP_FECMethod::value_type (
				m_FECMethodString[i], m_FECMethodValues[i]
				)
			);

	nLen = sizeof (m_BinaryConvolutionCodeRateValues)/sizeof (m_BinaryConvolutionCodeRateValues[0]);
	for (i=0;i<nLen;i++)
		m_BinaryConvolutionCodeRateMap.insert (
			MAP_BinaryConvolutionCodeRate::value_type (
				m_BinaryConvolutionCodeRateString[i], 
				m_BinaryConvolutionCodeRateValues[i]
				)
			);
	nLen = sizeof (m_ModulationTypeValues)/sizeof (m_ModulationTypeValues[0]);
	for (i=0;i<nLen;i++)
		m_ModulationTypeMap.insert (
			MAP_ModulationType::value_type (
				m_ModulationTypeString[i], 
				m_ModulationTypeValues[i]
				)
			);
	nLen = sizeof (m_TunerInputTypeValues)/sizeof (m_TunerInputTypeValues[0]);
	for (i=0;i<nLen;i++)
		m_TunerInputTypeMap.insert (
			MAP_TunerInputType::value_type (
				m_TunerInputTypeString[i], 
				m_TunerInputTypeValues[i]
				)
			);
	nLen = sizeof (m_PolarisationValues)/sizeof (m_PolarisationValues[0]);
	for (i=0;i<nLen;i++)
		m_PolarisationMap.insert (
			MAP_Polarisation::value_type (
				m_PolarisationString[i], 
				m_PolarisationValues[i]
				)
			);
	nLen = sizeof (m_SpectralInversionValues)/sizeof (m_SpectralInversionValues[0]);
	for (i=0;i<nLen;i++)
		m_SpectralInversionMap.insert (
			MAP_SpectralInversion::value_type (
				m_SpectralInversionString[i], 
				m_SpectralInversionValues[i]
				)
			);
	
}


CComBSTR 
CBDAMiscellaneous::ConvertFECMethodToString (FECMethod	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_FECMethod::iterator it;
	for (it = m_FECMethodMap.begin();it != m_FECMethodMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertInnerFECRateToString (BinaryConvolutionCodeRate	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_BinaryConvolutionCodeRate::iterator it;
	for (it = m_BinaryConvolutionCodeRateMap.begin();it != m_BinaryConvolutionCodeRateMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertModulationToString (ModulationType	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_ModulationType::iterator it;
	for (it = m_ModulationTypeMap.begin();it != m_ModulationTypeMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertTunerInputTypeToString (TunerInputType	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_TunerInputType::iterator it;
	for (it = m_TunerInputTypeMap.begin();it != m_TunerInputTypeMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertPolarisationToString (Polarisation	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_Polarisation::iterator it;
	for (it = m_PolarisationMap.begin();it != m_PolarisationMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

CComBSTR
CBDAMiscellaneous::ConvertSpectralInversionToString (SpectralInversion	method)
{
	//the map is not used for this
	//we're using map only for coverting from 
	//a string to a integer representation
	MAP_SpectralInversion::iterator it;
	for (it = m_SpectralInversionMap.begin();it != m_SpectralInversionMap.end ();it++)
	{
		if ((*it).second == method)
			return (*it).first.c_str ();
	}
	ASSERT (FALSE);
	return _T("");
}

//and the map methods
FECMethod 
CBDAMiscellaneous::ConvertStringToFECMethod (string str)
{
	MAP_FECMethod::iterator it = 
		m_FECMethodMap.find (str);
	ASSERT (it != m_FECMethodMap.end());
	if (it == m_FECMethodMap.end())
		return BDA_FEC_METHOD_NOT_SET;
	return (*it).second;
}

BinaryConvolutionCodeRate
CBDAMiscellaneous::ConvertStringToBinConvol (string	str)
{
	MAP_BinaryConvolutionCodeRate::iterator it = 
		m_BinaryConvolutionCodeRateMap.find (str);
	ASSERT (it != m_BinaryConvolutionCodeRateMap.end());
	if (it == m_BinaryConvolutionCodeRateMap.end())
		return BDA_BCC_RATE_NOT_SET;
	return (*it).second;
}

ModulationType
CBDAMiscellaneous::ConvertStringToModulation (string str)
{
	MAP_ModulationType::iterator it = 
		m_ModulationTypeMap.find (str);
	ASSERT (it != m_ModulationTypeMap.end());
	if (it == m_ModulationTypeMap.end())
		return BDA_MOD_NOT_SET;
	return (*it).second;
}

TunerInputType
CBDAMiscellaneous::ConvertStringToTunerInputType (string str)
{
	MAP_TunerInputType::iterator it = 
		m_TunerInputTypeMap.find (str);
	ASSERT (it != m_TunerInputTypeMap.end());
	if (it == m_TunerInputTypeMap.end())
		return TunerInputCable;
	return (*it).second;
}

Polarisation
CBDAMiscellaneous::ConvertStringToPolarisation (string str)
{
	MAP_Polarisation::iterator it = 
		m_PolarisationMap.find (str);
	ASSERT (it != m_PolarisationMap.end());
	if (it == m_PolarisationMap.end())
		return BDA_POLARISATION_NOT_SET;
	return (*it).second;
}

SpectralInversion
CBDAMiscellaneous::ConvertStringToSpectralInversion (string str)
{
	MAP_SpectralInversion::iterator it = 
		m_SpectralInversionMap.find (str);
	ASSERT (it != m_SpectralInversionMap.end());
	if (it == m_SpectralInversionMap.end())
		return   BDA_SPECTRAL_INVERSION_NOT_SET;
	return (*it).second;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NPPropPage.rc
//
#define IDS_HELPFILEATSCPropPage        107
#define IDS_DOCSTRINGATSCPropPage       108
#define IDR_ATSCPROPPAGE                109
#define IDD_ATSCPROPPAGE                110
#define IDD_DVBSTUNINGSPACES            111
#define IDS_TITLEDVBSTuningSpaces       112
#define IDS_HELPFILEDVBSTuningSpaces    113
#define IDS_DOCSTRINGDVBSTuningSpaces   114
#define IDR_DVBSTUNINGSPACES            115
#define IDS_TITLEDVBSTuneRequestPage    117
#define IDS_HELPFILEDVBSTuneRequestPage 118
#define IDS_DOCSTRINGDVBSTuneRequestPage 119
#define IDR_DVBSTUNEREQUESTPAGE         120
#define IDD_DVBSTUNEREQUESTPAGE         121
#define IDS_TITLEATSCPropPage           122
#define IDD_NP_COMMONPAGE               123
#define IDR_NP_COMMONPAGE               124
#define IDS_DOCSTRINGNP_CommonPage      125
#define IDS_HELPFILENP_CommonPage       126
#define IDS_TITLENP_CommonPage          127
#define IDS_PROJNAME                    128
#define IDS_FAILED_GET_SID              129
#define IDS_FAILED_GET_TSID             130
#define IDS_CANNOT_SET_INNERFEC         131
#define IDS_CANNOT_SET_INNERFECRATE     132
#define IDS_CANNOT_SET_MODULATION       133
#define IDS_CANNOT_SET_OUTERFECRATE     135
#define IDS_CANNOT_SET_SIGNALPOLARISATION 136
#define IDS_CANNOT_SET_CARRIERFREQUENCY 137
#define IDS_CANNOT_SET_SYMBOLRATE       138
#define IDS_CANNOT_SET_AZIMUTH          139
#define IDS_CANNOT_SET_ELEVATION        140
#define IDS_CANNOT_SET_ORBITALPOSITION  141
#define IDS_CANNOT_SET_WESTPOSITION     142
#define IDS_CANNOT_SET_ONID             143
#define IDS_CANNOT_SET_TSID             144
#define IDS_CANNOT_SET_SID              145
#define IDS_CANNOT_GET_DEFLOC           146
#define IDS_CANNOT_GET_DEF_DVBSLOCATOR  147
#define IDS_CANNOT_CREATE_NEW_TUNEREQUEST 148
#define IDS_CANNOT_RETRIEVE_DVBSTUNEREQUEST 149
#define IDS_CANNOT_SET_LOCATOR_FOR_TUNEREQUEST 150
#define IDS_CANNOT_PUT_TUNE_REQUEST     151
#define IDS_CANNOT_GET_UNIQUENAME       152
#define IDS_CANNOT_GET_FRIENDLYNAME     153
#define IDS_CANNOT_GET_FREQUENCYMAPPING 154
#define IDS_CANNOT_GET_NETWORKID        155
#define IDS_CANNOT_GET_HIGHOSCILATOR    156
#define IDS_CANNOT_GET_LNBSWITCH        157
#define IDS_CANNOT_GET_INPUTRANGE       158
#define IDS_CANNOT_GET_LOWOSCILLATOR    159
#define IDS_CANNOT_GET_SPECTRALINVERSION 160
#define IDS_CANNOT_GET_ILOCATOR         161
#define IDS_CANNOT_GET_DVBSLOCATOR      162
#define IDS_CANNOT_SET_OUTERFEC         166
#define IDS_CANNOT_SET_UNIQUENAME       175
#define IDS_CANNOT_SET_FRIENDLYNAME     176
#define IDS_CANNOT_SET_FREQUENCYMAPPING 177
#define IDS_CANNOT_SET_NETWORKID        178
#define IDS_CANNOT_SET_HIGHOSCILATOR    179
#define IDS_CANNOT_SET_LNBSWITCH        180
#define IDS_CANNOT_SET_INPUTRANGE       181
#define IDS_CANNOT_SET_LOWOSCILLATOR    182
#define IDS_CANNOT_SET_SPECTRALINVERSION 183
#define IDS_CANNOT_SET_NETWORKTYPE      184
#define IDS_CANNOT_INSTANTIATE_DVBSTUNE 185
#define IDS_CANNOT_GET_IDVBSLOCATOR     186
#define IDS_CANNOT_INSTANTIATE_TUNECONTAINER 187
#define IDS_ENTER_UNIQUE_NAME           188
#define IDS_CANNOT_RETRIEVE_UNIQUENAME  189
#define IDS_CANNOT_SET_UNIQUE           190
#define IDS_CANNOT_SUBMIT_TUNE          191
#define IDS_CANNOT_FIND_TUNE_IN_CONTAINER 192
#define IDS_CANNOT_REMOVE_TUNINGSPACE   193
#define IDS_PUT_CHANNEL                 194
#define IDS_PUT_MINOR_CHANNEL           195
#define IDS_CANNOT_IATSCLOCATOR         196
#define IDS_PUT_PHYSICAL                197
#define IDS_NOT_VALID_TUNE_REQUEST      198
#define IDS_CANNOT_SUBMIT_TUNE_REQUEST  199
#define IDC_DEFAULT_LOCATOR             200
#define IDC_BUTTON_SEEK_UP              202
#define IDC_BUTTON_SEEK_DOWN            203
#define IDC_BUTTON_AUTO_PROGRAM         204
#define IDC_STATIC_TSID                 206
#define IDC_STATIC_SIGNALQUALITY        207
#define IDC_STATIC_SIGNAL_STRENGTH      208
#define IDC_TREE_TUNING_SPACES          209
#define IDC_STATIC_HRESULT              210
#define IDS_FAILED_GET_ONID             211
#define IDD_NEW                         212
#define IDS_ERROR_CAPTION               212
#define IDC_BUTTON_SCAN_UP              214
#define IDC_BUTTON_SCAN_DOWN            215
#define IDC_BUTTON_SUBMIT_LOCATOR       216
#define IDC_EDIT_PHYSICAL_CHANNEL       217
#define IDC_EDIT_MINOR_CHANNEL          218
#define IDC_EDIT_SID                    219
#define IDC_SPIN_MINOR_CHANNEL          220
#define IDC_EDIT_MAJOR_CHANNEL          221
#define IDC_SPIN_MAJOR_CHANNEL          222
#define IDC_BUTTON_VALIDATE             223
#define IDC_EDIT_UNIQUE_NAME            224
#define IDC_EDIT_FRIENDLY_NAME          225
#define IDC_EDIT_CARRIER_FREQUENCY      226
#define IDC_SPIN_CARRIER                227
#define IDC_EDIT_ONID                   228
#define IDC_SPIN_PHYSICAL_CHANNEL       229
#define IDC_EDIT_SYMBOL_RATE            236
#define IDC_SPIN_SYMBOL_RATE            237
#define IDC_EDIT_TSID                   238
#define IDC_SPIN_TSID                   239
#define IDC_BUTTON_SUBMIT_TUNE_REQUEST  240
#define IDC_COMBO_INNER_FEC             241
#define IDC_COMBO_FEC_RATE              242
#define IDC_COMBO_MODULATION            243
#define IDC_COMBO_OUTER_FEC             244
#define IDC_COMBO_OUTER_FEC_RATE        245
#define IDC_LIST_TUNING_SPACES          246
#define IDC_BUTTON_SUBMIT_TUNING_SPACE  247
#define IDC_COMBO_OUTER_SIGNAL_POLARISATION 248
#define IDC_EDIT_MODULATION             251
#define IDC_BUTTON_NEW_TUNING_SPACE     252
#define IDC_EDIT_MINMINOR_CHANNEL       253
#define IDC_SPIN_MINMINOR_CHANNEL       254
#define IDC_EDIT_HIGH_OSCILLATOR        255
#define IDC_SPIN_HIGH_OSCILLATOR        256
#define IDC_EDIT_LNBSwitch              257
#define IDC_SPIN_LNBSwitch              258
#define IDC_EDIT_INPUT_RANGE            259
#define IDC_SPIN_INPUT_RANGE            260
#define IDC_EDIT_COUNTRY_CODE           261
#define IDC_COMBOINPUT_TYPE             262
#define IDC_EDIT_FREQUENCY_MAPPING      263
#define IDC_EDIT_NETWORKID              264
#define IDC_EDIT_LOW_OSCILATOR          265
#define IDC_EDITSPECTRAL_INVERSION      266
#define IDC_SPIN_SPECTRAL_INVERSION     267
#define IDC_SPIN_LOW_OSCILATOR          268
#define IDC_SPIN_NETWORKID              269
#define IDC_EDIT_AZIMUTH                270
#define IDC_SPIN_AZIMUTH                271
#define IDC_EDIT_ELEVATION              272
#define IDC_SPIN_ELEVATION              273
#define IDC_EDIT_ORBITAL_POSITION       274
#define IDC_SPIN_ORBITAL_POSITION       275
#define IDC_CHECK_WEST_POSITION         276
#define IDC_COMBO_SPECTRAL_INVERSION    277
#define IDC_SPIN_ONID                   279
#define IDC_SPIN_SID                    281
#define IDC_BUTTON_REST_TO_DEFAULT_LOCATOR 282

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         283
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\treewin.h ===
// TreeWindow.h: interface for the CTreeWindow class.
// implements the subclassed tree control for the common prop page
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TREEWINDOW_H__5AAE4BD7_4DA7_4064_88BB_8C7FDF9A1464__INCLUDED_)
#define AFX_TREEWINDOW_H__5AAE4BD7_4DA7_4064_88BB_8C7FDF9A1464__INCLUDED_

#include "resource.h"       // main symbols
#include "misccell.h"

using namespace std;
class CNP_CommonPage;

class CTreeWin : 
	public CWindowImpl<CTreeWin>
{
public:
	CTreeWin(
		CNP_CommonPage* pParent
		);
	virtual ~CTreeWin();

private:
	//typedef	CAdapt <CComPtr <ILocator> >	PAdaptILocator;
	//typedef	CAdapt <CComPtr <ITuningSpace> >	PAdaptITuningSpace;
	typedef map <ITuningSpace*, ILocator*>	TREE_MAP;
	typedef	enum 
	{
		CarrierFrequency,
		InnerFEC,
		InnerFECRate,
		Modulation,
		OuterFEC,
		OuterFECRate,
		SymbolRate,
		UniqueName,
		FriendlyName,
		TunSpace_CLSID,
		FrequencyMapping
	}TreeParams;	//all possible param values for the Tree leafs
	
	TREE_MAP		m_treeMap;	//list used for the tree
	CNP_CommonPage*	m_pCommonPage;
	CBDAMiscellaneous m_misc;

	void
	CleanMapList ();//release all tree interface pointers	

	//the message map for the sublassed tree control
	BEGIN_MSG_MAP(CTreeWin)
		//we would like to do smtg like that
		//NOTIFY_HANDLER(IDC_TREE_TUNING_SPACES, NM_CLICK, OnClickTree_tuning_spaces)
		//but it seems ATL is not reflecting same WM_NOTIFY MESSAGE
		MESSAGE_HANDLER(OCM__BASE+WM_NOTIFY, ON_REFLECT_WM_NOTIFY)	
		DEFAULT_REFLECTION_HANDLER ()
	END_MSG_MAP()

	LRESULT OnClickTree_tuning_spaces(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		return 0;
	}
	LRESULT OnItemexpandedTree_tuning_spaces(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		return 0;
	}

	LRESULT ON_REFLECT_WM_NOTIFY(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		if (lParam == NM_CLICK )
			return 0;
		LPNMHDR lpnmh = (LPNMHDR) lParam; 
		switch (lpnmh->code)
		{
		case TVN_ITEMEXPANDED:
			return OnItemexpandedTree_tuning_spaces (
				IDC_TREE_TUNING_SPACES, 
				lpnmh, 
				bHandled
				);
		case NM_CLICK:
			return OnClickTree_tuning_spaces (
				IDC_TREE_TUNING_SPACES, 
				lpnmh, 
				bHandled
				);
		}
		return 0;
	}

	HTREEITEM
	InsertLocator (
		HTREEITEM	hParentItem, 
		ILocator*	pLocator
		);

	HTREEITEM
	InsertTuningSpace (
		ITuningSpace*	pTunSpace,
		TCHAR*	szCaption = _T("")
		);

	HTREEITEM
	InsertTreeItem (
		HTREEITEM	hParentItem	,
		LONG		lParam,
		TCHAR*		pszText,
		bool		bBold = false
	);

public:
	//============================================================
	//	It's refreshing the tree with the new TunningSpace info
	//	from the NP.
	//
	//============================================================
	HRESULT	
	RefreshTree (
		IScanningTuner*	pTuner
		);

	//============================================================
	//	Will set the current tuning space locator to the NP
	//	
	//
	//============================================================
	HRESULT
	SubmitCurrentLocator ();
};

#endif // !defined(AFX_TREEWINDOW_H__5AAE4BD7_4DA7_4064_88BB_8C7FDF9A1464__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__441F7B28_4315_4EB4_AFB9_F461CB8AD90D__INCLUDED_)
#define AFX_STDAFX_H__441F7B28_4315_4EB4_AFB9_F461CB8AD90D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
//#ifndef _WIN32_WINNT
//#define _WIN32_WINNT 0x0400
//#endif
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <mmsystem.h>

//#include <debug.h>
//#include "shell.h"

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
//#include <list.h>
#include <setupapi.h>
#include <wtypes.h>  

// KS
//#include <ks.h>
//#include <ksmedia.h>

#include <tuner.h>
#include <tune.h>
#include <BdaTypes.h>
#include <BdaMedia.h>
//#include <NewMedia.h>
#include <BdaIface.h>

#define MESSAGEBOX(wnd, ID) \
        {\
            TCHAR szPath[MAX_PATH];\
            if (0 != LoadString (_Module.GetModuleInstance (), ID, szPath, MAX_PATH))\
            {\
                TCHAR szCaption[MAX_PATH];\
                if (NULL != LoadString (_Module.GetModuleInstance (), IDS_ERROR_CAPTION, szCaption, MAX_PATH))\
                {\
                    ::MessageBox (wnd->m_hWnd, szPath, szCaption, MB_OK);\
                }\
            }\
        }

#define MESSAGEBOX_ERROR(wnd, ID) \
        {\
            TCHAR szPath[MAX_PATH];\
            if (0 != LoadString (_Module.GetModuleInstance (), ID, szPath, MAX_PATH))\
            {\
                TCHAR szCaption[MAX_PATH];\
                if (NULL != LoadString (_Module.GetModuleInstance (), IDS_ERROR_CAPTION, szCaption, MAX_PATH))\
                {\
                    ::MessageBox (wnd->m_hWnd, szPath, szCaption, MB_OK|MB_ICONSTOP);\
                }\
            }\
        }
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__441F7B28_4315_4EB4_AFB9_F461CB8AD90D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\np_commonpage.h ===
// NP_CommonPage.h : Declaration of the CNP_CommonPage

#ifndef __NP_COMMONPAGE_H_
#define __NP_COMMONPAGE_H_

#include "resource.h"       // main symbols
#include "misccell.h"
#include "TreeWin.h"
#include "LastErrorWin.h"

//BUG: C4003: resolution
#undef SubclassWindow 

EXTERN_C const CLSID CLSID_NP_CommonPage;

/////////////////////////////////////////////////////////////////////////////
// CNP_CommonPage
class ATL_NO_VTABLE CNP_CommonPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNP_CommonPage, &CLSID_NP_CommonPage>,
	public IPropertyPageImpl<CNP_CommonPage>,
	public CDialogImpl<CNP_CommonPage>,
    public IBroadcastEvent
{
public:
	CNP_CommonPage():
		m_treeWinControl(this)
	{
		m_dwTitleID = IDS_TITLENP_CommonPage;
		m_dwHelpFileID = IDS_HELPFILENP_CommonPage;
		m_dwDocStringID = IDS_DOCSTRINGNP_CommonPage;
	}

	enum {IDD = IDD_NP_COMMONPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_NP_COMMONPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNP_CommonPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
END_COM_MAP()

BEGIN_MSG_MAP(CNP_CommonPage)
	CHAIN_MSG_MAP(IPropertyPageImpl<CNP_CommonPage>)
	COMMAND_HANDLER(IDC_BUTTON_SEEK_UP, BN_CLICKED, OnClickedButton_seek_up)
	COMMAND_HANDLER(IDC_BUTTON_SEEK_DOWN, BN_CLICKED, OnClickedButton_seek_down)
	COMMAND_HANDLER(IDC_BUTTON_AUTO_PROGRAM, BN_CLICKED, OnClickedButton_auto_program)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	//MESSAGE_HANDLER(m_NotifyMessage, OnDShowNotify)
	COMMAND_HANDLER(IDC_BUTTON_SCAN_DOWN, BN_CLICKED, OnClickedButton_scan_down)
	COMMAND_HANDLER(IDC_BUTTON_SCAN_UP, BN_CLICKED, OnClickedButton_scan_up)
	COMMAND_HANDLER(IDC_BUTTON_SUBMIT_LOCATOR, BN_CLICKED, OnClickedButton_submit_locator)
	REFLECT_NOTIFICATIONS ()
END_MSG_MAP()
// Handler prototypes:
    
    typedef IPropertyPageImpl<CNP_CommonPage> PPGBaseClass;

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown** ppUnk)
	{
		// Use SetObjects to perform basic sanity checks on the objects whose properties will be set

		// This page can only handle a single object
		// and that object must support the IBDA_NetworkProvider interface.
		// We return E_INVALIDARG in any other situation

		HRESULT hr = E_INVALIDARG;
		if (nObjects == 1)								// Single object
		{
			CComQIPtr<IBDA_NetworkProvider> pNP(ppUnk[0]);	// Must support IBDA_NetworkProvider
			if (pNP)
				hr = PPGBaseClass::SetObjects(nObjects, ppUnk);
		}
		return hr;
	}
			
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT prc, BOOL bModal)
	{
		// If we don't have any objects, this method should not be called
		// Note that OleCreatePropertyFrame will call Activate even if a call to SetObjects fails, so this check is required
		if (!m_ppUnk)
			return E_UNEXPECTED;

		// Use Activate to update the property page's UI with information
		// obtained from the objects in the m_ppUnk array

		// We update the page to display the Name and ReadOnly properties of the document

		// Call the base class
		HRESULT hr = PPGBaseClass::Activate(hWndParent, prc, bModal);

        if (!m_ppUnk[0])
            return E_UNEXPECTED;

        //if already advised, unadvise
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            if (pConPoint)
                pConPoint->Unadvise (m_dwEventCookie);
            m_pBroadcastEventService.Release ();
        }

        IBroadcastEvent* pEvent = NULL;
        //register for events
        hr = CBDAMiscellaneous::RegisterForEvents (
            m_ppUnk[0], 
            static_cast<IBroadcastEvent*>(this),
            &pEvent, 
            m_dwEventCookie
            );
        if (SUCCEEDED (hr))
            m_pBroadcastEventService.Attach (pEvent);

		m_pTuner = m_ppUnk[0];
        if (!m_pTuner)
            return E_FAIL;
				
		//make sure the tree is initialized
		RefreshFromNP ();
		RefreshControls ();
		return S_OK;
	}
    
    STDMETHOD(Apply)(void)
	{
		//ATLTRACE(_T("CNP_CommonPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
		}
		m_bDirty = FALSE;
		return S_OK;
	}

	void SendError (
		TCHAR*	szMessage,
		HRESULT	hrErrorCode
		)
	{
		TCHAR	szText[MAX_PATH];
		m_lastHRESULT = hrErrorCode;
		wsprintf (szText, _T("%ld - When...%s"), m_lastHRESULT, szMessage);
		SetDlgItemText (IDC_STATIC_HRESULT, szText);
		//now flash the graphedit window so, 
		//the user will notice he's in trouble
        //we used to flash the window so the user will notice that smtg is wrong
        //but it turned out that the user is actually confused with this
		/*FLASHWINFO flashInfo;
		flashInfo.cbSize = sizeof (FLASHWINFO);
		flashInfo.hwnd = ::GetParent (::GetParent (::GetParent(m_hWnd)));
		flashInfo.dwFlags = FLASHW_ALL;
		flashInfo.uCount = 3;//3 times
		flashInfo.dwTimeout = 500;//half of second
		FlashWindowEx (&flashInfo);*/
	}

	HRESULT
	PutTuningSpace (
		ITuningSpace* pTuneSpace
		)
	{
		ASSERT (m_pTuner);
		return m_pTuner->put_TuningSpace (pTuneSpace);
	}
	
private:
	
	//======================================================================
	//	Will query the NP filter and set all controls according to its props
	//	
	//
	//======================================================================
	HRESULT	RefreshFromNP ()
	{
		if (!m_pTuner)
			return E_FAIL;

		return m_treeWinControl.RefreshTree (m_pTuner);
	}

	void RefreshControls ()
	{
		//now set all controls according to what found
		TCHAR	szText[MAX_PATH];
		HRESULT hr = m_pTuner->get_SignalStrength (&m_lSignalStrength);
		if (FAILED (hr))
		{
			//We got an error 
			SendError (_T("Calling IScanningTuner::get_SignalStrength"), hr);
			//BUGBUG - add a special case for error
			return;
		}
		wsprintf (szText, _T("%ld"), m_lSignalStrength);
		SetDlgItemText (IDC_STATIC_SIGNAL_STRENGTH, szText);
		SendError (_T(""), m_lastHRESULT);
	}
	//
private:
	//member variables
	//couple interfaces we need from NP
	CComQIPtr <IScanningTuner>			m_pTuner;
	CComQIPtr <IMediaEventEx>			m_pEventInterface;
    CComPtr   <IBroadcastEvent>         m_pBroadcastEventService;
    DWORD                               m_dwEventCookie;
    static UINT m_NotifyMessage;

	CTreeWin		m_treeWinControl;
	CLastErrorWin	m_lastErrorControl;
	HRESULT			m_lastHRESULT;
	LONG			m_lSignalStrength;

	HWND GetSafeTreeHWND ();
	HWND GetSafeLastErrorHWND ();

	LRESULT OnClickedButton_seek_up(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (!m_pTuner)
			return E_FAIL;
		m_pTuner->SeekUp ();
		return 0;
	}
	LRESULT OnClickedButton_seek_down(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (!m_pTuner)
			return E_FAIL;
		m_pTuner->SeekDown ();
		return 0;
	}
	LRESULT OnClickedButton_auto_program(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		if (!m_pTuner)
			return E_FAIL;
		m_pTuner->AutoProgram ();
		return 0;
	}
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		m_treeWinControl.SubclassWindow (GetSafeTreeHWND ());
		m_lastErrorControl.SubclassWindow (GetSafeLastErrorHWND ());
		//RefreshControls ();
		return 0;
	}

	//received notifications from Network Provider
	LRESULT OnDShowNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		RefreshFromNP ();
		RefreshControls ();
		return 0;
	}
	
	LRESULT OnClickedButton_scan_down(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		//scan for 1000 miliseconds
		m_pTuner->ScanDown (1000);
		return 0;
	}
	LRESULT OnClickedButton_scan_up(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		//scan for 1000 miliseconds
		m_pTuner->ScanUp (1000);
		return 0;
	}
	LRESULT OnClickedButton_submit_locator(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		m_treeWinControl.SubmitCurrentLocator ();
		return 0;
	}

    STDMETHOD(Fire)(GUID EventID)
    {
#ifdef DEBUG
        TCHAR szInfo[MAX_PATH];
        CComBSTR bstrEventID;
        USES_CONVERSION;
        StringFromCLSID (EventID, &bstrEventID);
        wsprintf (szInfo, _T("Notification received for %s"), OLE2T (bstrEventID));
        ATLTRACE (szInfo);
#endif
        if (EventID == EVENTID_SignalStatusChanged)
        {
            ATLTRACE ("Starting to refresh");
            RefreshControls ();
        }
        return S_OK;
    }

    virtual void OnFinalMessage( HWND hWnd )
    {
        if (m_pBroadcastEventService)
        {
            CComQIPtr <IConnectionPoint> pConPoint(m_pBroadcastEventService);
            pConPoint->Unadvise (m_dwEventCookie);
        }
    }
};

#endif //__NP_COMMONPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\msdvbnp\treewin.cpp ===
// TreeWindow.cpp: implementation of the CTreeWindow class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TreeWin.h"
#include "NP_CommonPage.h"
#include "misccell.h"
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTreeWin::CTreeWin(
			CNP_CommonPage* pParent
			)
{
	m_pCommonPage = pParent;
}

CTreeWin::~CTreeWin()
{
	CleanMapList ();
}

void
CTreeWin::CleanMapList ()
{
	//first make sure we free the existing list
	TREE_MAP::iterator	treeIt = m_treeMap.begin ();
	while (treeIt != m_treeMap.end ())
	{
		if ((*treeIt).first)
			(*treeIt).first->Release ();
		if ((*treeIt).second)
			(*treeIt).second->Release ();
		m_treeMap.erase (treeIt);
		treeIt = m_treeMap.begin ();
	}
}

HRESULT	
CTreeWin::RefreshTree (
	IScanningTuner*	pTuner
	)
{
	HRESULT hr = S_OK;
	USES_CONVERSION;

	if (!m_hWnd)
		return NULL;

	//first make sure we free the existing list
	CleanMapList ();
	//delete all previous items
	TreeView_DeleteAllItems (m_hWnd);
	
	//insert the default TuningSpace
    ITuningSpace*	pTunningSpace;
	CComPtr <ITuneRequest>	pTuneRequest;
	hr = pTuner->get_TuneRequest (&pTuneRequest);
	if (pTuneRequest)
	{
	    pTuneRequest->get_TuningSpace (&pTunningSpace);
	    HTREEITEM hLocatorParent = InsertTuningSpace (
									    pTunningSpace, 
									    _T ("Current TuneRequest")
									    );
	    TreeView_SelectItem (m_hWnd, hLocatorParent);

	    if (hLocatorParent == NULL)
	    {
		    pTunningSpace->Release ();
		    pTunningSpace = NULL;
	    }
        //now let's fill with the ILocator info
        //add to the list
        ILocator* pLocator = NULL;
        hr = pTuneRequest->get_Locator (&pLocator);
        InsertLocator (hLocatorParent, pLocator);
        //add to the maplist
        m_treeMap.insert (TREE_MAP::value_type (pTunningSpace, pLocator));
    }

	//fill the tree with all TunningSpaces this NP knows about them
	CComPtr <IEnumTuningSpaces> pEnumTunningSpaces;
	hr = pTuner->EnumTuningSpaces (&pEnumTunningSpaces);
	if (FAILED (hr) || (!pEnumTunningSpaces))
		return hr;
	while (pEnumTunningSpaces->Next (1, &pTunningSpace, 0) == S_OK)
	{
		HTREEITEM hLocatorParent = InsertTuningSpace (pTunningSpace);
		if (hLocatorParent == NULL)
		{
			pTunningSpace->Release ();
			pTunningSpace = NULL;
			continue;
		}

		//now let's fill with the ILocator info
		//add to the list
		ILocator* pLocator = NULL;
		hr = pTunningSpace->get_DefaultLocator (&pLocator);
		if (FAILED (hr) || (!pLocator))
		{
			pTunningSpace->Release ();
			pTunningSpace = NULL;
			continue;
		}
		InsertLocator (hLocatorParent, pLocator);

		//add to the maplist
		m_treeMap.insert (TREE_MAP::value_type (pTunningSpace, pLocator));
	}
	

	
	return hr;
}

HTREEITEM
CTreeWin::InsertTuningSpace (
	ITuningSpace*	pTunSpace,
	TCHAR*	szCaption
	)
{
	HRESULT	hr = S_OK;
	USES_CONVERSION;
	TCHAR	szText[MAX_PATH];

	CComBSTR	friendlyName;
	hr = pTunSpace->get_FriendlyName (&friendlyName);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_FriendlyName"), hr);
		return NULL;
	}
	bool bBold = false;
	//make sure we write the caption if there is one
	if (_tcslen (szCaption) > 0)
	{
		wsprintf (szText, _T("%s-%s"), szCaption, W2T (friendlyName));
		bBold = true;
	}
	else
	{
		_tcscpy (szText, W2T (friendlyName));
	}
	HTREEITEM hParentItem = InsertTreeItem (
		NULL, 
		reinterpret_cast <DWORD_PTR> (pTunSpace), 
		szText,
		bBold
		);
	//for all the outers add the TreeParams params

	//uniqueName
	CComBSTR	uniqueName;
	hr = pTunSpace->get_UniqueName (&uniqueName);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_UniqueName"), hr);
		return NULL;
	}
	wsprintf (szText, _T("Unique Name - %s"), W2T(uniqueName));
	HTREEITEM hItem = InsertTreeItem (
		hParentItem, 
		UniqueName, 
		szText
		);
	//frequencyMapping
	CComBSTR	frequencyMapping;
	hr = pTunSpace->get_FrequencyMapping (&frequencyMapping);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_FrequencyMapping"), hr);
		return NULL;
	}
	wsprintf (szText, _T("Frequency Mapping - %s"), W2T(frequencyMapping));
	hItem = InsertTreeItem (
		hParentItem, 
		FrequencyMapping, 
		szText
		);
	//TunCLSID
	CComBSTR	TunCLSID;
	hr = pTunSpace->get_CLSID (&TunCLSID);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_CLSID"), hr);
		return NULL;
	}
	wsprintf (szText, _T("CLSID - %s"), W2T(TunCLSID));
	hItem = InsertTreeItem (
		hParentItem, 
		TunSpace_CLSID, 
		szText
		);

	//finally insert the locator parent
	ILocator* pLocator = NULL;
	hr = pTunSpace->get_DefaultLocator (&pLocator);
	if (FAILED (hr) || (!pLocator))
	{
		//first delete the tunning space item
		TreeView_DeleteItem (m_hWnd, hParentItem);
		m_pCommonPage->SendError (_T("Calling ITuningSpace::get_DefaultLocator"), hr);
		return NULL;
	}

	hItem = InsertTreeItem (
		hParentItem, 
		reinterpret_cast <DWORD_PTR> (pLocator),
		_T("Locator")
		);

	return hItem;
}

//==================================================================
//	Will insert in the tree all information for the passed ILocator
//	
//
//==================================================================
HTREEITEM	
CTreeWin::InsertLocator (
	HTREEITEM	hParentItem, 
	ILocator*	pLocator
	)
{
	USES_CONVERSION;
	HRESULT	hr = S_OK;
	TCHAR	szText[MAX_PATH];

	LONG	lFrequency;
	hr = pLocator->get_CarrierFrequency (&lFrequency);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_CarrierFrequency"), hr);
		return NULL;
	}
	wsprintf (szText, _T("Frequency - %ld"), lFrequency);
	HTREEITEM hItem = InsertTreeItem (
		hParentItem, 
		CarrierFrequency, 
		szText
		);

	FECMethod	fecMethod;
	hr = pLocator->get_InnerFEC (&fecMethod);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_InnerFEC"), hr);
		return NULL;
	}
	CComBSTR bstrTemp = m_misc.ConvertFECMethodToString (fecMethod);
	wsprintf (szText, _T("InnerFEC - %s"), W2T (bstrTemp));

	hItem = InsertTreeItem (
		hParentItem, 
		InnerFEC, 
		szText
		);

	BinaryConvolutionCodeRate	binaryConvolutionCodeRate;
	hr = pLocator->get_InnerFECRate (&binaryConvolutionCodeRate);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_InnerFECRate"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertInnerFECRateToString (binaryConvolutionCodeRate);
	wsprintf (szText, _T("InnerFECRate - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		InnerFECRate, 
		szText
		);

	ModulationType	modulationType;
	hr = pLocator->get_Modulation (&modulationType);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_Modulation"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertModulationToString (modulationType);
	wsprintf (szText, _T("Modulation - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		Modulation, 
		szText
		);

	hr = pLocator->get_OuterFEC (&fecMethod);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_OuterFEC"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertFECMethodToString (fecMethod);
	wsprintf (szText, _T("OuterFEC - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		OuterFEC, 
		szText
		);
	
	hr = pLocator->get_OuterFECRate (&binaryConvolutionCodeRate);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_OuterFECRate"), hr);
		return NULL;
	}
	bstrTemp = m_misc.ConvertInnerFECRateToString (binaryConvolutionCodeRate);
	wsprintf (szText, _T("OuterFECRate - %s"), W2T (bstrTemp));
	hItem = InsertTreeItem (
		hParentItem, 
		OuterFECRate, 
		szText
		);
	
	LONG	lRate;
	hr = pLocator->get_SymbolRate (&lRate);
	if (FAILED (hr))
	{
		m_pCommonPage->SendError (_T("Calling ILocator::get_SymbolRate"), hr);
		return NULL;
	}
	wsprintf (szText, _T("SymbolRate - %ld"), lRate);
	hItem = InsertTreeItem (
		hParentItem, 
		SymbolRate, 
		szText
		);

	return hItem;
}

//================================================
// Helper method to the tree helper macro...
// This will just insert an item in the tree
//================================================
HTREEITEM
CTreeWin::InsertTreeItem (
	HTREEITEM	hParentItem	,
	LONG		lParam,
	TCHAR*		pszText,
	bool		bBold /*= false*/
)
{
	if (!m_hWnd)
		return NULL;
	HTREEITEM hItem = NULL;

	TVINSERTSTRUCT tviInsert;
	tviInsert.hParent = hParentItem;
	tviInsert.hInsertAfter = TVI_LAST;

	TVITEM	tvItem;
	tvItem.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_TEXT;
	if (bBold)
	{
		tvItem.mask |= TVIF_STATE;
		tvItem.state = TVIS_BOLD | TVIS_EXPANDED;
		tvItem.stateMask = TVIS_BOLD;
	}
	tvItem.hItem = NULL;
	tvItem.lParam = lParam;

	tvItem.pszText = pszText;
	tvItem.cchTextMax = _tcslen (pszText);

	tviInsert.item = tvItem;
	hItem = TreeView_InsertItem (m_hWnd, &tviInsert);
	return hItem;
}


HRESULT
CTreeWin::SubmitCurrentLocator ()
{
	ASSERT (m_hWnd);
	HTREEITEM hItem = TreeView_GetSelection (m_hWnd);
	ASSERT (hItem);
	HRESULT hr = S_OK;
	//this state is merely impossible
	if (hItem == NULL)
		return E_FAIL;
	HTREEITEM hRoot = hItem;
	HTREEITEM hParent = hRoot;
	TVITEM	tvItem;
	tvItem.mask = TVIF_PARAM;
	tvItem.lParam = NULL; 
	//just get the parent
	while ( (hRoot = TreeView_GetParent (m_hWnd, hRoot)) != NULL)
	{
		//keep the last parent alive so we can query later
		hParent = hRoot;
	}

	tvItem.hItem = hParent;
	if (!TreeView_GetItem (m_hWnd, &tvItem))
	{
		ASSERT (FALSE);
		return E_FAIL;
	}
	//normally this cast should not be done between different apartments
	//It's ok with DShow apartment model
	ITuningSpace* pTuneSpace = reinterpret_cast <ITuningSpace*> (tvItem.lParam);
	ASSERT (pTuneSpace);
	//TREE_MAP::iterator it = m_treeMap.find (pTuneSpace);
	//ILocator* pLocator = (*it).second;
	if (FAILED (hr = m_pCommonPage->PutTuningSpace (pTuneSpace)))
	{
		m_pCommonPage->SendError (_T("Calling IScaningTuner::put_TuningSpace"), hr);
		return hr;
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\atlproppage.cpp ===
// msdvbnp.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f NPPropPageps.mk in the project directory.

#include "..\msdvbnp\stdafx.h"
#include "..\msdvbnp\resource.h"
#include <initguid.h>
#include "..\msdvbnp\NPPropPage.h"

#include "..\msdvbnp\NPPropPage_i.c"
#include "..\msdvbnp\NP_CommonPage.h"
#include "..\msdvbnp\ATSCPropPage.h"
#include "..\msdvbnp\DVBSTuningSpaces.h"
#include "..\msdvbnp\DVBSTuneRequestPage.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NP_CommonPage, CNP_CommonPage)
OBJECT_ENTRY(CLSID_ATSCPropPage, CATSCPropPage)
OBJECT_ENTRY(CLSID_DVBSTuningSpaces, CDVBSTuningSpaces)
OBJECT_ENTRY(CLSID_DVBSTuneRequestPage, CDVBSTuneRequestPage)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

extern "C" 
STDAPI DllCanUnload();

extern "C" 
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {

    case DLL_PROCESS_ATTACH:
        _Module.Init(ObjectMap, hInstance);
        break;

    case DLL_PROCESS_DETACH:
        _Module.Term();
        break;
    }

    return DllEntryPoint(hInstance, dwReason, lpReserved);
}



/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI PPDllCanUnloadNow(void)
{
    HRESULT hr = DllCanUnloadNow();

    if (hr == S_OK) {
        if (_Module.GetLockCount() != 0) {
            hr = S_FALSE;
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI PPDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    hr = DllGetClassObject(rclsid, riid, ppv);
    if (SUCCEEDED(hr))
        return hr;

    return _Module.GetClassObject(rclsid, riid, ppv);
}

STDAPI DllRegisterServer(void)

{ // DllRegisterServer //
    _Module.RegisterServer(TRUE);
  return AMovieDllRegisterServer2(TRUE);

} // DllRegisterServer //

STDAPI DllUnregisterServer(void)
{ // DllUnRegisterServer //

    _Module.UnregisterServer(TRUE);
  return AMovieDllRegisterServer2(FALSE);

} // DllUnRegisterServer //
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\proppage.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// Proppage.cpp
//
// Provides two support property pages for GraphEdt
// File & MediaType

//
// !!! TODO move strings in CFileProperties into *.rc file
//
#include <streams.h>
#include <windowsx.h>
#include <initguid.h>
#include <olectl.h>
#include <memory.h>

#include <string.h>
#include <stdio.h>
#include <tchar.h>
#include <wchar.h>

#include "resource.h"
#include "propguid.h"
#include "texttype.h"
#include "proppage.h"

//
// other property pages we will be including
//

//  VMR
#include "..\vmrprop\vmrprop.h"

//  mpg2splt proppages
#include "..\mp2demux\mp2prop.h"

// *
// * CMediaTypeProperties
// *

// provides a standard property page that
// a pin can support to display its media type

// COM global table of objects in this dll
CFactoryTemplate g_Templates[] = {

    {L"GraphEdt property sheets", &CLSID_MediaTypePropertyPage, CMediaTypeProperties::CreateInstance, NULL, NULL},
    {L"GraphEdt property sheets", &CLSID_FileSourcePropertyPage, CFileSourceProperties::CreateInstance, NULL, NULL},
    {L"GraphEdt property sheets", &CLSID_FileSinkPropertyPage, CFileSinkProperties::CreateInstance, NULL, NULL},
    {L"VMR property sheet", &CLSID_VMRFilterConfigProp, CVMRFilterConfigProp::CreateInstance, NULL, NULL},
    {L"Mpeg2splt Output Pins Sheet", & CLSID_MPEG2DemuxPropOutputPins, CMPEG2PropOutputPins::CreateInstance, NULL, NULL},
    {L"Mpeg2splt PID Map Sheet", & CLSID_MPEG2DemuxPropPIDMap, CMPEG2PropPIDMap::CreateInstance, NULL, NULL},
    {L"Mpeg2splt stream_id Map Sheet", & CLSID_MPEG2DemuxPropStreamIdMap, CMPEG2PropStreamIdMap::CreateInstance, NULL, NULL},
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
//  CreateInstance
//
//  The DShow way to create instances.  Look at ATLPropPage.cpp to see how
//  to add ATL property pages.
//
CUnknown *CMediaTypeProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMediaTypeProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//
// CMediaTypeProperties::Constructor
//
CMediaTypeProperties::CMediaTypeProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("Media Type Property Page"), lpunk)
    , m_pPin(NULL)
    , m_fUnconnected(FALSE)
    , m_hwnd(NULL) {

}


//
// CMediaTypeProperties::Destructor
//
CMediaTypeProperties::~CMediaTypeProperties(void)
{
    //
    // OleCreatePropertyFrame bug:
    //   - Final SetObjects(NULL) is missing. Might have to release
    //     interfaces at this point.
    //
    ASSERT( m_pPin == NULL );

    /*    if (m_pPin)
    m_pPin->Release();

    m_pPin = NULL; */
}

//
// NonDelegatingQueryInterface
//
// Reveal our property page
STDMETHODIMP CMediaTypeProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (riid == IID_IPropertyPage) {
    return GetInterface((IPropertyPage *) this, ppv);
    } else {
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// SetPageSite
//
// called with null as the page shuts down. therefore release the pin
// here.
STDMETHODIMP CMediaTypeProperties::SetPageSite(LPPROPERTYPAGESITE pPageSite) {

    if( !pPageSite && m_pPin ){
        m_pPin->Release();
        m_pPin = NULL;
    }

    return NOERROR;
}


//
// GetPageInfo
//
// set the page info so that the page site can size itself, etc
STDMETHODIMP CMediaTypeProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo) {

    PIN_INFO pi;

    if (m_pPin) {
    m_pPin->QueryPinInfo(&pi);
    QueryPinInfoReleaseFilter(pi);
    }
    else {
    wcscpy(pi.achName, L"Connection Format");
    }

    LPOLESTR pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(pi.achName));
    memcpy(pszTitle, &pi.achName, sizeof(pi.achName));

    pPageInfo->cb               = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle         = pszTitle;

    // set default size values if GetDialogSize fails
    pPageInfo->size.cx = 340;
    pPageInfo->size.cy = 150;
    GetDialogSize( IDD_TYPEPROP, DialogProc, 0L, &pPageInfo->size);

    pPageInfo->pszDocString     = NULL;
    pPageInfo->pszHelpFile      = NULL;
    pPageInfo->dwHelpContext    = 0;

    return NOERROR;

}


//
// DialogProc
//
// Handles the messages for our property window
INT_PTR CALLBACK CMediaTypeProperties::DialogProc( HWND hwnd
                     , UINT uMsg
                     , WPARAM wParam
                     , LPARAM lParam) {

    static CMediaTypeProperties *pThis = NULL;

    // While we try to find the size of our property page
    // this window proc is called with pThis == NULL! Don't
    // do anything in that case.

    switch (uMsg) {
    case WM_INITDIALOG:

    pThis = (CMediaTypeProperties *) lParam;

    if (!pThis)
        return TRUE;


    CreateWindow( TEXT("STATIC")
            , pThis->m_szBuff
            , WS_CHILD | WS_VISIBLE
            , 0, 0
            , 300, 200
            , hwnd
            , NULL
            , g_hInst
            , NULL
            );

    if (pThis->m_fUnconnected) {
        pThis->CreateEditCtrl(hwnd);
        pThis->FillEditCtrl();
    }

    return TRUE;    // I don't call setfocus...

    default:
    return FALSE;

    }
}

//
// CreateEditCtrl
//
// Creates a list box which lists all prefered media types of the pin
//
void CMediaTypeProperties::CreateEditCtrl(HWND hwnd)
{
    m_EditCtrl = CreateWindow( TEXT("EDIT"), NULL,
                  ,WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL
                  | WS_BORDER | ES_LEFT | ES_AUTOHSCROLL | ES_MULTILINE
                  | ES_AUTOVSCROLL | ES_READONLY
                  , 10, 20, 330, 180, hwnd, NULL, g_hInst, NULL);
}

//
// FillEditCtrl
//
// Enumerates all prefered media types of the pin and adds them to the
// list box.
//
void CMediaTypeProperties::FillEditCtrl()
{
    IEnumMediaTypes * pMTEnum;
    AM_MEDIA_TYPE * pMediaType;
    ULONG count;
    ULONG number = 0;
    TCHAR szBuffer[400];
    TCHAR szEditBuffer[2000];
    ULONG iRemainingLength = 2000;

    HRESULT hr = m_pPin->EnumMediaTypes(&pMTEnum);
    szEditBuffer[0] = TEXT('\0');

    if (SUCCEEDED(hr)) {
    ASSERT(pMTEnum);
    pMTEnum->Next(1, &pMediaType, &count);
    while (count == 1) {
        CTextMediaType(*pMediaType).AsText(szBuffer, NUMELMS(szBuffer), TEXT(" - "), TEXT(" - "), TEXT("\r\n"));

        DeleteMediaType(pMediaType);

        _tcsncat(szEditBuffer, szBuffer, iRemainingLength);
        iRemainingLength = 2000 - _tcslen(szEditBuffer);

        if (iRemainingLength <= 20)
        break;
    
        number++;
        pMTEnum->Next(1, &pMediaType, &count);
    }
    pMTEnum->Release();
    }

    // no prefered media types
    if (number == 0) {
    LoadString(g_hInst, IDS_NOTYPE, szEditBuffer, iRemainingLength);
    }
    SetWindowText(m_EditCtrl, szEditBuffer);
}


//
// Activate
//
// Create the window we will use to edit properties
STDMETHODIMP CMediaTypeProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal) {

    ASSERT(!m_hwnd);

    m_hwnd = CreateDialogParam( g_hInst
             , MAKEINTRESOURCE(IDD_TYPEPROP)
             , hwndParent
             , DialogProc
             , (LPARAM) this
             );

    if (m_hwnd == NULL) {
    DWORD dwErr = GetLastError();
    DbgLog((LOG_ERROR, 1, TEXT("Could not create window: 0x%x"), dwErr));
    return E_FAIL;
    }

    Move(prect);
    ShowWindow( m_hwnd, SW_SHOWNORMAL );

    return NOERROR;
}


//
// Show
//
// Display the property dialog
STDMETHODIMP CMediaTypeProperties::Show(UINT nCmdShow) {

    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    if (!((nCmdShow == SW_SHOW) || (nCmdShow == SW_SHOWNORMAL) || (nCmdShow == SW_HIDE))) {
    return( E_INVALIDARG);
    }

    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);

    return NOERROR;
}


//
// Deactivate
//
// Destroy the dialog
STDMETHODIMP CMediaTypeProperties::Deactivate(void) {
    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    if (DestroyWindow(m_hwnd)) {
    m_hwnd = NULL;
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}

//
// Move
//
// put the property page over its home in the parent frame.
STDMETHODIMP CMediaTypeProperties::Move(LPCRECT prect) {

    if (m_hwnd == NULL) {
    return( E_UNEXPECTED );
    }

    if (MoveWindow( m_hwnd
          , prect->left
          , prect->top
          , prect->right - prect->left
          , prect->bottom - prect->top
          , TRUE                // send WM_PAINT
          ) ) {
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}


//
// SetObjects
//
// Sets the object(s) we are browsing. Confirm they are pins and query them
// for their media type, if connected
STDMETHODIMP CMediaTypeProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) {

    if (cObjects == 1) {
    ASSERT(!m_pPin);

    if ((ppunk == NULL) || (*ppunk == NULL)) {
        return( E_POINTER );
    }

    HRESULT hr = (*ppunk)->QueryInterface(IID_IPin, (void **) &m_pPin);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    //
    // Find the media type of the pin. If we don't succeed, we are
    // not connected. Set the m_fUnconnected flag, which will be used
    // during creation of the dialog.
    //

    CMediaType mt;
    hr = m_pPin->ConnectionMediaType(&mt);

    if (S_OK == hr) {

        //
        // Connected. Convert the media type to a string in m_szBuff.
        //

        CTextMediaType(mt).AsText
        (m_szBuff, sizeof(m_szBuff), TEXT("\n\n"), TEXT("\n"), TEXT(""));

    }
    else {
        //
        // Not connected
        //
        LoadString(g_hInst, IDS_UNCONNECTED, m_szBuff, sizeof(m_szBuff));

        m_fUnconnected = TRUE;
    }
    
    }
    else if (cObjects == 0) {
    //
    // Release the interface ...
    //
    if (m_pPin == NULL) {
        return( E_UNEXPECTED);
    }

    m_pPin->Release();
    m_pPin = NULL;
    }
    else {
    ASSERT(!"No support for more than one object");
    return( E_UNEXPECTED );
    }

    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////
// *
// * CFileProperties
// *


//
// Constructor
//
CFileProperties::CFileProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("File Property Page"), lpunk)
    , m_oszFileName(NULL)
    , m_pPageSite(NULL)
    , m_bDirty(FALSE)
    , m_hwnd(NULL) {

}


//
// Destructor
//
CFileProperties::~CFileProperties(void)
{
     //
     // OleCreatePropertyFrame bug:
     //   - Final SetObjects(NULL) call is missing. Might have to
     //     release interfaces at this point.
     //

     ASSERT(m_pPageSite == NULL);
}


//
// NonDelegatingQueryInterface
//
// Reveal our property page
STDMETHODIMP CFileProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (riid == IID_IPropertyPage) {
    return GetInterface((IPropertyPage *) this, ppv);
    } else {
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


//
// SetPageSite
//
// called with null as the page shuts down. therefore release the file interface
// here.
STDMETHODIMP CFileProperties::SetPageSite(LPPROPERTYPAGESITE pPageSite) {

    if (pPageSite == NULL) {

    ASSERT(m_pPageSite);
    m_pPageSite->Release();
    m_pPageSite = NULL;
    }
    else {
    if (m_pPageSite != NULL) {
        return( E_UNEXPECTED );
    }

    m_pPageSite = pPageSite;
    m_pPageSite->AddRef();
    }

    return( S_OK );
}


//
// GetPageInfo
//
// set the page info so that the page site can size itself, etc
STDMETHODIMP CFileProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo) {

    WCHAR szTitle[] = L"File";

    LPOLESTR pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(szTitle));
    memcpy(pszTitle, szTitle, sizeof(szTitle));

    pPageInfo->cb               = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle         = pszTitle;

    // set default size values if GetDialogSize fails
    pPageInfo->size.cx          = 325;
    pPageInfo->size.cy          = 95;
    GetDialogSize(GetPropPageID(), DialogProc, 0L, &pPageInfo->size);

    pPageInfo->pszDocString     = NULL;
    pPageInfo->pszHelpFile      = NULL;
    pPageInfo->dwHelpContext    = 0;

    return NOERROR;

}



//
// Show
//
// Display the property dialog
STDMETHODIMP CFileProperties::Show(UINT nCmdShow) {

    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    if (!((nCmdShow == SW_SHOW) || (nCmdShow == SW_SHOWNORMAL) || (nCmdShow == SW_HIDE))) {
    return( E_INVALIDARG);
    }

    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);

    return NOERROR;
}


//
// Activate
//
// Create the window we will use to edit properties
STDMETHODIMP CFileProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal) {

    if ( m_hwnd != NULL ) {
    return( E_UNEXPECTED );
    }

    m_hwnd = CreateDialogParam( g_hInst
                  , MAKEINTRESOURCE(GetPropPageID())
                  , hwndParent
                  , DialogProc
                  , (LPARAM) this
                  );

    if (m_hwnd == NULL) {
    DWORD dwErr = GetLastError();
    DbgLog((LOG_ERROR, 1, TEXT("Could not create window: 0x%x"), dwErr));
    return E_FAIL;
    }

    DWORD dwStyle = ::GetWindowLong( m_hwnd, GWL_EXSTYLE );
    dwStyle |= WS_EX_CONTROLPARENT;
    SetWindowLong(m_hwnd, GWL_EXSTYLE, dwStyle);

    if (m_oszFileName) {
    FileNameToDialog();
    }

    Move(prect);
    ShowWindow( m_hwnd, SW_SHOWNORMAL );

    return NOERROR;
}


//
// Deactivate
//
// Destroy the dialog
STDMETHODIMP CFileProperties::Deactivate(void) {

    if (m_hwnd == NULL) {
    return E_UNEXPECTED;
    }

    //
    // HACK: Remove WS_EX_CONTROLPARENT before DestroyWindow call
    //       (or NT crashes!)
    DWORD dwStyle = ::GetWindowLong(m_hwnd, GWL_EXSTYLE);
    dwStyle = dwStyle & (~WS_EX_CONTROLPARENT);
    SetWindowLong(m_hwnd, GWL_EXSTYLE, dwStyle);

    if (DestroyWindow(m_hwnd)) {
    m_hwnd = NULL;
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}


//
// Move
//
// put the property page over its home in the parent frame.
STDMETHODIMP CFileProperties::Move(LPCRECT prect) {

    if ( m_hwnd == NULL ) {
    return( E_UNEXPECTED );
    }

    if (MoveWindow( m_hwnd
          , prect->left
          , prect->top
          , prect->right - prect->left
          , prect->bottom - prect->top
          , TRUE                // send WM_PAINT
          ) ) {
    return NOERROR;
    }
    else {
    return E_FAIL;
    }
}


//
// IsPageDirty
//
STDMETHODIMP CFileProperties::IsPageDirty(void) {

    if (m_bDirty) {
    return S_OK;
    }
    else {
    return S_FALSE;
    }
}


//
// DialogProc
//
// Handles the window messages for our property page
INT_PTR CALLBACK CFileProperties::DialogProc( HWND hwnd
                     , UINT uMsg
                     , WPARAM wParam
                     , LPARAM lParam) {

    static CFileProperties *pThis = NULL;

    switch (uMsg) {
    case WM_INITDIALOG: // GWLP_USERDATA has not been set yet. pThis in lParam

    pThis = (CFileProperties *) lParam;

    return TRUE;    // I don't call setfocus...

    case WM_COMMAND:
    if (!pThis)
        return( TRUE );

    pThis->OnCommand(HIWORD(wParam), LOWORD(wParam), (HWND) lParam);
    return TRUE;

    default:
    return FALSE;
    }
}

//
// SetDirty
//
// Notify the page site that we are dirty and set our dirty flag, if bDirty = TRUE
// otherwise set the flag to not dirty
void CFileProperties::SetDirty(BOOL bDirty) {

    m_bDirty = bDirty;

    if (bDirty) {
    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }
}


//
// OnCommand
//
// handles WM_COMMAND messages from the property page
void CFileProperties::OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl) {

    switch (wID) {
    case IDC_FILE_SELECT:
    //
    // Let the user chose a new file name
    //

    ASSERT(m_hwnd);

    TCHAR tszFile[MAX_PATH];
    tszFile[0] = TEXT('\0');

    OPENFILENAME ofn;
    ZeroMemory(&ofn, sizeof(ofn));

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner   = m_hwnd;
    ofn.lpstrFilter = TEXT("Media files\0*.MPG;*.AVI;*.MOV;*.WAV\0MPEG files\0*.MPG\0AVI files\0*.AVI\0Quick Time files\0*.MOV\0Wave audio files\0*.WAV\0All Files\0*.*\0\0");
    ofn.nFilterIndex = 1;
    ofn.lpstrFile   = tszFile;
    ofn.nMaxFile    = MAX_PATH;
    ofn.lpstrTitle  = TEXT("Select File Source");
    ofn.Flags       = OFN_PATHMUSTEXIST;

    if (GetOpenFileName(&ofn)) {
        SetDirty();

        ASSERT(m_hwnd);
        HWND hWndEdit = GetDlgItem(m_hwnd, IDC_FILENAME);
        SetWindowText(hWndEdit, tszFile);
    }

    break;

    default:
    break;
    }
}

//
// FileNameToDialog
//
void CFileProperties::FileNameToDialog()
{
    ASSERT(m_hwnd);

    //
    // Get window handle for the edit control.
    //
    HWND hWnd = GetDlgItem(m_hwnd, IDC_FILENAME);
    ASSERT(hWnd);

    if (!m_oszFileName) {
    // No name!
    SetWindowText(hWnd, TEXT(""));

    return;
    }

    TCHAR * tszFileName;

#ifndef UNICODE

    CHAR szFileName[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0,
            m_oszFileName, -1,
            szFileName, sizeof(szFileName),
            NULL, NULL);

    tszFileName = szFileName;

#else // UNICODE

    tszFileName = m_oszFileName;
#endif

    SetWindowText(hWnd, tszFileName);
}


//
// CreateInstance
//
// The only allowed way to create File Property pages
CUnknown *CFileSourceProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CFileSourceProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CFileSourceProperties::CFileSourceProperties(LPUNKNOWN lpunk, HRESULT *phr) :
    CFileProperties(lpunk, phr)
    , m_pIFileSource(NULL)
{
}

CFileSourceProperties::~CFileSourceProperties()
{
  //
  // OleCreatePropertyFrame bug:
  //   - Final SetObjects(NULL) call is missing. Might have to
  //     release interfaces at this point.
  //

  if (m_pIFileSource)
     m_pIFileSource->Release();
     m_pIFileSource = NULL;
}

//
// SetObjects
//
STDMETHODIMP CFileSourceProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) {

    if (cObjects == 1) {
    //
    // Initialise
    //
    if ( (ppunk == NULL) || (*ppunk == NULL) ) {
        return( E_POINTER );
    }

    ASSERT( !m_pIFileSource );

    HRESULT hr = (*ppunk)->QueryInterface(IID_IFileSourceFilter, (void **) &m_pIFileSource);
    if ( FAILED(hr) ) {
        return( E_NOINTERFACE );
    }

    ASSERT( m_pIFileSource );

    //
    // Get file name of file source
    //
    if (m_oszFileName) {
        QzTaskMemFree((PVOID) m_oszFileName);
        m_oszFileName = NULL;
    }

    AM_MEDIA_TYPE mtNotUsed;
    if (FAILED(m_pIFileSource->GetCurFile(&m_oszFileName, &mtNotUsed))) {
        SetDirty();
    }

    if (m_hwnd) {
        FileNameToDialog();
    }
    }
    else if ( cObjects == 0 ) {

    if ( m_pIFileSource == NULL ) {
        return( E_UNEXPECTED );
    }

    ASSERT(m_pIFileSource);
    m_pIFileSource->Release();
    m_pIFileSource = NULL;
    }
    else {
    ASSERT( !"No support for more than 1 object" );
    return( E_UNEXPECTED );
    }

    return( S_OK );
}

//
// Apply
//
STDMETHODIMP CFileSourceProperties::Apply(void) {

    if (IsPageDirty() == S_OK) {

    TCHAR szFileName[MAX_PATH];

    ASSERT(m_hwnd);
    GetWindowText(GetDlgItem(m_hwnd, IDC_FILENAME), szFileName, sizeof(szFileName));

#ifndef UNICODE

    WCHAR wszFileName[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0,
                szFileName, -1,
                wszFileName, sizeof(wszFileName));
#else
    #define wszFileName szFileName
#endif

        HRESULT hr = m_pIFileSource->Load(wszFileName, NULL);
    if (FAILED(hr)) {
        TCHAR tszMessage[MAX_PATH];
        LoadString(g_hInst, IDS_FAILED_LOAD_FILE, tszMessage, MAX_PATH);
        MessageBox(m_hwnd, tszMessage, NULL, MB_OK);
        return E_FAIL;
    }

    SetDirty(FALSE);
    }
    return NOERROR;
}


//
// CreateInstance
//
// The only allowed way to create File Property pages
CUnknown *CFileSinkProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CFileSinkProperties(lpunk, phr);
    if (punk == NULL) {
    *phr = E_OUTOFMEMORY;
    }

    return punk;
}

CFileSinkProperties::CFileSinkProperties(LPUNKNOWN lpunk, HRESULT *phr) :
    CFileProperties(lpunk, phr)
    , m_fTruncate(FALSE)
    , m_pIFileSink(NULL)
    , m_pIFileSink2(NULL)
{
}

CFileSinkProperties::~CFileSinkProperties()
{
  //
  // OleCreatePropertyFrame bug:
  //   - Final SetObjects(NULL) call is missing. Might have to
  //     release interfaces at this point.
  //

  if (m_pIFileSink)
     m_pIFileSink->Release();
     m_pIFileSink = NULL;
  if (m_pIFileSink2)
     m_pIFileSink2->Release();
     m_pIFileSink = NULL;
}

//
// SetObjects
//
STDMETHODIMP CFileSinkProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) {

    if (cObjects == 1) {
    //
    // Initialise
    //
    if ( (ppunk == NULL) || (*ppunk == NULL) ) {
        return( E_POINTER );
    }

    ASSERT( !m_pIFileSink && !m_pIFileSink2);

    HRESULT hr = (*ppunk)->QueryInterface(IID_IFileSinkFilter2, (void **) &m_pIFileSink2);
    if ( FAILED(hr) ) {
            hr = (*ppunk)->QueryInterface(IID_IFileSinkFilter, (void **) &m_pIFileSink);
            if ( FAILED(hr) ) {
                return( E_NOINTERFACE );
            }
    }
        else
        {
            m_pIFileSink = (IFileSinkFilter *)m_pIFileSink2;
            m_pIFileSink2->AddRef();
        }
    

    ASSERT( m_pIFileSink || (m_pIFileSink2 && m_pIFileSink2) );

    //
    // Get file name of file sink
    //
    if (m_oszFileName) {
        QzTaskMemFree((PVOID) m_oszFileName);
        m_oszFileName = NULL;
    }

    AM_MEDIA_TYPE mtNotUsed;
    if (FAILED(m_pIFileSink->GetCurFile(&m_oszFileName, &mtNotUsed))) {
        SetDirty();
    }

        if(m_pIFileSink2)
        {
            DWORD dwFlags;
            if (FAILED(m_pIFileSink2->GetMode(&dwFlags))) {
                SetDirty();
            }
            else
            {
                m_fTruncate = ((dwFlags & AM_FILE_OVERWRITE) != 0);
            }
        }


        if (m_hwnd) {
            FileNameToDialog();
        }
    }
    else if ( cObjects == 0 ) {

    if ( m_pIFileSink == NULL ) {
        return( E_UNEXPECTED );
    }

    ASSERT(m_pIFileSink);
    m_pIFileSink->Release();
    m_pIFileSink = NULL;
        if(m_pIFileSink2)
        {
            m_pIFileSink2->Release();
            m_pIFileSink2 = NULL;
        }
    }
    else {
    ASSERT( !"No support for more than 1 object" );
    return( E_UNEXPECTED );
    }

    return( S_OK );
}

void CFileSinkProperties::OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl) {

    switch (wID) {
    case IDC_TRUNCATE:

        m_fTruncate = ::SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED;
        SetDirty();
    break;

    default:
    CFileProperties::OnCommand(wNotifyCode, wID, hwndCtl);
    }
}

void CFileSinkProperties::FileNameToDialog()
{
    ASSERT(m_hwnd);

    //
    // Get window handle for the edit control.
    //
    HWND hWnd = GetDlgItem(m_hwnd, IDC_TRUNCATE);
    ASSERT(hWnd);

    if(m_pIFileSink2)
        CheckDlgButton (m_hwnd, IDC_TRUNCATE, m_fTruncate ? BST_CHECKED : 0);
    else
        Edit_Enable(GetDlgItem(m_hwnd, IDC_TRUNCATE), FALSE);


    CFileProperties::FileNameToDialog();
}

//
// Apply
//
STDMETHODIMP CFileSinkProperties::Apply(void) {

    if (IsPageDirty() == S_OK) {

    TCHAR szFileName[MAX_PATH];

    ASSERT(m_hwnd);
    GetWindowText(GetDlgItem(m_hwnd, IDC_FILENAME), szFileName, sizeof(szFileName));
        BOOL fTruncate = SendMessage(GetDlgItem(m_hwnd, IDC_TRUNCATE), BM_GETCHECK, 0, 0) == BST_CHECKED;

#ifndef UNICODE

    WCHAR wszFileName[MAX_PATH];

    MultiByteToWideChar(CP_ACP, 0,
                szFileName, -1,
                wszFileName, sizeof(wszFileName));
#else
    #define wszFileName szFileName
#endif

        HRESULT hr = m_pIFileSink->SetFileName(wszFileName, NULL);
    if (FAILED(hr)) {
        TCHAR tszMessage[MAX_PATH];
        LoadString(g_hInst, IDS_FAILED_SET_FILENAME, tszMessage, MAX_PATH);
        MessageBox(m_hwnd, tszMessage, NULL, MB_OK);
        return E_FAIL;
    }

        if(m_pIFileSink2)
        {
            hr = m_pIFileSink2->SetMode(fTruncate ? AM_FILE_OVERWRITE : 0);
            if (FAILED(hr)) {
                TCHAR tszMessage[MAX_PATH];
                LoadString(g_hInst, IDS_FAILED_SET_FILENAME, tszMessage, MAX_PATH);
                MessageBox(m_hwnd, tszMessage, NULL, MB_OK);
                return E_FAIL;
            }
        }

    SetDirty(FALSE);
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\propguid.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// propguid.h
//

// CLSID_MediaTypePropertyPage
// {fd501045-8ebe-11ce-8183-00aa00577da1}
DEFINE_GUID(CLSID_MediaTypePropertyPage,
0xfd501045, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

// CLSID_FileSourcePropertyPage
// {29e07010-bd27-11ce-ab59-00aa00577da1}
DEFINE_GUID(CLSID_FileSourcePropertyPage,
0x29e07010, 0xbd27, 0x11ce, 0xab, 0x59, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

// CLSID_FileSinkPropertyPage
// {E0B9CDA0-96E3-11cf-B9FA-00AA00A3F1A6}
DEFINE_GUID(CLSID_FileSinkPropertyPage,
0xe0b9cda0, 0x96e3, 0x11cf, 0xb9, 0xfa, 0x0, 0xaa, 0x0, 0xa3, 0xf1, 0xa6);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\texttype.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// texttype.h
//


// A CMediaType that can return itsself as text.

class CTextMediaType : public CMediaType {

public:

    CTextMediaType(AM_MEDIA_TYPE mt):CMediaType(mt) {}
    void AsText(LPTSTR szType, unsigned int iLen, LPTSTR szAfterMajor, LPTSTR szAfterOthers, LPTSTR szAtEnd);

    struct TableEntry {
        const GUID * guid;
        UINT stringID;
    };

private:
    void CLSID2String(LPTSTR, UINT, const GUID*, TableEntry*, ULONG);
    void Format2String(LPTSTR, UINT, const GUID*, BYTE*, ULONG);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\vmrprop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vmrprop.rc
//
#define IDD_FILTERCONFIG                105
#define IDS_TITLE_FILTERCONFIG          106
#define IDC_NUMPINS                     1000
#define IDC_PINSPIN                     1001
#define IDC_PINSELECT                   1007
#define IDC_YPOS_SLIDER                 1008
#define IDC_XPOS_SLIDER                 1009
#define IDC_XPOS                        1010
#define IDC_YPOS                        1011
#define IDC_XSIZE                       1012
#define IDC_YSIZE                       1013
#define IDC_ALPHA                       1014
#define IDC_XPOS_STATIC                 1015
#define IDC_YPOS_STATIC                 1016
#define IDC_BUTTON1                     1017
#define IDC_XSIZE_SLIDER                1018
#define IDC_YSIZE_SLIDER                1019
#define IDC_ALPHA_SLIDER                1020
#define IDC_SNAPSHOT			1021 
#define IDC_STATIC			-1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\resource.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
// Used by typeprop.rc
//
#define IDD_TYPEPROP        101
#define IDD_FILESOURCEPROP  102
#define IDD_FILESINKPROP        103
#define IDR_STATIC      -1

#define IDS_TYPE        104

#define IDS_UNCONNECTED     105

#define IDS_FORMAT_AnalogVideo                     3111
#define IDS_FORMAT_DolbyAC3                3112
#define IDS_FORMAT_MPEG2Audio              3218
#define IDS_FORMAT_DVD_LPCMAudio           3219
#define IDS_FORMAT_DvInfo                  3113
#define IDS_FORMAT_MPEG2Video                  3114
#define IDS_FORMAT_MPEG2_VIDEO                 3115
#define IDS_FORMAT_MPEGStreams                 3116
#define IDS_FORMAT_MPEGVideo                   3117
#define IDS_FORMAT_VIDEOINFO2                  3118
#define IDS_FORMAT_VideoInfo                   3119
#define IDS_FORMAT_VideoInfo2                  3120
#define IDS_FORMAT_WaveFormatEx                3121
#define IDS_MEDIASUBTYPE_AIFF                  3122
#define IDS_MEDIASUBTYPE_AU                3123
#define IDS_MEDIASUBTYPE_AnalogVideo_NTSC_M        3124
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_B         3125
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_D         3126
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_G         3127
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_H         3128
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_I         3129
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_M         3130
#define IDS_MEDIASUBTYPE_AnalogVideo_PAL_N         3131
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_B           3132
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_D           3133
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_G           3134
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_H           3135
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K           3136
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K1          3137
#define IDS_MEDIASUBTYPE_AnalogVideo_SECAM_L           3138
#define IDS_MEDIASUBTYPE_Avi                   3139
#define IDS_MEDIASUBTYPE_CFCC                  3140
#define IDS_MEDIASUBTYPE_CLJR                  3141
#define IDS_MEDIASUBTYPE_CPLA                  3142
#define IDS_MEDIASUBTYPE_DOLBY_AC3             3143
#define IDS_MEDIASUBTYPE_DVCS                  3144
#define IDS_MEDIASUBTYPE_DVD_LPCM_AUDIO            3146
#define IDS_MEDIASUBTYPE_DVD_NAVIGATION_DSI        3147
#define IDS_MEDIASUBTYPE_DVD_NAVIGATION_PCI            3148
#define IDS_MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER       3149
#define IDS_MEDIASUBTYPE_DVD_SUBPICTURE            3150
#define IDS_MEDIASUBTYPE_DVSD                   3151
#define IDS_MEDIASUBTYPE_DssAudio               3152
#define IDS_MEDIASUBTYPE_DssVideo               3153
#define IDS_MEDIASUBTYPE_IF09                   3154
#define IDS_MEDIASUBTYPE_IJPG                   3155
#define IDS_MEDIASUBTYPE_Line21_BytePair        3156
#define IDS_MEDIASUBTYPE_Line21_GOPPacket       3157
#define IDS_MEDIASUBTYPE_Line21_VBIRawData      3158
#define IDS_MEDIASUBTYPE_MDVF                   3159
#define IDS_MEDIASUBTYPE_MJPG                   3160
#define IDS_MEDIASUBTYPE_MPEG1Audio             3161
#define IDS_MEDIASUBTYPE_MPEG1Packet            3162
#define IDS_MEDIASUBTYPE_MPEG1Payload           3163
#define IDS_MEDIASUBTYPE_MPEG1System            3164
#define IDS_MEDIASUBTYPE_MPEG1Video             3165
#define IDS_MEDIASUBTYPE_MPEG1VideoCD           3166
#define IDS_MEDIASUBTYPE_MPEG2_AUDIO            3167
#define IDS_MEDIASUBTYPE_MPEG2_PROGRAM          3168
#define IDS_MEDIASUBTYPE_MPEG2_TRANSPORT        3169
#define IDS_MEDIASUBTYPE_MPEG2_VIDEO            3170
#define IDS_MEDIASUBTYPE_Overlay                3171
#define IDS_MEDIASUBTYPE_PCMAudio_Obsolete      3172
#define IDS_MEDIASUBTYPE_Plum                   3173
#define IDS_MEDIASUBTYPE_QTJpeg                 3174
#define IDS_MEDIASUBTYPE_QTMovie                3175
#define IDS_MEDIASUBTYPE_QTRle                  3176
#define IDS_MEDIASUBTYPE_QTRpza                 3177
#define IDS_MEDIASUBTYPE_QTSmc                  3178
#define IDS_MEDIASUBTYPE_RGB1                   3179
#define IDS_MEDIASUBTYPE_RGB24                  3180
#define IDS_MEDIASUBTYPE_RGB32                  3181
#define IDS_MEDIASUBTYPE_RGB4                   3182
#define IDS_MEDIASUBTYPE_RGB555                 3183
#define IDS_MEDIASUBTYPE_RGB565                 3184
#define IDS_MEDIASUBTYPE_RGB8                   3185
#define IDS_MEDIASUBTYPE_TVMJ                   3186
#define IDS_MEDIASUBTYPE_UYVY                   3187
#define IDS_MEDIASUBTYPE_WAKE                   3188
#define IDS_MEDIASUBTYPE_WAVE                   3189
#define IDS_MEDIASUBTYPE_Y211                   3190
#define IDS_MEDIASUBTYPE_Y411                   3191
#define IDS_MEDIASUBTYPE_Y41P                   3192
#define IDS_MEDIASUBTYPE_YUY2                   3193
#define IDS_MEDIASUBTYPE_YV12                   3194
#define IDS_MEDIASUBTYPE_YVU9                   3195
#define IDS_MEDIASUBTYPE_YVYU                   3196
#define IDS_MEDIASUBTYPE_dvhd                   3197
#define IDS_MEDIASUBTYPE_dvsd                   3198
#define IDS_MEDIASUBTYPE_dvsl                   3199
#define IDS_MEDIATYPE_AUXLine21Data             3200
#define IDS_MEDIATYPE_AnalogAudio               3201
#define IDS_MEDIATYPE_AnalogVideo               3202
#define IDS_MEDIATYPE_Audio                     3203
#define IDS_MEDIATYPE_DVD_ENCRYPTED_PACK        3204
#define IDS_MEDIATYPE_DVD_NAVIGATION            3205
#define IDS_MEDIATYPE_File                      3206
#define IDS_MEDIATYPE_Interleaved               3207
#define IDS_MEDIATYPE_MPEG1SystemStream         3208
#define IDS_MEDIATYPE_MPEG2_PES                 3209
#define IDS_MEDIATYPE_Midi                      3210
#define IDS_MEDIATYPE_ScriptCommand             3211
#define IDS_MEDIATYPE_Stream                    3212
#define IDS_MEDIATYPE_Text                      3213
#define IDS_MEDIATYPE_Timecode                  3214
#define IDS_MEDIATYPE_Video                     3215
#define IDS_MEDIASUBTYPE_PCM                    3216
#define IDS_MEDIASUBTYPE_MPEG1AudioPayload      3217
#define IDS_MEDIASUBTYPE_DRM_Audio              3221
#define IDS_MEDIASUBTYPE_IEEE_FLOAT             3222
#define IDS_MEDIASUBTYPE_DOLBY_AC3_SPDIF        3223
#define IDS_MEDIASUBTYPE_RAW_SPORT              3224
#define IDS_MEDIASUBTYPE_SPDIF_TAG_241h         3225

#define IDS_MEDIASUBTYPE_ARGB32                 3226
#define IDS_MEDIASUBTYPE_ARGB1555               3227
#define IDS_MEDIASUBTYPE_ARGB4444               3228
#define IDS_MEDIASUBTYPE_AYUV                   3229

#define IDS_MEDIASUBTYPE_RGB32_D3D_DX7_RT       3230
#define IDS_MEDIASUBTYPE_RGB16_D3D_DX7_RT       3231
#define IDS_MEDIASUBTYPE_ARGB32_D3D_DX7_RT      3232
#define IDS_MEDIASUBTYPE_ARGB1555_D3D_DX7_RT    3233
#define IDS_MEDIASUBTYPE_ARGB4444_D3D_DX7_RT    3234

#define IDS_DXVA_ModeNone                       3235
#define IDS_DXVA_ModeH261_A                     3236
#define IDS_DXVA_ModeH261_B                     3237
#define IDS_DXVA_ModeH263_A                     3238
#define IDS_DXVA_ModeH263_B                     3239
#define IDS_DXVA_ModeH263_C                     3240
#define IDS_DXVA_ModeH263_D                     3241
#define IDS_DXVA_ModeH263_E                     3242
#define IDS_DXVA_ModeH263_F                     3243
#define IDS_DXVA_ModeMPEG1_A                    3244
#define IDS_DXVA_ModeMPEG2_A                    3245
#define IDS_DXVA_ModeMPEG2_B                    3246
#define IDS_DXVA_ModeMPEG2_C                    3247
#define IDS_DXVA_ModeMPEG2_D                    3248
#define IDS_DXVA_NoEncrypt                      3249
#define IDS_DXVA_EncryptProt1                   3250

//
// Last used IDS_... value is 3220 (for IDS_MEDIASUBTYPE_ARGB32)
//

#define IDC_FILENAME        200
#define IDC_FILE_SELECT     201
#define IDC_SAVE        202
#define IDC_TRUNCATE        203

#define IDS_UNKNOWN             300
#define IDS_PREFORMAT           301
#define IDS_PREMAJOR            302
#define IDS_PRESUB              303
#define IDS_NOTYPE              304

#define IDS_FAILED_LOAD_FILE    500
#define IDS_FAILED_SET_FILENAME 501
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\proppage.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// TypeProp.h
//

// A property page that allows a pin to display
// its media type.

class CMediaTypeProperties : public IPropertyPage,
			     public CUnknown {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CMediaTypeProperties(void);

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void) 			{ return S_FALSE; }
    STDMETHODIMP Apply(void)				{ return NOERROR; }
    STDMETHODIMP Help(LPCWSTR lpszHelpDir)		{ return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg)	{ return E_NOTIMPL; }

    void CreateEditCtrl(HWND);
    void FillEditCtrl();

    BOOL        m_fUnconnected;         // True if pin is unconnected

private:

    CMediaTypeProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static INT_PTR CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND	m_hwnd;		// the handle of our property dialog
    TCHAR	m_szBuff[1000]; // media type as a string

    IPin	*m_pPin;        // the pin this page is attached to
    HWND        m_EditCtrl;     // the edit control to display a
                                //  list of media types
};


//
// CFileProperties
//
class CFileProperties : public IPropertyPage,
		        public CUnknown {

public:

    virtual ~CFileProperties(void);

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite);
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void);
    STDMETHODIMP Apply(void) PURE;
    STDMETHODIMP Help(LPCWSTR lpszHelpDir)		{ return E_NOTIMPL; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg)	{ return E_NOTIMPL; }
    virtual ULONG GetPropPageID() PURE;

protected:

    CFileProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static INT_PTR CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND	m_hwnd;		// the handle of our property dialog

    IPropertyPageSite	*m_pPageSite;

    BOOL		m_bDirty;
    LPOLESTR    m_oszFileName;

    void	SetDirty(BOOL bDirty = TRUE);
    virtual void	OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl);

    virtual void FileNameToDialog();
};

class CFileSourceProperties : public CFileProperties
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CFileSourceProperties();
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Apply(void);
    ULONG GetPropPageID() { return IDD_FILESOURCEPROP; }
private:
    CFileSourceProperties(LPUNKNOWN lpunk, HRESULT *phr);

    IFileSourceFilter   *m_pIFileSource; // the IFileSourceFilter interface to manage
};

class CFileSinkProperties : public CFileProperties
{
public:
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CFileSinkProperties();
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Apply(void);
    ULONG GetPropPageID() { return IDD_FILESINKPROP; }
    void FileNameToDialog();
    
private:

    CFileSinkProperties(LPUNKNOWN lpunk, HRESULT *phr);

    void	OnCommand(WORD wNotifyCode, WORD wID, HWND hwndCtl);
    
    // the IFileSinkFilter interface to manage, and optionally the
    // corresponding IFileSinkFilter2
    IFileSinkFilter   *m_pIFileSink; 
    IFileSinkFilter2  *m_pIFileSink2;

    BOOL m_fTruncate;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\vmrprop\vmrprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// VMRProp.cpp
//
//  Created 3/18/2001
//  Author: Steve Rowe [StRowe]
//
//----------------------------------------------------------------------------

#include <windowsx.h>
#include <streams.h>
#include <atlbase.h>
#include <commctrl.h>
#include <stdio.h>
#include <shlobj.h> // for SHGetSpecialFolderPath
#include "resource.h"

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "vmrprop.h"


#ifdef FILTER_DLL

STDAPI DllRegisterServer()
{
    AMTRACE((TEXT("DllRegisterServer")));
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    AMTRACE((TEXT("DllUnregisterServer")));
    return AMovieDllRegisterServer2( FALSE );
}

CFactoryTemplate g_Templates[] = {
	{
		L"",
		&CLSID_VMRFilterConfigProp,
		CVMRFilterConfigProp::CreateInstance
	}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif // #ifdef FILTER_DLL


//
// Constructor
//
CVMRFilterConfigProp::CVMRFilterConfigProp(LPUNKNOWN pUnk, HRESULT *phr) :
	CBasePropertyPage(NAME("Filter Config Page"),pUnk,IDD_FILTERCONFIG,IDS_TITLE_FILTERCONFIG),
	m_pIFilterConfig(NULL),
	m_pIMixerControl(NULL),
	m_dwNumPins(1),
	m_pEventSink(NULL), 
	m_CurPin(0), 
	m_XPos(0.0F),
	m_YPos(0.0F),
	m_XSize(1.0F),
	m_YSize(1.0F),
	m_Alpha(1.0F)
{
	ASSERT(phr);
}


//
// Create a quality properties object
//
CUnknown * CVMRFilterConfigProp::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
	ASSERT(phr);

    CUnknown * pUnknown = new CVMRFilterConfigProp(pUnk, phr);
    if (pUnknown == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return pUnknown;
}


//
// OnConnect
//
// Override CBasePropertyPage method.
// Notification of which filter this property page will communicate with
// We query the object for the IVMRFilterConfig interface.
//
HRESULT CVMRFilterConfigProp::OnConnect(IUnknown *pUnknown)
{
	ASSERT(NULL != pUnknown);
    ASSERT(NULL == m_pIFilterConfig);
    ASSERT(NULL == m_pIMixerControl);

    HRESULT hr = pUnknown->QueryInterface(IID_IVMRFilterConfig, (void **) &m_pIFilterConfig);
    if (FAILED(hr) || NULL == m_pIFilterConfig)
    {
        return E_NOINTERFACE;
    }

	// Get the IMediaEventSink interface.  We use this later to tell graphedit that we updated the number of pins
	CComPtr<IBaseFilter> pFilter;
	hr = pUnknown->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
    if (FAILED(hr) || !pFilter)
    {
        return E_NOINTERFACE;
    }

	FILTER_INFO Info;
	hr = pFilter->QueryFilterInfo(&Info);
	if (FAILED(hr))
	{
		return E_FAIL;
	}

    hr = Info.pGraph->QueryInterface(IID_IMediaEventSink, (void**) &m_pEventSink);
	Info.pGraph->Release(); // the IFilterGraph pointer is ref counted.  We need to release it or leak.
    if (FAILED(hr) || NULL == m_pEventSink) 
	{
        return E_NOINTERFACE;
    }

    return NOERROR;
} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release all interfaces we referenced in OnConnect
//
HRESULT CVMRFilterConfigProp::OnDisconnect(void)
{
	if (m_pIFilterConfig)
	{
		m_pIFilterConfig->Release();
		m_pIFilterConfig = NULL;
	}
	if (m_pIMixerControl)
	{
		m_pIMixerControl->Release();
		m_pIMixerControl = NULL;
	}
	if (m_pEventSink)
	{
		m_pEventSink->Release();
		m_pEventSink = NULL;
	}
	return NOERROR;
} // OnDisconnect


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR CVMRFilterConfigProp::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
		HANDLE_MSG(hwnd, WM_HSCROLL, OnHScroll);
    } // switch
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} // OnReceiveMessage


//
// OnCommand
//
// Handles the command messages for our property window
//
void CVMRFilterConfigProp::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDC_NUMPINS:
		if (EN_CHANGE == codeNotify)
		{
			SetDirty();
			break;
		}
		break;

		// the selected pin changed
		case IDC_PINSELECT:
		if (CBN_SELCHANGE == codeNotify)
		{
			m_CurPin = ComboBox_GetCurSel(GetDlgItem(m_Dlg, IDC_PINSELECT));
			InitConfigControls(m_CurPin);
			break;
		}
		break;

	// Reset X position to center
	case IDC_XPOS_STATIC:
		if (STN_CLICKED == codeNotify)
		{
			m_XPos = 0.0F;
			UpdatePinPos(m_CurPin);

			HWND hwndT;
			int pos;
			TCHAR sz[32];
			hwndT = GetDlgItem(m_Dlg, IDC_XPOS_SLIDER );
			pos = int(1000 * m_XPos) + 1000;
			SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
			_stprintf(sz, TEXT("%.3f"), m_XPos);
			SetDlgItemText(m_Dlg, IDC_XPOS, sz);
		}
		break;

	// Reset Y position to center
	case IDC_YPOS_STATIC:
		if (STN_CLICKED == codeNotify)
		{
			m_YPos = 0.0F;
			UpdatePinPos(m_CurPin);

			HWND hwndT;
			int pos;
			TCHAR sz[32];
			pos = int(1000 * m_YPos) + 1000;
			hwndT = GetDlgItem(m_Dlg, IDC_YPOS_SLIDER );
			SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
			_stprintf(sz, TEXT("%.3f"), m_YPos);
			SetDlgItemText(m_Dlg, IDC_YPOS, sz);
		}
		break;

    // Capture the current video image
    case IDC_SNAPSHOT:
        CaptureCurrentImage();
        break;

	}
} // OnCommand


//
// OnApplyChanges
//
// Override CBasePropertyPage method.
// Called when the user clicks ok or apply.
// We update the number of pins on the VMR.
//
HRESULT CVMRFilterConfigProp::OnApplyChanges()
{
    ASSERT(m_pIFilterConfig);

    BOOL Success;
    m_dwNumPins = GetDlgItemInt(m_Dlg, IDC_NUMPINS, &Success, FALSE);

    //
    // Set Number of Streams
    //
    HRESULT hr = m_pIFilterConfig->SetNumberOfStreams(m_dwNumPins);
    if (SUCCEEDED(hr) && !m_pIMixerControl)
    {
        hr = m_pIFilterConfig->QueryInterface(IID_IVMRMixerControl, (void **) &m_pIMixerControl);
        if (SUCCEEDED(hr))
        {
            // select the last pin connected because this will be highest in the z-order
            m_CurPin = m_dwNumPins - 1;
            InitConfigControls(m_CurPin); 
        }

    }

    // Notify the graph so it will draw the new pins
    if (m_pEventSink)
    {
	    hr = m_pEventSink->Notify(EC_GRAPH_CHANGED, 0, 0);
    }

    return NOERROR;
} // OnApplyChanges


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CVMRFilterConfigProp::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }

} // SetDirty


//
// OnActivate
//
// Override CBasePropertyPage method.
// Called when the page is being displayed.  Used to initialize page contents.
//
HRESULT CVMRFilterConfigProp::OnActivate()
{
 	ASSERT(m_pIFilterConfig);

	HRESULT hr = m_pIFilterConfig->GetNumberOfStreams(&m_dwNumPins);
	if (NULL == m_pIMixerControl)
	{
		hr = m_pIFilterConfig->QueryInterface(IID_IVMRMixerControl, (void **) &m_pIMixerControl);
		// if IMixerControl is exposed, the VMR is in mixing mode
		if (S_OK == hr && m_pIMixerControl)   
		{
			// if this is the first time, select the last pin connected because this will be highest in the z-order
			m_CurPin = m_dwNumPins - 1;
			InitConfigControls(m_CurPin); 
		}
	}
	else
	{
		InitConfigControls(m_CurPin); 
	}

	BOOL bSet = SetDlgItemInt(m_Dlg, IDC_NUMPINS, m_dwNumPins, 0);
	ASSERT(bSet);

	// Set the range of the spin control
	HWND hSpin = GetDlgItem(m_Dlg, IDC_PINSPIN);
	if(hSpin)
	{
		SendMessage(hSpin, UDM_SETRANGE32, 1, 16);
	}
    return NOERROR;
} // OnActivate



//
// InitConfigControls
//
// Enable and update the content of the configuration controls .
//
void CVMRFilterConfigProp::InitConfigControls(DWORD pin)
{
	// If this call fails, the pins are not connected or there is no mixing control.
	if (FAILED(UpdateMixingData(pin)))
	{
		return;
	}

	//
	// Populate Combo List Box and Enable Pin Config Controls
	//
	CComPtr<IBaseFilter> pFilter;
    HRESULT hr = m_pIFilterConfig->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
    if (FAILED(hr) || !pFilter)
    {
        return;
    }
	CComPtr<IEnumPins> pEnum;
	hr = pFilter->EnumPins(&pEnum);
    if (FAILED(hr) || !pEnum)
    {
        return;
    }
	HWND hCtl = GetDlgItem(m_Dlg, IDC_PINSELECT);
	ComboBox_ResetContent(GetDlgItem(m_Dlg, IDC_PINSELECT));
	pEnum->Reset();
	IPin * pPin;
	PIN_INFO Info;
	TCHAR szPinName[255]; // pin names are 32 characters or less.  This should be sufficient for a long time to come.
	while (S_OK == pEnum->Next(1, &pPin, NULL))
	{
		hr = pPin->QueryPinInfo(&Info);
        if (SUCCEEDED(hr))
        {
#ifdef UNICODE
		_tcscpy(szPinName, Info.achName);
#else
        WideCharToMultiByte(CP_ACP, NULL, Info.achName, -1, szPinName, 255, NULL, NULL);
#endif
		ComboBox_AddString(GetDlgItem(m_Dlg, IDC_PINSELECT), szPinName);
		pPin->Release();
		Info.pFilter->Release();
        }
	}

	ComboBox_SetCurSel(GetDlgItem(m_Dlg, IDC_PINSELECT), pin); // select the pin
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_PINSELECT), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_XPOS_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_YPOS_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_XSIZE_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_YSIZE_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_ALPHA_SLIDER), TRUE);

	// Initialize the sliders
	HWND hwndT;
    int pos;
    TCHAR sz[32];

	hwndT = GetDlgItem(m_Dlg, IDC_XPOS_SLIDER );
	pos = int(1000 * m_XPos) + 1000;
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_XPos);
	SetDlgItemText(m_Dlg, IDC_XPOS, sz);

	pos = int(1000 * m_YPos) + 1000;
	hwndT = GetDlgItem(m_Dlg, IDC_YPOS_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_YPos);
	SetDlgItemText(m_Dlg, IDC_YPOS, sz);

	pos = int(1000 * m_XSize) + 1000;
	hwndT = GetDlgItem(m_Dlg, IDC_XSIZE_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_XSize);
	SetDlgItemText(m_Dlg, IDC_XSIZE, sz);

	pos = int(1000 * m_YSize) + 1000;
	hwndT = GetDlgItem(m_Dlg, IDC_YSIZE_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_YSize);
	SetDlgItemText(m_Dlg, IDC_YSIZE, sz);

	pos = int(1000 * m_Alpha);
	hwndT = GetDlgItem(m_Dlg, IDC_ALPHA_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_Alpha);
	SetDlgItemText(m_Dlg, IDC_ALPHA, sz);
}// InitConfigControls


//
// OnHScroll
//
// Handles the scroll messages for our property window
//
void CVMRFilterConfigProp::OnHScroll(HWND hwnd, HWND hwndCtrl, UINT code, int pos)
{
	ASSERT(m_pIMixerControl);

    TCHAR sz[32];

    if (GetDlgItem(m_Dlg, IDC_ALPHA_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_Alpha = (FLOAT)pos / 1000.0F;
        UpdatePinAlpha(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_Alpha);
        SetDlgItemText(m_Dlg, IDC_ALPHA, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_XPOS_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_XPos = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_XPos);
        SetDlgItemText(m_Dlg, IDC_XPOS, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_YPOS_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_YPos = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_YPos);
        SetDlgItemText(m_Dlg, IDC_YPOS, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_XSIZE_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_XSize = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_XSize);
        SetDlgItemText(m_Dlg, IDC_XSIZE, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_YSIZE_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_YSize = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_YSize);
        SetDlgItemText(m_Dlg, IDC_YSIZE, sz);
    }
} // OnHScroll


//
// UpdatePinAlpha
//
// Update the alpha value of a stream
//
void CVMRFilterConfigProp::UpdatePinAlpha(DWORD dwStreamID)
{
    if (m_pIMixerControl)
	{
        m_pIMixerControl->SetAlpha(dwStreamID, m_Alpha);
	}
} // UpdatePinAlpha


//
// UpdatePinPos
//
// Update the position rectangle of a stream
//
void CVMRFilterConfigProp::UpdatePinPos(DWORD dwStreamID)
{
    NORMALIZEDRECT r = {m_XPos, m_YPos, m_XPos + m_XSize, m_YPos + m_YSize};

    if (m_pIMixerControl)
	{
        m_pIMixerControl->SetOutputRect(dwStreamID, &r);
	}
} // UpdatePinPos


//
// UpdateMixingData
//
// Query the filter for the current alpha value and position of a stream
//
HRESULT CVMRFilterConfigProp::UpdateMixingData(DWORD dwStreamID)
{
    NORMALIZEDRECT r;

    if (m_pIMixerControl)
	{
        HRESULT hr = m_pIMixerControl->GetOutputRect(dwStreamID, &r);
		if (FAILED(hr))
		{
			return hr;
		}
		m_XPos = r.left;
		m_YPos = r.top;
		m_XSize = r.right - r.left;
		m_YSize = r.bottom - r.top;

		return m_pIMixerControl->GetAlpha(dwStreamID, &m_Alpha);
	}
	return E_NOINTERFACE;
} // UpdateMixingData


//
// Data types and macros used for image capture
//
typedef     LPBITMAPINFOHEADER PDIB;

#define BFT_BITMAP 0x4d42   /* 'BM' */
#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + \
                                 (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))

#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))


//
// SaveCapturedImage
//
// Save a captured image (bitmap) to a file
//
bool CVMRFilterConfigProp::SaveCapturedImage(TCHAR* szFile, BYTE* lpCurrImage)
{

    BITMAPFILEHEADER    hdr;
    DWORD               dwSize;
    PDIB                pdib = (PDIB)lpCurrImage;

    //fh = OpenFile(szFile,&of,OF_CREATE|OF_READWRITE);
    HANDLE hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (INVALID_HANDLE_VALUE == hFile)
        return FALSE;

    dwSize = DibSize(pdib);

    hdr.bfType          = BFT_BITMAP;
    hdr.bfSize          = dwSize + sizeof(BITMAPFILEHEADER);
    hdr.bfReserved1     = 0;
    hdr.bfReserved2     = 0;
    hdr.bfOffBits       = (DWORD)sizeof(BITMAPFILEHEADER) + pdib->biSize +
                          DibPaletteSize(pdib);

    DWORD dwWritten;
    WriteFile(hFile, (LPVOID)&hdr, sizeof(BITMAPFILEHEADER), &dwWritten, NULL);
    if (sizeof(BITMAPFILEHEADER) != dwWritten)
        return FALSE;
    WriteFile(hFile, (LPVOID)pdib, dwSize, &dwWritten, NULL);
    if (dwSize != dwWritten)
        return FALSE;

    CloseHandle(hFile);
    return TRUE;
}


//
// CaptureCurrentImage
//
// Captures the current VMR image and save it to a file
//
void CVMRFilterConfigProp::CaptureCurrentImage(void)
{
    IBasicVideo* iBV;
    BYTE* lpCurrImage = NULL;

    HRESULT hr = m_pIFilterConfig->QueryInterface(IID_IBasicVideo, (LPVOID*)&iBV);
    if (SUCCEEDED(hr)) {
        LONG BuffSize = 0;
        hr = iBV->GetCurrentImage(&BuffSize, NULL);
        if (SUCCEEDED(hr)) {
            lpCurrImage = new BYTE[BuffSize];
            if (lpCurrImage) {
                hr = iBV->GetCurrentImage(&BuffSize, (long*)lpCurrImage);
                if (FAILED(hr)) {
                    delete lpCurrImage;
                    lpCurrImage = NULL;
                }
            }
        }
    } // QI

    if (lpCurrImage) {
        // Get the path to the My Pictures folder.  Create it if it doesn't exist.
        // If we can't get it, don't use a path.  Picture will then be saved in 
        // current working directory.
        TCHAR tszPath[MAX_PATH];
        if (!SHGetSpecialFolderPath(NULL, tszPath, CSIDL_MYPICTURES, TRUE))
        {
            tszPath[0]=TEXT('\0');
        }

        DWORD dwTime = timeGetTime();

        TCHAR szFile[MAX_PATH];
        wsprintf(szFile, TEXT("%s\\VMRImage%X.bmp"), tszPath, dwTime);
        SaveCapturedImage(szFile, lpCurrImage);

        delete lpCurrImage;
    }

    if (iBV) {
        iBV->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\proppage\texttype.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// texttype.cpp
//
//
// typetext.cpp
//

// CTextMediaType

#include <streams.h>

#include <string.h>
#include <tchar.h>
#include <dvdmedia.h>   //VIDEOINFOHEADER2 definition

#include <initguid.h>
#include <dxva.h>       //for dxva media subtypes

#include <stdio.h>
#include <wchar.h>

#include "resource.h"
#include "texttype.h"


//
// Global table for this module
//

//
// Text string for Majortypes
//
CTextMediaType::TableEntry g_pMajorTable[] = {
    { NULL, IDS_UNKNOWN},        // THIS ENTRY MUST BE FIRST !!!
    { &MEDIATYPE_AUXLine21Data                      ,IDS_MEDIATYPE_AUXLine21Data},
    { &MEDIATYPE_AnalogAudio                        ,IDS_MEDIATYPE_AnalogAudio},
    { &MEDIATYPE_AnalogVideo                        ,IDS_MEDIATYPE_AnalogVideo},
    { &MEDIATYPE_Audio                              ,IDS_MEDIATYPE_Audio},
    { &MEDIATYPE_DVD_ENCRYPTED_PACK                 ,IDS_MEDIATYPE_DVD_ENCRYPTED_PACK},
    { &MEDIATYPE_DVD_NAVIGATION                     ,IDS_MEDIATYPE_DVD_NAVIGATION},
    { &MEDIATYPE_File                               ,IDS_MEDIATYPE_File},
    { &MEDIATYPE_Interleaved                        ,IDS_MEDIATYPE_Interleaved},
    { &MEDIATYPE_MPEG1SystemStream                  ,IDS_MEDIATYPE_MPEG1SystemStream},
    { &MEDIATYPE_MPEG2_PES                          ,IDS_MEDIATYPE_MPEG2_PES},
    { &MEDIATYPE_Midi                               ,IDS_MEDIATYPE_Midi},
    { &MEDIATYPE_ScriptCommand                      ,IDS_MEDIATYPE_ScriptCommand},
    { &MEDIATYPE_Stream                             ,IDS_MEDIATYPE_Stream},
    { &MEDIATYPE_Text                               ,IDS_MEDIATYPE_Text},
    { &MEDIATYPE_Timecode                           ,IDS_MEDIATYPE_Timecode},
    { &MEDIATYPE_Video                              ,IDS_MEDIATYPE_Video}
};

ULONG g_iMajorTable = sizeof(g_pMajorTable) / sizeof(g_pMajorTable[0]);

//
// Text String for SubMedia types
//
CTextMediaType::TableEntry g_pSubTable[] = {
    { NULL, IDS_UNKNOWN},              // THIS ENTRY MUST BE FIRST !!!
    { &MEDIASUBTYPE_AIFF                            ,IDS_MEDIASUBTYPE_AIFF},
    { &MEDIASUBTYPE_AU                              ,IDS_MEDIASUBTYPE_AU},
    { &MEDIASUBTYPE_AnalogVideo_NTSC_M              ,IDS_MEDIASUBTYPE_AnalogVideo_NTSC_M},
    { &MEDIASUBTYPE_AnalogVideo_PAL_B               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_B},
    { &MEDIASUBTYPE_AnalogVideo_PAL_D               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_D},
    { &MEDIASUBTYPE_AnalogVideo_PAL_G               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_G},
    { &MEDIASUBTYPE_AnalogVideo_PAL_H               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_H},
    { &MEDIASUBTYPE_AnalogVideo_PAL_I               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_I},
    { &MEDIASUBTYPE_AnalogVideo_PAL_M               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_M},
    { &MEDIASUBTYPE_AnalogVideo_PAL_N               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_N},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_B             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_B},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_D             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_D},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_G             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_G},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_H             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_H},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_K             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_K1            ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K1},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_L             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_L},
    { &MEDIASUBTYPE_Avi                             ,IDS_MEDIASUBTYPE_Avi},
    { &MEDIASUBTYPE_CFCC                            ,IDS_MEDIASUBTYPE_CFCC},
    { &MEDIASUBTYPE_CLJR                            ,IDS_MEDIASUBTYPE_CLJR},
    { &MEDIASUBTYPE_CPLA                            ,IDS_MEDIASUBTYPE_CPLA},
    { &MEDIASUBTYPE_DOLBY_AC3                       ,IDS_MEDIASUBTYPE_DOLBY_AC3},
    { &MEDIASUBTYPE_DVCS                            ,IDS_MEDIASUBTYPE_DVCS},
    { &MEDIASUBTYPE_DVD_LPCM_AUDIO                  ,IDS_MEDIASUBTYPE_DVD_LPCM_AUDIO},
    { &MEDIASUBTYPE_DVD_NAVIGATION_DSI              ,IDS_MEDIASUBTYPE_DVD_NAVIGATION_DSI},
    { &MEDIASUBTYPE_DVD_NAVIGATION_PCI              ,IDS_MEDIASUBTYPE_DVD_NAVIGATION_PCI},
    { &MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER         ,IDS_MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER},
    { &MEDIASUBTYPE_DVD_SUBPICTURE                  ,IDS_MEDIASUBTYPE_DVD_SUBPICTURE},
    { &MEDIASUBTYPE_DVSD                            ,IDS_MEDIASUBTYPE_DVSD},
    { &MEDIASUBTYPE_DssAudio                        ,IDS_MEDIASUBTYPE_DssAudio},
    { &MEDIASUBTYPE_DssVideo                        ,IDS_MEDIASUBTYPE_DssVideo},
    { &MEDIASUBTYPE_IF09                            ,IDS_MEDIASUBTYPE_IF09},
    { &MEDIASUBTYPE_IJPG                            ,IDS_MEDIASUBTYPE_IJPG},
    { &MEDIASUBTYPE_Line21_BytePair                 ,IDS_MEDIASUBTYPE_Line21_BytePair},
    { &MEDIASUBTYPE_Line21_GOPPacket                ,IDS_MEDIASUBTYPE_Line21_GOPPacket},
    { &MEDIASUBTYPE_Line21_VBIRawData               ,IDS_MEDIASUBTYPE_Line21_VBIRawData},
    { &MEDIASUBTYPE_MDVF                            ,IDS_MEDIASUBTYPE_MDVF},
    { &MEDIASUBTYPE_MJPG                            ,IDS_MEDIASUBTYPE_MJPG},
    { &MEDIASUBTYPE_MPEG1Audio                      ,IDS_MEDIASUBTYPE_MPEG1Audio},
    { &MEDIASUBTYPE_MPEG1Packet                     ,IDS_MEDIASUBTYPE_MPEG1Packet},
    { &MEDIASUBTYPE_MPEG1Payload                  ,IDS_MEDIASUBTYPE_MPEG1Payload},
    { &MEDIASUBTYPE_MPEG1AudioPayload          ,IDS_MEDIASUBTYPE_MPEG1AudioPayload},
    { &MEDIASUBTYPE_MPEG1System                     ,IDS_MEDIASUBTYPE_MPEG1System},
    { &MEDIASUBTYPE_MPEG1Video                      ,IDS_MEDIASUBTYPE_MPEG1Video},
    { &MEDIASUBTYPE_MPEG1VideoCD                    ,IDS_MEDIASUBTYPE_MPEG1VideoCD},
    { &MEDIASUBTYPE_MPEG2_AUDIO                     ,IDS_MEDIASUBTYPE_MPEG2_AUDIO},
    { &MEDIASUBTYPE_MPEG2_PROGRAM                   ,IDS_MEDIASUBTYPE_MPEG2_PROGRAM},
    { &MEDIASUBTYPE_MPEG2_TRANSPORT                 ,IDS_MEDIASUBTYPE_MPEG2_TRANSPORT},
    { &MEDIASUBTYPE_MPEG2_VIDEO                     ,IDS_MEDIASUBTYPE_MPEG2_VIDEO},
    { &MEDIASUBTYPE_Overlay                         ,IDS_MEDIASUBTYPE_Overlay},
    { &MEDIASUBTYPE_PCM                             ,IDS_MEDIASUBTYPE_PCM},
    { &MEDIASUBTYPE_Plum                            ,IDS_MEDIASUBTYPE_Plum},
    { &MEDIASUBTYPE_QTJpeg                          ,IDS_MEDIASUBTYPE_QTJpeg},
    { &MEDIASUBTYPE_QTMovie                         ,IDS_MEDIASUBTYPE_QTMovie},
    { &MEDIASUBTYPE_QTRle                           ,IDS_MEDIASUBTYPE_QTRle},
    { &MEDIASUBTYPE_QTRpza                          ,IDS_MEDIASUBTYPE_QTRpza},
    { &MEDIASUBTYPE_QTSmc                           ,IDS_MEDIASUBTYPE_QTSmc},
    { &MEDIASUBTYPE_RGB1                            ,IDS_MEDIASUBTYPE_RGB1},
    { &MEDIASUBTYPE_RGB24                           ,IDS_MEDIASUBTYPE_RGB24},
    { &MEDIASUBTYPE_RGB32                           ,IDS_MEDIASUBTYPE_RGB32},
    { &MEDIASUBTYPE_ARGB32                          ,IDS_MEDIASUBTYPE_ARGB32},
    { &MEDIASUBTYPE_ARGB4444                        ,IDS_MEDIASUBTYPE_ARGB4444},
    { &MEDIASUBTYPE_ARGB1555                        ,IDS_MEDIASUBTYPE_ARGB1555},
    { &MEDIASUBTYPE_AYUV                            ,IDS_MEDIASUBTYPE_AYUV},
    { &MEDIASUBTYPE_RGB32_D3D_DX7_RT                ,IDS_MEDIASUBTYPE_RGB32_D3D_DX7_RT},
    { &MEDIASUBTYPE_RGB16_D3D_DX7_RT                ,IDS_MEDIASUBTYPE_RGB16_D3D_DX7_RT},
    { &MEDIASUBTYPE_ARGB32_D3D_DX7_RT               ,IDS_MEDIASUBTYPE_ARGB32_D3D_DX7_RT},
    { &MEDIASUBTYPE_ARGB1555_D3D_DX7_RT             ,IDS_MEDIASUBTYPE_ARGB1555_D3D_DX7_RT},
    { &MEDIASUBTYPE_ARGB4444_D3D_DX7_RT             ,IDS_MEDIASUBTYPE_ARGB4444_D3D_DX7_RT},
    { &MEDIASUBTYPE_RGB4                            ,IDS_MEDIASUBTYPE_RGB4},
    { &MEDIASUBTYPE_RGB555                          ,IDS_MEDIASUBTYPE_RGB555},
    { &MEDIASUBTYPE_RGB565                          ,IDS_MEDIASUBTYPE_RGB565},
    { &MEDIASUBTYPE_RGB8                            ,IDS_MEDIASUBTYPE_RGB8},
    { &MEDIASUBTYPE_TVMJ                            ,IDS_MEDIASUBTYPE_TVMJ},
    { &MEDIASUBTYPE_UYVY                            ,IDS_MEDIASUBTYPE_UYVY},
    { &MEDIASUBTYPE_WAKE                            ,IDS_MEDIASUBTYPE_WAKE},
    { &MEDIASUBTYPE_WAVE                            ,IDS_MEDIASUBTYPE_WAVE},
    { &MEDIASUBTYPE_Y211                            ,IDS_MEDIASUBTYPE_Y211},
    { &MEDIASUBTYPE_Y411                            ,IDS_MEDIASUBTYPE_Y411},
    { &MEDIASUBTYPE_Y41P                            ,IDS_MEDIASUBTYPE_Y41P},
    { &MEDIASUBTYPE_YUY2                            ,IDS_MEDIASUBTYPE_YUY2},
    { &MEDIASUBTYPE_YV12                            ,IDS_MEDIASUBTYPE_YV12},
    { &MEDIASUBTYPE_YVU9                            ,IDS_MEDIASUBTYPE_YVU9},
    { &MEDIASUBTYPE_YVYU                            ,IDS_MEDIASUBTYPE_YVYU},
    { &MEDIASUBTYPE_dvhd                            ,IDS_MEDIASUBTYPE_dvhd},
    { &MEDIASUBTYPE_dvsd                            ,IDS_MEDIASUBTYPE_dvsd},
    { &MEDIASUBTYPE_dvsl                            ,IDS_MEDIASUBTYPE_dvsl},
    { &MEDIASUBTYPE_IEEE_FLOAT                      ,IDS_MEDIASUBTYPE_IEEE_FLOAT},
    { &MEDIASUBTYPE_DOLBY_AC3_SPDIF                 ,IDS_MEDIASUBTYPE_DOLBY_AC3_SPDIF},
    { &MEDIASUBTYPE_RAW_SPORT                       ,IDS_MEDIASUBTYPE_RAW_SPORT},
    { &MEDIASUBTYPE_SPDIF_TAG_241h                  ,IDS_MEDIASUBTYPE_SPDIF_TAG_241h},
    { &MEDIASUBTYPE_DRM_Audio                       ,IDS_MEDIASUBTYPE_DRM_Audio},
    { &DXVA_ModeNone                                ,IDS_DXVA_ModeNone},
    { &DXVA_ModeH261_A                              ,IDS_DXVA_ModeH261_A},
    { &DXVA_ModeH261_B                              ,IDS_DXVA_ModeH261_B},

    { &DXVA_ModeH263_A                              ,IDS_DXVA_ModeH263_A},
    { &DXVA_ModeH263_B                              ,IDS_DXVA_ModeH263_B},
    { &DXVA_ModeH263_C                              ,IDS_DXVA_ModeH263_C},
    { &DXVA_ModeH263_D                              ,IDS_DXVA_ModeH263_D},
    { &DXVA_ModeH263_E                              ,IDS_DXVA_ModeH263_E},
    { &DXVA_ModeH263_F                              ,IDS_DXVA_ModeH263_F},

    { &DXVA_ModeMPEG1_A                             ,IDS_DXVA_ModeMPEG1_A},

    { &DXVA_ModeMPEG2_A                             ,IDS_DXVA_ModeMPEG2_A},
    { &DXVA_ModeMPEG2_B                             ,IDS_DXVA_ModeMPEG2_B},
    { &DXVA_ModeMPEG2_C                             ,IDS_DXVA_ModeMPEG2_C},
    { &DXVA_ModeMPEG2_D                             ,IDS_DXVA_ModeMPEG2_D}
};

ULONG g_iSubTable = sizeof(g_pSubTable) / sizeof(g_pSubTable[0]);

//
//
//
CTextMediaType::TableEntry g_pFormatTable [] = {
    { NULL, IDS_UNKNOWN},       // THIS ENTRY MUST BE FIRST !!!
    { &FORMAT_AnalogVideo                           ,IDS_FORMAT_AnalogVideo},
    { &FORMAT_DolbyAC3                              ,IDS_FORMAT_DolbyAC3},
    { &FORMAT_MPEG2Audio                            ,IDS_FORMAT_MPEG2Audio},
    { &FORMAT_DVD_LPCMAudio                         ,IDS_FORMAT_DVD_LPCMAudio},
    { &FORMAT_DvInfo                                ,IDS_FORMAT_DvInfo},
    { &FORMAT_MPEG2Video                            ,IDS_FORMAT_MPEG2Video},
    { &FORMAT_MPEG2_VIDEO                           ,IDS_FORMAT_MPEG2_VIDEO},
    { &FORMAT_MPEGStreams                           ,IDS_FORMAT_MPEGStreams},
    { &FORMAT_MPEGVideo                             ,IDS_FORMAT_MPEGVideo},
    { &FORMAT_VIDEOINFO2                            ,IDS_FORMAT_VIDEOINFO2},
    { &FORMAT_VideoInfo                             ,IDS_FORMAT_VideoInfo},
    { &FORMAT_VideoInfo2                            ,IDS_FORMAT_VideoInfo2},
    { &FORMAT_WaveFormatEx                          ,IDS_FORMAT_WaveFormatEx}
};

ULONG g_iFormatTable = sizeof(g_pFormatTable) / sizeof(g_pFormatTable[0]);


//
// AsText
//
// Return the media type as a text string. Will place szAfterMajor after
// the text string for the major type and szAfterOthers after all other
// string apart from the last one.
//
void CTextMediaType::AsText(LPTSTR szType, unsigned int iLen, LPTSTR szAfterMajor, LPTSTR szAfterOthers, LPTSTR szAtEnd) {

    ASSERT(szType);

    //
    // Convert Majortype to string
    //
    TCHAR szMajorType[100];
    UINT  iMajorType = 100;

    CLSID2String(szMajorType, iMajorType, &majortype, g_pMajorTable, g_iMajorTable);

    //
    // Convert Subtype to string
    //
    TCHAR szSubType[100];
    UINT  iSubType = 100;
    CLSID2String(szSubType, iSubType, &subtype, g_pSubTable, g_iSubTable);

    //
    // Convert Format to string
    TCHAR szFormat[300];
    UINT  iFormat = 300;
    Format2String(szFormat, iFormat, FormatType(), Format(), FormatLength());

    //
    // Obtain the strings preceeding the Major Type, Sub Type and Format.
    //
    TCHAR szPreMajor[50];
    TCHAR szPreSub[50];
    TCHAR szPreFormat[50];

    LoadString(g_hInst, IDS_PREMAJOR, szPreMajor, 50);
    LoadString(g_hInst, IDS_PRESUB, szPreSub, 50);
    LoadString(g_hInst, IDS_PREFORMAT, szPreFormat, 50);

    _sntprintf(szType, iLen, TEXT("%s%s%s%s%s%s%s%s%s"),
               szPreMajor,  szMajorType, szAfterMajor,
               szPreSub,    szSubType, szAfterOthers,
               szPreFormat, szFormat, szAtEnd);
}

//
// CLSID2String
//
// Given a CLSID and a table which binds CLSIDs to string resource IDs,
// we find the string for a given CLSID and place it in szBuffer.
// If none of the CLSIDs match, we use the first entry in the table.
//
void CTextMediaType::CLSID2String(LPTSTR szBuffer, UINT iLength, const GUID* pGuid, TableEntry pTable[], ULONG iTable)
{
    for (ULONG index = 1; index < iTable; index++) {
        if (IsEqualGUID(*pGuid, *pTable[index].guid)) {
            LoadString(g_hInst, pTable[index].stringID, szBuffer, iLength);

            return;
        }
    }

    // no match
    LoadString(g_hInst, pTable[0].stringID, szBuffer, iLength);
}

//
// Format2String
//
// Converts a format block to a string
//
void CTextMediaType::Format2String(LPTSTR szBuffer, UINT iLength, const GUID* pFormatType, BYTE* pFormat, ULONG lFormatLength)
{
    //
    // Get the name of the format
    //
    TCHAR szName[50];
    UINT iName = 50;
    CLSID2String(szName, iName, pFormatType, g_pFormatTable, g_iFormatTable);

    if (pFormat) {
        //
        // Video Format
        //
        if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo) ||
            IsEqualGUID(*pFormatType, FORMAT_MPEGVideo)) {

            VIDEOINFO * pVideoFormat = (VIDEOINFO *) pFormat;
            DbgLog((LOG_TRACE, 0, TEXT("Width = %d"), pVideoFormat->bmiHeader.biWidth));

            _sntprintf(szBuffer, iLength,
                        TEXT("%4.4hs %dx%d, %d bits\n")
                        TEXT("rcSrc=(%d,%d,%d,%d)\n")
                        TEXT("rcDst=(%d,%d,%d,%d)")
                       , (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB" :
                            ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                            (LPSTR) &pVideoFormat->bmiHeader.biCompression )
                       , pVideoFormat->bmiHeader.biWidth
                       , pVideoFormat->bmiHeader.biHeight
                       , pVideoFormat->bmiHeader.biBitCount
                       , pVideoFormat->rcSource.left
                       , pVideoFormat->rcSource.top
                       , pVideoFormat->rcSource.right
                       , pVideoFormat->rcSource.bottom
                       , pVideoFormat->rcTarget.left
                       , pVideoFormat->rcTarget.top
                       , pVideoFormat->rcTarget.right
                       , pVideoFormat->rcTarget.bottom
                      );

            return;
        }


        if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo2)) {

            VIDEOINFOHEADER2 * pVideoFormat = (VIDEOINFOHEADER2 *) pFormat;

            TCHAR* szInterlaced = TEXT("Frames");

            const DWORD dwNIBob = (AMINTERLACE_IsInterlaced |
                                   AMINTERLACE_1FieldPerSample |
                                   AMINTERLACE_DisplayModeBobOnly);

            const DWORD dwWeave = (AMINTERLACE_IsInterlaced |
                                   AMINTERLACE_DisplayModeWeaveOnly);

            const DWORD dwIBobOnly = (AMINTERLACE_IsInterlaced |
                                      AMINTERLACE_DisplayModeBobOnly);

            const DWORD dwIBobWeave = (AMINTERLACE_IsInterlaced |
                                       AMINTERLACE_FieldPatBothRegular |
                                       AMINTERLACE_DisplayModeBobOrWeave);


            if ((pVideoFormat->dwInterlaceFlags & dwNIBob) == dwNIBob) {
                 szInterlaced = TEXT("Non-Interleaved Bob");
            }
            else if ((pVideoFormat->dwInterlaceFlags & dwIBobWeave) == dwIBobWeave) {
                 szInterlaced = TEXT("Interleaved Bob or Weave");
            }
            else if ((pVideoFormat->dwInterlaceFlags & dwWeave) == dwWeave) {
                 szInterlaced = TEXT("Weave Only");
            }
            else if ((pVideoFormat->dwInterlaceFlags & dwIBobOnly) == dwIBobOnly) {
                 szInterlaced = TEXT("Interleaved Bob Only");
            }

            _sntprintf(szBuffer, iLength,
                        TEXT("%4.4hs %dx%d, %d bits,\n")
                        TEXT("Aspect Ratio: %dx%d,\n")
                        TEXT("Interlace format: %s\n")
                        TEXT("rcSrc=(%d,%d,%d,%d)\n")
                        TEXT("rcDst=(%d,%d,%d,%d)")
                       , (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB" :
                            ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                            (LPSTR) &pVideoFormat->bmiHeader.biCompression )
                       , pVideoFormat->bmiHeader.biWidth
                       , pVideoFormat->bmiHeader.biHeight
                       , pVideoFormat->bmiHeader.biBitCount
                       , pVideoFormat->dwPictAspectRatioX
                       , pVideoFormat->dwPictAspectRatioY
                       , szInterlaced
                       , pVideoFormat->rcSource.left
                       , pVideoFormat->rcSource.top
                       , pVideoFormat->rcSource.right
                       , pVideoFormat->rcSource.bottom
                       , pVideoFormat->rcTarget.left
                       , pVideoFormat->rcTarget.top
                       , pVideoFormat->rcTarget.right
                       , pVideoFormat->rcTarget.bottom
                      );

            return;
        }
        //
        // Audio Format
        //
        if (IsEqualGUID(*pFormatType, FORMAT_WaveFormatEx)) {
            WAVEFORMATEX *pWaveFormat = (WAVEFORMATEX *) pFormat;

            // !!! use ACM to get format type name?
            _sntprintf(szBuffer, iLength, TEXT("%s: %.3f KHz %d bit %s ")
                       , szName
                       , (double) pWaveFormat->nSamplesPerSec / 1000.0
                       , pWaveFormat->wBitsPerSample
                       , pWaveFormat->nChannels == 1 ? TEXT("mono") : TEXT("stereo")
                      );

            return;
        }

        if (IsEqualGUID (*pFormatType,FORMAT_DvInfo )) {
            DVINFO *pDvInfo = (DVINFO *) pFormat;
            BYTE bSystem,bBcsys, bDisp ,bQU , bSamFreq;
            TCHAR szSystem[15],szQU [15], szAR[32] , szSamFreq[10];

            //Obtaining relevant fields from the Dvinfo structure

            bSystem = (BYTE) (( pDvInfo->dwDVAAuxSrc & 0x00200000) >> 21);  //Indicate Pal / Ntsc
            bBcsys  = (BYTE) (( pDvInfo->dwDVVAuxCtl & 0x00030000) >> 16);  //BroadCast System
            bDisp   = (BYTE) (( pDvInfo->dwDVVAuxCtl & 0x00000700) >> 8);   //Display Select mode
            bQU     = (BYTE) (( pDvInfo->dwDVAAuxSrc & 0x07000000) >> 24);  //Quantization
            bSamFreq= (BYTE) (( pDvInfo->dwDVAAuxSrc & 0x38000000) >> 27);  //Sampling Frequency


            // Determine whether Pal or NTSC
            if (bSystem)
                _tcscpy (szSystem ,TEXT("PAL"));
            else
                _tcscpy (szSystem ,TEXT("NTSC"));

            // Obtain Audio Format
            switch (bQU) {
            case 0:
                _tcscpy (szQU  ,TEXT ("16 bits"));
                break;
            case 1:
                _tcscpy (szQU  ,TEXT ("12 bits"));
                break;
            case 2:
                _tcscpy (szQU  ,TEXT ("20 bits"));
                break;
            default:
                _tcscpy (szQU  ,TEXT ("Not Defined"));
            }


            // Determine aspect ratio
            switch (bBcsys) {
            case 0:
                switch (bDisp) {
                case 0:
                    _tcscpy (szAR   ,TEXT ("4:3 full format"));
                    break;
                case 1:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box centre"));
                    break;
                case 2:
                    _tcscpy (szAR   ,TEXT ("16:9 full format (squeeze)"));
                    break;
                default:
                    _tcscpy (szAR   ,TEXT ("Not Defined"));
                }
                break;

            case 1:
                switch (bDisp) {
                case 0:
                    _tcscpy (szAR   ,TEXT ("4:3 full format"));
                    break;
                case 1:
                    _tcscpy (szAR   ,TEXT ("14:9 letter box centre"));
                    break;
                case 2:
                    _tcscpy (szAR   ,TEXT ("14:9 letter box top"));
                    break;
                case 6:
                    _tcscpy (szAR   ,TEXT ("14:9 full format centre"));
                    break;
                case 3:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box centre"));
                    break;
                case 4:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box top"));
                    break;
                case 5:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box centre"));
                    break;
                case 7:
                    _tcscpy (szAR   ,TEXT ("16:9 full format (anamorphic)"));
                }
                break;
            default:
                _tcscpy (szAR   ,TEXT ("Not Defined"));

            }

            //Unable to use this because the limit to be shown in the property page is three lines
            // Will enable it after fixing that problem

            /*  //Determine Sampling Frequency
                switch (bSamFreq)
                {
                case 0:
                        _tcscpy (szSamFreq  ,TEXT ("48 kHz"));
                        break;
                case 1:
                        _tcscpy (szSamFreq  ,TEXT ("44.1 kHz"));
                        break;
                case 2:
                        _tcscpy (szSamFreq  ,TEXT ("32 kHz"));
                        break;
                default:
                        _tcscpy (szSamFreq  ,TEXT ("Undefined"));

                }

        */
            _sntprintf(szBuffer, iLength, TEXT ("DV Stream \nAudio Format: %s \n %s  Aspect Ratio: %s"),
                       szQU, szSystem, szAR);
            return;

        }
    }

    _sntprintf(szBuffer, iLength, TEXT("%s"), szName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\graphedt\proppage\vmrprop\vmrprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// VMRProp.h
//
//  Created 3/18/2001
//  Author: Steve Rowe [StRowe]
//
//----------------------------------------------------------------------------


#ifndef __VMRPROP__
#define __VMRPROP__

// {A2CA6D57-BE10-45e0-9B81-7523681EC278}
DEFINE_GUID(CLSID_VMRFilterConfigProp, 
0xa2ca6d57, 0xbe10, 0x45e0, 0x9b, 0x81, 0x75, 0x23, 0x68, 0x1e, 0xc2, 0x78);

class CVMRFilterConfigProp : public CBasePropertyPage
{  
public:
    
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    
private:
    void CaptureCurrentImage(void);
    bool SaveCapturedImage(TCHAR* szFile, BYTE* lpCurrImage);
	HRESULT UpdateMixingData(DWORD dwStreamID);
	void UpdatePinPos(DWORD dwStreamID);
	void UpdatePinAlpha(DWORD dwStreamID);
	void OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
	void InitConfigControls(DWORD pin);
	
    CVMRFilterConfigProp(LPUNKNOWN pUnk, HRESULT *phr);

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
	HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();
    void SetDirty();

    // IVMRFilterConfig interface
    IVMRFilterConfig *		m_pIFilterConfig;
	IVMRMixerControl *		m_pIMixerControl;
	IMediaEventSink *		m_pEventSink;
    DWORD					m_dwNumPins;
	DWORD					m_CurPin;
	FLOAT					m_XPos;
	FLOAT					m_YPos;
	FLOAT					m_XSize;
	FLOAT					m_YSize;
	FLOAT					m_Alpha;

};  // class COMPinConfigProperties


#endif // __VMRPROP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\measure\measure.cpp ===
// Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.

#pragma warning(disable: 4201 4514)

/*
    It is very easy to fill large amounts of storage with data
    (e.g. 5 filters in a graph,
          5 interesting start/stop times per sample each = 10 events
          30 samples per second
          16 bytes per sample (8 bytes time, 8 bytes to identify incident)
       = 24KB/sec)

    this means that even a quite large buffer (I have in mind 64KB) will
    overflow after a few seconds.  Writing it out to a file is completely out
    (don't want to take page faults in the middle of things - even writing to
    memory carries some risk).

    I want to have two kinds of data available at the end of the run:
    1. A record of what actually happened (i.e. what the sequence of events
       actually was for at least a few frames)
    2. Statistical information (e.g. for inter-frame video times I would like
       to see number, average, standard deviation, greatest, smallest.

    The volume of information that the actual sequence of events generates means
    that it may only hold a second or two of information.  The statistical
    information should take in the whole run.  This means that information will
    be logged two ways.

    For the detailed record I log
        <incident, type, time>
    in a circular buffer and regularly over-write the oldest information.
    For the statistical information I record the informatin in an array, where
    the incident identifier is the index.  the array elements hold
        <Number of readings, sum, sum of squares, largest, smallest, latest>
    The readings are differences (start..next or start..stop).  This means that
    the actual number of Noted events will be one more than the number of
    "readings", whereas for Start-Stop events they will be equal.  To fix this,
    the number of readings is articifially initialised to -1.  If Start sees
    this number it resets it to 0.

    Times will be in tens of microseconds (this allows up to about 1 3/4 hrs)

    The statistics array will have room for up to 128 types of incident (this is
    4K - i.e. one page.  I hope this will ensure that it never gets
    paged out and so causes negligible overhead.
*/
#include <Windows.h>        // BOOL etc
#include <limits.h>         // for INTT_MAX
#include <math.h>           // for sqrt
#include <stdio.h>          // for sprintf

#include "Measure.h"
#include "Perf.h"           // ultra fast QueryPerformanceCounter for pentium

// forwards


enum {START, STOP, NOTE, RESET, INTGR, PAUSE, RUN};  // values for Type field

typedef struct {
    LONGLONG Time;         // microsec since class construction
    int      Id;
    int      Type;
    int      n;            // the integer for Msr_Integer
} LogDatum;


typedef struct {
    LONGLONG Latest;       // microsec since class construction
    LONGLONG SumSq;        // sum of squares of entries for this incident
    int      Largest;      // tenmicrosec
    int      Smallest;     // tenmicrosec
    int      Sum;          // sum of entries for this incident
    int      Number;       // number of entries for this incident
                           // for Start/Stop it counts the stops
                           // for Note it counts the intervals (Number of Notes-1)
    int      iType;        // STOP, NOTE, INTGR
} Stat;


#define MAXLOG 4096
static BOOL bInitOk;          // Set to true once initialised
static LogDatum Log[MAXLOG];  // 64K circular buffer
static int NextLog;           // Next slot to overwrite in the log buffer.
static BOOL bFull;            // TRUE => buffer has wrapped at least once.
static BOOL bPaused;          // TRUE => do not record.  No log, no stats.

#define MAXSTAT 128
static Stat StatBuffer[MAXSTAT];
static int NextStat;             // next free slot in StatBuffer.

static LPTSTR Incidents[MAXSTAT];// Names of incidents
static LONGLONG QPFreq;
static LONGLONG QPStart;         // base time in perf counts
#ifdef DEBUG
static LONGLONG tLast;           // last time - looks for going backwards
#endif

static CRITICAL_SECTION CSMeasure;         // Controls access to list

// set it to 100000 for 10 microsecs
// if you fiddle with it then you have to rewrite Format.
#define UNIT 100000

// Times are printed as 9 digits - this means that we can go
// up to 9,999.999,99 secs or about 2 and 3/4 hours.


// ASSERT(condition, msg) e.g. ASSERT(x>1, "Too many xs");
#define ASSERT(_cond_, _msg_)                                         \
        if (!(_cond_)) Assert(_msg_, __FILE__, __LINE__)

// print out debug message box
void Assert( const CHAR *pText
           , const CHAR *pFile
           , INT        iLine
           )
{
    CHAR Buffer[200];

    sprintf(Buffer, "%s\nAt line %d file %s"
           , pText, iLine, pFile);

    INT MsgId = MessageBox( NULL, Buffer, TEXT("ASSERT Failed")
                          , MB_SYSTEMMODAL |MB_ICONHAND |MB_ABORTRETRYIGNORE);
    switch (MsgId)
    {
        case IDABORT:           /* Kill the application */

            FatalAppExit(FALSE, TEXT("Application terminated"));
            break;

        case IDRETRY:           /* Break into the debugger */
            DebugBreak();
            break;

        case IDIGNORE:          /* Ignore assertion continue executing */
            break;
        }
} // Assert



//=============================================================================
//
// Init
//
// Call this first.
//=============================================================================
void WINAPI Msr_Init()
{
    // I would like this to be idempotent - that is, harmless if it
    // gets called more than once.  However that's not 100% possible
    // At least we should be OK so long as it's not re-entered.

    if (!bInitOk) {
        bInitOk = TRUE;
        InitializeCriticalSection(&CSMeasure);
        NextLog = 0;
        bFull = FALSE;
        NextStat = 0;
        LARGE_INTEGER li;
        QUERY_PERFORMANCE_FREQUENCY(&li);
        QPFreq = li.QuadPart;
        QUERY_PERFORMANCE_COUNTER(&li);
        QPStart = li.QuadPart;
#ifdef DEBUG
        tLast = 0L;
#endif

        Msr_Register("Scratch pad");
    }
} // Msr_Init  "constructor"



//=============================================================================
//
// ResetAll
//
// Do a Reset on every Incident that has been registered.
//=============================================================================
void WINAPI ResetAll()
{
    EnterCriticalSection(&CSMeasure);
    int i;
    for (i = 0; i<NextStat; ++i) {
        Msr_Reset(i);
    }
    LeaveCriticalSection(&CSMeasure);
} // ResetAll



//=============================================================================
//
// Pause
//
// Pause it all
//=============================================================================
void Pause()
{
    if (!bInitOk) Msr_Init();
    EnterCriticalSection(&CSMeasure);

    bPaused = TRUE;

    // log a PAUSE event for this id.
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;

    Log[NextLog].Time = Tim;
    Log[NextLog].Type = PAUSE;
    Log[NextLog].Id   = -1;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    LeaveCriticalSection(&CSMeasure);

} // Pause



//=============================================================================
//
// Run
//
// Set it all running again
//=============================================================================
void Run()
{

    if (!bInitOk) Msr_Init();
    EnterCriticalSection(&CSMeasure);

    bPaused = FALSE;

    // log a RUN event for this id.
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;

    Log[NextLog].Time = Tim;
    Log[NextLog].Type = RUN;
    Log[NextLog].Id   = -1;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    LeaveCriticalSection(&CSMeasure);

} // Run



//=============================================================================
//
// Msr_Control
//
// Do ResetAll, set bPaused to FALSE or TRUE according to iAction
//=============================================================================
void WINAPI Msr_Control(int iAction)
{
   switch (iAction) {
      case MSR_RESET_ALL:
          ResetAll();
          break;
      case MSR_RUN:
          Run();
          break;
      case MSR_PAUSE:
          Pause();
          break;
   }
} // Msr_Control



//=============================================================================
//
// Terminate
//
// Call this last.  It frees storage for names of incidents.
//=============================================================================
void WINAPI Msr_Terminate()
{
    int i;
    if (bInitOk) {
        EnterCriticalSection(&CSMeasure);
        for (i = 0; i<NextStat; ++i) {
            free(Incidents[i]);
        }
        bInitOk = FALSE;
        LeaveCriticalSection(&CSMeasure);
        DeleteCriticalSection(&CSMeasure);
    }
} // Msr_Terminate  "~Measure"



//=============================================================================
//
// InitIncident
//
// Reset the statistical counters for this incident.
//=============================================================================
void InitIncident(int Id)
{
    StatBuffer[Id].Latest = -1;      // recogniseably odd (see STOP)
    StatBuffer[Id].Largest = 0;
    StatBuffer[Id].Smallest = INT_MAX;
    StatBuffer[Id].Sum = 0;
    StatBuffer[Id].SumSq = 0;
    StatBuffer[Id].Number = -1;
    StatBuffer[Id].iType = NOTE;     // reset on first Start for Start/Stop
                                     // reset on first Integer for INTGR

} // InitIncident


//=============================================================================
//
// Register
//
// Register a new kind of incident.  The id that is returned can then be used
// on calls to Start, Stop and Note to record the occurrences of these incidents
// so that statistical performance information can be dumped later.
//=============================================================================
int Msr_Register(LPTSTR Incident)
{

    if (!bInitOk) {
        Msr_Init();
    }
    // it's now safe to enter the critical section as it will be there!
    EnterCriticalSection(&CSMeasure);

    int i;
    for (i = 0; i<NextStat; ++i) {
        if (0==strcmp(Incidents[i],Incident) ) {
            // Attempting to re-register the same name.
            // Possible actions
            // 1. ASSERT - that just causes trouble.
            // 2. Register it as a new incident.  That produced quartz bug 1
            // 3. Hand the old number back and reset it.
            //    Msr_Reset(i); - possible, but not today.
            // 4. Hand the old number back and just keep going.

            LeaveCriticalSection(&CSMeasure);
            return i;
        }
    }
    if (NextStat==MAXSTAT-1) {
        Assert("Too many types of incident\n(ignore is safe)", __FILE__, __LINE__);
        LeaveCriticalSection(&CSMeasure);
        return -1;
    }

    Incidents[NextStat] = (LPTSTR)malloc(strlen(Incident)+1);
    strcpy(Incidents[NextStat], Incident);

    InitIncident(NextStat);

    LeaveCriticalSection(&CSMeasure);
    return NextStat++;

} // Msr_Register



//=============================================================================
//
// Reset
//
// Reset the statistical counters for this incident.
// Log that we did it.
//=============================================================================
void WINAPI Msr_Reset(int Id)
{
    if (!bInitOk) {
        Msr_Init();
    }
    // it's now safe to enter the critical section as it will be there!

    EnterCriticalSection(&CSMeasure);

    // log a RESET event for this id.
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;

    Log[NextLog].Time = Tim;
    Log[NextLog].Type = RESET;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    InitIncident(Id);

    LeaveCriticalSection(&CSMeasure);

} // Msr_Reset


//=============================================================================
//
// Msr_Start
//
// Record the start time of the event with registered id Id.
// Add it to the circular Log and record the time in StatBuffer.
// Do not update the statistical information, that happens when Stop is called.
//=============================================================================
void WINAPI Msr_Start(int Id)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }
    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = START;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    StatBuffer[Id].Latest = Tim;

    if (StatBuffer[Id].Number == -1) {
        StatBuffer[Id].Number = 0;
        StatBuffer[Id].iType = STOP;
    }
    LeaveCriticalSection(&CSMeasure);

} // Msr_Start


//=============================================================================
//
// Msr_Stop
//
// Record the stop time of the event with registered id Id.
// Add it to the circular Log and
// add (StopTime-StartTime) to the statistical record StatBuffer.
//=============================================================================
void WINAPI Msr_Stop(int Id)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs, then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = STOP;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    if (StatBuffer[Id].Latest!=-1) {
        int t = (int)(Tim - StatBuffer[Id].Latest);     // convert to delta
        // this is now OK for almost 6hrs since the last Start of this quantity.

        if (t > StatBuffer[Id].Largest) StatBuffer[Id].Largest = t;
        if (t < StatBuffer[Id].Smallest) StatBuffer[Id].Smallest = t;
        StatBuffer[Id].Sum += t;
        LONGLONG lt = t;
        StatBuffer[Id].SumSq += lt*lt;
        ++StatBuffer[Id].Number;
    }
    LeaveCriticalSection(&CSMeasure);

} // Msr_Stop


//=============================================================================
//
// Msr_Note
//
// Record the event with registered id Id.  Add it to the circular Log and
// add (ThisTime-PreviousTime) to the statistical record StatBuffer
//=============================================================================
void WINAPI Msr_Note(int Id)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }

    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = NOTE;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }
    int t = (int)(Tim - StatBuffer[Id].Latest);     // convert to delta
    // this is now OK for nearly 6 hrs since the last Note of this quantity.

    StatBuffer[Id].Latest = Tim;
    ++StatBuffer[Id].Number;
    if (StatBuffer[Id].Number>0) {
        if (t > StatBuffer[Id].Largest) StatBuffer[Id].Largest = t;
        if (t < StatBuffer[Id].Smallest) StatBuffer[Id].Smallest = t;
        StatBuffer[Id].Sum += (int)t;
        LONGLONG lt = t;
        StatBuffer[Id].SumSq += lt*lt;
    }
    LeaveCriticalSection(&CSMeasure);

} // Msr_Note


//=============================================================================
//
// Msr_Integer
//
// Record the event with registered id Id.  Add it to the circular Log and
// add (ThisTime-PreviousTime) to the statistical record StatBuffer
//=============================================================================
void WINAPI Msr_Integer(int Id, int n)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }

    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = INTGR;
    Log[NextLog].Id   = Id;
    Log[NextLog].n    = n;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    // StatBuffer[Id].Latest = garbage for Intgr

    if (StatBuffer[Id].Number == -1) {
        StatBuffer[Id].Number = 0;
        StatBuffer[Id].iType = INTGR;
    }
    ++StatBuffer[Id].Number;
    if (n > StatBuffer[Id].Largest) StatBuffer[Id].Largest = n;
    if (n < StatBuffer[Id].Smallest) StatBuffer[Id].Smallest = n;
    StatBuffer[Id].Sum += (int)n;
    LONGLONG ln = n;
    StatBuffer[Id].SumSq += ln*ln;

    LeaveCriticalSection(&CSMeasure);

} // Msr_Integer


//=============================================================================
//
// TypeName
//
// Convert the type code into readable format
//=============================================================================
const LPTSTR TypeName(int Type)
{
    switch(Type){
    case START: return "START";
    case STOP:  return "STOP ";
    case NOTE:  return "NOTE ";
    case RESET: return "RESET";
    case INTGR: return "INTGR";
    case PAUSE: return "PAUSE";
    case RUN:   return "RUN  ";
    default:    return "DUNNO";
    }

} // TypeName


//==============================================================================
//
// Format
//
// I haven't found any way to get sprintf to format integers as
//      1,234.567.89 - so this does it.  (that's 12 spaces)
// All times are in tens of microsecs - so they are formatted as
// n,nnn.mmm,mm - this uses 12 spaces.
// The result that it returns points to Buff - it doesn't allocate any storage
// i must be positive.  Negative numbers are not handled (the pain of the floating
// minus sign is the reason - i.e. "     -12,345" not "-     12,345"
//==============================================================================
LPTSTR Format( LPTSTR Buff, int i)
{
    if (i<0) {
        sprintf(Buff, "    -.      ");
        return Buff;
    }
    BOOL bStarted;  // TRUE means that some left part of the number has been
                    // formatted and so we must continue with zeros not spaces
    if (i>999999999) {
        sprintf(Buff, " ***large***");
        return Buff;
    }

    if (i>99999999) {
        sprintf(Buff, "%1d,", i/100000000);
        i = i%100000000;
        bStarted = TRUE;
    } else {
        sprintf(Buff, "  ");
        bStarted = FALSE;
    }

    if (bStarted) {
        sprintf(Buff, "%s%03d.", Buff, i/100000);
        i = i%100000;
    } else {
        sprintf(Buff, "%s%3d.", Buff,i/100000);
        i = i%100000;
    }

    sprintf(Buff, "%s%03d,%02d", Buff, i/100, i%100);

    return Buff;
} // Format


//=============================================================================
//
// WriteOut
//
// If hFile==NULL then write str to debug output, else write it to file hFile
//
//=============================================================================
void WriteOut(HANDLE hFile, LPSTR str)
{
    if (hFile==NULL) {
        OutputDebugString(str);
    } else {
        DWORD dw;
        WriteFile(hFile, str, lstrlen(str), &dw, NULL);
    }
} // WriteOut


typedef LONGLONG longlongarray[MAXSTAT];


//=============================================================================
//
// WriteLogEntry
//
// If hFile==NULL then write to debug output, else write to file hFile
// write the ith entry of Log in a readable format
//
//=============================================================================
void WriteLogEntry(HANDLE hFile, int i, longlongarray &Prev)
{
    // We have the problem of printing LONGLONGs and wsprintf (26/6/95)
    // doesn't like them - found out the hard way - Laurie.
    char Buffer[200];
    char s1[20];
    char s2[20];

    int Delta;  // time since previous interesting incident

    switch(Log[i].Type) {
       case START:
          Prev[Log[i].Id] = Log[i].Time;
          Delta = -2;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
       case STOP:
          if (Prev[Log[i].Id]==-1) {
              Delta = -2;
          } else {
              Delta = (int)(Log[i].Time - Prev[Log[i].Id]);
          }
          Prev[Log[i].Id] = -1;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
       case NOTE:
          if (Prev[Log[i].Id]==-1) {
              Delta = -2;
          } else {
              Delta = (int)(Log[i].Time - Prev[Log[i].Id]);
          }
          Prev[Log[i].Id] = Log[i].Time;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
       case INTGR:
          sprintf( Buffer, "%s  %5s %12d : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Log[i].n
                 , Incidents[Log[i].Id]
                 );
          break;
       case RESET:       // the delta for a reset will be length of run
       case PAUSE:
       case RUN:
          if ((Log[i].Id==-1)||(Prev[Log[i].Id]==-1)) {
              Delta = (int)(Log[i].Time);  // = time from start
          } else {
              Delta = (int)(Log[i].Time - Prev[Log[i].Id]);
          }
          if (Log[i].Id!=-1) Prev[Log[i].Id] = Log[i].Time;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
    }

    WriteOut(hFile, Buffer);

} // WriteLogEntry


//=============================================================================
//
// WriteLog
//
// Write the whole of Log out in readable format.
// If hFile==NULL then write to debug output, else write to hFile.
//=============================================================================
void WriteLog(HANDLE hFile)
{
    //LONGLONG Prev[MAXSTAT];  // previous values found in log
    longlongarray Prev;

    char Buffer[100];
    sprintf(Buffer, "  Time (sec)   Type        Delta  Incident_Name\r\n");
    WriteOut(hFile, Buffer);

    int i;

    // initialise Prev to recognisable odd values
    for (i = 0; i<MAXSTAT; ++i) {
        Prev[i] = -1;
    }

    if (bFull) {
        for(i = NextLog; i<MAXLOG; ++i) {
            WriteLogEntry(hFile, i, Prev);
        }
    }

    for(i = 0; i<NextLog; ++i) {
        WriteLogEntry(hFile, i, Prev);
    }

} // WriteLog


//=============================================================================
//
// WriteStats
//
// Write the whole of StatBuffer out in readable format.
// If hFile==NULL then write to DbgLog, else write to hFile.
//=============================================================================
void WriteStats(HANDLE hFile)
{
    char Buffer[200];
    char s1[20];
    char s2[20];
    char s3[20];
    char s4[20];
    sprintf( Buffer
           , "Number      Average       StdDev     Smallest      Largest Incident_Name\r\n"
           );
    WriteOut(hFile, Buffer);

    int i;
    for (i = 0; i<NextStat; ++i) {
        if (i==0 && StatBuffer[i].Number==0) {
            continue;   // no temp scribbles to report
        }
        double SumSq = (double)StatBuffer[i].SumSq;
        double Sum = StatBuffer[i].Sum;

        if (StatBuffer[i].iType==INTGR) {
            double Average;
            if (StatBuffer[i].Number<=0) {
                Average = 0;
            } else {
                Average = (double)StatBuffer[i].Sum / (double)StatBuffer[i].Number;
            }
            double Std;
            if (StatBuffer[i].Number<=1) Std = 0.0;
            Std = sqrt( ( (double)SumSq
                        - ( (double)(Sum * Sum)
                          / (double)StatBuffer[i].Number
                          )
                        )
                        / ((double)StatBuffer[i].Number-1.0)
                      );
            sprintf( Buffer
                   , "%6d %12.3f %12.3f %12d %12d : %s\r\n"
                   , StatBuffer[i].Number + (StatBuffer[i].iType==NOTE ? 1 : 0)
                   , Average
                   , Std
                   , StatBuffer[i].Smallest
                   , StatBuffer[i].Largest
                   , Incidents[i]
                   );
        } else {
            double StDev;
            int Avg;
            int Smallest;
            int Largest;

            // Calculate Standard Deviation
            if (StatBuffer[i].Number<=1) StDev = -2;
            else {
                StDev = sqrt( ( SumSq
                              - ( (Sum * Sum)
                                / StatBuffer[i].Number
                                )
                              )
                              / (StatBuffer[i].Number-1)
                            );
            }

            // Calculate average
            if (StatBuffer[i].Number<=0) {
                Avg = -2;
            } else {
                Avg = StatBuffer[i].Sum / StatBuffer[i].Number;
            }

            // Calculate smallest and largest
            if (StatBuffer[i].Number<=0) {
                Smallest = -2;
                Largest = -2;
            } else {
                Smallest = StatBuffer[i].Smallest;
                Largest =  StatBuffer[i].Largest;
            }
            sprintf( Buffer
                   , "%6d %s %s %s %s : %s\r\n"
                   , StatBuffer[i].Number + (StatBuffer[i].iType==NOTE ? 1 : 0)
                   , Format(s1, Avg )
                   , Format(s2, (int)StDev )
                   , Format(s3, Smallest )
                   , Format(s4, Largest )
                   , Incidents[i]
                   );
        }


        WriteOut(hFile, Buffer);
    }
    WriteOut(hFile, "Times such as 0.050,00 are in seconds (that was 1/20 sec) \r\n");
} // WriteStats


#if 0 // test format
void TestFormat(int n)
{
    char Buffer[50];
    char s1[20];
    sprintf(Buffer, ">%s<",Format(s1,n));
    DbgLog((LOG_TRACE, 0, Buffer));
} // TestFormat
#endif



//=====================================================================
//
// Dump
//
// Dump out all the results from Log and StatBuffer in readable format.
// If hFile is NULL then it uses DbgLog
// otherwise it prints it to that file
//=====================================================================
void Msr_Dump(HANDLE hFile)
{
    EnterCriticalSection(&CSMeasure);
    if (!bInitOk) {
        Msr_Init();  // of course the log will be empty - never mind!
    }

    WriteLog(hFile);
    WriteStats(hFile);

#if 0   // test Format
    TestFormat(1);
    TestFormat(12);
    TestFormat(123);
    TestFormat(1234);
    TestFormat(12345);
    TestFormat(123456);
    TestFormat(1234567);
    TestFormat(12345678);
    TestFormat(123456789);
    TestFormat(1234567890);
#endif

    LeaveCriticalSection(&CSMeasure);
} // Msr_Dump


//=====================================================================
//
// DumpStats
//
// Dump out all the results from Log and StatBuffer in readable format.
// If hFile is NULL then it uses DbgLog
// otherwise it prints it to that file
//=====================================================================
void WINAPI Msr_DumpStats(HANDLE hFile)
{
    EnterCriticalSection(&CSMeasure);
    if (!bInitOk) {
        Msr_Init();  // of course the stats will be empty - never mind!
    }
    WriteStats(hFile);

    LeaveCriticalSection(&CSMeasure);
} // Msr_DumpStats

extern "C" BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
    UNREFERENCED_PARAMETER(pv);
    switch (ulReason)
    {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);
        InitPerfCounter();
        Msr_Init();
        break;

    case DLL_PROCESS_DETACH:
        Msr_Terminate();
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\measure\perf.c ===
/******************************Module*Header*******************************\
* Module Name: Perf.c
*
* Performance counter functions.  Uses the Pentium performance counters
* if they are available, otherwise falls back to the system QueryPerformance
* api's.
*
* InitPerfCounter MUST be called before using the QUERY_PERFORMANCE_XXX macros
* as it initializes the two global functions pointers.
*
*
*
* Created: 13-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1995  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <windows.h>
#include "Perf.h"


PERFFUNCTION    lpQueryPerfCounter;
PERFFUNCTION    lpQueryPerfFreqency;

void
GetFrequencyEstimate(
    LARGE_INTEGER *li
    );


#ifdef TEST
#include <stdio.h>
/******************************Public*Routine******************************\
* main
*
* Program entry point.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
int __cdecl main( void )
{
    LARGE_INTEGER liP1;
    LARGE_INTEGER liP2;
    LARGE_INTEGER liPf;

    InitPerfCounter();

    QUERY_PERFORMANCE_FREQUENCY(&liPf);

    // Time a 50 milli second sleep
    QUERY_PERFORMANCE_COUNTER(&liP1);
    Sleep(50);
    QUERY_PERFORMANCE_COUNTER(&liP2);

    printf("Pentium counter frequency = %u\n", liPf.LowPart );
    printf("Pentium counter %#X%X - %#X%X = %u\n",
           liP2.HighPart, liP2.LowPart, liP1.HighPart, liP1.LowPart,
           liP2.LowPart - liP1.LowPart
           );

    printf("Time taken = %6.6f seconds\n",
           (double)(liP2.LowPart - liP1.LowPart) / (double)liPf.QuadPart);

    return 0;
}
#endif



/******************************Public*Routine******************************\
* InitPerfCounter
*
* Determine (at runtime) if it is possible to use the Pentium performance
* counter.  If it is not fall back to the system performance counter.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
InitPerfCounter(
    void
    )
{
    SYSTEM_INFO sysInfo;

    GetSystemInfo(&sysInfo);
    if (sysInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM) {
        lpQueryPerfFreqency = QueryPerfFrequency;
        lpQueryPerfCounter  = QueryPerfCounter;
    }
    else {
        lpQueryPerfFreqency = (PERFFUNCTION)QueryPerformanceFrequency;
        lpQueryPerfCounter  = (PERFFUNCTION)QueryPerformanceCounter;
    }
}


/******************************Public*Routine******************************\
* QueryPerfFrequency
*
* Determines the clock frequency of a (Pentium) microprocessor. Takes an
* averaged estimate of the clk frequency and then matches it to known
* Pentium clock frequencies.  Returns the estimate if a match is not found.
*
* This is an expensive call in cpu terms as it takes at least 16 milli seconds
* just to calculate an averaged estimate of the clock speed.  You only need
* to call this function once, make sure you don't call it more times.
*
* History:
* 13-10-95 - StephenE - Created
*
\**************************************************************************/
void WINAPI
QueryPerfFrequency(
    LARGE_INTEGER *li
    )
{
#ifdef _X86_
#define SAMPLE_SIZE     8

    LARGE_INTEGER   est;
    int             i;

    li->QuadPart = 0;
    for (i = 0; i < SAMPLE_SIZE; i++) {
        GetFrequencyEstimate(&est);
        li->QuadPart += est.QuadPart;
    }
    li->QuadPart /= SAMPLE_SIZE;

    //
    // At the moment Pentiums come in 60, 66, 75, 90, 100, 120 and 133 MHz
    // clock speeds.  So use the above estimation of the clock frequency
    // to determine the real clock frequency.
    //
    //  59Mhz to 61Mhz assume its a 60 Mhz
    if (li->QuadPart >= 59000000 && li->QuadPart < 61000000) {
        li->QuadPart = 60000000;

    }

    //  65Mhz to 67Mhz assume its a 66 Mhz
    else if (li->QuadPart >= 65000000 && li->QuadPart < 67000000) {
        li->QuadPart = 66000000;

    }

    //  74Mhz to 76Mhz assume its a 75 Mhz
    else if (li->QuadPart >= 74000000 && li->QuadPart < 76000000) {
        li->QuadPart = 75000000;

    }

    //  89Mhz to 91Mhz assume its a 90 Mhz
    else if (li->QuadPart >= 89000000 && li->QuadPart < 91000000) {
        li->QuadPart = 90000000;

    }

    //  99Mhz to 101Mhz assume its a 100 Mhz
    else if (li->QuadPart >= 99000000 && li->QuadPart < 101000000) {
        li->QuadPart = 100000000;

    }

    //  119Mhz to 121Mhz assume its a 120 Mhz
    else if (li->QuadPart >= 119000000 && li->QuadPart < 121000000) {
        li->QuadPart = 120000000;

    }
    //  132Mhz to 134Mhz assume its a 133 Mhz
    else if (li->QuadPart >= 132000000 && li->QuadPart < 134000000) {
        li->QuadPart = 133000000;
    }

    // if use our estimate.
#else
    li->QuadPart = -1;
#endif
}



/*****************************Private*Routine******************************\
* GetFrequencyEstimate
*
* Uses the system QueryPerformance counter to estimate the Pentium
* cpu clock * frequency
*
* History:
* 13-10-95 - StephenE - Created
*
\**************************************************************************/
void
GetFrequencyEstimate(
    LARGE_INTEGER *li
    )
{
    LARGE_INTEGER liP1;     // Pentium clk start
    LARGE_INTEGER liP2;     // Pentium clk end
    LARGE_INTEGER liS1;     // System clk end
    LARGE_INTEGER liS2;     // System clk end
    LARGE_INTEGER liSf;     // System clk frequency

    QueryPerformanceFrequency(&liSf);

    QueryPerformanceCounter(&liS1);
    QueryPerfCounter(&liP1);

    Sleep(2);         // Sleep for approx 2 milli- seconds

    QueryPerfCounter(&liP2);
    QueryPerformanceCounter(&liS2);

    //
    // Determine the time recorded by both clocks.
    //
    liP2.QuadPart = liP2.QuadPart - liP1.QuadPart;
    liS2.QuadPart = liS2.QuadPart - liS1.QuadPart;


    li->QuadPart = (liP2.QuadPart * liSf.QuadPart) / liS2.QuadPart;
}



/******************************Public*Routine******************************\
* QueryPerfCounter
*
* Query the internal clock counter on the Pentium, uses the undocumented
* rdtsc instruction, which copies the current 64 bit clock count into
* edx:eax.
*
* History:
* 13-10-95 - StephenE - Created
*
\**************************************************************************/
void WINAPI
QueryPerfCounter(
    LARGE_INTEGER *li
    )
{
#ifdef _X86_
    _asm    mov     ecx, dword ptr li           // copy li pointer value to ecx
    _asm    _emit   0x0f                        // opcode 0x0F31 is rdtsc
    _asm    _emit   0x31
    _asm    mov     dword ptr [ecx], eax        // save result in li->LowPart
    _asm    mov     dword ptr [ecx+4], edx      // and li->HighPart
#else
    ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\app.h ===
/******************************Module*Header*******************************\
* Module Name: app.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/




/* -------------------------------------------------------------------------
** Functions prototypes
** -------------------------------------------------------------------------
*/
int
DoMainLoop(
    void
    );

BOOL
InitApplication(
    HINSTANCE hInstance
    );

BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    );

BOOL
LoadWindowPos(
    LPRECT lprc
    );

BOOL
SaveWindowPos(
    HWND hwnd
    );

void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

void
UpdateMpegMovieRect(
    void
    );

void
GetAdjustedClientRect(
    RECT *prc
    );

BOOL
DrawStats(
    HDC hdc
    );

void
CalcMovieRect(
    LPRECT lprc
    );

LPCTSTR
IdStr(
    int idResource
    );

void
UpdateSystemColors(
    void
    );

#if 0
void
DrawShadowRect(
    HDC hdc,
    LPRECT lprc
    );
#endif

void
SetDurationLength(
    REFTIME rt
    );

void
SetCurrentPosition(
    REFTIME rt
    );

TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    );

void
DoMpegVideoPropertyPage();

void
DoMpegAudioPropertyPage();

/* -------------------------------------------------------------------------
** Registry stuff
** -------------------------------------------------------------------------
*/
int
ProfileIntIn(
   const TCHAR *szKey,
   int iDefault
   );

BOOL
ProfileIntOut(
   const TCHAR *szKey,
   int iDefault
   );

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    );

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    );

BOOL
LoadWindowPos(
    LPRECT lprc
    );

BOOL
SaveWindowPos(
    HWND hwnd
    );

HKEY
GetAppKey(
    BOOL fCreate
    );


/* -------------------------------------------------------------------------
** Message crackers
** -------------------------------------------------------------------------
*/
/* void Cls_OnUser(HWND hwnd, WPARAM wParam, LPARAM lParam ) */
#define HANDLE_WM_USER(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd, wParam, lParam), 0L)

#ifndef HANDLE_WM_NOTIFY
/* LRESULT Cls_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr); */
#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR FAR*)(lParam))
#endif



/* -------------------------------------------------------------------------
** VideoCd window class prototypes
** -------------------------------------------------------------------------
*/
extern "C" LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnClose(
    HWND hwnd
    );

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    );

void
VideoCd_OnDestroy(
    HWND hwnd
    );

void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

void
VideoCd_OnPaint(
    HWND hwnd
    );

void
VideoCd_OnTimer(
    HWND hwnd,
    UINT id
    );

BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    );

void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    );

void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    );

void
VideoCd_OnActivate(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnHScroll(
    HWND hwnd,
    HWND hwndCtl,
    UINT code,
    int pos
    );

void
VideoCd_OnUser(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnSysColorChange(
    HWND hwnd
    );

void
VideoCd_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    );

void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    );

#ifdef WM_NOTIFY
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    );
#endif


void
VideoCd_OnGraphNotify(
    void
    );

void
VideoCd_OnDropFiles(
    HWND hwnd,
    HDROP hdrop);

void
SetPlayButtonsEnableState(
    void
    );



/* -------------------------------------------------------------------------
** Command processing functions
** -------------------------------------------------------------------------
*/

BOOL
VcdPlayerSetLog(
    void
    );

BOOL
VcdPlayerSetPerfLogFile(
    void
    );

BOOL
VcdPlayerOpenCmd(
    void
    );

BOOL
VcdPlayerCloseCmd(
    void
    );

BOOL
VcdPlayerPlayCmd(
    void
    );

BOOL
VcdPlayerStopCmd(
    void
    );

BOOL
VcdPlayerPauseCmd(
    void
    );

BOOL
VcdPlayerPauseCmd(
    void
    );

void
VcdPlayerSeekCmd(
    REFTIME rtSeekBy
    );

void
ProcessOpen(
    TCHAR *achFileName,
    BOOL bPlay = FALSE
    );

int
VcdPlayerChangeTimeFormat(
    int id
    );


/* -------------------------------------------------------------------------
** Recent filename stuff
** -------------------------------------------------------------------------
*/
typedef TCHAR RECENTFILES[MAX_PATH];
#define MAX_RECENT_FILES    5
#define ID_RECENT_FILE_BASE 500

int
GetRecentFiles(
    int LastCount
    );

int
SetRecentFiles(
    TCHAR *FileName,
    int iCount
    );


/* -------------------------------------------------------------------------
** Global Variables
** -------------------------------------------------------------------------
*/
extern int              cxMovie;
extern int              cyMovie;
extern HWND             hwndApp;
extern HWND             g_hwndStatusbar;

extern int              cx;
extern int              cy;
extern int              xOffset;
extern int              yOffset;
extern TCHAR            g_achFileName[];
extern OPENFILENAME     ofn;
extern DWORD            g_State;
extern HANDLE           hRenderLog;
extern int              nRecentFiles;
extern LONG             lMovieOrgX, lMovieOrgY;
extern TCHAR            g_szPerfLog[];
extern int              g_TimeFormat;
extern BOOL             g_bUseThreadedGraph;




/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
#define LEFT_MARGIN 2



/* -------------------------------------------------------------------------
** Video CD Player states
**
**  These are bit flags
** -------------------------------------------------------------------------
*/

#define VCD_PLAYING          0x0001
#define VCD_STOPPED          0x0002
#define VCD_PAUSED           0x0004
#define VCD_SKIP_F           0x0008
#define VCD_SKIP_B           0x0010
#define VCD_FF               0x0020
#define VCD_RW               0x0040
#define VCD_SEEKING          (VCD_FF | VCD_RW)
#define VCD_LOADED           0x0080
#define VCD_NO_CD            0x0100
#define VCD_DATA_CD_LOADED   0x0200
#define VCD_EDITING          0x0400
#define VCD_PAUSED_AND_MOVED 0x0800
#define VCD_PLAY_PENDING     0x1000
#define VCD_WAS_PLAYING      0x2000
#define VCD_IN_USE           0x4000

enum {PerformanceTimer = 32, StatusTimer = 33};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\measure\perf.h ===
/******************************Module*Header*******************************\
* Module Name: Perf.h
*
* Performance counter functions.  Uses the Pentium performance counters
* if they are available, otherwise falls back to the system QueryPerformance
* api's.
*
* InitPerfCounter MUST be called before using the QUERY_PERFORMANCE_XXX macros
* as it initializes the two global functions pointers.
*
*
* Created: 13-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
#ifndef _PERF_
#define _PERF_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

void
InitPerfCounter(
    void
    );

void
QueryPerfCounter(
    LARGE_INTEGER *li
    );

void
QueryPerfFrequency(
    LARGE_INTEGER *li
    );


typedef void (WINAPI* PERFFUNCTION)(LARGE_INTEGER *li);
extern PERFFUNCTION    lpQueryPerfCounter;
extern PERFFUNCTION    lpQueryPerfFreqency;

#define QUERY_PERFORMANCE_FREQUENCY(x)  (*lpQueryPerfFreqency)(x)
#define QUERY_PERFORMANCE_COUNTER(x)    (*lpQueryPerfCounter)(x)

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* !_PERF_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\commands.cpp ===
/******************************Module*Header*******************************\
* Module Name: commands.cpp
*
*  Processes commands from the user.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"
#include <stdio.h>


BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen);

extern CMpegMovie *pMpegMovie;

/******************************Public*Routine******************************\
* VcdPlayerOpenCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerOpenCmd(
    void
    )
{
    static BOOL fFirstTime = TRUE;
    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;

    if (fFirstTime) {

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = hwndApp;
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                    OFN_SHAREAWARE | OFN_PATHMUSTEXIST;
    }

    lstrcpy(achFilter, IdStr(STR_FILE_FILTER) );
    ofn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    ZeroMemory(achFileName, sizeof(achFileName));

    fRet = GetOpenFileName(&ofn);
    if ( fRet ) {

        fFirstTime = FALSE;
        ProcessOpen(achFileName);

    }

    return fRet;
}



/******************************Public*Routine******************************\
* VcdPlayerSetLog
*
*
*
* History:
* 11-04-94 - LaurieGr - Created
*
\**************************************************************************/
BOOL
VcdPlayerSetLog(
    void
    )
{

    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;
    OPENFILENAME opfn;

    ZeroMemory(&opfn, sizeof(opfn));

    opfn.lStructSize = sizeof(opfn);
    opfn.hwndOwner = hwndApp;
    opfn.Flags = OFN_HIDEREADONLY | OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    lstrcpy(achFilter, IdStr(STR_FILE_LOG_FILTER) );
    opfn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    opfn.lpstrFile = achFileName;
    opfn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    ZeroMemory(achFileName, sizeof(achFileName));

    fRet = GetOpenFileName(&opfn);
    if ( fRet ) {
        hRenderLog = CreateFile( achFileName
                               , GENERIC_WRITE
                               , 0    // no sharing
                               , NULL // no security
                               , OPEN_ALWAYS
                               , 0    // no attributes, no flags
                               , NULL // no template
                               );
        if (hRenderLog==INVALID_HANDLE_VALUE) {
            volatile int Err = GetLastError();
            fRet = FALSE;
        }
        // Seek to end of file
        SetFilePointer(hRenderLog, 0, NULL, FILE_END);
    }

    return fRet;
}

/******************************Public*Routine******************************\
* VcdPlayerSetPerfLogFile
*
*
*
* History:
* 30-05-96 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerSetPerfLogFile(
    void
    )
{

    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;
    OPENFILENAME opfn;

    ZeroMemory(&opfn, sizeof(opfn));

    opfn.lStructSize = sizeof(opfn);
    opfn.hwndOwner = hwndApp;
    opfn.Flags = OFN_HIDEREADONLY | OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    lstrcpy(achFilter, IdStr(STR_FILE_PERF_LOG) );
    opfn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    opfn.lpstrFile = achFileName;
    opfn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    lstrcpy(achFileName, g_szPerfLog);

    fRet = GetOpenFileName(&opfn);
    if ( fRet ) {
        lstrcpy(g_szPerfLog, achFileName);
    }

    return fRet;
}



/******************************Public*Routine******************************\
* VcdPlayerCloseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerCloseCmd(
    void
    )
{
    if (pMpegMovie) {

        LONG cx, cy;

        if (pMpegMovie->pMpegDecoder != NULL) {
            KillTimer(hwndApp, 32);
        }

        g_State = VCD_NO_CD;
        pMpegMovie->GetMoviePosition(&lMovieOrgX, &lMovieOrgY, &cx, &cy);
        pMpegMovie->CloseMovie();

        SetDurationLength((REFTIME)0);
        SetCurrentPosition((REFTIME)0);

        delete pMpegMovie;
        pMpegMovie = NULL;
    }
    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPlayCmd(
    void
    )
{
    BOOL fStopped = (g_State & VCD_STOPPED);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fStopped || fPaused) ) {

        HDC hdc;
        RECT rc;


        //
        // Clear out the old stats from the main window
        //
        hdc = GetDC(hwndApp);
        GetAdjustedClientRect(&rc);
        FillRect(hdc, &rc, (HBRUSH)(COLOR_BTNFACE + 1));
        ReleaseDC(hwndApp, hdc);

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~(fStopped ? VCD_STOPPED : VCD_PAUSED);
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerStopCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fPlaying || fPaused) ) {

        if (pMpegMovie) {
            pMpegMovie->StopMovie();
            pMpegMovie->SetFullScreenMode(FALSE);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
        }

        g_State &= ~(fPlaying ? VCD_PLAYING : VCD_PAUSED);
        g_State |= VCD_STOPPED;
    }
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPauseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPauseCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if (fPlaying) {

        if (pMpegMovie) {
            pMpegMovie->PauseMovie();
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
        }

        g_State &= ~VCD_PLAYING;
        g_State |= VCD_PAUSED;
    }
    else if (fPaused) {

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~VCD_PAUSED;
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* VcdPlayerSeekCmd
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
VcdPlayerSeekCmd(
    REFTIME rtSeekBy
    )
{
    REFTIME rt;
    REFTIME rtDur;

    rtDur = pMpegMovie->GetDuration();
    rt = pMpegMovie->GetCurrentPosition() + rtSeekBy;

    rt = max(0, min(rt, rtDur));

    pMpegMovie->SeekToPosition(rt,TRUE);
    SetCurrentPosition(pMpegMovie->GetCurrentPosition());
}


/******************************Public*Routine******************************\
* ProcessOpen
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
ProcessOpen(
    TCHAR *achFileName,
    BOOL bPlay
    )
{
    /*
    ** If we currently have a video loaded we need to discard it here.
    */
    if ( g_State & VCD_LOADED) {
        VcdPlayerCloseCmd();
    }

    lstrcpy(g_achFileName, achFileName);

    pMpegMovie = new CMpegMovie(hwndApp);
    if (pMpegMovie) {

        HRESULT hr = pMpegMovie->OpenMovie(g_achFileName);
        if (SUCCEEDED(hr)) {

            TCHAR achTmp[MAX_PATH];
            LONG  x, y, cx, cy;

            nRecentFiles = SetRecentFiles(achFileName, nRecentFiles);

            wsprintf( achTmp, IdStr(STR_APP_TITLE_LOADED),
                      g_achFileName );
            g_State = (VCD_LOADED | VCD_STOPPED);

            if (pMpegMovie->pMpegDecoder != NULL
             || pMpegMovie->pVideoRenderer != NULL) {
                SetTimer(hwndApp, PerformanceTimer, 1000, NULL);
            }

            // SetDurationLength(pMpegMovie->GetDuration());
            g_TimeFormat = VcdPlayerChangeTimeFormat(g_TimeFormat);

            pMpegMovie->GetMoviePosition(&x, &y, &cx, &cy);
            pMpegMovie->PutMoviePosition(lMovieOrgX, lMovieOrgY, cx, cy);
            pMpegMovie->SetWindowForeground(OATRUE);

            //  If play
            if (bPlay) {
                pMpegMovie->PlayMovie();
            }
        }
        else {
            TCHAR Buffer[MAX_ERROR_TEXT_LEN];

            if (GetAMErrorText(hr, Buffer, MAX_ERROR_TEXT_LEN)) {
                MessageBox( hwndApp, Buffer,
                            IdStr(STR_APP_TITLE), MB_OK );
            }
            else {
                MessageBox( hwndApp,
                            TEXT("Failed to open the movie; ")
                            TEXT("either the file was not found or ")
                            TEXT("the wave device is in use"),
                            IdStr(STR_APP_TITLE), MB_OK );
            }

            pMpegMovie->CloseMovie();
            delete pMpegMovie;
            pMpegMovie = NULL;
        }
    }

    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
}


/******************************Public*Routine******************************\
* VcdPlayerChangeTimeFormat
*
* Tries to change the time format to id.  Returns the time format that
* actually got set.  This may differ from id if the graph does not support
* the requested time format.
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/
int
VcdPlayerChangeTimeFormat(
    int id
    )
{
    // Menu items are disabled while we are playing

    BOOL    bRet = FALSE;
    int     idActual = id;

    ASSERT(pMpegMovie);
    ASSERT(pMpegMovie->StatusMovie() != MOVIE_NOTOPENED);

    // Change the time format with the filtergraph

    switch (id) {
    case IDM_FRAME:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_FRAME);
        break;

    case IDM_FIELD:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_FIELD);
        break;

    case IDM_SAMPLE:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_SAMPLE);
        break;

    case IDM_BYTES:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_BYTE);
        break;
    }

    if (!bRet) {
        // IDM_TIME and all other cases,  everyone should support IDM_TIME
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_MEDIA_TIME);
        ASSERT(bRet);
        idActual = IDM_TIME;
    }

    // Pause the movie to get a current position

    SetDurationLength(pMpegMovie->GetDuration());
    SetCurrentPosition(pMpegMovie->GetCurrentPosition());

    return idActual;
}


const TCHAR quartzdllname[] = TEXT("quartz.dll");
#ifdef UNICODE
const char  amgeterrorprocname[] = "AMGetErrorTextW";
#else
const char  amgeterrorprocname[] = "AMGetErrorTextA";
#endif

BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen)
{
    HMODULE hInst = GetModuleHandle(quartzdllname);
    if (hInst) {
        AMGETERRORTEXTPROC lpProc;
        *((FARPROC *)&lpProc) = GetProcAddress(hInst, amgeterrorprocname);
        if (lpProc) {
            return 0 != (*lpProc)(hr, Buffer, dwLen);
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\app.cpp ===
/******************************Module*Header*******************************\
* Module Name: app.cpp
*
* A simple Video CD player
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <atlbase.h>
#include <atlconv.cpp>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include <initguid.h>
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>

/* -------------------------------------------------------------------------
** Global variables that are initialized at run time and then stay constant.
** -------------------------------------------------------------------------
*/
HINSTANCE           hInst;
HICON               hIconVideoCd;
HWND                hwndApp;
HWND                g_hwndToolbar;
HWND                g_hwndStatusbar;
HWND                g_hwndTrackbar;
CMpegMovie          *pMpegMovie;
double              g_TrackBarScale = 1.0;
BOOL                g_bUseThreadedGraph;
BOOL                g_bPlay = FALSE;

int                 dyToolbar, dyStatusbar, dyTrackbar;

MSR_DUMPPROC        *lpDumpProc;
MSR_CONTROLPROC     *lpControlProc;
HINSTANCE           hInstMeasure;



/* -------------------------------------------------------------------------
** True Globals - these may change during execution of the program.
** -------------------------------------------------------------------------
*/
TCHAR               g_achFileName[MAX_PATH];
TCHAR               g_szPerfLog[MAX_PATH];
OPENFILENAME        ofn;
DWORD               g_State = VCD_NO_CD;
RECENTFILES         aRecentFiles[MAX_RECENT_FILES];
int                 nRecentFiles;
LONG                lMovieOrgX, lMovieOrgY;
int                 g_TimeFormat = IDM_TIME;
HANDLE              hRenderLog = INVALID_HANDLE_VALUE;
TCHAR *		    g_szOtherStuff;
BOOL                g_IsNT;


/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
const TCHAR szClassName[] = TEXT("SJE_VCDPlayer_CLASS");
const TCHAR g_szNULL[]    = TEXT("\0");
const TCHAR g_szEmpty[]   = TEXT("");
const TCHAR g_szMovieX[]  = TEXT("MovieOriginX");
const TCHAR g_szMovieY[]  = TEXT("MovieOriginY");

/*
** these values are defined by the UI gods...
*/
const int   dxBitmap        = 16;
const int   dyBitmap        = 15;
const int   dxButtonSep     = 8;
const TCHAR g_chNULL        = TEXT('\0');


const TBBUTTON tbButtons[DEFAULT_TBAR_SIZE] = {
    { IDX_SEPARATOR,    1,                    0,               TBSTYLE_SEP           },
    { IDX_1,            IDM_MOVIE_PLAY,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_2,            IDM_MOVIE_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_3,            IDM_MOVIE_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    2,                    0,               TBSTYLE_SEP           },
    { IDX_4,            IDM_MOVIE_PREVTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_5,            IDM_MOVIE_SKIP_BACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_6,            IDM_MOVIE_SKIP_FORE,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_7,            IDM_MOVIE_NEXTTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    3,                    0,               TBSTYLE_SEP           },
    { IDX_9,            IDM_PERF_NEW,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_10,           IDM_PERF_DUMP,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    4,                    0,               TBSTYLE_SEP           },
    { IDX_11,           IDM_FULL_SCREEN,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0, 0, 0, -1 }
};

const int CX_DEFAULT	      = 310;
const int CY_DEFAULT	      = 120;

const int CX_MOVIE_DEFAULT    = 352;
const int CY_MOVIE_DEFAULT    = 120;



/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLineOld,
    int nCmdShow
    )
{
    USES_CONVERSION;
    lstrcpy(g_szPerfLog, TEXT("c:\\perfdata.log"));
    LPTSTR lpCmdLine = A2T(lpCmdLineOld);

    if ( !hPrevInstance ) {
        if ( !InitApplication( hInstance ) ) {
            return FALSE;
        }
    }

    /*
    ** Perform initializations that apply to a specific instance
    */
    if ( !InitInstance( hInstance, nCmdShow ) ) {
        return FALSE;
    }

    /* Look for options */
    while (lpCmdLine && (*lpCmdLine == '-' || *lpCmdLine == '/')) {
        if (lpCmdLine[1] == 'T') {
            //  No threaded graph
            g_bUseThreadedGraph = TRUE;
            lpCmdLine += 2;
        } else if (lpCmdLine[1] == 'P') {
            g_bPlay = TRUE;
            lpCmdLine += 2;
        } else {
            break;
        }
        while (lpCmdLine[0] == ' ') {
            lpCmdLine++;
        }
    }


    if (lpCmdLine != NULL && lstrlen(lpCmdLine) > 0) {
        ProcessOpen(lpCmdLine, g_bPlay);
        SetPlayButtonsEnableState();
    }

    /*
    ** Acquire and dispatch messages until a WM_QUIT message is received.
    */
    return DoMainLoop();
}


/*****************************Private*Routine******************************\
* DoMainLoop
*
* Process the main message loop
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
DoMainLoop(
    void
    )
{
    MSG         msg;
    HANDLE      ahObjects[1];   // handles that need to be waited on
    const int   cObjects = 1;   // no of objects that we are waiting on
    HACCEL      haccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));

    //
    // message loop lasts until we get a WM_QUIT message
    // upon which we shall return from the function
    //

    for ( ;; ) {

        if (pMpegMovie != NULL) {
            ahObjects[0] = pMpegMovie->GetMovieEventHandle();
        }
        else {
            ahObjects[0] = NULL;
        }

        if (ahObjects[0] == NULL) {
            WaitMessage();
        }
        else {

            //
            // wait for any message sent or posted to this queue
            // or for a graph notification
            //
            DWORD result;

            result = MsgWaitForMultipleObjects(cObjects, ahObjects, FALSE,
                                               INFINITE, QS_ALLINPUT);
            if (result != (WAIT_OBJECT_0 + cObjects)) {

                if (result == WAIT_OBJECT_0) {
                    VideoCd_OnGraphNotify();
                }
                continue;
            }
        }

        //
        // When here, we either have a message or no event handle
        // has been created yet.
        //
        // read all of the messages in this next loop
        // removing each message as we read it
        //

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

            if (msg.message == WM_QUIT) {
                return (int) msg.wParam;
            }

            if (!TranslateAccelerator(hwndApp, haccel, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

} // DoMainLoop


//
// InitAboutString
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
TCHAR *InitAboutString()
{
    //
    // Find the version of this binary
    //
    TCHAR achFileName[128];
    if ( !GetModuleFileName(hInst, achFileName, sizeof(achFileName)) )
        return((TCHAR *)g_szEmpty);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return((TCHAR *)g_szEmpty);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return((TCHAR *)g_szEmpty);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind = FindFirstFile(achFileName, &FindFileData);
        ASSERT(hFind != INVALID_HANDLE_VALUE);
        FindClose(hFind);

        FILETIME ModTime = FindFileData.ftLastWriteTime;
        SYSTEMTIME SysTime;
        FileTimeToSystemTime(&ModTime,&SysTime);
        char szBuildDate[20];
        sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
              SysTime.wYear % 100, SysTime.wMonth, SysTime.wDay);
        strcat((LPSTR) lpvValue, szBuildDate);
    }

    TCHAR *szAbout = (TCHAR *) _strdup((LPSTR) lpvValue);

    LocalUnlock( hTemp );
    LocalFree( hTemp );

    return(szAbout);
}


/*****************************Private*Routine******************************\
* InitApplication(HANDLE)
*
* This function is called at initialization time only if no other
* instances of the application are running.  This function performs
* initialization tasks that can be done once for any number of running
* instances.
*
* In this case, we initialize a window class by filling out a data
* structure of type WNDCLASS and calling the Windows RegisterClass()
* function.  Since all instances of this application use the same window
* class, we only need to do this when the first instance is initialized.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitApplication(
    HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

    hInstMeasure = LoadLibraryA("measure.dll");
    if (hInstMeasure) {
        *(FARPROC *)&lpDumpProc = GetProcAddress(hInstMeasure, "Msr_Dump");
        *(FARPROC *)&lpControlProc = GetProcAddress(hInstMeasure, "Msr_Control");
    }

    /*
    ** Fill in window class structure with parameters that describe the
    ** main window.
    */
    hIconVideoCd     = LoadIcon( hInstance, MAKEINTRESOURCE(IDR_VIDEOCD_ICON) );

    wc.style         = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc   = VideoCdWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = hIconVideoCd;
    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName  = MAKEINTRESOURCE( IDR_MAIN_MENU);
    wc.lpszClassName = szClassName;

    OSVERSIONINFO OSVer;
    OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bRet = GetVersionEx((LPOSVERSIONINFO) &OSVer);
    ASSERT(bRet);

    g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    g_szOtherStuff = InitAboutString();

    /*
    ** Register the window class and return success/failure code.
    */
    return RegisterClass( &wc );

}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    )
{
    HWND    hwnd;
    RECT    rc;
    POINT   pt;

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    hInst = hInstance;

    if ( ! LoadWindowPos(&rc))
       rc.left = rc.top = CW_USEDEFAULT;

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateWindow( szClassName, IdStr(STR_APP_TITLE),
                         WS_THICKFRAME | WS_POPUP | WS_CAPTION  |
                         WS_SYSMENU | WS_MINIMIZEBOX,
                         rc.left, rc.top,
                         rc.right - rc.left, rc.bottom - rc.top,
                         NULL, NULL, hInstance, NULL );

    /*
    ** If window could not be created, return "failure"
    */
    if ( NULL == hwnd ) {
        return FALSE;
    }


    hwndApp = hwnd;
    nRecentFiles = GetRecentFiles(nRecentFiles);

    pt.x = lMovieOrgX =  ProfileIntIn(g_szMovieX, 0);
    pt.y = lMovieOrgY =  ProfileIntIn(g_szMovieY, 0);

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if (!SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, FALSE)) {
        rc.top = rc.left = 0;
        rc.right = 640;
        rc.bottom = 480;
    }

    if (!PtInRect(&rc, pt)) {
        lMovieOrgX = lMovieOrgY = 0L;
    }


    /*
    ** Make the window visible; update its client area; and return "success"
    */
    SetPlayButtonsEnableState();
    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    return TRUE;
}


/******************************Public*Routine******************************\
* VideoCdWndProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_CREATE,            VideoCd_OnCreate );
    HANDLE_MSG( hwnd, WM_PAINT,             VideoCd_OnPaint );
    HANDLE_MSG( hwnd, WM_COMMAND,           VideoCd_OnCommand );
    HANDLE_MSG( hwnd, WM_CLOSE,             VideoCd_OnClose );
    HANDLE_MSG( hwnd, WM_QUERYENDSESSION,   VideoCd_OnQueryEndSession );
    HANDLE_MSG( hwnd, WM_DESTROY,           VideoCd_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              VideoCd_OnSize );
    HANDLE_MSG( hwnd, WM_SYSCOLORCHANGE,    VideoCd_OnSysColorChange );
    HANDLE_MSG( hwnd, WM_MENUSELECT,        VideoCd_OnMenuSelect );
    HANDLE_MSG( hwnd, WM_INITMENUPOPUP,     VideoCd_OnInitMenuPopup );
    HANDLE_MSG( hwnd, WM_HSCROLL,           VideoCd_OnHScroll );
    HANDLE_MSG( hwnd, WM_TIMER,             VideoCd_OnTimer );
    HANDLE_MSG( hwnd, WM_NOTIFY,            VideoCd_OnNotify );
    HANDLE_MSG( hwnd, WM_DROPFILES,         VideoCd_OnDropFiles);
    HANDLE_MSG( hwnd, WM_KEYUP,             VideoCd_OnKeyUp);

    // Note: we do not use HANDLE_MSG here as we want to call
    // DefWindowProc after we have notifed the FilterGraph Resource Manager,
    // otherwise our window will not finish its activation process.

    case WM_ACTIVATE: VideoCd_OnActivate(hwnd, wParam, lParam);

	// IMPORTANT - let this drop through to DefWindowProc

    default:
        return DefWindowProc( hwnd, message, wParam, lParam );
    }

    return 0L;
}


/*****************************Private*Routine******************************\
* VideoCd_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    RECT rc;
    int Pane[2];

    InitCommonControls();

    /*
    ** Create the toolbar and statusbar.
    */
    g_hwndToolbar = CreateToolbarEx( hwnd,
                                     WS_VISIBLE | WS_CHILD |
                                     TBSTYLE_TOOLTIPS | CCS_NODIVIDER,
                                     ID_TOOLBAR, NUMBER_OF_BITMAPS,
                                     hInst, IDR_TOOLBAR, tbButtons,
                                     DEFAULT_TBAR_SIZE, dxBitmap, dyBitmap,
                                     dxBitmap, dyBitmap, sizeof(TBBUTTON) );

    if ( g_hwndToolbar == NULL ) {
        return FALSE;
    }


    g_hwndStatusbar = CreateStatusWindow( WS_VISIBLE | WS_CHILD | CCS_BOTTOM,
                                          TEXT("Example Text"),
                                          hwnd, ID_STATUSBAR );

    GetWindowRect(g_hwndToolbar, &rc);
    dyToolbar = rc.bottom - rc.top;

    GetWindowRect(g_hwndStatusbar, &rc);
    dyStatusbar = rc.bottom - rc.top;

    dyTrackbar = 30;

    GetClientRect(hwnd, &rc);
    Pane[0] = (rc.right - rc.left) / 2 ;
    Pane[1] = -1;
    SendMessage(g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)Pane);


    g_hwndTrackbar = CreateWindowEx(0, TRACKBAR_CLASS, TEXT("Trackbar Control"),
                                    WS_CHILD | WS_VISIBLE |
                                    TBS_AUTOTICKS | TBS_ENABLESELRANGE,
                                    LEFT_MARGIN, dyToolbar - 1,
                                    (rc.right - rc.left) - (2* LEFT_MARGIN),
                                    dyTrackbar, hwnd, (HMENU)ID_TRACKBAR,
                                    hInst, NULL);

    SetDurationLength((REFTIME)0);
    SetCurrentPosition((REFTIME)0);

    SetTimer(hwnd, StatusTimer, 500, NULL);

    if (g_hwndStatusbar == NULL || g_hwndTrackbar == NULL) {
        return FALSE;
    }

    // accept filemanager WM_DROPFILES messages
    DragAcceptFiles(hwnd, TRUE);

    return TRUE;
}

/*****************************Private*Routine******************************\
* VideoCd_OnActivate
*
*
*
* History:
* 18/9/1996 - SteveDav - Created
*
\**************************************************************************/

void
VideoCd_OnActivate(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )

{
    if ((UINT)LOWORD(wParam)) {
	// we are being activated - tell the Filter graph (for Sound follows focus)
        if (pMpegMovie) {
            pMpegMovie->SetFocus();
        }
    }
}

/*****************************Private*Routine******************************\
* VideoCd_OnKeyUp
*
*
*
* History:
* 23/3/1996 - AnthonyP - Created
*
\**************************************************************************/
void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    )
{
    // Catch escape sequences to stop fullscreen mode

    if (vk == VK_ESCAPE) {
        if (pMpegMovie) {
            pMpegMovie->SetFullScreenMode(FALSE);
            SetPlayButtonsEnableState();
        }
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnHScroll
*
*
*
* History:
* 11/3/1995 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnHScroll(
    HWND hwnd,
    HWND hwndCtl,
    UINT code,
    int pos
    )
{
    static BOOL fWasPlaying = FALSE;
    static BOOL fBeginScroll = FALSE;

    if (pMpegMovie == NULL) {
        return;
    }

    if (hwndCtl == g_hwndTrackbar) {

        REFTIME     rtCurrPos;
        REFTIME     rtTrackPos;
        REFTIME     rtDuration;

        pos = (int)SendMessage(g_hwndTrackbar, TBM_GETPOS, 0, 0);
        rtTrackPos = (REFTIME)pos * g_TrackBarScale;

        switch (code) {
        case TB_BOTTOM:
            rtDuration = pMpegMovie->GetDuration();
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtDuration - rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_TOP:
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(-rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_LINEDOWN:
            VcdPlayerSeekCmd(10.0);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_LINEUP:
            VcdPlayerSeekCmd(-10.0);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_ENDTRACK:
            fBeginScroll = FALSE;
            if (fWasPlaying) {
                VcdPlayerPauseCmd();
                fWasPlaying = FALSE;
            }
            break;

        case TB_THUMBTRACK:
            if (!fBeginScroll) {
                fBeginScroll = TRUE;
                fWasPlaying = (g_State & VCD_PLAYING);
                if (fWasPlaying) {
                    VcdPlayerPauseCmd();
                }
            }
        case TB_PAGEUP:
        case TB_PAGEDOWN:
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtTrackPos - rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;
        }
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnTimer
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnTimer(
    HWND hwnd,
    UINT id
    )
{
    HDC     hdc;

    if (pMpegMovie && pMpegMovie->StatusMovie() == MOVIE_PLAYING) {

        switch (id) {
        case StatusTimer:
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case PerformanceTimer:
            hdc = GetDC(hwnd);
            DrawStats(hdc);
            ReleaseDC(hwnd, hdc);
            break;
        }
    }
}


/*****************************Private*Routine******************************\
* DrawStats
*
* Gets some stats from the decoder and displays them on the display.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
DrawStats(
    HDC hdc
    )
{
    HFONT   hFont;

    TCHAR   Text[1024];
    TCHAR   szSurface[64];

    RECT    rc;

    DWORD   IFramesDecoded;
    DWORD   PFramesDecoded;
    DWORD   BFramesDecoded;
    DWORD   IFramesSkipped;
    DWORD   PFramesSkipped;
    DWORD   BFramesSkipped;

    DWORD   dwTotalFrames;
    DWORD   dwTotalDecoded;
    DWORD   dwSurface;

    int     cFramesDropped;
    int     cFramesDrawn;
    int     iAvgFrameRate;
    int     iAvgFrameRateFraction;
    int     iAvgFrameRateWhole;
    int     iJitter;
    int     iSyncAvg;
    int     iSyncDev;

    BOOL    fClipped;
    BOOL    fHalfWidth;

    if (pMpegMovie == NULL) {
        return FALSE;
    }

    GetAdjustedClientRect(&rc);
    hFont = (HFONT)SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));

    if (pMpegMovie->pMpegDecoder) {
        pMpegMovie->pMpegDecoder->get_OutputFormat(&dwSurface);
        pMpegMovie->pMpegDecoder->get_FrameStatistics(
                                           &IFramesDecoded, &PFramesDecoded,
                                           &BFramesDecoded, &IFramesSkipped,
                                           &PFramesSkipped, &BFramesSkipped);
    }
    else {
        IFramesDecoded = PFramesDecoded = BFramesDecoded = 0;
        IFramesSkipped = PFramesSkipped = BFramesSkipped = 0;
        dwSurface = MM_RGB8_DIB;
    }

    fClipped = ((dwSurface & MM_CLIPPED) == MM_CLIPPED);
    fHalfWidth = ((dwSurface & MM_HRESOLUTION) == MM_HRESOLUTION);

    dwSurface &= ~(MM_HRESOLUTION | MM_CLIPPED);
    switch (dwSurface) {

    case MM_NOCONV:
        lstrcpy(szSurface, TEXT("MM_NOCONV"));
        break;

    case MM_420PL:
        lstrcpy(szSurface, TEXT("MM_420PL"));
        break;

    case MM_420PL_:
        lstrcpy(szSurface, TEXT("MM_420PL_"));
        break;

    case MM_422PK:
        lstrcpy(szSurface, TEXT("MM_422PK"));
        break;

    case MM_422PK_:
        lstrcpy(szSurface, TEXT("MM_422PK_"));
        break;

    case MM_422SPK:
        lstrcpy(szSurface, TEXT("MM_422SPK"));
        break;

    case MM_422SPK_:
        lstrcpy(szSurface, TEXT("MM_422SPK_"));
        break;

    case MM_411PK:
        lstrcpy(szSurface, TEXT("MM_411PK"));
        break;

    case MM_410PL_:
        lstrcpy(szSurface, TEXT("MM_410PL_"));
        break;

    case MM_Y_DIB:
        lstrcpy(szSurface, TEXT("MM_Y_DIB"));
        break;

    case MM_RGB24_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB24_DIB"));
        break;

    case MM_RGB32_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB32_DIB"));
        break;

    case MM_RGB565_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB565_DIB"));
        break;

    case MM_RGB555_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB555_DIB"));
        break;

    case MM_RGB8_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB8_DIB"));
        break;

    case MM_Y_DDB:
        lstrcpy(szSurface, TEXT("MM_Y_DDB"));
        break;

    case MM_RGB24_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB24_DDB"));
        break;

    case MM_RGB32_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB32_DDB"));
        break;

    case MM_RGB565_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB565_DDB"));
        break;

    case MM_RGB555_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB555_DDB"));
        break;

    case MM_RGB8_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB8_DDB"));
        break;
    }

    if (fHalfWidth) {
        lstrcat(szSurface, TEXT(" Decimated"));
    }

    if (fClipped) {
        lstrcat(szSurface, TEXT(" Clipped"));
    }

    dwTotalDecoded = IFramesDecoded + PFramesDecoded + BFramesDecoded;
    dwTotalFrames  = IFramesSkipped + PFramesSkipped + BFramesSkipped
                     + dwTotalDecoded;


    if (pMpegMovie->pVideoRenderer) {

        pMpegMovie->pVideoRenderer->get_FramesDroppedInRenderer(&cFramesDropped);
        pMpegMovie->pVideoRenderer->get_FramesDrawn(&cFramesDrawn);
        pMpegMovie->pVideoRenderer->get_AvgFrameRate(&iAvgFrameRate);
        iAvgFrameRateWhole    = iAvgFrameRate / 100;
        iAvgFrameRateFraction = iAvgFrameRate % 100;
        pMpegMovie->pVideoRenderer->get_Jitter(&iJitter);
        pMpegMovie->pVideoRenderer->get_AvgSyncOffset(&iSyncAvg);
        pMpegMovie->pVideoRenderer->get_DevSyncOffset(&iSyncDev);
    }
    else {

        cFramesDropped = 0;
        cFramesDrawn = 0;
        iAvgFrameRate = 0;
        iAvgFrameRateWhole = 0;
        iAvgFrameRateFraction = 0;
        iJitter = 0;
        iSyncAvg = 0;
        iSyncDev = 0;
    }


    wsprintf(Text,
            TEXT("Decoded %08.8ld out of %08.8ld frames\r\n")
            TEXT("Proportion decoded = %d%%\r\n")
            TEXT("Avg Frame Rate = %d.%02d fps\r\n")
            TEXT("Frames drawn by renderer = %d\r\n")
            TEXT("Frames dropped by renderer = %d\r\n")
            TEXT("Frame jitter = %4d mSec\r\n")
            TEXT("Avg Sync Offset (neg = early) = %4d mSec\r\n")
            TEXT("Std Dev Sync Offset = %4d mSec\r\n")
            TEXT("Surface type = %s\r\n")
            TEXT("I Frames: Decoded %8.8ld Skipped %8.8ld\r\n")
            TEXT("P Frames: Decoded %8.8ld Skipped %8.8ld\r\n")
            TEXT("B Frames: Decoded %8.8ld Skipped %8.8ld\r\n"),
             dwTotalDecoded, dwTotalFrames,
             (100 * dwTotalDecoded) / (dwTotalFrames ? dwTotalFrames : 1),
             iAvgFrameRateWhole, iAvgFrameRateFraction,
             cFramesDrawn, cFramesDropped,
             iJitter, iSyncAvg, iSyncDev,
             szSurface,
             IFramesDecoded, IFramesSkipped,
             PFramesDecoded, PFramesSkipped,
             BFramesDecoded, BFramesSkipped);

    COLORREF clr = SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    DrawText(hdc, Text, -1, &rc, DT_LEFT | DT_BOTTOM);
    SetBkColor(hdc, clr);

    SelectObject(hdc, hFont);
    return TRUE;
}


/*****************************Private*Routine******************************\
* VideoCd_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT        rc;

    /*
    ** Draw a frame around the movie playback area.
    */
    hdc = BeginPaint( hwnd, &ps );
    if (!DrawStats(hdc)) {
        GetClientRect(hwnd, &rc);
        FillRect(hdc, &rc, (HBRUSH)(COLOR_BTNFACE + 1));
    }
    EndPaint( hwnd, &ps );
}


/*****************************Private*Routine******************************\
* VideoCd_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch (id) {

    case IDM_FILE_SET_LOG:
        VcdPlayerSetLog();    // set RenderFile log
        break;

    case IDM_FILE_SET_PERF_LOG:
        VcdPlayerSetPerfLogFile();    // set perf log
        break;

    case IDM_FILE_OPEN:
        VcdPlayerOpenCmd();
        break;

    case IDM_FILE_CLOSE:
        VcdPlayerCloseCmd();
        QzFreeUnusedLibraries();
        break;

    case IDM_FILE_EXIT:
        PostMessage( hwnd, WM_CLOSE, 0, 0L );
        break;

    case IDM_MOVIE_PLAY:
        VcdPlayerPlayCmd();
        break;

    case IDM_MOVIE_STOP:
        VcdPlayerStopCmd();
        break;

    case IDM_MOVIE_PAUSE:
        VcdPlayerPauseCmd();
        break;

    case IDM_MOVIE_SKIP_FORE:
        VcdPlayerSeekCmd(1.0);
        break;

    case IDM_MOVIE_SKIP_BACK:
        VcdPlayerSeekCmd(-1.0);
        break;

    case IDM_MOVIE_PREVTRACK:
        if (pMpegMovie) {
            VcdPlayerSeekCmd(-pMpegMovie->GetCurrentPosition());
        }
        break;

    case IDM_TIME:
    case IDM_FRAME:
    case IDM_FIELD:
    case IDM_SAMPLE:
    case IDM_BYTES:
        if (pMpegMovie) {
            g_TimeFormat = VcdPlayerChangeTimeFormat(id);
        }
        break;

    case IDM_MOVIE_NEXTTRACK:
        if (pMpegMovie) {
            REFTIME rtDur = pMpegMovie->GetDuration();
            REFTIME rtPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtDur - rtPos);
        }
        break;

    case IDM_PERF_NEW:
        if (lpControlProc) (*lpControlProc)(MSR_RESET_ALL);
        break;

    case IDM_PERF_DUMP:
        if (lpDumpProc) {

            HANDLE hFile;
            hFile = CreateFile(g_szPerfLog, GENERIC_WRITE, 0, NULL,
                               CREATE_ALWAYS, 0, NULL);
            (*lpDumpProc)(hFile);
            CloseHandle(hFile);
        }
        break;

    case IDM_FULL_SCREEN:
        if (pMpegMovie) {
            BOOL bFullScreen = (BOOL) SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED, IDM_FULL_SCREEN, 0 );
            pMpegMovie->SetFullScreenMode(bFullScreen);
        }
        break;

    case IDM_VIDEO_DECODER:
        DoMpegVideoPropertyPage();
        break;

    case IDM_AUDIO_DECODER:
        DoMpegAudioPropertyPage();
        break;

    case IDM_FILTERS:
        if (pMpegMovie) {
            pMpegMovie->ConfigDialog(hwnd);
        }
        break;

    case IDM_MOVIE_ALIGN:
        {
            RECT rc, rcWnd;
            HWND hwndRenderer = FindWindow(TEXT("VideoRenderer"), NULL);
            if (hwndRenderer) {
                GetClientRect(hwndRenderer, &rc);
                GetWindowRect(hwndRenderer, &rcWnd);

                MapWindowPoints(hwndRenderer, HWND_DESKTOP, (LPPOINT)&rc, 2);
                rcWnd.left -= rc.left & 3;
                rcWnd.top  -= rc.top  & 3;

                SetWindowPos(hwndRenderer, NULL, rcWnd.left, rcWnd.top, 0, 0,
                             SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;

    case IDM_HELP_ABOUT:
        {
            TCHAR  szApp[STR_MAX_STRING_LEN];
            TCHAR  szOtherStuff[STR_MAX_STRING_LEN];

            lstrcpy( szApp, IdStr(STR_APP_TITLE) );
            lstrcat( szApp, TEXT("#") );
            if (g_IsNT)
		lstrcat( szApp, TEXT("Windows NT") );
	    // for some reason ShellAbout prints OS uner Win95 but not NT
	    // else
	    //	strcat( szApp, "Windows 95" );
            lstrcpy( szOtherStuff, IdStr(STR_APP_TITLE) );
            lstrcat( szOtherStuff, TEXT("\n") );
            lstrcat( szOtherStuff, g_szOtherStuff );
            ShellAbout( hwnd, szApp, szOtherStuff, hIconVideoCd );
        }
        break;

    default:
        if (id > ID_RECENT_FILE_BASE
         && id <= (ID_RECENT_FILE_BASE + MAX_RECENT_FILES + 1)) {

            ProcessOpen(aRecentFiles[id - ID_RECENT_FILE_BASE - 1]);
        } else if (id >= 2000 && id <= 2050) {
	    pMpegMovie->SelectStream(id - 2000);
	}
	break;
	
    }

    SetPlayButtonsEnableState();
}




/******************************Public*Routine******************************\
* VideoCd_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnDestroy(
    HWND hwnd
    )
{
    PostQuitMessage( 0 );
}




/******************************Public*Routine******************************\
* VideoCd_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnClose(
    HWND hwnd
    )
{

    // stop accepting dropped filenames
    DragAcceptFiles(hwnd, FALSE);

    VcdPlayerCloseCmd();
    ProfileIntOut(g_szMovieX, lMovieOrgX);
    ProfileIntOut(g_szMovieY, lMovieOrgY);

    SaveWindowPos( hwnd );
    DestroyWindow( hwnd );
}

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    )
{
    SaveWindowPos( hwnd );
    return TRUE;
}


/******************************Public*Routine******************************\
* VideoCd_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int dx,
    int dy
    )
{
    if (IsWindow(g_hwndStatusbar)) {

        int Pane[2] = {dx/2-8, -1};

        SendMessage(g_hwndStatusbar, WM_SIZE, 0, 0L);
        SendMessage(g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)Pane);
    }

    if (IsWindow(g_hwndTrackbar)) {
        SetWindowPos(g_hwndTrackbar, HWND_TOP, LEFT_MARGIN, dyToolbar - 1,
                     dx - (2 * LEFT_MARGIN), dyTrackbar, SWP_NOZORDER );
    }

    if (IsWindow(g_hwndToolbar)) {
        SendMessage( g_hwndToolbar, WM_SIZE, 0, 0L );
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnSysColorChange
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSysColorChange(
    HWND hwnd
    )
{
    FORWARD_WM_SYSCOLORCHANGE(g_hwndToolbar, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(g_hwndStatusbar, SendMessage);
}




/*****************************Private*Routine******************************\
* VideoCd_OnInitMenuPopup
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    )
{
    UINT uFlags;

    switch (item) {

    case 0: // File menu
        if (g_State & (VCD_IN_USE | VCD_NO_CD | VCD_DATA_CD_LOADED)) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_CLOSE, uFlags );

        if (lpControlProc == NULL) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_SET_PERF_LOG, uFlags );
        break;

    case 1: // Properties menu
        if (pMpegMovie && pMpegMovie->pMpegDecoder) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_VIDEO_DECODER, uFlags );

        if (pMpegMovie && pMpegMovie->pMpegAudioDecoder) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_AUDIO_DECODER, uFlags );

        if (pMpegMovie) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FILTERS, uFlags );
        break;

    case 2: // Time formats menu

        // Can only change time format when stopped
    {
        EMpegMovieMode State = MOVIE_NOTOPENED;
        if (pMpegMovie) {
            State = pMpegMovie->StatusMovie();
        }
	

        if (State && pMpegMovie->IsTimeSupported()) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_TIME, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_FRAME)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FRAME, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_FIELD)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FIELD, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_SAMPLE)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_SAMPLE, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_BYTE)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_BYTES, uFlags );

        CheckMenuItem(hMenu, IDM_BYTES, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_SAMPLE, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_FRAME, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_FIELD, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_TIME, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, g_TimeFormat, MF_BYCOMMAND | MF_CHECKED);
    }
	break;
	
    case 3: // streams menu

	if (pMpegMovie && pMpegMovie->m_pStreamSelect) {
	    DWORD	cStreams;

	    pMpegMovie->m_pStreamSelect->Count(&cStreams);

	    for (DWORD i = 0; i < cStreams; i++) {
		DWORD dwFlags;
		
		pMpegMovie->m_pStreamSelect->Info(i, NULL, &dwFlags, NULL, NULL, NULL, NULL, NULL);

		CheckMenuItem(hMenu, 2000+i, MF_BYCOMMAND |
			      ((dwFlags & AMSTREAMSELECTINFO_ENABLED) ? MF_CHECKED : MF_UNCHECKED));
	    }
	}
	
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnGraphNotify
*
* This is where we get any notifications from the filter graph.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnGraphNotify(
    void
    )
{
    long    lEventCode;
    HDC     hdc;

    lEventCode = pMpegMovie->GetMovieEventCode();
    switch (lEventCode) {
    case EC_FULLSCREEN_LOST:
        pMpegMovie->SetFullScreenMode(FALSE);
        SetPlayButtonsEnableState();
        break;

    case EC_COMPLETE:
    case EC_USERABORT:
    case EC_ERRORABORT:
        VcdPlayerStopCmd();
        SetPlayButtonsEnableState();
        hdc = GetDC(hwndApp);
        DrawStats(hdc);
        ReleaseDC(hwndApp, hdc);
        break;

    default:
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnNotify
*
* This is where we get the text for the little tooltips
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    )
{
    switch (pnmhdr->code) {

    case TTN_NEEDTEXT:
        {
            LPTOOLTIPTEXT   lpTt;

            lpTt = (LPTOOLTIPTEXT)pnmhdr;
            LoadString( hInst, (UINT) lpTt->hdr.idFrom, lpTt->szText,
                        sizeof(lpTt->szText) );
        }
        break;
    }

    return 0;
}




/*****************************Private*Routine******************************\
* VideoCd_OnMenuSelect
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    )
{

    TCHAR szString[STR_MAX_STRING_LEN + 1];

    /*
    ** Is it time to end the menu help ?
    */

    if ( (flags == 0xFFFFFFFF) && (hmenu == NULL) ) {

        SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    /*
    ** Do we have a separator, popup or the system menu ?
    */
    else if ( flags & MF_POPUP ) {

        SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    else if (flags & MF_SYSMENU) {

        switch (item) {

        case SC_RESTORE:
            lstrcpy( szString, IdStr(STR_SYSMENU_RESTORE) );
            break;

        case SC_MOVE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MOVE) );
            break;

        case SC_MINIMIZE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MINIMIZE) );
            break;

        case SC_MAXIMIZE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MAXIMIZE) );
            break;

        case SC_TASKLIST:
            lstrcpy( szString, IdStr(STR_SYSMENU_TASK_LIST) );
            break;

        case SC_CLOSE:
            lstrcpy( szString, IdStr(STR_SYSMENU_CLOSE) );
            break;
        }

        SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPTSTR)szString );
        SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
        UpdateWindow(g_hwndStatusbar);

    }

    /*
    ** Hopefully its one of ours
    */
    else {

        if ((flags & MF_SEPARATOR)) {

            szString[0] = g_chNULL;
        }
        else {

            lstrcpy( szString, IdStr(item + MENU_STRING_BASE) );

        }

        SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPTSTR)szString );
        SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
        UpdateWindow(g_hwndStatusbar);
    }
}

/*****************************Private*Routine******************************\
* VideoCd_OnDropFiles
*
* -- handle a file-manager drop of a filename to indicate a movie we should
*    open.
*
*
* History:
* 22-01-96 - GeraintD - Created
*
\**************************************************************************/
void
VideoCd_OnDropFiles(
    HWND hwnd,
    HDROP hdrop)
{
    // if there is more than one file, simply open the first one

    // find the length of the path (plus the null
    int cch = DragQueryFile(hdrop, 0, NULL, 0) + 1;
    TCHAR * pName = new TCHAR[cch];

    DragQueryFile(hdrop, 0, pName, cch);

    // open the file
    ProcessOpen(pName);

    // update the toolbar state
    SetPlayButtonsEnableState();

    // free up used resources
    delete [] pName;
    DragFinish(hdrop);
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 VCD Player buttons enable state table
* Ŀ
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other 
* Ĵ
* Disk in use                 D     D      D       D      D   
* Ĵ
* No video cd or data cdrom   D     D      E       D      D   
* Ĵ
* Video cd (playing)          D     E      E       E      E   
* Ĵ
* Video cd (paused)           E     D      E       E      E   
* Ĵ
* Video cd (stopped)          E     D      E       D      E   
* 
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fEnable, fPress;
    BOOL    fVideoCdLoaded;

    /*
    ** Do we have a video cd loaded.
    */
    if (g_State & (VCD_NO_CD | VCD_DATA_CD_LOADED | VCD_IN_USE)) {
        fVideoCdLoaded = FALSE;
    }
    else {
        fVideoCdLoaded = TRUE;
    }


    /*
    ** Do the play button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_STOPPED) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PLAY, fEnable );


    /*
    ** Do the stop button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_PLAYING) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_STOP, fEnable );


    /*
    ** Do the pause button
    */
    if ( fVideoCdLoaded && (g_State & VCD_PLAYING) ) {
        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PAUSE, fEnable );


    /*
    ** Do the remaining buttons
    */

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_FORE, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_BACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_NEXTTRACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_PREVTRACK, fVideoCdLoaded );


    /*
    ** Do the fullscreen button
    */
    if ( fVideoCdLoaded && pMpegMovie->IsFullScreenMode() ) {
        fPress = TRUE;
    }
    else {
        fPress = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_CHECKBUTTON, IDM_FULL_SCREEN, MAKELONG(fPress,0) );
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_FULL_SCREEN, fVideoCdLoaded );


    //
    // do "new log" and "dump log" buttons
    //
    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_NEW, lpControlProc == NULL);

    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_DUMP, lpDumpProc == NULL);
}


/*****************************Private*Routine******************************\
* GetAdjustedClientRect
*
* Calculate the size of the client rect and then adjusts it to take into
* account the space taken by the toolbar and status bar.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
GetAdjustedClientRect(
    RECT *prc
    )
{
    RECT    rcTool;

    GetClientRect(hwndApp, prc);

    GetWindowRect(g_hwndToolbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);

    GetWindowRect(g_hwndTrackbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);

    GetWindowRect(g_hwndStatusbar, &rcTool);
    prc->bottom -= (rcTool.bottom - rcTool.top);
}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPCTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
        return g_szEmpty;
    }

    return chBuffer;

}

/*+ GetAppKey
 *
 *-=================================================================*/

static TCHAR cszWindow[] = TEXT("Window");
static TCHAR cszAppKey[] = TEXT("Software\\Microsoft\\Multimedia Tools\\VCDPlayer");

HKEY
GetAppKey(
    BOOL fCreate
    )
{
    HKEY hKey = 0;

    if (fCreate) {
       if (RegCreateKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }
    else {
       if (RegOpenKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }

    return NULL;
}

/*+ ProfileIntIn
 *
 *-=================================================================*/

int
ProfileIntIn(
    const TCHAR *szKey,
    int iDefault
    )
{
    DWORD dwType;
    int   iValue;
    BYTE  aData[20];
    DWORD cb;
    HKEY  hKey;

    if (!(hKey = GetAppKey(TRUE))) {
        return iDefault;
    }

    *(UINT *)&aData = 0;
    cb = sizeof(aData);

    if (RegQueryValueEx (hKey, szKey, NULL, &dwType, aData, &cb)) {
       iValue = iDefault;
    }
    else {

        if (dwType == REG_DWORD || dwType == REG_BINARY) {
            iValue = *(int *)&aData;
        }
        else if (dwType == REG_SZ) {
            iValue = _ttoi((LPTSTR)aData);
        }
    }

    RegCloseKey (hKey);
    return iValue;
}


/*+ ProfileIntOut
 *
 *-=================================================================*/

BOOL
ProfileIntOut (
    const TCHAR *szKey,
    int iVal
    )
{
    HKEY  hKey;
    BOOL  bRet = FALSE;

    hKey = GetAppKey(TRUE);
    if (hKey) {
        RegSetValueEx(hKey, szKey, 0, REG_DWORD, (LPBYTE)&iVal, sizeof(DWORD));
        RegCloseKey (hKey);
        bRet = TRUE;
    }
    return bRet;
}


/*+ ProfileString
 *
 *-=================================================================*/

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    )
{
    HKEY  hKey;
    DWORD dwType;

    if (!(hKey = GetAppKey (FALSE)))
    {
        lstrcpy (sz, szDef);
        return lstrlen (sz);
    }

    if (RegQueryValueEx(hKey, szKey, NULL, &dwType, (LPBYTE)sz, &cb) || dwType != REG_SZ)
    {
        lstrcpy (sz, szDef);
        cb = lstrlen (sz);
    }

    RegCloseKey (hKey);
    return cb;
}

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    )
{
    HKEY  hKey;

    hKey = GetAppKey(TRUE);
    if (hKey)
        RegSetValueEx(hKey, szKey, 0, REG_SZ, (LPBYTE)sz, lstrlen(sz)+1);

    RegCloseKey (hKey);
}


/*+ LoadWindowPos
 *
 * retrieve the window position information from dragn.ini
 *
 *-=================================================================*/

#ifndef SPI_GETWORKAREA
 #define SPI_GETWORKAREA 48  // because NT doesnt have this define yet
#endif

BOOL
LoadWindowPos(
    LPRECT lprc
    )
{
    static RECT rcDefault = {0,0,CX_DEFAULT,CY_DEFAULT};
    RECT  rcScreen;
    RECT  rc;
    HKEY  hKey = GetAppKey(FALSE);

    // read window placement from the registry.
    //
    *lprc = rcDefault;
    if (hKey)
    {
        DWORD cb;
        DWORD dwType;

        cb = sizeof(rc);
        if ( ! RegQueryValueEx(hKey, cszWindow, NULL, &dwType, (LPBYTE)&rc, &cb)
            && dwType == REG_BINARY && cb == sizeof(RECT))
        {
            *lprc = rc;
        }

        RegCloseKey (hKey);
    }

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if ( ! SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, FALSE))
    {
        rcScreen.top = rcScreen.left = 0;
        rcScreen.right = 640;
        rcScreen.bottom = 480;
    }

    // if the proposed window position is outside the screen,
    // use the default placement
    //
    if ( ! IntersectRect(&rc, &rcScreen, lprc)) {
        *lprc = rcDefault;
    }

    return ! IsRectEmpty (lprc);
}


/*+ SaveWindowPos
 *
 * store the window position information in dragn.ini
 *
 *-=================================================================*/

BOOL
SaveWindowPos(
    HWND hwnd
    )
{
    WINDOWPLACEMENT wpl;
    HKEY  hKey = GetAppKey(TRUE);

    if (!hKey) {
       return FALSE;
    }

    // save the current size and position of the window to the registry
    //
    ZeroMemory (&wpl, sizeof(wpl));
    wpl.length = sizeof(wpl);
    GetWindowPlacement (hwnd, &wpl);


    RegSetValueEx( hKey, cszWindow, 0, REG_BINARY,
                   (LPBYTE)&wpl.rcNormalPosition,
                   sizeof(wpl.rcNormalPosition));

    RegCloseKey (hKey);
    return TRUE;
}


/*****************************Private*Routine******************************\
* GetRecentFiles
*
* Reads at most MAX_RECENT_FILES from vcdplyer.ini. Returns the number
* of files actually read.  Updates the File menu to show the "recent" files.
*
* History:
* 26-10-95 - StephenE - Created
*
\**************************************************************************/
int
GetRecentFiles(
    int iLastCount
    )
{
    int     i;
    TCHAR   FileName[MAX_PATH];
    TCHAR   szKey[32];
    HMENU   hSubMenu;

    //
    // Delete the files from the menu
    //
    hSubMenu = GetSubMenu(GetMenu(hwndApp), 0);

    // Delete the separator at slot 2 and all the other recent file entries

    if (iLastCount != 0) {
        DeleteMenu(hSubMenu, 2, MF_BYPOSITION);

        for (i = 1; i <= iLastCount; i++) {
            DeleteMenu(hSubMenu, ID_RECENT_FILE_BASE + i, MF_BYCOMMAND);
        }
    }


    for (i = 1; i <= MAX_RECENT_FILES; i++) {

        DWORD   len;
        TCHAR   szMenuName[MAX_PATH + 3];

        wsprintf(szKey, TEXT("File %d"), i);
        len = ProfileStringIn(szKey, TEXT(""), FileName, MAX_PATH);
        if (len == 0) {
            i = i - 1;
            break;
        }

        lstrcpy(aRecentFiles[i - 1], FileName);
        wsprintf(szMenuName, TEXT("&%d %s"), i, FileName);

        if (i == 1) {
            InsertMenu(hSubMenu, 2, MF_SEPARATOR | MF_BYPOSITION, (UINT)-1, NULL );
        }

        InsertMenu(hSubMenu, 2 + i, MF_STRING | MF_BYPOSITION,
                   ID_RECENT_FILE_BASE + i, szMenuName );
    }

    //
    // i is the number of recent files in the array.
    //
    return i;
}


/*****************************Private*Routine******************************\
* SetRecentFiles
*
* Writes the most recent files to the vcdplyer.ini file.  Purges the oldest
* file if necessary.
*
* History:
* 26-10-95 - StephenE - Created
*
\**************************************************************************/
int
SetRecentFiles(
    TCHAR *FileName,    // File name to add
    int iCount          // Current count of files
    )
{
    TCHAR   FullPathFileName[MAX_PATH];
    TCHAR   *lpFile;
    TCHAR   szKey[32];
    int     iCountNew;
    int     i;

    //
    // Check for dupes - we don't allow them !
    //
    for (i = 0; i < iCount; i++) {
        if (0 == lstrcmpi(FileName, aRecentFiles[i])) {
            return iCount;
        }
    }

    //
    // Throw away the oldest entry
    //
    MoveMemory(&aRecentFiles[1], &aRecentFiles[0],
               sizeof(aRecentFiles) - sizeof(aRecentFiles[1]));

    //
    // Copy in the full path of the new file.
    //
    GetFullPathName(FileName, MAX_PATH, FullPathFileName, &lpFile);
    lstrcpy(aRecentFiles[0], FullPathFileName);

    //
    // Update the count of files, saturate to MAX_RECENT_FILES.
    //
    iCountNew = min(iCount + 1, MAX_RECENT_FILES);

    //
    // Clear the old stuff and the write out the recent files to disk
    //
    for (i = 1; i <= iCountNew; i++) {
        wsprintf(szKey, TEXT("File %d"), i);
        ProfileStringOut(szKey, aRecentFiles[i - 1]);
    }

    //
    // Update the file menu
    //
    GetRecentFiles(iCount);

    return iCountNew;  // the updated count of files.
}

/*****************************Private*Routine******************************\
* SetDurationLength
*
* Updates pane 0 on the status bar
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
void
SetDurationLength(
    REFTIME rt
    )
{
    TCHAR   szFmt[64];
    TCHAR   sz[64];

    g_TrackBarScale = 1.0;
    while (rt / g_TrackBarScale > 30000) {
        g_TrackBarScale *= 10;
    }

    SendMessage(g_hwndTrackbar, TBM_SETRANGE, TRUE,
                MAKELONG(0, (WORD)(rt / g_TrackBarScale)));

    SendMessage(g_hwndTrackbar, TBM_SETTICFREQ, (WPARAM)((int)(rt / g_TrackBarScale) / 9), 0);
    SendMessage(g_hwndTrackbar, TBM_SETPAGESIZE, 0, (LPARAM)((int)(rt / g_TrackBarScale) / 9));

    wsprintf(sz, TEXT("Length: %s"), FormatRefTime(szFmt, rt));
    SendMessage(g_hwndStatusbar, SB_SETTEXT, 0, (LPARAM)sz);
}


/*****************************Private*Routine******************************\
* SetCurrentPosition
*
* Updates pane 1 on the status bar
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
void
SetCurrentPosition(
    REFTIME rt
    )
{
    TCHAR   szFmt[64];
    TCHAR   sz[64];

    SendMessage(g_hwndTrackbar, TBM_SETPOS, TRUE, (LPARAM)(rt / g_TrackBarScale));

    wsprintf(sz, TEXT("Elapsed: %s"), FormatRefTime(szFmt, rt));
    SendMessage(g_hwndStatusbar, SB_SETTEXT, 1, (LPARAM)sz);
}


/*****************************Private*Routine******************************\
* FormatRefTime
*
* Formats the given RefTime into the passed in character buffer,
* returns a pointer to the character buffer.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    )
{
    // If we are not seeking in time then format differently

    if (pMpegMovie && pMpegMovie->GetTimeFormat() != TIME_FORMAT_MEDIA_TIME) {
        wsprintf(sz,TEXT("%s"),(LPCTSTR) CDisp ((LONGLONG) rt,CDISP_DEC));
        return sz;
    }

    int hrs, mins, secs;

    rt += 0.49;

    hrs  =  (int)rt / 3600;
    mins = ((int)rt % 3600) / 60;
    secs = ((int)rt % 3600) % 60;

#ifdef UNICODE
    swprintf(sz, L"%02d:%02d:%02d h:m:s", rt);
#else
    sprintf(sz, "%02d:%02d:%02d h:m:s", hrs, mins, secs);
#endif

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe     \
         $(SDK_ROOT)\bin\$(DBG_RTL)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\project.h ===
/******************************Module*Header*******************************\
* Module Name: project.h
*
*  Master header file that includes all the other header files used by the
* project.  This enables compiled headers to work using build.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/

#include "app.h"
#include "vcdplyer.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\mpgcodec.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
#include <mpegtype.h>   // IMpegAudioDecoder

typedef struct {
    LONG           lWidth;             //  Native Width in pixels
    LONG           lHeight;            //  Native Height in pixels
    LONG           lvbv;               //  vbv
    REFERENCE_TIME PictureTime;        //  Time per picture in 100ns units
    LONG           lTimePerFrame;      //  Time per picture in MPEG units
    LONG           dwBitRate;          //  Bits per second
    LONG           lXPelsPerMeter;     //  Pel aspect ratio
    LONG           lYPelsPerMeter;     //  Pel aspect ratio
    DWORD          dwStartTimeCode;    //  First GOP time code (or -1)
    LONG           lActualHeaderLen;   //  Length of valid bytes in raw seq hdr
    BYTE           RawHeader[140];     //  The real sequence header
} SEQHDR_INFO;


#define DECODE_I        0x0001L
#define DECODE_IP       0x0003L
#define DECODE_IPB      0x0007L     // Normal B Frame
#define DECODE_IPB1     0x000FL     // Decode 1 out of 4 B frames
#define DECODE_IPB2     0x0010L     // Decode 2 out of 4 B frames
#define DECODE_IPB3     0x0020L     // Decode 3 out of 4 B frames
#define DECODE_DIS      0x0040L     // No Decode, Convert only

#define DECODE_BQUAL_HIGH   0x00000000L  // Normal B Decode
#define DECODE_BQUAL_MEDIUM 0x10000000L  // Fast B Frame (No Half Pixel)
#define DECODE_BQUAL_LOW    0x20000000L  // Super Fast B Frame (No Half Pixel & Fast IDCT)

#define MM_NOCONV       0x00000000L     // No Conversion
#define MM_HRESOLUTION  0x10000000L     // Half Resolution
#define MM_CLIPPED      0x20000000L     // Clipped version (RGB8 only at present)

#define MM_420PL        0x00000001L     // YU12 :: YCbCr
#define MM_420PL_       0x00000002L     // YV12 :: YCrCb

#define MM_422PK        0x00000010L     // YUY2 :: YCbCr
#define MM_422PK_       0x00000020L     // YVY2 :: YCrCb
#define MM_422SPK       0x00000040L     //      :: CbYCrY
#define MM_422SPK_      0x00000080L     //      :: CrYCbY
#define MM_411PK        0x00000100L     // BT41
#define MM_410PL_       0x00000200L     // YVU9 - 16:1:1 Planar format


#define MM_Y_DIB        0x00001000L     // Luminance Only DIB
#define MM_Y_DDB        0x00002000L     // Luminance Only DDB

#define MM_RGB24_DIB    0x00010000L     // RGB 8:8:8 DIB   (Not Supported)
#define MM_RGB24_DDB    0x00020000L     // RGB 8:8:8 DDB   (Not Supported)
#define MM_RGB32_DIB    0x00040000L     // RGB a:8:8:8 DIB   (Not Supported)
#define MM_RGB32_DDB    0x00080000L     // RGB a:8:8:8 DDB   (Not Supported)

#define MM_RGB565_DIB   0x00100000L     // RGB 5:6:5 DIB
#define MM_RGB565_DDB   0x00200000L     // RGB 5:6:5 DDB
#define MM_RGB555_DIB   0x00400000L     // RGB 5:5:5 DIB
#define MM_RGB555_DDB   0x00800000L     // RGB 5:5:5 DDB

#define MM_RGB8_DIB     0x01000000L     // 8 Bit Paletized RGB DIB
#define MM_RGB8_DDB     0x02000000L     // 8 Bit Paletized RGB DDB


#define DECODE_HALF_HIQ	  0x00004000L
#define DECODE_HALF_FULLQ 0x00008000L


// {CC785860-B2CA-11ce-8D2B-0000E202599C}
DEFINE_GUID(CLSID_MpegAudioDecodePropertyPage,
0xcc785860, 0xb2ca, 0x11ce, 0x8d, 0x2b, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c);


// {E5B4EAA0-B2CA-11ce-8D2B-0000E202599C}
DEFINE_GUID(CLSID_MpegVideoDecodePropertyPage,
0xe5b4eaa0, 0xb2ca, 0x11ce, 0x8d, 0x2b, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c);


// {EB1BB270-F71F-11CE-8E85-02608C9BABA2}
DEFINE_GUID(IID_IMpegVideoDecoder,
0xeb1bb270, 0xf71f, 0x11ce, 0x8e, 0x85, 0x02, 0x60, 0x8c, 0x9b, 0xab, 0xa2);


//
// Structure to describe the caps of the mpeg video decoder.
//
typedef struct {
    DWORD   VideoMaxBitRate;
} MPEG_VIDEO_DECODER_CAPS;


//
// IMpegVideoDecoder
//
DECLARE_INTERFACE_(IMpegVideoDecoder, IUnknown) {

    STDMETHOD(get_CurrentDecoderOption)
    ( THIS_
      DWORD *pOptions
    ) PURE;

    STDMETHOD(set_CurrentDecoderOption)
    ( THIS_
      DWORD Options
    ) PURE;

    STDMETHOD(get_DefaultDecoderOption)
    ( THIS_
      DWORD *pOptions
    ) PURE;

    STDMETHOD(set_DefaultDecoderOption)
    ( THIS_
      DWORD Options
    ) PURE;

    STDMETHOD(get_QualityMsgProcessing)
    ( THIS_
      BOOL *pfIgnore
    ) PURE;

    STDMETHOD(set_QualityMsgProcessing)
    ( THIS_
      BOOL fIgnore
    ) PURE;

    STDMETHOD(get_GreyScaleOutput)
    ( THIS_
      BOOL *pfGrey
    ) PURE;

    STDMETHOD(set_GreyScaleOutput)
    ( THIS_
      BOOL fGrey
    ) PURE;

    STDMETHOD(get_SequenceHeader)
    ( THIS_
      SEQHDR_INFO *pSeqHdrInfo
    ) PURE;

    STDMETHOD(get_OutputFormat)
    ( THIS_
      DWORD *pOutputFormat
    ) PURE;

    STDMETHOD(get_FrameStatistics)
    ( THIS_
      DWORD *pIFramesDecoded,
      DWORD *pPFramesDecoded,
      DWORD *pBFramesDecoded,
      DWORD *pIFramesSkipped,
      DWORD *pPFramesSkipped,
      DWORD *pBFramesSkipped
    ) PURE;

    STDMETHOD(ResetFrameStatistics)
    ( THIS_
    ) PURE;

    STDMETHOD(get_DecoderPaletteInfo)
    ( THIS_
      LPDWORD lpdwFirstEntry,
      LPDWORD lpdwLastEntry
    ) PURE;

    STDMETHOD(get_DecoderPaletteEntries)
    ( THIS_
      DWORD dwStartEntry,
      DWORD dwNumEntries,
      LPPALETTEENTRY lppe
    ) PURE;

    STDMETHOD(get_EncryptionKey)
    ( THIS_
      DWORD *dwEncrptionKey
    ) PURE;

    STDMETHOD(put_EncryptionKey)
    ( THIS_
      DWORD dwEncrptionKey
    ) PURE;

    STDMETHOD(get_DecoderCaps)
    ( THIS_
      MPEG_VIDEO_DECODER_CAPS *pCaps
    ) PURE;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\resource.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// These are indexes used by the toolbar.
//
#define IDC_ADEFAULT2                   4013
#define IDC_STATIC                      -1

#define IDX_SEPARATOR                   -1
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define IDX_10                          9
#define IDX_11                          10
#define DEFAULT_TBAR_SIZE               14
#define NUMBER_OF_BITMAPS               11


#define ID_STATUSBAR                    8
#define ID_TOOLBAR                      9
#define ID_TRACKBAR                     10

#define IDR_MAIN_MENU                   101
#define IDR_TOOLBAR                     102
#define IDR_VIDEOCD_ICON                103
#define IDR_ACCELERATOR                 104

#define IDM_FILE_OPEN                   40001
#define IDM_FILE_CLOSE                  40002
#define IDM_FILE_EXIT                   40003


#define IDM_PROPERTIES                  40004
#define IDM_VIDEO_DECODER               40005
#define IDM_AUDIO_DECODER               40006
#define IDM_FILTERS                     40007

#define IDM_FILE_SET_LOG                40008
#define IDM_FILE_SET_PERF_LOG           40009

#define IDM_HELP_INDEX                  40100
#define IDM_HELP_USING                  40101
#define IDM_HELP_ABOUT                  40102
#define IDM_HELP_SEARCH                 40103

// Different time formats
#define IDM_TIME                        40150
#define IDM_FRAME                       40151
#define IDM_FIELD                       40152
#define IDM_SAMPLE                      40153
#define IDM_BYTES                       40154

// Toolbar commands
#define IDM_MOVIE_STOP                  40010
#define IDM_MOVIE_PLAY                  40011
#define IDM_MOVIE_PREVTRACK             40012
#define IDM_MOVIE_PAUSE                 40013
#define IDM_MOVIE_SKIP_FORE             40014
#define IDM_MOVIE_SKIP_BACK             40015
#define IDM_MOVIE_NEXTTRACK             40016

#define IDM_PERF_NEW                    40017
#define IDM_PERF_DUMP                   40018
#define IDM_FULL_SCREEN                 40019

#define IDM_MOVIE_ALIGN                 40020



#define MENU_STRING_BASE                1000

        // File
#define STR_FILE_OPEN           IDM_FILE_OPEN  + MENU_STRING_BASE
#define STR_FILE_CLOSE          IDM_FILE_CLOSE + MENU_STRING_BASE
#define STR_FILE_EXIT           IDM_FILE_EXIT  + MENU_STRING_BASE
#define STR_FILE_SET_LOG        IDM_FILE_SET_LOG  + MENU_STRING_BASE
#define STR_FILE_SET_PERF_LOG   IDM_FILE_SET_PERF_LOG  + MENU_STRING_BASE


        // Properties Menu
#define STR_PROP_VIDEO_DECODER  IDM_VIDEO_DECODER + MENU_STRING_BASE
#define STR_PROP_AUDIO_DECODER  IDM_AUDIO_DECODER + MENU_STRING_BASE
#define STR_PROP_OTHER          IDM_FILTERS + MENU_STRING_BASE

        // Time format menu
#define STR_PROP_IDM_TIME       IDM_TIME      + MENU_STRING_BASE
#define STR_PROP_IDM_FRAME      IDM_FRAME     + MENU_STRING_BASE
#define STR_PROP_IDM_FIELD      IDM_FIELD     + MENU_STRING_BASE
#define STR_PROP_IDM_SAMPLE     IDM_SAMPLE    + MENU_STRING_BASE
#define STR_PROP_IDM_BYTES      IDM_BYTES     + MENU_STRING_BASE

        // Dither Menu          OPTIONS_MENU_BASE


        // Help Menu            HELP_MENU_BASE
#define STR_HELP_INDEX          IDM_HELP_INDEX    + MENU_STRING_BASE
#define STR_HELP_USING          IDM_HELP_USING    + MENU_STRING_BASE
#define STR_HELP_ABOUT          IDM_HELP_ABOUT    + MENU_STRING_BASE
#define STR_HELP_SEARCH         IDM_HELP_SEARCH   + MENU_STRING_BASE


        // System Menu
#define STR_SYSMENU_RESTORE     1800
#define STR_SYSMENU_MOVE        1801
#define STR_SYSMENU_MINIMIZE    1802
#define STR_SYSMENU_CLOSE       1803
#define STR_SYSMENU_MAXIMIZE    1804
#define STR_SYSMENU_TASK_LIST   1805



#define STR_FILE_FILTER         2000
#define STR_APP_TITLE           2001
#define STR_APP_TITLE_LOADED    2002
#define STR_FILE_LOG_FILTER     2003
#define STR_FILE_PERF_LOG       2004


#define MPEG_CODEC_BASE         4000

#define IDD_AUDIOPROP           4000    //  MPEG_CODEC_BASE + 0
#define FULL_FREQ               MPEG_CODEC_BASE + 1
#define HALF_FREQ               MPEG_CODEC_BASE + 2
#define QUARTER_FREQ            MPEG_CODEC_BASE + 3
#define IDC_INTEGER             MPEG_CODEC_BASE + 4
#define D_HIGH                  MPEG_CODEC_BASE + 5
#define D_MEDIUM                MPEG_CODEC_BASE + 6
#define D_LOW                   MPEG_CODEC_BASE + 7
#define STEREO_OUTPUT           MPEG_CODEC_BASE + 8
#define IDC_8_BIT               MPEG_CODEC_BASE + 9
#define IDC_16_BIT              MPEG_CODEC_BASE + 10
#define IDC_ADEFAULT            MPEG_CODEC_BASE + 11
#define IDC_AINFO               MPEG_CODEC_BASE + 12


#define IDD_VIDEOPROP           4008    //  MPEG_CODEC_BASE + 9
#define NO_DECODE               MPEG_CODEC_BASE + 10
#define I_ONLY                  MPEG_CODEC_BASE + 11
#define IP_ONLY                 MPEG_CODEC_BASE + 12
#define IP_1_IN_4_B             MPEG_CODEC_BASE + 13
#define IP_2_IN_4_B             MPEG_CODEC_BASE + 14
#define IP_3_IN_4_B             MPEG_CODEC_BASE + 15
#define IP_ALL_B                MPEG_CODEC_BASE + 16
#define B_HIGH                  MPEG_CODEC_BASE + 17
#define B_MEDIUM                MPEG_CODEC_BASE + 18
#define B_LOW                   MPEG_CODEC_BASE + 19
#define OUTPUT_16BIT            MPEG_CODEC_BASE + 20
#define OUTPUT_8BIT             MPEG_CODEC_BASE + 21
#define CONVERT_OUTPUT          MPEG_CODEC_BASE + 22
#define HI_QUALITY_OUTPUT       MPEG_CODEC_BASE + 23

#define B_GREY                  MPEG_CODEC_BASE + 24
#define IGNORE_QUALITY          MPEG_CODEC_BASE + 25
#define STATS_BUTTON            MPEG_CODEC_BASE + 26
#define ID_DEFAULT              MPEG_CODEC_BASE + 27

#define IDD_VIDEOSTATS          4027    //  MPEG_CODEC_BASE + 28
#define ID_STATSBOX             MPEG_CODEC_BASE + 29
#define ID_REFRESH              MPEG_CODEC_BASE + 30

#define IDD_PROPPAGE            4040    //  MPEG_CODEC_BASE + 40
#define IDC_FILTERS             MPEG_CODEC_BASE + 41
#define IDC_PROPERTIES          MPEG_CODEC_BASE + 42

#define STR_MAX_STRING_LEN      256
#define IDS_FRAMES_DEC          MPEG_CODEC_BASE + 31
#define IDS_PROPORTION          MPEG_CODEC_BASE + 32
#define IDS_IMAGE_SIZE          MPEG_CODEC_BASE + 33
#define IDS_BUFFER_VBV          MPEG_CODEC_BASE + 34
#define IDS_BITRATE             MPEG_CODEC_BASE + 35
#define IDS_PROP_I              MPEG_CODEC_BASE + 36
#define IDS_PROP_P              MPEG_CODEC_BASE + 37
#define IDS_PROP_B              MPEG_CODEC_BASE + 38
#define IDS_SKIP_I              MPEG_CODEC_BASE + 39
#define IDS_SKIP_P              MPEG_CODEC_BASE + 40
#define IDS_SKIP_B              MPEG_CODEC_BASE + 41
#define IDS_NO_DATA             MPEG_CODEC_BASE + 42
#define IDS_NEWLINE             MPEG_CODEC_BASE + 43
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\qprops.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"
#include <olectl.h>
#include <stdio.h>
extern HINSTANCE hInst;

// these lines copied from SDK\CLASSES\BASE\FILTER.H
#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();

typedef HRESULT (STDAPICALLTYPE *LPOCPF)(HWND hwndOwner, UINT x, UINT y,
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages,
    LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved);

typedef HRESULT (STDAPICALLTYPE *LPOI)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE *LPOUI)(void);


//
// Release the reference count for those filters put into the configuration
// listbox
//

void ReleaseFilters(HWND hwndListbox)
{
    if (hwndListbox) {
        IBaseFilter* pFilter;

        for (int i=ListBox_GetCount(hwndListbox); i--;) {
            if (pFilter = (IBaseFilter*)ListBox_GetItemData(hwndListbox, i))
                pFilter->Release();
            else
                break;
        }
    }
}

INT_PTR CALLBACK ConfigDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    case WM_INITDIALOG:
        {
            IFilterGraph *pFG = (IFilterGraph *) lParam;

            IEnumFilters* pEF;	
            IBaseFilter* pFilter;
            FILTER_INFO Info;

            HWND hlist = GetDlgItem(hDlg, IDC_FILTERS);
            if (pFG == NULL)
                return FALSE;

            // Grab an enumerator for the filter graph.
            HRESULT hr = pFG->EnumFilters(&pEF);

            // ASSERT(SUCCEEDED(hr));

            // Check out each filter.
            while (pEF->Next(1, &pFilter, NULL) == S_OK)
            {
                int Index;

                hr = pFilter->QueryFilterInfo(&Info);
                // ASSERT(SUCCEEDED(hr));
                QueryFilterInfoReleaseGraph(Info);

#ifdef UNICODE
                Index = ListBox_AddString(hlist, Info.achName);
#else
                CHAR    aFilterName[MAX_FILTER_NAME];
                WideCharToMultiByte(CP_ACP, 0, Info.achName, -1, aFilterName, MAX_FILTER_NAME, NULL, NULL);
                Index = ListBox_AddString(hlist, aFilterName);
#endif

                // ASSERT(Index != LB_ERR);
                // ASSERT(Index != LB_ERRSPACE);

                // Store the IBaseFilter pointer with the listbox item.
                // it gets used if the properties have to be queried
                ListBox_SetItemData(hlist, Index, pFilter);
            }

            pEF->Release();
        }
        return TRUE;

    case WM_ENDSESSION:
        if (wParam)	{
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, FALSE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, FALSE);
            break;

        case IDC_FILTERS:
            if (HIWORD(wParam) == LBN_SELCHANGE) {

                HRESULT hr = E_FAIL;

                HWND    hlist = GetDlgItem(hDlg, IDC_FILTERS);
                IBaseFilter *pF;
                ISpecifyPropertyPages *pSPP;

                pF = (IBaseFilter *)
                     ListBox_GetItemData(hlist, ListBox_GetCurSel(hlist));

                if (pF) {
                    hr = pF->QueryInterface(IID_ISpecifyPropertyPages,
                                                    (void **)&pSPP);
                }

                if (hr == S_OK) {
                    pSPP->Release();
                }
                EnableWindow(GetDlgItem(hDlg, IDC_PROPERTIES), hr == S_OK);
            }
            else if (HIWORD(wParam) == LBN_DBLCLK) {
                HWND hwndBtn = GetDlgItem(hDlg, IDC_PROPERTIES);
                SendMessage(hwndBtn, WM_LBUTTONDOWN, 0, 0L);
                SendMessage(hwndBtn, WM_LBUTTONUP, 0, 0L);
            }
            break;

        case IDC_PROPERTIES:
            {
                HWND hlist = GetDlgItem(hDlg, IDC_FILTERS);
                IBaseFilter *pF;
                pF = (IBaseFilter *)
                ListBox_GetItemData(hlist, ListBox_GetCurSel(hlist));

                static const TCHAR szOleControlDll[] = TEXT("OLEPRO32.dll");
                static const char szOCPF[] = "OleCreatePropertyFrame";
                static const TCHAR szOleDll[] = TEXT("OLE32.dll");
                static const char szOleInit[] = "OleInitialize";
                static const char szOleUninit[] = "OleUninitialize";

                HINSTANCE hinst = LoadLibrary(szOleControlDll);
                if (!hinst) break;

                LPOCPF lpfn = (LPOCPF)GetProcAddress(hinst, szOCPF);
                HINSTANCE hinstOLE = LoadLibrary(szOleDll);

                if (hinstOLE) {
                    LPOI lpfnInit = (LPOI)GetProcAddress(hinstOLE, szOleInit);
                    LPOUI lpfnUninit = (LPOUI)GetProcAddress(hinstOLE, szOleUninit);

                    if (lpfn && lpfnInit && lpfnUninit) {

                        (*lpfnInit) (NULL);
                        (*lpfn)(hDlg,               // Parent
                            0,                      // x coordinate
                            0,                      // y coordinate
                            L"Filter",              // Caption
                            1,                      // Number of objects
                            (IUnknown**)&pF,        // 1 object
                            0,                      // No pages :- will use
                            NULL,                   // ISpecifyPropertyPages	
                            0,                      // AmbientLocaleID(),
                            0,                      // Reserved
                            NULL);                  // Reserved
                        (*lpfnUninit) ();
                    }
                    FreeLibrary(hinstOLE);
                }
                FreeLibrary(hinst);
            }
            break;
        }
        break;
    }
    return FALSE;
}



BOOL CMpegMovie::ConfigDialog(HWND hwnd)
{
    BOOL f = TRUE;

    f = (BOOL) DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_PROPPAGE),
                       hwnd, ConfigDlgProc, (DWORD_PTR)m_Fg);

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\vcdplyer.cpp ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.cpp
*
* A simple Video CD player
*
*
* Created: 30-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>


/******************************Public*Routine******************************\
* CMpegMovie
*
* Constructors and destructors
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
CMpegMovie::CMpegMovie(HWND hwndApplication)
    : m_hwndApp(hwndApplication),
      m_MediaEvent(NULL),
      m_Mode(MOVIE_NOTOPENED),
      m_Fg(NULL),
      m_Gb(NULL),
      m_Mc(NULL),
      m_Ms(NULL),
      m_Me(NULL),
      m_Vw(NULL),
      m_pStreamSelect(NULL),
      m_bFullScreen(FALSE),
      pMpegDecoder(NULL),
      pMpegAudioDecoder(NULL),
      pVideoRenderer(NULL),
      m_TimeFormat(TIME_FORMAT_MEDIA_TIME)
    {}
CMpegMovie::~CMpegMovie() {}



/******************************Public*Routine******************************\
* OpenMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::OpenMovie(
    TCHAR *lpFileName
    )
{
    IUnknown        *pUnk;
    HRESULT         hres;

    WCHAR           FileName[MAX_PATH];

#ifdef UNICODE
    lstrcpy(FileName, lpFileName);
#else
    swprintf(FileName, L"%hs", lpFileName);
#endif

    hres = CoInitialize(NULL);
    if (hres == S_FALSE) {
        CoUninitialize();
    }

    hres = CoCreateInstance(
        g_bUseThreadedGraph ?
            CLSID_FilterGraph :
            CLSID_FilterGraphNoThread,
        NULL,
        CLSCTX_INPROC,
        IID_IUnknown,
        (LPVOID *)&pUnk);

    if (SUCCEEDED(hres)) {

        m_Mode = MOVIE_OPENED;
        hres = pUnk->QueryInterface(IID_IFilterGraph, (LPVOID *)&m_Fg);
        if (FAILED(hres)) {
            pUnk->Release();
            return hres;
        }

        hres = pUnk->QueryInterface(IID_IGraphBuilder, (LPVOID *)&m_Gb);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            m_Gb->SetLogFile((DWORD_PTR) hRenderLog);
        }

        hres = m_Gb->RenderFile(FileName, NULL);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            CloseHandle(hRenderLog);
            hRenderLog = INVALID_HANDLE_VALUE;
        }

        hres = pUnk->QueryInterface(IID_IMediaControl, (LPVOID *)&m_Mc);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        //
        // Not being able to get the IMediaEvent interface does
        // necessarly mean that we can't play the graph.
        //
        pUnk->QueryInterface(IID_IMediaEvent, (LPVOID *)&m_Me);
        GetMovieEventHandle();

        pUnk->QueryInterface(IID_IMediaSeeking, (LPVOID *)&m_Ms);

        GetPerformanceInterfaces();

        if (SUCCEEDED(pUnk->QueryInterface(IID_IVideoWindow, (LPVOID *)&m_Vw))) {
            m_Vw->put_Caption(FileName);
            m_Vw->put_AutoShow(0);
        }

	hres = FindInterfaceFromFilterGraph(IID_IAMStreamSelect, (LPVOID *)&m_pStreamSelect);
	if (SUCCEEDED(hres)) {
	    DWORD cStreams;

	    m_pStreamSelect->Count(&cStreams);

	    DWORD i;

	    int iMenuItemsAdded = 0;

	    HMENU hmenu = GetMenu(m_hwndApp);
	    hmenu = GetSubMenu(hmenu, 3);

	    RemoveMenu(hmenu, 0, MF_BYPOSITION);
	    
	    DWORD dwLastGroup;
	    
	    for (i = 0; i < cStreams; i++) {
		WCHAR *pwszName;
		DWORD dwGroup;
		DWORD dwFlags;

		m_pStreamSelect->Info(i, NULL, &dwFlags, NULL, &dwGroup, &pwszName, NULL, NULL);

		if (iMenuItemsAdded > 0 && dwGroup != dwLastGroup)
		    InsertMenu(hmenu, iMenuItemsAdded++,
			       MF_SEPARATOR | MF_BYPOSITION, -1, NULL);

		dwLastGroup = dwGroup;

		TCHAR	ach[200];
		if (pwszName) {
#ifndef UNICODE
		    WideCharToMultiByte(CP_ACP,0,pwszName,-1,ach,200,NULL,NULL);
		    CoTaskMemFree(pwszName);
#else
		    lstrcpyW(ach, pwszName);
#endif
		} else {
		    wsprintf(ach, TEXT("Stream %d"), i);
		}

		DWORD dwMenuFlags = MF_STRING | MF_BYPOSITION;
		if (dwFlags & AMSTREAMSELECTINFO_ENABLED)
		    dwMenuFlags |= MF_CHECKED;
		
		InsertMenu(hmenu, iMenuItemsAdded++, dwMenuFlags, 2000+i, ach);
	    }
	}
	
        pUnk->Release();
        return S_OK;

    }
    else {
        m_Fg = NULL;
    }

    return hres;
}


/******************************Public*Routine******************************\
* CloseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
DWORD
CMpegMovie::CloseMovie(
    )
{
    m_Mode = MOVIE_NOTOPENED;
    m_bFullScreen = FALSE;

    if (m_Mc) {

        if (pMpegDecoder) {
            pMpegDecoder->Release();
            pMpegDecoder = NULL;
        }

        if (pMpegAudioDecoder) {
            pMpegAudioDecoder->Release();
            pMpegAudioDecoder = NULL;
        }

        if (pVideoRenderer) {
            pVideoRenderer->Release();
            pVideoRenderer = NULL;
        }

        if (m_Me) {
            m_MediaEvent = NULL;
            m_Me->Release();
            m_Me = NULL;
        }

        if (m_Ms) {
            m_Ms->Release();
            m_Ms = NULL;
        }

        if (m_Vw) {
            m_Vw->Release();
            m_Vw = NULL;
        }

	if (m_pStreamSelect) {
	    HMENU hmenu = GetMenu(m_hwndApp);
	    hmenu = GetSubMenu(hmenu, 3);

	    while (RemoveMenu(hmenu, 0, MF_BYPOSITION));
	    InsertMenu(hmenu, 0, MF_BYPOSITION | MF_STRING | MF_GRAYED,
		       -1, TEXT("(not available)"));
	    
	    m_pStreamSelect->Release();
	    m_pStreamSelect = NULL;
	}

        m_Mc->Release();
        m_Mc = NULL;

        if (m_Gb) {
            m_Gb->Release();
            m_Gb = NULL;
        }

        if (m_Fg) {
            m_Fg->Release();
            m_Fg = NULL;
        }


    }
    QzUninitialize();
    return 0L;
}


/******************************Public*Routine******************************\
* GetMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetMoviePosition(
    LONG *x,
    LONG *y,
    LONG *cx,
    LONG *cy
    )
{
    BOOL    bRet = FALSE;

    if (m_Vw) {
        bRet = (m_Vw->GetWindowPosition(x, y, cx, cy) == S_OK);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* PutMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PutMoviePosition(
    LONG x,
    LONG y,
    LONG cx,
    LONG cy
    )
{
    BOOL    bRet = FALSE;

    if (m_Vw) {
        bRet = (m_Vw->SetWindowPosition(x, y, cx, cy) == S_OK);
    }

    return bRet;
}


/******************************Public*Routine******************************\
* SetMovieWindowState
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetMovieWindowState(
    long uState
    )
{
    return SUCCEEDED(m_Vw->put_WindowState(uState));
}


/******************************Public*Routine******************************\
* SetWindowForeground
*
*
*
* History:
* dd-mm-95 - Anthonyp - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetWindowForeground(
    long Focus
    )
{
    return SUCCEEDED(m_Vw->SetWindowForeground(Focus));
}


/******************************Public*Routine******************************\
* GetMovieWindowState
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetMovieWindowState(
    long *lpuState
    )
{
    return S_OK == m_Vw->get_WindowState(lpuState);
}


/******************************Public*Routine******************************\
* PlayMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PlayMovie(
    )
{
    REFTIME rt;
    REFTIME rtAbs;
    REFTIME rtDur;

    rt = GetCurrentPosition();
    rtDur = GetDuration();

    //
    // If we are near the end of the movie seek to the start, otherwise
    // stay where we are.
    //
    rtAbs = rt - rtDur;
    if (rtAbs < (REFTIME)0) {
        rtAbs = -rtAbs;
    }

    if (rtAbs < (REFTIME)1) {
        SeekToPosition((REFTIME)0,FALSE);
    }

    //
    // Start playing from the begining of the movie
    //
    if (pMpegDecoder) {
        pMpegDecoder->ResetFrameStatistics();
    }

    if (m_Vw) {
        long lVis;
        m_Vw->get_Visible(&lVis);
        if (lVis == OAFALSE) {
            m_Vw->put_Visible(OATRUE);
        }
    }

    //
    // Change mode after setting m_Mode but before starting the graph
    //
    m_Mode = MOVIE_PLAYING;
    SetFullScreenMode(m_bFullScreen);
    m_Mc->Run();
    return TRUE;
}


/******************************Public*Routine******************************\
* PauseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PauseMovie(
    )
{
    m_Mode = MOVIE_PAUSED;
    m_Mc->Pause();
    return TRUE;
}


/******************************Public*Routine******************************\
* GetStateMovie
*
*
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/

OAFilterState
CMpegMovie::GetStateMovie(
    )
{
    OAFilterState State;
    m_Mc->GetState(INFINITE,&State);
    return State;
}


/******************************Public*Routine******************************\
* StopMovie
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::StopMovie(
    )
{
    m_Mode = MOVIE_STOPPED;
    m_Mc->Stop();
    return TRUE;
}


/******************************Public*Routine******************************\
* StatusMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
EMpegMovieMode
CMpegMovie::StatusMovie(
    )
{
    if (m_Mc) {

        FILTER_STATE    fs;
        HRESULT         hr;

        hr = m_Mc->GetState(100, (OAFilterState *)&fs);

        // Don't know what the state is so just stay at old state.
        if (hr == VFW_S_STATE_INTERMEDIATE) {
            return m_Mode;
        }

        switch (fs) {

        case State_Stopped:
            m_Mode = MOVIE_STOPPED;
            break;

        case State_Paused:
            m_Mode = MOVIE_PAUSED;
            break;

        case State_Running:
            m_Mode = MOVIE_PLAYING;
            break;
        }
    }

    return m_Mode;
}


/******************************Public*Routine******************************\
* GetMediaEventHandle
*
* Returns the IMediaEvent event hamdle for the filter graph iff the
* filter graph exists.
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HANDLE
CMpegMovie::GetMovieEventHandle(
    )
{
    HRESULT     hr;

    if (m_Me != NULL) {

        if ( m_MediaEvent == NULL) {
            hr = m_Me->GetEventHandle((OAEVENT *)&m_MediaEvent);
        }
    }
    else {
        m_MediaEvent = NULL;
    }

    return m_MediaEvent;
}


/******************************Public*Routine******************************\
* GetMovieEventCode
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
long
CMpegMovie::GetMovieEventCode()
{
    HRESULT hr;
    long    lEventCode;
	LONG_PTR	lParam1, lParam2;

    if (m_Me != NULL) {
        hr = m_Me->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
        if (SUCCEEDED(hr)) {
            return lEventCode;
        }
    }

    return 0L;
}


/******************************Public*Routine******************************\
* GetDuration
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetDuration()
{
    HRESULT hr;
    LONGLONG Duration;

    // Should we seek using IMediaSelection

    if (m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration) / UNITS;
        }
    }
    return 0;
}


/******************************Public*Routine******************************\
* GetCurrentPosition
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetCurrentPosition()
{
    REFTIME rt = (REFTIME)0;
    HRESULT hr;
    LONGLONG Position;

    // Should we return a media position

    if (m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position) / UNITS;
        }
    }
    return rt;
}


/*****************************Private*Routine******************************\
* SeekToPosition
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SeekToPosition(
    REFTIME rt,
    BOOL bFlushData
    )
{
    HRESULT hr;
    LONGLONG llTime = LONGLONG( m_TimeFormat == TIME_FORMAT_MEDIA_TIME ? rt * double(UNITS) : rt );

    if (m_Ms != NULL) {

        FILTER_STATE fs;
        m_Mc->GetState(100, (OAFilterState *)&fs);

        m_Ms->SetPositions(&llTime, AM_SEEKING_AbsolutePositioning, NULL, 0);

        // This gets new data through to the renderers

        if (fs == State_Stopped && bFlushData){
            m_Mc->Pause();
            hr = m_Mc->GetState(INFINITE, (OAFilterState *)&fs);
            m_Mc->Stop();
        }

        if (SUCCEEDED(hr)) {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************Private*Routine******************************\
* GetPerformanceInterfaces
*
*
*
* History:
* 31-10-95 - StephenE - Created
*
\**************************************************************************/
void
CMpegMovie::GetPerformanceInterfaces(
    )
{
    FindInterfaceFromFilterGraph(IID_IMpegVideoDecoder, (LPVOID *)&pMpegDecoder);
    FindInterfaceFromFilterGraph(IID_IMpegAudioDecoder, (LPVOID *)&pMpegAudioDecoder);
    FindInterfaceFromFilterGraph(IID_IQualProp, (LPVOID *)&pVideoRenderer);
}


HRESULT
CMpegMovie::FindInterfaceFromFilterGraph(
    REFIID iid, // interface to look for
    LPVOID *lp  // place to return interface pointer in
    )
{
    IEnumFilters*   pEF;	
    IBaseFilter*        pFilter;

    // Grab an enumerator for the filter graph.
    HRESULT hr = m_Fg->EnumFilters(&pEF);

    if (FAILED(hr)) {
        return hr;
    }

    // Check out each filter.
    while (pEF->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(iid, lp);
        pFilter->Release();

        if (SUCCEEDED(hr)) {
            break;
        }
    }

    pEF->Release();

    return hr;
}


/*****************************Public*Routine******************************\
* SetFullScreenMode
*
*
*
* History:
* 17-03-96 - AnthonyP - Created
*
\**************************************************************************/
void
CMpegMovie::SetFullScreenMode(BOOL bMode)
{
    m_bFullScreen = bMode;

    // Defer until we activate the movie

    if (m_Mode != MOVIE_PLAYING) {
        if (bMode == TRUE) {
            return;
        }
    }

    // Make the change now

    if (bMode == FALSE) {
        m_Vw->put_FullScreenMode(OAFALSE);
        m_Vw->put_MessageDrain((OAHWND) NULL);
    } else {
        m_Vw->put_MessageDrain((OAHWND) hwndApp);
        m_Vw->put_FullScreenMode(OATRUE);
    }
}


/*****************************Public*Routine******************************\
* IsFullScreenMode
*
*
*
* History:
* 17-03-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsFullScreenMode()
{
    return m_bFullScreen;
}


/*****************************Public*Routine******************************\
* IsTimeFormatSupported
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsTimeFormatSupported(GUID Format)
{
    return m_Ms != NULL && m_Ms->IsFormatSupported(&Format) == S_OK;
}


/*****************************Public*Routine******************************\
* IsTimeSupported
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsTimeSupported()
{
    return m_Ms != NULL && m_Ms->IsFormatSupported(&TIME_FORMAT_MEDIA_TIME) == S_OK;
}


/*****************************Public*Routine******************************\
* GetTimeFormat
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
GUID
CMpegMovie::GetTimeFormat()
{
    return m_TimeFormat;
}

/*****************************Public*Routine******************************\
* SetTimeFormat
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetTimeFormat(GUID Format)
{
    HRESULT hr = m_Ms->SetTimeFormat(&Format);
    if (SUCCEEDED(hr)) {
        m_TimeFormat = Format;
    }
    return SUCCEEDED(hr);
}

/******************************Public*Routine******************************\
* SetFocus
*
*
*
* History:
* 18-09-96 - SteveDav - Created
*
\**************************************************************************/
void
CMpegMovie::SetFocus()
{
    if (m_Fg) {

	// Tell the resource manager that we are being made active.  This
	// will then cause the sound to switch to us.  This is especially
	// important when playing audio only files as there is no other
	// playback window.
        IResourceManager* pResourceManager;

        HRESULT hr = m_Fg->QueryInterface(IID_IResourceManager, (void**)&pResourceManager);

        if (SUCCEEDED(hr)) {
            IUnknown* pUnknown;

            hr = m_Fg->QueryInterface(IID_IUnknown, (void**)&pUnknown);

            if (SUCCEEDED(hr)) {
                pResourceManager->SetFocus(pUnknown);
                pUnknown->Release();
            }

            pResourceManager->Release();
        }
    }
}

BOOL CMpegMovie::SelectStream(int iStream)
{
    HRESULT hr = E_NOINTERFACE;
    
    if (m_pStreamSelect) {
	hr = m_pStreamSelect->Enable(iStream, AMSTREAMSELECTENABLE_ENABLE);
    }

    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\vcdplyer.h ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/



/* -------------------------------------------------------------------------
** CMpegMovie - an Mpeg movie playback class.
** -------------------------------------------------------------------------
*/
enum EMpegMovieMode { MOVIE_NOTOPENED = 0x00,
                      MOVIE_OPENED = 0x01,
                      MOVIE_PLAYING = 0x02,
                      MOVIE_STOPPED = 0x03,
                      MOVIE_PAUSED = 0x04 };

struct IMpegAudioDecoder;
struct IMpegVideoDecoder;
struct IQualProp;

class CMpegMovie {

private:
    // Our state variable - records whether we are opened, playing etc.
    EMpegMovieMode   m_Mode;
    HANDLE           m_MediaEvent;
    HWND             m_hwndApp;
    BOOL             m_bFullScreen;
    GUID             m_TimeFormat;

    IFilterGraph     *m_Fg;
    IGraphBuilder    *m_Gb;
    IMediaControl    *m_Mc;
    IMediaSeeking    *m_Ms;
    IMediaEvent      *m_Me;
    IVideoWindow     *m_Vw;

    void GetPerformanceInterfaces();
    HRESULT FindInterfaceFromFilterGraph(
        REFIID iid, // interface to look for
        LPVOID *lp  // place to return interface pointer in
        );

public:
     CMpegMovie(HWND hwndApplication);
    ~CMpegMovie();

    HRESULT         OpenMovie(TCHAR *lpFileName);
    DWORD           CloseMovie();
    BOOL            PlayMovie();
    BOOL            PauseMovie();
    BOOL            StopMovie();
    OAFilterState   GetStateMovie();
    HANDLE          GetMovieEventHandle();
    long            GetMovieEventCode();
    BOOL            PutMoviePosition(LONG x, LONG y, LONG cx, LONG cy);
    BOOL            GetMoviePosition(LONG *x, LONG *y, LONG *cx, LONG *cy);
    BOOL            GetMovieWindowState(long *lpuState);
    BOOL            SetMovieWindowState(long uState);
    REFTIME         GetDuration();
    REFTIME         GetCurrentPosition();
    BOOL            SeekToPosition(REFTIME rt,BOOL bFlushData);
    EMpegMovieMode  StatusMovie();
    void            SetFullScreenMode(BOOL bMode);
    BOOL            IsFullScreenMode();
    BOOL            SetWindowForeground(long Focus);
    BOOL            IsTimeFormatSupported(GUID Format);
    BOOL            IsTimeSupported();
    BOOL            SetTimeFormat(GUID Format);
    GUID            GetTimeFormat();
    void            SetFocus();
    BOOL            ConfigDialog(HWND hwnd);
    BOOL	    SelectStream(int iStream);


    IMpegVideoDecoder   *pMpegDecoder;
    IMpegAudioDecoder   *pMpegAudioDecoder;
    IQualProp           *pVideoRenderer;
    IAMStreamSelect	*m_pStreamSelect;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\analogradiotsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// analogradiotsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef ANALOGRADIOTSIMPL_H
#define ANALOGRADIOTSIMPL_H

#include "tuningspaceimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IAnalogRadioTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IAnalogRadioTSImpl : 
	public ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    IAnalogRadioTSImpl() : m_MinFreq(BDA_UNDEFINED_CHANNEL), m_MaxFreq(BDA_UNDEFINED_CHANNEL), m_Step(0) {}
    virtual ~IAnalogRadioTSImpl() {}
    typedef ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IAnalogRadioTSImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("MinFrequency", m_MinFreq, VT_I4)
        PROP_DATA_ENTRY("MaxFrequency", m_MaxFreq, VT_I4)
        PROP_DATA_ENTRY("Step", m_Step, VT_I4)
    END_PROPERTY_MAP()

    long m_MinFreq;
    long m_MaxFreq;
    long m_Step;

// IAnalogRadioTS
    STDMETHOD(get_MinFrequency)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MinFreq;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MinFrequency)(long newVal)
    {   
		ATL_LOCKT();
        if (newVal > m_MaxFreq) {
		  return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogRadioTuningSpace), E_INVALIDARG);
		}
        m_MinFreq = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxFrequency)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MaxFreq;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MaxFrequency)(long newVal)
    {
        if (newVal < m_MinFreq) {
		  return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogRadioTuningSpace), E_INVALIDARG);
		}
		ATL_LOCKT();
        m_MaxFreq = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Step)(long* pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_Step;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_Step)(long newVal)
    {
		ATL_LOCKT();
        m_Step = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

			T* pt = static_cast<T*>(*ppTS);

            pt->m_MinFreq = m_MinFreq;
            pt->m_MaxFreq = m_MaxFreq;
            pt->m_Step = m_Step;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace
#endif // ANALOGRADIOTSIMPL_H
// end of file -- analogradiotsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\analogtunerimpl.h ===
//==========================================================================;
//
// devimpl.h : additional infrastructure to support implementing IMSVidDevice 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef ANALOGTUNERIMPL_H
#define ANALOGTUNERIMPL_H

#include "tunerimpl.h"

namespace MSVideoControl {

template<class T, 
		 LPCGUID LibID, 
		 LPCGUID KSCategory, 
		 class MostDerivedInterface = IMSVidDevice>
    class DECLSPEC_NOVTABLE IMSVidAnalogTunerImpl : public IMSVidTunerImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	virtual ~IMSVidAnalogTunerImpl() {}
    virtual PQTVTuner GetTuner() = 0;

	virtual HRESULT DoTune(PQTuneRequest &pTR) {
		PQChannelTuneRequest ctr(pTR);
		if (!ctr) {
	        return ImplReportError(__uuidof(T), IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), DISP_E_TYPEMISMATCH);
		}
		return NOERROR;
	}
    // IMSVidAnalogTuner
	STDMETHOD(get_Channel)(LONG * Channel)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (Channel == NULL)
			return E_POINTER;
        try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            long vsc, asc;
            return pTV->get_Channel(Channel, &vsc, &asc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(put_Channel)(LONG Channel)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
        try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->put_Channel(Channel, 0, 0);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_VideoFrequency)(LONG * lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lcc == NULL)
			return E_POINTER;			
        try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->get_VideoFrequency(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_AudioFrequency)(LONG * lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lcc == NULL)
			return E_POINTER;
		try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->get_AudioFrequency(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_CountryCode)(LONG * lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lcc == NULL)
			return E_POINTER;
		try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->get_CountryCode(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(put_CountryCode)(LONG lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
                return HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
            }
            return pTV->put_CountryCode(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_SAP)(VARIANT_BOOL *pfSAP)
	{
        HRESULT hr = S_OK;
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (pfSAP == NULL)
			return E_POINTER;
        DSFilterList::iterator i;
        CComQIPtr<IAMTVAudio>spTVAudio;
        for(i = m_Filters.begin(); i != m_Filters.end(); ++i){
            spTVAudio = *i;
            if(spTVAudio){
                break;
            }
        }
        
        if(i == m_Filters.end()){
            return E_NOINTERFACE;
        }
        
        long dwMode = 0;
#if 0
        hr = spTVAudio->GetHardwareSupportedTVAudioModes(&dwMode);
        if(FAILED(hr)){
            return hr;
        }  
        hr = spTVAudio->GetAvailableTVAudioModes(&dwMode);
        if(FAILED(hr)){
            return hr;
        }
#endif
        hr = spTVAudio->get_TVAudioMode(&dwMode);
        if(FAILED(hr)){
            return hr;
        }
        if(dwMode & AMTVAUDIO_MODE_LANG_B){
            *pfSAP = VARIANT_FALSE;
        }
        else{
            *pfSAP = VARIANT_TRUE;
        }
        return S_OK;
	}
	STDMETHOD(put_SAP)(VARIANT_BOOL fSAP)
	{
        HRESULT hr = S_OK;
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
        DSFilterList::iterator i;
        CComQIPtr<IAMTVAudio>spTVAudio;
        for(i = m_Filters.begin(); i != m_Filters.end(); ++i){
            spTVAudio = *i;
            if(spTVAudio){
                break;
            }
        }
        if(i == m_Filters.end()){
            return E_NOINTERFACE;
        }
        long dwMode = 0;
        if(fSAP == VARIANT_TRUE){
            dwMode = AMTVAUDIO_MODE_LANG_B | AMTVAUDIO_MODE_MONO;
            hr = spTVAudio->put_TVAudioMode(dwMode);
        }
        else{
            dwMode = AMTVAUDIO_MODE_STEREO | AMTVAUDIO_MODE_LANG_A;
            hr = spTVAudio->put_TVAudioMode(dwMode);
        }
        if(FAILED(hr)){
            return hr;
        }
		return S_OK;
	}
	STDMETHOD(ChannelAvailable)(LONG nChannel, LONG * SignalStrength, VARIANT_BOOL * fSignalPresent)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (SignalStrength == NULL)
			return E_POINTER;
			
		if (fSignalPresent == NULL)
			return E_POINTER;
        CComQIPtr<IAMTuner> pTV(GetTuner());
        if (!pTV) {
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }			
        long curChannel = 0;
        HRESULT hr = get_Channel(&curChannel);
        if(nChannel != curChannel){
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        hr = pTV->SignalPresent(SignalStrength);
        if(FAILED(hr)){
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        if(hr == S_FALSE){
            *SignalStrength = 0;
            *fSignalPresent = VARIANT_FALSE;
            return S_OK;
        }
        CComQIPtr<IAMTVTuner> qiTV(GetTuner());
        if (!qiTV){
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        long foundSignal;
        hr = qiTV->AutoTune(curChannel, &foundSignal);
        if(hr == S_FALSE){
            *SignalStrength = 0;
            *fSignalPresent = VARIANT_FALSE;
            return S_OK;
        }
        if(foundSignal){
            *fSignalPresent = VARIANT_TRUE;
        }
        else{
            *fSignalPresent = VARIANT_FALSE;
        }
		return S_OK;
	}
#if 0
	STDMETHOD(MinMaxChannel)(LONG * lChannelMin, LONG * lChannelMax)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lChannelMin == NULL)
			return E_POINTER;
			
		if (lChannelMax == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
#endif
};

}; //namespace

#endif
// end of file - analogtunerimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\analogtvtsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// analogtvtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef ANALOGTVTSIMPL_H
#define ANALOGTVTSIMPL_H

#include "errsupp.h"
#include "tuningspaceimpl.h"
#include "ChannelTuneRequest.h"

namespace BDATuningModel {

template<class T,
         class TUNEREQUESTTYPE = CChannelTuneRequest,
         class MostDerived = IAnalogTVTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IAnalogTVTSImpl : 
	public ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    IAnalogTVTSImpl() : m_MinChan(BDA_UNDEFINED_CHANNEL), m_MaxChan(BDA_UNDEFINED_CHANNEL), m_InputType(TunerInputCable), m_CountryCode(0) {}
	virtual ~IAnalogTVTSImpl() {}
    typedef ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IAnalogTVTSImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("MinChannel", m_MinChan, VT_I4)
        PROP_DATA_ENTRY("MaxChannel", m_MaxChan, VT_I4)
        PROP_DATA_ENTRY("InputType", m_InputType, VT_UI4)
        PROP_DATA_ENTRY("CountryCode", m_CountryCode, VT_I4)
    END_PROPERTY_MAP()

    long m_MinChan;
    long m_MaxChan;
    TunerInputType m_InputType;
    long m_CountryCode;

// IAnalogTVTS
    STDMETHOD(get_MinChannel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MinChan;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MinChannel)(long newVal)
    {
		if (newVal > m_MaxChan) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogTVTuningSpace), E_INVALIDARG);
		}
		ATL_LOCKT();
        m_MinChan = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxChannel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MaxChan;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MaxChannel)(long newVal)
    {
		if (newVal < m_MinChan) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogTVTuningSpace), E_INVALIDARG);
		}
		ATL_LOCKT();
        m_MaxChan = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_InputType)(TunerInputType* pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_InputType;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_InputType)(TunerInputType newVal)
    {
		ATL_LOCKT();
        m_InputType = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_CountryCode)(long* pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_CountryCode;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_CountryCode)(long newVal)
    {
		ATL_LOCKT();
        m_CountryCode = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

			T* pt = static_cast<T*>(*ppTS);

            pt->m_MinChan = m_MinChan;
            pt->m_MaxChan = m_MaxChan;
            pt->m_InputType = m_InputType;
            pt->m_CountryCode = m_CountryCode;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // ANALOGTVTSIMPL_H
// end of file -- analogtvtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\tools\vcdplyer\property.cpp ===
/******************************Module*Header*******************************\
* Module Name: property.cpp
*
* Support for the mpeg video and audio decoder property pages.
*
*
* Created: 24-01-96
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>

extern HINSTANCE           hInst;
extern HWND                hwndApp;
extern CMpegMovie          *pMpegMovie;

extern "C" {
INT_PTR CALLBACK
VideoStatsDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
VideoDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
AudioDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );
}

void
UpdateStats(
    HWND hwnd
    );

TCHAR *
StringFromId(
    int idResource
    );

void
SetDecoderOption(
    HWND m_hwnd,
    DWORD dwOptions
    );

DWORD
GetDecoderOption(
    HWND m_hwnd
    );

void
GetButtonValues(
    HWND m_hwnd,
    LPDWORD iChannels,
    LPDWORD iSkip,
    LPDWORD iQuality,
    LPDWORD iInteger,
    LPDWORD iOutputWordSize
    );

void
SetButtonValues(
    HWND m_hwnd,
    DWORD iChannels,
    DWORD iSkip,
    DWORD iQuality,
    DWORD iInteger,
    DWORD iOutputWordSize
    );

void
PutDecoderInteger(
    const TCHAR *pKey,
    int iValue
    );

/* -------------------------------------------------------------------------
** Decoder strings
** -------------------------------------------------------------------------
*/
const TCHAR chVideoFramesDecoded[] = TEXT("VideoFramesDecoded");
const TCHAR chVideoQuality[]       = TEXT("VideoQuality");
const TCHAR chGreyScale[]          = TEXT("GreyScale");
const TCHAR chIgnoreQMessages[]    = TEXT("IgnoreQMessages");

const TCHAR chAudioChannels[]      = TEXT("AudioChannels");
const TCHAR chAudioFreqDivider[]   = TEXT("AudioFreqDivider");
const TCHAR chAudioQuality[]       = TEXT("AudioQuality");
const TCHAR chAudioQuarterInt[]    = TEXT("AudioQuarterInt");
const TCHAR chAudioBits[]          = TEXT("AudioBits");
const TCHAR chRegistryKey[]        = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\MPEG Decoder");


/******************************Public*Routine******************************\
* DoMpegVideoPropertyPage
*
*
*
* History:
* 24-01-96 - StephenE - Created
*
\**************************************************************************/
void
DoMpegVideoPropertyPage()
{
    DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_VIDEOPROP),
                   hwndApp, VideoDialogProc, (LPARAM)NULL);
}



/******************************Public*Routine******************************\
* DoMpegAudioPropertyPage
*
*
*
* History:
* 24-01-96 - StephenE - Created
*
\**************************************************************************/
void
DoMpegAudioPropertyPage()
{
    DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_AUDIOPROP),
                   hwndApp, AudioDialogProc, (LPARAM)NULL);
}


/******************************Public*Routine******************************\
* VideoDialogProc
*
* Handles the messages for our property window
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
VideoDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD m_dwDecoderOptions;
    BOOL  m_fQualityOption;
    BOOL  m_fGreyScaleOption;

    switch (uMsg) {
    case WM_INITDIALOG:
        pMpegMovie->pMpegDecoder->get_DefaultDecoderOption(&m_dwDecoderOptions);
        pMpegMovie->pMpegDecoder->get_QualityMsgProcessing(&m_fQualityOption);
        pMpegMovie->pMpegDecoder->get_GreyScaleOutput(&m_fGreyScaleOption);

        SetDecoderOption(hwnd, m_dwDecoderOptions);
        Button_SetCheck(GetDlgItem(hwnd, B_GREY), m_fGreyScaleOption);
        Button_SetCheck(GetDlgItem(hwnd, IGNORE_QUALITY), m_fQualityOption);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        case IDOK:
            m_dwDecoderOptions = GetDecoderOption(hwnd);
            m_fQualityOption   = Button_GetCheck(GetDlgItem(hwnd, IGNORE_QUALITY));
            m_fGreyScaleOption = Button_GetCheck(GetDlgItem(hwnd, B_GREY));

            pMpegMovie->pMpegDecoder->set_DefaultDecoderOption(m_dwDecoderOptions);
            pMpegMovie->pMpegDecoder->set_QualityMsgProcessing(m_fQualityOption);
            pMpegMovie->pMpegDecoder->set_GreyScaleOutput(m_fGreyScaleOption);
            EndDialog(hwnd, wParam);
            break;

        case STATS_BUTTON:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_VIDEOSTATS),
                           hwnd, VideoStatsDialogProc, (LPARAM)NULL);
            break;

        case ID_DEFAULT:
            m_dwDecoderOptions = GetDecoderOption(hwnd);
            PutDecoderInteger(chVideoFramesDecoded, m_dwDecoderOptions & 0x3F);
            PutDecoderInteger(chVideoQuality, m_dwDecoderOptions & 0x30000000);

            PutDecoderInteger(chGreyScale,
                              Button_GetCheck(GetDlgItem(hwnd, B_GREY)));

            PutDecoderInteger(chIgnoreQMessages,
                              Button_GetCheck(GetDlgItem(hwnd, IGNORE_QUALITY)));
            break;
        }
        return TRUE;

    default:
        return FALSE;

    }
}

/*****************************Private*Routine******************************\
* SetDecoderOption
*
* This function puts the buttons on the property page into the state that
* corresponds to the passed in dwOptions parameter.
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
void
SetDecoderOption(
    HWND m_hwnd,
    DWORD dwOptions
    )
{
    switch (dwOptions & 0x0FFFFFFF) {

    case DECODE_I:
        Button_SetCheck(GetDlgItem(m_hwnd, I_ONLY), TRUE );
        break;

    case DECODE_IP:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_ONLY), TRUE );
        break;

    case DECODE_IPB:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_ALL_B), TRUE );
        break;

    case DECODE_IPB1:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_1_IN_4_B), TRUE );
        break;

    case DECODE_IPB2:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_2_IN_4_B), TRUE );
        break;

    case DECODE_IPB3:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_3_IN_4_B), TRUE );
        break;
    }

    switch (dwOptions & 0xF0000000) {
    case DECODE_BQUAL_HIGH:
        Button_SetCheck(GetDlgItem(m_hwnd, B_HIGH), TRUE );
        break;

    case DECODE_BQUAL_MEDIUM:
        Button_SetCheck(GetDlgItem(m_hwnd, B_MEDIUM), TRUE );
        break;

    case DECODE_BQUAL_LOW:
        Button_SetCheck(GetDlgItem(m_hwnd, B_LOW), TRUE );
        break;
    }
}

/*****************************Private*Routine******************************\
* GetDecoderOption
*
* Returns the decoder options from the property page dialog.
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
DWORD
GetDecoderOption(
    HWND m_hwnd
    )
{
    DWORD dwOption = 0L;

    if (Button_GetCheck(GetDlgItem(m_hwnd, I_ONLY))) {
        dwOption = DECODE_I;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, I_ONLY))) {
        dwOption = DECODE_I;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_ONLY))) {
        dwOption = DECODE_IP;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_ALL_B))) {
        dwOption = DECODE_IPB;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_1_IN_4_B))) {
        dwOption = DECODE_IPB1;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_2_IN_4_B))) {
        dwOption = DECODE_IPB2;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_3_IN_4_B))) {
        dwOption = DECODE_IPB3;
    }


    if (Button_GetCheck(GetDlgItem(m_hwnd, B_HIGH))) {
        dwOption |= DECODE_BQUAL_HIGH;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, B_MEDIUM))) {
        dwOption |= DECODE_BQUAL_MEDIUM;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, B_LOW))) {
        dwOption |= DECODE_BQUAL_LOW;
    }

    return dwOption;
}

/******************************Public*Routine******************************\
* VideoStatsDialogProc
*
* Handles the messages for our property window
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
VideoStatsDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowFont(GetDlgItem(hwnd,ID_STATSBOX),
                      GetStockObject(ANSI_FIXED_FONT), FALSE);
        UpdateStats(hwnd);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
        case IDOK:
            EndDialog(hwnd, wParam);
            break;

        case ID_REFRESH:
            UpdateStats(hwnd);
            break;
        }
        return TRUE;

    default:
        return FALSE;
    }
}

/*****************************Private*Routine******************************\
* UpdateStats
*
* Gets the video decoder statics and then formats and displays then in the
* read only edit field.
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
void
UpdateStats(
    HWND hwnd
    )
{
    DWORD       dwIFramesDecoded;
    DWORD       dwPFramesDecoded;
    DWORD       dwBFramesDecoded;
    DWORD       dwIFramesSkipped;
    DWORD       dwPFramesSkipped;
    DWORD       dwBFramesSkipped;
    DWORD       dwTotalFrames;
    DWORD       dwTotalIFrames;
    DWORD       dwTotalPFrames;
    DWORD       dwTotalBFrames;
    DWORD       dwTotalDecoded;
    TCHAR       Text[1024];
    SEQHDR_INFO SeqHdr;

    pMpegMovie->pMpegDecoder->get_SequenceHeader(&SeqHdr);

    pMpegMovie->pMpegDecoder->get_FrameStatistics(
                    &dwIFramesDecoded, &dwPFramesDecoded, &dwBFramesDecoded,
                    &dwIFramesSkipped, &dwPFramesSkipped, &dwBFramesSkipped);

    dwTotalIFrames = dwIFramesDecoded + dwIFramesSkipped;
    dwTotalPFrames = dwPFramesDecoded + dwPFramesSkipped;
    dwTotalBFrames = dwBFramesDecoded + dwBFramesSkipped;
    dwTotalFrames  = dwTotalIFrames   + dwTotalPFrames   + dwTotalBFrames;
    dwTotalDecoded = dwIFramesDecoded + dwPFramesDecoded + dwBFramesDecoded;

    wsprintf(Text, StringFromId(IDS_IMAGE_SIZE), SeqHdr.lWidth, SeqHdr.lHeight);
    wsprintf(Text + lstrlen(Text), StringFromId(IDS_BUFFER_VBV), SeqHdr.lvbv);
    wsprintf(Text + lstrlen(Text), StringFromId(IDS_BITRATE), SeqHdr.dwBitRate);

    if (dwTotalFrames != 0) {

        lstrcat(Text, StringFromId(IDS_NEWLINE));
        wsprintf(Text + lstrlen(Text), StringFromId(IDS_FRAMES_DEC),
                 dwTotalDecoded, dwTotalFrames);
        wsprintf(Text + lstrlen(Text), StringFromId(IDS_PROPORTION),
                 (100 * dwTotalDecoded) / dwTotalFrames);

        lstrcat(Text, StringFromId(IDS_NEWLINE));
        wsprintf(Text + lstrlen(Text), StringFromId(IDS_SKIP_I),
                 dwIFramesDecoded, dwIFramesSkipped);

        wsprintf(Text + lstrlen(Text), StringFromId(IDS_SKIP_P),
                 dwPFramesDecoded, dwPFramesSkipped);

        wsprintf(Text + lstrlen(Text), StringFromId(IDS_SKIP_B),
                 dwBFramesDecoded, dwBFramesSkipped);
    }

    SetWindowText(GetDlgItem(hwnd, ID_STATSBOX), Text);
}


/******************************Public*Routine******************************\
* AudioDialogProc
*
* Handles the messages for our property window
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
AudioDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD m_iChannels;
    DWORD m_iSkip;
    DWORD m_iQuality;
    DWORD m_iInteger;
    DWORD m_iWordSize;

    switch (uMsg) {
    case WM_INITDIALOG:
        pMpegMovie->pMpegAudioDecoder->get_Stereo(&m_iChannels);
        pMpegMovie->pMpegAudioDecoder->get_IntegerDecode(&m_iInteger );
        pMpegMovie->pMpegAudioDecoder->get_FrequencyDivider(&m_iSkip);
        pMpegMovie->pMpegAudioDecoder->get_DecoderAccuracy(&m_iQuality);
        pMpegMovie->pMpegAudioDecoder->get_DecoderWordSize(&m_iWordSize);
        SetButtonValues(hwnd, m_iChannels, m_iSkip,
                        m_iQuality, m_iInteger, m_iWordSize);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        case IDOK:
            GetButtonValues(hwnd, &m_iChannels, &m_iSkip, &m_iQuality,
                            &m_iInteger, &m_iWordSize);

            pMpegMovie->pMpegAudioDecoder->put_Stereo(m_iChannels);
            pMpegMovie->pMpegAudioDecoder->put_IntegerDecode(m_iInteger );
            pMpegMovie->pMpegAudioDecoder->put_FrequencyDivider(m_iSkip);
            pMpegMovie->pMpegAudioDecoder->put_DecoderAccuracy(m_iQuality);
            pMpegMovie->pMpegAudioDecoder->put_DecoderWordSize(m_iWordSize);
            EndDialog(hwnd, wParam);
            break;

        case IDC_AINFO:
//          DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_VIDEOSTATS),
//                         hwnd, VideoStatsDialogProc, (LPARAM)pThis);
            break;

        case IDC_ADEFAULT:
            GetButtonValues(hwnd, &m_iChannels, &m_iSkip,
                            &m_iQuality, &m_iInteger, &m_iWordSize);

            PutDecoderInteger(chAudioChannels,    m_iChannels);
            PutDecoderInteger(chAudioFreqDivider, m_iSkip);
            PutDecoderInteger(chAudioQuality,     m_iQuality);
            PutDecoderInteger(chAudioQuarterInt,  m_iInteger);
            PutDecoderInteger(chAudioBits,        m_iWordSize);
            break;
        }
        return TRUE;

    default:
        return FALSE;

    }
}

/*****************************Private*Routine******************************\
*
* SetButtonValues
*
* Sets the buttons in the dialog
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
void
SetButtonValues(
    HWND m_hwnd,
    DWORD iChannels,
    DWORD iSkip,
    DWORD iQuality,
    DWORD iInteger,
    DWORD iWordSize
    )
{
    Button_SetCheck(GetDlgItem(m_hwnd, STEREO_OUTPUT), iChannels == 2);

    int iButton;
    if (iInteger) {
        iButton = IDC_INTEGER;
    }
    else {
        switch (iSkip) {
        case 1:
            iButton = FULL_FREQ;
            break;
        case 2:
            iButton = HALF_FREQ;
            break;
        case 4:
            iButton = QUARTER_FREQ;
            break;
        default:
            DbgBreak("Illegal case");
        }
    }
    Button_SetCheck(GetDlgItem(m_hwnd, iButton), TRUE);

    switch (iQuality) {
    case DECODE_HALF_FULLQ:
        iButton = D_MEDIUM;
        break;

    case DECODE_HALF_HIQ:
        iButton = D_LOW;
        break;

    default:
        iButton = D_HIGH;
        break;
    }
    Button_SetCheck(GetDlgItem(m_hwnd, iButton), TRUE);

    switch(iWordSize) {
    case 16:
        iButton = IDC_16_BIT;
        break;

    default:
        iButton = IDC_8_BIT;
        break;
    }
    Button_SetCheck(GetDlgItem(m_hwnd, iButton), TRUE);
}

/*****************************Private*Routine******************************\
* GetButtonValues
*
* Gets the values of the button settings
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
void
GetButtonValues(
    HWND m_hwnd,
    LPDWORD iChannels,
    LPDWORD iSkip,
    LPDWORD iQuality,
    LPDWORD iInteger,
    LPDWORD iOutputWordSize
    )
{

    *iChannels = Button_GetCheck(GetDlgItem(m_hwnd, STEREO_OUTPUT)) ? 2 : 1;
    *iInteger = 0;

    if (Button_GetCheck(GetDlgItem(m_hwnd, FULL_FREQ))) {
        *iSkip = 1;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, HALF_FREQ))) {
        *iSkip = 2;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, QUARTER_FREQ))) {
        *iSkip = 4;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IDC_INTEGER))) {
        *iSkip = 4;
        *iInteger = 1;
    }
    else {
        DbgBreak("One button should be set");
    }

    if (Button_GetCheck(GetDlgItem(m_hwnd, D_MEDIUM))) {
        *iQuality = DECODE_HALF_FULLQ;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, D_LOW))) {
        *iQuality = DECODE_HALF_HIQ;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, D_HIGH))) {
        *iQuality = 0L;
    }
    else {
        DbgBreak("One button should be set");
    }

    if (Button_GetCheck(GetDlgItem(m_hwnd, IDC_8_BIT))) {
        *iOutputWordSize = 8;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IDC_16_BIT))) {
        *iOutputWordSize = 16;
    }
    else {
        DbgBreak("One button should be set");
    }
}


/******************************Public*Routine******************************\
* StringFromId
*
*
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
TCHAR *
StringFromId(
    int idResource
    )
{
    static TCHAR chBuffer[ STR_MAX_STRING_LEN ];
    static TCHAR chEmpty[] = TEXT("");

    if (LoadString(hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
        return chEmpty;
    }

    return chBuffer;
}


/******************************Public*Routine******************************\
* PutDecoderDword
*
*
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
void
PutDecoderInteger(
    const TCHAR *pKey,
    int iValue
    )
{
    HKEY hKey;

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER,
                                      chRegistryKey, &hKey)) {
        DWORD dwTmp = (DWORD)iValue;
        RegSetValueEx(hKey, pKey, 0L, REG_DWORD, (LPBYTE)&dwTmp, sizeof(dwTmp));
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atsctsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef ATSCTSIMPL_H
#define ATSCTSIMPL_H

#include "errsupp.h"
#include "analogtvtsimpl.h"
#include "ATSCChannelTuneRequest.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCTSImpl : 
	public IAnalogTVTSImpl<T, CATSCChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass>,
    public IMPEG2TuneRequestSupport
{

public:
    IATSCTSImpl() : 
	    m_MinMinorChannel(-1), 
		m_MaxMinorChannel(-1),
	    m_MinPhysicalChannel(-1), 
		m_MaxPhysicalChannel(-1)
		{}
	virtual ~IATSCTSImpl() {}
    typedef IAnalogTVTSImpl<T, CATSCChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IATSCTSImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Min Minor Channel", m_MinMinorChannel, VT_I4)
        PROP_DATA_ENTRY("Max Minor Channel", m_MaxMinorChannel, VT_I4)
        PROP_DATA_ENTRY("Min Physical Channel", m_MinPhysicalChannel, VT_I4)
        PROP_DATA_ENTRY("Max Physical Channel", m_MaxPhysicalChannel, VT_I4)
    END_PROPERTY_MAP()

	long m_MinMinorChannel;
	long m_MaxMinorChannel;
	long m_MinPhysicalChannel;
	long m_MaxPhysicalChannel;

    // override standard ITuningSpaceImpl
    STDMETHOD(put_DefaultLocator)(ILocator *pLoc) {
        if (pLoc) {
            PQATSCLocator p(pLoc);
            if (!p) {
                return DISP_E_TYPEMISMATCH;
            }
        }
        return basetype::put_DefaultLocator(pLoc);
    }

    // IATSCTuningSpace
    STDMETHOD(get_MinMinorChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MinMinorChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MinMinorChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal > m_MaxMinorChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}

        m_MinMinorChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxMinorChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MaxMinorChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MaxMinorChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal < m_MinMinorChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}
        m_MaxMinorChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MinPhysicalChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MinPhysicalChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MinPhysicalChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal > m_MaxPhysicalChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}
        m_MinPhysicalChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxPhysicalChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MaxPhysicalChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MaxPhysicalChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal < m_MinPhysicalChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}
        m_MaxPhysicalChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(Clone) (ITuningSpace **ppTS) {
		if (!ppTS) {
			return E_POINTER;
		}
        *ppTS = NULL;
		ATL_LOCKT();
        try {
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

			T* pt = static_cast<T*>(*ppTS);

            pt->m_MinMinorChannel = m_MinMinorChannel;
            pt->m_MaxMinorChannel = m_MaxMinorChannel;
            pt->m_MinPhysicalChannel = m_MinPhysicalChannel;
            pt->m_MaxPhysicalChannel = m_MaxPhysicalChannel;

			return NOERROR;
        } CATCHCOM_CLEANUP(if (*ppTS) {
                               (*ppTS)->Release();
                               *ppTS = NULL;
                           }
                          );
	}




};

}; // namespace

#endif // ATSCTSIMPL_H
// end of file -- ATSCtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atsclocatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCLocatorimpl.h : implementation helper template for ATSClocator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef ATSCLOCATORIMPL_H
#define ATSCLOCATORIMPL_H

#include <locatorimpl.h>

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCLocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCLocatorImpl : 
	public ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IATSCLocator
public:

	typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    typedef IATSCLocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;

	long m_PhysicalChannel;
	long m_TSID;
	long m_ProgramNumber;

    IATSCLocatorImpl() : m_PhysicalChannel(BDA_UNDEFINED_CHANNEL),
                         m_TSID(-1),
                         m_ProgramNumber(-1) {}
	virtual ~IATSCLocatorImpl() {}
    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Physical Channel", m_PhysicalChannel, VT_I4)
        PROP_DATA_ENTRY("Transport Stream ID", m_TSID, VT_I4)
        PROP_DATA_ENTRY("Program Number", m_ProgramNumber, VT_I4)
    END_PROP_MAP()

// IATSCLocator
public:
    STDMETHOD(get_PhysicalChannel)(/*[out, retval]*/ long *pPhysicalChannel) {
        try {
            if (!pPhysicalChannel) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pPhysicalChannel = m_PhysicalChannel;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_PhysicalChannel)(/*[in]*/ long NewPhysicalChannel) {
		ATL_LOCKT();
        m_PhysicalChannel = NewPhysicalChannel;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_TSID)(/*[out, retval]*/ long *pTSID) {
        try {
            if (!pTSID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pTSID = m_TSID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_TSID)(/*[in]*/ long NewTSID) {
		ATL_LOCKT();
        m_TSID = NewTSID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_ProgramNumber)(/*[out, retval]*/ long *pProgramNumber) {
        try {
            if (!pProgramNumber) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pProgramNumber = m_ProgramNumber;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_ProgramNumber)(/*[in]*/ long NewProgramNumber) {
		ATL_LOCKT();
        m_ProgramNumber = NewProgramNumber;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_PhysicalChannel = m_PhysicalChannel;
			pt->m_TSID = m_TSID;
			pt->m_ProgramNumber = m_ProgramNumber;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

typedef CComQIPtr<IATSCLocator> PQATSCLocator;

}; // namespace

#endif // ATSCLOCATORIMPL_H
// end of file -- ATSClocatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\auxintsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// auxintsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef AUXINTSIMPL_H
#define AUXINTSIMPL_H

#include "tuningspaceimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IAuxInTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IAuxInTSImpl : 
	public ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    IAuxInTSImpl() {}
    virtual ~IAuxInTSImpl() {}
    typedef ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IAuxInTSImpl)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

// IAuxInTS

    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

            //			T* pt = static_cast<T*>(*ppTS);
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace
#endif // AUXINTSIMPL_H
// end of file -- AuxIntsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atscchanneltunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCChannelTuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef ATSCCHANNELTUNEREQUESTIMPL_H
#define ATSCCHANNELTUNEREQUESTIMPL_H

#include "channeltunerequestimpl.h"
#include "atsclocator.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCChannelTuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCChannelTuneRequestImpl : 
	public IChannelTuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IATSCChannelTuneRequest
public:
    typedef IChannelTuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
	virtual ~IATSCChannelTuneRequestImpl() {}
	IATSCChannelTuneRequestImpl() : m_MinorChannel(-1){}

    BEGIN_PROP_MAP(IATSCChannelTuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Minor Channel", m_MinorChannel, VT_I4)
    END_PROP_MAP()

	long m_MinorChannel;

    STDMETHOD(get_MinorChannel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MinorChannel;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MinorChannel)(long newVal)
    {
		ATL_LOCKT();
		TNATSCTuningSpace ts(m_TS);
		if (!m_TS) {
			return E_UNEXPECTED;
		}
		if (newVal != BDA_UNDEFINED_CHANNEL) {
			if (newVal < ts.MinMinorChannel()) {
				newVal = ts.MaxMinorChannel();
			} else if (newVal > ts.MaxMinorChannel()) {
				newVal = ts.MinMinorChannel();
			}
		}
        m_MinorChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_MinorChannel = m_MinorChannel;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

    STDMETHOD(put_Locator)(ILocator *pLocator)
    {
        try {
            if (pLocator) {
                PQATSCLocator pL(pLocator);
                if (!pL) {
                    return DISP_E_TYPEMISMATCH;
                }
            }
            return basetype::put_Locator(pLocator);
        } catch (...) {
            return E_POINTER;
        }
    }


};

}; // namespace

#endif // ATSCCHANNELTUNEREQUESTIMPL_H
// end of file -- atschchanneltunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\bcasteventimpl.h ===
//==========================================================================;
//
// bcasteventimpl.h : additional infrastructure to support implementing IMSVidGraphSegment for
//   playback segments
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef BCASTEVENTIMPL_H
#define BCASTEVENTIMPL_H

namespace MSVideoControl {

template<class T> 
    class DECLSPEC_NOVTABLE IBroadcastEventImpl : public IBroadcastEvent {
protected:
    PQBroadcastEvent m_pBcast;
    DWORD m_dwEventCookie;
	
public:
    IBroadcastEventImpl<T>() : m_dwEventCookie(0) {}
    virtual ~IBroadcastEventImpl<T>() {}

    HRESULT RegisterService() {
        T* pT = static_cast<T*>(this);
        if (!pT->m_pGraph) {
            return E_UNEXPECTED;
        }
        if (!m_pBcast) {
            PQServiceProvider sp(pT->m_pGraph);
            if (!sp) {
                TRACELM(TRACE_ERROR, "BroadcastEventImpl::RegisterService() can't get service provider i/f");
    		    return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
            }
            HRESULT hr = sp->QueryService(SID_SBroadcastEventService, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&m_pBcast));
            if (FAILED(hr) || !m_pBcast) {
                hr = m_pBcast.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "BroadcastEventImpl::RegisterService() can't create bcast service");
    		        return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
                }
                PQRegisterServiceProvider rsp(pT->m_pGraph);
                if (!sp) {
                    TRACELM(TRACE_ERROR, "BroadcastEventImpl::RegisterService() can't get get register service provider i/f");
    		        return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
                }
                hr = rsp->RegisterService(SID_SBroadcastEventService, m_pBcast);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::RegisterService() can't get register service provider. hr = " << hexdump(hr)), "");
    		        return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
                }

            }
        }
        return NOERROR;
    }

    HRESULT BroadcastFire(GUID2& eventid) {
        HRESULT hr = RegisterService();
        if (FAILED(hr)) {
            return hr;
        }
        ASSERT(m_pBcast);
        return m_pBcast->Fire(eventid);
    }
	HRESULT BroadcastAdvise() {
        HRESULT hr = RegisterService();
        if (FAILED(hr)) {
            return hr;
        }
        ASSERT(m_pBcast);
        PQConnectionPoint cp(m_pBcast);
        if (!cp) {
            TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::Advise() can't QI event notification for connection point i/f. hr = " << hexdump(hr)), "");
    		return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
        }

        hr = cp->Advise(static_cast<IBroadcastEvent*>(this) /* IBroadcastEvent implementing event receiving object*/, &m_dwEventCookie);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::Advise() can't advise event notification. hr = " << hexdump(hr)), "");
    		return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
        }

        return NOERROR;
	}
    HRESULT BroadcastUnadvise() {
        if (m_pBcast && m_dwEventCookie) {
            PQConnectionPoint cp(m_pBcast);
            if (cp) {
                HRESULT hr = cp->Unadvise(m_dwEventCookie);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::Unadvise() can't unadvise event notification. hr = " << hexdump(hr)), "");
                }
            } else {
                TRACELM(TRACE_ERROR, "CMSVidBDATuner::Unload() can't QI event notification for connection point i/f.");
            }
            m_pBcast.Release();
            m_dwEventCookie = 0;
        }
        ASSERT(!m_pBcast && !m_dwEventCookie);
        return NOERROR;
    }

};


}; // namespace

#endif
// end of file - bcasteventimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\cc2impl.h ===
//==========================================================================;
//
// closedcaptioningimpl.h : additional infrastructure to support implementing IMSVidClosedCaptionings
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef CLOSEDCAPTIONINGIMPL2_H
#define CLOSEDCAPTIONINGIMPL2_H

#include "ccimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidClosedCaptioning>
    class DECLSPEC_NOVTABLE IMSVidClosedCaptioningImpl2 : public IMSVidClosedCaptioningImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:

    IMSVidClosedCaptioningImpl2() {}

    STDMETHOD(put_Service)(MSVidCCService ccServ) {
        return E_NOTIMPL;
    }
    STDMETHOD(get_Service)(MSVidCCService *ccServ) {
        if (!ccServ) {
            return E_POINTER;
        }
        return E_NOTIMPL;
    }
};

}; /// namespace

#endif
// end of file - closedcaptioningimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\arity.h ===
///////////////////////////////////////////
// helper templates for use with stl <functional>
// providing argument binding for more arities
// and proper const support
///////////////////////////////////////////

#pragma once
#pragma warning(disable:4181)

#include <functional>

///////////////////////////////////////////
// Types
///////////////////////////////////////////

// Type classes for arity 0

template<class R> class arity0_function {
public:
    typedef R result_type;
};

// Template Class to define Object Type
template<class Object> class ObjectType {
public:
    typedef Object object_type;
};

// template class for arity0 member function type
template<class Object, class R> class arity0_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R (Object::*pmf0type)();
};

// template class for arity0 member function type
template<class Object, class R> class arity0_const_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R (Object::*pmf0type)() const;
};


// Type classes for arity 1

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class arity1_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R (Object::*pmf1type)(A1);
};

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class arity1_const_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R (Object::*pmf1type)(A1) const;
};


// Type classes for arity 2

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R (Object::*pmf2type)(A1, A2);
};

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2_const_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R (Object::*pmf2type)(A1, A2) const;
};


// Type classes for arity 3

template<class A1, 
        class A2, 
        class A3, 
        class R> class arity3_function :
            public std::binary_function<A1, 
                                    A2,
                                     R> {
public:typedef first_argument_type argument_type;

    typedef A3 argument_3_type;
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R (Object::*pmf3type)(A1, A2, A3);
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3_const_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R (Object::*pmf3type)(A1, A2, A3) const;
};


// Type classes for arity 4

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4_function :
            public arity3_function<A1, 
                                    A2, 
                                    A3,
                                     R> {
public:
    typedef A4 argument_4_type;
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R (Object::*pmf4type)(A1, A2, A3, A4);
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4_const_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R (Object::*pmf4type)(A1, A2, A3, A4) const;
};


// Type classes for arity 5

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5_function :
            public arity4_function<A1, 
                                    A2, 
                                    A3, 
                                    A4,
                                     R> {
public:
    typedef A5 argument_5_type;
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R (Object::*pmf5type)(A1, A2, A3, A4, A5);
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5_const_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R (Object::*pmf5type)(A1, A2, A3, A4, A5) const;
};


// Type classes for arity 6

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6_function :
            public arity5_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5,
                                     R> {
public:
    typedef A6 argument_6_type;
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R (Object::*pmf6type)(A1, A2, A3, A4, A5, A6);
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6_const_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R (Object::*pmf6type)(A1, A2, A3, A4, A5, A6) const;
};


// Type classes for arity 7

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class arity7_function :
            public arity6_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6,
                                     R> {
public:
    typedef A7 argument_7_type;
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class arity7_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R (Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7);
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class arity7_const_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R (Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7) const;
};


// Type classes for arity 8

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class arity8_function :
            public arity7_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7,
                                     R> {
public:
    typedef A8 argument_8_type;
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class arity8_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R (Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8);
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class arity8_const_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R (Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8) const;
};


// Type classes for arity 9

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class arity9_function :
            public arity8_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8,
                                     R> {
public:
    typedef A9 argument_9_type;
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class arity9_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R (Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9);
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class arity9_const_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R (Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
};


// Type classes for arity 10

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class arity10_function :
            public arity9_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9,
                                     R> {
public:
    typedef A10 argument_10_type;
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class arity10_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R (Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class arity10_const_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R (Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
};


// Type classes for arity 11

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class arity11_function :
            public arity10_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10,
                                     R> {
public:
    typedef A11 argument_11_type;
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class arity11_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R (Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class arity11_const_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R (Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
};


// Type classes for arity 12

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class arity12_function :
            public arity11_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11,
                                     R> {
public:
    typedef A12 argument_12_type;
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class arity12_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R (Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class arity12_const_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R (Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
};


// Type classes for arity 13

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class arity13_function :
            public arity12_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12,
                                     R> {
public:
    typedef A13 argument_13_type;
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class arity13_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R (Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class arity13_const_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R (Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
};


// Type classes for arity 14

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class arity14_function :
            public arity13_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12, 
                                    A13,
                                     R> {
public:
    typedef A14 argument_14_type;
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class arity14_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R (Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class arity14_const_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R (Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
};


// Type classes for arity 15

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class arity15_function :
            public arity14_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12, 
                                    A13, 
                                    A14,
                                     R> {
public:
    typedef A15 argument_15_type;
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class arity15_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R (Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class arity15_const_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R (Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
};

// template class for arity0 member function type
template<class Object, class R> class std_arity0_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R ( __stdcall Object::*pmf0type)();
};

// template class for arity0 member function type
template<class Object, class R> class std_arity0_const_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R ( __stdcall Object::*pmf0type)() const;
};

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class std_arity1_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf1type)(A1);
};

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class std_arity1_const_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf1type)(A1) const;
};

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R ( __stdcall Object::*pmf2type)(A1, A2);
};

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2_const_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R ( __stdcall Object::*pmf2type)(A1, A2) const;
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf3type)(A1, A2, A3);
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3_const_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf3type)(A1, A2, A3) const;
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf4type)(A1, A2, A3, A4);
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4_const_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf4type)(A1, A2, A3, A4) const;
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf5type)(A1, A2, A3, A4, A5);
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5_const_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf5type)(A1, A2, A3, A4, A5) const;
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf6type)(A1, A2, A3, A4, A5, A6);
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6_const_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf6type)(A1, A2, A3, A4, A5, A6) const;
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class std_arity7_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7);
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class std_arity7_const_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7) const;
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class std_arity8_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8);
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class std_arity8_const_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8) const;
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class std_arity9_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9);
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class std_arity9_const_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class std_arity10_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class std_arity10_const_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class std_arity11_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class std_arity11_const_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class std_arity12_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class std_arity12_const_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class std_arity13_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class std_arity13_const_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class std_arity14_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class std_arity14_const_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class std_arity15_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class std_arity15_const_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
};


///////////////////////////////////////////
// Storage
///////////////////////////////////////////
// Template Class for object storage
template<class Object> class store_object {
public:
    explicit inline store_object(Object objinit) : objval(objinit) {}
    inline store_object(const store_object &init) : objval(init.objval) {}
protected:
    Object objval;
};


// storage allocation classes for arity 0

// Template Class for arity 0 function ptr storage
template<class R> class arity0fp:
                public arity0_function<R> {
public:
    typedef R (*const pf0type) ();
    explicit inline arity0fp(pf0type pfi) : 
        pf0(pfi) {}
    inline arity0fp(const arity0fp& fi) : 
        pf0(fi.pf0) {}
    inline R operator()() const {
        return pf0();
    }
    pf0type pf0;
};

// Template Function for arity 0 function ptr storage
template<class R> inline arity0fp<R> 
            arity0_pointer(R (*const pfi)()) {
                return arity0fp<R>(pfi);
};


// Template Class for arity 0 pmf storage
template<class Object, class R> class arity0pmf:
                public arity0_mf<Object, R> {
public:
    typedef typename arity0_mf<Object, R>::object_type object_type;
    explicit inline arity0pmf(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline arity0pmf(const arity0pmf& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

template<class Object, class R> class arity0pmf_ptr:
    public arity0pmf<Object, R>, public std::unary_function<Object, R> {
public:
    explicit inline arity0pmf_ptr(pmf0type pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline arity0pmf_ptr(const arity0pmf_ptr& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    inline virtual R operator()(Object* o ) const {
        return (o->*pmf0)();
    }
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline arity0pmf_ptr<Object, R>
            arity0_member_ptr(R (Object::*const pmfi)()) {
                return arity0pmf_ptr<Object, R>(pmfi);
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline arity0pmf<Object, R>
            arity0_member(R (Object::*const pmfi)()) {
                return arity0pmf<Object, R>(pmfi);
};


// Template Class for arity 0 const pmf storage
template<class Object, class R> class arity0pmf_const:
                public arity0_const_mf<const Object, R> {
public:
    typedef typename arity0_const_mf<const Object, R>::object_type object_type;
    explicit inline arity0pmf_const(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline arity0pmf_const(const arity0pmf_const& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(const Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

// Template Function for arity 0 const pmf storage
template<const class Object, class R> inline arity0pmf_const<const Object, R>
            arity0_const_member(R (Object::*const pmfi)() const) {
                return arity0pmf_const<const Object, R>(pmfi);
};


// Template Class for arity 0 obj&pmf ref storage
template<class Function> class arity0opmf:
                public arity0pmf<typename Function::object_type, typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity0opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity0pmf<typename Function::object_type, typename Function::result_type>(f) {}
    explicit inline arity0opmf(typename Function::object_type& oi, pmf0type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity0pmf<typename Function::object_type, typename Function::result_type>(pmfi) {}
    inline arity0opmf(const arity0opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity0pmf<typename Function::object_type, typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 obj&pmf ref storage
template<class Function, class Object> inline arity0opmf<Function>
            arity0_member_obj(Object& oi, const Function &f) {
                return arity0opmf<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};


// Template Class for arity 0 const obj&pmf ref storage
template<class Function> class arity0opmf_const:
                public arity0pmf_const<const typename Function::object_type, typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity0opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity0pmf_const<typename Function::object_type, typename Function::result_type>(f) {}
    explicit inline arity0opmf_const(typename Function::object_type& oi, pmf0type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity0pmf_const<typename Function::object_type, typename Function::result_type>(pmfi) {}
    inline arity0opmf_const(const arity0opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity0pmf_const<typename Function::object_type, typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 const obj&pmf ref storage
template<class Function, class Object> inline arity0opmf_const<Function>
            arity0_const_member_obj(Object& oi, const Function &f) {
                return arity0opmf_const<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};



// storage allocation classes for arity 1

// Template Class for arity 1 function ptr storage
template<class A1, 
        class R> class arity1fp:
                public std::unary_function<A1, 
                R>,
                public arity0fp<R> {
public:
    typedef typename std::unary_function<A1, 
            R>::result_type result_type;
    typedef R (*const pf1type) (A1);
    explicit inline arity1fp(pf1type pfi) : 
        arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline arity1fp(const arity1fp& fi) : 
        arity0fp<R>(fi) {}
    inline R operator()(A1 a1) const {
        pf1type pf = reinterpret_cast<pf1type>(pf0);
        return pf(a1);
    }
};

// Template Function for arity 1 function ptr storage
template<class A1, 
                class R> inline arity1fp<A1, 
                R> 
            arity1_pointer(R (*const pfi)(A1)) {
                return arity1fp<A1, 
                R>(pfi);
};


// Template Class for arity 1 pmf storage
template<class Object, 
        class A1, 
        class R> class arity1pmf:
                public arity1_mf<Object, 
                A1, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef typename std::unary_function<A1, 
            R>::result_type result_type;
    typedef typename arity1_mf<Object, 
                A1, 
                R>::object_type object_type;
    explicit inline arity1pmf(pmf1type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity1pmf(const arity1pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 pmf storage
template<class Object, 
                class A1, 
                class R> inline arity1pmf<Object, 
                A1, 
                R>
            arity1_member(R (Object::*const pmfi)(A1)) {
                return arity1pmf<Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 const pmf storage
template<class Object, 
        class A1, 
        class R> class arity1pmf_const:
                public arity1_const_mf<const Object, 
                A1, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef typename std::unary_function<A1, 
            R>::result_type result_type;
    typedef typename arity1_const_mf<const Object, 
                A1, 
                R>::object_type object_type;
    explicit inline arity1pmf_const(pmf1type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity1pmf_const(const arity1pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 const pmf storage
template<const class Object, 
                class A1, 
                class R> inline arity1pmf_const<const Object, 
                A1, 
                R>
            arity1_const_member(R (Object::*const pmfi)(A1) const) {
                return arity1pmf_const<const Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 obj&pmf ref storage
template<class Function> class arity1opmf:
                public arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity1opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(f) {}
    explicit inline arity1opmf(typename Function::object_type& oi, pmf1type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(pmfi) {}
    inline arity1opmf(const arity1opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 obj&pmf ref storage
template<class Function, class Object> inline arity1opmf<Function>
            arity1_member_obj(Object& oi, const Function &f) {
                return arity1opmf<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};


// Template Class for arity 1 const obj&pmf ref storage
template<class Function> class arity1opmf_const:
                public arity1pmf_const<const typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity1opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity1pmf_const<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(f) {}
    explicit inline arity1opmf_const(typename Function::object_type& oi, pmf1type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity1pmf_const<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(pmfi) {}
    inline arity1opmf_const(const arity1opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity1pmf_const<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 const obj&pmf ref storage
template<class Function, class Object> inline arity1opmf_const<Function>
            arity1_const_member_obj(Object& oi, const Function &f) {
                return arity1opmf_const<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};



// storage allocation classes for arity 2

// Template Class for arity 2 function ptr storage
template<class A1, 
        class A2, 
        class R> class arity2fp:
                public std::binary_function<A1, 
                A2, 
                R>,
                public arity0fp<R> {
public:
    typedef typename std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef typename std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef R (*const pf2type) (A1, A2);
    explicit inline arity2fp(pf2type pfi) : 
        arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline arity2fp(const arity2fp& fi) : 
        arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, a2);
    }
};

// Template Function for arity 2 function ptr storage
template<class A1, 
                class A2, 
                class R> inline arity2fp<A1, 
                A2, 
                R> 
            arity2_pointer(R (*const pfi)(A1, 
                                    A2)) {
                return arity2fp<A1, 
                A2, 
                R>(pfi);
};

// Template Class for arity 2 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2pmf:
                public arity2_mf<Object, 
                A1, 
                A2, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef typename std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef typename std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef typename arity2_mf<Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline arity2pmf(pmf2type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity2pmf(const arity2pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class R> inline arity2pmf<Object, 
                A1, 
                A2, 
                R>
            arity2_member(R (Object::*const pmfi)(A1, 
                                    A2)) {
                return arity2pmf<Object, 
                A1, 
                A2, 
                R>(pmfi);
};


// Template Class for arity 2 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2pmf_const:
                public arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef typename std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef typename std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef typename arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline arity2pmf_const(pmf2type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity2pmf_const(const arity2pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class R> inline arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>
            arity2_const_member(R (Object::*const pmfi)(A1, 
                                    A2) const) {
                return arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>(pmfi);
};

// Template Class for arity 2 obj&pmf ref storage
template<class Function> class arity2opmf:
                public arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity2opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(f) {}
    explicit inline arity2opmf(typename Function::object_type& oi, pmf2type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(pmfi) {}
    inline arity2opmf(const arity2opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 obj&pmf ref storage
template<class Function, class Object> inline arity2opmf<Function>
            arity2_member_obj(Object& oi, const Function &f) {
                return arity2opmf<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};


// Template Class for arity 2 const obj&pmf ref storage
template<class Function> class arity2opmf_const:
                public arity2pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity2opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity2pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(f) {}
    explicit inline arity2opmf_const(typename Function::object_type& oi, pmf2type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity2pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(pmfi) {}
    inline arity2opmf_const(const arity2opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity2pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 const obj&pmf ref storage
template<class Function, class Object> inline arity2opmf_const<Function>
            arity2_const_member_obj(Object& oi, const Function &f) {
                return arity2opmf_const<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};



// storage allocation classes for arity 3

// Template Class for arity 3 function ptr storage
template<class A1, 
        class A2, 
        class A3, 
        class R> class arity3fp:
                public arity3_function<A1, 
                A2, 
                A3, 
                R>,
                public arity0fp<R> {
public:
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef R (*const pf3type) (A1, A2, A3);
    explicit inline arity3fp(pf3type pfi) : 
        arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline arity3fp(const arity3fp& fi) : 
        arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, a2, a3);
    }
};

// Template Function for arity 3 function ptr storage
template<class A1, 
                class A2, 
                class A3, 
                class R> inline arity3fp<A1, 
                A2, 
                A3, 
                R> 
            arity3_pointer(R (*const pfi)(A1, 
                                    A2, 
                                    A3)) {
                return arity3fp<A1, 
                A2, 
                A3, 
                R>(pfi);
};


// Template Class for arity 3 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3pmf:
                public arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef typename arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline arity3pmf(pmf3type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity3pmf(const arity3pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>
            arity3_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3)) {
                return arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3pmf_const:
                public arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef typename arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline arity3pmf_const(pmf3type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity3pmf_const(const arity3pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>
            arity3_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3) const) {
                return arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 obj&pmf ref storage
template<class Function> class arity3opmf:
                public arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity3opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(f) {}
    explicit inline arity3opmf(typename Function::object_type& oi, pmf3type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(pmfi) {}
    inline arity3opmf(const arity3opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 obj&pmf ref storage
template<class Function, class Object> inline arity3opmf<Function>
            arity3_member_obj(Object& oi, const Function &f) {
                return arity3opmf<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};


// Template Class for arity 3 const obj&pmf ref storage
template<class Function> class arity3opmf_const:
                public arity3pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity3opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity3pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(f) {}
    explicit inline arity3opmf_const(typename Function::object_type& oi, pmf3type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity3pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(pmfi) {}
    inline arity3opmf_const(const arity3opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity3pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 const obj&pmf ref storage
template<class Function, class Object> inline arity3opmf_const<Function>
            arity3_const_member_obj(Object& oi, const Function &f) {
                return arity3opmf_const<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};



// storage allocation classes for arity 4

// Template Class for arity 4 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4pmf:
                public arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef typename arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline arity4pmf(pmf4type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity4pmf(const arity4pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            arity4_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4)) {
                return arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4pmf_const:
                public arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef typename arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline arity4pmf_const(pmf4type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity4pmf_const(const arity4pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            arity4_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4) const) {
                return arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 obj&pmf ref storage
template<class Function> class arity4opmf:
                public arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity4opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(f) {}
    explicit inline arity4opmf(typename Function::object_type& oi, pmf4type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(pmfi) {}
    inline arity4opmf(const arity4opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 obj&pmf ref storage
template<class Function, class Object> inline arity4opmf<Function>
            arity4_member_obj(Object& oi, const Function &f) {
                return arity4opmf<Function>(Function::object_type(oi), Function::pmf4type(f.pmf0));
};


// Template Class for arity 4 const obj&pmf ref storage
template<class Function> class arity4opmf_const:
                public arity4pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity4opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity4pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(f) {}
    explicit inline arity4opmf_const(typename Function::object_type& oi, pmf4type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity4pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(pmfi) {}
    inline arity4opmf_const(const arity4opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity4pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 const obj&pmf ref storage
template<class Function, class Object> inline arity4opmf_const<Function>
            arity4_const_member_obj(Object& oi, const Function &f) {
                return arity4opmf_const<Function>(Function::object_type(oi), Function::pmf4type(f.pmf0));
};



// storage allocation classes for arity 5

// Template Class for arity 5 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5pmf:
                public arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef typename arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline arity5pmf(pmf5type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity5pmf(const arity5pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            arity5_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5)) {
                return arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5pmf_const:
                public arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef typename arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline arity5pmf_const(pmf5type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity5pmf_const(const arity5pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            arity5_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5) const) {
                return arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 obj&pmf ref storage
template<class Function> class arity5opmf:
                public arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity5opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(f) {}
    explicit inline arity5opmf(typename Function::object_type& oi, pmf5type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(pmfi) {}
    inline arity5opmf(const arity5opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 obj&pmf ref storage
template<class Function, class Object> inline arity5opmf<Function>
            arity5_member_obj(Object& oi, const Function &f) {
                return arity5opmf<Function>(typename Function::object_type(oi), Function::pmf5type(f.pmf0));
};


// Template Class for arity 5 const obj&pmf ref storage
template<class Function> class arity5opmf_const:
                public arity5pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity5opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity5pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(f) {}
    explicit inline arity5opmf_const(typename Function::object_type& oi, pmf5type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity5pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(pmfi) {}
    inline arity5opmf_const(const arity5opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity5pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 const obj&pmf ref storage
template<class Function, class Object> inline arity5opmf_const<Function>
            arity5_const_member_obj(Object& oi, const Function &f) {
                return arity5opmf_const<Function>(Function::object_type(oi), Function::pmf5type(f.pmf0));
};



// storage allocation classes for arity 6

// Template Class for arity 6 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6pmf:
                public arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef typename arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline arity6pmf(pmf6type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity6pmf(const arity6pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                       A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            arity6_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6)) {
                return arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6pmf_const:
                public arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef typename arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline arity6pmf_const(pmf6type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity6pmf_const(const arity6pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            arity6_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6) const) {
                return arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 obj&pmf ref storage
template<class Function> class arity6opmf:
                public arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline arity6opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(f) {}
    explicit inline arity6opmf(typename Function::object_type& oi, pmf6type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(pmfi) {}
    inline arity6opmf(const arity6opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5, 
                        typename Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 obj&pmf ref storage
template<class Function, class Object> inline arity6opmf<Function>
            arity6_member_obj(Object& oi, const Function &f) {
                return arity6opmf<Function>(Function::object_type(oi), Function::pmf6type(f.pmf0));
};


// Template Class for arity 6 const obj&pmf ref storage
template<class Function> class arity6opmf_const:
                public arity6pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline arity6opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), arity6pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(f) {}
    explicit inline arity6opmf_const(typename Function::object_type& oi, pmf6type pmfi) : 
        store_object<typename Function::object_type&>(oi), arity6pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(pmfi) {}
    inline arity6opmf_const(const arity6opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), arity6pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5, 
                        typename Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 const obj&pmf ref storage
template<class Function, class Object> inline arity6opmf_const<Function>
            arity6_const_member_obj(Object& oi, const Function &f) {
                return arity6opmf_const<Function>(Function::object_type(oi), Function::pmf6type(f.pmf0));
};


#if defined(_M_ALPHA) || (_MSC_VER < 1300)
// Template Function for arity 3 pmf storage
template<class Object, 
                class A1, 
                const class A2, 
                const class A3, 
                class R> inline arity3pmf<Object, 
                A1, 
                const A2, 
                const A3, 
                R>
            arity3_member(R (Object::*const pmfi)(A1, 
                                    const A2, 
                                    const A3)) {
                return arity3pmf<Object, 
                A1, 
                const A2, 
                const A3, 
                R>(pmfi);
};
#endif

#if defined(_M_ALPHA) || (_MSC_VER < 1300)
// Template Function for arity 4 const pmf storage
template<const class Object, 
                const class A1, 
                const class A2, 
                class A3, 
                const class A4, 
                class R> inline arity4pmf_const<const Object, 
                const A1, 
                const A2, 
                A3, 
                const A4, 
                R>
            arity4_const_member(R (Object::*const pmfi)(const A1, 
                                    const A2, 
                                    A3, 
                                    const A4) const) {
                return arity4pmf_const<const Object, 
                const A1, 
                const A2, 
                A3, 
                const A4, 
                R>(pmfi);
};
#endif


// storage allocation classes for arity 0

// Template Class for arity 0 function ptr storage
template<class R> class std_arity0fp:
                public arity0_function<R> {
public:
    typedef R ( __stdcall *const pf0type) ();
    explicit inline std_arity0fp(pf0type pfi) : 
        pf0(pfi) {}
    inline std_arity0fp(const std_arity0fp& fi) : 
        pf0(fi.pf0) {}
    inline R operator()() const {
        return pf0();
    }
    pf0type pf0;
};

// Template Function for arity 0 function ptr storage
template<class R> inline std_arity0fp<R> 
            std_arity0_pointer(R ( __stdcall *const pfi)()) {
                return std_arity0fp<R>(pfi);
};


// Template Class for arity 0 pmf storage
template<class Object, class R> class std_arity0pmf:
                public std_arity0_mf<Object, R> {
public:
    typedef typename std_arity0_mf<Object, R>::object_type object_type;
    explicit inline std_arity0pmf(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline std_arity0pmf(const std_arity0pmf& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline std_arity0pmf<Object, R>
            std_arity0_member(R ( __stdcall Object::*const pmfi)()) {
                return std_arity0pmf<Object, R>(pmfi);
};


// Template Class for arity 0 const pmf storage
template<class Object, class R> class std_arity0pmf_const:
                public std_arity0_const_mf<const Object, R> {
public:
    typedef typename std_arity0_const_mf<const Object, R>::object_type object_type;
    explicit inline std_arity0pmf_const(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline std_arity0pmf_const(const std_arity0pmf_const& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(const Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

// Template Function for arity 0 const pmf storage
template<const class Object, class R> inline std_arity0pmf_const<const Object, R>
            std_arity0_const_member(R ( __stdcall Object::*const pmfi)() const) {
                return std_arity0pmf_const<const Object, R>(pmfi);
};

template<class Object, class R> class std_arity0pmf_ptr:
    public std_arity0pmf<Object, R>, public std::unary_function<Object, R> {
public:
    explicit inline std_arity0pmf_ptr(pmf0type pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline std_arity0pmf_ptr(const std_arity0pmf_ptr& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    inline virtual R operator()(Object* o ) const {
        return (o->*pmf0)();
    }
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline std_arity0pmf_ptr<Object, R>
            std_arity0_member_ptr(R (__stdcall Object::*const pmfi)()) {
                return std_arity0pmf_ptr<Object, R>(pmfi);
};

// Template Class for arity 0 obj&pmf ref storage
template<class Function> class std_arity0opmf:
                public std_arity0pmf<typename Function::object_type, typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity0opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity0pmf<typename Function::object_type, typename Function::result_type>(f) {}
    explicit inline std_arity0opmf(typename Function::object_type& oi, pmf0type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity0pmf<typename Function::object_type, typename Function::result_type>(pmfi) {}
    inline std_arity0opmf(const std_arity0opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity0pmf<typename Function::object_type, typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 obj&pmf ref storage
template<class Function, class Object> inline std_arity0opmf<Function>
            std_arity0_member_obj(Object& oi, const Function &f) {
                return std_arity0opmf<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};


// Template Class for arity 0 const obj&pmf ref storage
template<class Function> class std_arity0opmf_const:
                public std_arity0pmf_const<const typename Function::object_type, typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity0opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity0pmf_const<typename Function::object_type, typename Function::result_type>(f) {}
    explicit inline std_arity0opmf_const(typename Function::object_type& oi, pmf0type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity0pmf_const<typename Function::object_type, typename Function::result_type>(pmfi) {}
    inline std_arity0opmf_const(const std_arity0opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity0pmf_const<typename Function::object_type, typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 const obj&pmf ref storage
template<class Function, class Object> inline std_arity0opmf_const<Function>
            std_arity0_const_member_obj(Object& oi, const Function &f) {
                return std_arity0opmf_const<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};



// storage allocation classes for arity 1

// Template Class for arity 1 function ptr storage
template<class A1, 
        class R> class std_arity1fp:
                public std::unary_function<A1, 
                R>,
                public std_arity0fp<R> {
public:
    typedef typename std::unary_function<A1, 
            R>::result_type result_type;
    typedef R ( __stdcall *const pf1type) (A1);
    explicit inline std_arity1fp(pf1type pfi) : 
        std_arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline std_arity1fp(const std_arity1fp& fi) : 
        std_arity0fp<R>(fi) {}
    inline R operator()(A1 a1) const {
        pf1type pf = reinterpret_cast<pf1type>(pf0);
        return pf(a1);
    }
};

// Template Function for arity 1 function ptr storage
template<class A1, 
                class R> inline std_arity1fp<A1, 
                R> 
            std_arity1_pointer(R ( __stdcall *const pfi)(A1)) {
                return std_arity1fp<A1, 
                R>(pfi);
};


// Template Class for arity 1 pmf storage
template<class Object, 
        class A1, 
        class R> class std_arity1pmf:
                public std_arity1_mf<Object, 
                A1, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename std::unary_function<A1, 
            R>::result_type result_type;
    typedef typename std_arity1_mf<Object, 
                A1, 
                R>::object_type object_type;
    explicit inline std_arity1pmf(pmf1type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity1pmf(const std_arity1pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 pmf storage
template<class Object, 
                class A1, 
                class R> inline std_arity1pmf<Object, 
                A1, 
                R>
            std_arity1_member(R ( __stdcall Object::*const pmfi)(A1)) {
                return std_arity1pmf<Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 const pmf storage
template<class Object, 
        class A1, 
        class R> class std_arity1pmf_const:
                public std_arity1_const_mf<const Object, 
                A1, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef typename std::unary_function<A1, 
            R>::result_type result_type;
    typedef typename std_arity1_const_mf<const Object, 
                A1, 
                R>::object_type object_type;
    explicit inline std_arity1pmf_const(pmf1type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity1pmf_const(const std_arity1pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 const pmf storage
template<const class Object, 
                class A1, 
                class R> inline std_arity1pmf_const<const Object, 
                A1, 
                R>
            std_arity1_const_member(R ( __stdcall Object::*const pmfi)(A1) const) {
                return std_arity1pmf_const<const Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 obj&pmf ref storage
template<class Function> class std_arity1opmf:
                public std_arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity1opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity1opmf(typename Function::object_type& oi, pmf1type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity1opmf(const std_arity1opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity1pmf<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 obj&pmf ref storage
template<class Function, class Object> inline std_arity1opmf<Function>
            std_arity1_member_obj(Object& oi, const Function &f) {
                return std_arity1opmf<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};


// Template Class for arity 1 const obj&pmf ref storage
template<class Function> class std_arity1opmf_const:
                public std_arity1pmf_const<const typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity1opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity1pmf_const<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity1opmf_const(typename Function::object_type& oi, pmf1type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity1pmf_const<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity1opmf_const(const std_arity1opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity1pmf_const<typename Function::object_type, 
                typename Function::argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 const obj&pmf ref storage
template<class Function, class Object> inline std_arity1opmf_const<Function>
            std_arity1_const_member_obj(Object& oi, const Function &f) {
                return std_arity1opmf_const<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};



// storage allocation classes for arity 2

// Template Class for arity 2 function ptr storage
template<class A1, 
        class A2, 
        class R> class std_arity2fp:
                public std::binary_function<A1, 
                A2, 
                R>,
                public std_arity0fp<R> {
public:
    typedef typename std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef typename std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef R ( __stdcall *const pf2type) (A1, A2);
    explicit inline std_arity2fp(pf2type pfi) : 
        std_arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline std_arity2fp(const std_arity2fp& fi) : 
        std_arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, a2);
    }
};

// Template Function for arity 2 function ptr storage
template<class A1, 
                class A2, 
                class R> inline std_arity2fp<A1, 
                A2, 
                R> 
            std_arity2_pointer(R ( __stdcall *const pfi)(A1, 
                                    A2)) {
                return std_arity2fp<A1, 
                A2, 
                R>(pfi);
};


// Template Class for arity 2 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2pmf:
                public std_arity2_mf<Object, 
                A1, 
                A2, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef typename std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef typename std_arity2_mf<Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline std_arity2pmf(pmf2type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity2pmf(const std_arity2pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class R> inline std_arity2pmf<Object, 
                A1, 
                A2, 
                R>
            std_arity2_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2)) {
                return std_arity2pmf<Object, 
                A1, 
                A2, 
                R>(pmfi);
};


// Template Class for arity 2 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2pmf_const:
                public std_arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef typename std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef typename std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef typename std_arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline std_arity2pmf_const(pmf2type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity2pmf_const(const std_arity2pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class R> inline std_arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>
            std_arity2_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2) const) {
                return std_arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>(pmfi);
};


// Template Class for arity 2 obj&pmf ref storage
template<class Function> class std_arity2opmf:
                public std_arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity2opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity2opmf(typename Function::object_type& oi, pmf2type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity2opmf(const std_arity2opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity2pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 obj&pmf ref storage
template<class Function, class Object> inline std_arity2opmf<Function>
            std_arity2_member_obj(Object& oi, const Function &f) {
                return std_arity2opmf<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};


// Template Class for arity 2 const obj&pmf ref storage
template<class Function> class std_arity2opmf_const:
                public std_arity2pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity2opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity2pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity2opmf_const(typename Function::object_type& oi, pmf2type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity2pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity2opmf_const(const std_arity2opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity2pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 const obj&pmf ref storage
template<class Function, class Object> inline std_arity2opmf_const<Function>
            std_arity2_const_member_obj(Object& oi, const Function &f) {
                return std_arity2opmf_const<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};



// storage allocation classes for arity 3

// Template Class for arity 3 function ptr storage
template<class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3fp:
                public arity3_function<A1, 
                A2, 
                A3, 
                R>,
                public std_arity0fp<R> {
public:
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef R ( __stdcall *const pf3type) (A1, A2, A3);
    explicit inline std_arity3fp(pf3type pfi) : 
        std_arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline std_arity3fp(const std_arity3fp& fi) : 
        std_arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, a2, a3);
    }
};

// Template Function for arity 3 function ptr storage
template<class A1, 
                class A2, 
                class A3, 
                class R> inline std_arity3fp<A1, 
                A2, 
                A3, 
                R> 
            std_arity3_pointer(R ( __stdcall *const pfi)(A1, 
                                    A2, 
                                    A3)) {
                return std_arity3fp<A1, 
                A2, 
                A3, 
                R>(pfi);
};


// Template Class for arity 3 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3pmf:
                public std_arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline std_arity3pmf(pmf3type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity3pmf(const std_arity3pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline std_arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>
            std_arity3_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3)) {
                return std_arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3pmf_const:
                public std_arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef typename arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline std_arity3pmf_const(pmf3type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity3pmf_const(const std_arity3pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline std_arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>
            std_arity3_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3) const) {
                return std_arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 obj&pmf ref storage
template<class Function> class std_arity3opmf:
                public std_arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity3opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity3opmf(typename Function::object_type& oi, pmf3type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity3opmf(const std_arity3opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity3pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 obj&pmf ref storage
template<class Function, class Object> inline std_arity3opmf<Function>
            std_arity3_member_obj(Object& oi, const Function &f) {
                return std_arity3opmf<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};


// Template Class for arity 3 const obj&pmf ref storage
template<class Function> class std_arity3opmf_const:
                public std_arity3pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity3opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity3pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity3opmf_const(typename Function::object_type& oi, pmf3type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity3pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity3opmf_const(const std_arity3opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity3pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 const obj&pmf ref storage
template<class Function, class Object> inline std_arity3opmf_const<Function>
            std_arity3_const_member_obj(Object& oi, const Function &f) {
                return std_arity3opmf_const<Function>(typename Function::object_type(oi), typename Function::pmf3type(f.pmf0));
};



// storage allocation classes for arity 4

// Template Class for arity 4 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4pmf:
                public std_arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline std_arity4pmf(pmf4type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity4pmf(const std_arity4pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline std_arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            std_arity4_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4)) {
                return std_arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4pmf_const:
                public std_arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef typename arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline std_arity4pmf_const(pmf4type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity4pmf_const(const std_arity4pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline std_arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            std_arity4_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4) const) {
                return std_arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 obj&pmf ref storage
template<class Function> class std_arity4opmf:
                public std_arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity4opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity4opmf(typename Function::object_type& oi, pmf4type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity4opmf(const std_arity4opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity4pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 obj&pmf ref storage
template<class Function, class Object> inline std_arity4opmf<Function>
            std_arity4_member_obj(Object& oi, const Function &f) {
                return std_arity4opmf<Function>(typename Function::object_type(oi), typename Function::pmf4type(f.pmf0));
};


// Template Class for arity 4 const obj&pmf ref storage
template<class Function> class std_arity4opmf_const:
                public std_arity4pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity4opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity4pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity4opmf_const(typename Function::object_type& oi, pmf4type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity4pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity4opmf_const(const std_arity4opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity4pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 const obj&pmf ref storage
template<class Function, class Object> inline std_arity4opmf_const<Function>
            std_arity4_const_member_obj(Object& oi, const Function &f) {
                return std_arity4opmf_const<Function>(typename Function::object_type(oi), typename Function::pmf4type(f.pmf0));
};



// storage allocation classes for arity 5

// Template Class for arity 5 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5pmf:
                public std_arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline std_arity5pmf(pmf5type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity5pmf(const std_arity5pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline std_arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            std_arity5_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5)) {
                return std_arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5pmf_const:
                public std_arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef typename arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline std_arity5pmf_const(pmf5type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity5pmf_const(const std_arity5pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline std_arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            std_arity5_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5) const) {
                return std_arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 obj&pmf ref storage
template<class Function> class std_arity5opmf:
                public std_arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity5opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity5opmf(typename Function::object_type& oi, pmf5type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity5opmf(const std_arity5opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity5pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 obj&pmf ref storage
template<class Function, class Object> inline std_arity5opmf<Function>
            std_arity5_member_obj(Object& oi, const Function &f) {
                return std_arity5opmf<Function>(typename Function::object_type(oi), typename Function::pmf5type(f.pmf0));
};


// Template Class for arity 5 const obj&pmf ref storage
template<class Function> class std_arity5opmf_const:
                public std_arity5pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity5opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity5pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity5opmf_const(typename Function::object_type& oi, pmf5type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity5pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity5opmf_const(const std_arity5opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity5pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 const obj&pmf ref storage
template<class Function, class Object> inline std_arity5opmf_const<Function>
            std_arity5_const_member_obj(Object& oi, const Function &f) {
                return std_arity5opmf_const<Function>(typename Function::object_type(oi), typename Function::pmf5type(f.pmf0));
};



// storage allocation classes for arity 6

// Template Class for arity 6 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6pmf:
                public std_arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline std_arity6pmf(pmf6type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity6pmf(const std_arity6pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline std_arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            std_arity6_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6)) {
                return std_arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6pmf_const:
                public std_arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef typename arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline std_arity6pmf_const(pmf6type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity6pmf_const(const std_arity6pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline std_arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            std_arity6_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6) const) {
                return std_arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 obj&pmf ref storage
template<class Function> class std_arity6opmf:
                public std_arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity6opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity6opmf(typename Function::object_type& oi, pmf6type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity6opmf(const std_arity6opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity6pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5, 
                        typename Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 obj&pmf ref storage
template<class Function, class Object> inline std_arity6opmf<Function>
            std_arity6_member_obj(Object& oi, const Function &f) {
                return std_arity6opmf<Function>(typename Function::object_type(oi), typename Function::pmf6type(f.pmf0));
};


// Template Class for arity 6 const obj&pmf ref storage
template<class Function> class std_arity6opmf_const:
                public std_arity6pmf_const<const typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>,
                public store_object<const typename Function::object_type&> {
public:
    explicit inline std_arity6opmf_const(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity6pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity6opmf_const(typename Function::object_type& oi, pmf6type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity6pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity6opmf_const(const std_arity6opmf_const& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity6pmf_const<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5, 
                        typename Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 const obj&pmf ref storage
template<class Function, class Object> inline std_arity6opmf_const<Function>
            std_arity6_const_member_obj(Object& oi, const Function &f) {
                return std_arity6opmf_const<Function>(typename Function::object_type(oi), typename Function::pmf6type(f.pmf0));
};


// Template Class for arity 15 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class std_arity15pmf:
                public std_arity15_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef typename arity15_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            A7, 
            A8, 
            A9, 
            A10, 
            A11, 
            A12, 
            A13, 
            A14, 
            A15, 
            R>::result_type result_type;
    typedef typename arity15_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            A7, 
            A8, 
            A9, 
            A10, 
            A11, 
            A12, 
            A13, 
            A14, 
            A15, 
            R>::first_argument_type first_argument_type;
    typedef typename arity15_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            A7, 
            A8, 
            A9, 
            A10, 
            A11, 
            A12, 
            A13, 
            A14, 
            A15, 
            R>::second_argument_type second_argument_type;
    typedef typename std_arity15_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>::object_type object_type;
    explicit inline std_arity15pmf(pmf15type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity15pmf(const std_arity15pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6, 
                        A7 a7, 
                        A8 a8, 
                        A9 a9, 
                        A10 a10, 
                        A11 a11, 
                        A12 a12, 
                        A13 a13, 
                        A14 a14, 
                        A15 a15) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    }
};

// Template Function for arity 15 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15, 
                class R> inline std_arity15pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>
            std_arity15_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12, 
                                    A13, 
                                    A14, 
                                    A15)) {
                return std_arity15pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>(pmfi);
};


// Template Class for arity 15 obj&pmf ref storage
template<class Function> class std_arity15opmf:
                public std_arity15pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::argument_7_type, 
                typename Function::argument_8_type, 
                typename Function::argument_9_type, 
                typename Function::argument_10_type, 
                typename Function::argument_11_type, 
                typename Function::argument_12_type, 
                typename Function::argument_13_type, 
                typename Function::argument_14_type, 
                typename Function::argument_15_type, 
                typename Function::result_type>,
                public store_object<typename Function::object_type&> {
public:
    explicit inline std_arity15opmf(typename Function::object_type& oi, const Function &f) : 
        store_object<typename Function::object_type&>(oi), std_arity15pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::argument_7_type, 
                typename Function::argument_8_type, 
                typename Function::argument_9_type, 
                typename Function::argument_10_type, 
                typename Function::argument_11_type, 
                typename Function::argument_12_type, 
                typename Function::argument_13_type, 
                typename Function::argument_14_type, 
                typename Function::argument_15_type, 
                typename Function::result_type>(f) {}
    explicit inline std_arity15opmf(typename Function::object_type& oi, pmf15type pmfi) : 
        store_object<typename Function::object_type&>(oi), std_arity15pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::argument_7_type, 
                typename Function::argument_8_type, 
                typename Function::argument_9_type, 
                typename Function::argument_10_type, 
                typename Function::argument_11_type, 
                typename Function::argument_12_type, 
                typename Function::argument_13_type, 
                typename Function::argument_14_type, 
                typename Function::argument_15_type, 
                typename Function::result_type>(pmfi) {}
    inline std_arity15opmf(const std_arity15opmf& bndri) : 
        store_object<typename Function::object_type&>(bndri), std_arity15pmf<typename Function::object_type, 
                typename Function::first_argument_type, 
                typename Function::second_argument_type, 
                typename Function::argument_3_type, 
                typename Function::argument_4_type, 
                typename Function::argument_5_type, 
                typename Function::argument_6_type, 
                typename Function::argument_7_type, 
                typename Function::argument_8_type, 
                typename Function::argument_9_type, 
                typename Function::argument_10_type, 
                typename Function::argument_11_type, 
                typename Function::argument_12_type, 
                typename Function::argument_13_type, 
                typename Function::argument_14_type, 
                typename Function::argument_15_type, 
                typename Function::result_type>(bndri) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1, 
                        typename Function::second_argument_type a2, 
                        typename Function::argument_3_type a3, 
                        typename Function::argument_4_type a4, 
                        typename Function::argument_5_type a5, 
                        typename Function::argument_6_type a6, 
                        typename Function::argument_7_type a7, 
                        typename Function::argument_8_type a8, 
                        typename Function::argument_9_type a9, 
                        typename Function::argument_10_type a10, 
                        typename Function::argument_11_type a11, 
                        typename Function::argument_12_type a12, 
                        typename Function::argument_13_type a13, 
                        typename Function::argument_14_type a14, 
                        typename Function::argument_15_type a15) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    }
};


// Template Function for arity 15 obj&pmf ref storage
template<class Function, class Object> inline std_arity15opmf<Function>
            std_arity15_member_obj(Object& oi, const Function &f) {
                return std_arity15opmf<Function>(typename Function::object_type(oi), typename Function::pmf15type(f.pmf0));
};



///////////////////////////////////////////
// Binders
///////////////////////////////////////////

//
// binders for arity 2
//


// Template Classes for binding arity 2 to arity 1


// Template Classes for binding function ptrs of arity 2 to arity 1

template<class Function> class bndr_2 : 
                public arity1fp<typename Function::first_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type (*const pf2type) (typename Function::first_argument_type, typename Function::second_argument_type);
    explicit inline bndr_2(const Function &f, typename Function::second_argument_type a2) : 
        arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2) {}
    inline bndr_2(const bndr_2& bndri) : 
        arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class bndr_1 : 
                public arity1fp<typename Function::second_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type (*const pf2type) (typename Function::first_argument_type, typename Function::second_argument_type);
    explicit inline bndr_1(const Function &f, typename Function::first_argument_type a1) : 
        arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1) {}
    inline bndr_1(const bndr_1& bndri) : 
        arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding pmf  of arity 2 to arity 1

template<class Function> class bndr_mf_2 : 
                public arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_2(const Function &f, typename Function::second_argument_type a2) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline bndr_mf_2(const bndr_mf_2& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class bndr_mf_1 : 
                public arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1(const Function &f, typename Function::first_argument_type a1) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline bndr_mf_1(const bndr_mf_1& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding const pmf  of arity 2 to arity 1

template<class Function> class bndr_const_mf_2 : 
                public arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_2(const Function &f, typename Function::second_argument_type a2) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline bndr_const_mf_2(const bndr_const_mf_2& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class bndr_const_mf_1 : 
                public arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1(const Function &f, typename Function::first_argument_type a1) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline bndr_const_mf_1(const bndr_const_mf_1& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding obj&pmf Ref of arity 2 to arity 1

template<class Function> class bndr_obj_2 : 
                public arity1opmf<Function>, 
                private arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_2(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline bndr_obj_2(const bndr_obj_2& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class bndr_obj_1 : 
                public arity1opmf<Function>, 
                private arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline bndr_obj_1(const bndr_obj_1& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function> class bndr_const_obj_2 : 
                public arity1opmf_const<Function>, 
                private arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_2(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline bndr_const_obj_2(const bndr_const_obj_2& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class bndr_const_obj_1 : 
                public arity1opmf_const<Function>, 
                private arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline bndr_const_obj_1(const bndr_const_obj_1& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Functions for binding arity 2 to arity 1


// Template Functions for binding function ptrs of arity 2 to arity 1

template<class Function, class A2> inline bndr_2<Function>
            bind_fp_2(const Function &f, A2 a2) {
                return bndr_2<Function>(f, typename Function::second_argument_type(a2));
};

template<class Function, class A1> inline bndr_1<Function>
            bind_fp_1(const Function &f, A1 a1) {
                return bndr_1<Function>(f, typename Function::first_argument_type(a1));
};



// Template Functions for binding pmf  of arity 2 to arity 1

template<class Function, class A2> inline bndr_mf_2<Function>
            bind_mf_2(const Function &f, A2 a2) {
                return bndr_mf_2<Function>(f, typename Function::second_argument_type(a2));
};

template<class Function, class A1> inline bndr_mf_1<Function>
            bind_mf_1(const Function &f, A1 a1) {
                return bndr_mf_1<Function>(f, typename Function::first_argument_type(a1));
};



// Template Functions for binding const pmf  of arity 2 to arity 1

template<class Function, class A2> inline bndr_const_mf_2<Function>
            bind_const_mf_2(const Function &f, A2 a2) {
                return bndr_const_mf_2<Function>(f, typename Function::second_argument_type(a2));
};

template<class Function, class A1> inline bndr_const_mf_1<Function>
            bind_const_mf_1(const Function &f, A1 a1) {
                return bndr_const_mf_1<Function>(f, typename Function::first_argument_type(a1));
};



// Template Functions for binding obj&pmf Ref of arity 2 to arity 1

template<class Function, class Object, 
                class A2> inline bndr_obj_2<Function>
            bind_obj_2(Object& oi, const Function &f, A2 a2) {
                return bndr_obj_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2));
};

template<class Function, class Object, 
                class A1> inline bndr_obj_1<Function>
            bind_obj_1(Object& oi, const Function &f, A1 a1) {
                return bndr_obj_1<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1));
};



// Template Functions for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function, const class Object, 
                class A2> inline bndr_const_obj_2<Function>
            bind_const_obj_2(const Object& oi, const Function &f, A2 a2) {
                return bndr_const_obj_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2));
};

template<class Function, const class Object, 
                class A1> inline bndr_const_obj_1<Function>
            bind_const_obj_1(const Object& oi, const Function &f, A1 a1) {
                return bndr_const_obj_1<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1));
};



//
// binders for arity 3
//


// Template Classes for binding arity 3 to arity 1


// Template Classes for binding function ptrs of arity 3 to arity 1

template<class Function> class bndr_2_3 : 
                public arity1fp<typename Function::first_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type (*const pf3type) (typename Function::first_argument_type, typename Function::second_argument_type, typename Function::argument_3_type);
    explicit inline bndr_2_3(const Function &f, typename Function::second_argument_type a2, 
                    typename Function::argument_3_type a3) : 
        arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2), arg3val(a3) {}
    inline bndr_2_3(const bndr_2_3& bndri) : 
        arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_1_3 : 
                public arity1fp<typename Function::second_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type (*const pf3type) (typename Function::first_argument_type, typename Function::second_argument_type, typename Function::argument_3_type);
    explicit inline bndr_1_3(const Function &f, typename Function::first_argument_type a1, 
                    typename Function::argument_3_type a3) : 
        arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg3val(a3) {}
    inline bndr_1_3(const bndr_1_3& bndri) : 
        arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_1_2 : 
                public arity1fp<typename Function::argument_3_type, typename Function::result_type> {
public:
    typedef typename Function::result_type (*const pf3type) (typename Function::first_argument_type, typename Function::second_argument_type, typename Function::argument_3_type);
    explicit inline bndr_1_2(const Function &f, typename Function::first_argument_type a1, 
                    typename Function::second_argument_type a2) : 
        arity1fp<typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg2val(a2) {}
    inline bndr_1_2(const bndr_1_2& bndri) : 
        arity1fp<typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding pmf  of arity 3 to arity 1

template<class Function> class bndr_mf_2_3 : 
                public arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_2_3(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_mf_2_3(const bndr_mf_2_3& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_mf_1_3 : 
                public arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_3(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_mf_1_3(const bndr_mf_1_3& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_mf_1_2 : 
                public arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_2(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_mf_1_2(const bndr_mf_1_2& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding const pmf  of arity 3 to arity 1

template<class Function> class bndr_const_mf_2_3 : 
                public arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_const_mf_2_3(const bndr_const_mf_2_3& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_mf_1_3 : 
                public arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_const_mf_1_3(const bndr_const_mf_1_3& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_mf_1_2 : 
                public arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_const_mf_1_2(const bndr_const_mf_1_2& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding obj&pmf Ref of arity 3 to arity 1

template<class Function> class bndr_obj_2_3 : 
                public arity1opmf<Function>, 
                private arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_2_3(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_obj_2_3(const bndr_obj_2_3& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_obj_1_3 : 
                public arity1opmf<Function>, 
                private arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_3(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_obj_1_3(const bndr_obj_1_3& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_obj_1_2 : 
                public arity1opmf<Function>, 
                private arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_2(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_obj_1_2(const bndr_obj_1_2& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function> class bndr_const_obj_2_3 : 
                public arity1opmf_const<Function>, 
                private arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_const_obj_2_3(const bndr_const_obj_2_3& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_obj_1_3 : 
                public arity1opmf_const<Function>, 
                private arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_const_obj_1_3(const bndr_const_obj_1_3& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_obj_1_2 : 
                public arity1opmf_const<Function>, 
                private arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_const_obj_1_2(const bndr_const_obj_1_2& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Functions for binding arity 3 to arity 1


// Template Functions for binding function ptrs of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline bndr_2_3<Function>
            bind_fp_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_2_3<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline bndr_1_3<Function>
            bind_fp_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_1_3<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline bndr_1_2<Function>
            bind_fp_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_1_2<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline bndr_mf_2_3<Function>
            bind_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_mf_2_3<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline bndr_mf_1_3<Function>
            bind_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_mf_1_3<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline bndr_mf_1_2<Function>
            bind_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_mf_1_2<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding const pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline bndr_const_mf_2_3<Function>
            bind_const_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_const_mf_2_3<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline bndr_const_mf_1_3<Function>
            bind_const_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_const_mf_1_3<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline bndr_const_mf_1_2<Function>
            bind_const_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_const_mf_1_2<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding obj&pmf Ref of arity 3 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3> inline bndr_obj_2_3<Function>
            bind_obj_2_3(Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_obj_2_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A3> inline bndr_obj_1_3<Function>
            bind_obj_1_3(Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_obj_1_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A2> inline bndr_obj_1_2<Function>
            bind_obj_1_2(Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_obj_1_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3> inline bndr_const_obj_2_3<Function>
            bind_const_obj_2_3(const Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_const_obj_2_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A3> inline bndr_const_obj_1_3<Function>
            bind_const_obj_1_3(const Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_const_obj_1_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A2> inline bndr_const_obj_1_2<Function>
            bind_const_obj_1_2(const Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_const_obj_1_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



//
// binders for arity 4
//


// Template Classes for binding arity 4 to arity 1


// Template Classes for binding pmf  of arity 4 to arity 1

template<class Function> class bndr_mf_2_3_4 : 
                public arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_2_3_4(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_mf_2_3_4(const bndr_mf_2_3_4& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_mf_1_3_4 : 
                public arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_3_4(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_mf_1_3_4(const bndr_mf_1_3_4& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_mf_1_2_4 : 
                public arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_2_4(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_mf_1_2_4(const bndr_mf_1_2_4& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Classes for binding const pmf  of arity 4 to arity 1

template<class Function> class bndr_const_mf_2_3_4 : 
                public arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3_4(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_const_mf_2_3_4(const bndr_const_mf_2_3_4& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_mf_1_3_4 : 
                public arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3_4(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_const_mf_1_3_4(const bndr_const_mf_1_3_4& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_mf_1_2_4 : 
                public arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2_4(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_const_mf_1_2_4(const bndr_const_mf_1_2_4& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Classes for binding obj&pmf Ref of arity 4 to arity 1

template<class Function> class bndr_obj_2_3_4 : 
                public arity1opmf<Function>, 
                private arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_2_3_4(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_obj_2_3_4(const bndr_obj_2_3_4& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_obj_1_3_4 : 
                public arity1opmf<Function>, 
                private arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_3_4(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_obj_1_3_4(const bndr_obj_1_3_4& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_obj_1_2_4 : 
                public arity1opmf<Function>, 
                private arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_2_4(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_obj_1_2_4(const bndr_obj_1_2_4& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Classes for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function> class bndr_const_obj_2_3_4 : 
                public arity1opmf_const<Function>, 
                private arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3_4(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_const_obj_2_3_4(const bndr_const_obj_2_3_4& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_obj_1_3_4 : 
                public arity1opmf_const<Function>, 
                private arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3_4(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_const_obj_1_3_4(const bndr_const_obj_1_3_4& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_obj_1_2_4 : 
                public arity1opmf_const<Function>, 
                private arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2_4(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_const_obj_1_2_4(const bndr_const_obj_1_2_4& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Functions for binding arity 4 to arity 1


// Template Functions for binding pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline bndr_mf_2_3_4<Function>
            bind_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_mf_2_3_4<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline bndr_mf_1_3_4<Function>
            bind_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_mf_1_3_4<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline bndr_mf_1_2_4<Function>
            bind_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_mf_1_2_4<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



// Template Functions for binding const pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline bndr_const_mf_2_3_4<Function>
            bind_const_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_mf_2_3_4<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline bndr_const_mf_1_3_4<Function>
            bind_const_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_mf_1_3_4<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline bndr_const_mf_1_2_4<Function>
            bind_const_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_const_mf_1_2_4<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



// Template Functions for binding obj&pmf Ref of arity 4 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4> inline bndr_obj_2_3_4<Function>
            bind_obj_2_3_4(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_obj_2_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4> inline bndr_obj_1_3_4<Function>
            bind_obj_1_3_4(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_obj_1_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4> inline bndr_obj_1_2_4<Function>
            bind_obj_1_2_4(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_obj_1_2_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



// Template Functions for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4> inline bndr_const_obj_2_3_4<Function>
            bind_const_obj_2_3_4(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_obj_2_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4> inline bndr_const_obj_1_3_4<Function>
            bind_const_obj_1_3_4(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_obj_1_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4> inline bndr_const_obj_1_2_4<Function>
            bind_const_obj_1_2_4(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_const_obj_1_2_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



//
// binders for arity 5
//


// Template Classes for binding arity 5 to arity 1


// Template Classes for binding pmf  of arity 5 to arity 1

template<class Function> class bndr_mf_2_3_4_5 : 
                public arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_2_3_4_5(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_mf_2_3_4_5(const bndr_mf_2_3_4_5& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_mf_1_3_4_5 : 
                public arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_3_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_mf_1_3_4_5(const bndr_mf_1_3_4_5& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_mf_1_2_4_5 : 
                public arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_2_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_mf_1_2_4_5(const bndr_mf_1_2_4_5& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Classes for binding const pmf  of arity 5 to arity 1

template<class Function> class bndr_const_mf_2_3_4_5 : 
                public arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3_4_5(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_mf_2_3_4_5(const bndr_const_mf_2_3_4_5& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_mf_1_3_4_5 : 
                public arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_mf_1_3_4_5(const bndr_const_mf_1_3_4_5& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_mf_1_2_4_5 : 
                public arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_const_mf_1_2_4_5(const bndr_const_mf_1_2_4_5& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Classes for binding obj&pmf Ref of arity 5 to arity 1

template<class Function> class bndr_obj_2_3_4_5 : 
                public arity1opmf<Function>, 
                private arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_2_3_4_5(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_obj_2_3_4_5(const bndr_obj_2_3_4_5& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_obj_1_3_4_5 : 
                public arity1opmf<Function>, 
                private arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_3_4_5(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_obj_1_3_4_5(const bndr_obj_1_3_4_5& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_obj_1_2_4_5 : 
                public arity1opmf<Function>, 
                private arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_2_4_5(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_obj_1_2_4_5(const bndr_obj_1_2_4_5& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Classes for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function> class bndr_const_obj_2_3_4_5 : 
                public arity1opmf_const<Function>, 
                private arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3_4_5(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_obj_2_3_4_5(const bndr_const_obj_2_3_4_5& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_obj_1_3_4_5 : 
                public arity1opmf_const<Function>, 
                private arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3_4_5(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_obj_1_3_4_5(const bndr_const_obj_1_3_4_5& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_obj_1_2_4_5 : 
                public arity1opmf_const<Function>, 
                private arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2_4_5(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_const_obj_1_2_4_5(const bndr_const_obj_1_2_4_5& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Functions for binding arity 5 to arity 1


// Template Functions for binding pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_mf_2_3_4_5<Function>
            bind_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_mf_2_3_4_5<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_mf_1_3_4_5<Function>
            bind_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_mf_1_3_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_mf_1_2_4_5<Function>
            bind_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_mf_1_2_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



// Template Functions for binding const pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_mf_2_3_4_5<Function>
            bind_const_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_mf_2_3_4_5<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_mf_1_3_4_5<Function>
            bind_const_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_mf_1_3_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_const_mf_1_2_4_5<Function>
            bind_const_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_mf_1_2_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



// Template Functions for binding obj&pmf Ref of arity 5 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_obj_2_3_4_5<Function>
            bind_obj_2_3_4_5(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_obj_2_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_obj_1_3_4_5<Function>
            bind_obj_1_3_4_5(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_obj_1_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_obj_1_2_4_5<Function>
            bind_obj_1_2_4_5(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_obj_1_2_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



// Template Functions for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_obj_2_3_4_5<Function>
            bind_const_obj_2_3_4_5(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_obj_2_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_obj_1_3_4_5<Function>
            bind_const_obj_1_3_4_5(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_obj_1_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_const_obj_1_2_4_5<Function>
            bind_const_obj_1_2_4_5(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_obj_1_2_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



//
// binders for arity 6
//


// Template Classes for binding arity 6 to arity 1


// Template Classes for binding pmf  of arity 6 to arity 1

template<class Function> class bndr_mf_2_3_4_5_6 : 
                public arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_2_3_4_5_6(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_mf_2_3_4_5_6(const bndr_mf_2_3_4_5_6& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_mf_1_3_4_5_6 : 
                public arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_3_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_mf_1_3_4_5_6(const bndr_mf_1_3_4_5_6& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_mf_1_2_4_5_6 : 
                public arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_mf_1_2_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_mf_1_2_4_5_6(const bndr_mf_1_2_4_5_6& bndri) : 
        arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Classes for binding const pmf  of arity 6 to arity 1

template<class Function> class bndr_const_mf_2_3_4_5_6 : 
                public arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3_4_5_6(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_mf_2_3_4_5_6(const bndr_const_mf_2_3_4_5_6& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_mf_1_3_4_5_6 : 
                public arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_mf_1_3_4_5_6(const bndr_const_mf_1_3_4_5_6& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_mf_1_2_4_5_6 : 
                public arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_mf_1_2_4_5_6(const bndr_const_mf_1_2_4_5_6& bndri) : 
        arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Classes for binding obj&pmf Ref of arity 6 to arity 1

template<class Function> class bndr_obj_2_3_4_5_6 : 
                public arity1opmf<Function>, 
                private arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_2_3_4_5_6(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_obj_2_3_4_5_6(const bndr_obj_2_3_4_5_6& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_obj_1_3_4_5_6 : 
                public arity1opmf<Function>, 
                private arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_3_4_5_6(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_obj_1_3_4_5_6(const bndr_obj_1_3_4_5_6& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_obj_1_2_4_5_6 : 
                public arity1opmf<Function>, 
                private arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_obj_1_2_4_5_6(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_obj_1_2_4_5_6(const bndr_obj_1_2_4_5_6& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Classes for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function> class bndr_const_obj_2_3_4_5_6 : 
                public arity1opmf_const<Function>, 
                private arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3_4_5_6(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_obj_2_3_4_5_6(const bndr_const_obj_2_3_4_5_6& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_obj_1_3_4_5_6 : 
                public arity1opmf_const<Function>, 
                private arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3_4_5_6(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_obj_1_3_4_5_6(const bndr_const_obj_1_3_4_5_6& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_obj_1_2_4_5_6 : 
                public arity1opmf_const<Function>, 
                private arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2_4_5_6(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_obj_1_2_4_5_6(const bndr_const_obj_1_2_4_5_6& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Functions for binding arity 6 to arity 1


// Template Functions for binding pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_mf_2_3_4_5_6<Function>
            bind_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_mf_2_3_4_5_6<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_mf_1_3_4_5_6<Function>
            bind_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_mf_1_3_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_mf_1_2_4_5_6<Function>
            bind_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_mf_1_2_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Functions for binding const pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_mf_2_3_4_5_6<Function>
            bind_const_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_mf_2_3_4_5_6<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_mf_1_3_4_5_6<Function>
            bind_const_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_mf_1_3_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_mf_1_2_4_5_6<Function>
            bind_const_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_mf_1_2_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Functions for binding obj&pmf Ref of arity 6 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_obj_2_3_4_5_6<Function>
            bind_obj_2_3_4_5_6(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_obj_2_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_obj_1_3_4_5_6<Function>
            bind_obj_1_3_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_obj_1_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_obj_1_2_4_5_6<Function>
            bind_obj_1_2_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_obj_1_2_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Functions for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_obj_2_3_4_5_6<Function>
            bind_const_obj_2_3_4_5_6(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_obj_2_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_obj_1_3_4_5_6<Function>
            bind_const_obj_1_3_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_obj_1_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_obj_1_2_4_5_6<Function>
            bind_const_obj_1_2_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_obj_1_2_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



//
// binders for arity 2
//


// Template Classes for binding arity 2 to arity 1


// Template Classes for binding function ptrs of arity 2 to arity 1

template<class Function> class std_bndr_2 : 
                public std_arity1fp<typename Function::first_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type ( __stdcall *const pf2type) (typename Function::first_argument_type, typename Function::second_argument_type);
    explicit inline std_bndr_2(const Function &f, typename Function::second_argument_type a2) : 
        std_arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2) {}
    inline std_bndr_2(const std_bndr_2& bndri) : 
        std_arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_1 : 
                public std_arity1fp<typename Function::second_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type ( __stdcall *const pf2type) (typename Function::first_argument_type, typename Function::second_argument_type);
    explicit inline std_bndr_1(const Function &f, typename Function::first_argument_type a1) : 
        std_arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1) {}
    inline std_bndr_1(const std_bndr_1& bndri) : 
        std_arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding pmf  of arity 2 to arity 1

template<class Function> class std_bndr_mf_2 : 
                public std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_2(const Function &f, typename Function::second_argument_type a2) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_mf_2(const std_bndr_mf_2& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_mf_1 : 
                public std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1(const Function &f, typename Function::first_argument_type a1) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_mf_1(const std_bndr_mf_1& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding const pmf  of arity 2 to arity 1

template<class Function> class std_bndr_const_mf_2 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2(const Function &f, typename Function::second_argument_type a2) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_const_mf_2(const std_bndr_const_mf_2& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_const_mf_1 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1(const Function &f, typename Function::first_argument_type a1) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_const_mf_1(const std_bndr_const_mf_1& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding obj&pmf Ref of arity 2 to arity 1

template<class Function> class std_bndr_obj_2 : 
                public std_arity1opmf<Function>, 
                private std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_2(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_obj_2(const std_bndr_obj_2& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_obj_1 : 
                public std_arity1opmf<Function>, 
                private std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_obj_1(const std_bndr_obj_1& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Classes for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function> class std_bndr_const_obj_2 : 
                public std_arity1opmf_const<Function>, 
                private std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_const_obj_2(const std_bndr_const_obj_2& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    typename Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_const_obj_1 : 
                public std_arity1opmf_const<Function>, 
                private std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_const_obj_1(const std_bndr_const_obj_1& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    typename Function::first_argument_type arg1val;
};



// Template Functions for binding arity 2 to arity 1


// Template Functions for binding function ptrs of arity 2 to arity 1

template<class Function, class A2> inline std_bndr_2<Function>
            std_bind_fp_2(const Function &f, A2 a2) {
                return std_bndr_2<Function>(f, typename Function::second_argument_type(a2));
};

template<class Function, class A1> inline std_bndr_1<Function>
            std_bind_fp_1(const Function &f, A1 a1) {
                return std_bndr_1<Function>(f, typename Function::first_argument_type(a1));
};



// Template Functions for binding pmf  of arity 2 to arity 1

template<class Function, class A2> inline std_bndr_mf_2<Function>
            std_bind_mf_2(const Function &f, A2 a2) {
                return std_bndr_mf_2<Function>(f, typename Function::second_argument_type(a2));
};

template<class Function, class A1> inline std_bndr_mf_1<Function>
            std_bind_mf_1(const Function &f, A1 a1) {
                return std_bndr_mf_1<Function>(f, typename Function::first_argument_type(a1));
};



// Template Functions for binding const pmf  of arity 2 to arity 1

template<class Function, class A2> inline std_bndr_const_mf_2<Function>
            std_bind_const_mf_2(const Function &f, A2 a2) {
                return std_bndr_const_mf_2<Function>(f, typename Function::second_argument_type(a2));
};

template<class Function, class A1> inline std_bndr_const_mf_1<Function>
            std_bind_const_mf_1(const Function &f, A1 a1) {
                return std_bndr_const_mf_1<Function>(f, typename Function::first_argument_type(a1));
};



// Template Functions for binding obj&pmf Ref of arity 2 to arity 1

template<class Function, class Object, 
                class A2> inline std_bndr_obj_2<Function>
            std_bind_obj_2(Object& oi, const Function &f, A2 a2) {
                return std_bndr_obj_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2));
};

template<class Function, class Object, 
                class A1> inline std_bndr_obj_1<Function>
            std_bind_obj_1(Object& oi, const Function &f, A1 a1) {
                return std_bndr_obj_1<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1));
};



// Template Functions for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function, const class Object, 
                class A2> inline std_bndr_const_obj_2<Function>
            std_bind_const_obj_2(const Object& oi, const Function &f, A2 a2) {
                return std_bndr_const_obj_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2));
};

template<class Function, const class Object, 
                class A1> inline std_bndr_const_obj_1<Function>
            std_bind_const_obj_1(const Object& oi, const Function &f, A1 a1) {
                return std_bndr_const_obj_1<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1));
};



//
// binders for arity 3
//


// Template Classes for binding arity 3 to arity 1


// Template Classes for binding function ptrs of arity 3 to arity 1

template<class Function> class std_bndr_2_3 : 
                public std_arity1fp<typename Function::first_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type ( __stdcall *const pf3type) (typename Function::first_argument_type, typename Function::second_argument_type, typename Function::argument_3_type);
    explicit inline std_bndr_2_3(const Function &f, typename Function::second_argument_type a2, 
                    typename Function::argument_3_type a3) : 
        std_arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2), arg3val(a3) {}
    inline std_bndr_2_3(const std_bndr_2_3& bndri) : 
        std_arity1fp<typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_1_3 : 
                public std_arity1fp<typename Function::second_argument_type, typename Function::result_type> {
public:
    typedef typename Function::result_type ( __stdcall *const pf3type) (typename Function::first_argument_type, typename Function::second_argument_type, typename Function::argument_3_type);
    explicit inline std_bndr_1_3(const Function &f, typename Function::first_argument_type a1, 
                    typename Function::argument_3_type a3) : 
        std_arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg3val(a3) {}
    inline std_bndr_1_3(const std_bndr_1_3& bndri) : 
        std_arity1fp<typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_1_2 : 
                public std_arity1fp<typename Function::argument_3_type, typename Function::result_type> {
public:
    typedef typename Function::result_type ( __stdcall *const pf3type) (typename Function::first_argument_type, typename Function::second_argument_type, typename Function::argument_3_type);
    explicit inline std_bndr_1_2(const Function &f, typename Function::first_argument_type a1, 
                    typename Function::second_argument_type a2) : 
        std_arity1fp<typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg2val(a2) {}
    inline std_bndr_1_2(const std_bndr_1_2& bndri) : 
        std_arity1fp<typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding pmf  of arity 3 to arity 1

template<class Function> class std_bndr_mf_2_3 : 
                public std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_mf_2_3(const std_bndr_mf_2_3& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_mf_1_3 : 
                public std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_mf_1_3(const std_bndr_mf_1_3& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_mf_1_2 : 
                public std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_mf_1_2(const std_bndr_mf_1_2& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding const pmf  of arity 3 to arity 1

template<class Function> class std_bndr_const_mf_2_3 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_const_mf_2_3(const std_bndr_const_mf_2_3& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_mf_1_3 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_const_mf_1_3(const std_bndr_const_mf_1_3& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_mf_1_2 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_const_mf_1_2(const std_bndr_const_mf_1_2& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding obj&pmf Ref of arity 3 to arity 1

template<class Function> class std_bndr_obj_2_3 : 
                public std_arity1opmf<Function>, 
                private std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_obj_2_3(const std_bndr_obj_2_3& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_obj_1_3 : 
                public std_arity1opmf<Function>, 
                private std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_obj_1_3(const std_bndr_obj_1_3& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_obj_1_2 : 
                public std_arity1opmf<Function>, 
                private std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_obj_1_2(const std_bndr_obj_1_2& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Classes for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function> class std_bndr_const_obj_2_3 : 
                public std_arity1opmf_const<Function>, 
                private std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_const_obj_2_3(const std_bndr_const_obj_2_3& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_obj_1_3 : 
                public std_arity1opmf_const<Function>, 
                private std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_const_obj_1_3(const std_bndr_const_obj_1_3& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_obj_1_2 : 
                public std_arity1opmf_const<Function>, 
                private std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_const_obj_1_2(const std_bndr_const_obj_1_2& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
};



// Template Functions for binding arity 3 to arity 1


// Template Functions for binding function ptrs of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline std_bndr_2_3<Function>
            std_bind_fp_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_2_3<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline std_bndr_1_3<Function>
            std_bind_fp_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_1_3<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline std_bndr_1_2<Function>
            std_bind_fp_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_1_2<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline std_bndr_mf_2_3<Function>
            std_bind_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_mf_2_3<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline std_bndr_mf_1_3<Function>
            std_bind_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_mf_1_3<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline std_bndr_mf_1_2<Function>
            std_bind_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_mf_1_2<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding const pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline std_bndr_const_mf_2_3<Function>
            std_bind_const_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_const_mf_2_3<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline std_bndr_const_mf_1_3<Function>
            std_bind_const_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_const_mf_1_3<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline std_bndr_const_mf_1_2<Function>
            std_bind_const_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_const_mf_1_2<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding obj&pmf Ref of arity 3 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3> inline std_bndr_obj_2_3<Function>
            std_bind_obj_2_3(Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_obj_2_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A3> inline std_bndr_obj_1_3<Function>
            std_bind_obj_1_3(Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_obj_1_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A2> inline std_bndr_obj_1_2<Function>
            std_bind_obj_1_2(Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_obj_1_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



// Template Functions for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3> inline std_bndr_const_obj_2_3<Function>
            std_bind_const_obj_2_3(const Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_const_obj_2_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A3> inline std_bndr_const_obj_1_3<Function>
            std_bind_const_obj_1_3(const Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_const_obj_1_3<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A2> inline std_bndr_const_obj_1_2<Function>
            std_bind_const_obj_1_2(const Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_const_obj_1_2<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2));
};



//
// binders for arity 4
//


// Template Classes for binding arity 4 to arity 1


// Template Classes for binding pmf  of arity 4 to arity 1

template<class Function> class std_bndr_mf_2_3_4 : 
                public std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_mf_2_3_4(const std_bndr_mf_2_3_4& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_mf_1_3_4 : 
                public std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_mf_1_3_4(const std_bndr_mf_1_3_4& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_mf_1_2_4 : 
                public std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_mf_1_2_4(const std_bndr_mf_1_2_4& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Classes for binding const pmf  of arity 4 to arity 1

template<class Function> class std_bndr_const_mf_2_3_4 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3_4(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_mf_2_3_4(const std_bndr_const_mf_2_3_4& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_mf_1_3_4 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3_4(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_mf_1_3_4(const std_bndr_const_mf_1_3_4& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_mf_1_2_4 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2_4(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_const_mf_1_2_4(const std_bndr_const_mf_1_2_4& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Classes for binding obj&pmf Ref of arity 4 to arity 1

template<class Function> class std_bndr_obj_2_3_4 : 
                public std_arity1opmf<Function>, 
                private std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_obj_2_3_4(const std_bndr_obj_2_3_4& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_obj_1_3_4 : 
                public std_arity1opmf<Function>, 
                private std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_obj_1_3_4(const std_bndr_obj_1_3_4& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_obj_1_2_4 : 
                public std_arity1opmf<Function>, 
                private std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_obj_1_2_4(const std_bndr_obj_1_2_4& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Classes for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function> class std_bndr_const_obj_2_3_4 : 
                public std_arity1opmf_const<Function>, 
                private std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3_4(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_obj_2_3_4(const std_bndr_const_obj_2_3_4& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_obj_1_3_4 : 
                public std_arity1opmf_const<Function>, 
                private std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3_4(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_obj_1_3_4(const std_bndr_const_obj_1_3_4& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_obj_1_2_4 : 
                public std_arity1opmf_const<Function>, 
                private std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2_4(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_const_obj_1_2_4(const std_bndr_const_obj_1_2_4& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
};



// Template Functions for binding arity 4 to arity 1


// Template Functions for binding pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline std_bndr_mf_2_3_4<Function>
            std_bind_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_mf_2_3_4<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline std_bndr_mf_1_3_4<Function>
            std_bind_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_mf_1_3_4<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline std_bndr_mf_1_2_4<Function>
            std_bind_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_mf_1_2_4<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



// Template Functions for binding const pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline std_bndr_const_mf_2_3_4<Function>
            std_bind_const_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_mf_2_3_4<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline std_bndr_const_mf_1_3_4<Function>
            std_bind_const_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_mf_1_3_4<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline std_bndr_const_mf_1_2_4<Function>
            std_bind_const_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_const_mf_1_2_4<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



// Template Functions for binding obj&pmf Ref of arity 4 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4> inline std_bndr_obj_2_3_4<Function>
            std_bind_obj_2_3_4(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_obj_2_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4> inline std_bndr_obj_1_3_4<Function>
            std_bind_obj_1_3_4(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_obj_1_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4> inline std_bndr_obj_1_2_4<Function>
            std_bind_obj_1_2_4(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_obj_1_2_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



// Template Functions for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4> inline std_bndr_const_obj_2_3_4<Function>
            std_bind_const_obj_2_3_4(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_obj_2_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4> inline std_bndr_const_obj_1_3_4<Function>
            std_bind_const_obj_1_3_4(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_obj_1_3_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4> inline std_bndr_const_obj_1_2_4<Function>
            std_bind_const_obj_1_2_4(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_const_obj_1_2_4<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4));
};



//
// binders for arity 5
//


// Template Classes for binding arity 5 to arity 1


// Template Classes for binding pmf  of arity 5 to arity 1

template<class Function> class std_bndr_mf_2_3_4_5 : 
                public std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4_5(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_mf_2_3_4_5(const std_bndr_mf_2_3_4_5& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_mf_1_3_4_5 : 
                public std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_mf_1_3_4_5(const std_bndr_mf_1_3_4_5& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_mf_1_2_4_5 : 
                public std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_mf_1_2_4_5(const std_bndr_mf_1_2_4_5& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Classes for binding const pmf  of arity 5 to arity 1

template<class Function> class std_bndr_const_mf_2_3_4_5 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3_4_5(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_mf_2_3_4_5(const std_bndr_const_mf_2_3_4_5& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_mf_1_3_4_5 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_mf_1_3_4_5(const std_bndr_const_mf_1_3_4_5& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_mf_1_2_4_5 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2_4_5(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_mf_1_2_4_5(const std_bndr_const_mf_1_2_4_5& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Classes for binding obj&pmf Ref of arity 5 to arity 1

template<class Function> class std_bndr_obj_2_3_4_5 : 
                public std_arity1opmf<Function>, 
                private std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4_5(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_obj_2_3_4_5(const std_bndr_obj_2_3_4_5& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_obj_1_3_4_5 : 
                public std_arity1opmf<Function>, 
                private std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4_5(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_obj_1_3_4_5(const std_bndr_obj_1_3_4_5& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_obj_1_2_4_5 : 
                public std_arity1opmf<Function>, 
                private std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4_5(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_obj_1_2_4_5(const std_bndr_obj_1_2_4_5& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Classes for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function> class std_bndr_const_obj_2_3_4_5 : 
                public std_arity1opmf_const<Function>, 
                private std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3_4_5(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_obj_2_3_4_5(const std_bndr_const_obj_2_3_4_5& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_obj_1_3_4_5 : 
                public std_arity1opmf_const<Function>, 
                private std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3_4_5(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_obj_1_3_4_5(const std_bndr_const_obj_1_3_4_5& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_obj_1_2_4_5 : 
                public std_arity1opmf_const<Function>, 
                private std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2_4_5(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_obj_1_2_4_5(const std_bndr_const_obj_1_2_4_5& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
};



// Template Functions for binding arity 5 to arity 1


// Template Functions for binding pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_mf_2_3_4_5<Function>
            std_bind_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_mf_2_3_4_5<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_mf_1_3_4_5<Function>
            std_bind_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_mf_1_3_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_mf_1_2_4_5<Function>
            std_bind_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_mf_1_2_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



// Template Functions for binding const pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_mf_2_3_4_5<Function>
            std_bind_const_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_mf_2_3_4_5<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_mf_1_3_4_5<Function>
            std_bind_const_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_mf_1_3_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_const_mf_1_2_4_5<Function>
            std_bind_const_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_mf_1_2_4_5<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



// Template Functions for binding obj&pmf Ref of arity 5 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_obj_2_3_4_5<Function>
            std_bind_obj_2_3_4_5(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_obj_2_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_obj_1_3_4_5<Function>
            std_bind_obj_1_3_4_5(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_obj_1_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_obj_1_2_4_5<Function>
            std_bind_obj_1_2_4_5(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_obj_1_2_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



// Template Functions for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_obj_2_3_4_5<Function>
            std_bind_const_obj_2_3_4_5(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_obj_2_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_obj_1_3_4_5<Function>
            std_bind_const_obj_1_3_4_5(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_obj_1_3_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_const_obj_1_2_4_5<Function>
            std_bind_const_obj_1_2_4_5(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_obj_1_2_4_5<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5));
};



//
// binders for arity 6
//


// Template Classes for binding arity 6 to arity 1


// Template Classes for binding pmf  of arity 6 to arity 1

template<class Function> class std_bndr_mf_2_3_4_5_6 : 
                public std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4_5_6(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_mf_2_3_4_5_6(const std_bndr_mf_2_3_4_5_6& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_mf_1_3_4_5_6 : 
                public std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_mf_1_3_4_5_6(const std_bndr_mf_1_3_4_5_6& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_mf_1_2_4_5_6 : 
                public std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_mf_1_2_4_5_6(const std_bndr_mf_1_2_4_5_6& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Classes for binding const pmf  of arity 6 to arity 1

template<class Function> class std_bndr_const_mf_2_3_4_5_6 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3_4_5_6(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_mf_2_3_4_5_6(const std_bndr_const_mf_2_3_4_5_6& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_mf_1_3_4_5_6 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_mf_1_3_4_5_6(const std_bndr_const_mf_1_3_4_5_6& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_mf_1_2_4_5_6 : 
                public std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2_4_5_6(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_mf_1_2_4_5_6(const std_bndr_const_mf_1_2_4_5_6& bndri) : 
        std_arity1pmf_const<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Classes for binding obj&pmf Ref of arity 6 to arity 1

template<class Function> class std_bndr_obj_2_3_4_5_6 : 
                public std_arity1opmf<Function>, 
                private std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4_5_6(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_obj_2_3_4_5_6(const std_bndr_obj_2_3_4_5_6& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_obj_1_3_4_5_6 : 
                public std_arity1opmf<Function>, 
                private std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4_5_6(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_obj_1_3_4_5_6(const std_bndr_obj_1_3_4_5_6& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_obj_1_2_4_5_6 : 
                public std_arity1opmf<Function>, 
                private std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4_5_6(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_obj_1_2_4_5_6(const std_bndr_obj_1_2_4_5_6& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Classes for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function> class std_bndr_const_obj_2_3_4_5_6 : 
                public std_arity1opmf_const<Function>, 
                private std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3_4_5_6(const typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_obj_2_3_4_5_6(const std_bndr_const_obj_2_3_4_5_6& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_obj_1_3_4_5_6 : 
                public std_arity1opmf_const<Function>, 
                private std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3_4_5_6(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_obj_1_3_4_5_6(const std_bndr_const_obj_1_3_4_5_6& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_obj_1_2_4_5_6 : 
                public std_arity1opmf_const<Function>, 
                private std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2_4_5_6(const typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_obj_1_2_4_5_6(const std_bndr_const_obj_1_2_4_5_6& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
};



// Template Functions for binding arity 6 to arity 1


// Template Functions for binding pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_mf_2_3_4_5_6<Function>
            std_bind_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_mf_2_3_4_5_6<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_mf_1_3_4_5_6<Function>
            std_bind_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_mf_1_3_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_mf_1_2_4_5_6<Function>
            std_bind_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_mf_1_2_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Functions for binding const pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_mf_2_3_4_5_6<Function>
            std_bind_const_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_mf_2_3_4_5_6<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_mf_1_3_4_5_6<Function>
            std_bind_const_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_mf_1_3_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_mf_1_2_4_5_6<Function>
            std_bind_const_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_mf_1_2_4_5_6<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Functions for binding obj&pmf Ref of arity 6 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_obj_2_3_4_5_6<Function>
            std_bind_obj_2_3_4_5_6(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_obj_2_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_obj_1_3_4_5_6<Function>
            std_bind_obj_1_3_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_obj_1_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_obj_1_2_4_5_6<Function>
            std_bind_obj_1_2_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_obj_1_2_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Functions for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_obj_2_3_4_5_6<Function>
            std_bind_const_obj_2_3_4_5_6(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_obj_2_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_obj_1_3_4_5_6<Function>
            std_bind_const_obj_1_3_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_obj_1_3_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_obj_1_2_4_5_6<Function>
            std_bind_const_obj_1_2_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_obj_1_2_4_5_6<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6));
};



// Template Classes for binding arity 15 to 1


// Template Classes for binding pmf  of arity 15 to arity 1

template<class Function> class std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>, 
                private std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6, typename Function::argument_7_type a7, typename Function::argument_8_type a8, typename Function::argument_9_type a9, typename Function::argument_10_type a10, typename Function::argument_11_type a11, typename Function::argument_12_type a12, typename Function::argument_13_type a13, typename Function::argument_14_type a14, typename Function::argument_15_type a15) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::first_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::first_argument_type a1) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
    typename Function::argument_7_type arg7val;
    typename Function::argument_8_type arg8val;
    typename Function::argument_9_type arg9val;
    typename Function::argument_10_type arg10val;
    typename Function::argument_11_type arg11val;
    typename Function::argument_12_type arg12val;
    typename Function::argument_13_type arg13val;
    typename Function::argument_14_type arg14val;
    typename Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>, 
                private std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6, typename Function::argument_7_type a7, typename Function::argument_8_type a8, typename Function::argument_9_type a9, typename Function::argument_10_type a10, typename Function::argument_11_type a11, typename Function::argument_12_type a12, typename Function::argument_13_type a13, typename Function::argument_14_type a14, typename Function::argument_15_type a15) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::second_argument_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::second_argument_type a2) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
    typename Function::argument_7_type arg7val;
    typename Function::argument_8_type arg8val;
    typename Function::argument_9_type arg9val;
    typename Function::argument_10_type arg10val;
    typename Function::argument_11_type arg11val;
    typename Function::argument_12_type arg12val;
    typename Function::argument_13_type arg13val;
    typename Function::argument_14_type arg14val;
    typename Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>, 
                private std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6, typename Function::argument_7_type a7, typename Function::argument_8_type a8, typename Function::argument_9_type a9, typename Function::argument_10_type a10, typename Function::argument_11_type a11, typename Function::argument_12_type a12, typename Function::argument_13_type a13, typename Function::argument_14_type a14, typename Function::argument_15_type a15) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1pmf<typename Function::object_type, typename Function::argument_3_type, typename Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline virtual typename Function::result_type operator()(typename Function::object_type& o, typename Function::argument_3_type a3) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
    typename Function::argument_7_type arg7val;
    typename Function::argument_8_type arg8val;
    typename Function::argument_9_type arg9val;
    typename Function::argument_10_type arg10val;
    typename Function::argument_11_type arg11val;
    typename Function::argument_12_type arg12val;
    typename Function::argument_13_type arg13val;
    typename Function::argument_14_type arg14val;
    typename Function::argument_15_type arg15val;
};



// Template Classes for binding obj&pmf Ref of arity 15 to arity 1

template<class Function> class std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1opmf<Function>, 
                private std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15(typename Function::object_type& oi, const Function &f, typename Function::second_argument_type a2, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6, typename Function::argument_7_type a7, typename Function::argument_8_type a8, typename Function::argument_9_type a9, typename Function::argument_10_type a10, typename Function::argument_11_type a11, typename Function::argument_12_type a12, typename Function::argument_13_type a13, typename Function::argument_14_type a14, typename Function::argument_15_type a15) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline typename Function::result_type operator()(typename Function::first_argument_type a1) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    typename Function::second_argument_type arg2val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
    typename Function::argument_7_type arg7val;
    typename Function::argument_8_type arg8val;
    typename Function::argument_9_type arg9val;
    typename Function::argument_10_type arg10val;
    typename Function::argument_11_type arg11val;
    typename Function::argument_12_type arg12val;
    typename Function::argument_13_type arg13val;
    typename Function::argument_14_type arg14val;
    typename Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1opmf<Function>, 
                private std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::argument_3_type a3, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6, typename Function::argument_7_type a7, typename Function::argument_8_type a8, typename Function::argument_9_type a9, typename Function::argument_10_type a10, typename Function::argument_11_type a11, typename Function::argument_12_type a12, typename Function::argument_13_type a13, typename Function::argument_14_type a14, typename Function::argument_15_type a15) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline typename Function::result_type operator()(typename Function::second_argument_type a2) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::argument_3_type arg3val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
    typename Function::argument_7_type arg7val;
    typename Function::argument_8_type arg8val;
    typename Function::argument_9_type arg9val;
    typename Function::argument_10_type arg10val;
    typename Function::argument_11_type arg11val;
    typename Function::argument_12_type arg12val;
    typename Function::argument_13_type arg13val;
    typename Function::argument_14_type arg14val;
    typename Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1opmf<Function>, 
                private std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15(typename Function::object_type& oi, const Function &f, typename Function::first_argument_type a1, typename Function::second_argument_type a2, typename Function::argument_4_type a4, typename Function::argument_5_type a5, typename Function::argument_6_type a6, typename Function::argument_7_type a7, typename Function::argument_8_type a8, typename Function::argument_9_type a9, typename Function::argument_10_type a10, typename Function::argument_11_type a11, typename Function::argument_12_type a12, typename Function::argument_13_type a13, typename Function::argument_14_type a14, typename Function::argument_15_type a15) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<typename Function::object_type, typename Function::first_argument_type, 
                                typename Function::second_argument_type, 
                                typename Function::argument_3_type, 
                                typename Function::argument_4_type, 
                                typename Function::argument_5_type, 
                                typename Function::argument_6_type, 
                                typename Function::argument_7_type, 
                                typename Function::argument_8_type, 
                                typename Function::argument_9_type, 
                                typename Function::argument_10_type, 
                                typename Function::argument_11_type, 
                                typename Function::argument_12_type, 
                                typename Function::argument_13_type, 
                                typename Function::argument_14_type, 
                                typename Function::argument_15_type, typename Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline typename Function::result_type operator()(typename Function::argument_3_type a3) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    typename Function::first_argument_type arg1val;
    typename Function::second_argument_type arg2val;
    typename Function::argument_4_type arg4val;
    typename Function::argument_5_type arg5val;
    typename Function::argument_6_type arg6val;
    typename Function::argument_7_type arg7val;
    typename Function::argument_8_type arg8val;
    typename Function::argument_9_type arg9val;
    typename Function::argument_10_type arg10val;
    typename Function::argument_11_type arg11val;
    typename Function::argument_12_type arg12val;
    typename Function::argument_13_type arg13val;
    typename Function::argument_14_type arg14val;
    typename Function::argument_15_type arg15val;
};



// Template Functions for binding arity 15 to 1


// Template Functions for binding pmf  of arity 15 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6), typename Function::argument_7_type(a7), typename Function::argument_8_type(a8), typename Function::argument_9_type(a9), typename Function::argument_10_type(a10), typename Function::argument_11_type(a11), typename Function::argument_12_type(a12), typename Function::argument_13_type(a13), typename Function::argument_14_type(a14), typename Function::argument_15_type(a15));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6), typename Function::argument_7_type(a7), typename Function::argument_8_type(a8), typename Function::argument_9_type(a9), typename Function::argument_10_type(a10), typename Function::argument_11_type(a11), typename Function::argument_12_type(a12), typename Function::argument_13_type(a13), typename Function::argument_14_type(a14), typename Function::argument_15_type(a15));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>(f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6), typename Function::argument_7_type(a7), typename Function::argument_8_type(a8), typename Function::argument_9_type(a9), typename Function::argument_10_type(a10), typename Function::argument_11_type(a11), typename Function::argument_12_type(a12), typename Function::argument_13_type(a13), typename Function::argument_14_type(a14), typename Function::argument_15_type(a15));
};



// Template Functions for binding obj&pmf Ref of arity 15 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::second_argument_type(a2), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6), typename Function::argument_7_type(a7), typename Function::argument_8_type(a8), typename Function::argument_9_type(a9), typename Function::argument_10_type(a10), typename Function::argument_11_type(a11), typename Function::argument_12_type(a12), typename Function::argument_13_type(a13), typename Function::argument_14_type(a14), typename Function::argument_15_type(a15));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::argument_3_type(a3), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6), typename Function::argument_7_type(a7), typename Function::argument_8_type(a8), typename Function::argument_9_type(a9), typename Function::argument_10_type(a10), typename Function::argument_11_type(a11), typename Function::argument_12_type(a12), typename Function::argument_13_type(a13), typename Function::argument_14_type(a14), typename Function::argument_15_type(a15));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>(static_cast<typename Function::object_type&>(oi), f, typename Function::first_argument_type(a1), typename Function::second_argument_type(a2), typename Function::argument_4_type(a4), typename Function::argument_5_type(a5), typename Function::argument_6_type(a6), typename Function::argument_7_type(a7), typename Function::argument_8_type(a8), typename Function::argument_9_type(a9), typename Function::argument_10_type(a10), typename Function::argument_11_type(a11), typename Function::argument_12_type(a12), typename Function::argument_13_type(a13), typename Function::argument_14_type(a14), typename Function::argument_15_type(a15));
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\atsccomponenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef ATSCCOMPONENTTYPEIMPL_H
#define ATSCCOMPONENTTYPEIMPL_H

#include "componenttypeimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCComponentTypeImpl : 
	public IMPEG2ComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IATSCComponentType
public:
    DWORD m_dwFlags;

    IATSCComponentTypeImpl() : m_dwFlags(0) {}
	virtual ~IATSCComponentTypeImpl() {}
//    typedef IATSCComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef IMPEG2ComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(IATSCComponentTypeImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Flags", m_dwFlags, VT_UI4)
    END_PROP_MAP()

    STDMETHOD(get_Flags)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_dwFlags;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_Flags)(long newVal)
    {
		ATL_LOCKT();
        m_dwFlags = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppCT);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppCT);
			pt->m_dwFlags = m_dwFlags;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace

#endif // ATSCCOMPONENTTYPEIMPL_H
// end of file -- ATSCcomponenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dataserviceimpl.h ===
//==========================================================================;
//
// dataserviceimpl.h : additional infrastructure to support implementing IMSVidDataServices
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef DATASERVICEIMPL_H
#define DATASERVICEIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidDataServiceDevice>
    class DECLSPEC_NOVTABLE IMSVidDataServicesImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	    virtual ~IMSVidDataServicesImpl() {}
};

}; /// namespace

#endif
// end of file - dataserviceimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\channeltunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ChannelTuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef CHANNELTUNEREQUESTIMPL_H
#define CHANNELTUNEREQUESTIMPL_H

#include <tune.h>
#include "tunerequestimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IChannelTuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IChannelTuneRequestImpl : 
	public ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IChannelTuneRequest
public:
	typedef ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;

	IChannelTuneRequestImpl() : m_Channel(-1) {}
	virtual ~IChannelTuneRequestImpl() {}
    BEGIN_PROP_MAP(IChannelTuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Channel", m_Channel, VT_I4)
    END_PROP_MAP()

	long m_Channel;
    STDMETHOD(get_Channel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_Channel;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_Channel)(long newVal)
    {
		ATL_LOCKT();
		if (!m_TS) {
			return E_UNEXPECTED;
		}
		long maxval;
		long minval;
		TNAnalogTVTuningSpace ts(m_TS);
        if (ts) {
			maxval = ts.MaxChannel();
			minval = ts.MinChannel();
        } else {
            TNAnalogRadioTuningSpace ts2(m_TS);
            if (ts2) {
                maxval = ts2.MaxFrequency();
                minval = ts2.MinFrequency();
            } else {
                TNAuxInTuningSpace ts3(m_TS);
                if(ts3){
                    maxval = 1;
                    minval = 0;
                }
                else{
                    return E_UNEXPECTED;
                }
            }
        }
		if (newVal != BDA_UNDEFINED_CHANNEL) {
			if (newVal < minval) {
				newVal = maxval;
			} else if (newVal > maxval) {
				newVal = minval;
			}
		}
        m_Channel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_Channel = m_Channel;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};
typedef CComQIPtr<IChannelTuneRequest> PQChannelTuneRequest;

}; // namespace

#endif // CHANNELTUNEREQUESTIMPL_H
// end of file -- channeltunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\componenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef COMPONENTTYPEIMPL_H
#define COMPONENTTYPEIMPL_H

#pragma once
#include <tuner.h>
#include "errsupp.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IComponentTypeImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IComponentType
public:
    BEGIN_PROP_MAP(IComponentTypeImpl)
        PROP_DATA_ENTRY("Category", m_ComponentCategory, VT_I4)
        PROP_DATA_ENTRY("Media Major Type", m_MediaMajorType, VT_BSTR)
        PROP_DATA_ENTRY("Media Sub Type", m_MediaSubType, VT_BSTR)
        PROP_DATA_ENTRY("Media Format Type", m_MediaFormatType, VT_BSTR)
	END_PROP_MAP()

    ComponentCategory m_ComponentCategory;
	CComBSTR m_MediaMajorType;
	CComBSTR m_MediaSubType;
	CComBSTR m_MediaFormatType;

    IComponentTypeImpl() : m_ComponentCategory(CategoryNotSet) {
      GUID2 g(GUID_NULL);
      m_MediaMajorType = g.GetBSTR();
      m_MediaSubType = g.GetBSTR();
      m_MediaFormatType = g.GetBSTR();
    }
    virtual ~IComponentTypeImpl() {}
    STDMETHOD(get_Category)(/*[out, retval]*/ ComponentCategory *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ComponentCategory;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }
    STDMETHOD(put_Category)(/*[in]*/ ComponentCategory newVal) {
		ATL_LOCKT();
        m_ComponentCategory = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_MediaMajorType)(/*[out, retval]*/ BSTR *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_MediaMajorType.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

	STDMETHOD(get__MediaMajorType)(/*[out, retval]*/ GUID* pMediaMajorTypeGuid) {
        try {
            if (!pMediaMajorTypeGuid) {
                return E_POINTER;
            }
			ATL_LOCKT();
			GUID2 g(m_MediaMajorType);
            memcpy(pMediaMajorTypeGuid, &g, sizeof(GUID));
      		return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(put_MediaMajorType)(/*[in]*/ BSTR newVal) {
		try {
			GUID2 g(newVal);
			return put__MediaMajorType(g);
		} catch (ComException &e) {
			return e;
		} catch (...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }
    
    STDMETHOD(put__MediaMajorType)(/*[in]*/REFCLSID newVal) {
        try {
		    GUID2 g(newVal);
			ATL_LOCKT();
		    m_MediaMajorType = g.GetBSTR();
			MARK_DIRTY(T);
			return NOERROR;
		} catch(...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(get_MediaSubType)(/*[out, retval]*/ BSTR *pVal) {
        try {
            if (!pVal) {
				return E_POINTER;
            }
			ATL_LOCKT();
            return m_MediaSubType.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

	STDMETHOD(get__MediaSubType)(/*[out, retval]*/ GUID* pMediaSubTypeGuid) {
        try {
            if (!pMediaSubTypeGuid) {
                return E_POINTER;
            }
			ATL_LOCKT();
			GUID2 g(m_MediaSubType);
            memcpy(pMediaSubTypeGuid, &g, sizeof(GUID));
      		return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(put_MediaSubType)(/*[in]*/ BSTR newVal) {
        try {
			return put__MediaSubType(GUID2(newVal));
		} catch (ComException &e) {
			return e;
		} catch (...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(put__MediaSubType)(/*[in]*/ REFCLSID newVal) {
        try {
            GUID2 g(newVal);
			ATL_LOCKT();
			m_MediaSubType = g.GetBSTR();
			MARK_DIRTY(T);

			return NOERROR;
		} catch(...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(get_MediaFormatType)(/*[out, retval]*/ BSTR *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_MediaFormatType.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(get__MediaFormatType)(/*[out, retval]*/ GUID* pMediaFormatTypeGuid) {
        try {
            if (!pMediaFormatTypeGuid) {
                return E_POINTER;
            }
			ATL_LOCKT();
			GUID2 g(m_MediaFormatType);
            memcpy(pMediaFormatTypeGuid, &g, sizeof(GUID));
      		return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(put_MediaFormatType)(/*[in]*/ BSTR newVal) {  
        try {
            return put__MediaFormatType(GUID2(newVal));
		} catch (ComException &e) {
            return e;
		} catch (...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
   }
   STDMETHOD(put__MediaFormatType)(/*[in]*/ REFCLSID newVal) {
		try {
			GUID2 g(newVal);
			ATL_LOCKT();
			m_MediaFormatType =  g.GetBSTR();
			MARK_DIRTY(T);
			return NOERROR;
		} catch(...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(get_MediaType)(/*[out, retval]*/ AM_MEDIA_TYPE *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();

			pVal->majortype = GUID2(m_MediaMajorType);
			pVal->subtype = GUID2(m_MediaSubType);
			pVal->formattype = GUID2(m_MediaFormatType);

            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    }
    STDMETHOD(put_MediaType)(/*[in]*/ AM_MEDIA_TYPE *pnewVal) {
        try {
            if (!pnewVal) {
                return E_POINTER;
            }
			ATL_LOCKT();

			m_MediaMajorType = GUID2(pnewVal->majortype).GetBSTR();
			m_MediaSubType = GUID2(pnewVal->subtype).GetBSTR();
			m_MediaFormatType = GUID2(pnewVal->formattype).GetBSTR();

			MARK_DIRTY(T);
			return NOERROR;
        } catch (...) {
            return E_FAIL;
        }

    }

	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();

			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return ImplReportError(__uuidof(T), IDS_E_OUTOFMEMORY, __uuidof(IComponentType), E_OUTOFMEMORY);
			}
			pt->m_ComponentCategory = m_ComponentCategory;
   			pt->m_MediaMajorType = m_MediaMajorType;
			pt->m_MediaSubType = m_MediaSubType;
			pt->m_MediaFormatType = m_MediaFormatType;
			pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppCT = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // COMPONENTTYPEIMPL_H
// end of file -- componenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\componentimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Componentimpl.h : implementation helper template for component interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef COMPONENTIMPL_H
#define COMPONENTIMPL_H

#include "componenttype.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IComponent, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IComponentImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IComponent
public:
    PQComponentType m_Type;
    CComBSTR m_Desc;
    ComponentStatus m_ComponentStatus;
    long m_DescLangID;

    IComponentImpl() : m_ComponentStatus(StatusUnavailable), 
                       m_DescLangID(-1) {}
	virtual ~IComponentImpl() {}
    typedef IComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    BEGIN_PROP_MAP(thistype)
        PROP_DATA_QI_ENTRY("Type", m_Type.p, __uuidof(IComponentType))
        PROP_DATA_ENTRY("Description", m_Desc.m_str, VT_BSTR)
        PROP_DATA_ENTRY("DescLangID", m_DescLangID, VT_I4)
        PROP_DATA_ENTRY("Status", m_ComponentStatus, VT_I4)
    END_PROP_MAP()

// IComponent
public:
    STDMETHOD(get_Type)(/*[out, retval]*/ IComponentType** ppVal) {
        try {
            if (!ppVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_Type.CopyTo(ppVal);
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Type)(/*[in]*/ IComponentType*  pNewVal) {
		ATL_LOCKT();
        m_Type = pNewVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal) {
        try {
			ATL_LOCKT();
            return m_Desc.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Description)(/*[in]*/ BSTR newVal) {
        try {
			CHECKBSTRLIMIT(newVal);
			ATL_LOCKT();
            m_Desc = newVal;
            MARK_DIRTY(T);
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }
    STDMETHOD(get_DescLangID)(/*[out, retval]*/ long *pLangID) {
        try {
            if (!pLangID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLangID = m_DescLangID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_DescLangID)(/*[in]*/ long NewLangID) {
		ATL_LOCKT();
        m_DescLangID = NewLangID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Status)(/*[out, retval]*/ ComponentStatus *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ComponentStatus;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }
    STDMETHOD(put_Status)(/*[in]*/ ComponentStatus newVal) {
		ATL_LOCKT();
        m_ComponentStatus = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(Clone)(/*[out, retval]*/ IComponent **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
			if(m_Type){
              ASSERT(!pt->m_Type);
			  HRESULT hr = m_Type->Clone(&pt->m_Type);
			  if (FAILED(hr)) {
			    delete pt;
			    return hr;
			  }
			}
			pt->AddRef();
    	    pt->m_Desc = m_Desc.Copy();
        	pt->m_DescLangID = m_DescLangID;
	        pt->m_ComponentStatus = m_ComponentStatus;

			pt->m_bRequiresSave = true;

			*ppNew = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}

	    return NOERROR;
    }
};

}; // namespace

#endif // COMPONENTIMPL_H
// end of file -- componentimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\deviceeventimpl.h ===
// Copyright (c) 1999-2002  Microsoft Corporation.  All Rights Reserved.

#pragma once 

#ifndef _MSVIDDEVICEEVENT_H_
#define _MSVIDDEVICEEVENT_H_

template <class T, const IID* piid = &IID_IMSVidDeviceEvent, class CDV = CComDynamicUnkArray>
class CProxy_DeviceEvent : public IConnectionPointImpl<T, piid, CDV>
{
public:

    void Fire_VoidMethod(DISPID eventid) {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                HRESULT hr;
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                hr = pDispatch->Invoke(eventid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                if(FAILED(hr)){
                    TRACELSM(TRACE_ERROR, (dbgDump << "CProxy_DeviceEvent::Fire_VoidMethod() Eventid " << eventid << "Invoke " << nConnectionIndex << " failed hr = " << hexdump(hr)), "");
                }

            }
        }
    }

    void Fire_StateChange(IMSVidDevice *lpd, long oldState, long newState) 
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[3];
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {

                pvars[0] = lpd;
                pvars[1] = oldState;
                pvars[2] = newState;
                DISPPARAMS disp = { pvars, NULL, 3, 0 };
                pDispatch->Invoke(eventidStateChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
        }
        delete[] pvars;

    }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\ccimpl.h ===
//==========================================================================;
//
// closedcaptioningimpl.h : additional infrastructure to support implementing IMSVidClosedCaptionings
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef CLOSEDCAPTIONINGIMPL_H
#define CLOSEDCAPTIONINGIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidClosedCaptioning>
    class DECLSPEC_NOVTABLE IMSVidClosedCaptioningImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:

    IMSVidClosedCaptioningImpl() : m_fCCEnable(false) {}
    bool m_fCCEnable;

    STDMETHOD(put_Enable)(VARIANT_BOOL fEnable) {
        m_fCCEnable = (fEnable == VARIANT_TRUE);
		return NOERROR;
    }
    STDMETHOD(get_Enable)(VARIANT_BOOL *pfEnable) {
        if (!pfEnable) {
            return E_POINTER;
        }
        try {
            *pfEnable = m_fCCEnable ? VARIANT_TRUE : VARIANT_FALSE;
			return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
	}
};

}; /// namespace

#endif
// end of file - closedcaptioningimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\compimpl.h ===
//==========================================================================;
//
// compimpl.h : additional infrastructure to support implementing IMSVidCompositionSegment 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef COMPIMPL_H
#define COMPIMPL_H

#include <segimpl.h>

namespace MSVideoControl {

typedef CComQIPtr<IMSVidCompositionSegment, &__uuidof(IMSVidCompositionSegment)> PQCompositionSegment;

template<class T, class DerivedMost = IMSVidCompositionSegment> class DECLSPEC_NOVTABLE IMSVidCompositionSegmentImpl : 
    public IMSVidGraphSegmentImpl<T, MSVidSEG_XFORM, &GUID_NULL, DerivedMost> {
public:

    bool m_fComposed;
    VWSegmentList m_Segments;
    VWSegmentList::iterator m_pUp;
    VWSegmentList::iterator m_pDown;

    IMSVidCompositionSegmentImpl() : 
            m_fComposed(false), 
            m_Segments(VWSegmentList()),
            m_pUp(m_Segments.end()),
            m_pDown(m_Segments.end())
        {}

    virtual ~IMSVidCompositionSegmentImpl() {
        m_fComposed = false;
    }

    STDMETHOD(GetClassID) (LPCLSID guid) {
        try {
            memcpy(guid, &__uuidof(T), sizeof(CLSID));
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Up)(IMSVidGraphSegment **upstream)
	{
        if (!m_fComposed) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidCompositionSegment), CO_E_NOTINITIALIZED);
        }
        ASSERT(m_pGraph);
        try {
            return (*m_pUp).CopyTo(upstream);
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(get_Down)(IMSVidGraphSegment **downstream)
	{
        if (!m_fComposed) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidCompositionSegment), CO_E_NOTINITIALIZED);
        }
        ASSERT(m_pGraph);
        try {
            return (*m_pDown).CopyTo(downstream);
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

};

}; // namespace

#endif
// end of file compimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\devsegimpl.h ===
//==========================================================================;
//
// devsegimpl.h : additional infrastructure to support implementing device segments
// virtual base class used by devimpl and segimpl to store shared data
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DEVICESEGMENTIMPL_H
#define DEVICESEGMENTIMPL_H

#include <segment.h>
#include <seg.h>
#include <filterenum.h>
#include <errsupp.h>

#ifndef DECLSPEC_NOVTABLE
#define DECLSPEC_NOVTABLE __declspec(novtable)
#endif

namespace MSVideoControl {

class DECLSPEC_NOVTABLE CMSVidDeviceSegmentImpl {
public:
    bool m_fInit;
    VWSegmentContainer m_pContainer;
    DSGraph m_pGraph;
    DSFilterList m_Filters;
	DSFilterMoniker m_pDev;

    CMSVidDeviceSegmentImpl() : m_fInit(false), m_Filters(DSFilterList()) {}
    virtual ~CMSVidDeviceSegmentImpl() {
        m_pContainer.p = NULL;  // we didn't addref to avoid circular ref counts(we're guaranteed nested lifetimes) and
                                // we don't want to cause an unmatched release so manually clear the pointer
        
    }
};

}; // namespace

#endif 
// end of file - devsegimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\devimpl.h ===
//==========================================================================;
//
// devimpl.h : additional infrastructure to support implementing IMSVidDevice 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef DEVIMPL_H
#define DEVIMPL_H

#include "devsegimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidDevice>
    class DECLSPEC_NOVTABLE IMSVidDeviceImpl :         
    	public IDispatchImpl<MostDerivedInterface, &__uuidof(MostDerivedInterface), LibID>,
        public virtual CMSVidDeviceSegmentImpl {
public:
	    virtual ~IMSVidDeviceImpl() {}
    CComBSTR GetName(DSFilter& pF, DSFilterMoniker& pDev, CComBSTR& DefName) {
        if (pF) {
            CString csName(pF.GetName());
            if (!csName.IsEmpty()) {
                return CComBSTR(csName);
            }
        }
        if (pDev) {
            return pDev.GetName();
        }
        return DefName;
    }

	STDMETHOD(get_Status)(LONG * Status)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_Power)(VARIANT_BOOL * Status)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(put_Power)(VARIANT_BOOL Status)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }
		return E_NOTIMPL;
	}
	STDMETHOD(get_Category)(BSTR *guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            GUID2 g(Category);
            *guid = g.GetBSTR();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
	STDMETHOD(get__Category)(GUID* guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            memcpy(guid, Category, sizeof(GUID));
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

	STDMETHOD(get_ClassID)(BSTR *guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            GUID2 g(__uuidof(T));
            *guid = g.GetBSTR();
        } catch(...) {
            return E_UNEXPECTED;
        }

		return NOERROR;
	}
	STDMETHOD(get__ClassID)(GUID* guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            memcpy(guid, &__uuidof(T), sizeof(GUID));
        } catch(...) {
            return E_UNEXPECTED;
        }

		return NOERROR;
	}
    STDMETHOD(IsEqualDevice)(IMSVidDevice *pDev, VARIANT_BOOL* pfAnswer) {
        if (!pDev || !pfAnswer) {
            return E_POINTER;
        }
        try {
            *pfAnswer = VARIANT_FALSE;
            PUnknown pt(this);
            PUnknown pd(pDev);
            if (pt == pd) {
                *pfAnswer = VARIANT_TRUE;
                return NOERROR;
            }
            GUID2 gt, gd;
            HRESULT hr = get__ClassID(&gt);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            hr = pDev->get__ClassID(&gd);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            if (gd != gt) {
                return S_FALSE;
            }
            PQGraphSegment pst(this), pdt(pDev);
            PUnknown pit, pid;
            hr = pst->get_Init(&pit);
            if (FAILED(hr)) {
                pit.Release();
            }
            hr = pdt->get_Init(&pid);
            if (FAILED(hr)) {
                pid.Release();
            }
            if (pit == pid) {
                *pfAnswer = VARIANT_TRUE;
                return NOERROR;
            }   
            PQMoniker pmt(pit), pmd(pid);
            if (!pmt || !pmd) {
                // we don't know how to deal with init data that isn't a moniker
                return S_FALSE;
            }
            PQMalloc pmalloc;
            hr = CoGetMalloc(1, &pmalloc);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            LPOLESTR pnt, pnd;
            hr = pmt->GetDisplayName(NULL, NULL, &pnt);
            if (FAILED(hr)) {
                return S_FALSE;
            }
            hr = pmd->GetDisplayName(NULL, NULL, &pnd);
            if (FAILED(hr)) {
                pmalloc->Free(pnt);
                return S_FALSE;
            }
            int rc = wcscmp(pnt, pnd);
            pmalloc->Free(pnt);
            pmalloc->Free(pnd);
            if (rc) {
                return S_FALSE;
            }
            *pfAnswer = VARIANT_TRUE;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

};

}; // namespace

#endif
// end of file - devimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dsextend.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-2000.
//
//--------------------------------------------------------------------------;
//
// dsextend.cpp : implementation of various direct show extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "ksextend.h"
#include "dsextend.h"

const int MAX_OCCURRENCE_COUNT = 2;

static DWORD dwFetch;
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap
// and calling it in our dllmain.

// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = &std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = &std_arity0_member(&IEnumFilters::Reset);
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = &std_arity1_member(&IBaseFilter::EnumPins);
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = &std_arity0_member(&IEnumPins::Reset);
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = &std_arity0_member(&IEnumMoniker::Reset);
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = &std_arity1_member(&IPin::EnumMediaTypes);
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = &std_arity0_member(&IEnumMediaTypes::Reset);
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
#else
// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = NULL;
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = NULL;
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = NULL;

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = NULL;
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = NULL;
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = NULL;

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = NULL;
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = NULL;

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = NULL;
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = NULL;
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = NULL;
#endif


// work around compiler bug as per above description
void CtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    DSGraphContainer::Fetch = new std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
    DSGraphContainer::iterator::Reset = new std_arity0pmf<IEnumFilters, HRESULT>(&IEnumFilters::Reset);
    DSGraphContainer::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumFilters, ULONG, IBaseFilter**, ULONG *, HRESULT> >(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

    // DSFilter
    DSFilter::Fetch = new std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT>(&IBaseFilter::EnumPins);
    DSFilter::iterator::Reset = new std_arity0pmf<IEnumPins, HRESULT>(&IEnumPins::Reset);
    DSFilter::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumPins, ULONG, IPin **, ULONG *, HRESULT> >(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    DSDevices::iterator::Reset = new std_arity0pmf<IEnumMoniker, HRESULT>(&IEnumMoniker::Reset);
    DSDevices::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMoniker, ULONG, IMoniker **, ULONG *, HRESULT> >(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    DSPin::Fetch = new std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT>(&IPin::EnumMediaTypes);
    DSPin::iterator::Reset = new std_arity0pmf<IEnumMediaTypes, HRESULT>(&IEnumMediaTypes::Reset);
    DSPin::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMediaTypes, DWORD, AM_MEDIA_TYPE **, DWORD *, HRESULT> >(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
}

// work around compiler bug as per above description
void DtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    delete DSGraphContainer::Fetch;
    delete DSGraphContainer::iterator::Reset;
    delete DSGraphContainer::iterator::Next;

    // DSFilter
    delete DSFilter::Fetch;
    delete DSFilter::iterator::Reset;
    delete DSFilter::iterator::Next;

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    delete DSDevices::iterator::Reset;
    delete DSDevices::iterator::Next;

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    delete DSPin::Fetch;
    delete DSPin::iterator::Reset;
    delete DSPin::iterator::Next;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSGraph
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT DSGraph::Connect(DSFilter &pStart, DSFilter &pStop, DSFilterList &Added, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    ASSERT(pStop.GetGraph() == *this);
    try {
		DSFilterIDList AddedIDs;
        int origsize = Added.size();
        if (ConnectFilters(pStart, pStop, AddedIDs, dwFlags, pd)) {
			for (DSFilterIDList::iterator i = AddedIDs.begin(); i != AddedIDs.end(); ++i) {
				Added.push_back((*i).first);
			}
            return NOERROR;
        }
        ASSERT(!AddedIDs.size());
        ASSERT(Added.size() == origsize);
        return E_FAIL;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

bool DSGraph::Connect(DSFilter &pStart, DSFilterMoniker &pStop, DSFilter &pEndPointAdded, DSFilterList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    pEndPointAdded = AddMoniker(pStop);
    if (!pEndPointAdded) {
        return false;
    }
    ASSERT(pEndPointAdded.GetGraph() == *this);
    int origsize = IntermediatesAdded.size();
    if (SUCCEEDED(Connect(pStart, pEndPointAdded, IntermediatesAdded, dwFlags, pd))) {
        return true;
    }
    RemoveFilter(pEndPointAdded);
    pEndPointAdded.Release();
    ASSERT(IntermediatesAdded.size() == origsize);
    return false;
}


#ifdef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinDirect(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinDirect() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
			if (!DSPin(*i).GetConnection()) {
				HRESULT hr = pPin.Connect(*i, NULL);
				if (SUCCEEDED(hr)) {
					TRACEOUTDENT();
					TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinDirect() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinDirect() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinDirect() failed");
    return false;
}
#endif

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinByMedium(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    int cUseablePins = 0;
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMedium() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
            if (HasUnconnectedMedium(pPin, *i, cUseablePins)) {
                break;
            }
        }
        if (i != pFilter.end()) {
            HRESULT hr = pPin.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() can't connect pin " << pPin << " to " << *i), " with matching medium");
                return false;
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMedium() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() connect pin "), " THREWUP");
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinByMedium() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinByMedium() failed");
    return false;
}
#endif

// attempt to connect the given pin to the given filter by hunting for an indirection through
// another filter already in the graph
// then attempt to connect the new filter to the original destination
bool DSGraph::FindPinByMedium(DSPin &pPin1, DSFilter &pFDest, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() pPin1 = " << pPin1 << " pFDest = " << pFDest), "");
    KSMediumList ml;
    HRESULT hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() " << pPin1 << " has no mediums"), "");
        return false;
    }

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        // try all the direct connections
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() succeeded");
				return true;
			}
		}
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() can't connect pin to anything in graph");
    return false;
}

// we have already established that we can't connect directly or via other filters
// already in the graph so go hunt for a new filter to load
// if we fail we must leave the graph in its initial state
bool DSGraph::LoadPinByMedium(KSPinMedium &medium, DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    if (medium == NULL_MEDIUM || medium == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() NULL Medium, don't bother");
        // don't build an enumerator for a null medium or we will search through every
        // single filter on the system that doesn't have mediums
        return false;
    }
    try {
        TRACEINDENT();
        TRACELSM(TRACE_PAINT, (dbgDump << "medium = " << medium), "");
        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
                THROWCOM(E_UNEXPECTED);
        }


        bool fInReq = false, fOutReq = false;
        DSREGPINMEDIUM *pInMed = NULL, *pOutMed = NULL;

        switch (pd) {
        case PINDIR_INPUT:  // hunting through graph from right to left

#ifdef FILTERDATA
                    fOutReq = true;
                    pOutMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#else
            // NOTE: because of mediums get registered from the .inf with an
            // incomplete registry blob, filtermapper thinks that any pin with a
            // medium is an input pin and we use the low flag bit in the second
            // medium dword to solve this problem. == 1 for input == 0 for output
                    fInReq = true;
                    pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
            medium.Flags &= ~(KSMEDIUM_INPUTFLAG);
#endif
            break;
        case PINDIR_OUTPUT: // hunting through graph from left to right
            fInReq = true;
            pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#ifndef FILTERDATA
            medium.Flags |= KSMEDIUM_INPUTFLAG;
#endif
            break;
        }

        if (pInMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " " << (*pInMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " (NULL)"), "");
        }
        if (pOutMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " " << (*pOutMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " (Null)"), "");
        }
        // NOTE: since we're using mediums which are hw specific we include filters w/
        // MERIT_DO_NOT_USE since this is the default merit and most HW device filters
        // don't specify a merit.
        DSFilterMapper fmr(PQFilterMapper(*this),
                       0,
                       true,                                    // no wildcards
                       MERIT_DO_NOT_USE,                        // default merit for hw filters
                       fInReq,                                  // input required
                       0,
                       NULL,
                       pInMed,                                  // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       0,
                       NULL,
                       pOutMed,                                 // output medium
                       NULL                                     // output pin cat
                      );
        if (fmr) {
            // try all the direct connections
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() succeeded");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMedium(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMedium()");
    try {
        KSMediumList ml;
        HRESULT hr = pPin.GetMediums(ml);
        if (FAILED(hr) || !ml.size()) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMedium() " << pPin << " has no mediums"), "");
            return false;
        }
		for (KSMediumList::iterator i = ml.begin(); i != ml.end(); ++i) {
			if (LoadPinByMedium(KSPinMedium(*i), pPin, pRight, IntermediatesAdded, dwFlags)) {
				return true;
			}
		}
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMedium() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMedium() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we may have added and leave the graph in the
// state we started with.
bool DSGraph::ConnectPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DWORD dwFlags) {
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    try {
        TRACEINDENT();
        // try media types
		DSFilter::iterator i;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			if (HasUnconnectedMediaType(pPin1, *i, dwFlags)) {
				break;
			}
		}
        if (i != pFilter1.end()) {
            ASSERT(*this);
            ASSERT(pPin1.GetGraph() == *this);
            ASSERT((*i).GetGraph() == *this);
            HRESULT hr = pPin1.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) can't connect pin " << pPin1 << " to " << *i << " hr = " << hexdump(hr)), " with matching media type.");
#ifdef DEBUG
                if (dwTraceLevel >= TRACE_DETAIL) {
                    DumpHdr(dbgDump) << "pin1 " << pPin1.GetFilter() << " " << pPin1 << std::endl;
                    DumpHdr(dbgDump) << "pin2 " << (*i).GetFilter() << " " << *i << std::endl;
                    DumpMediaTypes(pPin1, *i);
                }
#endif
                if (!(dwFlags & IGNORE_MEDIATYPE_ERRORS)) {
                    THROWCOM(HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH));
                } else {
                    return false;
                }
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) connected " << pPin1.GetFilter() << " " << pPin1 << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED || h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) failed");

    return false;
}
#endif

bool DSGraph::FindPinByMediaType(DSPin &pPinLeft, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    ASSERT(pPinLeft.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() pPinLeft = " << pPinLeft << " filter = " << pRight), "");
    // possibly in the future we should find all of the possible choices and
    // use the shortest available path.  but for now, we're just going to
    // find the first one that exists
    try {
        TRACEINDENT();
		// NOTE: IFilterGraph::ConnectDirect() bumps the graph version number which invalidates
		// all the enumerators.  thus we'll run through and make a list of all the filters in the 
		// graph and then check them
		DSFilterList l;
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
			l.push_back(*i);
		}
		for (DSFilterList::iterator li = l.begin(); li != l.end(); ++li) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() succeeded");
				return true;
			}
		}
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() enumeration exhausted");
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() rethrowing E_UNEXPECTED");
			throw;
		}
		TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
    } catch(...) {
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() catch ...");
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMediaType(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMediaType() pPin = " << pPin.GetName() << " dwFlags = " << hexdump(dwFlags)), "");
    ASSERT(pPin.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
#ifdef DEBUG
    BEGIN_TRACEL(TRACE_DETAIL)
        if (pPin.begin() == pPin.end()) {
            dbgDump << "DSGraph::LoadPinByAnyMediaType() pin has no media types\r\n";
            dbgDump.flush();
        }
    END_TRACEL
#endif
    try {
		DWORD dwMerit = MERIT_NORMAL;
		if (dwFlags & ATTEMPT_MERIT_UNLIKELY) {
			dwMerit = MERIT_UNLIKELY;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_UNLIKELY");
		} else if (dwFlags & ATTEMPT_MERIT_DO_NOT_USE) {
			dwMerit = MERIT_DO_NOT_USE;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_DO_NOT_USE");
		}

		return LoadPinByMediaType(pPin, pRight, IntermediatesAdded, dwFlags, dwMerit);
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() failed");

    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsConnectable(DSPin &pPin1, DSFilter &pNew, DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, ConnectPred_t ConnPred) {
    ASSERT(pPin1 != NULL);
    ASSERT(pPin1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() pPin1 = " << pPin1 << " pNew = " << pNew << " pFDestination = " << pFDestination), "");
    try {
        PIN_INFO pinfo;
        HRESULT hr = pPin1->QueryPinInfo(&pinfo);
		if (FAILED(hr)) {
			THROWCOM(E_UNEXPECTED);
		}
        DSFilter Pin1Filter;
        Pin1Filter.p = pinfo.pFilter;  // transfer refcount ownership

        if (pNew && pNew != pFDestination && pNew != Pin1Filter) {
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() connpred == true");
                PIN_DIRECTION direction;
                hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsConnectable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
                if (ConnectFilters(pNew, pFDestination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() succeeded");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsConnectable() rethrowing E_UNEXPECTED");
			    pPin1.Disconnect();
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsConnectable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsLoadable(DSPin &pPin1, DSFilterMoniker &Mapper, DSFilter &Destination, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, ConnectPred_t ConnPred) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() pPin1 = " << pPin1 << " " << pPin1.GetFilter() << " Destination = " << Destination), "");
    ASSERT(pPin1.GetGraph() == *this);
    DSFilter pNew;
    try {
		DSFilterIDList::iterator i = IntermediatesAdded.size() ? (IntermediatesAdded.end() - 1) : IntermediatesAdded.end();

		if (i != IntermediatesAdded.end()) {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() checking duplicate moniker last = " << (*i).second << " new = " << Mapper.DisplayName()), "");
		} else {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() first moniker can't be dup(no check) new = " << Mapper.DisplayName()), "");
		}

		// undone: if the chains get longer we should use a map for this.  this may explain why perf
        // collapses as soon as we end up over on the audio side of things
		int occurrences = 0;
		CString newmkrname = Mapper.DisplayName();
		for (i = IntermediatesAdded.begin(); i != IntermediatesAdded.end(); ++i) {
			if ((!(*i).second.IsEmpty()) && 
				(newmkrname == (*i).second)) {
				   ++occurrences;
			}
		}
		if (occurrences > MAX_OCCURRENCE_COUNT) {
			TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::IsLoadable() max occurrence count exceeded for mkr = " << newmkrname), "");
			return false;
		}
        pNew = AddMoniker(Mapper);
        IntermediatesAdded.push_back(DSFilterID(pNew, Mapper.DisplayName()));
// ???? implement flag
        if (pNew) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() added moniker pNew = " << pNew), "");
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() connpred succeeded");
                PIN_DIRECTION direction;
                HRESULT hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsLoadable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
		        if (!pNew.PinCount(direction)) {
                    if (!(dwFlags & DONT_TERMINATE_ON_RENDERER)) {
                        TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() throwing ERROR_NO_MORE_ITEMS");
                        THROWCOM(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
                    }
		        }
                if (ConnectFilters(pNew, Destination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() succeeded.  pPin1 = " << pPin1 << " pNew = " << pNew << " Destination = " << Destination), "");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsLoadable() rethrowing");
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
				pPin1.Disconnect();
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
				IntermediatesAdded.pop_back();
				RemoveFilter(pNew);
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
	IntermediatesAdded.pop_back();
    if (pNew) {
        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
        RemoveFilter(pNew);
    }
    return false;
}

bool DSGraph::ConnectPin(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pin1dir) {
    // NOTE: this is where we enforce the desired directional assymetry.  from now on through the call tree
    // we can assume that pin1 is already the desired directional type. and we only have to check
    // pin2 at the end in hasunconnectedxxxx()
    // this ensures that all of our connection paths are unidirectional through the graph. in other words,
    // make sure that we don't go downstream then back upstream or vice versa.
    // this allows all of our connection routines to be useable from either direction
    // since there are times when we have an input side starting point and other times the opposite
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1 = " << pPin1 << " " << pPin1.GetFilter() << " to " << pFilter1), "");
	TRACEINDENT();
    PIN_DIRECTION pd;

    HRESULT hr = pPin1->QueryDirection(&pd);
    if (pd != pin1dir) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() wrong dir");
        return false;
    }

	if (!(dwFlags & RENDER_ALL_PINS) &&  !pPin1.IsRenderable()) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() non-renderable");
		return false;
	}

    // make sure we're not trying to connect a filter to itself
    PIN_INFO pinfo;
    DSFilter PinFilter;
    hr = pPin1->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
		TRACEOUTDENT();
        TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() can't get pin info");
        THROWCOM(E_UNEXPECTED);
    }
    PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    if (PinFilter == pFilter1) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() can't connect filter to itself");
        return false;
    }

    DSPin pConn = pPin1.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1  = " << pPin1 << " connected, tracing through to next filter = " << pConn.GetFilter()), "");
        // a connected output pin should be traced through the next filter
        DSFilter pNext = pConn.GetFilter();
        if (!pNext) {
			TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() pNext has no filter");
            THROWCOM(E_UNEXPECTED);
        }
        if (pNext != pFilter1) {
	        bool rc = ConnectFilters(pNext, pFilter1, IntermediatesAdded, dwFlags, pin1dir);
			TRACEOUTDENT();
			return rc;
		} else {
			TRACEOUTDENT();
			TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pNext == pFilter1");
			return true;
		}
    }

#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by returning, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pin free");
	PIN_DIRECTION pd2;
	pd2 = OppositeDirection(pd);
	if (!pFilter1.HasFreePins(pd2)) {
		TRACEOUTDENT();
		TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has no free pins");
		return false;
	}
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has free pins");
#endif

    try {
#ifdef ATTEMPT_DIRECT_CONNECT
        if (ConnectPinDirect(pPin1, pFilter1) ||     // can these connect direct
#else
        if (ConnectPinByMedium(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||     // any paths in graph
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags))    ||     // any filters in system
#ifndef ATTEMPT_DIRECT_CONNECT
			ConnectPinByMediaType(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags))) {
			TRACEOUTDENT();
            TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() succeeded");
            return true;
        }
        TRACEOUTDENT(); // to avoid outdenting too far in a catch case
    } catch (ComException &h) {
		TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPin() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPin() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch (...) {
		TRACEOUTDENT();
    }

	//TRACEOUTDENT();
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() failed");
    return false;
}

// attempt to disconnect this pin
bool DSGraph::DisconnectPin(DSPin &pPin, const bool fRecurseInputs, const bool fRecurseOutputs) {
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin()");

    PIN_DIRECTION pd;
    HRESULT hr = pPin->QueryDirection(&pd);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() can't get direction");
        THROWCOM(E_UNEXPECTED);
    }

    DSPin pConnection = pPin.GetConnection();
    if (!pConnection) {
        return false;
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::DisconnectPin() disconnecting " << pPin << " from " << pConnection), "");
    pPin.Disconnect();
    DSFilter pNext = pConnection.GetFilter();
    if (!pNext) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() pConnection has no filter");
        THROWCOM(E_UNEXPECTED);
    }

    switch (pd) {
    case PINDIR_INPUT:
        if (fRecurseInputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  fRecurseInputs,
                                  false));  // we moving inputward, don't backtrack
#endif
		    for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, fRecurseInputs, false);
			}
        }
        break;
    case PINDIR_OUTPUT:
        if (fRecurseOutputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  false,
                                  fRecurseOutputs));
#endif
			for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, false, fRecurseOutputs);
			}
        }
        break;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin() succeeded");
    return true;
}

// attempt to connect this from the graph
bool DSGraph::DisconnectFilter(DSFilter &pFilter, const bool fRecurseInputs, const bool fRecurseOutputs) {
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectFilter() can't disconnect NULL filter");
        return FALSE;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectFilter()");
    for (DSFilter::iterator i = pFilter.begin(); i != pFilter.end(); ++i) {
        DisconnectPin(*i, fRecurseInputs, fRecurseOutputs);
    }

    return true;
}


bool DSGraph::RemoveFilter(DSFilter &pFilter) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::RemoveFilter() removing " << pFilter), "");
    if (!pFilter) return false;

    DisconnectFilter(pFilter, false, false);

    HRESULT hr = (*this)->RemoveFilter(pFilter);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::RemoveFilter() can't remove filter");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::RemoveFilter() complete");

    return true;
}

// pin matches medium
// requires an exact match, won't treat GUID_NULL as wildcard and treats 'host memory' as unmatchable
bool DSGraph::HasMedium(const KSPinMedium &Medium1, const DSPin &pPin2) const {
    DSPin junk(pPin2);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMedium() medium1 = " << Medium1 << " pPin2 = " << junk), "");
    if (Medium1 == NULL_MEDIUM || Medium1 == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() medium1 == NULL");
        return false;
    }
    KSMediumList ml;

    HRESULT hr = pPin2.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        return false;
    }
#if 0
    KSMediumList::iterator i = std::find_if(ml.begin(),
                                       ml.end(),
                                       std::bind2nd(std::equal_to<KSPinMedium>(), Medium1));
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
        return true;
    }
#endif
	KSMediumList::iterator i;
	for (i = ml.begin(); i != ml.end(); ++i) {
		if (*i == Medium1) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
			return true;
		}
	}

    TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() no match");

    return false;
}

bool DSGraph::HasMediaType(const DSMediaType &LeftMedia, const DSPin &pPinRight) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() LeftMedia = " << LeftMedia << " LeftMedia.p " << LeftMedia.p << " pPinRight = " << pPinRight), "");

    if (pPinRight.IsKsProxied()) {
#if 0
        DSPin::iterator i = std::find_if(pPinRight.begin(),
                                         pPinRight.end(),
                                         std::bind2nd(std::equal_to<DSMediaType>(),
                                         LeftMedia) );
        if (i != pPinRight.end()) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
#endif
		DSPin::iterator i;
		for (i = pPinRight.begin(); i != pPinRight.end(); ++i) {
            // NOTE: DSMediaType operator== enables wildcard matches
			if (*i == LeftMedia) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
				return true;
			}
		}
    } else {
        HRESULT hr = pPinRight->QueryAccept(LeftMedia);
        if (SUCCEEDED(hr) && hr != S_FALSE) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() query accept refused hr = " << hexdump(hr)), "");
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// pin is unconnected, opposite direction, and has at least 1 matching medium
// requires an exact match, won't treat GUID_NULL as wildcard
bool DSGraph::HasUnconnectedMedium(const DSPin &pPin1, const DSPin &pPin2, int& cUseable) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMedium() pin1 = " << pPin1 << " pin2 = " << pPin2), "");
    PIN_DIRECTION pd1, pd2;
    HRESULT hr = pPin1->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin1 direction");
        return false;
    }
    hr = pPin2->QueryDirection(&pd2);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin2 direction");
        return false;
    }
    if (pd1 == pd2) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() can't connect two pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() checking connection status");

    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMedium() pPin2 = " << pPin2 << " already connected"), "");
        return false;
    }
    ++cUseable;

    KSMediumList ml;
    hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pin has no mediums");
        return false;
    }
    KSMediumList::iterator i;
    for (i = ml.begin(); i != ml.end(); ++i) {
        if (HasMedium(*i, pPin2)) {
            break;
        }
    }
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() succeeded");
        return true;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pPin2 has no matching medium");
    return false;
}

// pin is unconnected, opposite direction,  and there is at least 1 matching media type
bool DSGraph::HasUnconnectedMediaType(const DSPin &pPin1, const DSPin &pPin2, DWORD dwFlags) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMediaType() pPin1 = " << pPin1 << " pPin2 = " << pPin2), "");
    if (pPin1.GetDirection() == pPin2.GetDirection()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() cant connect 2 pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMediaType() pPin2 connected to " << pConn), "");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() finding");
    // pin right isn't connected to anything so hunt for a
    // compatible media type
	for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
		if (HasMediaType(*i, pPin2)) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded forward");
			return true;
		}
	}
    if (dwFlags & BIDIRECTIONAL_MEDIATYPE_MATCHING) {
	    for (DSPin::iterator i = pPin2.begin(); i != pPin2.end(); ++i) {
		    if (HasMediaType(*i, pPin1)) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded backward(bidi)");
			    return true;
		    }
	    }
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() no matching media types");
    return false;
}
#endif

// we are checking to see if pPin1 is connected(possibly indirectly) to pFDestionation by traveling in destdir direction through
// the graph
bool DSGraph::IsPinConnected(const DSPin &pPin1, const DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, PIN_DIRECTION destdir) const {
    PIN_DIRECTION direction;
    HRESULT hr = pPin1->QueryDirection(&direction);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::IsPinConnected() can't query direction");
        THROWCOM(E_UNEXPECTED);
    }
    if (direction != destdir) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() wrong direction");
        return false;
    }
    DSPin pConn = pPin1.GetConnection();
        if (!pConn) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to anything");
        return false;
        }
    PIN_INFO pinfo;
    DSFilter PinFilter;
    if (pConn) {
        hr = pConn->QueryPinInfo(&pinfo);
        PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    }
    if (PinFilter == pFDestination) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() directly true");
        return true;
    }
#if 0
#if CRASH
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bind_const_obj_2_3_4(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#else
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#endif
    if (i != PinFilter.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
        return true;
    }
#endif
	for (DSFilter::iterator i = PinFilter.begin(); i != PinFilter.end(); ++i) {
		if (IsPinConnected(*i, pFDestination, IntermediatesAdded, destdir)) {
			TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
			return true;
		}
	}
    TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to desired dest");
    return false;
}


#if 0
DSFilter DSGraph::LoadFilter(const PQMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    csName = _T("");
    PQFilter pFilter;
    PQPropertyBag pPropBag;
    HRESULT hr = (pM)->BindToStorage(0, 0, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pPropBag));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to storage");
        THROWCOM(hr);
    }
    CComVariant vName;
    vName.vt = VT_BSTR;
    hr = pPropBag->Read(L"FriendlyName", &vName, NULL);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't read friendly name");
        THROWCOM(hr);
    }
    USES_CONVERSION;
    BSTR p = vName.bstrVal;
    csName = OLE2T(p);
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter() have propbag");
    hr = (pM)->BindToObject(0, 0, IID_IBaseFilter, reinterpret_cast<LPVOID *>(&pFilter));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to object");
        THROWCOM(hr);
    }
    return pFilter;
}
#else
DSFilter DSGraph::LoadFilter(const DSFilterMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    CComBSTR p(pM.GetName());
        if (p) {
                USES_CONVERSION;
                csName = OLE2T(p);
        }
    return pM.GetFilter();
}
#endif

DSFilter DSGraph::AddMoniker(const DSFilterMoniker &pM) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker()");
    CString csName;

    DSFilter pFilter = LoadFilter(pM, csName);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddMoniker() can't load filter");
        return pFilter;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker() have pFilter");
    USES_CONVERSION;
    HRESULT hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddMoniker() can't add filter " << csName << " to graph"), "");
        return DSFilter();
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddMoniker() added " << csName), "");

    return pFilter;
}

HRESULT DSGraph::AddFilter(DSFilter &pFilter, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    USES_CONVERSION;
    hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return hr;
}

DSFilter DSGraph::AddFilter(const CLSID &cls, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    DSFilter pFilter(cls, NULL, CLSCTX_INPROC_SERVER);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddFilter() can't create filter");
        return pFilter;
    }
    hr = AddFilter(pFilter, csName);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
        THROWCOM(hr);
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return pFilter;
}

// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we've added and leave the graph in the
// state we started with.
// only look at pFilter1 pins of pFilter1Direction
bool DSGraph::ConnectFilters(DSFilter &pFilter1, DSFilter &pFilter2, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, PIN_DIRECTION pFilter1Direction) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    if (pFilter1 == pFilter2) {
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters same filter");
        return false;
    }
    try {
        TRACEINDENT();
		// undone: there should be some way to preserve the info
		// from the following check to speed up the actual connection in the event
		// that they aren't already connected.

        // see if these filters are already connected
		DSFilter::iterator i;
		if (!(dwFlags & IGNORE_EXISTING_CONNECTIONS)) {
#if 0
#if CRASH
			i = std::find_if(pFilter1.begin(),
 							 pFilter1.end(),
 							 bind_obj_2_3_4(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#else
			i = std::find_if(pFilter1.begin(),
							 pFilter1.end(),
							 bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#endif
			if (i != pFilter1.end()) {
				TRACEOUTDENT();
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
				return true;
			}
#endif
			for (DSFilter::iterator i = pFilter1.begin(); i != pFilter1.end(); ++i) {
				if (IsPinConnected(*i, pFilter2, IntermediatesAdded, pFilter1Direction)) {
					TRACEOUTDENT();
					TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
					return true;
				}
			}
		}

        // they're not connected so see if we can connect them
        // connect every possible pin available and keep track of how many we connect
        int cConnected = 0;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			try {
				if (ConnectPin(DSPin(*i), pFilter2, IntermediatesAdded, dwFlags, pFilter1Direction)) {
					TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() pin connected");
					cConnected++;
				}
			} catch(ComException &h) {
				if (h != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
					try {
						TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() rethrowing");
					} catch(...) {
					}
					throw;
				}
			}
		}
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() cConnected = " << cConnected), "");
        if (cConnected) {
            TRACEOUTDENT();// just inside try
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() succeeded pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
            return true;    // we connected at least one pin
        }
        TRACEOUTDENT();// just inside try
	} catch (ComException &h) {
        TRACEOUTDENT();// just inside try
		if (h == E_UNEXPECTED) {
			throw;
		}
    } catch (...) {
        TRACEOUTDENT();  // just inside try
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() catch...");
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() failed pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    return false;
}

// this function returns a list of pairs of input and output points
// that must be connected to activate the shortest path between two filters
// it returns the number of connections in the path.
// i.e if start is adjacent to stop then rc is 1. if a single filter is between them then 2, etc.
// 0 indicates no path found.
int DSGraph::BuildGraphPath(const DSFilter& pStart,
                            const DSFilter& pStop,
                            VWStream &path,
                            MediaMajorTypeList& MediaTypes,
                            PIN_DIRECTION direction,
                            const DSPin &InitialInput)
{
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() start = " << pStart << " stop = " << pStop), "");
    int pathlen = INT_MAX;
    VWStream returnpath;
    ASSERT(InitialInput || (!InitialInput && !pStart.IsXBar())); // first time in can't be an xbar unless original caller establishes InitialInput
    for (DSFilter::iterator i = pStart.begin(); i != pStart.end(); ++i) {
        DSPin pPin1(*i);
        if (pPin1.GetDirection() != direction) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " wrong direction"), "");
            continue;  // search forward
        }
        DSPin pConnection = pPin1.GetConnection();
        if (!pConnection) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " unconnected"), "");
            continue;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() checking " << pPin1 << " connected to " << pConnection.GetFilter() << " " << pConnection), "");
        if (InitialInput) {
            ASSERT(pPin1 != InitialInput);  // direction check should already have filtered for this

            DSMediaType amt(pPin1.GetConnectionMediaType());
            ASSERT(amt);
            if (amt->pUnk) {
                amt->pUnk->Release();
            }

            MediaMajorTypeList::iterator l;
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() searching for " << GUID2(amt.p->majortype)), "");
            l = std::find(MediaTypes.begin(), MediaTypes.end(), amt.p->majortype);
            if (l == MediaTypes.end()) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "major media type not matched"), "");
                continue;
            }

            if (!pPin1.CanRoute(InitialInput)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ",  " << InitialInput << " Can't Route to " << pPin1), "");
                continue;
            }
        }

        DSFilter nextFilter = pConnection.GetFilter();
        ASSERT(nextFilter);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() nextFilter = " << nextFilter), "");

        if (nextFilter == pStop) {
            TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() found stop filter"), "");
            // we found the destination, we're done with this one
                        if (pStart.IsXBar()) {
                // if we started on xbar then connected pin's outputpoint pairs with the
                // initialinput(&pin) to form the first pair in the return path
                    TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                ASSERT(DSXBarPin(InitialInput));
                PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                ASSERT(!!p1);

                ASSERT(DSXBarPin(pPin1));
                PQPoint p2(DSXBarPin(pPin1).GetPoint());
                ASSERT(!!p2);

                switch (direction) {
                case DOWNSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                    returnpath.push_back(CIOPoint(p1, p2));
                    break;
                case UPSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                    returnpath.push_back(CIOPoint(p2, p1));
                    break;
                }
                        }
            pathlen = 1;
            break;
        } else {
            VWStream temp;
            int rc = BuildGraphPath(nextFilter, pStop, temp, MediaTypes, direction, pConnection);
            // undone: in win64 size() is really __int64.  fix output operator for
            // that type and remove cast

            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() recursed buildgraphpath returned rc = " << rc << " pathlen = " << pathlen << "sz = " << (long)temp.size()), "");

            // if we found a path and the new one is shorter then the current one
            if (rc && ((rc + 1) < pathlen)) {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() accepting new path");
                // save the new path
                pathlen = rc + 1;
                returnpath.clear();
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() checking xbar adjacency");
                if (pStart.IsXBar()) {
                                        // if we started on xbar then connected pin's outputpoint pairs with the
                                        // initialinput(&pin) to form the next pair in the return path
                        TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                    ASSERT(DSXBarPin(InitialInput));
                    PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                    ASSERT(!!p1);

                    ASSERT(DSXBarPin(pPin1));
                    PQPoint p2(DSXBarPin(pPin1).GetPoint());
                    ASSERT(!!p2);

                    switch (direction) {
                    case DOWNSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                        returnpath.push_back(CIOPoint(p1, p2));
                        break;
                    case UPSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                        returnpath.push_back(CIOPoint(p2, p1));
                        break;
                    }
                }
                                // append onto path any further downstream xbars found by recursion
                returnpath.splice(returnpath.end(), temp);
            } else {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() discarding new path");
                // keep the old return path and cleanup the temp one we just got back
                temp.clear();
            }
        }
    }
    if (pathlen == INT_MAX) {  // didn't find anything
                return 0;
    }
    path = returnpath;
    return pathlen;
}

HRESULT DSGraph::AddToROT(DWORD *pdwObjectRegistration) {
    PQMoniker pGraphMK;
    PQROT pROT;
    if (FAILED(::GetRunningObjectTable(0, &pROT))) {
        return E_UNEXPECTED;
    }
    OLECHAR osz[256];
    // undone: in the ia64 case the following format spec isn't enough digits for an address
    //wsprintfW(osz, OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    HRESULT hr = StringCchPrintfW(osz, sizeof(osz) / sizeof(osz[0]), OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    if(FAILED(hr)){
        ASSERT(false);
    }
    hr = ::CreateItemMoniker(OLESTR("!"), osz, &pGraphMK);
    if (SUCCEEDED(hr)) {
        hr = pROT->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, *this, pGraphMK, pdwObjectRegistration);
    }
    return hr;
}

void DSGraph::RemoveFromROT(DWORD dwObjectRegistration) {
   PQROT pROT;
   if (SUCCEEDED(::GetRunningObjectTable(0, &pROT))) {
       pROT->Revoke(dwObjectRegistration);
   }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////

DSGraph DSFilter::GetGraph(void) {
    FILTER_INFO finfo;
    HRESULT hr = (*this)->QueryFilterInfo(&finfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSFilter::GetGraph() failed");
        return DSGraph();
    }
    DSGraph graph = finfo.pGraph;
    if (finfo.pGraph) finfo.pGraph->Release(); // transfer ref count
    return graph;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////
CString DSFilter::GetName(void) const {
    CString csName;
    FILTER_INFO finfo;
    if (*this) {
        HRESULT hr = (*this)->QueryFilterInfo(&finfo);
        if (SUCCEEDED(hr)) {
            csName = finfo.achName;
            if (csName.IsEmpty()) {
                csName = _T("");
            }
            if (finfo.pGraph) {
                finfo.pGraph->Release();
            }
        } else {
#ifdef _DEBUG
            csName = _T("**** UNKNOWN FILTER NAME ****");
#endif
        }
    } else {
#ifdef _DEBUG
        csName = _T("**** NULL FILTER POINTER ****");
#endif
    }
    return csName;
}

void DSFilter::GetPinCounts(ULONG &ulIn, ULONG &ulOut) const
{
    HRESULT hr;
    ulIn = ulOut = 0;
    PIN_DIRECTION pd;
    DSFilter::iterator i;
    for (i = begin(); i != end(); ++i) {
        hr = (*i)->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSFilter:GetPinCounts() can't query pin direction hr = " << hr), "");
            THROWCOM(E_UNEXPECTED);
        }
        switch (pd) {
        case PINDIR_INPUT:
            ulIn++;
            break;
        case PINDIR_OUTPUT:
            ulOut++;
            break;
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSPin
///////////////////////////////////////////////////////////////////////////////////////////////

bool DSPin::HasCategory(const GUID2 &clsCategory, const PIN_DIRECTION pd) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::IsPinCategory() pin = " << this), "");
    PIN_DIRECTION pd1;
    HRESULT hr = (*this)->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPIN::IsPinCategeory() cant query Pin direction");
        return false;
    }
    if (pd1 != pd) {
        TRACELM(TRACE_ERROR, "DSPin::IsPinCategeory() wrong direction");
        return false;
    }
    GUID2 pincat2;
    GetCategory(pincat2);
    return clsCategory == pincat2;
}

HRESULT DSPin::Connect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType) {
    DSGraph pGraph = GetGraph();
    DSGraph pConnGraph = ConnectTo.GetGraph();
    ASSERT(pGraph);
    ASSERT(pConnGraph);
    ASSERT(pGraph == pConnGraph);
    if (!pGraph || !pConnGraph || pGraph != pConnGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() pins not in same graph");
        THROWCOM(E_FAIL);
    }
	if (GetDirection() == PINDIR_OUTPUT) {
	    return pGraph->ConnectDirect(*this, ConnectTo, pMediaType);
	} else {
	    return pGraph->ConnectDirect(ConnectTo, *this, pMediaType);
	}
}

HRESULT DSPin::Disconnect(void) {
    DSPin ConnectedTo;
    HRESULT hr = (*this)->ConnectedTo(&ConnectedTo);
    if (FAILED(hr) || !ConnectedTo) {
        return NOERROR;  // not connected to anything
    }
    PIN_INFO pinfo;
    hr = (*this)->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() can't call QueryPinInfo");
        THROWCOM(E_UNEXPECTED);
    }
    DSFilter PinFilter;
    PinFilter.p = pinfo.pFilter;  // directly transfer ownership of ref count
    DSGraph pGraph = PinFilter.GetGraph();
    if (!pGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Disconnect() can't get graph from PinFilter");
        THROWCOM(E_UNEXPECTED);
    }
    hr = pGraph->Disconnect(ConnectedTo);
    if (FAILED(hr)) {
        return hr;
    }
    return pGraph->Disconnect(*this);
}

// for any pin to possibly route they must be on the same filter and different directions
bool DSPin::Routable(const DSPin pin2) const {
    if (GetFilter() != pin2.GetFilter()) {
        return false;
    }
    if (GetDirection() == pin2.GetDirection()) {
        return false;
    }
    return true;
}

bool DSPin::CanRoute(const DSPin pin2) const {
        ASSERT(GetFilter() == pin2.GetFilter());
    PQCrossbarSwitch px1(GetFilter());
    if (!px1) {
        return Routable(pin2);
    }

    return DSXBarPin(*this).CanRoute(DSXBarPin(pin2));
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSXBarPin
///////////////////////////////////////////////////////////////////////////////////////////////
#if 0
const DSXBarPin DSXBarPin::Find(const CPinPoints &pinpoints, const PQPoint &point, PIN_DIRECTION pindir) {
    CPinPoints::const_iterator i;
    TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() finding " << point << " direction = " << pindir), "");
    for (i = pinpoints.begin(); i != pinpoints.end(); ++i) {
        TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() checking " << DSPin((*i).first) << " direction " << DSPin((*i).first).GetDirection() << " " << (*i).second), "");
        if ((*i).second == point && DSPin((*i).first).GetDirection() == pindir) {
            DSPin p((*i).first);
            PQCrossbarSwitch px1(p.GetFilter());
            if (!px1) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Find() not an xbar " << p), "");
                THROWCOM(E_FAIL);
            }
            TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() found " << p), "");
            return DSXBarPin(p);
        }
    }
    THROWCOM(E_FAIL);
    return DSXBarPin();
}
#endif
// undone: cache this lookup
const PQPoint DSXBarPin::GetPoint() const {
    DSFilter f= GetFilter();
    PQCrossbarSwitch px(f);
    if (!px) {
        TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Pin2Point() not an xbar" << *this), "");
        THROWCOM(E_INVALIDARG);
    }

    PIN_DIRECTION dir = GetDirection();
    long idx = 0;
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end() && *i != *this; ++i) {
        if ((*i).GetDirection() == dir) {  // output idx's start over at 0
            ++idx;
        }
    }

    if (i != f.end()) {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() " << *this << " pt = " << idx), "");
        return PQPoint(px, idx);
    } else {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() No Point"), "");
        return PQPoint();
    }
}

bool DSXBarPin::CanRoute(const DSXBarPin pin2) const {
    if (!Routable(pin2)) {
        // pins not on same filter or both pins same direction
        return false;
    }
    PQPoint pt1(GetPoint());
    if (!pt1.first) {
        // not on xbar or something corrupt
        return false;
    }
    PQPoint pt2(pin2.GetPoint());
    if (!pt2.first) {
        // not on xbar or something corrupt
        return false;
    }
    ASSERT(pt1.first == pt2.first);  // must be on same xbar

    HRESULT hr = E_FAIL;
    switch(GetDirection()) {
    case PINDIR_INPUT:
        hr = (pt1.first)->CanRoute(pt2.second, pt1.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() in 2.sec " << pt2.second << " 1.sec " << pt1.second << " hr = " << hr), "");
        break;
    case PINDIR_OUTPUT:
        hr = (pt1.first)->CanRoute(pt1.second, pt2.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() out 1.sec " << pt1.second << " 2.sec " << pt2.second << " hr = " << hr), "");
        break;
    }
    return hr == S_OK;
}

void VWStream::Route() {
    for (iterator i = begin(); i != end(); ++i) {
        CIOPoint p(*i);
        ASSERT(p.first.first == p.second.first);
        PQCrossbarSwitch px(p.first.first);
        HRESULT hr = px->Route(p.second.second, p.first.second);
        ASSERT(SUCCEEDED(hr));
                TRACELSM(TRACE_DETAIL, (dbgDump << "VWStream::Route() hr = " << hr << " px = " << px << " P.2.2 = " << p.second.second << " p.1.2 " << p.first.second), "");
    }
}

bool IsVideoFilter(const DSFilter& f) {
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end(); ++i) {
        if (IsVideoPin(*i)) {
            return true;
        }
    }
    return false;
}

bool IsVideoPin(const DSPin& p) {
    DSPin::iterator i;
    for (i = p.begin(); i != p.end(); ++i) {
        if (IsVideoMediaType(*i)) {
            return true;
        }
    }
    return false;
}

#if 0
// disable until we have pinpoints cache
void DSXBarPin::GetRelations(const CPinPoints &pinpoints, CString &csName, CString &csType, CString &csRelName) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar pin " << *this), "");
    CString csw;

    DSFilter f = GetFilter();
    PQCrossbarSwitch xbar(f);
    if (!xbar) {
        THROWCOM(E_FAIL);
    }
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar filter" << f), "");
    long rel, phys;
    HRESULT hr = xbar->get_CrossbarPinInfo(IsInput(), Pin2Point(pinpoints).second, &rel, &phys);
    if (FAILED(hr)) {
        THROWCOM(hr);
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  have xbar info.  pin = " << (*this) << " rel = " << rel << " phys = " << phys), "");

    TCHAR tphys[256];
    _ltot(phys, tphys, 10);

    csName = GetName();
    csType = tphys;

    ULONG inc, outc;
    f.GetPinCounts(inc, outc);
    long pincount = inc + outc;
    if (rel >= 0 && rel < pincount) {
        DSXBarPin RelPin(Find(pinpoints, PQPoint(xbar, rel), (*this).GetDirection()));
        if (!RelPin) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  can't build relpin.  rel = " << rel), "");
        } else {
            csRelName = RelPin.GetName();
        }
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  Name " << csName << " Type " << csType << " RelName " << csRelName), "");

    return;
}
#endif

#ifdef _DEBUG
void DumpMediaTypes(DSPin &p1, DSPin &p2) {
    DSPin::iterator i;
    DumpHdr(dbgDump) << "DumpMediaTypes(): " << std::endl;
    TRACEINDENT();
    for (i = p1.begin(); i != p1.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p2->QueryAccept(*i)) << std::endl;
    }
    DumpHdr(dbgDump) << "----" << std::endl;
    for (i = p2.begin(); i != p2.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p1->QueryAccept(*i)) << std::endl;
    }
    TRACEOUTDENT();
    dbgDump.flush();
}
#endif

#pragma optimize("a", off)

bool DSGraph::LoadPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, const DWORD dwMerit) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);

    GUID2* pInMedia = NULL;
    GUID2* pOutMedia = NULL;

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
            THROWCOM(E_UNEXPECTED);
        }
		PIN_DIRECTION pd2;
		switch (pd) {
		case PINDIR_INPUT:
			pd2 = PINDIR_OUTPUT;
			break;
		case PINDIR_OUTPUT:
			pd2 = PINDIR_INPUT;
			break;
		}

        bool fInReq = false, fOutReq = false;
        DWORD dwIn = 0;
        DWORD dwOut = 0;
        GUID2** ppMediaList = NULL;
        DWORD dwMediaCount = 0;

        for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
            ++dwMediaCount;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pindir = " << pd << " mediacount = " << dwMediaCount), "");

        switch (pd) {
        case PINDIR_INPUT:
            // hunting through graph from right to left
            fOutReq = true;
            dwOut = dwMediaCount;
            pOutMedia = new GUID2[dwOut * 2];
            ppMediaList = &pOutMedia;
            break;
        case PINDIR_OUTPUT:
            // hunting through graph from left to right
            fInReq = true;
            dwIn = dwMediaCount;
            pInMedia = new GUID2[dwIn * 2];
            ppMediaList = &pInMedia;

            break;
        }
        DWORD idx = 0;
        // note: some buggy filters don't support the reuse of an IEnumMediaTypes even though
        // reset succeeds.  they AV during the next pass through the enumerator.  thus, we
        // just create a new iterator which fetches a new IEnumMediaTypes interface(and underlying object)
        for (DSPin::iterator i2 = pPin1.begin(); i2 != pPin1.end(); ++i2) {
            (*ppMediaList)[idx++] = (*i2)->majortype;
            (*ppMediaList)[idx++] =  (*i2)->subtype;
        }

        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMediaType()  dwFlags = " << hexdump(dwFlags) << " Merit = " << hexdump(dwMerit) << " MediaList = ");
        TRACEINDENT();
        for (idx = 0; idx < dwMediaCount; ++idx) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "major = " << (*ppMediaList)[idx * 2] << " sub = " << (*ppMediaList)[(idx * 2) + 1] ), "");
        }
        TRACEOUTDENT();

        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fInReq = " << fInReq), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fOutReq = " << fOutReq), "");

                // try normal first
        {DSFilterMapper fmr(PQFilterMapper(*this),
                       0,										// 0 flags
                       !(dwFlags & ALLOW_WILDCARDS),			// bExactMatch
                       dwMerit,						            // merit
                       fInReq,                                  // input required
                       dwIn,
                       pInMedia,
                       NULL,                                    // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       dwOut,
                       pOutMedia,
                       NULL,                                    // output medium
                       NULL                                             // output pin cat
                      );
        if (fmr) {
            // direct connect
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() succeeded");
                    delete[] pInMedia;
                    delete[] pOutMedia;
					return true;
				}
			}
        }}
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
                delete[] pInMedia;
                delete[] pOutMedia;
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    delete[] pInMedia;
    delete[] pOutMedia;
    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() failed");
    return false;
}

#endif //TUNING_MODEL_ONLY

// end of file - dsextend.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dvbslocatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSLocatorimpl.h : implementation helper template for DVBSlocator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef DVBSLOCATORIMPL_H
#define DVBSLOCATORIMPL_H

#include <locatorimpl.h>

namespace BDATuningModel {

template<class T,
         class MostDerived = IDVBSLocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBSLocatorImpl : 
	public ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IDVBSLocator
public:

	typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    typedef IDVBSLocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;

	Polarisation m_SignalPolarisation;
	VARIANT_BOOL m_WestPosition;
	long m_OrbitalPosition;
	long m_Azimuth;
	long m_Elevation;

	IDVBSLocatorImpl() : m_SignalPolarisation(BDA_POLARISATION_NOT_SET),
						 m_WestPosition(VARIANT_TRUE),
						 m_OrbitalPosition(-1),
						 m_Azimuth(-1),
						 m_Elevation(-1) {}
    virtual ~IDVBSLocatorImpl() {}
    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)
		PROP_DATA_ENTRY("Polarisation",  m_SignalPolarisation, VT_I4)
		PROP_DATA_ENTRY("OrbitalPosition", m_OrbitalPosition, VT_I4)
		PROP_DATA_ENTRY("Azimuth", m_Azimuth, VT_I4)
		PROP_DATA_ENTRY("Elevation", m_Elevation, VT_I4)
		PROP_DATA_ENTRY("WestPosition", m_WestPosition, VT_BOOL)
    END_PROP_MAP()

// IDVBSLocator
public:
    STDMETHOD(get_SignalPolarisation)(/*[out, retval]*/ Polarisation *pSignalPolarisation) {
        try {
            if (!pSignalPolarisation) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pSignalPolarisation = m_SignalPolarisation;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_SignalPolarisation)(/*[in]*/ Polarisation NewSignalPolarisation) {
		ATL_LOCKT();
        m_SignalPolarisation = NewSignalPolarisation;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_WestPosition)(/*[out, retval]*/ VARIANT_BOOL *pWestPosition) {
        try {
            if (!pWestPosition) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pWestPosition = m_WestPosition;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_WestPosition)(/*[in]*/ VARIANT_BOOL NewWestPosition) {
		ATL_LOCKT();
        m_WestPosition = NewWestPosition;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OrbitalPosition)(/*[out, retval]*/ long *pOrbitalPosition) {
        try {
            if (!pOrbitalPosition) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pOrbitalPosition = m_OrbitalPosition;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OrbitalPosition)(/*[in]*/ long NewOrbitalPosition) {
		ATL_LOCKT();
        m_OrbitalPosition = NewOrbitalPosition;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Azimuth)(/*[out, retval]*/ long *pAzimuth) {
        try {
            if (!pAzimuth) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pAzimuth = m_Azimuth;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Azimuth)(/*[in]*/ long NewAzimuth) {
		ATL_LOCKT();
        m_Azimuth = NewAzimuth;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Elevation)(/*[out, retval]*/ long *pElevation) {
        try {
            if (!pElevation) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pElevation = m_Elevation;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Elevation)(/*[in]*/ long NewElevation) {
		ATL_LOCKT();
        m_Elevation = NewElevation;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_SignalPolarisation = m_SignalPolarisation;
			pt->m_WestPosition = m_WestPosition;
			pt->m_OrbitalPosition = m_OrbitalPosition;
			pt->m_Azimuth = m_Azimuth;
			pt->m_Elevation = m_Elevation;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;

}; // namespace

#endif // DVBSLOCATORIMPL_H
// end of file -- DVBSlocatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dsextend.h ===
//==========================================================================;
//
// dsextend.h : additional infrastructure to extend the dshow stuff so that it
// works nicely from c++
// Copyright (c) Microsoft Corporation 1995-1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DSEXTEND_H
#define DSEXTEND_H

#include <algorithm>
#include <functional>
#include <utility>
#include <vector>
#include <list>
#include <map>
#include <trace.h>
#include <throw.h>
#include <stextend.h>
#include <w32extend.h>
#include <ksextend.h>
#include <fwdseq.h>
#include <control.h>
#include <mpconfig.h>
#include <vptype.h>
#include <vpnotify.h>
#include <il21dec.h>
#include <mtype.h>
#include <tuner.h>
#include <bdaiface.h>
#include <errors.h>
#include <winerror.h>
#include <evcode.h>

struct DECLSPEC_NOVTABLE DECLSPEC_UUID("6E8D4A21-310C-11d0-B79A-00AA003767A7") IAMLine21Decoder;

#define LINE21_BY_MAGIC
#define FILTERDATA

// #define ATTEMPT_DIRECT_CONNECT
// we'd like to check to see if two filters can be connected by just trying to connect them
// this is less work and techinically more accurate since pins aren't required to enumerate all
// of the media types they potentiall could support.
// however, this exposes bugs in the filters and causes random hangs and crashes.  instead
// we manually check mediums and media types and only attempt the connection when we find a match.
// this turns out to be much more stable. 


//#define FORWARD_TRACE

const PIN_DIRECTION DOWNSTREAM = PINDIR_OUTPUT;
const PIN_DIRECTION UPSTREAM = PINDIR_INPUT;


typedef CComQIPtr<IFileSourceFilter, &IID_IFileSourceFilter> PQFileSourceFilter;
#ifndef POLYMORPHIC_TUNERS
typedef CComQIPtr<IAMTVTuner, &IID_IAMTVTuner> PQTVTuner;
//typedef CComQIPtr<ISatelliteTuner, &IID_ISatelliteTuner> PQSatelliteTuner;
#else
typedef CComQIPtr<IAMTuner, &IID_IAMTuner> PQTuner;
typedef CComQIPtr<IAMTVTuner, &IID_IAMTVTuner> PQTVTuner;
typedef CComQIPtr<IBPCSatelliteTuner, &IID_IBPCSatelliteTuner> PQSatelliteTuner;
#endif
#if 0
typedef CComQIPtr<IVideoWindow, &IID_IVideoWindow> PQVideoWindow;
typedef CComQIPtr<IBasicVideo, &IID_IBasicVideo> PQBasicVideo;
#else
typedef CComQIPtr<IVMRWindowlessControl, &IID_IVMRWindowlessControl> PQVMRWindowlessControl;
#endif

typedef CComQIPtr<IPin, &IID_IPin> PQPin;
typedef CComQIPtr<IBaseFilter, &IID_IBaseFilter> PQFilter;
typedef CComQIPtr<IFilterInfo, &IID_IFilterInfo> PQFilterInfo;
typedef CComQIPtr<IEnumPins, &IID_IEnumPins> PQEnumPins;
typedef CComQIPtr<IEnumFilters, &IID_IEnumFilters> PQEnumFilters;
typedef CComQIPtr<IBasicAudio, &IID_IBasicAudio> PQBasicAudio;
typedef CComQIPtr<IAMCrossbar, &IID_IAMCrossbar> PQCrossbarSwitch;
typedef CComQIPtr<IMediaEventEx, &IID_IMediaEventEx> PQMediaEventEx;
typedef CComQIPtr<IMediaControl, &IID_IMediaControl> PQMediaControl;
typedef CComQIPtr<IMediaPosition, &IID_IMediaPosition> PQMediaPosition;
typedef CComQIPtr<IMediaSeeking, &IID_IMediaSeeking> PQMediaSeeking;
typedef CComQIPtr<IGraphBuilder, &IID_IGraphBuilder> PQGraphBuilder;
typedef CComQIPtr<ICreateDevEnum, &IID_ICreateDevEnum> PQCreateDevEnum;
typedef CComQIPtr<IEnumMoniker, &IID_IEnumMoniker> PQEnumMoniker;
typedef CComQIPtr<IFilterMapper2, &IID_IFilterMapper2> PQFilterMapper;
typedef CComQIPtr<IEnumMediaTypes, &IID_IEnumMediaTypes> PQEnumMediaTypes;
typedef CComQIPtr<IAMAnalogVideoDecoder, &IID_IAMAnalogVideoDecoder> PQAnalogVideoDecoder;
typedef CComQIPtr<IMixerPinConfig, &IID_IMixerPinConfig> PQMixerPinConfig;
typedef CComQIPtr<IAMAudioInputMixer, &IID_IAMAudioInputMixer> PQAudioInputMixer;
typedef CComQIPtr<IAMLine21Decoder, &IID_IAMLine21Decoder> PQLine21Decoder;
typedef CComQIPtr<IVPNotify2, &IID_IVPNotify2> PQVPNotify2;
typedef CComQIPtr<ITuner> PQBDATuner;
typedef CComQIPtr<IBDA_IPSinkControl> PQBDA_IPSinkControl;
typedef CComQIPtr<IDvdControl, &IID_IDvdControl> PQDVDNavigator;
typedef CComQIPtr<IVideoFrameStep> PQVideoFrameStep;
typedef CComQIPtr<IMediaEventSink> PQMediaEventSink;
typedef CComQIPtr<IVMRMonitorConfig> PQVMRMonitorConfig;
typedef CComQIPtr<IDirectDraw7, &IID_IDirectDraw7> PQDirectDraw7;
typedef CComQIPtr<IRegisterServiceProvider, &IID_IRegisterServiceProvider> PQRegisterServiceProvider;
typedef std::vector<GUID2> MediaMajorTypeList;

#if 0
typedef std::pair<PQCrossbarSwitch, long> PQBasePoint;

inline void clear(PQBasePoint &p) {p.first.Release(); p.second = 0;}
class PQPoint : public PQBasePoint {
public:
        //PQBasePoint p;
		inline PQPoint() :  PQBasePoint(PQCrossbarSwitch(), 0) {}
        inline PQPoint(const PQBasePoint &p2) : PQBasePoint(p2) {}
        inline PQPoint(const PQPoint &p2) : PQBasePoint(p2) {}
        inline PQPoint(const PQCrossbarSwitch &s, long i) : PQBasePoint(s, i) {}
        virtual ~PQPoint() { ::clear(*this); }
        inline void clear(void) { ::clear(*this); }
};
#else
typedef std::pair<PQCrossbarSwitch, long> PQPoint;
#endif

class CDevices;
class DSFilter;
class DSPin;
typedef std::vector< DSFilter, stl_smart_ptr_allocator<DSFilter> > DSFilterList;
typedef std::vector< DSPin, stl_smart_ptr_allocator<DSPin> > DSPinList;

typedef std::pair< DSFilter, CString> DSFilterID;
typedef std::vector< DSFilterID > DSFilterIDList;

typedef PQPoint XBarInputPoint, PQInputPoint;
typedef PQPoint XBarOutputPoint, PQOutputPoint;
typedef PQPoint XBarPoint;

typedef std::pair<XBarInputPoint, XBarOutputPoint> CIOPoint;
typedef std::list<CIOPoint> VWGraphPath;

class VWStream : public VWGraphPath {
public:
    //PQBasePoint p;
    VWStream() {}
    VWStream(const VWGraphPath &p2) : VWGraphPath(p2) {}
    VWStream(const VWStream &p2) : VWGraphPath(p2) {}
    virtual ~VWStream() {}
    void Route(void);
};

typedef std::list<VWStream> VWStreamList;

#ifdef _DEBUG
class DSREGPINMEDIUM;
class DSMediaType;
inline tostream &operator<<(tostream &dc, const DSREGPINMEDIUM &g);
inline tostream& operator<<(tostream &d, const PQPin &pin);
inline tostream &operator<<(tostream &dc, const DSREGPINMEDIUM &g);
inline tostream& operator<<(tostream &d, const PQPin &pin);
inline tostream& operator<<(tostream &d, const _AMMediaType *pmt);
#endif


// AM_MEDIA_TYPE:
//    GUID      majortype;
//    GUID      subtype;
//    BOOL      bFixedSizeSamples;
//    BOOL      bTemporalCompression;
//    ULONG     lSampleSize;
//    GUID      formattype;
//    IUnknown  *pUnk;
//    ULONG     cbFormat;

#define GUID0 0L, 0, 0, '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'
const AM_MEDIA_TYPE NULL_AMMEDIATYPE = {
    GUID0,
    GUID0,
    0,
    0,
    0L,
    GUID0,
    NULL,
    0L
};


// this is basically a CComQIPtr with allocate/copy semantics instead of
// refcount semantics and without the QI stuff.
// i don't know why they didn't just implement media types as an
// com object with an IMediaType interface instead of this weird alloc stuff

// REV2: investigate inheriting from CMediaType class in mtype.h.  but, i'm not using anything
// from the filter implementation class hierarchy.  and, i'd like to keep this interface division
// clean.  right now we only use dshow sdk \include which is the external interface stuff.
class DSMediaType {
public:
    AM_MEDIA_TYPE *p;

    inline DSMediaType() : p(NULL) {}
    DSMediaType(GUID majortype, GUID subtype = GUID_NULL, GUID formattype = GUID_NULL) : p(NULL) {
        try {
            p = CreateMediaType(&NULL_AMMEDIATYPE);
            if (p) {
                p->majortype            = majortype;
                p->subtype              = subtype;
                p->formattype           = formattype;
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::DSMediaType(const DSMediaType) Exception");
        }
    }
    DSMediaType(const DSMediaType &d) : p(NULL) {
        try {
            if (d.p) {
                p = CreateMediaType(d.p);
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::DSMediaType(const DSMediaType) Exception");
        }
    }
    DSMediaType(int a) : p(NULL) {}
    ~DSMediaType() {
        try {
            if (p) {
                DeleteMediaType(p);
                p = NULL;
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::~DSMediaType() Exception");
        }
    }

    inline operator AM_MEDIA_TYPE*() const {return p;}
    inline AM_MEDIA_TYPE& operator*() const {_ASSERTE(p!=NULL); return *p; }
    inline AM_MEDIA_TYPE ** operator&() {ASSERT(p == NULL); return &p; }
    inline AM_MEDIA_TYPE * operator->() const {_ASSERTE(p!=NULL); return p; }
    inline DSMediaType * address(void) { return this; }
    inline const DSMediaType * const_address(void) const { return this; }
	typedef stl_smart_ptr_allocator<DSMediaType> stl_allocator;
    DSMediaType& operator=(const AM_MEDIA_TYPE &d) {
        if (&d != p) {
            try {
                if (p) {
                    DeleteMediaType(p);
                    p = NULL;
                }
                if (&d) {
                    p = CreateMediaType(&d);
                }
            } catch(...) {
                TRACELM(TRACE_ERROR, "DSMediaType::operator=(const AM_MEDIA_TYPE &) Exception");
            }
        }
        return *this;
    }
    DSMediaType& operator=(const AM_MEDIA_TYPE *pd) {
        try {
            if (pd != p) {
                if (p) {
                    DeleteMediaType(p);
                    p = NULL;
                }
                if (pd) {
                    p = CreateMediaType(pd);
                }
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::operator=(const AM_MEDIA_TYPE *) Exception");
        }
        return *this;
    }
    DSMediaType& operator=(const DSMediaType &d) {
        try {
            if (d.const_address() != this) {
                if (p) {
                    DeleteMediaType(p);
                    p = NULL;
                }
                if (d.p) {
                    p = CreateMediaType(d.p);
                }
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::operator=(DSMediaType &)Exception");
        }
        return *this;
    }
    DSMediaType& operator=(int d) {
        ASSERT(d == 0);
        try {
            if (p) {
                DeleteMediaType(p);
                p = NULL;
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::operator=(int) Exception");
        }
        return *this;
    }

    inline bool operator==(const DSMediaType &d) const {
        if (!p && !d.p) {
            // both null then they're the same
            return true;
        }
        if (!p || !d.p) {
            // if either one null but not both then they aren't the same
            return false;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSMediaType::operator==() this = " << *this << " d = " << d), "");
        return p->majortype == d.p->majortype &&
               (p->subtype == GUID_NULL || d.p->subtype == GUID_NULL || p->subtype == d.p->subtype);
    }
    inline bool operator==(const AM_MEDIA_TYPE &d) const {
        if (!p && !&d) {
            return true;
        }
        return p && (&d) && p->majortype == d.majortype &&
               (p->subtype == GUID_NULL || d.subtype == GUID_NULL || p->subtype == d.subtype);
    }
    inline bool operator==(const AM_MEDIA_TYPE *d) const {
        if (!p && !d) {
            return true;
        }
        return p && d && p->majortype == d->majortype &&
               (p->subtype == GUID_NULL || d->subtype == GUID_NULL || p->subtype == d->subtype);
    }
    inline bool operator!=(const DSMediaType &d) const {
        return !(*this == d);
    }
    inline bool operator!() const {
        return (p == NULL);
    }
    inline bool MatchingMajor(const AM_MEDIA_TYPE *prhs) const {
		if (!p && !prhs) {
			return true;
		}
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSMediaType::MatchingMajor() this = " << *this << "\rprhs = " << prhs), "");
        return p && prhs && p->majortype == prhs->majortype;
    }
    inline bool MatchingMajor(const DSMediaType &rhs) const {
        return MatchingMajor(rhs.p);
    }

#ifdef _DEBUG
	inline tostream& operator<<(tostream &d) {
		d << p;
		if (p) {
			d << _T(" major = ") << GUID2(p->majortype) << _T(" sub = ") << GUID2(p->subtype);
		}
		return d;
	}
#endif
};

class DSFilterMoniker : public W32Moniker {
public:
    inline DSFilterMoniker() {}
    inline DSFilterMoniker(const PQMoniker &a) : W32Moniker(a) {}
    inline DSFilterMoniker(const W32Moniker &a) : W32Moniker(a) {}
    inline DSFilterMoniker(IMoniker *p) : W32Moniker(p) {}
    inline DSFilterMoniker(IUnknown *p) : W32Moniker(p) {}
    inline DSFilterMoniker(const DSFilterMoniker &a) : W32Moniker(a) {}

    CComBSTR GetName() const {
        CComVariant vName;
        vName.vt = VT_BSTR;
        HRESULT hr = (GetPropertyBag())->Read(OLESTR("FriendlyName"), &vName, NULL);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "DSFilterMoniker::GetName() can't read friendly name");
            return CComBSTR();
        }
        USES_CONVERSION;
        ASSERT(vName.vt == VT_BSTR);
        CComBSTR Name(vName.bstrVal);
        return Name;
    }
    DSFilter GetFilter() const;
};

typedef Forward_Sequence<
    PQCreateDevEnum,
    PQEnumMoniker,
    DSFilterMoniker,
    ICreateDevEnum,
    IEnumMoniker,
    IMoniker*> DSDeviceSequence;

typedef Forward_Sequence<
    PQFilterMapper,
    PQEnumMoniker,
    DSFilterMoniker,
    IFilterMapper2,
    IEnumMoniker,
    IMoniker*> DSFilterMapperSequence;

typedef Forward_Sequence<
    PQPin,
    PQEnumMediaTypes,
    DSMediaType,
    IPin,
    IEnumMediaTypes,
    AM_MEDIA_TYPE*> DSPinSequence;

class DSGraph;

class DSPin : public DSPinSequence {
public:
    DSPin() {}
    DSPin(const PQPin &a) : DSPinSequence(a) {}
    DSPin(IPin *p) : DSPinSequence(p) {}
    DSPin(IUnknown *p) : DSPinSequence(p) {}
    DSPin(const DSPin &a) : DSPinSequence(a) {}

    CString GetName() const {
        CString csPinName;
        PIN_INFO pinfo;
        HRESULT hr = (*this)->QueryPinInfo(&pinfo);
        if (SUCCEEDED(hr)) {
            csPinName = pinfo.achName;
            if (pinfo.pFilter) pinfo.pFilter->Release();
        }
        return csPinName;
    }

    PIN_DIRECTION GetDirection() const {
        PIN_DIRECTION pin1dir;
        HRESULT hr = (*this)->QueryDirection(&pin1dir);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "DSPin::GetDirection() can't call QueryDirection");
            THROWCOM(E_UNEXPECTED);
        }
        return pin1dir;
    }

    bool IsConnected() const {
        return GetConnection() != DSPin();
    }

	bool IsRenderable() {
		CString csName(GetName());
		if (!csName.IsEmpty() && csName.GetAt(0) == '~') {
			return false;
		}
		return true;
	}
    bool IsInput() const {
        return GetDirection() == PINDIR_INPUT;
    }
    static inline bool IsInput(const DSPin pin) {
        PIN_DIRECTION pin1dir = pin.GetDirection();
        return pin1dir == PINDIR_INPUT;
    }
    bool IsKsProxied() const;
    HRESULT GetMediums(KSMediumList &MediumList) const {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::GetMediums() " << this), "");
        PQKSPin pin(*this);
        if (!pin) {
            TRACELM(TRACE_DETAIL, "DSPin::GetMedium() can't get IKsPin");
            return E_FAIL;
        }
        HRESULT hr = pin->KsQueryMediums(&MediumList);
        // undone: in win64 mediumlist.size is really __int64.  fix output operator for
        // that type and remove cast
        TRACELSM(TRACE_DETAIL, (dbgDump <<
            "DSPin::GetMediums() hr = " <<
            hr <<
            " size = " <<
            (long) MediumList.size()), "");
        return hr;
    }

    static inline bool HasCategory(DSPin& pin, const GUID2 &clsCategory, const PIN_DIRECTION pd) {
        return pin.HasCategory(clsCategory, pd);
    }

    static inline bool HasCategory(DSPin& pin, const GUID2 &clsCategory) {
        return pin.HasCategory(clsCategory);
    }

    void GetCategory(CLSID &clsCategory) const {
        ULONG outcount;

        PQKSPropertySet ps(*this);
        if (!ps) {
            TRACELM(TRACE_ERROR, "DSPin::GetCategory() can't get IKsPropertySet");
            clsCategory = GUID_NULL;
            return;
        }

        HRESULT hr = ps->Get(AMPROPSETID_Pin, AMPROPERTY_PIN_CATEGORY,
                             NULL, 0, &clsCategory, sizeof(clsCategory), &outcount);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSPin::GetCategory() can't get pin category hr = " << hr), "");
            clsCategory = GUID_NULL;
        }
        return;
    }
    DSPin GetConnection(void) const {
        DSPin pConn;
        HRESULT hr = (*this)->ConnectedTo(&pConn);
        if (FAILED(hr) || !pConn) {
            return DSPin();
        }
#ifdef _DEBUG
        DSPin pConn2;
        hr = pConn->ConnectedTo(&pConn2);
        if (FAILED(hr) || pConn2.IsEqualObject(*this)) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::GetConnection() " << *this << " is Connected to " << pConn << " but not vice versa"), "");
        }
#endif
        return pConn;
    }
    DSMediaType GetConnectionMediaType(void) const {
        DSMediaType amt(GUID_NULL);
        HRESULT hr = (*this)->ConnectionMediaType(amt);
        if (SUCCEEDED(hr)) {
            return amt;
        } else {
            return DSMediaType();
        }
    }
    DSGraph GetGraph(void) const;
    DSFilter GetFilter(void) const;

    bool HasCategory(const GUID2 &clsCategory, const PIN_DIRECTION pd) const;
    bool HasCategory(const GUID2 &clsCategory) const;
    HRESULT Connect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType = NULL);
    HRESULT IntelligentConnect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType = NULL) {
		// undone: implement this via igb2, currently we're just connecting directly via graph mgr.
		return Connect(ConnectTo, pMediaType);
	}
    HRESULT IntelligentConnect(DSFilter& Filter1, DSFilterList &intermediates, const DWORD dwFlags = 0, const PIN_DIRECTION pd = DOWNSTREAM);
    HRESULT Disconnect(void);
    bool CanRoute(const DSPin pin2) const;

protected:
    bool Routable(const DSPin pin2) const;
};

typedef Forward_Sequence<
    PQFilter,
    PQEnumPins,
    DSPin,
    IBaseFilter ,
    IEnumPins,
    IPin*> DSFilterSequence;

inline bool _cdecl operator==(const CString &cs, const DSFilterSequence& pF);
inline bool _cdecl operator==(const CLSID &cls, const DSFilterSequence& pF);

class DSFilter : public DSFilterSequence {
public:
    DSFilter() {}
    DSFilter(const PQFilter &a) : DSFilterSequence(a) {}
    DSFilter(const DSFilterSequence &a) : DSFilterSequence(a) {}
    DSFilter(IBaseFilter *p) : DSFilterSequence(p) {}
    DSFilter(IUnknown *p) : DSFilterSequence(p) {}
    DSFilter(const DSFilter &a) : DSFilterSequence(a) {}
    DSFilter(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) : DSFilterSequence(rclsid, pUnkOuter, dwClsContext) {}
    DSGraph GetGraph(void);
    void GetPinCounts(ULONG &ulIn, ULONG &ulOut) const;
    ULONG PinCount(PIN_DIRECTION pd) {
        ULONG in, out;
        GetPinCounts(in, out);
        if (pd == PINDIR_INPUT) {
            return in;
        } else {
            return out;
        }
    }
	ULONG OutputPinCount() const {
		ULONG in, out;
		GetPinCounts(in, out);
		return out;
	}
	ULONG InputPinCount() const {
		ULONG in, out;
		GetPinCounts(in, out);
		return in;
	}
	bool HasFreePins(PIN_DIRECTION pd) const {
		int count = 0;
		for (iterator i = begin(); i != end(); ++i) {
			DSPin p(*i);
			if (p.GetDirection() != pd) {
				continue;
			}
			if (p.IsConnected()) {
				continue;
			}
			++count;
		}
		return !!count;
	}
    bool IsKsProxied() const {
        CLSID cls;
        HRESULT hr = (*this)->GetClassID(&cls);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "DSFilter::IsKsProxied() can't get class id");
            return false;  // if it doesn't have a clsid it can't be the proxy
        }
#pragma warning(disable: 4800)
        return (cls == CLSID_Proxy);
#pragma warning(default: 4800)
    }
#if 0
    DSFilter *operator&() {  // using vector instead of list so don't need this
        return this;
    }
#endif
    bool IsXBar() const;
    CString GetName(void) const;
	DSPin FirstPin(PIN_DIRECTION pd = PINDIR_INPUT) const {
		for (DSFilter::iterator i = begin(); i != end(); ++i) {
			if ((*i).GetDirection() == pd) {
				return *i;
			}
		}
		return DSPin();
	}
    GUID2 ClassID() const {
        PQPersist p(*this);
        GUID2 g;
        p->GetClassID(&g);
        return g;
    }
};

typedef Forward_Sequence<
    PQGraphBuilder,
    PQEnumFilters,
    DSFilter,
    IGraphBuilder,
    IEnumFilters,
    IBaseFilter*> DSGraphContainer;

typedef std_arity3pmf<
                ICreateDevEnum, REFCLSID, IEnumMoniker **, ULONG, HRESULT
        > DSDevicesMFType;

typedef std_bndr_mf_1_3<DSDevicesMFType> DSDevicesFetchType;

class DSDevices : public DSDeviceSequence {
public:
    DSDevicesFetchType * Fetch;
    DSDevices(DSDeviceSequence &p, REFCLSID clsid) :  Fetch(NULL), DSDeviceSequence(p) {
        SetFetch(clsid);
    }
    DSDevices(PQCreateDevEnum &p, REFCLSID clsid) : Fetch(NULL), DSDeviceSequence(p) {
        SetFetch(clsid);
    }
    DSDevices(DSDevices &d) : DSDeviceSequence(d) {
        SetFetch((d.Fetch)->arg1val);
    }
    virtual DSDeviceSequence::FetchType * GetFetch() const { return Fetch; }
    ~DSDevices() { if (Fetch) delete Fetch; }
protected:
    // NOTE: this invalidates all currently outstanding iterators
    // don't use outside of construction
    void SetFetch(REFCLSID clsid) {
        if (Fetch) {
            delete Fetch;
        }
        Fetch =
            new DSDevicesFetchType(std_arity3_member(&ICreateDevEnum::CreateClassEnumerator),
                                   clsid,
                                   0);
    }

};

typedef std_arity15pmf<
                IFilterMapper2,
                IEnumMoniker **,           // enumerator returned
                DWORD,                   // 0 flags
                BOOL,                // don't match wildcards
                DWORD,                   // at least this merit needed
                BOOL,              // need at least one input pin
                DWORD,               // input media type count
                const GUID *,               // input major+sub pair array
                const REGPINMEDIUM *,      // input medium
                const CLSID*,             // input pin category
                BOOL,                   // must the input be rendered?
                BOOL,             // need at least one output pin
                DWORD,              // output media type count
                const GUID *,             // output major type
                const REGPINMEDIUM *,     // output medium
                const CLSID*,             // output pin category
                HRESULT
        > DSFilterMapperMFType;

typedef std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15<DSFilterMapperMFType> DSFilterMapperFetchType;

class DSFilterMapper : public DSFilterMapperSequence {
public:
    DSFilterMapperFetchType *Fetch;

protected:
    // NOTE: this invalidates all currently outstanding iterators
    // don't use outside of construction
    void SetFetch(
        DWORD dwFlags,                   // 0
        BOOL bExactMatch,                // don't match wildcards
        DWORD dwMerit,                   // at least this merit needed
        BOOL  bInputNeeded,              // need at least one input pin
        DWORD cInputTypes,               // Number of input types to match
                                        // Any match is OK
        const GUID *pInputTypes, // input major+subtype pair array
        const REGPINMEDIUM *pMedIn,      // input medium
        const CLSID *pPinCategoryIn,     // input pin category
        BOOL  bRender,                   // must the input be rendered?
        BOOL  bOutputNeeded,             // need at least one output pin
        DWORD cOutputTypes,              // Number of output types to match
                                       // Any match is OK
        const GUID *pOutputTypes, // output major+subtype pair array
        const REGPINMEDIUM *pMedOut,     // output medium
        const CLSID *pPinCategoryOut     // output pin category
   ) {
        if (Fetch) {
            delete Fetch;
        }
        Fetch =
            new DSFilterMapperFetchType(std_arity15_member(&IFilterMapper2::EnumMatchingFilters),
                                        dwFlags,                   // 0
                                        bExactMatch,
                                        dwMerit,
                                        bInputNeeded,
                                        cInputTypes,               // Number of input types to match
                                        pInputTypes, // input major+subtype pair array
                                                    // Any match is OK
                                        pMedIn,
                                        pPinCategoryIn,
                                        bRender,
                                        bOutputNeeded,
                                        cOutputTypes,      // Number of output types to match
                                                           // Any match is OK
                                        pOutputTypes, // output major+subtype pair array
                                        pMedOut,
                                        pPinCategoryOut
                                       );
    }

public:
    DSFilterMapper(PQFilterMapper &p,
                   DWORD dwFlags,                   // 0
                   BOOL bExactMatch,                // don't match wildcards
                   DWORD dwMerit,                   // at least this merit needed
                   BOOL  bInputNeeded,              // need at least one input pin
                   DWORD cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                   const GUID *pInputTypes, // input major+subtype pair array
                   const REGPINMEDIUM *pMedIn,      // input medium
                   const CLSID* pInCat,             // input pin category
                   BOOL  bRender,                   // must the input be rendered?
                   BOOL  bOutputNeeded,             // need at least one output pin
                   DWORD cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                   const GUID *pOutputTypes, // output major+subtype pair array
                   const REGPINMEDIUM *pMedOut,     // output medium
                   const CLSID* pOutCat             // output pin category
                  ) : Fetch(NULL), DSFilterMapperSequence(p) {
        SetFetch(
                 dwFlags,                   // 0
                 bExactMatch,
                 dwMerit,
                 bInputNeeded,
                 cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                 pInputTypes, // input major+subtype pair array
                 pMedIn,
                 pInCat,
                 bRender,
                 bOutputNeeded,
                 cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                 pOutputTypes, // output major+subtype pair array
                 pMedOut,
                 pOutCat
                );
    }

    DSFilterMapper(DSFilterMapperSequence &p,
                   DWORD dwFlags,                   // 0
                   BOOL bExactMatch,                // don't match wildcards
                   DWORD dwMerit,                   // at least this merit needed
                   BOOL  bInputNeeded,              // need at least one input pin
                   DWORD cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                   const GUID *pInputTypes, // input major+subtype pair array
                   const REGPINMEDIUM *pMedIn,      // input medium
                   const CLSID* pInCat,             // input pin category
                   BOOL  bRender,                   // must the input be rendered?
                   BOOL  bOutputNeeded,             // need at least one output pin
                   DWORD cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                   const GUID *pOutputTypes, // output major+subtype pair array
                   const REGPINMEDIUM *pMedOut,     // output medium
                   const CLSID* pOutCat             // output pin category
                  ) :  Fetch(NULL), DSFilterMapperSequence(p) {
        SetFetch(
                 dwFlags,                   // 0
                 bExactMatch,
                 dwMerit,
                 bInputNeeded,
                 cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                 pInputTypes, // input major+subtype pair array
                 pMedIn,
                 pInCat,
                 bRender,
                 bOutputNeeded,
                 cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                 pOutputTypes, // output major+subtype pair array
                 pMedOut,
                 pOutCat
                );
    }

    DSFilterMapper(DSFilterMapper &d) : DSFilterMapperSequence(d) {
        SetFetch((d.Fetch)->arg2val, (d.Fetch)->arg3val, (d.Fetch)->arg4val, (d.Fetch)->arg5val,
                 (d.Fetch)->arg6val, (d.Fetch)->arg7val, (d.Fetch)->arg8val, (d.Fetch)->arg9val,
                 (d.Fetch)->arg10val, (d.Fetch)->arg11val, (d.Fetch)->arg12val,
                 (d.Fetch)->arg13val, (d.Fetch)->arg14val, (d.Fetch)->arg15val
                );
    }
    virtual DSFilterMapperSequence::FetchType *GetFetch() const { return Fetch; }
    ~DSFilterMapper() { if (Fetch) delete Fetch; }
};


class DSREGPINMEDIUM : public REGPINMEDIUM {
public:
    DSREGPINMEDIUM() { memset(this, 0, sizeof(*this)); }
    DSREGPINMEDIUM(REFGUID SetInit, ULONG IdInit, ULONG FlagsInit) {
        clsMedium = SetInit;
        dw1 = IdInit;
        dw2 = FlagsInit;
    }
    DSREGPINMEDIUM(DSREGPINMEDIUM &rhs) {
        clsMedium = rhs.clsMedium;
        dw1 = rhs.dw1;
        dw2 = rhs.dw2;
    }
    DSREGPINMEDIUM(KSPinMedium &rhs) {
        clsMedium = rhs.Set;
        dw1 = rhs.Id;
        dw2 = rhs.Flags;
    }

    DSREGPINMEDIUM& operator=(const KSPinMedium &rhs) {
        if (reinterpret_cast<const REGPINMEDIUM *>(&rhs) != this) {
            clsMedium = rhs.Set;
            dw1 = rhs.Id;
            dw2 = rhs.Flags;
        }
        return *this;
    }
    DSREGPINMEDIUM& operator=(const DSREGPINMEDIUM &rhs) {
        if (&rhs != this) {
            clsMedium = rhs.clsMedium;
            dw1 = rhs.dw1;
            dw2 = rhs.dw2;
        }
        return *this;
    }
    bool operator==(const DSREGPINMEDIUM &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return (dw1 == rhs.dw1 && clsMedium == rhs.clsMedium);
    }
    bool operator!=(const DSREGPINMEDIUM &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return !(*this == rhs);
    }
};

const long DEFAULT_GRAPH_STATE_TIMEOUT = 5000;

class DSGraph : public DSGraphContainer {
public:
    DSGraph() {}
    DSGraph(const DSGraph &a) : DSGraphContainer(a) {}
    DSGraph(const PQGraphBuilder &a) : DSGraphContainer(a) {}
    DSGraph(const DSGraphContainer &a) : DSGraphContainer(a) {}
    DSGraph(IGraphBuilder *p) : DSGraphContainer(p) {}
    DSGraph(IUnknown *p) : DSGraphContainer(p) {}

    HRESULT AddToROT(DWORD *pdwObjectRegistration);
    void RemoveFromROT(DWORD dwObjectRegistration);

    // graph operation
    inline OAFilterState GetState(long timeout = DEFAULT_GRAPH_STATE_TIMEOUT) {
        PQMediaControl pMC(*this);
        if(!pMC) {
            THROWCOM(E_UNEXPECTED);
        }
        OAFilterState state;
        HRESULT hr = pMC->GetState(timeout, &state);
        if (hr == VFW_S_CANT_CUE) {
            state = State_Paused;
        } else 	if (hr == VFW_S_STATE_INTERMEDIATE) {
            THROWCOM(HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        } else 	if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::GetState() can't get graph state hr = " << hr), "");
            THROWCOM(hr);
		}
        return state;
    }
    inline bool IsPlaying() {
        try {
            return GetState() == State_Running;
        } catch(...) {
            return false;
        }
    }
    inline bool IsPaused() {
        try {
            return GetState() == State_Paused;
        } catch(...) {
            return false;
        }
    }
    inline bool IsStopped() {
        try {
            return GetState() == State_Stopped;
        } catch(...) {
            return false;
        }
    }

    // graph building helpers
    HRESULT Connect(DSFilter &pStart, DSFilter &pStop, DSFilterList &Added, const DWORD dwFlags = 0, PIN_DIRECTION pFilter1Direction = DOWNSTREAM);
    bool Connect(DSFilter &pFilter1, DSFilterMoniker &pMoniker, DSFilter &pAdded, DSFilterList &NewIntermediateFilters, const DWORD dwFlags = 0, PIN_DIRECTION pFilter1Direction = DOWNSTREAM);

    typedef bool (DSGraph::*ConnectPred_t)(DSPin&, DSFilter&, DWORD dwFlags);
    typedef arity5pmf<DSGraph, DSPin&, DSFilterMoniker&, DSFilter&, DSFilterIDList &, ConnectPred_t, bool> LoadCheck_t;
    typedef arity5pmf<DSGraph, DSPin&, DSFilter&, DSFilter&, DSFilterIDList &, ConnectPred_t, bool> ConnectCheck_t;

    bool DisconnectPin(DSPin &pPin, const bool fRecurseInputs, const bool fRecurseOutputs);
    bool DisconnectFilter(DSFilter &pFilter, const bool fRecurseInputs, const bool fRecurseOutputs);
    bool RemoveFilter(DSFilter &pFilter);

    bool IsConnectable(DSPin &pPin1, DSFilter &Mapper, DSFilter &Destination, DSFilterIDList &NewFilters, const DWORD dwFlags, ConnectPred_t ConnPred);
    bool IsLoadable(DSPin &pPin1, DSFilterMoniker &Mapper, DSFilter &Destination, DSFilterIDList &IntermediateFilters, const DWORD dwFlags, ConnectPred_t ConnPred);
    bool IsPinConnected(const DSPin &pPin1, const DSFilter &pFDestination, DSFilterIDList &IntermediateFilters, const PIN_DIRECTION destdir) const;


    // generic recursive build functions
#ifdef ATTEMPT_DIRECT_CONNECT    
	bool ConnectPinDirect(DSPin &pPin, DSFilter &pFilter2, DWORD dwFlags);
#else
    bool HasMediaType(const DSMediaType &LeftMedia, const DSPin &pPinRight) const;
    bool HasMedium(const KSPinMedium &Medium1, const DSPin &pPin2) const;
    bool HasUnconnectedMedium(const DSPin &pPinLeft, const DSPin &pPin2, int& cUseable) const;
    bool HasUnconnectedMediaType(const DSPin &pPinLeft, const DSPin &pPin2, DWORD dwFlags) const;
    bool ConnectPinByMedium(DSPin &pPin, DSFilter &pFilter2, DWORD dwFlags);
    bool ConnectPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DWORD dwFlags);
#endif
    bool FindPinByMedium(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &InterediateFilters, const DWORD dwFlags);
    bool LoadPinByMedium(KSPinMedium &medium, DSPin &pPinLeft, DSFilter &pFilter2, DSFilterIDList &IntermediateFilters, const DWORD dwFlags);
    bool LoadPinByAnyMedium(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &IntermediateFilters, const DWORD dwFlags);
    bool FindPinByMediaType(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &InterediateFilters, const DWORD dwFlags);
    bool LoadPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, const DWORD dwMerit);
    bool LoadPinByAnyMediaType(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &IntermediateFilters, const DWORD dwFlags);

	enum {
		RENDER_ALL_PINS = 0x01,
		IGNORE_EXISTING_CONNECTIONS = 0x02,
		DO_NOT_LOAD = 0x04,
        ATTEMPT_MERIT_DO_NOT_USE = 0x08,
		ATTEMPT_MERIT_UNLIKELY = 0x10,
		ALLOW_WILDCARDS = 0x20,
        IGNORE_MEDIATYPE_ERRORS = 0x40,
        DONT_TERMINATE_ON_RENDERER= 0x80,
        BIDIRECTIONAL_MEDIATYPE_MATCHING = 0x100,
	}; // render flags

    bool ConnectPin(DSPin &pPin1, DSFilter &pFilter2, DSFilterIDList &NewFilters, const DWORD dwFlags, PIN_DIRECTION pin1dir);
    bool ConnectPin(DSPin &pPin1, DSFilter &pFilter2, DSFilterList &NewFilters, const DWORD dwFlags, PIN_DIRECTION pin1dir) {
		DSFilterIDList AddedIDs;
		bool rc = ConnectPin(pPin1, pFilter2, AddedIDs, dwFlags, pin1dir);
		if (rc) {
			for (DSFilterIDList::iterator i = AddedIDs.begin(); i != AddedIDs.end(); ++i) {
				NewFilters.push_back((*i).first);
			}
		}
		return rc;
	}
    DSFilter LoadFilter(const DSFilterMoniker &pM, CString &csName);
    DSFilter AddMoniker(const DSFilterMoniker &pM);
    HRESULT AddFilter(DSFilter &pFilter, CString &csName);
    DSFilter AddFilter(const CLSID &cls, CString &csName);
    bool ConnectFilters(DSFilter &pFilter1, DSFilter &pFilter2, DSFilterIDList &NewIntermediateFilters, const DWORD dwFlags = 0, PIN_DIRECTION pFilter1Direction = DOWNSTREAM);
    int BuildGraphPath(const DSFilter& pStart, const DSFilter& pStop,
                       VWStream &path, MediaMajorTypeList& MediaList, PIN_DIRECTION direction, const DSPin &InitialInput);

    HRESULT SetMediaEventNotificationWindow(HWND h, UINT msg, long lInstance) {
        // If windowless, WM_MEDIAEVENT is processed by the timer in OnTimer
        PQMediaEventEx pme(*this);
        if (!pme) {
            return E_UNEXPECTED;
        }
        HRESULT hr = pme->CancelDefaultHandling(EC_STATE_CHANGE);
        ASSERT(SUCCEEDED(hr));

        return pme->SetNotifyWindow((OAHWND) h, msg, lInstance);

    }
};

class DSXBarPin : public DSPin {
public:
    DSXBarPin() {}
    DSXBarPin(const DSPin &p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(const PQPin &p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(const DSXBarPin &p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(IUnknown *p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(IAMCrossbar *p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }

#if 0
    static const DSXBarPin Find(const CPinPoints &pinpoints, const PQPoint &point, PIN_DIRECTION pindir);
#endif


//    static DSPin DSPinFromIndex(const DSFilter XBar, const ULONG index);
    const PQPoint GetPoint() const;
    bool CanRoute(const DSXBarPin pin2) const;
#if 0
    void GetRelations(const CPinPoints &pinpoint,
                      CString &csName, CString &csType, CString &csRelName) const;
#endif
};

inline DSFilter DSFilterMoniker::GetFilter() const {
    DSFilter pFilter;
    HRESULT hr = (*this)->BindToObject(0, 0, __uuidof(IBaseFilter), reinterpret_cast<LPVOID *>(&pFilter));
    if (FAILED(hr)) {
        // undone: it would be useful to dump the mkr display name here....
        TRACELSM(TRACE_ERROR, (dbgDump << "DSFilterMoniker::GetFilter() can't bind to object.  hr = " << hexdump(hr)), "");
        return DSFilter();
    }
    return pFilter;
}

#ifdef _DEBUG
//void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel);
inline tostream &operator<<(tostream &dc, const DSREGPINMEDIUM &g) {
    //TRACELM(TRACE_DETAIL, "operator<<(tostream, DSREGPINMEDIUM)");
        const GUID2 g2(g.clsMedium);
        dc << _T("DSREGPINMEDIUM( ") << g2 << _T(", ") << hexdump(g.dw1) << _T(", ") << hexdump(g.dw2) << _T(")");
        return dc;
}
inline tostream& operator<<(tostream &d, const PQPin &pin) {
    const CString csPinName(const DSPin(pin).GetName());

    d << (csPinName.IsEmpty() ? CString(_T("**** UNKNOWN PIN NAME ****")) : csPinName) << " " << reinterpret_cast<void *>(pin.p);
    return d;
}

inline tostream& operator<<(tostream &d, const DSFilter &filt) {
    d << filt.GetName() << _T(" ") << reinterpret_cast<void *>(filt.p);
    return d;
}

inline tostream& operator<<(tostream &d, const _AMMediaType *pamt) {
    d << reinterpret_cast<const void *>(pamt);
    if (pamt) {
        d << _T(" major = ") << GUID2(pamt->majortype) << _T(" sub = ") << GUID2(pamt->subtype);
	}
    return d;
}
inline tostream& operator<<(tostream &d, const PQPoint &p) {
    const DSFilter pF(p.first);
    d << _T("PQPoint( ") << pF << _T(", ") << p.second << _T(")");
    return d;
}

inline tostream& operator<<(tostream &d, const CIOPoint &p) {
    d << _T("CIOPoint( ") << p.first << _T(", ") << p.second << _T(")");
    return d;
}

void DumpMediaTypes(DSPin &p1, DSPin &p2);
#endif

inline bool _cdecl operator==(const CString &cs, const DSFilterSequence& pF) {
    // filter name
    FILTER_INFO fi;
    HRESULT hr = pF->QueryFilterInfo(&fi);
    if (SUCCEEDED(hr)) {
        USES_CONVERSION;
        if (fi.pGraph) fi.pGraph->Release();
        return (cs == OLE2T(fi.achName));
    }
    return false;
}
inline bool _cdecl operator!=(const CString &cs, const DSFilterSequence& pF) {
    return !(cs == pF);
}
inline bool _cdecl operator==(const DSFilterSequence& pF, const CString &cs) {
    return (cs == pF);
}
inline bool _cdecl operator!=(const DSFilterSequence& pF, const CString &cs) {
    return !(cs == pF);
}


inline bool _cdecl operator==(const CLSID &cls, const DSFilterSequence& pF) {
    // filter name
    CLSID cid;
    HRESULT hr = pF->GetClassID(&cid);
    if (SUCCEEDED(hr)) {
#pragma warning(disable: 4800)
        return (cid == cls);
#pragma warning(default: 4800)
    }
    return false;
}

inline bool _cdecl operator!=(const CLSID &cls, const DSFilterSequence& pF) {
    return !(cls == pF);
}
inline bool _cdecl operator==(const DSFilterSequence& pF, const CLSID &cls) {
    return (cls == pF);
}

inline bool _cdecl operator!=(const DSFilterSequence& pF, const CLSID &cls) {
    return !(cls == pF);
}


typedef enum {
    tempAMPROPERTY_OvMixerOwner = 0x01  //use AMOVMIXEROWNER
} tempAMPROPERTY_NOTIFYOWNER;

typedef enum {
    tempAM_OvMixerOwner_Unknown = 0x01,
    tempAM_OvMixerOwner_BPC = 0x02
} tempAMOVMIXEROWNER;

inline bool DSPin::IsKsProxied() const {
    return GetFilter().IsKsProxied();
}
inline bool DSFilter::IsXBar() const {
    PQCrossbarSwitch px(*this);
	TRACELSM(TRACE_PAINT, (dbgDump << "DSFilter::IsXBar() " << *this << " is " << ((!px) ? " not " : "")), "crossbar");
    return !!px;
}


void CtorStaticDSExtendFwdSeqPMFs(void);
void DtorStaticDSExtendFwdSeqPMFs(void);

bool IsVideoFilter(const DSFilter& f);
bool IsVideoPin(const DSPin& p);

inline PIN_DIRECTION OppositeDirection(PIN_DIRECTION pd) {
	if (pd == PINDIR_INPUT) {
		return PINDIR_OUTPUT;
	} else {
		return PINDIR_INPUT;
	}
}

inline bool IsVideoMediaType(const DSMediaType& mt) {
    GUID2 g(mt.p->majortype);
    if ((g == MEDIATYPE_Video) || (g == MEDIATYPE_AnalogVideo)) {
        return true;
    }
    return false;
}

inline bool IsAnalogVideoCapture(const DSFilter &f) {
    return !!PQAnalogVideoDecoder(f);
}

inline bool IsIPSink(const DSFilter &f) {
    return !!PQBDA_IPSinkControl(f);
}

inline bool IsVPM(const DSFilter &f) {
    return f.ClassID() == CLSID_VideoPortManager;
}

inline bool IsVideoRenderer(const DSFilter &f) {
    return f.ClassID() == CLSID_VideoMixingRenderer;
}

inline bool IsDigitalAudioRenderer(const DSFilter &f) {
    return f.ClassID() == CLSID_DSoundRender;
}

inline bool IsAnalogVideoCaptureViewingPin(const DSPin &p) {
    GUID2 pincat;
    p.GetCategory(pincat);
    return (pincat == PIN_CATEGORY_VIDEOPORT || pincat == PIN_CATEGORY_CAPTURE);
}

inline bool IsAnalogVideoCapturePreviewPin(const DSPin &p) {
    GUID2 pincat;
    p.GetCategory(pincat);
    return (pincat == PIN_CATEGORY_PREVIEW);
}

inline bool IsDVDNavigator(const DSFilter &f) {
    return !!PQDVDNavigator(f);
}

inline bool IsL21Decoder(const DSFilter &f) {
    return !!PQLine21Decoder(f);
}

inline bool IsDVDNavigatorVideoOutPin(const DSPin &p) {
    
    DSPin::iterator iMediaType;
    for (iMediaType = p.begin(); iMediaType != p.end(); ++iMediaType) {
        DSMediaType mt(*iMediaType);
        if ((mt.p->majortype == MEDIATYPE_MPEG2_PES ||
             mt.p->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ) &&
             mt.p->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            return true;
        
        // elementary stream
        if ((mt.p->majortype == MEDIATYPE_Video)  &&
            (mt.p->subtype == MEDIASUBTYPE_MPEG2_VIDEO ||
             mt.p->subtype == MEDIASUBTYPE_RGB8   ||
             mt.p->subtype == MEDIASUBTYPE_RGB565 ||
             mt.p->subtype == MEDIASUBTYPE_RGB555 ||
             mt.p->subtype == MEDIASUBTYPE_RGB24  ||
             mt.p->subtype == MEDIASUBTYPE_RGB32))
             return true;
    }

    return false;
}

inline bool IsDVDNavigatorSubpictureOutPin(const DSPin &p) {
    
    DSPin::iterator iMediaType;
    for (iMediaType = p.begin(); iMediaType != p.end(); ++iMediaType) {
        DSMediaType mt(*iMediaType);
        if ((mt.p->majortype == MEDIATYPE_MPEG2_PES ||
             mt.p->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ) &&
             mt.p->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            return true;

        // elementary stream
        if ((mt.p->majortype == MEDIATYPE_Video)  &&
             mt.p->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            return true;
    }

    return false;
}

///////// DSPin
inline  HRESULT DSPin::IntelligentConnect(DSFilter& Filter1, DSFilterList &intermediates, const DWORD dwFlags, const PIN_DIRECTION pd) {
	bool rc = GetGraph().ConnectPin(*this, Filter1, intermediates, dwFlags, pd);
	if (rc) {
		return NOERROR;
	}
	return E_FAIL;
}

inline DSFilter DSPin::GetFilter(void) const {
    PIN_INFO pinfo;

    HRESULT hr = (*this)->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
        return DSFilter();
    }
    DSFilter pRet;
    pRet.p = pinfo.pFilter;  // directly transfer ownership of ref count

    return pRet;
}

inline DSGraph DSPin::GetGraph(void) const {
    DSFilter f = GetFilter();
    return f.GetGraph();
}

inline bool DSPin::HasCategory(const GUID2 &clsCategory) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::IsPinCategory() pin = " << this), "");
    GUID2 pincat2;
    GetCategory(pincat2);
    return clsCategory == pincat2;
}

#endif
// end of file - dsextend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dvbstsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef DVBSTSIMPL_H
#define DVBSTSIMPL_H

#include "dvbtsimpl.h"

namespace BDATuningModel {

template<class T,
         class TUNEREQUESTTYPE = CDVBTuneRequest,
         class MostDerived = IDVBSTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBSTuningSpaceImpl : 
	public IDVBTuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, 
                               LibID, wMajor, wMinor, tihclass>
{
public:

    long m_HiOsc;
    long m_LoOsc;
    long m_LNBSwitch;
    CComBSTR m_InputRange;
    SpectralInversion m_SpectralInversion;

    IDVBSTuningSpaceImpl() : m_HiOsc(-1), m_LoOsc(-1), m_LNBSwitch(-1), m_InputRange(0), m_SpectralInversion(BDA_SPECTRAL_INVERSION_NOT_SET), 
                             IDVBTuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, 
                                                 LibID, wMajor, wMinor, tihclass>(DVB_Satellite) {}
    virtual ~IDVBSTuningSpaceImpl() {}
    typedef IDVBTuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IDVBSTuningSpaceImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("High Oscillator Frequency", m_HiOsc, VT_I4)
        PROP_DATA_ENTRY("Low Oscillator Frequency", m_LoOsc, VT_I4)
        PROP_DATA_ENTRY("LNB Switch Frequency", m_LNBSwitch, VT_I4)
        PROP_DATA_ENTRY("Input Range", m_InputRange.m_str, VT_BSTR_BLOB)
        PROP_DATA_ENTRY("Spectral Inversion", m_SpectralInversion, VT_I4)
    END_PROPERTY_MAP()

// IDVBSTS
    STDMETHOD(put_SystemType)(DVBSystemType NewSysType)
    {
        if (NewSysType != DVB_Satellite) {
            return DISP_E_TYPEMISMATCH;
        }
		ATL_LOCKT();
        m_SystemType = NewSysType;
        MARK_DIRTY(T);

	    return NOERROR;
    }


    STDMETHOD(get_HighOscillator)(long *pHiOsc)
    {
        try {
            if (!pHiOsc) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pHiOsc = m_HiOsc;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_HighOscillator)(long NewHiOsc)
    {
		ATL_LOCKT();
        m_HiOsc = NewHiOsc;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_LowOscillator)(long *pLoOsc)
    {
        try {
            if (!pLoOsc) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLoOsc = m_LoOsc;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_LowOscillator)(long NewLoOsc)
    {
		ATL_LOCKT();
        m_LoOsc = NewLoOsc;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_LNBSwitch)(long *pLNBSwitch)
    {
        try {
            if (!pLNBSwitch) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLNBSwitch = m_LNBSwitch;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_LNBSwitch)(long NewLNBSwitch)
    {
		ATL_LOCKT();
        m_LNBSwitch = NewLNBSwitch;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_InputRange)(BSTR *pInputRange)
    {
        try {
            if (!pInputRange) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_InputRange.CopyTo(pInputRange);
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_InputRange)(BSTR NewInputRange)
    {
		CHECKBSTRLIMIT(NewInputRange);
		ATL_LOCKT();
        m_InputRange = &NewInputRange;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_SpectralInversion)(SpectralInversion *pSpectralInversion)
    {
        try {
            if (!pSpectralInversion) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pSpectralInversion = m_SpectralInversion;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_SpectralInversion)(SpectralInversion NewSpectralInversion)
    {
		ATL_LOCKT();
        m_SpectralInversion = NewSpectralInversion;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTS);
            pt->m_HiOsc = m_HiOsc;
            pt->m_LoOsc = m_LoOsc;
            pt->m_LNBSwitch = m_LNBSwitch;
            pt->m_InputRange = m_InputRange;
            pt->m_SpectralInversion = m_SpectralInversion;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // DVBSTSIMPL_H
// end of file -- DVBtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\devseq.h ===
//==========================================================================;
//
// Devseq.h : types for device sequences
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DEVSEQ_H
#define DEVSEQ_H

#include <w32extend.h>
#include <fwdseq.h>
#include <tuner.h>
#include <msvidctl.h>

namespace BDATuningModel {};

namespace MSVideoControl {

using namespace BDATuningModel;

typedef CComQIPtr<IMSVidDevice, &__uuidof(IMSVidDevice)> PQDevice;
typedef CComQIPtr<IMSVidInputDevice, &__uuidof(IMSVidInputDevice)> PQInputDevice;
typedef CComQIPtr<IMSVidOutputDevice, &__uuidof(IMSVidOutputDevice)> PQOutputDevice;
typedef CComQIPtr<IMSVidVideoRenderer, &__uuidof(IMSVidVideoRenderer)> PQVideoRenderer;
typedef CComQIPtr<IMSVidAudioRenderer, &__uuidof(IMSVidAudioRenderer)> PQAudioRenderer;
typedef CComQIPtr<IMSVidFeature, &__uuidof(IMSVidFeature)> PQFeature;
#if 0
typedef CComQIPtr<IMSVidDevices, &__uuidof(IMSVidDevices)> PQDevices;
#endif
typedef CComQIPtr<IMSVidInputDevices, &__uuidof(IMSVidInputDevices)> PQInputDevices;
typedef CComQIPtr<IMSVidOutputDevices, &__uuidof(IMSVidOutputDevices)> PQOutputDevices;
typedef CComQIPtr<IMSVidVideoRendererDevices, &__uuidof(IMSVidVideoRendererDevices)> PQVideoRendererDevices;
typedef CComQIPtr<IMSVidAudioRendererDevices, &__uuidof(IMSVidAudioRendererDevices)> PQAudioRendererDevices;
typedef CComQIPtr<IMSVidFeatures, &__uuidof(IMSVidFeatures)> PQFeatures;
typedef std::vector<PQDevice, PQDevice::stl_allocator> DeviceCollection;

// REV2:  since IMSVidXXXXXDevices is an ole collection rather than a com enumerator
// we could do a real random access container for it.  but, since all we need to do here
// is enumerate it, we won't bother to do that work, at least for now.

#if 0
typedef Forward_Sequence<
    PQDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWDevices;
#endif

typedef Forward_Sequence<
    PQInputDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidInputDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWInputDevices;

typedef Forward_Sequence<
    PQOutputDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidOutputDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWOutputDevices;

typedef Forward_Sequence<
    PQVideoRendererDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidVideoRendererDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWVideoRendererDevices;

typedef Forward_Sequence<
    PQAudioRendererDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidAudioRendererDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWAudioRendererDevices;

typedef Forward_Sequence<
    PQFeatures,
    PQEnumVARIANT,
    CComVariant,
    IMSVidFeatures ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWFeatures;
#endif

}; // namespace
// end of file devseq.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\vidctl\dvbtlocatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTLocatorimpl.h : implementation helper template for ATSClocator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef DVBTLOCATORIMPL_H
#define DVBTLOCATORIMPL_H

#include <locatorimpl.h>

namespace BDATuningModel {

template<class T,
         class MostDerived = IDVBTLocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBTLocatorImpl : 
	public ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IDVBTLocator
public:

	typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    typedef IDVBTLocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;

	IDVBTLocatorImpl() : m_Bandwidth(-1),
						 m_LPInnerFECMethod(BDA_FEC_METHOD_NOT_SET),
						 m_LPInnerFECRate(BDA_BCC_RATE_NOT_SET),
						 m_HAlpha(BDA_HALPHA_NOT_SET),
						 m_GuardInterval(BDA_GUARD_NOT_SET),
						 m_XmitMode(BDA_XMIT_MODE_NOT_SET),
						 m_OtherFreqInUse(VARIANT_FALSE) {}

    virtual ~IDVBTLocatorImpl() {}
	long m_Bandwidth;
	FECMethod m_LPInnerFECMethod;
	BinaryConvolutionCodeRate m_LPInnerFECRate;
	HierarchyAlpha m_HAlpha;
	GuardInterval m_GuardInterval;
	TransmissionMode m_XmitMode;
	VARIANT_BOOL m_OtherFreqInUse;

    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Bandwidth", m_Bandwidth, VT_I4)
        PROP_DATA_ENTRY("LPInnerFECMethod", m_LPInnerFECMethod, VT_I4)
        PROP_DATA_ENTRY("LPInnerFECRate", m_LPInnerFECRate, VT_I4)
        PROP_DATA_ENTRY("HierarchyAlpha", m_HAlpha, VT_I4)
        PROP_DATA_ENTRY("GuardInterval", m_GuardInterval, VT_I4)
        PROP_DATA_ENTRY("TransmissionMode", m_XmitMode, VT_I4)
        PROP_DATA_ENTRY("OtherFrequencyInUse", m_OtherFreqInUse, VT_BOOL)
    END_PROP_MAP()

// IDVBTLocator
public:
    STDMETHOD(get_Bandwidth)(/*[out, retval]*/ long *pBandwidth) {
        try {
            if (!pBandwidth) {
  