onCode());
        }

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamGetDisplayEnumerationIndex (
      IN    SAM_HANDLE        DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PUNICODE_STRING   Prefix,
      OUT   PULONG            Index
      )
/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_NO_MORE_ENTRIES - There are no entries for this information class.
                             The returned index is invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    //
    // Check parameters
    //

    if ( !ARGUMENT_PRESENT(Prefix) ) {
        return(STATUS_INVALID_PARAMETER);
    }
    if ( !ARGUMENT_PRESENT(Index) ) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{
        if (DisplayInformation <= DomainDisplayMachine) {
            //
            // Info levels supported via original API in NT1.0
            //

            NtStatus = SamrGetDisplayEnumerationIndex (
                            (SAMPR_HANDLE)RpcContextHandle,
                            DisplayInformation,
                            (PRPC_UNICODE_STRING)Prefix,
                            Index
                            );
        } else {

            //
            // Info levels added in NT1.0A via new API
            //

            NtStatus = SamrGetDisplayEnumerationIndex2 (
                            (SAMPR_HANDLE)RpcContextHandle,
                            DisplayInformation,
                            (PRPC_UNICODE_STRING)Prefix,
                            Index
                            );
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));


}




NTSTATUS
SamOpenGroup(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT PSAM_HANDLE GroupHandle
    )

/*++

Routine Description:

    This API opens an existing group in the account database.  The group
    is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the group must be
    declared at this time.

    This call returns a handle to the newly opened group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.  These access types are reconciled
        with the Discretionary Access Control list of the group to
        determine whether the accesses will be granted or denied.

    GroupId - Specifies the relative ID value of the group to be
        opened.

    GroupHandle - Receives a handle referencing the newly opened
        group.  This handle will be required in successive calls to
        operate on the group.

Return Values:

    STATUS_SUCCESS - The group was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, GroupRpcContextHandle;
    SAMP_HANDLE         SampGroupHandle;

    SampOutputDebugString("SamOpenGroup");


    if (IsBadWritePtr(GroupHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampGroupHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*GroupHandle) = 0;

        NtStatus =
            SamrOpenGroup(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                DesiredAccess,
                GroupId,
                (SAMPR_HANDLE *)&GroupRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampGroupHandle->ContextHandle = GroupRpcContextHandle;
    } else {
        SampFreeHandle(&SampGroupHandle);
    }
    *GroupHandle = SampGroupHandle;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamQueryInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PVOID * Buffer
)

/*++

Routine Description:

    This API retrieves information on the group specified.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ----------------------          ----------------------
        GroupGeneralInformation         GROUP_READ_INFORMATION
        GroupNameInformation            GROUP_READ_INFORMATION
        GroupAttributeInformation       GROUP_READ_INFORMATION
        GroupAdminInformation           GROUP_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer must be freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    SampOutputDebugString("SamQueryInformationGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        NtStatus =
            SamrQueryInformationGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                GroupInformationClass,
                (PSAMPR_GROUP_INFO_BUFFER *)Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if ( ( (NtStatus == RPC_NT_INVALID_TAG)
       ||  (NtStatus == STATUS_INVALID_INFO_CLASS))
      && (GroupInformationClass == GroupReplicationInformation)  ) {

        //
        // GroupReplicationInformation is supported over RPC in the
        // 5.1 release (.NET).  When calling downlevel servers, back down
        // to GroupGeneralInformation which retrieves the necessary information
        // in addition to the potentially expensive MemberCount field.
        //

        RpcTryExcept{

            NtStatus =
                SamrQueryInformationGroup(
                    (SAMPR_HANDLE)RpcContextHandle,
                    GroupGeneralInformation,
                    (PSAMPR_GROUP_INFO_BUFFER *)Buffer
                    );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;

    }

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamSetInformationGroup(
    IN SAM_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PVOID Buffer
)
/*++


Routine Description:

    This API allows the caller to modify group information.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        GroupGeneralInformation         (can't write)

        GroupNameInformation            GROUP_WRITE_ACCOUNT
        GroupAttributeInformation       GROUP_WRITE_ACCOUNT
        GroupAdminInformation           GROUP_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_GROUP - The group specified is unknown.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetInformationGroup");


    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrSetInformationGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                GroupInformationClass,
                Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamAddMemberToGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
)

/*++

Routine Description:

    This API adds a member to a group.  Note that this API requires the
    GROUP_ADD_MEMBER access type for the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    Attributes - The attributes of the group assigned to the user.  The
        attributes assigned here must be compatible with the attributes
        assigned to the group as a whole.  Compatible attribute
        assignments are:

          Mandatory - If the Mandatory attribute is assigned to the
                    group as a whole, then it must be assigned to the
                    group for each member of the group.

          EnabledByDefault - This attribute may be set to any value
                    for each member of the group.  It does not matter
                    what the attribute value for the group as a whole
                    is.

          Enabled - This attribute may be set to any value for each
                    member of the group.  It does not matter what the
                    attribute value for the group as a whole is.

          Owner -   The Owner attribute may be assigned any value.
                    However, if the Owner attribute of the group as a
                    whole is not set, then the value assigned to
                    members is ignored.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.

    STATUS_INVALID_GROUP_ATTRIBUTES - Indicates the group attribute
        values being assigned to the member are not compatible with
        the attribute values of the group as a whole.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    SampOutputDebugString("SamAddMemberToGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrAddMemberToGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId,
                Attributes
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamDeleteGroup(
    IN SAM_HANDLE GroupHandle
)

/*++

Routine Description:

    This API removes a group from the account database.  There may be no
    members in the group or the deletion request will be rejected.  Note
    that this API requires DELETE access to the specific group being
    deleted.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_MEMBER_IN_GROUP - The group still has members.  A group may
        not be deleted unless it has no members.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        LocalHandle;

    SampOutputDebugString("SamDeleteGroup");

    if (!SampIsValidClientHandle(GroupHandle, &LocalHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =  SamrDeleteGroup( &LocalHandle );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampFreeHandle((SAMP_HANDLE *)&GroupHandle);
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamRemoveMemberFromGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId
)

/*++

Routine Description:

    This API removes a single member from a group.  Note that this API
    requires the GROUP_REMOVE_MEMBER access type.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to remove.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_MEMBER_NOT_IN_GROUP - The specified user does not belong
        to the group.

    STATUS_MEMBERS_PRIMARY_GROUP - A user may not be removed from its
        primary group.  The primary group of the user account must first
        be changed.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamRemoveMemberFromGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrRemoveMemberFromGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamGetMembersInGroup(
    IN SAM_HANDLE GroupHandle,
    OUT PULONG * MemberIds,
    OUT PULONG * Attributes,
    OUT PULONG MemberCount
)

/*++

Routine Description:

    This API lists all the members in a group.  This API requires
    GROUP_LIST_MEMBERS access to the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberIds - Receives a pointer to a buffer containing An array of
        ULONGs.  These ULONGs contain the relative IDs of the members
        of the group.  When this information is no longer needed,
        this buffer must be freed using SamFreeMemory().

    Attributes - Receives a pointer to a buffer containing an array of
        ULONGs.  These ULONGs contain the attributes of the
        corresponding member ID returned via the MemberId paramter.

    MemberCount - number of members in the group (and, thus, the
        number relative IDs returned).

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{

    NTSTATUS                    NtStatus;
    PSAMPR_GET_MEMBERS_BUFFER   GetMembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;


    SampOutputDebugString("SamGetMembersInGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    GetMembersBuffer = NULL;

    RpcTryExcept{

        NtStatus =
            SamrGetMembersInGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                &GetMembersBuffer
                );

        //
        // What we get back is the following:
        //
        //               +-------------+
        //     --------->| MemberCount |
        //               |-------------+                    +-------+
        //               |  Members  --|------------------->| Rid-0 |
        //               |-------------|   +------------+   |  ...  |
        //               |  Attributes-|-->| Attribute0 |   |       |
        //               +-------------+   |    ...     |   | Rid-N |
        //                                 | AttributeN |   +-------+
        //                                 +------------+
        //
        // Each block allocated with MIDL_user_allocate.  We return the
        // RID and ATTRIBUTE blocks, and free the block containing
        // the MemberCount ourselves.
        //


        if (NT_SUCCESS(NtStatus)) {
            (*MemberCount)  = GetMembersBuffer->MemberCount;
            (*MemberIds)    = GetMembersBuffer->Members;
            (*Attributes)   = GetMembersBuffer->Attributes;
            MIDL_user_free( GetMembersBuffer );
        } else {

            //
            // Deallocate any returned buffers on error
            //

            if (GetMembersBuffer != NULL) {
                if (GetMembersBuffer->Members != NULL) {
                    MIDL_user_free(GetMembersBuffer->Members);
                }
                if (GetMembersBuffer->Attributes != NULL) {
                    MIDL_user_free(GetMembersBuffer->Attributes);
                }
                MIDL_user_free(GetMembersBuffer);
            }
        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));


}



NTSTATUS
SamSetMemberAttributesOfGroup(
    IN SAM_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
)

/*++

Routine Description:

    This routine modifies the group attributes of a member of the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.  This
        handle must be open for GROUP_ADD_MEMBER access to the group.

    MemberId - Contains the relative ID of member whose attributes
        are to be modified.

    Attributes - The group attributes to set for the member.  These
        attributes must not conflict with the attributes of the group
        as a whole.  See SamAddMemberToGroup() for more information
        on compatible attribute settings.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_USER - The user specified does not exist.

    STATUS_MEMBER_NOT_IN_GROUP - Indicates the specified relative ID
        is not a member of the group.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetMemberAttributesOfGroup");

    if (!SampIsValidClientHandle(GroupHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrSetMemberAttributesOfGroup(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId,
                Attributes
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    )

/*++

Routine Description:

    This API opens an existing Alias object.  The Alias is specified by
    a ID value that is relative to the SID of the domain.  The operations
    that will be performed on the Alias must be declared at this time.

    This call returns a handle to the newly opened Alias that may be used
    for successive operations on the Alias.  This handle may be closed
    with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the alias.

    AliasId - Specifies the relative ID value of the Alias to be opened.

    AliasHandle - Receives a handle referencing the newly opened Alias.
        This handle will be required in successive calls to operate on
        the Alias.

Return Values:

    STATUS_SUCCESS - The Alias was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_ALIAS - The specified Alias does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, AliasRpcContextHandle;
    SAMP_HANDLE         SampAliasHandle;

    SampOutputDebugString("SamOpenAlias");


    if (IsBadWritePtr(AliasHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampAliasHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*AliasHandle) = 0;

        NtStatus =
            SamrOpenAlias(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                DesiredAccess,
                AliasId,
                (SAMPR_HANDLE *)&AliasRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    if (NT_SUCCESS(NtStatus)) {
        SampAliasHandle->ContextHandle = AliasRpcContextHandle;
    } else {
        SampFreeHandle(&SampAliasHandle);
    }
    *AliasHandle = SampAliasHandle;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamQueryInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PVOID * Buffer
)

/*++

Routine Description:

    This API retrieves information on the alias specified.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ----------------------          ----------------------
        AliasGeneralInformation         ALIAS_READ_INFORMATION
        AliasNameInformation            ALIAS_READ_INFORMATION
        AliasAdminInformation           ALIAS_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer and any memory pointed to through this buffer must be
        freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamQueryInformationAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }


    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        NtStatus =
            SamrQueryInformationAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                AliasInformationClass,
                (PSAMPR_ALIAS_INFO_BUFFER *)Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamSetInformationAlias(
    IN SAM_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PVOID Buffer
)
/*++


Routine Description:

    This API allows the caller to modify alias information.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        AliasGeneralInformation         (can't write)

        AliasNameInformation            ALIAS_WRITE_ACCOUNT
        AliasAdminInformation           ALIAS_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_ALIAS - The alias specified is unknown.

    STATUS_SPECIAL_ALIAS - The alias specified is a special alias and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamSetInformationAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrSetInformationAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                AliasInformationClass,
                Buffer
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));
}



NTSTATUS
SamDeleteAlias(
    IN SAM_HANDLE AliasHandle
)

/*++

Routine Description:

    This API deletes an Alias from the account database.  The Alias does
    not have to be empty.

    Note that following this call, the AliasHandle is no longer valid.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        LocalHandle;

    SampOutputDebugString("SamDeleteAlias");

    if (!SampIsValidClientHandle(AliasHandle, &LocalHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =  SamrDeleteAlias( &LocalHandle );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampFreeHandle((SAMP_HANDLE *)&AliasHandle);
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamAddMemberToAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )

/*++

Routine Description:

    This API adds a member to an Alias.


Parameters:

    AliasHandle - The handle of an opened Alias object to operate on.
        The handle must be open for ALIAS_ADD_MEMBER.

    MemberId - The SID of the member to add.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_MEMBER_IN_ALIAS - The member already belongs to the Alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.
        The domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamAddMemberToAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrAddMemberToAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

#if DBG
    if (!NT_SUCCESS(NtStatus))
    {
        DbgPrint("SAM: SamAddMemberToAlias() failed. NtStatus 0x%x\n", NtStatus);
    }
#endif // DBG

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamRemoveMemberFromAlias(
    IN SAM_HANDLE AliasHandle,
    IN PSID MemberId
    )

/*++

Routine Description:

    This API removes a member from an Alias.


Parameters:

    AliasHandle - The handle of an opened Alias object to operate on.
        The handle must be open for ALIAS_REMOVE_MEMBER.

    MemberId - The SID of the member to remove.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_SPECIAL_ALIAS - The group specified is a special alias and
        cannot be operated on in the requested fashion.

    STATUS_MEMBER_NOT_IN_ALIAS - The specified member does not belong to
        the Alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.
        The domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamRemoveMemberFromAlias");

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrRemoveMemberFromAlias(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamRemoveMemberFromForeignDomain(
    IN SAM_HANDLE DomainHandle,
    IN PSID MemberId
    )

/*++

Routine Description:

    This API removes a member from an all Aliases in the domain specified.


Parameters:

    DomainHandle - The handle of an opened domain to operate in.  All
        aliases in the domain that the member is a part of must be
        accessible by the caller with ALIAS_REMOVE_MEMBER.

    MemberId - The SID of the member to remove.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the correct
        state (disabled or enabled) to perform the requested operation.
        The domain server must be enabled for this operation.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the incorrect
        role (primary or backup) to perform the requested operation.


--*/

{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamRemoveMemberFromForeignDomain");

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =
            SamrRemoveMemberFromForeignDomain(
                (SAMPR_HANDLE)RpcContextHandle,
                MemberId
                );



    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}




NTSTATUS
SamGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSID **MemberIds,
    OUT PULONG MemberCount
    )

/*++

Routine Description:

    This API lists all members in an Alias.  This API requires
    ALIAS_LIST_MEMBERS access to the Alias.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Receives a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members of the
        Alias.  When this information is no longer needed, this buffer
        must be freed using SamFreeMemory().

    MemberCount - number of members in the Alias (and, thus, the number
        of relative IDs returned).

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there are
        no additional entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/

{
    NTSTATUS                    NtStatus;
    SAMPR_PSID_ARRAY            MembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;

    SampOutputDebugString("SamGetMembersInAlias");

    //
    // Validate parameters
    //

    if ( !ARGUMENT_PRESENT(MemberIds) ) {
        return(STATUS_INVALID_PARAMETER_2);
    }
    if ( !ARGUMENT_PRESENT(MemberCount) ) {
        return(STATUS_INVALID_PARAMETER_3);
    }

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    RpcTryExcept{

        //
        // Prepare for failure
        //

        *MemberIds = NULL;
        *MemberCount = 0;

        //
        // Call the server ...
        //

        MembersBuffer.Sids = NULL;

        NtStatus = SamrGetMembersInAlias(
                        (SAMPR_HANDLE)RpcContextHandle,
                        (PSAMPR_PSID_ARRAY_OUT)&MembersBuffer
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Return the member list
            //

            *MemberCount = MembersBuffer.Count;
            *MemberIds = (PSID *)(MembersBuffer.Sids);

        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;



    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamAddMultipleMembersToAlias(
    IN SAM_HANDLE   AliasHandle,
    IN PSID         *MemberIds,
    IN ULONG        MemberCount
    )

/*++

Routine Description:

    This API adds the SIDs listed in MemberIds to the specified Alias.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Points to an array of SID pointers containing MemberCount
        entries.

    MemberCount - number of members in the array.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now members of the alias.  However, some of
        the members may already have been members of the alias (this is
        NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_MEMBER - The member has the wrong account type.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.
--*/

{
    NTSTATUS                    NtStatus;
    SAMPR_PSID_ARRAY            MembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;

    SampOutputDebugString("SamAddMultipleMembersToAlias");

    //
    // Validate parameters
    //

    if ( !ARGUMENT_PRESENT(MemberIds) ) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    RpcTryExcept{

        //
        // Call the server ...
        //

        MembersBuffer.Count = MemberCount;
        MembersBuffer.Sids  = (PSAMPR_SID_INFORMATION)MemberIds;

        NtStatus = SamrAddMultipleMembersToAlias(
                        (SAMPR_HANDLE)RpcContextHandle,
                        &MembersBuffer
                        );


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamRemoveMultipleMembersFromAlias(
    IN SAM_HANDLE   AliasHandle,
    IN PSID         *MemberIds,
    IN ULONG        MemberCount
    )

/*++

Routine Description:

    This API Removes the SIDs listed in MemberIds from the specified Alias.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Points to an array of SID pointers containing MemberCount
        entries.

    MemberCount - number of members in the array.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now NOT members of the alias.  However, some of
        the members may already have not been members of the alias (this
        is NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/

{
    NTSTATUS                    NtStatus;
    SAMPR_PSID_ARRAY            MembersBuffer;
    SAMPR_HANDLE                RpcContextHandle;

    SampOutputDebugString("SamRemoveMultipleMembersFromAlias");

    //
    // Validate parameters
    //

    if ( !ARGUMENT_PRESENT(MemberIds) ) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if (!SampIsValidClientHandle(AliasHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    RpcTryExcept{

        //
        // Call the server ...
        //

        MembersBuffer.Count = MemberCount;
        MembersBuffer.Sids  = (PSAMPR_SID_INFORMATION)MemberIds;

        NtStatus = SamrRemoveMultipleMembersFromAlias(
                        (SAMPR_HANDLE)RpcContextHandle,
                        &MembersBuffer
                        );


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamOpenUser(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG UserId,
    OUT PSAM_HANDLE UserHandle
    )
/*++

Routine Description:

    This API opens an existing user in the account database.  The user
    is specified by SID value.  The operations that will be performed on
    the user must be declared at this time.

    This call returns a handle to the newly opened user that may be used
    for successive operations on the user.  This handle may be closed
    with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.  These access types are reconciled
        with the Discretionary Access Control list of the user to
        determine whether the accesses will be granted or denied.

    UserId - Specifies the relative ID value of the user account to
        be opened.

    UserHandle - Receives a handle referencing the newly opened User.
        This handle will be required in successive calls to operate
        on the user.

Return Values:

    STATUS_SUCCESS - The group was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_USER - The specified user does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.



--*/
{

    NTSTATUS            NtStatus;
    SAMPR_HANDLE        DomainRpcContextHandle, UserRpcContextHandle;
    SAMP_HANDLE         SampUserHandle;

    SampOutputDebugString("SamOpenUser");

    if (IsBadWritePtr(UserHandle, sizeof(SAM_HANDLE))) {
        return STATUS_INVALID_PARAMETER;
    }

    if (!SampIsValidClientHandle(DomainHandle, &DomainRpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Prepare the new handle to return
    //
    NtStatus = SampCreateNewHandle((SAMP_HANDLE)DomainHandle,
                                   NULL,
                                   &SampUserHandle);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        (*UserHandle) = 0;

        NtStatus =
            SamrOpenUser(
                (SAMPR_HANDLE)DomainRpcContextHandle,
                DesiredAccess,
                UserId,
                (SAMPR_HANDLE *)&UserRpcContextHandle
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    if (NT_SUCCESS(NtStatus)) {
        SampUserHandle->ContextHandle = UserRpcContextHandle;
    } else {
        SampFreeHandle(&SampUserHandle);
    }
    *UserHandle = SampUserHandle;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamDeleteUser(
    IN SAM_HANDLE UserHandle
)

/*++

Routine Description:

    This API deletes a user from the account database.  If the account
    being deleted is the last account in the database in the ADMIN
    group, then STATUS_LAST_ADMIN is returned, and the Delete fails.  Note
    that this API required DOMAIN_DELETE_USER access.

    Note that following this call, the UserHandle is no longer valid.


Parameters:

    UserHandle - The handle of an opened user to operate on.  The handle
        must be opened for DELETE access.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_LAST_ADMIN - Cannot delete the last administrator.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        LocalHandle;

    SampOutputDebugString("SamDeleteUser");

    if (!SampIsValidClientHandle(UserHandle, &LocalHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus =  SamrDeleteUser( &LocalHandle );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if (NT_SUCCESS(NtStatus)) {
        SampFreeHandle((SAMP_HANDLE *)&UserHandle);
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamQueryInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    OUT PVOID * Buffer
)

/*++


Routine Description:

    This API looks up some level of information about a particular user.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    UserInformationClass - Class of information desired about this
        user.  The accesses required for each class is shown below:

        Info Level                      Required Access Type
        ----------------------          --------------------------

        UserGeneralInformation          USER_READ_GENERAL
        UserPreferencesInformation      USER_READ_PREFERENCES
        UserLogonInformation            USER_READ_GENERAL and
                                        USER_READ_PREFERENCES and
                                        USER_READ_LOGON

        UserLogonHoursInformation       USER_READ_LOGON

        UserAccountInformation          USER_READ_GENERAL and
                                        USER_READ_PREFERENCES and
                                        USER_READ_LOGON and
                                        USER_READ_ACCOUNT

        UserParametersInformation       USER_READ_ACCOUNT

        UserNameInformation             USER_READ_GENERAL
        UserAccountNameInformation      USER_READ_GENERAL
        UserFullNameInformation         USER_READ_GENERAL
        UserPrimaryGroupInformation     USER_READ_GENERAL
        UserHomeInformation             USER_READ_LOGON
        UserScriptInformation           USER_READ_LOGON
        UserProfileInformation          USER_READ_LOGON
        UserAdminCommentInformation     USER_READ_GENERAL
        UserWorkStationsInformation     USER_READ_LOGON

        UserSetPasswordInformation      (Can't query)

        UserControlInformation          USER_READ_ACCOUNT
        UserExpiresInformation          USER_READ_ACCOUNT

        UserInternal1Information        (trusted client use only)
        UserInternal2Information        (trusted client use only)

        UserAllInformation              Will return fields that user
                                        has access to.

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer must be freed using SamFreeMemory().


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    SampOutputDebugString("SamQueryInformationUser");


    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    (*Buffer) = NULL;

    RpcTryExcept{

        NtStatus =
            SamrQueryInformationUser(
                (SAMPR_HANDLE)RpcContextHandle,
                UserInformationClass,
                (PSAMPR_USER_INFO_BUFFER *)Buffer
                );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SampOwfPassword(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING UnicodePassword,
    IN BOOLEAN IgnorePasswordRestrictions,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN LmPasswordPresent,
    OUT PLM_OWF_PASSWORD LmOwfPassword
)

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    makes sure it meets our high standards for password quality,
    converts it to an LM password if possible, and runs both passwords
    through a one-way function (OWF).

Parameters:

    RpcContextHandle - The handle of an opened user to operate on.

    UnicodePassword - the cleartext unicode NT password.

    IgnorePasswordRestrictions - When TRUE, indicates that the password
        should be accepted as legitimate regardless of what the domain's
        password restrictions indicate (e.g., can be less than
        required password length).  This is expected to be used when
        setting up a new machine account.

    NtPasswordPresent - receives a boolean that says whether the NT
        password is present or not.

    NtOwfPassword - receives the OWF'd version of the NT password.

    LmPasswordPresent - receives a boolean that says whether the LM
        password is present or not.

    LmOwfPassword - receives the OWF'd version of the LM password.


Return Values:

    STATUS_SUCCESS - the service has completed.  The booleans say which
        of the OWFs are valid.

    Errors are returned by SampCheckPasswordRestrictions(),
    RtlCalculateNtOwfPassword(), SampCalculateLmPassword(), and
    RtlCalculateLmOwfPassword().

--*/
{
    NTSTATUS            NtStatus;
    PCHAR               LmPasswordBuffer;
    BOOLEAN             UseOwfPasswords;

    //
    // We ignore the UseOwfPasswords flag since we already are.
    //

    if (IgnorePasswordRestrictions) {
        NtStatus = STATUS_SUCCESS;
    } else {
        NtStatus = SampCheckPasswordRestrictions(
                       RpcContextHandle,
                       UnicodePassword,
                       &UseOwfPasswords
                       );
    }

    //
    // Compute the NT One-Way-Function of the password
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        *NtPasswordPresent = TRUE;

        NtStatus = RtlCalculateNtOwfPassword(
                    UnicodePassword,
                    NtOwfPassword
                    );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Calculate the LM version of the password
            //

            NtStatus = SampCalculateLmPassword(
                        UnicodePassword,
                        &LmPasswordBuffer);

            if (NT_SUCCESS(NtStatus)) {

                //
                // Compute the One-Way-Function of the LM password
                //

                *LmPasswordPresent = TRUE;

                NtStatus = RtlCalculateLmOwfPassword(
                                LmPasswordBuffer,
                                LmOwfPassword);

                //
                // We're finished with the LM password
                //

                MIDL_user_free(LmPasswordBuffer);
            }
        }
    }

    return( NtStatus );
}




NTSTATUS
SampEncryptClearPasswordNew(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING UnicodePassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD_NEW EncryptedUserPassword
)

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    and encrypts it with the session key.

    Note: The encryption algorithm changed since Win2K Service Pack 2.

    Prior to Win2000 SP2:

        Clear password is encrypted by session key directly.

        This exposes the problem, which clear text password can be cracked
        by examining two network frames and apply certain encryption
        algorithm. Refer to WinSE Bug 9254 / 9587 for more details.

    The Fix:

        Apply MD5 hash on a random bit stream, then use Session key to hash
        it again, then use the hash result to encrypt clear text password.

    Client Side:

        NT4, Windows 2000 client without this fix will continue to use the old
        encryption method with Information Level - UserInternal4Information or
        UserInternal5Information.

        NT4 with this fix, Windows 2000 SP2 and above, (Whistler) will have
        this fix and using UserInternal4InformationNew and
        UserInternal5InformationNew.

    The server side:

        Without the fix, server side will continue to use the old encryption
        method.

        With the fix, server side will check UserInformationClass to determine
        which decryption method to use.

Parameters:

    RpcContextHandle - SAM_HANDLE used to acquiring a session key.

    UnicodePassword - the cleartext unicode NT password.

    EncryptedUserPassword - receives the encrypted cleartext password.

Return Values:

    STATUS_SUCCESS - the service has completed.  The booleans say which
        of the OWFs are valid.


--*/
{
    NTSTATUS             NtStatus;
    USER_SESSION_KEY     UserSessionKey;
    struct RC4_KEYSTRUCT Rc4Key;
    PSAMPR_USER_PASSWORD_NEW UserPassword = (PSAMPR_USER_PASSWORD_NEW) EncryptedUserPassword;
    MD5_CTX              Md5Context;


    if (UnicodePassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    NtStatus = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)RpcContextHandle,
                   &UserSessionKey
                   );

    if (NT_SUCCESS(NtStatus))
    {
        RtlCopyMemory(
            ((PCHAR) UserPassword->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                UnicodePassword->Length,
            UnicodePassword->Buffer,
            UnicodePassword->Length
            );
        UserPassword->Length = UnicodePassword->Length;

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        UnicodePassword->Length,
                    (PUCHAR) UserPassword->Buffer
                    );
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampRandomFill(
                    (SAM_PASSWORD_ENCRYPTION_SALT_LEN),
                    (PUCHAR) UserPassword->ClearSalt
                    );
    }

    if (NT_SUCCESS(NtStatus))
    {

        MD5Init(&Md5Context);

        MD5Update(&Md5Context,
                  (PUCHAR) UserPassword->ClearSalt,
                  SAM_PASSWORD_ENCRYPTION_SALT_LEN
                  );

        MD5Update(&Md5Context,
                  (PUCHAR) &UserSessionKey,
                  sizeof(UserSessionKey)
                  );

        MD5Final(&Md5Context);

        //
        // Convert the MD5 Hash into an RC4 key
        //

        rc4_key(
            &Rc4Key,
            MD5DIGESTLEN,
            Md5Context.digest
            );

        rc4(&Rc4Key,
            sizeof(SAMPR_ENCRYPTED_USER_PASSWORD_NEW) - SAM_PASSWORD_ENCRYPTION_SALT_LEN,
            (PUCHAR) UserPassword
            );

    }

    return( NtStatus );
}



NTSTATUS
SampEncryptClearPassword(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING UnicodePassword,
    OUT PSAMPR_ENCRYPTED_USER_PASSWORD EncryptedUserPassword
)

/*++

Routine Description:

    This routine takes a cleartext unicode NT password from the user,
    and encrypts it with the session key.

Parameters:

    RpcContextHandle - SAM_HANDLE used to acquiring a session key.

    UnicodePassword - the cleartext unicode NT password.

    EncryptedUserPassword - receives the encrypted cleartext password.

Return Values:

    STATUS_SUCCESS - the service has completed.  The booleans say which
        of the OWFs are valid.


--*/
{
    NTSTATUS             NtStatus;
    USER_SESSION_KEY     UserSessionKey;
    struct RC4_KEYSTRUCT Rc4Key;
    PSAMPR_USER_PASSWORD UserPassword = (PSAMPR_USER_PASSWORD) EncryptedUserPassword;

    if (UnicodePassword->Length > SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    NtStatus = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)RpcContextHandle,
                   &UserSessionKey
                   );

    //
    // Convert the session key into an RC4 key
    //

    if (NT_SUCCESS(NtStatus)) {

        rc4_key(
            &Rc4Key,
            sizeof(USER_SESSION_KEY),
            (PUCHAR) &UserSessionKey
            );

        RtlCopyMemory(
            ((PCHAR) UserPassword->Buffer) +
                (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                UnicodePassword->Length,
            UnicodePassword->Buffer,
            UnicodePassword->Length
            );
        UserPassword->Length = UnicodePassword->Length;

        NtStatus = SampRandomFill(
                    (SAM_MAX_PASSWORD_LENGTH * sizeof(WCHAR)) -
                        UnicodePassword->Length,
                    (PUCHAR) UserPassword->Buffer
                    );

        if (NT_SUCCESS(NtStatus)) {
            rc4(
                &Rc4Key,
                sizeof(SAMPR_ENCRYPTED_USER_PASSWORD),
                (PUCHAR) UserPassword
                );

        }


    }


    return( NtStatus );
}






NTSTATUS
SampEncryptOwfs(
    IN SAMPR_HANDLE RpcContextHandle,
    IN BOOLEAN NtPasswordPresent,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN BOOLEAN LmPasswordPresent,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
)

/*++

Routine Description:

    This routine takes NT and LM passwords that have already been OWF'd,
    and encrypts them so that they can be safely sent to the server.


Parameters:

    RpcContextHandle - The handle of an opened user to operate on.

    NtPasswordPresent - indicates whether NtOwfPassword is valid or not.

    NtOwfPassword - an OWF'd NT password, if NtPasswordPresent is true.

    EncryptedNtOwfPassword - an encrypted version of the OWF'd NT password
        that can be safely sent to the server.

    LmPasswordPresent - indicates whether LmOwfPassword is valid or not.

    LmOwfPassword - an OWF'd LM password, if LmPasswordPresent is true.

    EncryptedLmOwfPassword - an encrypted version of the OWF'd LM password
        that can be safely sent to the server.

Return Values:

    STATUS_SUCCESS - the passwords were encrypted and may be sent to the
        server.

    Errors may be returned by RtlGetUserSessionKeyClient(),
    RtlEncryptNtOwfPwdWithUserKey(), and RtlEncryptLmOwfPwdWithUserKey().

--*/
{
    NTSTATUS            NtStatus;
    USER_SESSION_KEY    UserSessionKey;


    NtStatus = RtlGetUserSessionKeyClient(
                   (RPC_BINDING_HANDLE)RpcContextHandle,
                   &UserSessionKey
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        if (NtPasswordPresent) {

            //
            // Encrypt the Nt OWF Password with the user session key
            // and store it the buffer to send
            //

            NtStatus = RtlEncryptNtOwfPwdWithUserKey(
                           NtOwfPassword,
                           &UserSessionKey,
                           EncryptedNtOwfPassword
                           );
        }


        if ( NT_SUCCESS( NtStatus ) ) {

            if (LmPasswordPresent) {

                //
                // Encrypt the Lm OWF Password with the user session key
                // and store it the buffer to send
                //

                NtStatus = RtlEncryptLmOwfPwdWithUserKey(
                               LmOwfPassword,
                               &UserSessionKey,
                               EncryptedLmOwfPassword
                               );
            }
        }
    }

    return( NtStatus );
}



NTSTATUS
SampSetInfoUserUseOldInfoClass(
    IN SAMPR_HANDLE RpcContextHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer,
    IN PUNICODE_STRING  pClearPassword
    )
/*++

Routine Description:

    This routine reverts password encryption to old algorithm with old
    UserInformationClass, so that new Client (with the patch) can talk
    to the old server (without fix).

Parameters:

    RpcContextHandle - SAM Handle

    UserInformationClass - Indicates Information Level,

    BufferToPass - User attribute to set, including password

    pClearPassword - Pointer to clear text password.

Return Value:

    STATUS_SUCCESS - success
    error code

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SAMPR_USER_INTERNAL4_INFORMATION Internal4RpcBuffer;
    SAMPR_USER_INTERNAL5_INFORMATION Internal5RpcBuffer;
    USER_INFORMATION_CLASS  ClassToUse;
    PVOID                   BufferToPass = NULL;

    if (UserInternal4InformationNew == UserInformationClass)
    {
        ClassToUse = UserInternal4Information;

        Internal4RpcBuffer.I1 = ((PSAMPR_USER_INTERNAL4_INFORMATION_NEW)Buffer)->I1;

        BufferToPass = &Internal4RpcBuffer;

        NtStatus = SampEncryptClearPassword(
                            RpcContextHandle,
                            pClearPassword,
                            &Internal4RpcBuffer.UserPassword
                            );

        RtlZeroMemory(
                &Internal4RpcBuffer.I1.NtOwfPassword,
                sizeof(UNICODE_STRING)
                );

    }
    else if (UserInternal5InformationNew == UserInformationClass)
    {
        ClassToUse = UserInternal5Information;

        Internal5RpcBuffer.PasswordExpired =
                ((PSAMPR_USER_INTERNAL5_INFORMATION_NEW)Buffer)->PasswordExpired;

        BufferToPass = &Internal5RpcBuffer;

        NtStatus = SampEncryptClearPassword(
                            RpcContextHandle,
                            pClearPassword,
                            &Internal5RpcBuffer.UserPassword
                            );
    }
    else
    {
        NtStatus = STATUS_INTERNAL_ERROR;
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SamrSetInformationUser2(
                        (SAMPR_HANDLE)RpcContextHandle,
                        ClassToUse,
                        BufferToPass
                        );
    }

    return( NtStatus );
}



NTSTATUS
SamSetInformationUser(
    IN SAM_HANDLE UserHandle,
    IN USER_INFORMATION_CLASS UserInformationClass,
    IN PVOID Buffer
)

/*++


Routine Description:

    This API modifies information in a user record.  The data modified
    is determined by the UserInformationClass parameter.  To change
    information here requires access to the user object defined above.
    Each structure has both a read and write access type associated with
    it.  In general, a user may call GetInformation with class
    UserLogonInformation, but may only call SetInformation with class
    UserPreferencesInformation.  Access type USER_WRITE_ACCOUNT allows
    changes to be made to all fields.

    NOTE: If the password is set to a new password then the password-
    set timestamp is reset as well.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    UserInformationClass - Class of information provided.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ------------------------
        UserGeneralInformation          (Can't set)

        UserPreferencesInformation      USER_WRITE_PREFERENCES

        UserParametersInformation       USER_WRITE_ACCOUNT

        UserLogonInformation            (Can't set)

        UserLogonHoursInformation       USER_WRITE_ACCOUNT

        UserAccountInformation          (Can't set)

        UserNameInformation             USER_WRITE_ACCOUNT
        UserAccountNameInformation      USER_WRITE_ACCOUNT
        UserFullNameInformation         USER_WRITE_ACCOUNT
        UserPrimaryGroupInformation     USER_WRITE_ACCOUNT
        UserHomeInformation             USER_WRITE_ACCOUNT
        UserScriptInformation           USER_WRITE_ACCOUNT
        UserProfileInformation          USER_WRITE_ACCOUNT
        UserAdminCommentInformation     USER_WRITE_ACCOUNT
        UserWorkStationsInformation     USER_WRITE_ACCOUNT
        UserSetPasswordInformation      USER_FORCE_PASSWORD_CHANGE (also see note below)
        UserControlInformation          USER_WRITE_ACCOUNT
        UserExpiresInformation          USER_WRITE_ACCOUNT
        UserInternal1Information        USER_FORCE_PASSWORD_CHANGE (also see note below)
        UserInternal2Information        (trusted client use only)
        UserAllInformation              Will set fields that user
                                        specifies, if accesses are
                                        held as described above.


        NOTE: When setting a password (with either
              UserSetPasswordInformation or UserInternal1Information),
              you MUST open the user account via a DomainHandle that
              was opened for DOMAIN_READ_PASSWORD_PARAMETERS.

    Buffer - Buffer containing a user info struct.





Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMPR_USER_INTERNAL1_INFORMATION Internal1RpcBuffer;
    USER_INTERNAL1_INFORMATION       Internal1Buffer;
    SAMPR_USER_INTERNAL4_INFORMATION_NEW Internal4RpcBufferNew;
    SAMPR_USER_INTERNAL5_INFORMATION_NEW Internal5RpcBufferNew;
    PVOID                            BufferToPass;
    PUSER_ALL_INFORMATION            UserAll;
    USER_ALL_INFORMATION             LocalAll;
    NTSTATUS                         NtStatus = STATUS_SUCCESS;
    BOOLEAN                          IgnorePasswordRestrictions;
    ULONG                            Pass = 0;
    USER_INFORMATION_CLASS           ClassToUse = UserInformationClass;
    BOOLEAN                          SendOwfs = FALSE;
    SAMPR_HANDLE                     RpcContextHandle;
    PUNICODE_STRING                  pClearPassword = NULL;

    SampOutputDebugString("SamSetInformationUser");

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    do
    {

        RpcTryExcept{

            //
            // Normally just pass the info buffer through to rpc
            //

            BufferToPass = Buffer;


            //
            // Deal with special cases
            //

            switch (UserInformationClass) {


            case UserPreferencesInformation: {

                //
                // Field is unused, but make sure RPC doesn't choke on it.
                //

                ((PUSER_PREFERENCES_INFORMATION)(Buffer))->Reserved1.Length = 0;
                ((PUSER_PREFERENCES_INFORMATION)(Buffer))->Reserved1.MaximumLength = 0;
                ((PUSER_PREFERENCES_INFORMATION)(Buffer))->Reserved1.Buffer = NULL;

                break;
            }

            case UserSetPasswordInformation:

                if (Pass == 0) {

                    //
                    // On the zeroth pass try sending a UserInternal5 structure.
                    // This is only available on 3.51 and above releases.
                    //

                    //
                    // Check password restrictions.
                    //

                    NtStatus = SampCheckPasswordRestrictions(
                                    RpcContextHandle,
                                    &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password,
                                    &SendOwfs
                                    );

                    //
                    // If password restrictions told us we could send reversibly
                    // encrypted passwords, compute them. Otherwise drop through
                    // to the OWF case.
                    //

                    if (!SendOwfs) {

                        //
                        // Encrypt the cleatext password - we don't need to
                        // restrictions because that can be done on the server.
                        //

                        NtStatus = SampEncryptClearPasswordNew(
                                        RpcContextHandle,
                                        &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password,
                                        &Internal5RpcBufferNew.UserPassword
                                        );

                        if (!NT_SUCCESS(NtStatus)) {
                            break;
                        }

                        pClearPassword = &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password;

                        Internal5RpcBufferNew.PasswordExpired =
                            ((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->PasswordExpired;


                        //
                        // Set the class and buffer to send over.
                        //

                        ClassToUse = UserInternal5InformationNew;
                        BufferToPass = &Internal5RpcBufferNew;
                        break;

                    }

                } else {

                    //
                    // Set the pass counter to one since we aren't trying a new
                    // interface and don't want to retry.
                    //

                    Pass = 1;
                    SendOwfs = TRUE;
                }

                ASSERT(SendOwfs);

                //
                // We're going to calculate the OWFs for the password and
                // turn this into an INTERNAL1 set info request by dropping
                // through to the INTERNAL1 code with Buffer pointing at our
                // local INTERNAL1 buffer.  First, make sure that the password
                // meets our quality requirements.
                //

                NtStatus = SampOwfPassword(
                               RpcContextHandle,
                               &((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->Password,
                               FALSE,      // Don't ignore password restrictions
                               &Internal1Buffer.NtPasswordPresent,
                               &Internal1Buffer.NtOwfPassword,
                               &Internal1Buffer.LmPasswordPresent,
                               &Internal1Buffer.LmOwfPassword
                               );

                if (!NT_SUCCESS(NtStatus)) {
                    break;
                }


                //
                // Copy the PasswordExpired flag
                //

                Internal1Buffer.PasswordExpired =
                    ((PUSER_SET_PASSWORD_INFORMATION)(Buffer))->PasswordExpired;


                //
                // We now have a USER_INTERNAL1_INFO buffer in Internal1Buffer.
                // Point Buffer at Internal1buffer and drop through to the code
                // that handles INTERNAL1 requests

                Buffer = &Internal1Buffer;
                ClassToUse = UserInternal1Information;

                //
                // drop through.....
                //


            case UserInternal1Information:


                //
                // We're going to pass a different data structure to rpc
                //

                BufferToPass = &Internal1RpcBuffer;


                //
                // Copy the password present flags
                //

                Internal1RpcBuffer.NtPasswordPresent =
                    ((PUSER_INTERNAL1_INFORMATION)Buffer)->NtPasswordPresent;

                Internal1RpcBuffer.LmPasswordPresent =
                    ((PUSER_INTERNAL1_INFORMATION)Buffer)->LmPasswordPresent;


                //
                // Copy the PasswordExpired flag
                //

                Internal1RpcBuffer.PasswordExpired =
                    ((PUSER_INTERNAL1_INFORMATION)Buffer)->PasswordExpired;


                //
                // Encrypt the OWFs with the user session key before we send
                // them over the Rpc link
                //

                NtStatus = SampEncryptOwfs(
                               RpcContextHandle,
                               Internal1RpcBuffer.NtPasswordPresent,
                               &((PUSER_INTERNAL1_INFORMATION)Buffer)->NtOwfPassword,
                               &Internal1RpcBuffer.EncryptedNtOwfPassword,
                               Internal1RpcBuffer.LmPasswordPresent,
                               &((PUSER_INTERNAL1_INFORMATION)Buffer)->LmOwfPassword,
                               &Internal1RpcBuffer.EncryptedLmOwfPassword
                               );

                break;



            case UserAllInformation:

                UserAll = (PUSER_ALL_INFORMATION)Buffer;

                //
                // If the caller is passing passwords we need to convert them
                // into OWFs and encrypt them.
                //

                if (UserAll->WhichFields & (USER_ALL_LMPASSWORDPRESENT |
                                            USER_ALL_NTPASSWORDPRESENT) ) {

                    //
                    // We'll need a private copy of the buffer which we can edit
                    // and then send over RPC.
                    //




                    if (UserAll->WhichFields & USER_ALL_OWFPASSWORD) {

                        LocalAll = *UserAll;
                        BufferToPass = &LocalAll;
                        SendOwfs = TRUE;

                        //
                        // The caller is passing OWFS directly
                        // Check they're valid and copy them into the
                        // Internal1Buffer in preparation for encryption.
                        //

                        if (LocalAll.WhichFields & USER_ALL_NTPASSWORDPRESENT) {

                            if (LocalAll.NtPasswordPresent) {

                                if (LocalAll.NtPassword.Length != NT_OWF_PASSWORD_LENGTH) {
                                    NtStatus = STATUS_INVALID_PARAMETER;
                                } else {
                                    Internal1Buffer.NtOwfPassword =
                                      *((PNT_OWF_PASSWORD)LocalAll.NtPassword.Buffer);
                                }

                            } else {
                                LocalAll.NtPasswordPresent = FALSE;
                            }
                        }

                        if (LocalAll.WhichFields & USER_ALL_LMPASSWORDPRESENT) {

                            if (LocalAll.LmPasswordPresent) {

                                if (LocalAll.LmPassword.Length != LM_OWF_PASSWORD_LENGTH) {
                                    NtStatus = STATUS_INVALID_PARAMETER;
                                } else {
                                    Internal1Buffer.LmOwfPassword =
                                      *((PNT_OWF_PASSWORD)LocalAll.LmPassword.Buffer);
                                }

                            } else {
                                LocalAll.LmPasswordPresent = FALSE;
                            }
                        }


                        //
                        // Always remove the OWF_PASSWORDS flag. This is used
                        // only on the client side to determine the mode
                        // of password input and will be rejected by the server
                        //

                        LocalAll.WhichFields &= ~USER_ALL_OWFPASSWORD;



                    } else {



                        //
                        // The caller is passing text passwords.
                        // Check for validity and convert to OWFs.
                        //

                        if (UserAll->WhichFields & USER_ALL_LMPASSWORDPRESENT) {

                            //
                            // User clients are only allowed to put a unicode string
                            // in the NT password. We always calculate the LM password
                            //

                            NtStatus = STATUS_INVALID_PARAMETER;

                        } else {

                            //
                            // The caller might be simultaneously setting
                            // the password and changing the account to be
                            // a machine or trust account.  In this case,
                            // we don't validate the password (e.g., length).
                            //

                            IgnorePasswordRestrictions = FALSE;
                            if (UserAll->WhichFields &
                                USER_ALL_USERACCOUNTCONTROL) {
                                if (UserAll->UserAccountControl &
                                    (USER_WORKSTATION_TRUST_ACCOUNT | USER_SERVER_TRUST_ACCOUNT)
                                   ) {
                                    IgnorePasswordRestrictions = TRUE;
                                }
                            }


                            SendOwfs = TRUE;
                            if (Pass == 0) {

                                //
                                // On the first pass, try sending the cleatext
                                // password.
                                //

                                Internal4RpcBufferNew.I1 = *(PSAMPR_USER_ALL_INFORMATION)
                                                            UserAll;

                                BufferToPass = &Internal4RpcBufferNew;
                                ClassToUse = UserInternal4InformationNew;
                                SendOwfs = FALSE;

                                //
                                // Check the password restrictions.  We also
                                // want to get the information on whether
                                // we can send reversibly encrypted passwords.
                                //

                                NtStatus = SampCheckPasswordRestrictions(
                                                RpcContextHandle,
                                                &UserAll->NtPassword,
                                                &SendOwfs
                                                );

                                if (IgnorePasswordRestrictions) {
                                    NtStatus = STATUS_SUCCESS;
                                }

                                if (!SendOwfs) {
                                    //
                                    // Encrypt the clear password
                                    //

                                    NtStatus = SampEncryptClearPasswordNew(
                                                    RpcContextHandle,
                                                    &UserAll->NtPassword,
                                                    &Internal4RpcBufferNew.UserPassword
                                                    );
                                    if (!NT_SUCCESS(NtStatus)) {
                                        break;
                                    }

                                    pClearPassword = &UserAll->NtPassword;

                                    //
                                    // Zero the password NT password
                                    //

                                    RtlZeroMemory(
                                        &Internal4RpcBufferNew.I1.NtOwfPassword,
                                        sizeof(UNICODE_STRING)
                                        );

                                }
                            }

                            if (SendOwfs) {


                                //
                                // On the second pass, do the normal thing.
                                //

                                LocalAll = *UserAll;
                                BufferToPass = &LocalAll;
                                SendOwfs = TRUE;

                                ClassToUse = UserAllInformation;
                                if ( LocalAll.WhichFields & USER_ALL_NTPASSWORDPRESENT ) {

                                    //
                                    // The user specified a password.  We must validate
                                    // it, convert it to LM, and calculate the OWFs
                                    //

                                    LocalAll.WhichFields |= USER_ALL_LMPASSWORDPRESENT;


                                    //
                                    // Stick the OWFs in the Internal1Buffer - just
                                    // until we use them in the SampEncryptOwfs().
                                    //

                                    NtStatus = SampOwfPassword(
                                                   RpcContextHandle,
                                                   &LocalAll.NtPassword,
                                                   IgnorePasswordRestrictions,
                                                   &LocalAll.NtPasswordPresent,
                                                   &(Internal1Buffer.NtOwfPassword),
                                                   &LocalAll.LmPasswordPresent,
                                                   &(Internal1Buffer.LmOwfPassword)
                                                   );
                                }
                            }

                        }
                    }




                    //
                    // We now have one or more OWFs in Internal1 buffer.
                    // We got these either directly or we calculated them
                    // from the text strings.
                    // Encrypt these OWFs with the session key and
                    // store the result in Internal1RpcBuffer.
                    //
                    // Note the Password present flags are in LocalAll.
                    // (The ones in Internal1Buffer are not used.)
                    //

                    if ( NT_SUCCESS( NtStatus ) && SendOwfs ) {

                        //
                        // Make all LocalAll's password strings point to
                        // the buffers in Internal1RpcBuffer
                        //

                        LocalAll.NtPassword.Length =
                            sizeof( ENCRYPTED_NT_OWF_PASSWORD );
                        LocalAll.NtPassword.MaximumLength =
                            sizeof( ENCRYPTED_NT_OWF_PASSWORD );
                        LocalAll.NtPassword.Buffer = (PWSTR)
                            &Internal1RpcBuffer.EncryptedNtOwfPassword;

                        LocalAll.LmPassword.Length =
                            sizeof( ENCRYPTED_LM_OWF_PASSWORD );
                        LocalAll.LmPassword.MaximumLength =
                            sizeof( ENCRYPTED_LM_OWF_PASSWORD );
                        LocalAll.LmPassword.Buffer = (PWSTR)
                            &Internal1RpcBuffer.EncryptedLmOwfPassword;

                        //
                        // Encrypt the Owfs
                        //

                        NtStatus = SampEncryptOwfs(
                                       RpcContextHandle,
                                       LocalAll.NtPasswordPresent,
                                       &Internal1Buffer.NtOwfPassword,
                                       &Internal1RpcBuffer.EncryptedNtOwfPassword,
                                       LocalAll.LmPasswordPresent,
                                       &Internal1Buffer.LmOwfPassword,
                                       &Internal1RpcBuffer.EncryptedLmOwfPassword
                                       );
                    }
                }

                break;

            default:

                break;

            } // switch




            //
            // Call the server ...
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // If we are trying one of the new info levels, use the new
                // api.
                //

                if ((ClassToUse == UserInternal4InformationNew) ||
                     (ClassToUse == UserInternal5InformationNew)) {

                    RpcTryExcept{

                        NtStatus =
                            SamrSetInformationUser2(
                                (SAMPR_HANDLE)RpcContextHandle,
                                ClassToUse,
                                BufferToPass
                                );

                    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                          NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

                    } RpcEndExcept;

                    if ((RPC_NT_INVALID_TAG == NtStatus) ||
                        (STATUS_INVALID_INFO_CLASS == NtStatus))
                    {
                        NtStatus = SampSetInfoUserUseOldInfoClass(
                                        RpcContextHandle,
                                        ClassToUse,
                                        BufferToPass,
                                        pClearPassword
                                        );
                    }

                } else {
                    NtStatus =
                        SamrSetInformationUser(
                            (SAMPR_HANDLE)RpcContextHandle,
                            ClassToUse,
                            BufferToPass
                            );
                }
            }

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;

        Pass++;

        //
        // If this is the first pass and the status indicated that the
        // server did not support the info class or the api
        // and we were trying one of the new info levels, try again.
        //

    } while ( (Pass < 2) &&
              ((NtStatus == RPC_NT_INVALID_TAG) ||
               (NtStatus == RPC_NT_UNKNOWN_IF) ||
               (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)));

    return(SampMapCompletionStatus(NtStatus));

}





NTSTATUS
SamiLmChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew,
    IN PENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld
)

/*++


Routine Description:

    Changes the password of a user account. This routine is intended to be
    called by down-level system clients who have only the cross-encrypted
    LM passwords available to them.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.

    This api will fail unless UAS Compatibility is enabled for the domain.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    LmOldEncryptedWithLmNew - the OWF of the old LM password encrypted using
                 the OWF of the new LM password as a key.

    LmNewEncryptedWithLmOld - the OWF of the new LM password encrypted using
                 the OWF of the old LM password as a key.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - The old password is incorrect.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;

    //
    // Check parameter validity
    //

    if (LmOldEncryptedWithLmNew == NULL) {
        return(STATUS_INVALID_PARAMETER_1);
    }
    if (LmNewEncryptedWithLmOld == NULL) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus = SamrChangePasswordUser(
                            (SAMPR_HANDLE)RpcContextHandle,

                            TRUE,   // LmOldPresent
                            LmOldEncryptedWithLmNew,
                            LmNewEncryptedWithLmOld,

                            FALSE,  // NtPresent
                            NULL,   // NtOldEncryptedWithNtNew
                            NULL,   // NtNewEncryptedWithNtOld

                            FALSE,  // NtCrossEncryptionPresent
                            NULL,

                            FALSE,  // LmCrossEncryptionPresent
                            NULL

                            );

        //
        // We should never get asked for cross-encrypted data
        // since the server knows we don't have any NT data.
        //

        ASSERT (NtStatus != STATUS_NT_CROSS_ENCRYPTION_REQUIRED);
        ASSERT (NtStatus != STATUS_LM_CROSS_ENCRYPTION_REQUIRED);


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}





NTSTATUS
SamiChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN BOOLEAN LmOldPresent,
    IN PLM_OWF_PASSWORD LmOldOwfPassword,
    IN PLM_OWF_PASSWORD LmNewOwfPassword,
    IN BOOLEAN NtPresent,
    IN PNT_OWF_PASSWORD NtOldOwfPassword,
    IN PNT_OWF_PASSWORD NtNewOwfPassword
)

/*++


Routine Description:

    Changes the password of a user account. This is the worker routine for
    SamChangePasswordUser and can be called by OWF-aware clients.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    LMOldPresent - TRUE if the LmOldOwfPassword is valid. This should only
                   be FALSE if the old password is too long to be represented
                   by a LM password. (Complex NT password).
                   Note the LMNewOwfPassword must always be valid.
                   If the new password is complex, the LMNewOwfPassword should
                   be the well-known LM OWF of a NULL password.

    LmOldOwfPassword - One-way-function of the current LM password for the user.
                     - Ignored if LmOldPresent == FALSE

    LmNewOwfPassword - One-way-function of the new LM password for the user.

    NtPresent - TRUE if the NT one-way-functions are valid.
              - i.e. This will be FALSE if we're called from a down-level client.

    NtOldOwfPassword - One-way-function of the current NT password for the user.

    NtNewOwfPassword - One-way-function of the new NT password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

    STATUS_INVALID_PARAMETER_MIX - LmOldPresent or NtPresent or both
        must be TRUE.

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    ENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithNtOld;
    ENCRYPTED_NT_OWF_PASSWORD NtOldEncryptedWithNtNew;
    ENCRYPTED_NT_OWF_PASSWORD NtNewEncryptedWithLmNew;
    ENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithLmOld;
    ENCRYPTED_LM_OWF_PASSWORD LmOldEncryptedWithLmNew;
    ENCRYPTED_LM_OWF_PASSWORD LmNewEncryptedWithNtNew;

    PENCRYPTED_NT_OWF_PASSWORD pNtNewEncryptedWithNtOld;
    PENCRYPTED_NT_OWF_PASSWORD pNtOldEncryptedWithNtNew;
    PENCRYPTED_LM_OWF_PASSWORD pLmNewEncryptedWithLmOld;
    PENCRYPTED_LM_OWF_PASSWORD pLmOldEncryptedWithLmNew;
    SAMPR_HANDLE               RpcContextHandle;

    //
    // Check parameter validity
    //

    if (!LmOldPresent && !NtPresent) {
        return(STATUS_INVALID_PARAMETER_MIX);
    }

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        //
        // We're going to encrypt the oldLM with the newLM and vice-versa.
        // We're going to encrypt the oldNT with the newNT and vice-versa.
        // We're going to send these 4 encryptions and see if we're successful.
        //
        // If we get a return code of STATUS_LM_CROSS_ENCRYPTION_REQUIRED,
        // we'll also encrypt the newLM with the newNT and send it all again.
        //
        // If we get a return code of STATUS_NT_CROSS_ENCRYPTION_REQUIRED,
        // we'll also encrypt the newNT with the newLM and send it all again.
        //
        // We don't always send the cross-encryption otherwise we would be
        // compromising security on pure NT systems with long passwords.
        //

        //
        // Do the LM Encryption
        //

        if (!LmOldPresent) {

            pLmOldEncryptedWithLmNew = NULL;
            pLmNewEncryptedWithLmOld = NULL;

        } else {

            pLmOldEncryptedWithLmNew = &LmOldEncryptedWithLmNew;
            pLmNewEncryptedWithLmOld = &LmNewEncryptedWithLmOld;

            NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                            LmOldOwfPassword,
                            LmNewOwfPassword,
                            &LmOldEncryptedWithLmNew);

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                                LmNewOwfPassword,
                                LmOldOwfPassword,
                                &LmNewEncryptedWithLmOld);
            }
        }

        //
        // Do the NT Encryption
        //

        if (NT_SUCCESS(NtStatus)) {

            if (!NtPresent) {

                pNtOldEncryptedWithNtNew = NULL;
                pNtNewEncryptedWithNtOld = NULL;

            } else {

                pNtOldEncryptedWithNtNew = &NtOldEncryptedWithNtNew;
                pNtNewEncryptedWithNtOld = &NtNewEncryptedWithNtOld;

                NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                                NtOldOwfPassword,
                                NtNewOwfPassword,
                                &NtOldEncryptedWithNtNew);

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                                    NtNewOwfPassword,
                                    NtOldOwfPassword,
                                    &NtNewEncryptedWithNtOld);
                }
            }
        }


        //
        // Call the server (with no cross-encryption)
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SamrChangePasswordUser(
                                (SAMPR_HANDLE)RpcContextHandle,

                                LmOldPresent,
                                pLmOldEncryptedWithLmNew,
                                pLmNewEncryptedWithLmOld,

                                NtPresent,
                                pNtOldEncryptedWithNtNew,
                                pNtNewEncryptedWithNtOld,

                                FALSE,  // NtCrossEncryptionPresent
                                NULL,

                                FALSE,  // LmCrossEncryptionPresent
                                NULL

                                );

            if (NtStatus == STATUS_NT_CROSS_ENCRYPTION_REQUIRED) {

                //
                // The server cannot process the request as is: try again
                // cross encrypting the passwords
                //

                //
                // Compute the cross-encryption of the new Nt password
                //

                ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                NtStatus = RtlEncryptNtOwfPwdWithNtOwfPwd(
                                NtNewOwfPassword,
                                (PNT_OWF_PASSWORD)LmNewOwfPassword,
                                &NtNewEncryptedWithLmNew);


                //
                // Call the server (with NT cross-encryption)
                //

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = SamrChangePasswordUser(
                                        (SAMPR_HANDLE)RpcContextHandle,

                                        LmOldPresent,
                                        pLmOldEncryptedWithLmNew,
                                        pLmNewEncryptedWithLmOld,

                                        NtPresent,
                                        pNtOldEncryptedWithNtNew,
                                        pNtNewEncryptedWithNtOld,

                                        TRUE,
                                        &NtNewEncryptedWithLmNew,

                                        FALSE,
                                        NULL
                                        );
                }

            } else {

                if (NtStatus == STATUS_LM_CROSS_ENCRYPTION_REQUIRED) {

                    //
                    // We should only get this if we have NT but no old LM data
                    // (This is not obvious - it results from the server-side logic)
                    //

                    ASSERT(NtPresent && !LmOldPresent);

                    //
                    // Compute the cross-encryption of the new Nt password
                    //

                    ASSERT(LM_OWF_PASSWORD_LENGTH == NT_OWF_PASSWORD_LENGTH);

                    NtStatus = RtlEncryptLmOwfPwdWithLmOwfPwd(
                                    LmNewOwfPassword,
                                    (PLM_OWF_PASSWORD)NtNewOwfPassword,
                                    &LmNewEncryptedWithNtNew);


                    //
                    // Call the server (with LM cross-encryption)
                    //

                    if ( NT_SUCCESS( NtStatus ) ) {

                        NtStatus = SamrChangePasswordUser(
                                            (SAMPR_HANDLE)RpcContextHandle,

                                            LmOldPresent,
                                            pLmOldEncryptedWithLmNew,
                                            pLmNewEncryptedWithLmOld,

                                            NtPresent,
                                            pNtOldEncryptedWithNtNew,
                                            pNtNewEncryptedWithNtOld,

                                            FALSE,
                                            NULL,

                                            TRUE,
                                            &LmNewEncryptedWithNtNew
                                            );
                    }
                }
            }

        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamChangePasswordUser(
    IN SAM_HANDLE UserHandle,
    IN PUNICODE_STRING OldNtPassword,
    IN PUNICODE_STRING NewNtPassword
)

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    LM_OWF_PASSWORD     NewLmOwfPassword, OldLmOwfPassword;
    NT_OWF_PASSWORD     NewNtOwfPassword, OldNtOwfPassword;
    BOOLEAN             LmOldPresent;
    PCHAR               LmPassword;
    NTSTATUS            NtStatus;
    BOOLEAN             UseOwfPasswords;
    SAMPR_HANDLE        RpcContextHandle;

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //

    RpcTryExcept{

        NtStatus = SampCheckPasswordRestrictions(
                       RpcContextHandle,
                       NewNtPassword,
                       &UseOwfPasswords
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Calculate the one-way-functions of the NT passwords
            //

            NtStatus = RtlCalculateNtOwfPassword(
                           OldNtPassword,
                           &OldNtOwfPassword
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = RtlCalculateNtOwfPassword(
                               NewNtPassword,
                               &NewNtOwfPassword
                               );
            }


            //
            // Calculate the one-way-functions of the LM passwords
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Calculate the LM version of the old password
                //

                NtStatus = SampCalculateLmPassword(
                            OldNtPassword,
                            &LmPassword);

                if (NT_SUCCESS(NtStatus)) {

                    if (NtStatus == STATUS_NULL_LM_PASSWORD) {
                        LmOldPresent = FALSE;
                    } else {
                        LmOldPresent = TRUE;

                        //
                        // Compute the One-Way-Function of the old LM password
                        //

                        NtStatus = RtlCalculateLmOwfPassword(
                                        LmPassword,
                                        &OldLmOwfPassword);
                    }

                    //
                    // We're finished with the LM password
                    //

                    MIDL_user_free(LmPassword);
                }

                //
                // Calculate the LM version of the new password
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampCalculateLmPassword(
                                NewNtPassword,
                                &LmPassword);

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Compute the One-Way-Function of the new LM password
                        //

                        NtStatus = RtlCalculateLmOwfPassword(
                                        LmPassword,
                                        &NewLmOwfPassword);

                        //
                        // We're finished with the LM password
                        //

                        MIDL_user_free(LmPassword);
                    }
                }
            }


            //
            // Call our worker routine with the one-way-functions
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SamiChangePasswordUser(
                                UserHandle,
                                LmOldPresent,
                                &OldLmOwfPassword,
                                &NewLmOwfPassword,
                                TRUE,               // NT present
                                &OldNtOwfPassword,
                                &NewNtOwfPassword
                           );
            }
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamGetGroupsForUser(
    IN SAM_HANDLE UserHandle,
    OUT PGROUP_MEMBERSHIP * Groups,
    OUT PULONG MembershipCount
)

/*++


Routine Description:

    This service returns the list of groups that a user is a member of.
    It returns a structure for each group that includes the relative ID
    of the group, and the attributes of the group that are assigned to
    the user.

    This service requires USER_LIST_GROUPS access to the user account
    object.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    Groups - Receives a pointer to a buffer containing an array of
        GROUP_MEMBERSHIPs data structures.  When this information is
        no longer needed, this buffer must be freed using
        SamFreeMemory().

    MembershipCount - Receives the number of groups the user is a
        member of, and, thus, the number elements returned in the
        Groups array.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{
    NTSTATUS                    NtStatus;
    PSAMPR_GET_GROUPS_BUFFER    GetGroupsBuffer;
    SAMPR_HANDLE                RpcContextHandle;


    SampOutputDebugString("SamGetGroupsForUser");

    if (!SampIsValidClientHandle(UserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    GetGroupsBuffer = NULL;

    RpcTryExcept{

        NtStatus =
            SamrGetGroupsForUser(
                (SAMPR_HANDLE)RpcContextHandle,
                &GetGroupsBuffer
                );

        if (NT_SUCCESS(NtStatus)) {
            (*MembershipCount) = GetGroupsBuffer->MembershipCount;
            (*Groups)          = GetGroupsBuffer->Groups;
            MIDL_user_free( GetGroupsBuffer );
        } else {

            //
            // Deallocate any returned buffers on error
            //

            if (GetGroupsBuffer != NULL) {
                if (GetGroupsBuffer->Groups != NULL) {
                    MIDL_user_free(GetGroupsBuffer->Groups);
                }
                MIDL_user_free(GetGroupsBuffer);
            }
        }


    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamTestPrivateFunctionsDomain(
    IN SAM_HANDLE DomainHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    DomainHandle - Handle to a domain to be tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{
#ifdef SAM_SERVER_TESTS

    NTSTATUS NtStatus;

    SAMPR_HANDLE        RpcContextHandle;

    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    return( SamrTestPrivateFunctionsDomain( RpcContextHandle ) );
#else
    return( STATUS_NOT_IMPLEMENTED );
    UNREFERENCED_PARAMETER(DomainHandle);
#endif
}



NTSTATUS
SamTestPrivateFunctionsUser(
    IN SAM_HANDLE UserHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    UserHandle - Handle to a user to be tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{
#ifdef SAM_SERVER_TESTS
    SAMPR_HANDLE        RpcContextHandle;

    if (!SampIsValidClientHandle(SamUserHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    return( SamrTestPrivateFunctionsUser( RpcContextHandle ) );
#else
    return( STATUS_NOT_IMPLEMENTED );
    UNREFERENCED_PARAMETER(UserHandle);
#endif
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private services                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampMapCompletionStatus(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This service maps completion status received back from an RPC call
    into a completion status to be returned from SAM api.


Parameters:

    Status - Status value to be mapped.

Return Values:

    The mapped SAM status value.


--*/
{

    if (Status == RPC_NT_INVALID_BINDING) {
        Status =  STATUS_INVALID_HANDLE;
    }
//    if (Status == RPC_ACCESS_DENIED) {
//        Status = STATUS_ACCESS_DENIED;
//    }



    return( Status );

}






////////////////////////////////////////////////////////////////////////

NTSTATUS
SampCheckStrongPasswordRestrictions(
    PUNICODE_STRING Password
    )

/*++

Routine Description:

    This routine is notified of a password change. It will check the
    password's complexity. The new Strong Password must meet the
    following criteria:
    1. Password must contain characters from at least 3 of the
       following 5 classes:

       Description                             Examples:
       1       English Upper Case Letters      A, B, C,   Z
       2       English Lower Case Letters      a, b, c,  z
       3       Westernized Arabic Numerals     0, 1, 2,  9
       4       Non-alphanumeric             ("Special characters")
                                            (`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)
       5       Any linguistic character: alphabetic, syllabary, or ideographic
               (localization issue)

    Note: The following restriction (No. 2) can only be enforced on
          the server side. Because when users change their password,
          the client code opens the User Account with WRITE access
          right only. Then samlib can not READ any user info (for
          example: Account Name and Full name). Thus we have to
          rely on the server side SAMSRV.dll to enforce restriction
          No. 2. The only exception would be when client send OWF
          password to server, then server can not do any restriction
          check at all.


          2. Password can not contain your account name or any part of
             user's full name.


    Note: This routine does NOT check password's length, since password
          length restriction has already been enforced by NT4 SAM if you
          set it correctly.

Arguments:

    Password - Cleartext new password for the user

Return Value:

    STATUS_SUCCESS if the specified Password is suitable (complex, long, etc).
        The system will continue to evaluate the password update request
        through any other installed password change packages.

    STATUS_PASSWORD_RESTRICTION
        if the specified Password is unsuitable. The password change
         on the specified account will fail.

    STATUS_NO_MEMORY

--*/
{

                    // assume the password in not complex enough
    NTSTATUS NtStatus = STATUS_PASSWORD_RESTRICTION;
    USHORT     cchPassword = 0;
    USHORT     i = 0;
    USHORT     NumInPassword = 0;
    USHORT     UpperInPassword = 0;
    USHORT     LowerInPassword = 0;
    USHORT     AlphaInPassword = 0;
    USHORT     SpecialCharInPassword = 0;
    PWSTR      _password = NULL;
    PWORD      CharType = NULL;


    // check if the password contains at least 3 of 4 classes.

    CharType = MIDL_user_allocate( Password->Length );

    if ( CharType == NULL ) {

        NtStatus = STATUS_NO_MEMORY;
        goto SampCheckStrongPasswordFinish;
    }

    cchPassword = Password->Length / sizeof(WCHAR);
    if(GetStringTypeW(
           CT_CTYPE1,
           Password->Buffer,
           cchPassword,
           CharType)) {

        for(i = 0 ; i < cchPassword ; i++) {

            //
            // keep track of what type of characters we have encountered
            //

            if(CharType[i] & C1_DIGIT) {
                NumInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_UPPER) {
                UpperInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_LOWER) {
                LowerInPassword = 1;
                continue;
            }

            if(CharType[i] & C1_ALPHA) {
                AlphaInPassword = 1;
                continue;
            }

        } // end of track character type.

        _password = MIDL_user_allocate(Password->Length + sizeof(WCHAR));

        if ( _password == NULL ) {

            NtStatus = STATUS_NO_MEMORY;
            goto SampCheckStrongPasswordFinish;
        }
        else {

            RtlSecureZeroMemory( _password, Password->Length + sizeof(WCHAR));
        }

        wcsncpy(_password,
                Password->Buffer,
                Password->Length/sizeof(WCHAR)
                );

        if (wcspbrk (_password, L"(`~!@#$%^&*_-+=|\\{}[]:;\"'<>,.?)") != NULL) {

                SpecialCharInPassword = 1 ;
        }

        //
        // Indicate whether we encountered enough password complexity
        //

        if( (NumInPassword + LowerInPassword + UpperInPassword + AlphaInPassword +
                SpecialCharInPassword) < 3)
        {
            NtStatus = STATUS_PASSWORD_RESTRICTION;
            goto SampCheckStrongPasswordFinish;

        } else
        {
            NtStatus = STATUS_SUCCESS ;
        }

    } // if GetStringTypeW failed, NtStatus will by default equal to
      // STATUS_PASSWORD_RESTRICTION


SampCheckStrongPasswordFinish:

    if ( CharType != NULL ) {
        RtlSecureZeroMemory( CharType, Password->Length );
        MIDL_user_free( CharType );
    }

    if ( _password != NULL ) {
        RtlSecureZeroMemory( _password, Password->Length + sizeof(WCHAR) );
        MIDL_user_free( _password );
    }

    return ( NtStatus );
}

/////////////////////////////////////////////////////////////////////





NTSTATUS
SampCheckPasswordRestrictions(
    IN SAMPR_HANDLE RpcContextHandle,
    IN PUNICODE_STRING NewNtPassword,
    OUT PBOOLEAN UseOwfPasswords
    )

/*++

Routine Description:

    This service is called to make sure that the password presented meets
    our quality requirements.


Arguments:

    RpcContextHandle - Handle to a user.

    NewNtPassword - Pointer to the UNICODE_STRING containing the new
        password.

    UseOwfPasswords - Indicates that reversibly encrypted passwords should
        not be sent over the network.


Return Value:

    STATUS_SUCCESS - The password is acceptable.

    STATUS_PASSWORD_RESTRICTION - The password is too short, or is not
        complex enough, etc.

    STATUS_INVALID_RESOURCES - There was not enough memory to do the
        password checking.


--*/
{
    USER_DOMAIN_PASSWORD_INFORMATION  DomainPasswordInformationBuffer;
    NTSTATUS                          NtStatus;

    //
    // If the new password is zero length the server side will do
    // the necessary checking.
    //

    if (NewNtPassword->Length == 0) {
        return(STATUS_SUCCESS);
    }

    //
    // The password should be less than PWLEN -- 256
    //
    if ((NewNtPassword->Length / sizeof(WCHAR)) > PWLEN)
    {
        return(STATUS_PASSWORD_RESTRICTION);
    }

    *UseOwfPasswords = FALSE;


    //
    // Query information domain to get password length and
    // complexity requirements.
    //

    NtStatus = SamrGetUserDomainPasswordInformation(
                   RpcContextHandle,
                   &DomainPasswordInformationBuffer
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        if ( (USHORT)( NewNtPassword->Length / sizeof(WCHAR) ) < DomainPasswordInformationBuffer.MinPasswordLength ) {

            NtStatus = STATUS_PASSWORD_RESTRICTION;

        } else {

            //
            // Check whether policy allows us to send reversibly encrypted
            // passwords.
            //

            if ( DomainPasswordInformationBuffer.PasswordProperties &
                 DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) {
                *UseOwfPasswords = TRUE;
            }

            //
            // Check password complexity.
            //

            if ( DomainPasswordInformationBuffer.PasswordProperties & DOMAIN_PASSWORD_COMPLEX ) {

                //
                // Make sure that the password meets our requirements for
                // complexity.  If it's got an odd byte count, it's
                // obviously not a hand-entered UNICODE string so we'll
                // consider it complex by default.
                //

                if ( !( NewNtPassword->Length & 1 ) ) {

                    //
                    // Apply Strong password restrictions
                    //

                    NtStatus = SampCheckStrongPasswordRestrictions( NewNtPassword );
                }
            }
        }
    }

    return( NtStatus );
}


NTSTATUS
SampChangePasswordUser2(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
)

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    UserHandle - The handle of an opened user to operate on.

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    NTSTATUS NtStatus;
    SAM_HANDLE SamServerHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;
    SAM_HANDLE UserHandle = NULL;
    LSA_HANDLE PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    PULONG UserId = NULL;
    PSID_NAME_USE NameUse = NULL;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes call doesn't initialize the
    // quality of serivce, so do that separately.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;



    NtStatus = LsaOpenPolicy(
                ServerName,
                &ObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                &AccountDomainInfo
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamConnect(
                ServerName,
                &SamServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamOpenDomain(
                SamServerHandle,
                GENERIC_EXECUTE,
                AccountDomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamLookupNamesInDomain(
                DomainHandle,
                1,
                UserName,
                &UserId,
                &NameUse
                );

    if (!NT_SUCCESS(NtStatus)) {
        if (NtStatus == STATUS_NONE_MAPPED) {
            NtStatus = STATUS_NO_SUCH_USER;
        }
        goto Cleanup;
    }

    NtStatus = SamOpenUser(
                DomainHandle,
                USER_CHANGE_PASSWORD,
                *UserId,
                &UserHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamChangePasswordUser(
                UserHandle,
                OldPassword,
                NewPassword
                );
Cleanup:
    if (UserHandle != NULL) {
        SamCloseHandle(UserHandle);
    }
    if (DomainHandle != NULL) {
        SamCloseHandle(DomainHandle);
    }
    if (SamServerHandle != NULL) {
        SamCloseHandle(SamServerHandle);
    }
    if (PolicyHandle != NULL){
        LsaClose(PolicyHandle);
    }
    if (AccountDomainInfo != NULL) {
        LsaFreeMemory(AccountDomainInfo);
    }
    if (UserId != NULL) {
        SamFreeMemory(UserId);
    }
    if (NameUse != NULL) {
        SamFreeMemory(NameUse);
    }

    return(NtStatus);

}

NTSTATUS
SampGetPasswordChangeFailureInfo(
    IN PUNICODE_STRING UncComputerName,
    PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy,
    PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo
    )
/*++

    This routine obtains the domain password policy pertaining
    to the account domain of a particular server.

    Parameters

        UncComputerName -- THe name of the server

    ReturnValues

        STATUS_SUCCESS
        Other Error codes upon failure
--*/
{
    NTSTATUS                    Status;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQos;
    SAM_HANDLE                  SamHandle = NULL;
    SAM_HANDLE                  DomainHandle = NULL;
    LSA_HANDLE                  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES           LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;



    //
    // Initialize Return values
    //

    *PasswordChangeFailureInfo = NULL;


    //
    // Get the SID of the account domain from LSA
    //

    InitializeObjectAttributes( &LSAObjectAttributes,
                                  NULL,             // Name
                                  0,                // Attributes
                                  NULL,             // Root
                                  NULL );           // Security Descriptor

    Status = LsaOpenPolicy( UncComputerName,
                            &LSAObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LSAPolicyHandle );

    if( !NT_SUCCESS(Status) ) {
        KdPrint(("MspChangePasswordSam: LsaOpenPolicy(%wZ) failed, status %x\n",
                 UncComputerName, Status));
        LSAPolicyHandle = NULL;
        goto Cleanup;
    }

    Status = LsaQueryInformationPolicy(
                    LSAPolicyHandle,
                    PolicyAccountDomainInformation,
                    (PVOID *) &AccountDomainInfo );

    if( !NT_SUCCESS(Status) ) {
        KdPrint(("MspChangePasswordSam: LsaQueryInformationPolicy(%wZ) failed, status %x\n",
                 UncComputerName, Status));
        AccountDomainInfo = NULL;
        goto Cleanup;
    }

    //
    // Setup ObjectAttributes for SamConnect call.
    //

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQos;

    SecurityQos.Length = sizeof(SecurityQos);
    SecurityQos.ImpersonationLevel = SecurityIdentification;
    SecurityQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
    SecurityQos.EffectiveOnly = FALSE;

    Status = SamConnect(
                 UncComputerName,
                 &SamHandle,
                 SAM_SERVER_LOOKUP_DOMAIN,
                 &ObjectAttributes
                 );


    if ( !NT_SUCCESS(Status) ) {

        DomainHandle = NULL;
        goto Cleanup;
    }


    //
    // Open the Account domain in SAM.
    //

    Status = SamOpenDomain(
                 SamHandle,
                 GENERIC_EXECUTE,
                 AccountDomainInfo->DomainSid,
                 &DomainHandle
                 );

    if ( !NT_SUCCESS(Status) ) {

        DomainHandle = NULL;
        goto Cleanup;
    }


    Status = SamQueryInformationDomain(
                    DomainHandle,
                    DomainPasswordInformation,
                    (PVOID *)EffectivePasswordPolicy );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // O.K Compose the PasswordChangeFailureInfo structure
    //

    *PasswordChangeFailureInfo = MIDL_user_allocate(sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));
    if (NULL==*PasswordChangeFailureInfo)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlSecureZeroMemory(*PasswordChangeFailureInfo,
                        sizeof(USER_PWD_CHANGE_FAILURE_INFORMATION));

Cleanup:

    //
    // Free Locally used resources
    //


    if (SamHandle) {
        SamCloseHandle(SamHandle);
    }

    if (DomainHandle) {
        SamCloseHandle(DomainHandle);
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    if ( AccountDomainInfo != NULL ) {
        (VOID) LsaFreeMemory( AccountDomainInfo );
    }

    return Status;
}


NTSTATUS
SamiChangePasswordUser3(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt,
    PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy, OPTIONAL
    PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo OPTIONAL
    )
/*++


Routine Description:

    Changes the password of a user account. This is the worker routine for
    SamChangePasswordUser2 and can be called by OWF-aware clients.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    NewPasswordEncryptedWithOldNt - The new cleartext password encrypted
        with the old NT OWF password.

    OldNtOwfPasswordEncryptedWithNewNt - The old NT OWF password encrypted
        with the new NT OWF password.

    LmPresent - If TRUE, indicates that the following two last parameter
        was encrypted with the LM OWF password not the NT OWF password.

    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted
        with the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLmOrNt - The old LM OWF password encrypted
        with the new LM OWF password.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    handle_t BindingHandle = NULL;
    PSAMPR_SERVER_NAME RServerNameWithNull;
    USHORT RServerNameWithNullLength;
    PSAMPR_SERVER_NAME  RServerName;
    ULONG Tries = 2;
    NTSTATUS NtStatus;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;
    PUSER_PWD_CHANGE_FAILURE_INFORMATION PasswordChangeFailureInformationLocal = NULL;
    PDOMAIN_PASSWORD_INFORMATION         EffectivePasswordPolicyLocal = NULL;;


    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';

    }

    //
    // Initialize return values
    //

    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
    {
        *PasswordChangeFailureInfo = NULL;
    }
    if (ARGUMENT_PRESENT(EffectivePasswordPolicy))
    {
        *EffectivePasswordPolicy = NULL;
    }

    do
    {
        //
        // Try privacy level first, and if that failed with unknown authn
        // level or invalid binding try with a lower level (none).
        //

        if (Tries == 2) {
            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                );


        } else if ((NtStatus == RPC_NT_UNKNOWN_AUTHN_LEVEL) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_TYPE) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_SERVICE) ||
                   (NtStatus == RPC_NT_INVALID_BINDING) ||
                   (NtStatus == STATUS_ACCESS_DENIED) ) {
            SampSecureUnbind(BindingHandle);

            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_NONE
                                );

        } else {
            break;
        }

        if (BindingHandle != NULL) {

            RpcTryExcept{

                //
                // Get password information to make sure this operation
                // is allowed.  We do it now because we wanted to bind
                // before trying it.
                //

                NtStatus = SamrGetDomainPasswordInformation(
                               BindingHandle,
                               (PRPC_UNICODE_STRING) ServerName,
                               &PasswordInformation
                               );

                if ((( NtStatus == STATUS_SUCCESS ) &&
                    (( PasswordInformation.PasswordProperties &
                        DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) == 0 ) ) ||
                    (NtStatus == STATUS_ACCESS_DENIED ) ) {



                   RpcTryExcept {

                       //
                       // Try the latest call
                       //

                        NtStatus = SamrUnicodeChangePasswordUser3(
                                       BindingHandle,
                                       (PRPC_UNICODE_STRING) ServerName,
                                       (PRPC_UNICODE_STRING) UserName,
                                       NewPasswordEncryptedWithOldNt,
                                       OldNtOwfPasswordEncryptedWithNewNt,
                                       LmPresent,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLmOrNt,
                                       NULL,
                                       &EffectivePasswordPolicyLocal,
                                       &PasswordChangeFailureInformationLocal
                                      );
                   } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

                          NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

                   } RpcEndExcept;

                    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
                        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

                           NtStatus = SamrUnicodeChangePasswordUser2(
                                       BindingHandle,
                                       (PRPC_UNICODE_STRING) ServerName,
                                       (PRPC_UNICODE_STRING) UserName,
                                       NewPasswordEncryptedWithOldNt,
                                       OldNtOwfPasswordEncryptedWithNewNt,
                                       LmPresent,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLmOrNt
                                       );

                           if (STATUS_PASSWORD_RESTRICTION==NtStatus)
                           {
                               NTSTATUS IgnoreStatus;

                               //
                               // Obtain the domain policy and a default
                               // password change failure info by reading
                               // the domain policy. Ignore the resulting
                               // NtStatus -- if the call failed,
                               // PasswordChangeFailureInfo would be NULL
                               //

                               IgnoreStatus = SampGetPasswordChangeFailureInfo(
                                                ServerName,
                                                &EffectivePasswordPolicyLocal,
                                                &PasswordChangeFailureInformationLocal
                                                );
                           }

                    }

                } else {

                    //
                    // Set the error to indicate that we should try the
                    // downlevel way to change passwords.
                    //

                    NtStatus = STATUS_NOT_SUPPORTED;
                }



            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {


                //
                // The mapping function doesn't handle this error so
                // special case it by hand.
                //
                NtStatus = RpcExceptionCode();

                if (NtStatus == RPC_S_SEC_PKG_ERROR) {
                    NtStatus = STATUS_ACCESS_DENIED;
                } else {
                    NtStatus = I_RpcMapWin32Status(NtStatus);
                }


            } RpcEndExcept;

        } else {
            NtStatus = RPC_NT_INVALID_BINDING;
        }

        Tries--;
    } while ( (Tries > 0) && (!NT_SUCCESS(NtStatus)) );
    if (RServerNameWithNull != NULL) {
        MIDL_user_free( RServerNameWithNull );
    }

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }

    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
    {
        *PasswordChangeFailureInfo = PasswordChangeFailureInformationLocal;
    }
    else if (NULL!=PasswordChangeFailureInformationLocal)
    {
        if (NULL!=PasswordChangeFailureInformationLocal->FilterModuleName.Buffer)
        {
            SamFreeMemory(PasswordChangeFailureInformationLocal->FilterModuleName.Buffer);
        }
        SamFreeMemory(PasswordChangeFailureInformationLocal);
    }

    if (ARGUMENT_PRESENT(EffectivePasswordPolicy))
    {
        *EffectivePasswordPolicy = EffectivePasswordPolicyLocal;
    }
    else if (NULL!=EffectivePasswordPolicyLocal)
    {
        SamFreeMemory(EffectivePasswordPolicyLocal);
    }

    return(SampMapCompletionStatus(NtStatus));


}



NTSTATUS
SamiChangePasswordUser2(
    PUNICODE_STRING ServerName,
    PUNICODE_STRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    BOOLEAN LmPresent,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt
    )
/*++


Routine Description:

    Changes the password of a user account. This is the worker routine for
    SamChangePasswordUser2 and can be called by OWF-aware clients.
    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    NewPasswordEncryptedWithOldNt - The new cleartext password encrypted
        with the old NT OWF password.

    OldNtOwfPasswordEncryptedWithNewNt - The old NT OWF password encrypted
        with the new NT OWF password.

    LmPresent - If TRUE, indicates that the following two last parameter
        was encrypted with the LM OWF password not the NT OWF password.

    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted
        with the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLmOrNt - The old LM OWF password encrypted
        with the new LM OWF password.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    handle_t BindingHandle;
    PSAMPR_SERVER_NAME RServerNameWithNull;
    USHORT RServerNameWithNullLength;
    PSAMPR_SERVER_NAME  RServerName;
    ULONG Tries = 2;
    NTSTATUS NtStatus;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;

    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';

    }


    do
    {
        //
        // Try privacy level first, and if that failed with unknown authn
        // level or invalid binding try with a lower level (none).
        //

        if (Tries == 2) {
            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                );


        } else if ((NtStatus == RPC_NT_UNKNOWN_AUTHN_LEVEL) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_TYPE) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_SERVICE) ||
                   (NtStatus == RPC_NT_INVALID_BINDING) ||
                   (NtStatus == STATUS_ACCESS_DENIED) ) {
            SampSecureUnbind(BindingHandle);

            BindingHandle = SampSecureBind(
                                RServerNameWithNull,
                                RPC_C_AUTHN_LEVEL_NONE
                                );

        } else {
            break;
        }

        if (BindingHandle != NULL) {

            RpcTryExcept{

                //
                // Get password information to make sure this operation
                // is allowed.  We do it now because we wanted to bind
                // before trying it.
                //

                NtStatus = SamrGetDomainPasswordInformation(
                               BindingHandle,
                               (PRPC_UNICODE_STRING) ServerName,
                               &PasswordInformation
                               );

                if ((( NtStatus == STATUS_SUCCESS ) &&
                    (( PasswordInformation.PasswordProperties &
                        DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) == 0 ) ) ||
                    (NtStatus == STATUS_ACCESS_DENIED ) ) {


                    NtStatus = SamrUnicodeChangePasswordUser2(
                                       BindingHandle,
                                       (PRPC_UNICODE_STRING) ServerName,
                                       (PRPC_UNICODE_STRING) UserName,
                                       NewPasswordEncryptedWithOldNt,
                                       OldNtOwfPasswordEncryptedWithNewNt,
                                       LmPresent,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLmOrNt
                                       );

                } else {

                    //
                    // Set the error to indicate that we should try the
                    // downlevel way to change passwords.
                    //

                    NtStatus = STATUS_NOT_SUPPORTED;
                }



            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {


                //
                // The mapping function doesn't handle this error so
                // special case it by hand.
                //
                NtStatus = RpcExceptionCode();

                if (NtStatus == RPC_S_SEC_PKG_ERROR) {
                    NtStatus = STATUS_ACCESS_DENIED;
                } else {
                    if (NtStatus == ERROR_PASSWORD_MUST_CHANGE) {
                        //
                        // I_RpcMapWin32Status returns WinError's
                        // when it can't map the error
                        //
                        NtStatus = STATUS_PASSWORD_MUST_CHANGE;
                    } else {
                        NtStatus = I_RpcMapWin32Status(NtStatus);
                    }
                }


            } RpcEndExcept;

        } else {
            NtStatus = RPC_NT_INVALID_BINDING;
        }

        Tries--;
    } while ( (Tries > 0) && (!NT_SUCCESS(NtStatus)) );
    if (RServerNameWithNull != NULL) {
        MIDL_user_free( RServerNameWithNull );
    }

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }
    return(SampMapCompletionStatus(NtStatus));


}
NTSTATUS
SamiOemChangePasswordUser2(
    PSTRING ServerName,
    PSTRING UserName,
    PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLm
    )
/*++


Routine Description:

    Changes the password of a user account. This  can be called by OWF-aware
    clients. Password will be set to NewPassword only if OldPassword matches
    the current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed


    NewPasswordEncryptedWithOldLm - The new cleartext password encrypted
        with the old LM OWF password.

    OldLmOwfPasswordEncryptedWithNewLm - The old LM OWF password encrypted
        with the new LM OWF password.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/

{
    handle_t BindingHandle = NULL;
    UNICODE_STRING RemoteServerName;
    ULONG Tries = 2;
    NTSTATUS NtStatus;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;

    RemoteServerName.Buffer = NULL;
    RemoteServerName.Length = 0;

    if (ARGUMENT_PRESENT(ServerName)) {

        NtStatus = RtlAnsiStringToUnicodeString(
                        &RemoteServerName,
                        ServerName,
                        TRUE            // allocate destination
                        );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
        ASSERT(RemoteServerName.Buffer[RemoteServerName.Length/sizeof(WCHAR)] == L'\0');
    }


    do
    {
        //
        // Try privacy level first, and if that failed with unknown authn
        // level or invalid binding try with a lower level (none).
        //

        if (Tries == 2) {
            BindingHandle = SampSecureBind(
                                RemoteServerName.Buffer,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                );


        } else if ((NtStatus == RPC_NT_UNKNOWN_AUTHN_LEVEL) ||
                   (NtStatus == RPC_NT_UNKNOWN_AUTHN_TYPE) ||
                   (NtStatus == RPC_NT_INVALID_BINDING) ||
                   (NtStatus == STATUS_ACCESS_DENIED) ) {
            SampSecureUnbind(BindingHandle);

            BindingHandle = SampSecureBind(
                                RemoteServerName.Buffer,
                                RPC_C_AUTHN_LEVEL_NONE
                                );

        } else {
            break;
        }

        if (BindingHandle != NULL) {

            RpcTryExcept{

                //
                // Get password information to make sure this operation
                // is allowed.  We do it now because we wanted to bind
                // before trying it.
                //

                NtStatus = SamrGetDomainPasswordInformation(
                               BindingHandle,
                               (PRPC_UNICODE_STRING) ServerName,
                               &PasswordInformation
                               );


               if ((( NtStatus == STATUS_SUCCESS ) &&
                    (( PasswordInformation.PasswordProperties &
                    DOMAIN_PASSWORD_NO_CLEAR_CHANGE ) == 0 ) ) ||
                    (NtStatus == STATUS_ACCESS_DENIED ) ) {


                        NtStatus = SamrOemChangePasswordUser2(
                                       BindingHandle,
                                       (PRPC_STRING) ServerName,
                                       (PRPC_STRING) UserName,
                                       NewPasswordEncryptedWithOldLm,
                                       OldLmOwfPasswordEncryptedWithNewLm
                                       );

                } else {

                    //
                    // Set the error to indicate that we should try the
                    // downlevel way to change passwords.
                    //

                    NtStatus = STATUS_NOT_SUPPORTED;
                }



            } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {


                //
                // The mappin function doesn't handle this error so
                // special case it by hand.
                //

                if (NtStatus == RPC_S_SEC_PKG_ERROR) {
                    NtStatus = STATUS_ACCESS_DENIED;
                } else {
                    NtStatus = I_RpcMapWin32Status(RpcExceptionCode());
                }


            } RpcEndExcept;

        } else {
            NtStatus = RPC_NT_INVALID_BINDING;
        }

        Tries--;
    } while ( (Tries > 0) && (!NT_SUCCESS(NtStatus)) );

    RtlFreeUnicodeString( &RemoteServerName );

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }

    return(SampMapCompletionStatus(NtStatus));

}


NTSTATUS
SamChangePasswordUser3(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword,
    OUT PDOMAIN_PASSWORD_INFORMATION * EffectivePasswordPolicy OPTIONAL,
    OUT PUSER_PWD_CHANGE_FAILURE_INFORMATION *PasswordChangeFailureInfo OPTIONAL
   )

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

    EffectivePasswordPolicy - returns the current effective password
                              policy

    PasswordChangeFailureInfo -- If the password change failed ( say due
                  to a password policy ) then this field might contain
                  additional info regarding the effective policy.

    if those optional parameters are supplied, then the caller is
    responsible to release the memory by calling SamFreeMemory().
    (EffectivePasswordPolicy and PasswordChangeFailureInfo, plus
     PasswordChangeFailureInfo->FilterModuleName.Buffer != NULL )


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldNt;
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt;
    ENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt;
    NTSTATUS            NtStatus;
    BOOLEAN             LmPresent = TRUE;
    ULONG               AuthnLevel;
    ULONG               Tries = 2;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;

    //
    // Initialize return values
    //

    if (ARGUMENT_PRESENT(PasswordChangeFailureInfo))
    {
        *PasswordChangeFailureInfo = NULL;
    }
    if (ARGUMENT_PRESENT(EffectivePasswordPolicy))
    {
        *EffectivePasswordPolicy = NULL;
    }

    //
    // Call the server, passing either a NULL Server Name pointer, or
    // a pointer to a Unicode Buffer with a Wide Character NULL terminator.
    // Since the input name is contained in a counted Unicode String, there
    // is no NULL terminator necessarily provided, so we must append one.
    //

    //
    // Encrypted the passwords
    //

    NtStatus = SamiEncryptPasswords(
                OldPassword,
                NewPassword,
                &NewNtEncryptedWithOldNt,
                &OldNtOwfEncryptedWithNewNt,
                &LmPresent,
                &NewNtEncryptedWithOldLm,
                &OldLmOwfEncryptedWithNewNt
                );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Try the remote call...
    //


    NtStatus = SamiChangePasswordUser3(
                   ServerName,
                   UserName,
                   &NewNtEncryptedWithOldNt,
                   &OldNtOwfEncryptedWithNewNt,
                   LmPresent,
                   &NewNtEncryptedWithOldLm,
                   &OldLmOwfEncryptedWithNewNt,
                   EffectivePasswordPolicy,
                   PasswordChangeFailureInfo
                   );


    //
    // If the new API failed, try calling the old API.
    //

    if (NtStatus == STATUS_NOT_SUPPORTED) {

        NtStatus = SampChangePasswordUser2(
                    ServerName,
                    UserName,
                    OldPassword,
                    NewPassword
                    );
    }

    return(SampMapCompletionStatus(NtStatus));

}


NTSTATUS
SamChangePasswordUser2(
    IN PUNICODE_STRING ServerName,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING OldPassword,
    IN PUNICODE_STRING NewPassword
)

/*++


Routine Description:

    Password will be set to NewPassword only if OldPassword matches the
    current user password for this user and the NewPassword is not the
    same as the domain password parameter PasswordHistoryLength
    passwords.  This call allows users to change their own password if
    they have access USER_CHANGE_PASSWORD.  Password update restrictions
    apply.


Parameters:

    ServerName - The server to operate on, or NULL for this machine.

    UserName - Name of user whose password is to be changed

    OldPassword - Current password for the user.

    NewPassword - Desired new password for the user.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_ILL_FORMED_PASSWORD - The new password is poorly formed,
        e.g. contains characters that can't be entered from the
        keyboard, etc.

    STATUS_PASSWORD_RESTRICTION - A restriction prevents the password
        from being changed.  This may be for a number of reasons,
        including time restrictions on how often a password may be
        changed or length restrictions on the provided password.

        This error might also be returned if the new password matched
        a password in the recent history log for the account.
        Security administrators indicate how many of the most
        recently used passwords may not be re-used.  These are kept
        in the password recent history log.

    STATUS_WRONG_PASSWORD - OldPassword does not contain the user's
        current password.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldNt;
    SAMPR_ENCRYPTED_USER_PASSWORD NewNtEncryptedWithOldLm;
    ENCRYPTED_NT_OWF_PASSWORD OldNtOwfEncryptedWithNewNt;
    ENCRYPTED_NT_OWF_PASSWORD OldLmOwfEncryptedWithNewNt;
    NTSTATUS            NtStatus;
    BOOLEAN             LmPresent = TRUE;
    ULONG               AuthnLevel;
    ULONG               Tries = 2;
    USER_DOMAIN_PASSWORD_INFORMATION PasswordInformation;


    //
    // Call the server, passing either a NULL Server Name pointer, or
    // a pointer to a Unicode Buffer with a Wide Character NULL terminator.
    // Since the input name is contained in a counted Unicode String, there
    // is no NULL terminator necessarily provided, so we must append one.
    //

    //
    // Encrypted the passwords
    //

    NtStatus = SamiEncryptPasswords(
                OldPassword,
                NewPassword,
                &NewNtEncryptedWithOldNt,
                &OldNtOwfEncryptedWithNewNt,
                &LmPresent,
                &NewNtEncryptedWithOldLm,
                &OldLmOwfEncryptedWithNewNt
                );

    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Try the remote call...
    //


    NtStatus = SamiChangePasswordUser2(
                   ServerName,
                   UserName,
                   &NewNtEncryptedWithOldNt,
                   &OldNtOwfEncryptedWithNewNt,
                   LmPresent,
                   &NewNtEncryptedWithOldLm,
                   &OldLmOwfEncryptedWithNewNt
                   );


    //
    // If the new API failed, try calling the old API.
    //

    if (NtStatus == STATUS_NOT_SUPPORTED) {

        NtStatus = SampChangePasswordUser2(
                    ServerName,
                    UserName,
                    OldPassword,
                    NewPassword
                    );
    }

    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamiSetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    IN SAMPR_BOOT_TYPE BootOptions,
    IN PUNICODE_STRING OldBootKey, OPTIONAL
    IN PUNICODE_STRING NewBootKey OPTIONAL
    )
/*++

Routine Description:

    This routine sets the boot key

Arguments:

    DomainHandle - Handle to the account domain object.
    BootOptions - New boot options.
    OldBootKey - If changing the boot key, old key must be provided.
    NewBootKey - New key to require for booting if changing or setting.

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Access was denied.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{


        NtStatus = SamrSetBootKeyInformation(
                    RpcContextHandle,
                    BootOptions,
                    (PRPC_UNICODE_STRING) OldBootKey,
                    (PRPC_UNICODE_STRING) NewBootKey
                    );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}



NTSTATUS
SamiGetBootKeyInformation(
    IN SAM_HANDLE DomainHandle,
    OUT PSAMPR_BOOT_TYPE BootOptions
    )
/*++
Routine Description:

    Establish a session with a SAM subsystem and subsequently open the
    SamServer object of that subsystem.  The caller must have
    SAM_SERVER_CONNECT access to the SamServer object of the subsystem
    being connected to.

    The handle returned is for use in future calls.


Arguments:

    DomainHandle - Handle to the account domain object.
    BootOptions - Current boot options

Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Access was denied.


--*/
{
    NTSTATUS            NtStatus;
    SAMPR_HANDLE        RpcContextHandle;


    if (!SampIsValidClientHandle(DomainHandle, &RpcContextHandle)) {
        return STATUS_INVALID_HANDLE;
    }

    //
    // Call the server ...
    //


    RpcTryExcept{

        NtStatus = SamrGetBootKeyInformation(
                    RpcContextHandle,
                    BootOptions
                    );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;


    return(SampMapCompletionStatus(NtStatus));

}

NTSTATUS
SamiChangeKeys()
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMPR_HANDLE  ServerHandle = NULL;
    SAMPR_HANDLE  DomainHandle=NULL;
    LSA_HANDLE    PolicyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    SAMPR_BOOT_TYPE   BootOptions;
    UCHAR    OriginalSyskeyBuffer[16];
    ULONG    OriginalSyskeyLen = sizeof(OriginalSyskeyBuffer);
    UNICODE_STRING OriginalSyskey;
    UCHAR    NewSyskeyBuffer[16];
    ULONG    NewSyskeyLen = sizeof(NewSyskeyBuffer);
    UNICODE_STRING NewSyskey;

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes call doesn't initialize the
    // quality of serivce, so do that separately.
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;



    NtStatus = LsaOpenPolicy(
                NULL, // local LSA
                &ObjectAttributes,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = LsaQueryInformationPolicy(
                PolicyHandle,
                PolicyAccountDomainInformation,
                &AccountDomainInfo
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamConnect(
                NULL, // Local SAM
                &ServerHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                &ObjectAttributes
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamOpenDomain(
                ServerHandle,
                DOMAIN_WRITE_PASSWORD_PARAMS|DOMAIN_READ_PASSWORD_PARAMETERS,
                AccountDomainInfo->DomainSid,
                &DomainHandle
                );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus = SamiGetBootKeyInformation(
                    DomainHandle,
                    &BootOptions
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    if (SamBootKeyStored!=BootOptions) {
        NtStatus = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Get the current syskey
    //

    NtStatus = WxReadSysKey(
                    &OriginalSyskeyLen,
                    OriginalSyskeyBuffer
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Change the password encryption key
    //

    OriginalSyskey.Length = OriginalSyskey.MaximumLength = (USHORT)OriginalSyskeyLen;
    OriginalSyskey.Buffer = (WCHAR * )OriginalSyskeyBuffer;

    NtStatus = SamiSetBootKeyInformation(
                    DomainHandle,
                    SamBootChangePasswordEncryptionKey,
                    &OriginalSyskey,
                    &OriginalSyskey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Generate the syskey
    //

    if (!RtlGenRandom( NewSyskeyBuffer, NewSyskeyLen)) {
     NtStatus = STATUS_UNSUCCESSFUL;
     goto Cleanup;
    }

    NewSyskey.Length = NewSyskey.MaximumLength
                                    = (USHORT)NewSyskeyLen;
    NewSyskey.Buffer = (WCHAR * )NewSyskeyBuffer;

    //
    // Change state in LSA and Sam to use the new key
    //

    NtStatus = SamiSetBootKeyInformation(
                    DomainHandle,
                    SamBootKeyStored,
                    &OriginalSyskey,
                    &NewSyskey
                    );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Write the new syskey to disk
    //

    NtStatus = WxSaveSysKey(NewSyskey.Length,NewSyskey.Buffer);


Cleanup:

    if (DomainHandle != NULL) {
        SamCloseHandle(DomainHandle);
    }
    if (ServerHandle != NULL) {
        SamCloseHandle(ServerHandle);
    }
    if (PolicyHandle != NULL){
        LsaClose(PolicyHandle);
    }
    if (AccountDomainInfo != NULL) {
        LsaFreeMemory(AccountDomainInfo);
    }

    return(NtStatus);

}



NTSTATUS
SamGetCompatibilityMode(
    IN  SAM_HANDLE ObjectHandle,
    OUT ULONG*     Mode
    )
/*++

Routine Description:

    This routine returns the emulation mode of the server that the handle
    was returned from.

Arguments:

    ObjectHandle -- a SAM handle returned from a SAM client API

    Mode --  SAM_SID_COMPATIBILITY_ALL:  no extended sid work

             SAM_SID_COMPATIBILITY_LAX:  set rid field to zero for callers

             SAM_SID_COMPATIBILITY_STRICT:  don't allow levels with RID field

Return Value:

    STATUS_SUCCESS

    STATUS_INVALID_HANDLE

    STATUS_INVALID_PARAMETER


--*/
{
    SAMP_HANDLE SampHandle = (SAMP_HANDLE) ObjectHandle;

    if (!SampIsValidClientHandle(ObjectHandle, NULL)) {
        return STATUS_INVALID_HANDLE;
    }

    if (NULL == Mode) {
        return STATUS_INVALID_PARAMETER;
    }

    *Mode = SAM_SID_COMPATIBILITY_ALL;
    if ( (SampHandle->ServerInfo.SupportedFeatures & SAM_EXTENDED_SID_DOMAIN_COMPAT_1) ) {
        *Mode = SAM_SID_COMPATIBILITY_LAX;
    } else if (SampHandle->ServerInfo.SupportedFeatures & SAM_EXTENDED_SID_DOMAIN_COMPAT_2) {
        *Mode = SAM_SID_COMPATIBILITY_STRICT;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SamConnectWithCreds(
    IN  PUNICODE_STRING             ServerName,
    OUT PSAM_HANDLE                 ServerHandle,
    IN  ACCESS_MASK                 DesiredAccess,
    IN  POBJECT_ATTRIBUTES          ObjectAttributes,
    IN  RPC_AUTH_IDENTITY_HANDLE    Creds,
    IN  PWCHAR                      Spn,
    OUT BOOL                        *pfDstIsW2K

    )
{
    NTSTATUS    status;
    TlsInfo     tlsInfo;

    *pfDstIsW2K = FALSE;

    if ( !Creds || !ServerName || !ServerName->Buffer || !ServerName->Length )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    if ( !TlsSetValue(gTlsIndex, &tlsInfo) )
    {
        return(I_RpcMapWin32Status(GetLastError()));
    }

    tlsInfo.Creds = Creds;
    tlsInfo.Spn = Spn;
    tlsInfo.fDstIsW2K = FALSE;

    status = SamConnect(ServerName, ServerHandle,
                        DesiredAccess, ObjectAttributes);

    if ( NT_SUCCESS(status) )
    {
        *pfDstIsW2K = tlsInfo.fDstIsW2K;
    }

    TlsSetValue(gTlsIndex, NULL);
    return(status);
}


NTSTATUS
SampCreateNewHandle(
    IN  SAMP_HANDLE RequestingHandle OPTIONAL,
    IN  PSID        DomainSid        OPTIONAL,
    OUT SAMP_HANDLE* NewHandle
    )
/*++

Routine Description:

    This routine allocates a new client side SAM handle.

Arguments:

    RequestingHandle -- handle the SAM client side function was called with
                        Used for transferring information about the server
                        to the new handle

    DomainSid        -- the domain SID (used during SamOpenDomain)

    NewHandle        -- the created handle

Return Value:

    STATUS_SUCCESS

    STATUS_NO_MEMORY


--*/
{
    SAMP_HANDLE LocalHandle;
    ULONG Length;
    PSID  Sid = NULL;

    ASSERT(NewHandle);
    *NewHandle = NULL;

    //
    // Allocate the handle
    //
    LocalHandle = MIDL_user_allocate(sizeof(SAMP_CLIENT_INFO));
    if (NULL == LocalHandle) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(LocalHandle, sizeof(SAMP_CLIENT_INFO));

    //
    // Copy in the server info, if any
    //
    if ( RequestingHandle ) {

        RtlCopyMemory(&LocalHandle->ServerInfo,
                      &RequestingHandle->ServerInfo,
                      sizeof(LocalHandle->ServerInfo));

        if (RequestingHandle->DomainSid) {
            Sid = RequestingHandle->DomainSid;
        }
    }

    if ( DomainSid ) {
        ASSERT( NULL == Sid );
        Sid = DomainSid;
    }

    //
    // Copy in the sid, if any
    //
    if ( Sid ) {
        Length = RtlLengthSid( Sid );
        LocalHandle->DomainSid = MIDL_user_allocate(Length);
        if (LocalHandle->DomainSid) {
            RtlCopySid(Length, LocalHandle->DomainSid, Sid);
        } else {
            MIDL_user_free(LocalHandle);
            return STATUS_NO_MEMORY;
        }
    }

    *NewHandle = LocalHandle;

    return STATUS_SUCCESS;

}



VOID
SampFreeHandle(
    IN OUT SAMP_HANDLE *Handle
    )
/*++

Routine Description:

    This routine frees the memory associated with Handle.
    It does not free the context handle

Arguments:

    Handle -- the handle to free; set to 0 on return

Return Value:

    None.

--*/
{
    ASSERT(Handle);
    if (*Handle) {
        if ( (*Handle)->DomainSid) {
            MIDL_user_free((*Handle)->DomainSid);
        }
        RtlZeroMemory(*Handle, sizeof(SAMP_CLIENT_INFO));
        MIDL_user_free(*Handle);
        *Handle = NULL;
    }
    return;
}



NTSTATUS
SamRidToSid (
    IN SAM_HANDLE Handle,
    IN ULONG      Rid,
    OUT PSID*     Sid
    )
/*++

Routine Description:

    This routine creates a SID given a the SAM handle that was passed into
    the routine that return the Rid that is passed in.

Arguments:

    Handle -- the SAM handle that was used to obtain the RID that is being
              passed in

    Rid    -- the "handle" relative id of a security principal

    Sid    -- the SID of principal referred to by Rid

Return Value:

    STATUS_SUCCESS

    STATUS_NOT_FOUND the RID could not be found

    a fatal NT resource or network error otherwise

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    SAMP_HANDLE SampHandle = (SAMP_HANDLE) Handle;


    if (!SampIsValidClientHandle(Handle, NULL)) {
        return STATUS_INVALID_HANDLE;
    }

    if (IsBadWritePtr(Sid, sizeof(PSID))) {
        return STATUS_INVALID_PARAMETER;
    }

#define SAMP_EXTENDED_SID_DOMAIN(x)                               \
   ((x)->ServerInfo.SupportedFeatures & (SAM_EXTENDED_SID_DOMAIN))

    if ( SAMP_EXTENDED_SID_DOMAIN(SampHandle) ) {

        //
        // Make network call
        //
        *Sid = NULL;

        NtStatus = SamrRidToSid(SampHandle->ContextHandle,
                                Rid,
                                (PRPC_SID*) Sid);


    } else {

        //
        // Perform locally
        //
        if (NULL == SampHandle->DomainSid) {
            return STATUS_INVALID_PARAMETER;
        }

        NtStatus = SampMakeSid(SampHandle->DomainSid,
                               Rid,
                               Sid);
    }

    return NtStatus;
}


NTSTATUS
SampMakeSid(
    IN PSID  DomainSid,
    IN ULONG Rid,
    OUT PSID* Sid
    )
/*++

Routine Description:

    This routine creates an account SID given a ULONG Rid and DomainSid

Arguments:

    DomainSid - The template SID to use.

    Rid       - The relative Id to append to the DomainId.

    Sid       - Returns a pointer to an allocated buffer containing the resultant
                Sid.  Free this buffer using MIDL_user_free (or SamFreeMemory).

Return Value:

    STATUS_SUCCESS - if successful

    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    UCHAR DomainIdSubAuthorityCount; // Number of sub authorities in domain ID
    ULONG SidLength;                 // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //
    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainSid ));
    SidLength = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((*Sid = (PSID) MIDL_user_allocate( SidLength )) == NULL ) {
        return STATUS_NO_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //
    RtlCopySid( SidLength, *Sid, DomainSid );

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( *Sid ))) ++;
    *RtlSubAuthoritySid( *Sid, DomainIdSubAuthorityCount ) = Rid;

    return STATUS_SUCCESS;
}


BOOLEAN
SampIsValidClientHandle(
    IN     SAM_HANDLE    SamHandle,
    IN OUT SAMPR_HANDLE *RpcHandle OPTIONAL
    )
/*++

Routine Description:

    This routine determines if the handle passed in from the client of
    samlib.dll (SamHandle) is valid or not.

    Note all exceptions are handled during deferences.

Arguments:

    SamHandle - client provided handle

    RpcHandle - set to the RpcContextHandle embedded in SamHandle (if SamHandle
                is valid)

Return Value:

    TRUE if valid; FALSE otherwise

--*/
{
    BOOLEAN fReturn = TRUE;
    SAMP_HANDLE SampHandle = (SAMP_HANDLE)SamHandle;
    SAMPR_HANDLE RpcContextHandle = NULL;

    if (NULL == SampHandle) {
        fReturn = FALSE;
    } else {
        _try {
            RpcContextHandle = SampHandle->ContextHandle;
            if (NULL == RpcContextHandle) {
                fReturn = FALSE;
            }
            if (SampHandle->DomainSid) {
                if (!RtlValidSid(SampHandle->DomainSid)) {
                    fReturn = FALSE;
                }
            }
        } _except ( EXCEPTION_EXECUTE_HANDLER ) {
            fReturn = FALSE;
        }
    }

    if (fReturn && RpcHandle) {
        *RpcHandle = RpcContextHandle;
    }

    return fReturn;
}



NTSTATUS
SampEncryptPasswordWithIndex(
    IN PUNICODE_STRING  ClearPassword,
    IN NT_OWF_PASSWORD  *PassedInNtOWFPassword,
    IN ULONG    Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD   EncryptedNtOwfPassword
    )
/*++

Routine Description:

    This routine generates NT OWF password, and furthe encrypts it
    with passed in Index.


Parameters:

    ClearPassword - clear text password to be encrypted

    Index - index to use

    EncryptedNtOwfPassword - return encrypted NT OWF password

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NT_OWF_PASSWORD NtOwfPassword;
    CRYPT_INDEX     EncryptIndex = Index;



    if (ARGUMENT_PRESENT(ClearPassword))
    {
        NtStatus = RtlCalculateNtOwfPassword(ClearPassword,
                                         &NtOwfPassword
                                         );
    }
    else
    {
        RtlCopyMemory(
            &NtOwfPassword,
            PassedInNtOWFPassword,
            sizeof(NT_OWF_PASSWORD)
            );
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlEncryptNtOwfPwdWithIndex(
                                    &NtOwfPassword,
                                    &EncryptIndex,
                                    EncryptedNtOwfPassword
                                    );
    }

    return( NtStatus );
}




NTSTATUS
SampSetDSRMPassword(
    IN PUNICODE_STRING  ServerName OPTIONAL,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    )
/*++
Routine Description:

    This routine connects to the server passed in, then sets that server's
    Directory Service Restore Mode User Account (specified by UserId) Password.

    Currently only Administrator Account Password Can be set.

Parameters:

    ServerName - Domain Controller's name to use.
                 Local machine will be used if NULL passed in.

    UserId - Only Administrator Account Relative ID is valid right now.

    ClearPassword - new password

Return Value:

    NTSTATUS Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    handle_t    BindingHandle = NULL;
    PSAMPR_SERVER_NAME  RServerName = NULL;
    PSAMPR_SERVER_NAME  RServerNameWithNull = NULL;
    USHORT      RServerNameWithNullLength = 0;
    ENCRYPTED_NT_OWF_PASSWORD   EncryptedNtOwfPassword;


    //
    // check input parameter
    //

    if ((NULL == ClearPassword) && (NULL==NtOwfPassword))
    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // extract server name
    //

    RServerNameWithNull = NULL;

    if (ARGUMENT_PRESENT(ServerName)) {

        RServerName = (PSAMPR_SERVER_NAME)(ServerName->Buffer);
        RServerNameWithNullLength = ServerName->Length + (USHORT) sizeof(WCHAR);
        RServerNameWithNull = MIDL_user_allocate( RServerNameWithNullLength );

        if (RServerNameWithNull == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlCopyMemory( RServerNameWithNull, RServerName, ServerName->Length);
        RServerNameWithNull[ServerName->Length/sizeof(WCHAR)] = L'\0';
    }


    //
    // encrypt password
    //

    NtStatus = SampEncryptPasswordWithIndex(ClearPassword,
                                            NtOwfPassword,
                                            UserId,
                                            &EncryptedNtOwfPassword
                                            );

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // make secure RPC connection
    //

    BindingHandle = SampSecureBind(RServerNameWithNull,
                                   RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                                   );

    if (NULL != BindingHandle)
    {
        //
        // talk to server, set DSRM admin password
        //
        RpcTryExcept {

            NtStatus = SamrSetDSRMPassword(BindingHandle,
                                           (PRPC_UNICODE_STRING) ServerName,
                                           UserId,
                                           &EncryptedNtOwfPassword
                                           );

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            NtStatus = I_RpcMapWin32Status(RpcExceptionCode());

        } RpcEndExcept;
    }
    else
    {
        NtStatus = RPC_NT_INVALID_BINDING;
    }



Error:

    //
    // Clean up
    //

    if (NULL != RServerNameWithNull) {
        MIDL_user_free( RServerNameWithNull );
    }

    if (BindingHandle != NULL) {
        SampSecureUnbind(BindingHandle);
    }

    //
    // Map these errors to STATUS_NOT_SUPPORTED
    //

    if ((NtStatus == RPC_NT_UNKNOWN_IF) ||
        (NtStatus == RPC_NT_PROCNUM_OUT_OF_RANGE)) {

        NtStatus = STATUS_NOT_SUPPORTED;
    }

    return( NtStatus );
}


NTSTATUS
SamiSetDSRMPassword(
    IN PUNICODE_STRING  ServerName OPTIONAL,
    IN ULONG            UserId,
    IN PUNICODE_STRING  ClearPassword
    )
{
    return(SampSetDSRMPassword(
                    ServerName ,
                    UserId,
                    ClearPassword,
                    NULL
                    ));
}

NTSTATUS
SamiSetDSRMPasswordOWF(
    IN PUNICODE_STRING  ServerName OPTIONAL,
    IN ULONG            UserId,
    IN PNT_OWF_PASSWORD NtPassword
    )
{
    return(SampSetDSRMPassword(
                    ServerName ,
                    UserId,
                    NULL,
                    NtPassword
                    ));
}

NTSTATUS
SampDsMakeSpnW(
    IN PWSTR ServiceClass, 
    IN PWSTR ServiceName, 
    IN OPTIONAL PWSTR InstanceName, 
    IN OPTIONAL USHORT InstancePort, 
    IN OPTIONAL PWSTR Referrer, 
    OUT PWSTR *Spn
)
/*
Routine Description:

    This routine is wrapper around DsMakeSpnW to avoid two calls to this function,
    one to find the size of the return value and second to get the actual value.
    
Arguments:

    ServiceClass -- Pointer to a constant null-terminated Unicode string specifying the 
        class of the service. This parameter may be any string unique to that service; 
        either the protocol name (for example, ldap) or the string form of a GUID will work. 
        
    ServiceName -- Pointer to a constant null-terminated string specifying the DNS name, 
        NetBIOS name, or distinguished name (DN). This parameter must be non-NULL. 

    InstanceName -- Pointer to a constant null-terminated Unicode string specifying the DNS name 
        or IP address of the host for an instance of the service. If ServiceName specifies 
        the DNS or NetBIOS name of the service's host computer, the InstanceName parameter must be NULL.

    InstancePort -- Port number for an instance of the service. Use 0 for the default port. 
        If this parameter is zero, the SPN does not include a port number. 
        
    Referrer -- Pointer to a constant null-terminated Unicode string specifying the DNS name 
        of the host that gave an IP address referral. This parameter is ignored unless the 
        ServiceName parameter specifies an IP address. 

    Spn -- Pointer to a Unicode string that receives the constructed SPN.

Return Value:

    STATUS_SUCCESS
        Successful

    STATUS_NO_MEMORY
        not enough memory to complete the task

    STATUS_INVALID_PARAMETER
        one of the parameters is invalid

    STATUS_INTERNAL_ERROR
        opps something went wrong!

*/
{
    DWORD DwStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpnLength = 0;

    *Spn = NULL;
    DwStatus = DsMakeSpnW(
                    ServiceClass,
                    ServiceName,
                    NULL,
                    0,
                    NULL,
                    &SpnLength,
                    NULL
                    );
    
    if( DwStatus != ERROR_BUFFER_OVERFLOW ) {

        ASSERT( !"DwStatus must be INVALID_PARAMETER, so which parameter did we pass wrong?" );
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    *Spn = MIDL_user_allocate( SpnLength * sizeof( WCHAR ) );
    
    if( *Spn == NULL ) {
        
        Status = STATUS_NO_MEMORY;
        goto Error;
    }
    
    DwStatus = DsMakeSpnW(
                    ServiceClass,
                    ServiceName,
                    NULL,
                    0,
                    NULL,
                    &SpnLength,
                    *Spn
                    );
    
    if( DwStatus != ERROR_SUCCESS ) {
        
        ASSERT( !"DwStatus must be INVALID_PARAMETER or BUFFER_OVERFLOW, so what did we do wrong?" );
        Status = STATUS_INTERNAL_ERROR;
        goto Error;
    }
Exit:    

    return Status;

Error:

    ASSERT( !NT_SUCCESS( Status ) );

    MIDL_user_free( *Spn );
    *Spn = NULL;
    goto Exit;
}
NTSTATUS
SamValidatePassword(
    IN OPTIONAL PUNICODE_STRING                 ServerName,
    IN          PASSWORD_POLICY_VALIDATION_TYPE ValidationType,
    IN          PSAM_VALIDATE_INPUT_ARG         InputArg,
    OUT         PSAM_VALIDATE_OUTPUT_ARG        *OutputArg
    )
/*++

Routine Description:

    This routine connects to the server provided and validates the
    password if it matches the policy of the domain.

Arguments:

    ServerName - name of the Server to connect NULL can be used to use local machine

    ValidationType - What type of check is to be done

        -SamValidateAuthentication
        -SamValidatePasswordChange
        -SamValidatePasswordReset

    InputArg - Information about what type of validation is to be made

    OutputArg - Result of the validation

Return Value:

    STATUS_SUCCESS
        CHECK OutputArg->ValidationStatus for details

    return codes of NtQuerySystemTime

    STATUS_NO_MEMORY
        not enough memory to complete the task

    STATUS_INVALID_PARAMETER
        one of the parameters is invalid

    STATUS_ACCESS_DENIED
        Caller doesn't have access to password policy


--*/

{
#define SERVICE_CLASS L"HOST"
    handle_t BindingHandle = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR StringBinding = NULL;
    PWSTR ServerName2 = NULL;
    PWSTR Spn = NULL;
    PWSTR ServiceName = NULL;
    
    if( !ARGUMENT_PRESENT( OutputArg ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Build a null-terminated ServerName 
    //

    if( ARGUMENT_PRESENT( ServerName ) ) {

        ULONG SizeOfServerName = ServerName->Length + sizeof( WCHAR );
        PWSTR ServerString = ServerName->Buffer;

        if( ServerString != NULL ) {
            
            if( wcsncmp( ServerString, L"\\\\", 2 ) == 0 ) {

                ServerString += 2;
                SizeOfServerName -= 4;
            }

            ServerName2 = MIDL_user_allocate( SizeOfServerName );
            
            if( ServerName2 == NULL ) {
                
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            CopyMemory( ServerName2, ServerString, SizeOfServerName - sizeof( WCHAR ) );
            ServerName2[ SizeOfServerName / sizeof( *ServerString ) - 1 ] = UNICODE_NULL;
            ServiceName = ServerName2;
        }
    }

    //
    // Build a string binding from this information
    //

    Status = I_RpcMapWin32Status( 
                RpcStringBindingComposeW(
                    NULL,
                    L"ncacn_ip_tcp",
                    ServerName2,
                    NULL,
                    NULL,
                    &StringBinding
                    ) 
                );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    //
    // Build the binding handle from the string binding
    //

    Status = I_RpcMapWin32Status( 
                RpcBindingFromStringBindingW(
                    StringBinding,
                    &BindingHandle
                    )
                );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    //
    // Build SPN
    //

    if( ServerName2 == NULL ) {

        ULONG ServiceNameLength = MAX_COMPUTERNAME_LENGTH + 1;

        ServiceName = MIDL_user_allocate( ServiceNameLength * sizeof( WCHAR ) );

        if( ServiceName == NULL ) {

            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        if( GetComputerNameW( ServiceName, &ServiceNameLength ) == FALSE ) {

            Status = STATUS_UNSUCCESSFUL;
            goto Error;
        }
    }

    Status = SampDsMakeSpnW(
                    SERVICE_CLASS,
                    ServiceName,
                    NULL,
                    0,
                    NULL,
                    &Spn
                    );
    
    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }
    //
    // Set authentication info
    //

    Status = I_RpcMapWin32Status( 
                RpcBindingSetAuthInfoW(
                    BindingHandle,
                    Spn,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_AUTHN_GSS_NEGOTIATE,
                    NULL,
                    RPC_C_AUTHZ_NONE
                    )
                );

    if( !NT_SUCCESS( Status ) ) {

        goto Error;
    }

    //1 Call the appropriate function
    
    *OutputArg = NULL;

    RpcTryExcept{

        Status = SamrValidatePassword(
                     BindingHandle,
                     ValidationType,
                     InputArg,
                     OutputArg
                     );

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        Status = I_RpcMapWin32Status(RpcExceptionCode());

    } RpcEndExcept;

    if( !NT_SUCCESS( Status ) ) {
        
        goto Error;
    }

Exit:
    
    //1 Release held resources

    if( BindingHandle ) {
        
        RpcBindingFree( &BindingHandle );
    }

    if( StringBinding ) {
        
        RpcStringFreeW( &StringBinding );
    }

    MIDL_user_free( Spn );

    if( ServiceName != ServerName2 ) {

        MIDL_user_free( ServiceName );
    }

    MIDL_user_free( ServerName2 );
    
    return Status;
    
Error:
    
    ASSERT( !NT_SUCCESS( Status ) );
    
    if( ARGUMENT_PRESENT( OutputArg ) ) {

        *OutputArg = NULL;
    }
    
    goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\lib\recovery.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    RECOVERY.C

Abstract:

    This file provides the implement which using SysKey to decrypt password.
    It is used by recovery tool during system recovery, so that the local
    machine's administrator gets authenticated before we grant system access
    for recovery.

    The argorithm used here is stated as follows:

    1. Looks into SAM Account Domain's Fixed Length Attribute.
       Checks the boot option type, determines how the local machine is syskey'd.
       If the machine is syskey'd, then retrieve the Encrypted Password
       Encryption Key.

    2. Looks up the User Account by Rid passed in. If we finds the User
       Account whose Rid equal to the Rid passed in. Retrieves it's
       Encrypted NT OWF Password

    3. Depending on how the machine is syekey'd. Tring to get the SysKey.

       3.1 SysKey is not enabled on this machine. Ok. nothing special to do.

       3.2 Syskey is stored in Registry, go ahead retrieve it.

       3.3 Syskey is derived from Boot Password or stored in floppy disk,
           then check the optional Parameter, if caller passed it to us,
           use it. Otherwise, if caller passed NULL, return error, let
           caller handle this through appropriate promots.


    4. At this point, we should have all information we might need.

       4.1 Machine is syskey enabled.

           Use SysKey to decrypt Encrypted Password Encryption Key, then
           use the Clear Password Encryption Key to decrypt NT Owf Password,
           Return the Clear NT OWF password.

       4.2 Machine is not syskey enabled.

           Return the NT OWF Password with minial modification.

    5. End

Author:

    09-Jan-99 ShaoYin

Environment:

    Kernel Mode - Win32

Revision History:

    08-Jan-99 ShaoYin Created Initial File.

--*/


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//    Include header files                                              //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


//
// NT header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>


//
// Windows header files
//

#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>

//
// header files related to recovery authenticate
//
#include <samsrvp.h>
#include <enckey.h>
#include <rc4.h>
#include <md5.h>
#include <wxlpc.h>
#include "recovery.h"
#include "recmem.h"



#define SAMP_SERVER_KEY_NAME            L"SAM"
#define SAMP_ACCOUNT_DOMAIN_KEY_NAME    L"SAM\\Domains\\Account"
#define SAMP_USERS_KEY_NAME             L"SAM\\Domains\\Account\\Users\\"
#define SAMP_USERSNAME_KEY_NAME         L"SAM\\Domains\\Account\\Users\\Names\\"
#define SECURITY_POLICY_POLSECRETENCRYPTIONKEY  L"Policy\\PolSecretEncryptionKey"



#define DwordAlignUlong( v ) (((v)+3) & 0xfffffffc)
//
// Helper macro to make object attribute initialization a little cleaner.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )



//
// Domain Information Class
// 

typedef enum _REC_DOMAIN_INFO_CLASS {
    RecDomainBootAndSessionKeyInfo = 1,
    RecDomainRidInfo
} REC_DOMAIN_INFO_CLASS;


//
// the following typedef should be in sync with 
// nt\private\security\lsa\server\dspolicy\dbp.h
// in stead of include <dbp.h>, just put what we need here.
//


typedef struct _LSAP_DB_ENCRYPTION_KEY {
    ULONG   Revision;
    ULONG   BootType;
    ULONG   Flags;
    GUID    Authenticator;
    UCHAR   Key [16];//128 bit key
    UCHAR   OldSyskey[16]; // for recovery
    UCHAR   Salt[16];//128 bit Salt
} LSAP_DB_ENCRYPTION_KEY, *PLSAP_DB_ENCRYPTION_KEY;


static GUID LsapDbPasswordAuthenticator = {0xf0ce3a80,0x155f,0x11d3,0xb7,0xe6,0x00,0x80,0x5f,0x48,0xca,0xeb};







//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Forward declaration                                                  //
//                                                                      //
//////////////////////////////////////////////////////////////////////////



NTSTATUS
WxReadSysKeyForRecovery(
    IN HANDLE hSystemRootKey,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key
    );

NTSTATUS
DuplicateUnicodeString(
    OUT PUNICODE_STRING OutString,
    IN  PUNICODE_STRING InString
    );

NTSTATUS
SampRetrieveRegistryAttribute(
    IN HANDLE   hKey,
    IN PVOID    Buffer,
    IN ULONG    BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG  RequiredLength
    );

NTSTATUS
SampGetEncryptionKeyDataFromSecurityHive(
    IN  HANDLE  hSecurityRootKey,
    OUT PLSAP_DB_ENCRYPTION_KEY EncryptionKeyData
    );

NTSTATUS
SampDecryptOldSyskeyWithNewSyskey(
    IN LSAP_DB_ENCRYPTION_KEY  * KeyToDecrypt,
    IN PVOID   Syskey,
    IN ULONG   SyskeyLength
    );

NTSTATUS
SampGetFixedDomainInfo(
    IN  HANDLE  hSamRootKey,
    IN  REC_DOMAIN_INFO_CLASS   RecDomainInfoClass,
    IN  ULONG   ServerRevision,
    OUT ULONG   *BootAuthType OPTIONAL,
    OUT ULONG   *CurrentKeyId,
    OUT ULONG   *PreviousKeyId,
    OUT KEEncKey *EncryptedSessionKey,
    OUT KEEncKey *EncryptedSessionKeyPrevious,
    OUT BOOLEAN *PreviousSessionKeyExists,
    OUT ULONG   *NextRid
    );

NTSTATUS
SampRetrieveSysKeyFromRegistry(
    IN HANDLE  hSystemRootKey,
    IN ULONG   BootAuthType,
    OUT KEClearKey *SysKey
    );


NTSTATUS
SampRetrieveVariableAttr(
    IN PUCHAR Buffer,
    IN ULONG AttributeIndex,
    OUT PUNICODE_STRING StoredBuffer
    );

NTSTATUS
SampGetPwdByRid(
    IN ULONG Rid,
    IN HANDLE hSamRootKey,
    OUT PUNICODE_STRING StoredBuffer
    );

NTSTATUS
SampGetRidAndPwdByAccountName(
    IN PWCHAR AccountName,
    IN HANDLE hSamRootKey,
    OUT ULONG *Rid,
    OUT PUNICODE_STRING EncryptedOwfPwd
    );

NTSTATUS
SampDecryptOwfPwd(
    IN ULONG Rid,
    IN ULONG BootAuthType,
    IN BOOLEAN PreviousSessionKeyExists,
    IN ULONG CurrentKeyId,
    IN ULONG PreviousKeyId,
    IN KEClearKey *ClearSessionKey,
    IN KEClearKey *ClearSessionKeyPrevious,
    IN UNICODE_STRING *EncryptedNtOwfPwd,
    OUT UNICODE_STRING *ClearNtOwfPwd
    );

NTSTATUS
SampDecryptSessionKey(
    IN BOOLEAN      OldSyskeyAvailable,
    IN PLSAP_DB_ENCRYPTION_KEY StoredEncryptionKeyData,
    IN KEClearKey   *DecryptionKey,
    IN KEEncKey     *EncryptedSessionKey,
    OUT KEClearKey  *ClearSessionKey
    );

NTSTATUS
SampGetServerRevision(
    IN HANDLE   hSamRootKey, 
    OUT ULONG   *ServerRevision
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Exported API                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

                
NTSTATUS
SampGetServerRevision(
    IN HANDLE   hSamRootKey, 
    OUT ULONG   *ServerRevision
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HANDLE      hServerKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    ServerKeyName;
    UNICODE_STRING    CombinedAttributeName;
    PUCHAR            Buffer = NULL;
    ULONG             BufferLength = 0;
    ULONG             RequiredLength = 0;
    PSAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttr = NULL;

    //
    // Create the object we will be opening in the registry
    //
    INIT_OBJA(&Attributes, &ServerKeyName, SAMP_SERVER_KEY_NAME);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hServerKey,
                    KEY_READ,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // Retrieve Fixed attribute
    //
    RtlInitUnicodeString(&CombinedAttributeName, L"C");

    NtStatus = SampRetrieveRegistryAttribute(
                        hServerKey,
                        Buffer,
                        BufferLength,
                        &CombinedAttributeName,
                        &RequiredLength
                        );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus ||
        STATUS_BUFFER_OVERFLOW == NtStatus)
    {
        BufferLength = DwordAlignUlong(RequiredLength);
        Buffer = RecSamAlloc( BufferLength );

        if (NULL == Buffer)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        RtlZeroMemory(Buffer, BufferLength);

        NtStatus = SampRetrieveRegistryAttribute(
                            hServerKey,
                            Buffer,
                            BufferLength,
                            &CombinedAttributeName,
                            &RequiredLength
                            );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ServerFixedAttr = (PSAMP_V1_FIXED_LENGTH_SERVER) (Buffer +
                       FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

    *ServerRevision = ServerFixedAttr->RevisionLevel;
                       

Error:

    //
    // close the handle
    //

    if (INVALID_HANDLE_VALUE != hServerKey)
    {
        ZwClose(hServerKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
        Buffer = NULL;
    }


    return( NtStatus );
}

//
// Only retrieve NT OWF Password only,
// if required, we can add support to retrieve LM OWF PWD.
//

NTSTATUS
SampDecryptSessionKey(
    IN BOOLEAN      OldSyskeyAvailable,
    IN PLSAP_DB_ENCRYPTION_KEY StoredEncryptionKeyData,
    IN KEClearKey   *DecryptionKey,
    IN KEEncKey     *EncryptedSessionKey,
    OUT KEClearKey  *ClearSessionKey
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       DecryptStatus = 0;
    KEEncKey    TempEncryptedSessionKey;
    KEClearKey  OldDecryptionKey;

    //
    // init local variables
    //  
    RtlZeroMemory(&TempEncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&OldDecryptionKey, sizeof(KEClearKey));

    //
    // Save the EncryptedSessionKey, KEDecryptKey() will destroy EncryptedSessionKey
    // before return.
    // 
    TempEncryptedSessionKey = (*EncryptedSessionKey);

    //
    // use syskey (DecryptionKey) to decrypt session key
    // 
    DecryptStatus = KEDecryptKey(
                        DecryptionKey,            // KEClearKey - syskey
                        EncryptedSessionKey,      // KEEncKey - encrypted password encryption key
                        ClearSessionKey,          // KEClearKey - clear password encryption key
                        0);

    if ((KE_BAD_PASSWORD == DecryptStatus) &&
        OldSyskeyAvailable)
    {
        // 
        // Decrypt Old Syskey
        // 

        NtStatus = SampDecryptOldSyskeyWithNewSyskey(
                        StoredEncryptionKeyData,
                        DecryptionKey->ClearKey,
                        KE_KEY_SIZE
                        );

        if (STATUS_SUCCESS != NtStatus)
        {
            goto Error;
        }

        OldDecryptionKey.dwVersion = KE_CUR_VERSION;
        OldDecryptionKey.dwLength = sizeof(KEClearKey);
        RtlCopyMemory(OldDecryptionKey.ClearKey,
                      StoredEncryptionKeyData->OldSyskey,
                      KE_KEY_SIZE
                      );

        //
        // Try using the Old Syskey to get the session key
        // 

        DecryptStatus = KEDecryptKey(
                            &OldDecryptionKey,
                            &TempEncryptedSessionKey,
                            ClearSessionKey,
                            0);
    }

    if (KE_OK != DecryptStatus)
    {
        NtStatus = STATUS_INTERNAL_ERROR;
    }

Error:
    //
    // Cleanup and return
    // 
    RtlZeroMemory(&TempEncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&OldDecryptionKey, sizeof(KEClearKey));

    return( NtStatus );
}


NTSTATUS
SamRetrieveOwfPasswordUser(
    IN ULONG    Rid,
    IN HANDLE   hSecurityRootKey,
    IN HANDLE   hSamRootKey,
    IN HANDLE   hSystemRootKey,
    IN PUNICODE_STRING BootKey OPTIONAL,
    IN USHORT   BootKeyType OPTIONAL,
    OUT PNT_OWF_PASSWORD NtOwfPassword,
    OUT PBOOLEAN NtPasswordPresent,
    OUT PBOOLEAN NtPasswordNonNull
    )
/*++
Routine Description:

    This routine will return the desired User's NT OWF(One Way Function)
    password to caller. If the local machine is syskey'ed, this routine
    will do the decryption work as well. Depending on how this machine is
    syskey'd, it might require the caller to provide the BootKey information.
    If caller does not pass in the BootKey, this routine will fail gracefully
    and return proper status code to indicate what we require.

Parameters:

    Rid - Logon user's Relative ID

    hSecurityRootKey - Handle of the Root of SECURITY hive

    hSamRootKey - Handle of the Root of the SAM hive

    hSystemRootKey - Handle of the Root of the System Hive

                     caller should Load the SAM hive and System hive,
                     and Unload them after this API returns

    BootKey - Optional, caller should provide this parameter if the local
              machine's syskey is stored as Boot Password or stored in
              separate floppy disk

    BootKeyType - Optional, accociated with BootKey. If BootKey is NULL,
                  BootKeyType is never been used. Otherwise, indicate
                  what kind of info BootKey contains.
                  Valid Value:
                        SamBootKeyPassword - BootKey contains the boot password
                                             in UNICODE_STRING format
                        SamBootKeyDisk - BootKey contains the syskey read from
                                         Disk. We are going to use the syskey
                                         without any modification.

    NtOwfPassword - Used to return the NT OWF Password if we found one.

    NtPasswordPresent - return to caller to indicate the NT OWF password
                        is presented or not.

    NtPasswordNonNull - indicate the password in Null or not.

Return Values:

    NTSTATUS code
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    BootAuthType = 0;
    KEEncKey EncryptedSessionKey;
    KEEncKey EncryptedSessionKeyPrevious;
    KEClearKey DecryptionKey;
    KEClearKey ClearSessionKey;
    KEClearKey ClearSessionKeyPrevious;
    UNICODE_STRING EncryptedNtOwfPwd;
    UNICODE_STRING ClearNtOwfPwd;
    UNICODE_STRING  NullPassword;
    NT_OWF_PASSWORD NullNtOwfPassword;
    ULONG       CryptIndex = Rid;
    ULONG       CurrentKeyId = 1;
    ULONG       PreviousKeyId = 0;
    ULONG       ServerRevision = 0;
    LSAP_DB_ENCRYPTION_KEY StoredEncryptionKeyData;
    BOOLEAN     OldSyskeyAvailable = FALSE;
    BOOLEAN     PreviousSessionKeyExists = FALSE;

    //
    // Check parameters
    //
    if (INVALID_HANDLE_VALUE == hSamRootKey ||
        INVALID_HANDLE_VALUE == hSystemRootKey ||
        INVALID_HANDLE_VALUE == hSecurityRootKey ||
        NULL == NtOwfPassword ||
        NULL == NtPasswordPresent ||
        NULL == NtPasswordNonNull )
    {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize local variable
    //
    RtlInitUnicodeString(&NullPassword, NULL);

    NtStatus = RtlCalculateNtOwfPassword(
                        &NullPassword,
                        &NullNtOwfPassword
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    RtlZeroMemory(&EncryptedNtOwfPwd, sizeof(UNICODE_STRING));
    RtlZeroMemory(&ClearNtOwfPwd, sizeof(UNICODE_STRING));
    RtlZeroMemory(&EncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&EncryptedSessionKeyPrevious, sizeof(KEEncKey));
    RtlZeroMemory(&DecryptionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKeyPrevious, sizeof(KEClearKey));
    RtlZeroMemory(&StoredEncryptionKeyData, sizeof(StoredEncryptionKeyData));


    //
    // Get SAM Server Object Revision first
    // 
    NtStatus = SampGetServerRevision(hSamRootKey,
                                     &ServerRevision
                                     );
                
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Get Boot Key Type from security hive
    //
    
    NtStatus = SampGetEncryptionKeyDataFromSecurityHive(
                        hSecurityRootKey,
                        &StoredEncryptionKeyData
                        );

    if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus)
    {
        //
        // Before build 2078, we store the boot option in SAM hive.
        // for the old build < 2078, switch to SAM hive to get the 
        // boot key type
        // 
        NtStatus = SampGetFixedDomainInfo(
                        hSamRootKey,                    // SamHiveRootKey
                        RecDomainBootAndSessionKeyInfo, // InfoClass
                        ServerRevision,                 // Server Revision
                        &BootAuthType,                  // BootAuthType
                        &CurrentKeyId,                  // CurrentKeyId
                        &PreviousKeyId,                 // PreviousKeyId
                        &EncryptedSessionKey,           // EncryptedSessionkey
                        &EncryptedSessionKeyPrevious,   // EncryptedSessionKeyPrevious
                        &PreviousSessionKeyExists,      // PreviousSessionKeyExists
                        NULL                            // NextRid
                        );

    }
    else if (STATUS_SUCCESS == NtStatus)
    {
        OldSyskeyAvailable = TRUE;
        BootAuthType = StoredEncryptionKeyData.BootType;
        //
        // Get Encrypted Session Key (ONLY) 
        // from Account Domain (in registry)
        //
        NtStatus = SampGetFixedDomainInfo(
                        hSamRootKey,                    // SamHiveRootKey
                        RecDomainBootAndSessionKeyInfo, // InfoClass
                        ServerRevision,                 // Server Revision
                        NULL,                           // BootAuthType
                        &CurrentKeyId,                  // CurrentKeyId
                        &PreviousKeyId,                 // PreviousKeyId
                        &EncryptedSessionKey,           // EncryptedSessionkey
                        &EncryptedSessionKeyPrevious,   // EncryptedSessionKeyPrevious
                        &PreviousSessionKeyExists,      // PreviousSessionKeyExists
                        NULL                            // NextRid
                        );

    }


    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }


    //
    // Get the SysKey (Boot Key)
    //
    switch (BootAuthType)
    {
    case WxStored:

        // retrieve the Key from registry

        NtStatus = SampRetrieveSysKeyFromRegistry(
                                hSystemRootKey,
                                BootAuthType,
                                &DecryptionKey
                                );
        break;

    case WxPrompt:

        //
        // Caller should provide this information
        //

        if (NULL == BootKey)
        {
            //
            // set return error code, so that the caller
            // will know we need logon user to enter
            // the boot key (syskey).
            //
            NtStatus = STATUS_SAM_NEED_BOOTKEY_PASSWORD;
        }
        else
        {
            MD5_CTX Md5;

            if (SamBootKeyPassword != BootKeyType)
            {
                NtStatus = STATUS_INVALID_PARAMETER;
                goto Error;
            }

            //
            // derive the syskey from the boot password
            //

            MD5Init( &Md5 );
            MD5Update( &Md5, (PUCHAR) BootKey->Buffer, BootKey->Length );
            MD5Final( &Md5 );

            DecryptionKey.dwVersion = KE_CUR_VERSION;
            DecryptionKey.dwLength = sizeof(KEClearKey);
            RtlCopyMemory(DecryptionKey.ClearKey,
                          Md5.digest,
                          KE_KEY_SIZE
                          );
        }
        break;

    case WxDisk:

        //
        // Caller should provide this information
        //

        if (NULL == BootKey || NULL == BootKey->Buffer)
        {
            //
            // set error return code, so that the caller
            // can who what we need, then read the floppy
            // disk to get the boot key.
            //
            NtStatus = STATUS_SAM_NEED_BOOTKEY_FLOPPY;
        }
        else if (BootKey->Length > KE_KEY_SIZE ||
                 (SamBootKeyDisk != BootKeyType))
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        else
        {
            //
            // this is the syskey, use it.
            //

            DecryptionKey.dwVersion = KE_CUR_VERSION;
            DecryptionKey.dwLength = sizeof(KEClearKey);
            RtlCopyMemory(DecryptionKey.ClearKey,
                          BootKey->Buffer,
                          BootKey->Length
                          );
        }
        break;

    case WxNone:

        //
        // Machine is not syskey enabled
        // nothing to do
        //

        break;

    default:

        NtStatus = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Get the User's Encrypted Password
    //

    NtStatus = SampGetPwdByRid(Rid,
                               hSamRootKey,
                               &EncryptedNtOwfPwd
                               );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // we have the encrypted session key and the Boot Key (SysKey),
    // Now, try to get the clear session key, which is the
    // password encryption key.
    //
    if (SamBootKeyNone != BootAuthType )
    {

        NtStatus = SampDecryptSessionKey(OldSyskeyAvailable,
                                         &StoredEncryptionKeyData,
                                         &DecryptionKey,
                                         &EncryptedSessionKey,
                                         &ClearSessionKey
                                         );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        if (PreviousSessionKeyExists)
        {
            NtStatus = SampDecryptSessionKey(OldSyskeyAvailable,
                                             &StoredEncryptionKeyData,
                                             &DecryptionKey,
                                             &EncryptedSessionKeyPrevious,
                                             &ClearSessionKeyPrevious
                                             );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }
    }

    //
    // Decrypt the encrypted password using the clear password encryption key
    //
    NtStatus = SampDecryptOwfPwd(Rid,
                                 BootAuthType,
                                 PreviousSessionKeyExists,
                                 CurrentKeyId,
                                 PreviousKeyId,
                                 &ClearSessionKey,  // clear Password encryption key
                                 &ClearSessionKeyPrevious,   // clear pwd encryption key previous
                                 &EncryptedNtOwfPwd,// encrypted NT OWF PWD
                                 &ClearNtOwfPwd     // return clear NT Owf Pwd
                                 );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    *NtPasswordPresent = (BOOLEAN) (ClearNtOwfPwd.Length != 0);

    if (*NtPasswordPresent)
    {
        NtStatus = RtlDecryptNtOwfPwdWithIndex(
                        (PENCRYPTED_NT_OWF_PASSWORD)ClearNtOwfPwd.Buffer,
                        &CryptIndex,
                        NtOwfPassword
                        );

        if (NT_SUCCESS(NtStatus))
        {
            *NtPasswordNonNull = (BOOLEAN)!RtlEqualNtOwfPassword(
                                    NtOwfPassword,
                                    &NullNtOwfPassword
                                    );
        }
    } else {

        //
        // Fill in the NULL password for caller convenience
        //

        RtlCopyMemory(NtOwfPassword,
                      &NullNtOwfPassword,
                      sizeof(NT_OWF_PASSWORD)
                      );

        *NtPasswordNonNull = FALSE;
    }

Error:

    RtlZeroMemory(&EncryptedSessionKey, sizeof(KEEncKey));
    RtlZeroMemory(&EncryptedSessionKeyPrevious, sizeof(KEEncKey));
    RtlZeroMemory(&DecryptionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKey, sizeof(KEClearKey));
    RtlZeroMemory(&ClearSessionKeyPrevious, sizeof(KEClearKey));
    RtlZeroMemory(&StoredEncryptionKeyData, sizeof(LSAP_DB_ENCRYPTION_KEY));

    if (NULL != EncryptedNtOwfPwd.Buffer)
    {
        RtlZeroMemory(EncryptedNtOwfPwd.Buffer, EncryptedNtOwfPwd.Length);
        RecSamFree(EncryptedNtOwfPwd.Buffer);
        RtlZeroMemory(&EncryptedNtOwfPwd, sizeof(UNICODE_STRING));
    }

    if (NULL != ClearNtOwfPwd.Buffer)
    {
        RtlZeroMemory(ClearNtOwfPwd.Buffer, ClearNtOwfPwd.Length);
        RecSamFree(ClearNtOwfPwd.Buffer);
        RtlZeroMemory(&ClearNtOwfPwd, sizeof(UNICODE_STRING));
    }

    return (NtStatus);
}





//////////////////////////////////////////////////////////////////////////
//                                                                      //
//     Private API                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

NTSTATUS
SampGetEncryptionKeyDataFromSecurityHive(
    IN  HANDLE  hSecurityRootKey,
    OUT PLSAP_DB_ENCRYPTION_KEY EncryptionKeyData
    )
/*++
Routine Description:

    This routine get the Boot Option from SECURITY hive

Parameters:

    hSeurityRootKey - Handle of the root of SECURITY hive
    
    BootAuthType - return Boot Type if success
    
Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    HANDLE      hPolSecretEncryptionKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES   Attributes;
    UNICODE_STRING      PolSecretEncryptionKeyName;
    UNICODE_STRING      NullName;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyPartialInformation = NULL;
    ULONG       KeyPartialInformationSize = 0;

    INIT_OBJA(&Attributes, &PolSecretEncryptionKeyName, SECURITY_POLICY_POLSECRETENCRYPTIONKEY);
    Attributes.RootDirectory = hSecurityRootKey;

    //
    // try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hPolSecretEncryptionKey,
                    KEY_READ,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    NullName.Length = 0;
    NullName.MaximumLength = 0;
    NullName.Buffer = NULL;

    NtStatus = ZwQueryValueKey(
                    hPolSecretEncryptionKey,
                    &NullName,
                    KeyValuePartialInformation,
                    KeyPartialInformation,
                    KeyPartialInformationSize,
                    &KeyPartialInformationSize
                    );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        KeyPartialInformation = RecSamAlloc(KeyPartialInformationSize);

        if (KeyPartialInformation)
        {
            NtStatus = ZwQueryValueKey(
                            hPolSecretEncryptionKey,
                            &NullName,
                            KeyValuePartialInformation,
                            KeyPartialInformation,
                            KeyPartialInformationSize,
                            &KeyPartialInformationSize
                            );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    RtlCopyMemory(EncryptionKeyData,
                  (LSAP_DB_ENCRYPTION_KEY *)KeyPartialInformation->Data,
                  sizeof(LSAP_DB_ENCRYPTION_KEY)
                  );

Error:

    if (KeyPartialInformation)
    {
        RecSamFree(KeyPartialInformation);
        KeyPartialInformation = NULL;
    }

    if (INVALID_HANDLE_VALUE != hPolSecretEncryptionKey)
    {
        NtStatus = ZwClose(hPolSecretEncryptionKey);
    }

    return( NtStatus );
}





NTSTATUS
SampDecryptOldSyskeyWithNewSyskey(
    IN LSAP_DB_ENCRYPTION_KEY  * KeyToDecrypt,
    IN PVOID   Syskey,
    IN ULONG   SyskeyLength
    )
/*++
Routine Description:

    The propose of this routine is using the New Syskey to decrypt the (encrypted)
    Old Syskey, so that we get the clear Old Syskey
    
Parameters:

    KeyToDecrypt - LSA Encryption Key Data, which contains the (encrypted) old syskey
    
    Syskey - New Syskey (clear)
    
    SyskeyLength - Length
    
Return Values:
    
    STATUS_SUCCESS - decrypted with no error
    
    STATUS_UNSUCCESSFUL - for some reason. failed. 

--*/
{
    MD5_CTX Md5Context;
    struct RC4_KEYSTRUCT Rc4Key;
    ULONG  i;
    
    //
    // Create an MD5 hash of the key and salt
    //

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        Syskey,
        SyskeyLength
        );
    //
    // Hash in the salt many many times. This slows down 
    // attackers employing a brute force approach to attack
    //

    for (i=0;i<1000;i++)
    {
        MD5Update(
            &Md5Context,
            KeyToDecrypt->Salt,
            sizeof(KeyToDecrypt->Salt)
            );
    }
   
    MD5Final(
        &Md5Context
        );

    //
    // Initialize the RC4 key sequence.
    //

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

   

    rc4(
        &Rc4Key,
        sizeof(KeyToDecrypt->Key)+ sizeof(KeyToDecrypt->Authenticator)+sizeof(KeyToDecrypt->OldSyskey),
        (PUCHAR) &KeyToDecrypt->Authenticator
        
        );


    if (!RtlEqualMemory(&KeyToDecrypt->Authenticator,&LsapDbPasswordAuthenticator,sizeof(GUID))) 
    {
        return( STATUS_UNSUCCESSFUL );
    }

    return( STATUS_SUCCESS );

}


NTSTATUS
SampGetFixedDomainInfo(
    IN  HANDLE  hSamRootKey,
    IN  REC_DOMAIN_INFO_CLASS   RecDomainInfoClass,
    IN  ULONG   ServerRevision,
    OUT ULONG   *BootAuthType OPTIONAL,
    OUT ULONG   *CurrentKeyId,
    OUT ULONG   *PreviousKeyId,
    OUT KEEncKey *EncryptedSessionKey,
    OUT KEEncKey *EncryptedSessionKeyPrevious,
    OUT BOOLEAN *PreviousSessionKeyExists,
    OUT ULONG   *NextRid
    )
/*++
Routine Description:

    This routine queries the Account Domain's Fixed Length Attribute stored
    in registry. Find out the Boot Type, whether the local machine is syskey'ed
    or not. And fill the EncryptedSessionKey properly.

Parameters:

    hSamRootKey - Handle of the Root of the hive

    RecDomainInfoClass - specify desired domain information

    BootAuthType - return How the machine is syskey. 
                   Since build 2078, we no longer store BootAuthType in SAM hive,
                   instead, we put the boot option in Security Hive.
                   So if this argument is not present, it means caller has already
                   got it from security hive.

    EncryptedSessionKey - once returned, contains the Encrypted Password
                          Encryption Key

    NextRid - Return the value of next available Rid                          

Return Values:

--*/
{
    NTSTATUS          NtStatus = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    HANDLE            hDomainKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    DomainKeyName;
    UNICODE_STRING    FixedAttributeName;
    PUCHAR            Buffer = NULL;
    ULONG             BufferLength = 0;
    ULONG             RequiredLength = 0;

    //
    // Create the object we will be opening in the registry
    //
    INIT_OBJA(&Attributes, &DomainKeyName, SAMP_ACCOUNT_DOMAIN_KEY_NAME);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hDomainKey,
                    KEY_READ,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set value to retrieve account domain fixed attribute
    // allocate enough buffer size
    //
    BufferLength = DwordAlignUlong(sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)) +
                   DwordAlignUlong(FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));


    Buffer = RecSamAlloc(BufferLength);

    if (NULL == Buffer)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory(Buffer, BufferLength);

    //
    // Retrieve Fixed attribute
    //
    RtlInitUnicodeString(&FixedAttributeName, L"F");

    NtStatus = SampRetrieveRegistryAttribute(
                        hDomainKey,
                        Buffer,
                        BufferLength,
                        &FixedAttributeName,
                        &RequiredLength
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // retrieve encrypted session key depends on SAM revision
    //

    if (ServerRevision <= SAMP_WIN2K_REVISION)
    {
        PSAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN V1aFixed = NULL;

        V1aFixed = (PSAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN)(Buffer +
                    FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

        switch (RecDomainInfoClass)
        {
        case RecDomainBootAndSessionKeyInfo:

            //
            // get the boot key type
            //
            if (NULL != BootAuthType)
            {
                *BootAuthType = (ULONG) V1aFixed->DomainKeyAuthType;
            }

            //
            // if applicable, get the encrypted session key
            //
            if (V1aFixed->DomainKeyFlags & SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED)
            {
                RtlCopyMemory(EncryptedSessionKey,
                              V1aFixed->DomainKeyInformation,
                              sizeof(KEEncKey)
                              );
            }

            *CurrentKeyId = SAMP_DEFAULT_SESSION_KEY_ID;
            *PreviousKeyId = 0;
            *PreviousSessionKeyExists = FALSE;

            break;

        case RecDomainRidInfo:

            //
            // get next available rid
            //

            if (NULL != NextRid)
            {
                *NextRid = (ULONG) V1aFixed->NextRid;
            }
            else
            {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
    }
    else if (ServerRevision == SAMP_WHISTLER_OR_W2K_SYSPREP_FIX_REVISION)
    {
        PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;

        V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                    FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

        switch (RecDomainInfoClass)
        {
        case RecDomainBootAndSessionKeyInfo:

            //
            // get the boot key type
            //
            if (NULL != BootAuthType)
            {
                *BootAuthType = (ULONG) V1aFixed->DomainKeyAuthType;
            }

            //
            // if applicable, get the encrypted session key
            //
            if (V1aFixed->DomainKeyFlags & SAMP_DOMAIN_SECRET_ENCRYPTION_ENABLED)
            {
                RtlCopyMemory(EncryptedSessionKey,
                              V1aFixed->DomainKeyInformation,
                              sizeof(KEEncKey)
                              );
            }

            *CurrentKeyId = V1aFixed->CurrentKeyId;
            *PreviousKeyId = V1aFixed->PreviousKeyId;
            if (V1aFixed->PreviousKeyId != 0)
            {
                *PreviousSessionKeyExists = TRUE;

                RtlCopyMemory(EncryptedSessionKeyPrevious,
                              V1aFixed->DomainKeyInformationPrevious,
                              sizeof(KEEncKey)
                              );
            }

            break;

        case RecDomainRidInfo:

            //
            // get next available rid
            //

            if (NULL != NextRid)
            {
                *NextRid = (ULONG) V1aFixed->NextRid;
            }
            else
            {
                NtStatus = STATUS_INVALID_PARAMETER;
            }
            break;

        default:
            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

    }
    else
    {
        NtStatus = STATUS_INTERNAL_ERROR;
    }


Error:

    //
    // close the handle
    //

    if (INVALID_HANDLE_VALUE != hDomainKey)
    {
        IgnoreStatus = ZwClose(hDomainKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
        Buffer = NULL;
    }

    return NtStatus;
}




NTSTATUS
SampRetrieveSysKeyFromRegistry(
    IN HANDLE  hSystemRootKey,
    IN ULONG   BootAuthType,
    OUT KEClearKey *SysKey
    )
/*++
Routine Description:

    Retrieve the SysKey buried in Registry.
    Caller should only call us when BootAuthType is WxStored

Parameters:

    hSystemRootKey - handle of the root of the System Hive

    BootAuthType - Indicate How the machine is syskey'ed

        Valid Values:
            WxStored - SysKey stored in registry

        Invalid Value: (Should not call this function)
            WxPrompt - SysKey stored as boot password
            WxDisk - SysKey stored in floppy disk
            WxNone - SysKey is not enabled.

    SysKey - Once success, contains the syskey

Return Values:

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
    STATUS_INVALID_PARAMETER
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    WXHASH OldHash;
    ULONG KeyLen = 0;


    if (WxStored != BootAuthType)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // retrieve the Key from registry
    //

    KeyLen = sizeof(OldHash.Digest);

    NtStatus = WxReadSysKeyForRecovery(hSystemRootKey,
                                       &KeyLen,
                                       &(OldHash.Digest)
                                       );

    if (!NT_SUCCESS(NtStatus))
    {
        return (NtStatus);
    }

    SysKey->dwVersion = KE_CUR_VERSION;
    SysKey->dwLength = sizeof(KEClearKey);
    RtlCopyMemory(SysKey->ClearKey,
                  OldHash.Digest,
                  KE_KEY_SIZE
                  );

    return (STATUS_SUCCESS);

}


NTSTATUS
SampRetrieveVariableAttr(
    IN PUCHAR Buffer,
    IN ULONG AttributeIndex,
    OUT PUNICODE_STRING StoredBuffer
    )
/*++
Routine Description:

    This routine retrieves one variable lengthed attribute from the
    attributes array.

Parameters:

    Buffer - Buffer contains the variable lengthed attributes and all
             related information

    AttributeIndex - Index of the desired attribute in the attributes array

    StoredBuffer - Used to returned the value of attribute

Return Values:

    STATUS_NO_MEMORY
    STATUS_SUCCESS
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AttributeArray = NULL;
    PUCHAR  AttributeAddress = NULL;
    ULONG   VariableArrayOffset = 0;
    ULONG   VariableDataOffset = 0;
    ULONG   AttributeLength = 0;


    VariableArrayOffset = DwordAlignUlong(FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

    VariableDataOffset = DwordAlignUlong(VariableArrayOffset +
                                         (SAMP_USER_VARIABLE_ATTRIBUTES *
                                          sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                                         );

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE) (Buffer + VariableArrayOffset);

    AttributeAddress = (PUCHAR) (Buffer + VariableDataOffset +
                                 AttributeArray[AttributeIndex].Offset);

    AttributeLength = AttributeArray[AttributeIndex].Length;
    StoredBuffer->Length = (USHORT) AttributeLength;
    StoredBuffer->MaximumLength = (USHORT) AttributeLength;

    StoredBuffer->Buffer = RecSamAlloc(AttributeLength);

    if (NULL == StoredBuffer->Buffer)
    {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(StoredBuffer->Buffer, AttributeLength);

    RtlCopyMemory(StoredBuffer->Buffer, AttributeAddress, AttributeLength);

    return NtStatus;
}



NTSTATUS
SampGetPwdByRid(
    IN ULONG Rid,
    IN HANDLE hSamRootKey,
    OUT PUNICODE_STRING StoredBuffer
    )
/*++
Routine Description:

    This routine queries the fixed length attribute of the user account
    (specified by UserName). If the user account'd Relative ID matches the
    Rid passed in, then further retrieve this user's Encrypted NT OWF Pwd.

Parameters:

    Rid - Relative ID of the user account which we are interested in.

    hSamRootKey -- Root of the Hive

    StoredBuffer - hold this user's encrypted NT OWF Pwd.

Return Values:

    STATUS_NO_MEMORY;
    STATUS_SUCCESS;

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    HANDLE   hUserKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES UserAttributes;
    UNICODE_STRING  UserKeyName;
    UNICODE_STRING  VariableAttributeName;
    WCHAR    UserName[REGISTRY_KEY_NAME_LENGTH_MAX];

    PUCHAR  Buffer = NULL;
    ULONG   BufferLength = 0;
    PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed = NULL;
    ULONG   RequiredUserLength = 0;

    //
    // Construct the User Key Name
    //
    RtlZeroMemory(UserName, sizeof(UserName));


    swprintf(UserName, L"%s%8.8lx", SAMP_USERS_KEY_NAME, Rid);

    INIT_OBJA(&UserAttributes, &UserKeyName, UserName);
    UserAttributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(&hUserKey,
                         KEY_READ,
                         &UserAttributes
                         );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    RtlInitUnicodeString(&VariableAttributeName, L"V");

    NtStatus = SampRetrieveRegistryAttribute(
                            hUserKey,
                            NULL,
                            0,
                            &VariableAttributeName,
                            &RequiredUserLength
                            );

    if ((STATUS_BUFFER_OVERFLOW == NtStatus) ||
        (STATUS_BUFFER_TOO_SMALL == NtStatus))
    {
        BufferLength = RequiredUserLength;

        Buffer = RecSamAlloc(BufferLength);

        if (NULL == Buffer)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlZeroMemory(Buffer, BufferLength);
        NtStatus = SampRetrieveRegistryAttribute(
                            hUserKey,
                            Buffer,
                            BufferLength,
                            &VariableAttributeName,
                            &RequiredUserLength
                            );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    NtStatus = SampRetrieveVariableAttr(Buffer,
                                        SAMP_USER_UNICODE_PWD,
                                        StoredBuffer
                                        );

Error:

    if (INVALID_HANDLE_VALUE != hUserKey)
    {
        ZwClose(hUserKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
    }

    return NtStatus;
}




NTSTATUS
SampGetRidAndPwdByAccountName(
    IN PWCHAR AccountName,
    IN HANDLE hSamRootKey,
    OUT ULONG *Rid,
    OUT PUNICODE_STRING EncryptedOwfPwd
    )
/*++
Routine Description:

    This routine opens the Key in the Account Domain whose name is equal to
    the AccountName passed in. Gets its Rid from "type" of the key.
    Then calls SampGetPwdByRid()

Parameters:

    AccountName -- Logon Account Name

    hSamRootKey -- Handle of the root of the SAM hive

    Rid - return the Relative ID of the user account which we are interested in.

    EncryptedOwfPwd - once succeed, filled with that user's Nt Owf Pwd.

Return Values:

    STATUS_SUCCESS
    STATUS_NO_MEMORY;
    STATUS_NO_SUCH_USER
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE  hUserKey = INVALID_HANDLE_VALUE;
    WCHAR   UserName[REGISTRY_KEY_NAME_LENGTH_MAX];
    UNICODE_STRING  UserKeyName;
    UNICODE_STRING  UnicodeString;

    PKEY_VALUE_PARTIAL_INFORMATION  KeyPartialInformation = NULL;
    ULONG   KeyPartialInformationSize = 0;


    //
    // initialize variables
    //
    RtlZeroMemory(UserName, REGISTRY_KEY_NAME_LENGTH_MAX * sizeof(WCHAR));
    RtlZeroMemory(&UnicodeString, sizeof(UNICODE_STRING));

    //
    // construct the key name
    //
    wcscpy(UserName, SAMP_USERSNAME_KEY_NAME);
    wcscat(UserName, AccountName);

    INIT_OBJA(&Attributes, &UserKeyName, UserName);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(&hUserKey,
                         KEY_READ,
                         &Attributes
                         );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Get the RID of the user
    //
    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = NULL;

    NtStatus = ZwQueryValueKey(hUserKey,
                               &UnicodeString,
                               KeyValuePartialInformation,
                               KeyPartialInformation,
                               KeyPartialInformationSize,
                               &KeyPartialInformationSize
                               );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        KeyPartialInformation = RecSamAlloc(KeyPartialInformationSize);

        if (KeyPartialInformation)
        {
            NtStatus = ZwQueryValueKey(hUserKey,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyPartialInformation,
                                       KeyPartialInformationSize,
                                       &KeyPartialInformationSize
                                       );

        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    *Rid = KeyPartialInformation->Type;

    //
    // Get the encrypted owf password
    //
    NtStatus = SampGetPwdByRid(*Rid,
                               hSamRootKey,
                               EncryptedOwfPwd
                               );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

Error:

    if (KeyPartialInformation)
    {
        RecSamFree(KeyPartialInformation);
        KeyPartialInformation = NULL;
    }

    if (INVALID_HANDLE_VALUE != hUserKey)
    {
        ZwClose(hUserKey);
    }

    return (NtStatus);
}




NTSTATUS
SampDecryptOwfPwd(
    IN ULONG Rid,
    IN ULONG BootAuthType,
    IN BOOLEAN PreviousSessionKeyExists,
    IN ULONG CurrentKeyId,
    IN ULONG PreviousKeyId,
    IN KEClearKey *ClearSessionKey,
    IN KEClearKey *ClearSessionKeyPrevious,
    IN UNICODE_STRING *EncryptedNtOwfPwd,
    OUT UNICODE_STRING *ClearNtOwfPwd
    )
/*++
Routine Description:

    This routine decrypts the Encrypted NT OWF Password properly.

Parameter:

    Rid - Relative ID of the logon user

    BootAuthType - Indicate whether this password has been encrypted or not

    ClearSessionKey - Pointer to the password encryption key

    EncryptedNtOwfPwd - Encrypted NT OWF password

    ClearNtOwfPwd - returns the clear NT OWF password

Return Values:

    STATUS_SUCCESS
    STATUS_INTERNAL_ERROR
    STATUS_NO_MEMORY

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_SECRET_DATA SecretData;
    struct RC4_KEYSTRUCT Rc4Key;
    MD5_CTX Md5Context;
    UCHAR * KeyToUse = NULL;
    ULONG   KeyLength = 0;
    ULONG   Key = 0;

    //
    // If encryption is not enabled, do nothing special
    // copy the Nt Owf Pwd and return immediately
    //
    if (WxNone == BootAuthType || 
        (!SampIsDataEncrypted(EncryptedNtOwfPwd)) )
    {
        return (DuplicateUnicodeString(ClearNtOwfPwd,
                                       EncryptedNtOwfPwd
                                       ));
    }

    //
    // health check of the encrypted nt owf pwd
    //
    SecretData = (PSAMP_SECRET_DATA) EncryptedNtOwfPwd->Buffer;

    if ((SecretData->KeyId != CurrentKeyId) &&
        ((!PreviousSessionKeyExists) || (SecretData->KeyId != PreviousKeyId))
        )
    {
        return (STATUS_INTERNAL_ERROR);
    }

    //
    // Compute the size of the output buffer and allocate it
    //
    ClearNtOwfPwd->Length = SampClearDataSize(EncryptedNtOwfPwd->Length);
    ClearNtOwfPwd->MaximumLength = ClearNtOwfPwd->Length;

    //
    // If there was no data we can return now.
    //
    if (0 == ClearNtOwfPwd->Length)
    {
        ClearNtOwfPwd->Buffer = NULL;
        return (STATUS_SUCCESS);
    }

    ClearNtOwfPwd->Buffer = (LPWSTR) RecSamAlloc(ClearNtOwfPwd->Length);

    if (NULL == ClearNtOwfPwd->Buffer)
    {
        return (STATUS_NO_MEMORY);
    }

    //
    // Find the Key to use
    // 
    if (SecretData->KeyId == CurrentKeyId)
    {
        KeyToUse = (PUCHAR) ClearSessionKey->ClearKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    }
    else if (PreviousSessionKeyExists &&
             (SecretData->KeyId == PreviousKeyId))
    {
        KeyToUse = (PUCHAR) ClearSessionKeyPrevious->ClearKey;
        KeyLength = SAMP_SESSION_KEY_LENGTH;
    }
    else
    {
        return( STATUS_INTERNAL_ERROR );
    }

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        KeyToUse,
        KeyLength
        );

    MD5Update(
        &Md5Context,
        (PUCHAR) &Rid,
        sizeof(ULONG)
        );

    if (SecretData->Flags & SAMP_ENCRYPTION_FLAG_PER_TYPE_CONST)
    {
        MD5Update(
          &Md5Context,
          "NTPASSWORD",
          sizeof("NTPASSWORD")
          );
    }

    MD5Final(&Md5Context);

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );

    RtlCopyMemory(
        ClearNtOwfPwd->Buffer,
        SecretData->Data,
        ClearNtOwfPwd->Length
        );

    rc4(
        &Rc4Key,
        ClearNtOwfPwd->Length,
        (PUCHAR) ClearNtOwfPwd->Buffer
        );

    return (STATUS_SUCCESS);
}





NTSTATUS
SampRetrieveRegistryAttribute(
    IN HANDLE   hKey,
    IN PVOID    Buffer,
    IN ULONG    BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG  RequiredLength
    )
/*++
Routine Description:

    This Routine retrieves the value of either Fixed attribute or variable
    length attribute

Parameters:

    hKey - Registry Key, should be opened before calling this routine.

    Buffer - Pointer to a buffer to hold the value

    BufferLength - Indicate the length of the buffer

    AttirubteName - Name of the attribute

    RequiredLength - The actual length of attribute's value

Return Values:

    NtStatus - STATUS_SUCCESS
               STATUS_BUFFER_OVERFLOW or STATUS_BUFFER_TOO_SMALL

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    NtStatus = ZwQueryValueKey(hKey,
                               AttributeName,
                               KeyValuePartialInformation,
                               (PVOID) Buffer,
                               BufferLength,
                               RequiredLength
                               );

    return NtStatus;
}



NTSTATUS
SampSetRegistryAttribute(
    IN HANDLE   hKey,
    IN PUNICODE_STRING AttributeName,
    IN PVOID    Buffer,
    IN ULONG    BufferLength
    )
/*++
Routine Description:

    This Routine set the value of either Fixed attribute or variable
    length attribute to disk

Parameters:

    hKey - Registry Key, should be opened before calling this routine.

    AttirubteName - Name of the attribute

    Buffer - Pointer to a buffer to hold the value

    BufferLength - Indicate the length of the buffer

Return Values:

    NtStatus - STATUS_SUCCESS or error code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    NtStatus = ZwSetValueKey(hKey,              // KeyHandle
                             AttributeName,     // ValueName
                             0,                 // TitleIndex
                             REG_BINARY,        // Type
                             Buffer,            // Data
                             BufferLength       // DataSize
                             );

    return( NtStatus );
}




NTSTATUS
DuplicateUnicodeString(
    OUT PUNICODE_STRING OutString,
    IN  PUNICODE_STRING InString
    )
/*++
Routine Decription:

    Duplicate a unicode string

Parameter:

    OutString - Destination Unicode String
    InString - Source Unicode String

Return Value:

    NtStatus - STATUS_INVALID_PARAMETER, STATUS_NO_MEMORY
               STATUS_SUCCESS
--*/
{
    if (NULL == InString || NULL == OutString)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (InString->Length > 0)
    {
        OutString->Buffer = RecSamAlloc(InString->Length);

        if (NULL == OutString->Buffer)
        {
            return STATUS_NO_MEMORY;
        }
        OutString->MaximumLength = InString->Length;
        RtlCopyUnicodeString(OutString, InString);

    }
    else
    {
        RtlInitUnicodeString(OutString, NULL);
    }

    return(STATUS_SUCCESS);
}




NTSTATUS
SamGetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    OUT PULONG pNextRid
    )
/*++
Routine Description:

    This routine reads the SAM Account Domain infomation from SAM hive, passed
    in through hSamRootKey, and returns the value of next available RID of 
    this account domain.  

Parameters:

    hSamRootKey - Handle of the Root of SAM hive

            SAM hive is located in %windir%\system32\config, name is SAM

    pNextRid - Return the value of next available Rid if success. 

Return Values:

    STATUS_SUCCESS
    or other error status code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       ServerRevision = 0;

    if ((INVALID_HANDLE_VALUE != hSamRootKey) && (NULL != pNextRid))
    {

        //
        // Get SAM Server Object Revision first
        // 
        NtStatus = SampGetServerRevision(hSamRootKey,
                                         &ServerRevision
                                         );

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampGetFixedDomainInfo(
                                hSamRootKey,        // SamHiveRootKey
                                RecDomainRidInfo,   // InfoClass
                                ServerRevision,     // Server Revision
                                NULL,               // BootAuthType
                                NULL,               // CurrentKeyId
                                NULL,               // PreviousKeyId
                                NULL,               // EncryptedSessionKey
                                NULL,               // EncryptedSessionKeyPrevious
                                NULL,               // PreviousSessionKeyExists
                                pNextRid
                                );
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return( NtStatus );
}


NTSTATUS
SamSetNextAvailableRid(
    IN HANDLE  hSamRootKey,
    IN ULONG   NextRid
    )
/*++
Routine Description:

    This routine queries the Account Domain's Fixed Length Attribute stored
    in registry. Update it with the passed in NextRid value.

Parameters:

    hSamRootKey - Handle of the Root of the hive

    NextRid - Set the domain next available rid to the passed in value

Return Values:

--*/
{
    NTSTATUS          NtStatus = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    HANDLE            hDomainKey = INVALID_HANDLE_VALUE;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    DomainKeyName;
    UNICODE_STRING    FixedAttributeName;
    PUCHAR            Buffer = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    ULONG             BufferLength = 0;
    ULONG             RequiredLength = 0;

    //
    // Create the object we will be opening in the registry
    //
    INIT_OBJA(&Attributes, &DomainKeyName, SAMP_ACCOUNT_DOMAIN_KEY_NAME);
    Attributes.RootDirectory = hSamRootKey;

    //
    // Try to open for read control
    //
    NtStatus = ZwOpenKey(
                    &hDomainKey,
                    KEY_READ | KEY_WRITE,
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Set value to retrieve account domain fixed attribute
    //
    BufferLength = DwordAlignUlong(sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)) +
                   DwordAlignUlong(FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));


    Buffer = RecSamAlloc(BufferLength);

    if (NULL == Buffer)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlZeroMemory(Buffer, BufferLength);

    //
    // Retrieve Fixed attribute
    //
    RtlInitUnicodeString(&FixedAttributeName, L"F");

    NtStatus = SampRetrieveRegistryAttribute(
                        hDomainKey,
                        Buffer,
                        BufferLength,
                        &FixedAttributeName,
                        &RequiredLength
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Let the pointer point to the right place (actual data)
    //

    V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));


    //
    // Set next available rid to passed in value
    //

    (ULONG) V1aFixed->NextRid = NextRid;

    NtStatus = SampSetRegistryAttribute(
                        hDomainKey,
                        &FixedAttributeName,
                        V1aFixed,
                        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN)
                        );

Error:

    //
    // close the handle
    //

    if (INVALID_HANDLE_VALUE != hDomainKey)
    {
        IgnoreStatus = ZwClose(hDomainKey);
    }

    if (NULL != Buffer)
    {
        RecSamFree(Buffer);
        Buffer = NULL;
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\lib\wxcli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       wxcli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-18-97   RichardW   Created
//
//              09-Jan-99 ShaoYin copied it from security project
//                        This file is just a mimimum subset of the original 
//                        file, only contains part of these original API(s)
// 
//
//----------------------------------------------------------------------------




#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include <zwapi.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <ntlsa.h>

//#include <windows.h>
#include <md5.h>

#include <wxlpc.h>
//#include <wxlpcp.h>

#include "recovery.h"
#include "recmem.h"

#include <stdio.h>
#include <stdlib.h>


/*++

    The following code was moved from syskey to wxcli so as to commonalize this code
    between syskey and samsrv.dll 

--*/
#if DBG
#define HIDDEN
#else
#define HIDDEN static
#endif

HIDDEN
UCHAR KeyShuffle[ 16 ] = { 8, 10, 3, 7, 2, 1, 9, 15, 0, 5, 13, 4, 11, 6, 12, 14 };

HIDDEN
CHAR HexKey[ 17 ] = "0123456789abcdef" ;

#define ToHex( f ) (HexKey[f & 0xF])


#define CONTROL_SET             L"ControlSet"
#define LSA_JD_KEY_NAME         L"Control\\Lsa\\JD"
#define LSA_SKEW1_KEY_NAME      L"Control\\Lsa\\Skew1"
#define LSA_GBG_KEY_NAME        L"Control\\Lsa\\GBG"
#define LSA_DATA_KEY_NAME       L"Control\\Lsa\\Data"
#define SELECT_KEY_NAME         L"Select"
#define VALUE_NAME              L"Current"


#define DATA_SIZE       9
#define KEY_NAME_SIZE   64


#define FromHex( c )    ( ( ( c >= '0' ) && ( c <= '9') ) ? c - '0' :      \
                          ( ( c >= 'a' ) && ( c <= 'f') ) ? c - 'a' + 10:      \
                          ( ( c >= 'A' ) && ( c <= 'F' ) ) ? c - 'A' + 10: -1 )


#define ErrorReturn( c )   if (!NT_SUCCESS(c))  \
                           {                    \
                               return (c);      \
                           }




NTSTATUS
SampDetermineCorrectControlKey(
    IN HANDLE hSystemRootKey, 
    OUT ULONG  *ControlSetNumber
    )
/*++
Routine Description:

    Parses the select node and finds the correct ControlSetXXX to use.
    
Parameters: 

    hSystemRootKey - Handle of the root of the system hive
    
    ControlSetNumber - pointer to a ULONG which will contain the number
    
Return Values:
    
    NTSTATUS code
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES   Attributes;
    UNICODE_STRING      SelectKeyName;
    UNICODE_STRING      SelectValue;
    HANDLE              hSelectKey;
    ULONG               KeyPartialInformationSize = 0;
    PKEY_VALUE_PARTIAL_INFORMATION  KeyPartialInformation = NULL;

    *ControlSetNumber = -1;

    RtlInitUnicodeString(&SelectKeyName, SELECT_KEY_NAME);
    InitializeObjectAttributes(&Attributes, 
                               &SelectKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );
    Attributes.RootDirectory = hSystemRootKey;

    NtStatus = ZwOpenKey(&hSelectKey, KEY_ALL_ACCESS, &Attributes);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    RtlInitUnicodeString(&SelectValue, VALUE_NAME);

    NtStatus = ZwQueryValueKey(hSelectKey, 
                               &SelectValue, 
                               KeyValuePartialInformation, 
                               KeyPartialInformation, 
                               KeyPartialInformationSize, 
                               &KeyPartialInformationSize
                               );

    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        KeyPartialInformation = RecSamAlloc(KeyPartialInformationSize);

        if (KeyPartialInformation)                   
        {
            NtStatus = ZwQueryValueKey(hSelectKey, 
                                       &SelectValue, 
                                       KeyValuePartialInformation, 
                                       KeyPartialInformation, 
                                       KeyPartialInformationSize, 
                                       &KeyPartialInformationSize
                                       );
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }
                              
    if (NT_SUCCESS(NtStatus))
    {
        if (KeyPartialInformation->Type == REG_DWORD)
        {
            *ControlSetNumber = *( (ULONG*) &(KeyPartialInformation->Data[0]) );
        }
        else
        {
            NtStatus = STATUS_OBJECT_NAME_NOT_FOUND; 
        }
    }

    ZwClose(hSelectKey);

    if (KeyPartialInformation)
    {
        RecSamFree(KeyPartialInformation);
    }

    return NtStatus;    
}



NTSTATUS                          
WxpDeobfuscateKeyForRecovery(
    HANDLE  hSystemRootKey,
    PWXHASH Hash
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    WXHASH ProtoHash ;
    CHAR Class[ DATA_SIZE ];
    WCHAR WClass[ DATA_SIZE ];
    ULONG i ;
    PUCHAR j ;
    int t;
    int t2 ;
    HANDLE          JDKey ; 
    HANDLE          Skew1Key ; 
    HANDLE          GBGKey ; 
    HANDLE          DataKey ; 
    UNICODE_STRING  JDKeyName;
    UNICODE_STRING  Skew1KeyName;
    UNICODE_STRING  GBGKeyName;
    UNICODE_STRING  DataKeyName;
    UNICODE_STRING  UnicodeString;
    ANSI_STRING     AnsiString;
    OBJECT_ATTRIBUTES JDAttributes;
    OBJECT_ATTRIBUTES Skew1Attributes;
    OBJECT_ATTRIBUTES GBGAttributes;
    OBJECT_ATTRIBUTES DataAttributes;
    UCHAR    KeyInfo[sizeof(KEY_NODE_INFORMATION) + REGISTRY_KEY_NAME_LENGTH_MAX];
    ULONG   RequiredKeyInfoLength = 0;
    ULONG   ControlSetNumber = -1; 
    WCHAR   JdName[KEY_NAME_SIZE];
    WCHAR   Skew1Name[KEY_NAME_SIZE];
    WCHAR   GbgName[KEY_NAME_SIZE];
    WCHAR   DataName[KEY_NAME_SIZE];


    //
    // Get the Current Control Set Number
    // 
    NtStatus = SampDetermineCorrectControlKey(hSystemRootKey, 
                                              &ControlSetNumber
                                              );

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    RtlZeroMemory(JdName, sizeof(WCHAR) * KEY_NAME_SIZE);
    RtlZeroMemory(Skew1Name, sizeof(WCHAR) * KEY_NAME_SIZE);
    RtlZeroMemory(GbgName, sizeof(WCHAR) * KEY_NAME_SIZE);
    RtlZeroMemory(DataName, sizeof(WCHAR) * KEY_NAME_SIZE);

    swprintf(JdName, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_JD_KEY_NAME
             );

    swprintf(Skew1Name, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_SKEW1_KEY_NAME
             );

    swprintf(GbgName, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_GBG_KEY_NAME
             );

    swprintf(DataName, 
             L"%s%03d\\%s", 
             CONTROL_SET, 
             ControlSetNumber, 
             LSA_DATA_KEY_NAME
             );

    //
    // Initialize Variables
    //
    RtlInitUnicodeString(&JDKeyName, JdName);

    RtlInitUnicodeString(&Skew1KeyName, Skew1Name); 

    RtlInitUnicodeString(&GBGKeyName, GbgName);

    RtlInitUnicodeString(&DataKeyName, DataName);

    InitializeObjectAttributes(
            &JDAttributes, 
            &JDKeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    JDAttributes.RootDirectory = hSystemRootKey;

    InitializeObjectAttributes(
            &Skew1Attributes, 
            &Skew1KeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    Skew1Attributes.RootDirectory = hSystemRootKey;

    InitializeObjectAttributes(
            &GBGAttributes, 
            &GBGKeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    GBGAttributes.RootDirectory = hSystemRootKey;

    InitializeObjectAttributes(
            &DataAttributes, 
            &DataKeyName, 
            OBJ_CASE_INSENSITIVE, 
            0, 
            NULL
            );
    DataAttributes.RootDirectory = hSystemRootKey;

    RtlZeroMemory(Class, sizeof(Class));
    RtlZeroMemory(WClass, sizeof(WClass));


    RtlInitUnicodeString(&UnicodeString, WClass);
    RtlInitAnsiString(&AnsiString, Class);

    UnicodeString.Length = (DATA_SIZE - 1) * sizeof(WCHAR);
    UnicodeString.MaximumLength = DATA_SIZE * sizeof(WCHAR);
    AnsiString.Length = (DATA_SIZE - 1) * sizeof(WCHAR);
    AnsiString.MaximumLength = DATA_SIZE * sizeof(CHAR);


    j = ProtoHash.Digest ;

    //
    // JD
    // 

    NtStatus = ZwOpenKey(&JDKey, 
                         KEY_READ, 
                         &JDAttributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(JDKey, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );

    ZwClose(JDKey);
    
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE      // do not allocate buffer 
                                            );

    ErrorReturn(NtStatus);

    
    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }

    //
    // Skew1 
    // 

    NtStatus = ZwOpenKey(&Skew1Key, 
                         KEY_READ, 
                         &Skew1Attributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(Skew1Key, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );

    ZwClose(Skew1Key);
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE          // do not allocate buffer
                                            );

    ErrorReturn(NtStatus);

    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }

    //
    // GBG 
    // 

    NtStatus = ZwOpenKey(&GBGKey, 
                         KEY_READ, 
                         &GBGAttributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(GBGKey, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );


    ZwClose(GBGKey);
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE          // do not allocate buffer
                                            );

    ErrorReturn(NtStatus); 
   
    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }


    //
    // Data 
    // 

    NtStatus = ZwOpenKey(&DataKey, 
                         KEY_READ, 
                         &DataAttributes
                         );

    ErrorReturn(NtStatus);

    NtStatus = ZwQueryKey(DataKey, 
                          KeyNodeInformation, 
                          KeyInfo, 
                          sizeof(KeyInfo), 
                          &RequiredKeyInfoLength
                          );

    ZwClose(DataKey);
    ErrorReturn(NtStatus);

    RtlCopyMemory(WClass, 
                  KeyInfo + ((PKEY_NODE_INFORMATION)KeyInfo)->ClassOffset, 
                  ((PKEY_NODE_INFORMATION)KeyInfo)->ClassLength 
                  );

    
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString, 
                                            &UnicodeString, 
                                            FALSE          // do not allocate buffer
                                            );

    ErrorReturn(NtStatus);

    for ( i = 0 ; i < 8 ; i += 2 )
    {
        t = FromHex( Class[ i ] );
        t2 = FromHex( Class[ i+1 ] );
        if ( (t >= 0 ) && ( t2 >= 0 ) )
        {
            *j++ = (t << 4) + t2 ;
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
            ErrorReturn(NtStatus);
        }
    }


    for ( i = 0 ; i < 16 ; i++ )
    {
        Hash->Digest[ KeyShuffle[ i ] ] = ProtoHash.Digest[ i ] ;
    }


    return NtStatus;

}




NTSTATUS
WxReadSysKeyForRecovery(
    IN HANDLE hSystemRootKey,
    IN OUT PULONG BufferLength,
    OUT PVOID  Key 
    )
 /*++

    Routine Description

    This routine is used to retrieve the syskey from
    the registry

    Paramaeters

        hSystemRootKey Handle of the root of the System Hive

        BufferLength  is filled in with the length required on output
                      is used to indicate the size of the buffer 
                      pointed to by Key.
        Key           Points to a buffer into which the key is recieved

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL
        STATUS_BUFFER_OVERFLOW
        STATUS_INTERNAL_ERROR
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    WXHASH H;

    if ((NULL==Key) || (*BufferLength <sizeof(H.Digest)))
    {
        *BufferLength = sizeof(H.Digest);
        return(STATUS_BUFFER_OVERFLOW);
    }

    NtStatus = WxpDeobfuscateKeyForRecovery(hSystemRootKey, 
                                            &H
                                            );

    if (NT_SUCCESS(NtStatus))
    {
          *BufferLength = sizeof(H.Digest);
          RtlCopyMemory(
                  Key,
                  &H.Digest,
                  *BufferLength
                  );

          return(STATUS_SUCCESS);
    }

    return (NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\ntdsupg\ntdsupg.c ===
/*++

Copyright (C) Microsoft Corporation, 1998.
              Microsoft Windows

Module Name:

    NTDSUPG.C

Abstract:

    This file is used to check NT4 (or any downlevel) Backup Domain
    Controller upgrading first problem. If the NT4 Primary Domain
    Controller has not been upgraded yet, we should disable NT4 BDC
    upgrading.

Author:

    ShaoYin 05/01/98

Environment:

    User Mode - Win32

Revision History:

    ShaoYin 05/01/98  Created Initial File.
    Tarekk  10/2002   Added dwonlevel interop checks

--*/

#pragma hdrstop

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <limits.h>

#include <winldap.h>

#include "comp.h"
#include "msgs.h"
#include "dsconfig.h"

#include "adpcheck.h"


#define NEEDED_DISK_SPACE_MB (250)
#define NEEDED_DISK_SPACE_BYTES (NEEDED_DISK_SPACE_MB * 1024 * 1024)

//  make sure there's enough disk space on the log drive for
//  at least a few logs plus the reserve logs
//
#define NEEDED_LOG_DISK_SPACE_MB        50
#define NEEDED_LOG_DISK_SPACE_BYTES     ( NEEDED_LOG_DISK_SPACE_MB * 1024 * 1024 )


DWORD
GetDbDiskSpaceSizes (
    PULARGE_INTEGER dbSize,
    PULARGE_INTEGER freeDiskBytes,
    char *driveAD
);

DWORD
GetLogDiskSpaceSizes (
    PULARGE_INTEGER freeDiskBytes,
    char *driveLogs
);


BOOL
WINAPI
DsUpgradeCheckNT4PDC(
    HMODULE     ResourceDll,
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    int         Response = 0;
    ULONG       Length = 0;
    WCHAR       *DescriptionString = NULL;
    WCHAR       *CaptionString = NULL;
    WCHAR       *WarningString = NULL;
    TCHAR       TextFileName[] = TEXT("compdata\\ntdsupg.txt");
    TCHAR       HtmlFileName[] = TEXT("compdata\\ntdsupg.htm");
    TCHAR       DefaultCaption[] = TEXT("Windows NT Domain Controller Upgrade Checking");
    TCHAR       DefaultDescription[] = TEXT("Primary Domain Controller should be upgraded first");
    TCHAR       DefaultWarning[] = TEXT("Before upgrading any Backup Domain Controller, you should upgrade your Primary Domain Controller first.\n\nClick Yes to continue, click No to exit from setup.");

    COMPATIBILITY_ENTRY CompEntry;
    BYTE*               pInfo = NULL;
    BYTE*               pPDCInfo = NULL;
    LPBYTE              pPDCName = NULL;
    PSERVER_INFO_101    pSrvInfo = NULL;
    NET_API_STATUS      NetStatus;

    //
    // initialize variables
    //
    RtlZeroMemory(&CompEntry, sizeof(COMPATIBILITY_ENTRY));

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_CAPTION,
                                        0,
                                        (LPWSTR)&CaptionString,
                                        0,
                                        NULL
                                        );
        if (CaptionString) {
            // Messages from message file have a cr and lf appended to the end
            CaptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_DESCRIPTION,
                                        0,
                                        (LPWSTR)&DescriptionString,
                                        0,
                                        NULL
                                        );
        if (DescriptionString) {
            DescriptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_WARNINGMESSAGE,
                                        0,
                                        (LPWSTR)&WarningString,
                                        0,
                                        NULL
                                        );
        if (WarningString) {
            WarningString[Length-2] = L'\0';
        }
    }

    //
    // use default messages if read from DLL failed
    //

    if (DescriptionString == NULL) {
        DescriptionString = DefaultDescription;
    }

    if (CaptionString == NULL) {
        CaptionString = DefaultCaption;
    }

    if (WarningString == NULL) {
        WarningString = DefaultWarning;
    }


    NetStatus = NetServerGetInfo(NULL,
                                 101,
                                 &pInfo
                                 );

    if (NetStatus != NERR_Success) {
        goto Error;
    }

    pSrvInfo = (PSERVER_INFO_101) pInfo;

    if (pSrvInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) { // BDC

        NetStatus = NetGetDCName(NULL,
                                 NULL,
                                 &pPDCName
                                 );

        if (NetStatus != NERR_Success) {
            goto Error;
        }

        NetStatus = NetServerGetInfo((LPWSTR)pPDCName,
                                     101,
                                     &pPDCInfo
                                     );

        if (NetStatus != NERR_Success) {
            goto Error;
        }

        pSrvInfo = (PSERVER_INFO_101) pPDCInfo;

        if (pSrvInfo->sv101_version_major < 5) {

            // PDC has not been upgraded yet
            // stop upgrading
            CompEntry.Description   = DescriptionString;
            CompEntry.HtmlName      = HtmlFileName;
            CompEntry.TextName      = TextFileName;
            CompEntry.RegKeyName    = NULL;
            CompEntry.RegValName    = NULL;
            CompEntry.RegValDataSize= 0;
            CompEntry.RegValData    = NULL;
            CompEntry.SaveValue     = NULL;
            CompEntry.Flags         = 0;

            CompatibilityCallback(&CompEntry, Context);
        }
    }

    goto Cleanup;

Error:


    Response = MessageBox(NULL,
                          WarningString,
                          CaptionString,
                          MB_YESNO | MB_ICONQUESTION |
                          MB_SYSTEMMODAL | MB_DEFBUTTON2
                          );

    if (Response == IDNO) {

        CompEntry.Description   = DescriptionString;
        CompEntry.HtmlName      = NULL;
        CompEntry.TextName      = TextFileName;
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }

Cleanup:

    if (pInfo != NULL) {
        NetApiBufferFree(pInfo);
    }
    if (pPDCInfo != NULL) {
        NetApiBufferFree(pPDCInfo);
    }
    if (pPDCName != NULL) {
        NetApiBufferFree(pPDCName);
    }

    if (CaptionString != NULL && CaptionString != DefaultCaption) {
        LocalFree(CaptionString);
    }

    if (WarningString != NULL && WarningString != DefaultWarning) {
        LocalFree(WarningString);
    }

    if (DescriptionString != NULL && DescriptionString != DefaultDescription) {
        LocalFree(DescriptionString);
    }


    return ((PCOMPATIBILITY_CONTEXT)Context)->Count;

}

BOOL
WINAPI
DsUpgradeQDomainRegKeyExists()
/*++

    Routine Description: Checks if a registry key exists or not

    Parameters:
        NONE

    Return Value:
        TRUE    Key exists
        FALSE   Key doesn't exist or some other error
--*/
{
    DWORD ErrorCode;
    DWORD Size = 0;
    const PWSTR QDomainsRegKey = L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters";
    const PWSTR QDomainsRegValue = L"QuarantinedDomains";
    HKEY QDomainsKey = NULL;

    //
    // Open the reg key
    //
    ErrorCode = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    QDomainsRegKey,
                    0,
                    KEY_READ,
                    &QDomainsKey
                    );

    if( ErrorCode != ERROR_SUCCESS ) {

        return FALSE;
    }

    //
    // Query the value of the key to see the size of the data
    //  if the value is not there, continue
    //
    ErrorCode = RegQueryValueExW(
                    QDomainsKey,
                    QDomainsRegValue,
                    0,
                    NULL,
                    NULL,
                    &Size
                    );


    RegCloseKey( QDomainsKey );

    if( ErrorCode != ERROR_SUCCESS ) {

        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
DsUpgradeCheckNT4QuarantinedDomains(
    HMODULE     ResourceDll,
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
/*++

    Routine Description: Checks if a registry key exists or not

    Parameters:
        ResourceDll - Handle to dll where resources are
        CompatibilityCallback - callback function for reporting errors
        Context - Datastructure to pass error information to the
            callback function

    Return Value:
        TRUE    Operation done successfully
        FALSE   Operation was not done successfully
--*/
{
    int         Response = 0;
    ULONG       Length = 0;
    WCHAR       *DescriptionString = NULL;
    WCHAR       *CaptionString = NULL;
    WCHAR       *WarningString = NULL;
    TCHAR       TextFileName[] = TEXT("compdata\\qdomains.txt");
    TCHAR       HtmlFileName[] = TEXT("compdata\\qdomains.htm");
    TCHAR       DefaultCaption[] = TEXT("Windows NT4 Primary Domain Controller Upgrade Checking");
    TCHAR       DefaultDescription[] = TEXT("No quarantined trusted domains can exist during NT4 PDC upgrade");
    TCHAR       DefaultWarning[] = TEXT("Due to unexpected error, setup can not determine your system type. If this machine is a Windows NT 4.0 Primary Domain Controller, before upgrading this machine please make sure that none of the trusted domains are quarantined. Otherwise continuing to upgrade on this system may lead this Primary Domain Controller in unstable state.\n\nClick Yes to continue upgrading, click No to exit from setup.");

    COMPATIBILITY_ENTRY CompEntry;
    BYTE*               pInfo = NULL;
    PSERVER_INFO_101    pSrvInfo = NULL;
    NET_API_STATUS      NetStatus;

    //
    // initialize variables
    //
    RtlZeroMemory(&CompEntry, sizeof(COMPATIBILITY_ENTRY));

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_QDOMAIN_CAPTION,
                                        0,
                                        (LPWSTR)&CaptionString,
                                        0,
                                        NULL
                                        );
        if (CaptionString) {
            // Messages from message file have a cr and lf appended to the end
            CaptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_QDOMAIN_DESCRIPTION,
                                        0,
                                        (LPWSTR)&DescriptionString,
                                        0,
                                        NULL
                                        );
        if (DescriptionString) {
            DescriptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_QDOMAIN_WARNINGMESSAGE,
                                        0,
                                        (LPWSTR)&WarningString,
                                        0,
                                        NULL
                                        );
        if (WarningString) {
            WarningString[Length-2] = L'\0';
        }
    }

    //
    // use default messages if read from DLL failed
    //

    if (DescriptionString == NULL) {
        DescriptionString = DefaultDescription;
    }

    if (CaptionString == NULL) {
        CaptionString = DefaultCaption;
    }

    if (WarningString == NULL) {
        WarningString = DefaultWarning;
    }


    NetStatus = NetServerGetInfo(NULL,
                                 101,
                                 &pInfo
                                 );

    if (NetStatus != NERR_Success) {
        goto Error;
    }

    pSrvInfo = (PSERVER_INFO_101) pInfo;


    if (!(pSrvInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) && // BDC
         (pSrvInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ) {   // DC


        if( DsUpgradeQDomainRegKeyExists() ) {

            CompEntry.Description   = DescriptionString;
            CompEntry.HtmlName      = HtmlFileName;
            CompEntry.TextName      = TextFileName;
            CompEntry.RegKeyName    = NULL;
            CompEntry.RegValName    = NULL;
            CompEntry.RegValDataSize= 0;
            CompEntry.RegValData    = NULL;
            CompEntry.SaveValue     = NULL;
            CompEntry.Flags         = 0;

            CompatibilityCallback(&CompEntry, Context);
        }
    }

    goto Cleanup;

Error:


    Response = MessageBox(NULL,
                          WarningString,
                          CaptionString,
                          MB_YESNO | MB_ICONQUESTION |
                          MB_SYSTEMMODAL | MB_DEFBUTTON2
                          );

    if (Response == IDNO) {

        CompEntry.Description   = DescriptionString;
        CompEntry.HtmlName      = HtmlFileName;
        CompEntry.TextName      = TextFileName;
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }

Cleanup:

    if (pInfo != NULL) {
        NetApiBufferFree(pInfo);
    }
    if (CaptionString != NULL && CaptionString != DefaultCaption) {
        LocalFree(CaptionString);
    }

    if (WarningString != NULL && WarningString != DefaultWarning) {
        LocalFree(WarningString);
    }

    if (DescriptionString != NULL && DescriptionString != DefaultDescription) {
        LocalFree(DescriptionString);
    }


    return ((PCOMPATIBILITY_CONTEXT)Context)->Count;

}

BOOL
WINAPI
DsUpgradeCheckDiskSpace(
    HMODULE     ResourceDll,
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context)
{
    int         Response = 0;
    ULONG       Length = 0;
    WCHAR       *DiskSpaceCaptionString = NULL;
    WCHAR       *DiskSpaceDescriptionString = NULL;
    WCHAR       *DiskSpaceErrorString = NULL;
    WCHAR       *DiskSpaceWarningString = NULL;
    TCHAR       DiskSpaceTextFileName[] = TEXT("compdata\\ntdsupgd.txt");
    TCHAR       DiskSpaceHtmlFileName[] = TEXT("compdata\\ntdsupgd.htm");
    TCHAR       DiskSpaceDefaultCaption[] = TEXT("Windows NT Domain Controller Disk Space Checking");
    TCHAR       DiskSpaceDefaultDescription[] = TEXT("Not enough disk space for Active Directory upgrade");
    TCHAR       DiskSpaceDefaultError[] = TEXT("Setup has detected that you may not have enough disk space for the Active Directory upgrade.\nTo complete the upgrade make sure that %1!u! MB of free space are available on drive %2!hs!.");
    TCHAR       DiskSpaceDefaultWarning[] = TEXT("Setup was unable to detect the amount of free space on the partition(s) on which the Active Directory database and/or log files reside. To complete the upgrade, make sure you have at least 250MB free on the partition on which the Active Directory database resides and 50Mb free on the partition on which the Active Directory log files reside, and press OK.\nTo exit Setup click Cancel.");

    COMPATIBILITY_ENTRY CompEntry;
    ULARGE_INTEGER dbSize, diskFreeBytes, neededSpace;
    DWORD       dwNeededDiskSpaceMB = NEEDED_DISK_SPACE_MB;
    LPVOID      lppArgs[2];
    char        driveAD[10];
    BOOL        fInsufficientSpace  = FALSE;
    DWORD       dwErr;

    //
    // initialize variables
    //
    RtlZeroMemory(&CompEntry, sizeof(COMPATIBILITY_ENTRY));

    //
    // read the DiskSpace related messages
    //
    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_DISKSPACE_CAPTION,
                                        0,
                                        (LPWSTR)&DiskSpaceCaptionString,
                                        0,
                                        NULL
                                        );
        if (DiskSpaceCaptionString) {
            DiskSpaceCaptionString[Length-2] = L'\0';
        }


        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_DISKSPACE_DESC,
                                        0,
                                        (LPWSTR)&DiskSpaceDescriptionString,
                                        0,
                                        NULL
                                        );

        if (DiskSpaceDescriptionString) {
            DiskSpaceDescriptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                        ResourceDll,
                                        NTDSUPG_DISKSPACE_WARNING,
                                        0,
                                        (LPWSTR)&DiskSpaceWarningString,
                                        0,
                                        NULL
                                        );
        if (DiskSpaceWarningString) {
            DiskSpaceWarningString[Length-2] = L'\0';
        }
    }

    if (DiskSpaceDescriptionString == NULL) {
        DiskSpaceDescriptionString = DiskSpaceDefaultDescription;
    }

    if (DiskSpaceCaptionString == NULL) {
        DiskSpaceCaptionString = DiskSpaceDefaultCaption;
    }

    if (DiskSpaceWarningString == NULL) {
        DiskSpaceWarningString = DiskSpaceDefaultWarning;
    }

    //
    // check for enough free disk space for the DS database
    //

    if ((dwErr = GetDbDiskSpaceSizes (&dbSize, &diskFreeBytes, driveAD)) != ERROR_SUCCESS) {
        goto DsUpgradeDiskSpaceError;
    }

    // we need 10% of database size or at least 250MB
    //

    if ((dbSize.QuadPart > 10 * diskFreeBytes.QuadPart) ||
        (diskFreeBytes.QuadPart < NEEDED_DISK_SPACE_BYTES )) {

        fInsufficientSpace = TRUE;

        neededSpace.QuadPart = dbSize.QuadPart / 10;

        if (neededSpace.QuadPart < NEEDED_DISK_SPACE_BYTES) {
            dwNeededDiskSpaceMB = NEEDED_DISK_SPACE_MB;
        }
        else {
            // convert it to MB
            neededSpace.QuadPart = neededSpace.QuadPart / 1024;
            neededSpace.QuadPart = neededSpace.QuadPart / 1024;

            if (neededSpace.HighPart) {
                dwNeededDiskSpaceMB = UINT_MAX;
            }
            else {
                dwNeededDiskSpaceMB = neededSpace.LowPart;
            }
        }
    }

    //  only bother to check log drive if db drive check succeeded
    //
    else if ( ( dwErr = GetLogDiskSpaceSizes( &diskFreeBytes, driveAD ) ) != ERROR_SUCCESS ) {
        goto DsUpgradeDiskSpaceError;
    }

    //  we need at least 50Mb on the log drive
    //
    else if ( diskFreeBytes.QuadPart < NEEDED_LOG_DISK_SPACE_BYTES ) {
        fInsufficientSpace = TRUE;
        dwNeededDiskSpaceMB = NEEDED_LOG_DISK_SPACE_MB;
    }

    if ( fInsufficientSpace ) {
        // now we have an estimate of the needed free space, so read string one more time
        //
        if (ResourceDll) {

            if (DiskSpaceWarningString != NULL && DiskSpaceWarningString != DiskSpaceDefaultWarning) {
                LocalFree(DiskSpaceWarningString);
                DiskSpaceWarningString = NULL;
            }

            lppArgs[0] = (void *)(DWORD_PTR)dwNeededDiskSpaceMB;
            lppArgs[1] = (void *)driveAD;

            Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                            ResourceDll,
                                            NTDSUPG_DISKSPACE_ERROR,
                                            0,
                                            (LPWSTR)&DiskSpaceErrorString,
                                            0,
                                            (va_list *)lppArgs
                                            );

            if (DiskSpaceErrorString) {
                DiskSpaceErrorString[Length-2] = L'\0';
            }
            else {
                DiskSpaceErrorString = DiskSpaceDefaultError;
            }
        }

        Response = MessageBox(NULL,
                              DiskSpaceErrorString,
                              DiskSpaceCaptionString,
                              MB_OK | MB_ICONQUESTION |
                              MB_SYSTEMMODAL | MB_DEFBUTTON2
                              );

        CompEntry.Description   = DiskSpaceDescriptionString;
        CompEntry.HtmlName      = DiskSpaceHtmlFileName;
        CompEntry.TextName      = DiskSpaceTextFileName;
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }


    goto DsUpgradeDiskSpaceCleanup;

DsUpgradeDiskSpaceError:

    Response = MessageBox(NULL,
                          DiskSpaceWarningString,
                          DiskSpaceCaptionString,
                          MB_OKCANCEL | MB_ICONQUESTION |
                          MB_SYSTEMMODAL | MB_DEFBUTTON2
                          );

    if (Response == IDCANCEL) {

        CompEntry.Description   = DiskSpaceDescriptionString;
        CompEntry.HtmlName      = DiskSpaceHtmlFileName;
        CompEntry.TextName      = DiskSpaceTextFileName;
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }

DsUpgradeDiskSpaceCleanup:


    if (DiskSpaceCaptionString != NULL && DiskSpaceCaptionString != DiskSpaceDefaultCaption) {
        LocalFree(DiskSpaceCaptionString);
    }

    if (DiskSpaceDescriptionString != NULL && DiskSpaceDescriptionString != DiskSpaceDefaultDescription) {
        LocalFree(DiskSpaceDescriptionString);
    }

    if (DiskSpaceWarningString != NULL && DiskSpaceWarningString != DiskSpaceDefaultWarning) {
        LocalFree(DiskSpaceWarningString);
    }

    if (DiskSpaceErrorString != NULL && DiskSpaceErrorString != DiskSpaceDefaultError) {
        LocalFree(DiskSpaceErrorString);
    }

    return ((PCOMPATIBILITY_CONTEXT)Context)->Count;

}




BOOL
WINAPI
DsUpgradeCheckForestAndDomainState(
    HMODULE     ResourceDll,
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    ULONG           WinError = ERROR_SUCCESS;
    WCHAR           *DescriptionString = NULL;
    WCHAR           *CaptionString = NULL;
    WCHAR           *ErrorString = NULL;
    TCHAR           *TextFileName = NULL;
    TCHAR           *HtmlFileName = NULL;
    TCHAR           DefaultCaption[] = TEXT("Check Active Directory upgrade preparation");
    TCHAR           DefaultDescription[] = TEXT("The Windows 2000 Active Directory forest and domain need to be prepared for Windows Server 2003");
    TCHAR           DefaultError[] = TEXT("Setup was unable to check your active directory upgrade preparation state. To successfully upgrade your domain controller, please make sure you run adprep.exe /forestprep on forest schema master domain controller and adprep.exe /domainprep on domain infrastructure master domain controller prior to upgrading this machine. Press OK to exit setup.");
    ULONG           Length = 0;

    int             Response = 0;
    COMPATIBILITY_ENTRY CompEntry;
    LDAP            *LdapHandle = NULL;
    ERROR_HANDLE    ErrorHandle;
    BOOLEAN         fAmISchemaMaster = FALSE,
                    fAmIInfrastructureMaster = FALSE,
                    fIsFinishedLocally = FALSE,
                    fIsFinishedOnSchemaMaster = FALSE,
                    fIsFinishedOnIM = FALSE,
                    fIsSchemaUpgradedLocally = FALSE,
                    fIsSchemaUpgradedOnSchemaMaster = FALSE,
                    fStopUpgrade = FALSE;
    PWCHAR          pSchemaMasterDnsHostName = NULL;
    PWCHAR          pInfraMasterDnsHostName = NULL;



    //
    // initialize variable
    //
    memset(&CompEntry, 0, sizeof(COMPATIBILITY_ENTRY));
    memset(&ErrorHandle, 0, sizeof(ERROR_HANDLE));

    // load resource string
    if (ResourceDll)
    {
        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_ADPREP_CAPTION,
                                        0,
                                        (LPWSTR)&CaptionString,
                                        0,
                                        NULL
                                        );
        if (CaptionString) {
            // Messages from message file have a cr and lf appended to the end
            CaptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_ADPREP_DESCRIPTION,
                                        0,
                                        (LPWSTR)&DescriptionString,
                                        0,
                                        NULL
                                        );
        if (DescriptionString) {
            // Messages from message file have a cr and lf appended to the end
            DescriptionString[Length-2] = L'\0';
        }

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        NTDSUPG_ADPREP_ERROR,
                                        0,
                                        (LPWSTR)&ErrorString,
                                        0,
                                        NULL
                                        );
        if (DescriptionString) {
            // Messages from message file have a cr and lf appended to the end
            ErrorString[Length-2] = L'\0';
        }
    }

    if (CaptionString == NULL) {
        CaptionString = DefaultCaption;
    }

    if (DescriptionString == NULL) {
        DescriptionString = DefaultDescription;
    }

    if (ErrorString == NULL) {
        ErrorString = DefaultError;
    }


    //
    // make ldap connection
    //
    WinError = AdpMakeLdapConnection(&LdapHandle,
                                     NULL,         // local host
                                     &ErrorHandle
                                     );

    if (ERROR_SUCCESS != WinError)
    {
        // failed to make ldap connection
        goto CheckForestAndDomainError;
    }

    //
    // check forest preparation
    //
    WinError = AdpCheckForestUpgradeStatus(LdapHandle,
                                           &pSchemaMasterDnsHostName,
                                           &fAmISchemaMaster,
                                           &fIsFinishedLocally,
                                           &fIsFinishedOnSchemaMaster,
                                           &fIsSchemaUpgradedLocally,
                                           &fIsSchemaUpgradedOnSchemaMaster,
                                           &ErrorHandle
                                           );

    if (ERROR_SUCCESS != WinError)
    {
        // somehow, failed to check Forest Upgrade status
        goto CheckForestAndDomainError;
    }

    if ( !fIsFinishedLocally || !fIsSchemaUpgradedLocally )
    {
        // Forest wide information has not been upgraded yet.
        // stop upgrading this DC

        if (fAmISchemaMaster)
        {
            // case Forest 1 a)
            HtmlFileName = TEXT("compdata\\forest1a.htm");
            TextFileName = TEXT("compdata\\forest1a.txt");
        }
        else
        {
            // case Forest 1 b)
            HtmlFileName = TEXT("compdata\\forest1b.htm");
            TextFileName = TEXT("compdata\\forest1b.txt");
        }

        fStopUpgrade = TRUE;
    }
    else
    {
        //
        // forest has been upgraded.
        // now check domain preparation
        //
        fIsFinishedLocally = FALSE;

        WinError = AdpCheckDomainUpgradeStatus(LdapHandle,
                                               &pInfraMasterDnsHostName,
                                               &fAmIInfrastructureMaster,
                                               &fIsFinishedLocally,
                                               &fIsFinishedOnIM,
                                               &ErrorHandle
                                               );

        if (ERROR_SUCCESS != WinError)
        {
            // somehow, failed to check Domain Upgrade status
            goto CheckForestAndDomainError;
        }

        if ( !fIsFinishedLocally )
        {
            // domain wide information has not been upgraded yet.
            // stop upgrading this machine


            if (fAmIInfrastructureMaster)
            {
                // case Domain 2 a)
                HtmlFileName = TEXT("compdata\\domain2a.htm");
                TextFileName = TEXT("compdata\\domain2a.txt");
            }
            else
            {
                // case Domain 2 b)
                HtmlFileName = TEXT("compdata\\domain2b.htm");
                TextFileName = TEXT("compdata\\domain2b.txt");
            }

            fStopUpgrade = TRUE;
        }
    }

    if (fStopUpgrade)
    {
        CompEntry.Description   = DescriptionString;
        CompEntry.HtmlName      = HtmlFileName;
        CompEntry.TextName      = TextFileName;
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }

    goto CheckForestAndDomainCleanup;

CheckForestAndDomainError:

    Response = MessageBox(NULL,
                          ErrorString,
                          CaptionString,
                          MB_ICONSTOP |
                          MB_SYSTEMMODAL | MB_DEFBUTTON1
                          );

    if (IDOK == Response)
    {
        CompEntry.Description   = DescriptionString;
        CompEntry.HtmlName      = TEXT("compdata\\adperr.htm");
        CompEntry.TextName      = TEXT("compdata\\adperr.txt");
        CompEntry.RegKeyName    = NULL;
        CompEntry.RegValName    = NULL;
        CompEntry.RegValDataSize= 0;
        CompEntry.RegValData    = NULL;
        CompEntry.SaveValue     = NULL;
        CompEntry.Flags         = 0;

        CompatibilityCallback(&CompEntry, Context);
    }

CheckForestAndDomainCleanup:

    if (NULL != LdapHandle) {
        ldap_unbind_s(LdapHandle);
    }

    if (CaptionString != NULL && CaptionString != DefaultCaption) {
        LocalFree(CaptionString);
    }

    if (ErrorString != NULL && ErrorString != DefaultError) {
        LocalFree(ErrorString);
    }

    if (DescriptionString != NULL && DescriptionString != DefaultDescription) {
        LocalFree(DescriptionString);
    }

    if (pSchemaMasterDnsHostName != NULL) {
        AdpFree( pSchemaMasterDnsHostName );
    }

    if (pInfraMasterDnsHostName != NULL) {
        AdpFree( pInfraMasterDnsHostName );
    }


    return ((PCOMPATIBILITY_CONTEXT)Context)->Count;
}

VOID
ConfigureServicesForUpgrade()
{

    LPQUERY_SERVICE_CONFIG ServiceConfig = NULL;
    SC_HANDLE              hScMgr = NULL;
    SC_HANDLE              hSvc = NULL;
    DWORD                  WinError = ERROR_SUCCESS;
    DWORD                  ServiceIndex = 0;

    struct {
        WCHAR *Name;
        DWORD Action;
    } UpgradeServices[] =
    {

        {   L"RPCLocator", SERVICE_DEMAND_START },
        {   NULL         , 0                    }

    };

    //
    // Open the service control manager
    //
    hScMgr = OpenSCManager( NULL,
                            SERVICES_ACTIVE_DATABASE,
                            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    while (UpgradeServices[ServiceIndex].Name) {

        if ( hScMgr == NULL ) {
            WinError = GetLastError();
            goto Cleanup;
        }

        // Open the service
        hSvc = OpenService( hScMgr,
                            UpgradeServices[ServiceIndex].Name,
                            SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG );

        if ( hSvc == NULL ) {
            WinError = GetLastError();
            goto Cleanup;
        }

        //Change the service to it's new configuration
        if ( ChangeServiceConfig( hSvc,
                                  SERVICE_NO_CHANGE,
                                  UpgradeServices[ServiceIndex].Action,
                                  SERVICE_NO_CHANGE,
                                  NULL,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL, NULL, NULL ) == FALSE ) {

            WinError = GetLastError();
            goto Cleanup;
        }

        if ( hSvc ) {

            CloseServiceHandle( hSvc );
            hSvc = NULL;

        }

        if ( hScMgr ) {

            CloseServiceHandle( hScMgr );
            hScMgr = NULL;

        }

        //Change the next service
        ServiceIndex++;

    }

Cleanup:

    if ( hSvc ) {

        CloseServiceHandle( hSvc );

    }

    if ( hScMgr ) {

        CloseServiceHandle( hScMgr );

    }

    ASSERT(WinError == ERROR_SUCCESS);

    return;
}


BOOL
WINAPI
DsUpgradeCompatibilityCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context)
{
    OSVERSIONINFOEXW    osvi;
    NT_PRODUCT_TYPE     Type;
    HMODULE             ResourceDll;
    BOOL                bOsVersionInfoEx = FALSE;
    BOOL                bDomainController = FALSE;


    //
    // get the string from resource table.
    //
    ResourceDll = (HMODULE) LoadLibrary( L"NTDSUPG.DLL" );


    //
    // get OS version and product type (try osversioninfoEX first)
    //
    memset(&osvi, 0, sizeof(OSVERSIONINFOEXW));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    if ( !(bOsVersionInfoEx = GetVersionExW((OSVERSIONINFOW *) &osvi)) )
    {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
        // OSVERSIONINFOEX only works on NT4.0 SP6 and later

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
        GetVersionExW( (OSVERSIONINFOW *)&osvi );
    }


    //
    // Windows NT, Windows 2000 or Whistler
    //
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
    {

        if ( bOsVersionInfoEx )
        {
            if (VER_NT_DOMAIN_CONTROLLER == osvi.wProductType) {
                bDomainController = TRUE;
            }
        }
        else
        {
            if ( !RtlGetNtProductType(&Type) ) {
                // can't retrieve ProductType, default it to Domain Controller
                bDomainController = TRUE;
            }
            else if (NtProductLanManNt == Type) {
                bDomainController = TRUE;
            }
        }

        //
        // Do Domain Controller upgrade checks
        //
        if (bDomainController)
        {
            if (osvi.dwMajorVersion <= 4) // NT4
            {
                // check NT4 PDC
                DsUpgradeCheckNT4PDC(ResourceDll,
                                     CompatibilityCallback,
                                     Context);
                // check if NT4 QuaratinedDomains reg key exists
                DsUpgradeCheckNT4QuarantinedDomains(ResourceDll,
                                                    CompatibilityCallback,
                                                    Context);

            }
            else // Windows 2000 or Whistler
            {
                // check disk space
                DsUpgradeCheckDiskSpace(ResourceDll,
                                        CompatibilityCallback,
                                        Context);


                // check Forest/Domain upgrade status
                DsUpgradeCheckForestAndDomainState(
                                        ResourceDll,
                                        CompatibilityCallback,
                                        Context
                                        );

                //We want to disable the RPC locator on non-NT4 DC upgrades
                //For NT4 upgrades the RPC locator service will be configured
                // during dcpromo.
                ConfigureServicesForUpgrade();
            }

        }

    }

    if (NULL != ResourceDll)
    {
        FreeLibrary(ResourceDll);
    }

    return ((PCOMPATIBILITY_CONTEXT)Context)->Count;
}



DWORD GetDbDiskSpaceSizes (PULARGE_INTEGER dbSize, PULARGE_INTEGER freeDiskBytes, char *driveAD)
{
    HKEY            hKey;
    DWORD           dwErr;
    DWORD           dwType;
    DWORD           cbData;
    char            pszDbFilePath[MAX_PATH];
    char            pszDbDir[MAX_PATH];
    char            *pTmp;
    DWORD           dwSuccess = ERROR_SUCCESS;
    HANDLE          hFind;
    WIN32_FIND_DATAA FindFileData;
    ULARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes, i64FreeBytes;


    if ( dwErr = RegOpenKeyA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hKey) )
    {
        return dwErr;
    }

    _try
    {
        cbData = sizeof(pszDbFilePath);
        dwErr = RegQueryValueExA(    hKey,
                                    FILEPATH_KEY,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) pszDbFilePath,
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            dwSuccess = dwErr;
            _leave;
        }
        else if ( cbData > sizeof(pszDbFilePath) )
        {
            dwSuccess = 1;
            _leave;
        }
        else
        {
            strcpy(pszDbDir, pszDbFilePath);
            pTmp = strrchr(pszDbDir, (int) '\\');  //find last occurence

            if ( !pTmp )
            {
                dwSuccess = 2;
                _leave;
            }
            else
            {
                *pTmp = '\0';
            }

            driveAD[0] = pszDbDir[0];
            driveAD[1] = pszDbDir[1];
            driveAD[2] = '\0';
        }


        // find DB size

        _try
        {
            hFind = FindFirstFileA(pszDbFilePath, &FindFileData);

            if (hFind == INVALID_HANDLE_VALUE) {
                dwSuccess = 3;
            }
            else {
                dbSize->HighPart = FindFileData.nFileSizeHigh;
                dbSize->LowPart  = FindFileData.nFileSizeLow;
            }
        }
        _finally
        {
            FindClose(hFind);;
        }


        // find disk free size
        //

        if (dwSuccess == ERROR_SUCCESS) {
            if (!GetDiskFreeSpaceExA (pszDbDir,
                (PULARGE_INTEGER)&i64FreeBytesToCaller,
                (PULARGE_INTEGER)&i64TotalBytes,
                (PULARGE_INTEGER)&i64FreeBytes) ) {

                dwSuccess = 4;
            }
            else {
                *freeDiskBytes = i64FreeBytes;
            }
        }
    }
    _finally
    {
        RegCloseKey(hKey);
    }

    return dwSuccess;
}


DWORD GetLogDiskSpaceSizes (PULARGE_INTEGER freeDiskBytes, char *driveLogs)
{
    HKEY            hKey;
    DWORD           dwErr;
    DWORD           dwType;
    DWORD           cbData;
    char            pszLogFilePath[MAX_PATH];
    DWORD           dwSuccess = ERROR_SUCCESS;
    ULARGE_INTEGER  i64FreeBytesToCaller, i64TotalBytes, i64FreeBytes;


    if ( dwErr = RegOpenKeyA(HKEY_LOCAL_MACHINE, DSA_CONFIG_SECTION, &hKey) )
    {
        return dwErr;
    }

    _try
    {
        cbData = sizeof(pszLogFilePath);
        dwErr = RegQueryValueExA(    hKey,
                                    LOGPATH_KEY,
                                    NULL,
                                    &dwType,
                                    (LPBYTE) pszLogFilePath,
                                    &cbData);

        if ( ERROR_SUCCESS != dwErr )
        {
            dwSuccess = dwErr;
        }
        else if ( cbData > sizeof(pszLogFilePath) )
        {
            dwSuccess = 1;
        }
        else
        {
            // find disk free size
            //
            driveLogs[0] = pszLogFilePath[0];
            driveLogs[1] = pszLogFilePath[1];
            driveLogs[2] = '\0';

            if (!GetDiskFreeSpaceExA (pszLogFilePath,
                (PULARGE_INTEGER)&i64FreeBytesToCaller,
                (PULARGE_INTEGER)&i64TotalBytes,
                (PULARGE_INTEGER)&i64FreeBytes) ) {

                dwSuccess = 4;
            }
            else {
                *freeDiskBytes = i64FreeBytes;
            }
        }
    }
    _finally
    {
        RegCloseKey(hKey);
    }

    return dwSuccess;
}

BOOL
WINAPI
SecUpgradeCheckDC(
    HMODULE     ResourceDll,
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context
    )
{
    ULONG       Length = 0;
    WCHAR       *DescriptionString = NULL;
    TCHAR       TextFileName[] = TEXT("compdata\\SecInterop.txt");
    TCHAR       HtmlFileName[] = TEXT("compdata\\SecInterop.htm");
    TCHAR       DefaultDescription[] = TEXT("Windows 95 and Windows NT 4.0 interoperability issues (Read Details!)");

    COMPATIBILITY_ENTRY CompEntry;
    BOOL        bRet = TRUE;
    //
    // initialize variables
    //
    RtlZeroMemory(&CompEntry, sizeof(COMPATIBILITY_ENTRY));

    if (ResourceDll) {

        Length = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        ResourceDll,
                                        SECUPG_DESCRIPTION,
                                        0,
                                        (LPWSTR)&DescriptionString,
                                        0,
                                        NULL
                                        );
        if (DescriptionString) {
            DescriptionString[Length-2] = L'\0';
        }

    }

    //
    // use default messages if read from DLL failed
    //

    if (DescriptionString == NULL) {
        DescriptionString = DefaultDescription;
    }


    //
    // Flag the warning.
    //
    CompEntry.Description   = DescriptionString;
    CompEntry.HtmlName      = HtmlFileName;
    CompEntry.TextName      = TextFileName;
    CompEntry.RegKeyName    = NULL;
    CompEntry.RegValName    = NULL;
    CompEntry.RegValDataSize= 0;
    CompEntry.RegValData    = NULL;
    CompEntry.SaveValue     = NULL;
    CompEntry.Flags         = 0;

    bRet = CompatibilityCallback(&CompEntry, Context);


    if (DescriptionString != NULL && DescriptionString != DefaultDescription) {
        LocalFree(DescriptionString);
    }


    return bRet;

}


BOOL
WINAPI
SecUpgradeCompatibilityCheck(
    PCOMPAIBILITYCALLBACK CompatibilityCallback,
    LPVOID Context)
{

    OSVERSIONINFOEXW    osvi;
    NT_PRODUCT_TYPE     Type;
    HMODULE             ResourceDll;
    BOOL                bOsVersionInfoEx = FALSE;
    BOOL                bDomainController = FALSE;
    BOOL                bRet = TRUE;



    //
    // get the string from resource table.
    //
    ResourceDll = (HMODULE) LoadLibrary( L"NTDSUPG.DLL" );


    //
    // get OS version and product type (try osversioninfoEX first)
    //
    memset(&osvi, 0, sizeof(OSVERSIONINFOEXW));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);

    if ( !(bOsVersionInfoEx = GetVersionExW((OSVERSIONINFOW *) &osvi)) )
    {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.
        // OSVERSIONINFOEX only works on NT4.0 SP6 and later

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
        GetVersionExW( (OSVERSIONINFOW *)&osvi );
    }


    //
    // Windows NT, Windows 2000 or Whistler
    //
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
    {
        if ( bOsVersionInfoEx )
        {
            if (VER_NT_DOMAIN_CONTROLLER == osvi.wProductType) {
                bDomainController = TRUE;
            }
        }
        else
        {
            if ( !RtlGetNtProductType(&Type) ) {
                // can't retrieve ProductType, default it to Domain Controller
                bDomainController = TRUE;
            }
            else if (NtProductLanManNt == Type) {
                bDomainController = TRUE;
            }
        }

        //
        // Report warning only on DC upgrades
        //
        if (bDomainController){

            bRet = SecUpgradeCheckDC(ResourceDll,
                                     CompatibilityCallback,
                                     Context);

        }

    }

    if (NULL != ResourceDll)
    {
        FreeLibrary(ResourceDll);
    }

    return bRet;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\alias.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    alias.c

Abstract:

    This file contains services related to the SAM "alias" object.


Author:

    Chad Schwitters (chads) 15-Jan-1992

Environment:

    User Mode - Win32

Revision History:

    7-1-96  - MURLIS - Modified to Use DS.


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



#include <samsrvp.h>
#include <msaudite.h>
#include <dslayer.h>
#include <dsmember.h>
#include <ridmgr.h>
#include <samtrace.h>
#include "validate.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampAddAccountToAlias(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Attribute,
    IN PSID AccountSid,
    IN DSNAME * AccountDn OPTIONAL
    );

NTSTATUS
SampRemoveAccountFromAlias(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Attribute,
    IN PSID AccountSid,
    IN DSNAME * AccountDn OPTIONAL
    );

NTSTATUS
SampAddAliasToAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    );

NTSTATUS
SampRemoveAliasFromAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    );

NTSTATUS
SampRemoveAliasFromAllAccounts(
    IN PSAMP_OBJECT AliasContext
    );

NTSTATUS
SampDeleteAliasKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampRetrieveAliasMembers(
    IN PSAMP_OBJECT AliasContext,
    IN PULONG MemberCount,
    IN PSID **Members OPTIONAL
    );

NTSTATUS
SampDeleteAliasMembershipKeysForAccount(
    IN PSID AccountSid
    );

NTSTATUS
SampAdjustAliasDomainsCount(
    IN BOOLEAN Increment
    );

NTSTATUS
SampValidateNewAliasMember(
    IN PSAMP_OBJECT AccountContext,
    IN PSID MemberId,
    IN DSNAME * MemberName OPTIONAL
    );

NTSTATUS
SampAddMemberToAliasActual(
    IN  PSAMP_OBJECT    AccountContext,
    IN  ULONG           Attribute,
    IN  PSID            MemberId,
    IN  DSNAME          *MemberName OPTIONAL
    );

NTSTATUS
SampRemoveMemberFromAliasActual(
    IN  PSAMP_OBJECT    AccountContext,
    IN  ULONG           Attribute,
    IN  PSID            MemberId,
    IN  DSNAME          *MemberName OPTIONAL
    );

NTSTATUS
SampGetDomainSidListForSam(
    PULONG pcDomainSids,
    PSID   **rgDomainSids,
    PULONG pcEnterpriseSids,
    PSID   **rgEnterpriseSids
   );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exposed RPC'able Services                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SamrOpenAlias(
    IN SAM_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG AliasId,
    OUT PSAM_HANDLE AliasHandle
    )

/*++

Routine Description:

    This API opens an existing Alias object.  The Alias is specified by
    a ID value that is relative to the SID of the domain.  The operations
    that will be performed on the Alias must be declared at this time.

    This call returns a handle to the newly opened Alias that may be used
    for successive operations on the Alias.  This handle may be closed
    with the SamCloseHandle API.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types are
        desired to the alias.

    AliasId - Specifies the relative ID value of the Alias to be opened.

    AliasHandle - Receives a handle referencing the newly opened Alias.
        This handle will be required in successive calls to operate on
        the Alias.

Return Values:

    STATUS_SUCCESS - The Alias was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_NO_SUCH_ALIAS - The specified Alias does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.


--*/
{
    NTSTATUS            NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrOpenAlias");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenAlias
                   );

    NtStatus = SampOpenAccount(
                   SampAliasObjectType,
                   DomainHandle,
                   DesiredAccess,
                   AliasId,
                   FALSE,
                   AliasHandle
                   );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenAlias
                   );

    return(NtStatus);
}



NTSTATUS
SamrQueryInformationAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    OUT PSAMPR_ALIAS_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    This API retrieves information on the alias specified.



Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ----------------------

        AliasGeneralInformation         ALIAS_READ_INFORMATION
        AliasNameInformation            ALIAS_READ_INFORMATION
        AliasAdminInformation           ALIAS_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer and any memory pointed to through this buffer must be
        freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    ULONG                   i;
    BOOLEAN                 fLockAcquired = FALSE;


    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                      ||
    //                                      vv
    PVOID                   AllocatedBuffer[10];
    ULONG                   AllocatedBufferCount = 0;
    DECLARE_CLIENT_REVISION(AliasHandle);

    SAMTRACE_EX("SamrQueryInformationAlias");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationAlias
                   );


    #define RegisterBuffer(Buffer)                                      \
        {                                                               \
            if ((Buffer) != NULL) {                                     \
                                                                        \
                ASSERT(AllocatedBufferCount <                           \
                       sizeof(AllocatedBuffer) / sizeof(*AllocatedBuffer)); \
                                                                        \
                AllocatedBuffer[AllocatedBufferCount++] = (Buffer);     \
            }                                                           \
        }

    #define AllocateBuffer(NewBuffer, Size)                             \
        {                                                               \
            (NewBuffer) = MIDL_user_allocate(Size);                     \
            RegisterBuffer(NewBuffer);                                  \
        }                                                               \



    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL)&&(*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Set the desired access based upon the Info class
    //

    switch (AliasInformationClass) {

    case AliasGeneralInformation:
    case AliasNameInformation:
    case AliasAdminCommentInformation:
    case AliasReplicationInformation:

        DesiredAccess = ALIAS_READ_INFORMATION;
        break;

    default:
        (*Buffer) = NULL;
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;


    } // end_switch



    //
    // Allocate the info structure
    //

    AllocateBuffer( *Buffer, sizeof(SAMPR_ALIAS_INFO_BUFFER) );
    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Acquire the read lock if required
    //

    AccountContext = (PSAMP_OBJECT)AliasHandle;
    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES,
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   AccountContext,
                   DesiredAccess,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        //
        // case on the type information requested
        //

        switch (AliasInformationClass) {

        case AliasGeneralInformation:
        case AliasReplicationInformation:


            if (AliasGeneralInformation==AliasInformationClass)
            {

                //
                // Get the member count
                //

                NtStatus = SampRetrieveAliasMembers(
                               AccountContext,
                               &(*Buffer)->General.MemberCount,
                               NULL                                 // Only need members
                               );
            }
            else
            {
                (*Buffer)->General.MemberCount=0;
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_ALIAS_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->General.Name)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->General.Name.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_ALIAS_ADMIN_COMMENT,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->General.AdminComment)
                                   );

                    if (NT_SUCCESS(NtStatus)) {
                        RegisterBuffer((*Buffer)->General.AdminComment.Buffer);
                    }
                }
            }


            break;


        case AliasNameInformation:

            //
            // Get copies of the strings we must retrieve from
            // the registry.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_NAME,
                           TRUE,    // Make copy
                           (PUNICODE_STRING)&((*Buffer)->Name.Name)
                           );

            if (NT_SUCCESS(NtStatus)) {
                RegisterBuffer((*Buffer)->Name.Name.Buffer);
            }

            break;


        case AliasAdminCommentInformation:

            //
            // Get copies of the strings we must retrieve from
            // the registry.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_ADMIN_COMMENT,
                           TRUE,    // Make copy
                           (PUNICODE_STRING)&((*Buffer)->AdminComment.AdminComment)
                           );

            if (NT_SUCCESS(NtStatus)) {
                RegisterBuffer((*Buffer)->AdminComment.AdminComment.Buffer);
            }


            break;

        }   // end_switch


        //
        // De-reference the object, discard any changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }

        (*Buffer) = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationAlias
                   );

    return(NtStatus);
}



NTSTATUS
SamrSetInformationAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ALIAS_INFORMATION_CLASS AliasInformationClass,
    IN PSAMPR_ALIAS_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    This API allows the caller to modify alias information.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    AliasInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        AliasGeneralInformation         (can't write)

        AliasNameInformation            ALIAS_WRITE_ACCOUNT
        AliasAdminCommentInformation    ALIAS_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_ALIAS - The alias specified is unknown.

    STATUS_SPECIAL_ALIAS - The alias specified is a special alias and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                TmpStatus;
    NTSTATUS                IgnoreStatus;

    PSAMP_OBJECT            AccountContext;

    SAMP_OBJECT_TYPE        FoundType;

    ACCESS_MASK             DesiredAccess;

    UNICODE_STRING          OldAccountName,
                            NewAccountName;

    ULONG                   AliasRid = 0;

    BOOLEAN                 Modified = FALSE,
                            RemoveAccountNameFromTable = FALSE,
                            AccountNameChanged = FALSE;
    DECLARE_CLIENT_REVISION(AliasHandle);

    SAMTRACE_EX("SamrSetInformationAlias");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationAlias
                   );


    RtlInitUnicodeString(&OldAccountName, NULL);
    RtlInitUnicodeString(&NewAccountName, NULL);

    //
    // Set the desired access based upon the Info class
    //

    switch (AliasInformationClass) {

    case AliasNameInformation:
    case AliasAdminCommentInformation:

        DesiredAccess = ALIAS_WRITE_ACCOUNT;
        break;


    case AliasGeneralInformation:
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        goto  Error;

    } // end_switch



    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)AliasHandle;
    NtStatus = SampLookupContext(
                   AccountContext,
                   DesiredAccess,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );


    if( NT_SUCCESS( NtStatus ) ) {

        //
        // Check input parameters
        //
        NtStatus = SampValidateAliasInfoBuffer(
                        Buffer,
                        AliasInformationClass,
                        AccountContext->TrustedClient
                        );
    }


    if (NT_SUCCESS(NtStatus)) {


        //
        // case on the type information requested
        //

        switch (AliasInformationClass) {

        case AliasNameInformation:

            NtStatus = SampChangeAliasAccountName(
                            AccountContext,
                            (PUNICODE_STRING)&(Buffer->Name.Name),
                            &OldAccountName
                            );

            if (!NT_SUCCESS(NtStatus)) {
                OldAccountName.Buffer = NULL;
            }

            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable
            // to remove the name from the table.
            //
            RemoveAccountNameFromTable =
                    AccountContext->RemoveAccountNameFromTable;

            //
            // Reset to FALSE
            //
            AccountContext->RemoveAccountNameFromTable = FALSE;

            //
            // Don't delete the old account name yet; we'll still need
            // to pass it to Netlogon below.
            //

            AccountNameChanged = TRUE;

            break;


        case AliasAdminCommentInformation:

            NtStatus = SampSetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_ALIAS_ADMIN_COMMENT,
                           (PUNICODE_STRING)&(Buffer->AdminComment.AdminComment)
                           );

            break;


        } // end_switch

        //
        // Go fetch AccountName
        // Do this before we dereference the context
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_ALIAS_NAME,
                               TRUE,    // Make copy
                               &NewAccountName
                               );
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Save object RID before dereferencing context.
            // RID is used in SampNotifyNetlogonOfDelta() call.
            //

            AliasRid = AccountContext->TypeBody.Alias.Rid;

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }

    } //end_if

    //
    // Commit the transaction and notify netlogon of any changes
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // Generate audit if necessary, after Commit() succeeded.
        //

        if ((NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(AccountContext->DomainIndex))) {

            // audit account name change
            if (AccountNameChanged)
            {
                SampAuditAccountNameChange(AccountContext,
                                           (PUNICODE_STRING)&(Buffer->Name.Name),
                                           &OldAccountName
                                           );
            }

            //
            // Generate a general change audit in the registry mode case.
            // In DS mode, the same audit is handled via audit notifications
            // and is processed in SampNotifyAuditChange()
            //
            SampAuditGroupChange(
                AccountContext->DomainIndex,
                AccountContext,
                (PVOID)&AliasInformationClass,
                TRUE,  // Alias not group
                &NewAccountName,
                &(AccountContext->TypeBody.Alias.Rid),
                (GROUP_TYPE_SECURITY_ENABLED |
                 GROUP_TYPE_RESOURCE_GROUP),
                NULL,
                FALSE   // Group change
                );
        }

        if (( NT_SUCCESS(NtStatus) ) &&
            (AccountContext->TypeBody.Alias.SecurityEnabled)){

            ASSERT((0 != AliasRid) && "AliasRid not been initialized\n");

            if ( AliasInformationClass == AliasNameInformation ) {

                SampNotifyNetlogonOfDelta(
                    SecurityDbRename,
                    SecurityDbObjectSamAlias,
                    AliasRid,
                    &OldAccountName,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );

            } else {

                SampNotifyNetlogonOfDelta(
                    SecurityDbChange,
                    SecurityDbObjectSamAlias,
                    AliasRid,
                    NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );
            }
        }
    }


    //
    // Free up our old account name if we have one
    //

    SampFreeUnicodeString( &OldAccountName );
    SampFreeUnicodeString( &NewAccountName );

    //
    // Remove the New Account Name from the Global
    // SAM Account Name Table
    //
    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)&(Buffer->Name.Name),
                            SampAliasObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Now release the write lock and return, propogating any errors.
    //

    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));


    if (NT_SUCCESS(NtStatus)) {
        NtStatus = TmpStatus;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationAlias
                   );

    return(NtStatus);

}



NTSTATUS
SamrDeleteAlias(
    IN SAM_HANDLE *AliasHandle
    )

/*++

Routine Description:

    This API deletes an Alias from the account database.  The Alias does
    not have to be empty.

    Note that following this call, the AliasHandle is no longer valid.



Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.



--*/
{
    UNICODE_STRING          AliasName;
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT) (*AliasHandle);
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_OBJECT_TYPE        FoundType;
    BOOLEAN                 fLockAcquired = FALSE;
    ULONG                   AliasRid,
                            DomainIndex;
    DECLARE_CLIENT_REVISION(*AliasHandle);


    SAMTRACE_EX("SamrDeleteAlias");


    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidDeleteAlias
                   );


    //
    // Grab the lock
    //

    NtStatus = SampMaybeAcquireWriteLock(AccountContext, &fLockAcquired);
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    NtStatus = SampLookupContext(
                   AccountContext,
                   DELETE,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );



    if (NT_SUCCESS(NtStatus)) {

        AliasRid = AccountContext->TypeBody.Alias.Rid;

        //
        // Get a pointer to the domain this object is in.
        // This is used for auditing.
        //

        DomainIndex = AccountContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // Make sure the account is one that can be deleted.
        // Can't be a built-in account, unless caller is trusted.
        //

        if ( !AccountContext->TrustedClient ) {

            NtStatus = SampIsAccountBuiltIn( AliasRid );
        }

        if (NT_SUCCESS(NtStatus)) {


            //
            // Remove this alias from every account's alias-membership list
            //

            NtStatus = SampRemoveAliasFromAllAccounts(AccountContext);


            if (NT_SUCCESS(NtStatus)) {

                //
                // First get and save the account name for
                // I_NetNotifyLogonOfDelta.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_ALIAS_NAME,
                               TRUE,    // Make copy
                               &AliasName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // This must be done before we invalidate contexts, because our
                    // own handle to the alias gets closed as well.
                    //

                    if (IsDsObject(AccountContext))
                    {
                        NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                      0             // Delete the object itself
                                                      );

                        //
                        // In Windows 2000 (NT5), an object has children cannot be
                        // deleted till its children are deleted first. Thus for
                        // Net API compatibility, we have to change the
                        // delete behavior from a delete object to delete tree.
                        //

                        if ((!AccountContext->LoopbackClient) &&
                            (STATUS_DS_CANT_ON_NON_LEAF == NtStatus)
                           )
                        {
                            //
                            // We only checked the right and access control for
                            // deleting the object itself, not check the right to
                            // delete all the children underneath, so turn off fDSA
                            // here, let core DS do the rest of check.
                            //

                            SampSetDsa(FALSE);

                            NtStatus = SampDsDeleteObject(AccountContext->ObjectNameInDs,
                                                          SAM_DELETE_TREE
                                                          );
                        }

                        if (NT_SUCCESS(NtStatus) && (!IsDsObject(AccountContext)) )
                        {
                            //
                            // Decrement the group count ONLY in Registry case
                            //

                            NtStatus = SampAdjustAccountCount(SampAliasObjectType, FALSE);
                        }

                    }
                    else
                    {
                        NtStatus = SampDeleteAliasKeys( AccountContext );
                    }

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // We must invalidate any open contexts to this alias
                        // This will close all handles to the alias's keys.
                        // THIS IS AN IRREVERSIBLE PROCESS.
                        //

                        SampInvalidateObjectContexts( AccountContext, AliasRid );

                        //
                        // Commit the whole mess
                        //

                        NtStatus = SampCommitAndRetainWriteLock();

                        if ( NT_SUCCESS( NtStatus ) ) {

                            //
                            // Update the Alias Information Cache in Registry Mode
                            //

                            if (!IsDsObject(AccountContext))
                            {
                                IgnoreStatus = SampAlDeleteAlias( AliasHandle );
                            }

                            //
                            // Audit the deletion before we free the write lock
                            // so that we have access to the context block.
                            //

                            //
                            // N.B. Deletion audits in the DS are performed in
                            // the notification routine on transaction commit.
                            //
                            if (SampDoAccountAuditing(DomainIndex) &&
                                (!IsDsObject(AccountContext)) &&
                                NT_SUCCESS(NtStatus) ) {

                                SampAuditGroupDelete(DomainIndex,
                                                     &AliasName,
                                                     &AliasRid,
                                                     GROUP_TYPE_RESOURCE_GROUP |
                                                     GROUP_TYPE_SECURITY_ENABLED);

                            }

                            //
                            // Notify netlogon of the change
                            //

                            if (AccountContext->TypeBody.Alias.SecurityEnabled)
                            {
                                SampNotifyNetlogonOfDelta(
                                    SecurityDbDelete,
                                    SecurityDbObjectSamAlias,
                                    AliasRid,
                                    &AliasName,
                                    (DWORD) FALSE,  // Replicate immediately
                                    NULL            // Delta data
                                    );
                            }

                            //
                            // Do delete auditing
                            //

                            if (NT_SUCCESS(NtStatus)) {

                                SampDeleteObjectAuditAlarm(AccountContext);
                            }


                        }
                    }

                    SampFreeUnicodeString( &AliasName );
                }
            }
        }



        //
        // De-reference the object, discard any changes
        //

        TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));


        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // If we actually deleted the alias, then delete the context
            // and let RPC know that the handle is invalid.
            //

            SampDeleteContext( AccountContext );

            (*AliasHandle) = NULL;
        }

    } //end_if

    //
    // Free the lock -
    //
    // Everything has already been committed above, so we must indicate
    // no additional changes have taken place.
    //

    TmpStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );

    if (NtStatus == STATUS_SUCCESS) {
        NtStatus = TmpStatus;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidDeleteAlias
                   );

    return(NtStatus);

}


NTSTATUS
SamrAddMemberToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN PRPC_SID MemberId
    )

/*++

Routine Description:

    This API adds a member to an alias.  Note that this API requires the
    ALIAS_ADD_MEMBER access type for the alias.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    MemberId - SID of the member to add.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_ALIAS - The member already belongs to the alias.

    STATUS_INVALID_MEMBER - The member has the wrong account type.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext = (PSAMP_OBJECT)(AliasHandle);
    SAMP_OBJECT_TYPE        FoundType;
    DSNAME                  **MemberName=NULL;
    ULONG                   ObjectRid = 0;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrAddMemberToAlias");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidAddMemberToAlias
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );



    //
    // Validate the Sid
    //
    if (!SampValidateRpcSID(MemberId))
    {
        //
        // the sid doesn't seem all right
        //
        NtStatus = STATUS_INVALID_SID;
        goto Error;
    }


    //
    // Resolve Sids if necessary. This call can also reference the
    // G.C in the DS case to resolve the Sid to a DS Name. This is
    // a No Op in the registry case. In case the G.C is referenced
    // a thread state will be left behind by this call. This thread
    // state will contain the list of validated names. For the foriegn
    // security principal case an FPO object might be added as a
    // result of this call.
    //

    NtStatus = SampDsResolveSids(
                    &MemberId,
                    1,
                    RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL|
                    RESOLVE_SIDS_VALIDATE_AGAINST_GC,
                    &MemberName
                    );

    if (NT_SUCCESS(NtStatus))
    {

        //
        // Grab the lock
        //

        NtStatus = SampAcquireWriteLock();
        if (!NT_SUCCESS(NtStatus)) {

            //
            // Resolve Sids will  leave a thread state in the
            // DS in case it needs to go to the G.C.
            // Need to make sure we close it.
            //

           goto Error;
        }


        //
        // Validate type of, and access to object.
        //

        NtStatus = SampLookupContext(
                       AccountContext,
                       ALIAS_ADD_MEMBER,
                       SampAliasObjectType,           // ExpectedType
                       &FoundType
                       );

        // If this is a (B)DC, then allow new members to be added to an alias.

        SampDiagPrint(INFORM,
                  ("SAMSS: AddMemberToAlias SampLookupContext status = 0x%lx\n",
                   NtStatus));


        if (NT_SUCCESS(NtStatus))
        {
            if (IsDsObject(AccountContext))
            {

                //
                // If it is a DS object then  verify whether the member was
                // resolved to a DS Name, as resolve Sids does not check for this
                //

                if ((NULL==MemberName) || (NULL==*MemberName))
                {
                    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                NtStatus =  SampAddMemberToAliasActual(
                                AccountContext,
                                SAMP_ALIAS_MEMBERS,
                                MemberId,
                                MemberName?*MemberName:NULL
                                );



            }

            //
            // Dereference the account context
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Save object RID before dereferencing context.
                // RID is used in SampNotifyNetlogonOfDelta() call.
                //

                ObjectRid = AccountContext->TypeBody.Alias.Rid;

                //
                // De-reference the object, write out any change to current xaction.
                //

                NtStatus = SampDeReferenceContext( AccountContext, TRUE );

            } else {

                //
                // De-reference the object, ignore changes
                //

                TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
                ASSERT(NT_SUCCESS(TmpStatus));
            }


            if (NT_SUCCESS(NtStatus)) {

                //
                // Commit the whole mess
                //

                NtStatus = SampCommitAndRetainWriteLock();

                if ( NT_SUCCESS( NtStatus ) ) {

                    SAM_DELTA_DATA DeltaData;

                    //
                    // Update the Alias Information Cache in Registry Mode
                    //

                    SAMPR_PSID_ARRAY MemberSids;
                    MemberSids.Count = 1;
                    MemberSids.Sids = (PSAMPR_SID_INFORMATION) &MemberId;

                    if (!IsDsObject(AccountContext))
                    {
                        IgnoreStatus = SampAlAddMembersToAlias(
                                           (SAMPR_HANDLE) AccountContext,
                                           0,
                                           &MemberSids
                                           );
                    }


                    //
                    // Fill in id of member being added
                    //

                    DeltaData.AliasMemberId.MemberSid = MemberId;

                    if (AccountContext->TypeBody.Alias.SecurityEnabled)
                    {
                        ASSERT(ObjectRid && "ObjectRid not initialized\n");

                        SampNotifyNetlogonOfDelta(
                            SecurityDbChangeMemberAdd,
                            SecurityDbObjectSamAlias,
                            ObjectRid,
                            (PUNICODE_STRING) NULL,
                            (DWORD) FALSE,  // Replicate immediately
                            &DeltaData
                            );
                    }
                }

            }

        }

        //
        // Release the Lock
        //

        TmpStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));

    }

Error:

    //
    // Free any memory associated with resolved Sids
    //

    if (NULL!=MemberName)
    {
        if (NULL!=*MemberName)
        {
            MIDL_user_free(*MemberName);
        }

        MIDL_user_free(MemberName);
    }

    if (SampUseDsData)
        SampMaybeEndDsTransaction(TransactionCommit);


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidAddMemberToAlias
                   );

    return(NtStatus);
}




NTSTATUS
SamrAddMultipleMembersToAlias(
    IN    SAMPR_HANDLE            AliasHandle,
    IN    PSAMPR_PSID_ARRAY       MembersBuffer
    )

/*++

Routine Description:

    This api adds multiple members to an alias.

    NOTE:  For now, this routine takes a brute force approach.
           I tried to do it in a better (more efficient) manner,
           but kept running into problems.  Finally, when I ran
           into problems in the way SAM uses RXACT, I gave up
           and did this brute force approach.

Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MembersBuffer - Contains a count of SIDs to be added to the
        alias and a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members to
        be added to the Alias.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now members of the alias.  However, some of
        the members may already have been members of the alias (this is
        NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_MEMBER - The member has the wrong account type.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS
        NtStatus;

    LONG
        MemberCount,
        i;

    PSID
        *MemberId;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrAddMultipleMembersToAlias");

    MemberCount = (LONG)MembersBuffer->Count;
    MemberId    = (PSID *)MembersBuffer->Sids;

    //
    // Set completion status in case there are no members
    //

    NtStatus = STATUS_SUCCESS;

    //
    // Validate Parameters
    //
    if( !SampValidateSIDArray( MembersBuffer ) ) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return (NtStatus);
    }

    //
    // Loop through the SIDs, adding them to the alias.
    // Ignore any status value indicating the member is already
    // a member.  Other errors, however, will cause us to abort.
    //

    for (i=0; i<MemberCount; i++) {

        NtStatus = SamrAddMemberToAlias( AliasHandle, MemberId[i] );

        if (NtStatus == STATUS_MEMBER_IN_ALIAS) {
            NtStatus = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(NtStatus)) {
            break; //for loop
        }

    } //end_for

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}


NTSTATUS
SamrRemoveMemberFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN PRPC_SID MemberId
    )

/*++

Routine Description:

    This API removes a member from an alias.  Note that this API requires the
    ALIAS_REMOVE_MEMBER access type for the alias.


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    MemberId - SID of the member to remove.

Return Value:


    ????


--*/
{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    DSNAME                  **MemberName = NULL;
    ULONG                   ObjectRid = 0;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrRemoveMemberFromAlias");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidRemoveMemberFromAlias
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Validate the Sid
    //

    if (!SampValidateRpcSID(MemberId))
    {
        // The Sid doesn't have correct structure.
        NtStatus = STATUS_INVALID_SID;
        goto Error;
    }



    //
    // Resolve Sids if necessary. This call can also reference the
    // G.C in the DS case to resolve the Sid to a DS Name. This is
    // a No Op in the registry case. In case the G.C is referenced
    // a thread state will be left behind by this call. This thread
    // state will contain the list of validated names.
    //

    NtStatus = SampDsResolveSids(
                    &MemberId,
                    1,
                    RESOLVE_SIDS_VALIDATE_AGAINST_GC,
                    &MemberName
                    );
    if (NT_SUCCESS(NtStatus))
    {
        //
        // Grab the lock
        //

        NtStatus = SampAcquireWriteLock();
        if (!NT_SUCCESS(NtStatus)) {

            //
            // Resolve Sids will  leave a thread state in the
            // DS in case it needs to go to the G.C.
            // Need to make sure we close it.
            //

           goto Error;
        }

        //
        // Validate type of, and access to object.
        //

        AccountContext = (PSAMP_OBJECT)(AliasHandle);
        NtStatus = SampLookupContext(
                       AccountContext,
                       ALIAS_REMOVE_MEMBER,
                       SampAliasObjectType,           // ExpectedType
                       &FoundType
                       );
        // If this is a (B)DC, then allow members to be removed from an alias.

        SampDiagPrint(INFORM,
                      ("SAMSS: AddMemberToAlias SampLookupContext status = 0x%lx\n",
                       NtStatus));



        //
        // If it is a DS object then  verify whether the member was
        // resolved to a DS Name, as resolve Sids does not check for this
        //

        if (NT_SUCCESS(NtStatus))
        {
            if (IsDsObject(AccountContext))
            {
                if ((NULL==MemberName) || (NULL==*MemberName))
                {
                    NtStatus = STATUS_OBJECT_NAME_NOT_FOUND;
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Call the actual worker routine
                //

                NtStatus = SampRemoveMemberFromAliasActual(
                                AccountContext,
                                SAMP_ALIAS_MEMBERS,
                                MemberId,
                                MemberName?*MemberName:NULL
                                );


            }

            //
            // Dereference the account context
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Save object RID before dereferencing context.
                // RID is used in SampNotifyNetlogonOfDelta() call.
                //

                ObjectRid = AccountContext->TypeBody.Alias.Rid;

                //
                // De-reference the object, write out any change to current xaction.
                //

                NtStatus = SampDeReferenceContext( AccountContext, TRUE );

            } else {

                //
                // De-reference the object, ignore changes
                //

                TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
                ASSERT(NT_SUCCESS(TmpStatus));
            }


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampCommitAndRetainWriteLock();

                if ( NT_SUCCESS( NtStatus ) ) {

                    SAM_DELTA_DATA DeltaData;

                    //
                    // Update the Alias Information Cache in Registry Mode
                    //

                    SAMPR_PSID_ARRAY MemberSids;
                    MemberSids.Count = 1;
                    MemberSids.Sids = (PSAMPR_SID_INFORMATION) &MemberId;

                    if (!IsDsObject(AccountContext))
                    {
                        IgnoreStatus = SampAlRemoveMembersFromAlias(
                                           (SAMPR_HANDLE) AccountContext,
                                           0,
                                           &MemberSids
                                           );
                    }


                    //
                    // Fill in id of member being deleted
                    //

                    DeltaData.AliasMemberId.MemberSid = MemberId;

                    if (AccountContext->TypeBody.Alias.SecurityEnabled)
                    {
                        ASSERT(ObjectRid && "ObjectRid not initialized\n");

                        SampNotifyNetlogonOfDelta(
                            SecurityDbChangeMemberDel,
                            SecurityDbObjectSamAlias,
                            ObjectRid,
                            (PUNICODE_STRING) NULL,
                            (DWORD) FALSE,      // Replicate immediately
                            &DeltaData
                            );
                    }

                }
            }

        }

        //
        //  Release the Lock
        //

        TmpStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(TmpStatus));


    }

Error:

    //
    // Free any memory associated with resolved Sids
    //

    if (NULL!=MemberName)
    {
        if (NULL!=*MemberName)
        {
            MIDL_user_free(*MemberName);
        }

        MIDL_user_free(MemberName);
    }

    //
    // Resolve Sids will  leave a thread state in the
    // DS in case it needs to go to the G.C.
    // Need to make sure we close it.
    //

    if (SampUseDsData)
        SampMaybeEndDsTransaction(TransactionCommit);

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromAlias
                   );

    return(NtStatus);

}


NTSTATUS
SamrRemoveMultipleMembersFromAlias(
    IN    SAMPR_HANDLE            AliasHandle,
    IN    PSAMPR_PSID_ARRAY       MembersBuffer
    )

/*++

Routine Description:

    This API removes members from an alias.  Note that this API requires
    the ALIAS_REMOVE_MEMBER access type for the alias.

    NOTE:  This api currently uses a brute-force approach to adding
           members to the alias.  This is because of problems
           encountered when trying to do "the right thing".


Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    MembersBuffer - Contains a count of SIDs to be added to the
        alias and a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members to
        be added to the Alias.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.  All of the
        listed members are now members of the alias.  However, some of
        the members may already have been members of the alias (this is
        NOT an error or warning condition).

    STATUS_ACCESS_DENIED - Caller does not have the object open for
        the required access.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_SID - The member sid is corrupted.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.


--*/
{

    NTSTATUS
        NtStatus;

    LONG
        MemberCount,
        i;

    PSID
        *MemberId;
    DECLARE_CLIENT_REVISION(AliasHandle);


    SAMTRACE_EX("SamrRemoveMultipleMembersFromAlias");

    MemberCount = (LONG)MembersBuffer->Count;
    MemberId    = (PSID *)MembersBuffer->Sids;


    //
    // Set completion status in case there are no members
    //

    NtStatus = STATUS_SUCCESS;

    //
    // Validate Parameters
    //
    if( !SampValidateSIDArray( MembersBuffer ) ) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return (NtStatus);
    }

    //
    // Loop through the SIDs, adding them to the alias.
    // Ignore any status value indicating the member is already
    // a member.  Other errors, however, will cause us to abort.
    //

    for (i=0; i<MemberCount; i++) {

        NtStatus = SamrRemoveMemberFromAlias( AliasHandle, MemberId[i] );

        if (NtStatus == STATUS_MEMBER_NOT_IN_ALIAS) {
            NtStatus = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(NtStatus)) {
            break; //for loop
        }

    } //end_for

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);

}


NTSTATUS
SamrGetMembersInAlias(
    IN SAM_HANDLE AliasHandle,
    OUT PSAMPR_PSID_ARRAY_OUT GetMembersBuffer
    )

/*++

Routine Description:

    This API lists all members in an Alias.  This API requires
    ALIAS_LIST_MEMBERS access to the Alias.

    NOTE:  This function does not use the Alias cache.


Parameters:

    AliasHandle - The handle of an opened Alias to operate on.

    MemberIds - Receives a pointer to a buffer containing an array of
        pointers to SIDs.  These SIDs are the SIDs of the members of the
        Alias.  When this information is no longer needed, this buffer
        must be freed using SamFreeMemory().

    MemberCount - number of members in the Alias (and, thus, the number
        of relative IDs returned).

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there are
        no additional entries.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    BOOLEAN                 fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(AliasHandle);

    SAMTRACE_EX("SamrGetMembersInAlias");

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetMembersInAlias
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (GetMembersBuffer != NULL);

    //
    // Grab the lock
    //

    AccountContext = (PSAMP_OBJECT)AliasHandle;

    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES,
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   AccountContext,
                   ALIAS_LIST_MEMBERS,
                   SampAliasObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampRetrieveAliasMembers(
                       AccountContext,
                       &(GetMembersBuffer->Count),
                       (PSID **)&(GetMembersBuffer->Sids)
                       );

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    //
    // Tidy up on failure
    //

    if (!NT_SUCCESS(NtStatus)){

        GetMembersBuffer->Count = 0;
        GetMembersBuffer->Sids = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI Event Trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetMembersInAlias
                   );

    return(NtStatus);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal Services Available For Use in Other SAM Modules                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN PDSNAME AccountDsName OPTIONAL,
    IN BOOLEAN CheckAccess,
    IN OPTIONAL SAMPR_HANDLE DomainHandle,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    )

/*++

Routine Description:

    This routine removes the specified account from the member list of all
    aliases in this domain.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.

    This routine is used while deleting a user or a group and hence should
    never be called on a DS domain. ( The DS will maintain the cross consi-
    stency when a user or group is deleted ).



Arguments:

    AccountSid - The SID of the account being Removed.

    AccountDsName -- Optional Parameter specifying the DS Name of the
                Account. This is used in the DS Case.

    CheckAccess - if TRUE, this routine will make sure that the caller
        is allowed REMOVE_ALIAS_MEMBER access to this alias.  If FALSE,
        the caller is already known to have proper access.

    DomainHandle - if CheckAccess is TRUE, this handle must be provided
        to allow access to be checked.  This Handle is also required in
        order to specify wether the Domain is in the DS or registry.

    MembershipCount - if CheckAccess is TRUE, this pointer must be
        provided to receive the number of aliases the account was
        deleted from.

    Membership - if CheckAccess is TRUE, this pointer must be provided
        to point to a list of aliases the account was removed from.  The
        caller must free this list with MIDL_user_free().

Return Value:


    STATUS_SUCCESS - The user has been Removed from all aliases.

--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          DomainKeyName, AccountKeyName;
    HANDLE                  TempHandle, AliasHandle;
    ULONG                   LocalMembershipCount;
    PULONG                  LocalMembership;
    ULONG                   KeyValueLength;
    ULONG                   i;
    PSAMP_OBJECT            DomainContext = (PSAMP_OBJECT)DomainHandle;

    SAMTRACE("SampRemoveAccountFromAllAliases");



    //
    // Need to do Different things for the Ds and Registry cases
    // The way this routine will be called is
    //   1. Either Deleting a Group or User in the Registry Case
    //   2. Or Somebody made a SamrRemoveAccountFromForignDomain call
    //   on us. This is done by the Net API to while deleting a user or
    //   group, to remove their memberships from the aliases in the builtin
    //   domain.
    //
    // In the DS case neither code path have a need to call this function and
    // they do not !!! This is because the Link Table autmotaically maintains
    // Group membership-Reverse Membership Consistency.
    //

    // Assert that nobody calls this in the DS case
    ASSERT(FALSE==SampUseDsData);


    if ((DomainHandle!=NULL) && (IsDsObject(DomainContext)))
    {
        //
        // The Code inside this If Statement will Correctly execute the operations
        // specified by this call in the DS case. Currently it is never called
        // however.
        //
        PSID DomainSid = NULL;
        ULONG cDsNames;
        PDSNAME  *rpDsNames;

        ASSERT(ARGUMENT_PRESENT(AccountDsName));

        //
        // Somebody made a SamrRemoveAccountFromForiegn Domain call.
        //

        if ( CheckAccess ) {
            // In case there is an error, these should be set
            // accordingly
            ASSERT(Membership);
            ASSERT(MembershipCount);
            *Membership = NULL;
            *MembershipCount = 0;
        }

        //
        // Get the reverse membership list. Limit to current domain.
        // No transitive closure, limit to alias objects
        //

        NtStatus = SampGetMemberships(
                        &AccountDsName,
                        1,
                        DomainContext->ObjectNameInDs,   // limiting domain
                        RevMembGetAliasMembership,       // Limit to alias objects
                        &cDsNames,
                        &rpDsNames,
                        NULL,
                        NULL,
                        NULL);


        if (NT_SUCCESS(NtStatus))
        {
            ULONG Index;
            ULONG  Rid;
            PSAMP_OBJECT AliasContext;

            //
            // Set the return parameters so the caller of this function
            // knows what aliases have been changed
            //
            if ( CheckAccess ) {
                // We will increment *MembershipCount as they are opened
                *Membership = MIDL_user_allocate(cDsNames * sizeof(ULONG));
                if ( !*Membership ) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }
            }
            //
            //  Walk the returned list of Sids and remove the Sid from the
            //  membership list.
            //


            for (Index=0;Index<cDsNames;Index++)
            {
                DSNAME * AliasObjectName = NULL;

                //
                // Split the Sid to find the Rid
                //

                ASSERT(rpDsNames[Index]->SidLen>0);

                NtStatus = SampSplitSid(
                                &(rpDsNames[Index]->Sid),
                                NULL,
                                &Rid
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Do an Open account. This both finds the Object Name
                    // plus checks for any necessary permissions
                    //

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampOpenAccount(
                                  SampAliasObjectType,
                                  DomainHandle,
                                  ALIAS_REMOVE_MEMBER,
                                  Rid,
                                  TRUE,
                                  (SAMPR_HANDLE *)&AliasContext
                                  );



                    if  (NT_SUCCESS(NtStatus))
                    {

                        //
                        //  Delete the Membership
                        //

                        IgnoreStatus = SampDsRemoveMembershipAttribute(
                                            AliasContext->ObjectNameInDs,
                                            SAMP_ALIAS_MEMBERS,
                                            SampAliasObjectType,
                                            AccountDsName
                                            );

                        SampDeleteContext((PSAMP_OBJECT)(AliasContext));

                        if (CheckAccess) {
                            (*Membership)[Index] = Rid;
                            *MembershipCount += 1;
                        }

                    }
                }
            }
        }

    }
    else
    {
        PSAMP_OBJECT AliasContext = NULL;

        //
        // Registry Case
        //

        ASSERT(FALSE==SampUseDsData);

        //
        // Get the alias membership for this account
        //

        NtStatus = SampBuildAliasMembersKeyName(
                       AccountSid,
                       &DomainKeyName,
                       &AccountKeyName
                       );
        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AccountKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );

            if ((NtStatus == STATUS_OBJECT_PATH_NOT_FOUND) ||
                (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) ) {

                //
                // This account is not a member of any of our aliases
                //

                NtStatus = STATUS_SUCCESS;

                if ( CheckAccess ) {

                    //
                    // Return the list of aliases the account was
                    // removed from; in this case, none.
                    //

                    ( *MembershipCount ) = 0;
                    ( *Membership ) = NULL;
                }

            } else {

                //
                // Load in the alias membership list
                //

                if (NT_SUCCESS(NtStatus)) {

                    KeyValueLength = 0;

                    NtStatus = RtlpNtQueryValueKey( TempHandle,
                                                    &LocalMembershipCount,
                                                    NULL,
                                                    &KeyValueLength,
                                                    NULL);

                    SampDumpRtlpNtQueryValueKey(&LocalMembershipCount,
                                                NULL,
                                                &KeyValueLength,
                                                NULL);

                    if (NT_SUCCESS(NtStatus)) {
                        ASSERT(LocalMembershipCount == 0);
                    }

                    if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                        LocalMembership = MIDL_user_allocate( KeyValueLength );

                        if (LocalMembership == NULL) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        } else {

                            NtStatus = RtlpNtQueryValueKey(
                                           TempHandle,
                                           NULL,
                                           LocalMembership,
                                           &KeyValueLength,
                                           NULL);

                            SampDumpRtlpNtQueryValueKey(NULL,
                                                        LocalMembership,
                                                        &KeyValueLength,
                                                        NULL);

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // Remove the account from each alias
                                //

                                for (i=0; i < LocalMembershipCount; i++) {

                                    if ( CheckAccess ) {

                                        //
                                        // If account is being removed from
                                        // the ADMIN alias, change ACL to
                                        // allow account operators to access
                                        // the account (unless account is an
                                        // admin some other way).  Kind of
                                        // useless since the account is about
                                        // to be deleted, but do it anyway
                                        // in case something bad happens and
                                        // it doesn't get deleted.
                                        //

                                        //
                                        // Admin Count on the object is checked
                                        // for these purpose inside of
                                        // SampChangeAccountOperatorAccess
                                        // ToMember
                                        //

                                        if ( LocalMembership[i] ==
                                            DOMAIN_ALIAS_RID_ADMINS ) {

                                            NtStatus = SampChangeAccountOperatorAccessToMember(
                                                           AccountSid,
                                                           RemoveFromAdmin,
                                                           NoChange );
                                        }

                                        //
                                        // Just open and close the alias
                                        // to make sure we are allowed
                                        // the necessary access.
                                        //

                                        SampSetTransactionWithinDomain(FALSE);

                                        NtStatus = SampOpenAccount(
                                                       SampAliasObjectType,
                                                       DomainHandle,
                                                       ALIAS_REMOVE_MEMBER,
                                                       LocalMembership[i],
                                                       TRUE,
                                                       (SAMPR_HANDLE *)&AliasHandle
                                                       );

                                        if (NT_SUCCESS(NtStatus)) {

                                            SampDeleteContext(
                                                (PSAMP_OBJECT)( AliasHandle ) );
                                        }
                                    }

                                    if (!NT_SUCCESS(NtStatus)) {
                                        break;
                                    }

                                    NtStatus = SampCreateAccountContext(
                                                   SampAliasObjectType,
                                                   LocalMembership[i],
                                                   TRUE,  // Trusted client
                                                   FALSE, // Loopback client
                                                   TRUE,  // Account exists
                                                   &AliasContext
                                                   );

                                    if (NT_SUCCESS(NtStatus)) {

                                        NtStatus = SampRemoveAccountFromAlias(
                                                       AliasContext,
                                                       SAMP_ALIAS_MEMBERS,
                                                       AccountSid,
                                                       NULL
                                                       );

                                        if (NT_SUCCESS(NtStatus)) {

                                            //
                                            // Save the alias changes we just
                                            // made.  We'll delete the context,
                                            // so don't let RXACT use the open
                                            // key handle in the context.
                                            //

                                            NtStatus = SampStoreObjectAttributes(
                                                           AliasContext,
                                                           FALSE
                                                           );
                                        }

                                        SampDeleteContext(AliasContext);
                                    }

                                    if (!NT_SUCCESS(NtStatus)) {
                                        break;
                                    }
                                }

                                //
                                // Delete the account membership keys
                                //

                                if (NT_SUCCESS(NtStatus)) {

                                    NtStatus = SampDeleteAliasMembershipKeysForAccount(
                                                    AccountSid);
                                }

                            }

                            if ( CheckAccess ) {

                                //
                                // Return the list of aliases the account was
                                // removed from.
                                //

                                ( *MembershipCount ) = LocalMembershipCount;
                                ( *Membership ) = LocalMembership;

                            } else {

                                MIDL_user_free(LocalMembership);
                            }
                        }
                    }

                    IgnoreStatus = NtClose( TempHandle );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                }
            }

            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );
}




NTSTATUS
SampRetrieveAliasMembership(
    IN PSID Account,
    IN DSNAME * AccountDn OPTIONAL,
    OUT PULONG MemberCount OPTIONAL,
    IN OUT PULONG BufferSize OPTIONAL,
    OUT PULONG Buffer OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of aliases in the current domain
    that the specified account is a member of. If desired it will also fill
    in a buffer with the alias rids.


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().


Arguments:

    Account - the account whose membership we are interested in.

    AccountDn - The DN of the account. Is passed in during the DS case. NULL for
                the registry case.

    MemberCount - Receives the number of current-domain-aliases the
                  account is a member of.

    BufferSize - (Optional) Specified the size of memory pointer to by buffer.

    Buffer - (Otional) Is filled in with the list of alias membership rids.
        If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()



--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    UNICODE_STRING          DomainKeyName, AccountKeyName;
    HANDLE                  TempHandle;
    PSAMP_OBJECT            DomainContext;

    SAMTRACE("SampRetrieveAliasMembership");


    DomainContext =  SampDefinedDomains[SampTransactionDomainIndex].Context;


    if (IsDsObject(DomainContext))
    {
        //
        // DS Case
        //

        ASSERT(ARGUMENT_PRESENT(AccountDn));

        NtStatus = SampDsGetAliasMembershipOfAccount(
                        DomainContext->ObjectNameInDs,
                        AccountDn,
                        MemberCount,
                        BufferSize,
                        Buffer
                        );
    }
    else
    {
        //
        // Get the membership count for this account
        //

        NtStatus = SampBuildAliasMembersKeyName(
                       Account,
                       &DomainKeyName,
                       &AccountKeyName
                       );
        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AccountKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );

            if ((NtStatus == STATUS_OBJECT_PATH_NOT_FOUND) ||
                (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) ) {

                //
                // This account is not a member of any of our aliases
                //

                NtStatus = STATUS_SUCCESS;

                if (ARGUMENT_PRESENT(MemberCount)) {
                    *MemberCount = 0;
                }
                if (ARGUMENT_PRESENT(BufferSize)) {
                    *BufferSize = 0;
                }

            } else {

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlpNtQueryValueKey( TempHandle,
                                                    MemberCount,
                                                    Buffer,
                                                    BufferSize,
                                                    NULL);

                    SampDumpRtlpNtQueryValueKey(MemberCount,
                                                Buffer,
                                                BufferSize,
                                                NULL);

                    IgnoreStatus = NtClose( TempHandle );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );
                }
            }

            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Services Private to this file                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampAddAccountToAlias(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Attribute,
    IN PSID AccountSid,
    IN DSNAME * AccountDn OPTIONAL
    )

/*++

Routine Description:

    This service is used to add an account as a member of a specified alias
    This is done by simply adding the account SID to the list of SIDs
    in the MEMBERS attribute of the the specified alias


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply edits the in-memory copy of
    the alias information.


Arguments:

    AccountContext - Context block Describing the Alias

    Attribute -- the membership attribute to modify

    AccountSid - The Sid of the account being added as a new member.

    AccountDn  - For DS cases only, the DN of the account

Return Value:

    STATUS_SUCCESS - The account was added.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       MemberCount, i;
    ULONG       MemberArraySize;
    PSID        MemberArray;
    PWCHAR      MemberStringName = NULL;

    SAMTRACE("SampAddAccountToAlias");

    if (IsDsObject(AccountContext)) {
        ASSERT((Attribute == SAMP_ALIAS_NON_MEMBERS) ||
               (Attribute == SAMP_ALIAS_MEMBERS));
    } else {
        ASSERT((Attribute == SAMP_ALIAS_MEMBERS));
    }


    //
    // Need to do different things for DS and Registry
    //

    if (IsDsObject(AccountContext))
    {

        //
        // DS based Domain
        //

        ASSERT(AccountDn!=NULL);

        //
        // Get Member account string name if available,
        // for auditing propose
        //
        if (AccountDn->NameLen && AccountDn->StringName)
        {
            MemberStringName = AccountDn->StringName;
        }

        //
        // Add this entry to the Ds. In Loopback case, buffer the membership operation in object
        // context. By doing so, we can speed up multiple membership add / remove operations.
        //

        if (AccountContext->BufferWrites)
        {
            NtStatus = SampDsAddMembershipOperationToCache(
                                            AccountContext,
                                            Attribute,
                                            ADD_VALUE,
                                            AccountDn
                                            );
        }
        else
        {
            NtStatus = SampDsAddMembershipAttribute(
                        AccountContext->ObjectNameInDs,
                        0,
                        Attribute,
                        SampAliasObjectType,
                        AccountDn
                        );
        }

        //
        // Map Error Codes
        //

        if (STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS==NtStatus)
        {
            NtStatus = STATUS_MEMBER_IN_ALIAS;
        }

    }
    else
    {

        //
        //  Regisry based Domain
        //

        NtStatus = SampGetSidArrayAttribute(
                        AccountContext,
                        Attribute,
                        FALSE,  // Reference directly
                        &MemberArray,
                        &MemberArraySize,
                        &MemberCount
                        );

        if (NT_SUCCESS(NtStatus)) {

            PSID MemberPointer = MemberArray;

            //
            // Check the member is really new
            //

            for (i = 0; i<MemberCount ; i++ ) {

                if (RtlEqualSid(MemberPointer, AccountSid)) {

                    NtStatus = STATUS_MEMBER_IN_ALIAS;
                    break;
                }

                ((PCHAR)MemberPointer) += RtlLengthSid(MemberPointer);
            }



            if (NT_SUCCESS(NtStatus)) {

                //
                // MemberPointer now points at the byte beyond the end of the
                // old member array
                //

                //
                // Allocate a new membership buffer large enough for the existing
                // member list and the new one.
                //

                ULONG OldTotalSize = (ULONG)(((PCHAR)MemberPointer) - ((PCHAR)MemberArray));
                ULONG NewMemberSize = RtlLengthSid(AccountSid);
                ULONG NewTotalSize = OldTotalSize + NewMemberSize;
                PSID NewMemberArray;


                NewMemberArray = MIDL_user_allocate( NewTotalSize );

                if (NewMemberArray == NULL) {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Copy the member list into the new array
                    //

                    RtlCopyMemory(NewMemberArray, MemberArray, OldTotalSize);

                    //
                    // Add the new member to the end
                    //

                    MemberCount += 1;

                    NtStatus = RtlCopySid(
                                        NewMemberSize,
                                        ((PCHAR)NewMemberArray) + OldTotalSize,
                                        AccountSid);

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Update the alias with it's new member list
                        //

                        NtStatus = SampSetSidArrayAttribute(
                                        AccountContext,
                                        Attribute,
                                        NewMemberArray,
                                        NewTotalSize,
                                        MemberCount
                                        );
                        }

                    //
                    // Free up the membership array we allocated
                    //

                    MIDL_user_free( NewMemberArray );
                }

            }
        }
    //
    // End of Registry Part
    //

    }

    //
    // Account has been added to alias membership
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(AccountContext->DomainIndex)) {

        //
        // Audit this member add operation
        //
        SampAuditGroupMemberChange(AccountContext,  // Alias Context
                                   TRUE,            // Add Member
                                   MemberStringName,// Member Name
                                   NULL,            // Member RID
                                   AccountSid       // Member SID
                                   );
    }

    return(NtStatus);
}



NTSTATUS
SampRemoveAccountFromAlias(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Attribute,
    IN PSID AccountSid,
    IN DSNAME * AccountDn  OPTIONAL
    )

/*++

Routine Description:

    This routine is used to Remove an account from a specified alias.
    This is done by simply Removing the user's Sid From the list of Sids
    in the MEMBERS sub-key of the the specified alias.

    It is the caller's responsibility to know that the user is, in fact,
    currently a member of the alias.


    The caller of this service is expected to be in the middle of a
    RXACT transaction.  This service simply adds some actions to that
    RXACT transaction.


Arguments:

    AliasRid - The RID of the alias the account is to be removed from.

    AccountSid - The SID of the account being Removed.

    AccountDn  - The DS Name of the account for DS cases

Return Value:


    STATUS_SUCCESS - The user has been Removed.

    STATUS_MEMBER_NOT_IN_ALIAS - The account was not a member of the alias.

--*/
{
    NTSTATUS    NtStatus =STATUS_SUCCESS;
    ULONG       MemberCount, i;
    ULONG       MemberArraySize;
    PSID        MemberArray, Member, NextMember;
    PWCHAR      MemberStringName = NULL;

    ULONG RemovedMemberSize = RtlLengthSid(AccountSid);

    SAMTRACE("SampRemoveAccountFromAlias");

    if (IsDsObject(AccountContext)) {
        ASSERT((Attribute == SAMP_ALIAS_NON_MEMBERS) ||
               (Attribute == SAMP_ALIAS_MEMBERS));
    } else {
        ASSERT((Attribute == SAMP_ALIAS_MEMBERS));
    }


    //
    // Test wether we are DS based
    //

    if (IsDsObject(AccountContext))
    {

        ASSERT(AccountDn!=NULL);

        //
        // Get Member String Name if available for auditing propose
        //
        if (AccountDn->NameLen && AccountDn->StringName)
        {
            MemberStringName = AccountDn->StringName;
        }

        //
        // Remove the account from the membership list
        //

        if (AccountContext->BufferWrites)
        {
            NtStatus = SampDsAddMembershipOperationToCache(
                                            AccountContext,
                                            Attribute,
                                            REMOVE_VALUE,
                                            AccountDn
                                            );
        }
        else
        {
            NtStatus = SampDsRemoveMembershipAttribute(
                            AccountContext->ObjectNameInDs,
                            Attribute,
                            SampAliasObjectType,
                            AccountDn
                            );
        }

        //
        // Re Map Error Codes
        //

        if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
        {
            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
        }


    }
    else
    {

        //
        // We are registry based
        //

        //
        // Get a copy of the current member array.
        //

        NtStatus = SampGetSidArrayAttribute(
                        AccountContext,
                        Attribute,
                        TRUE, // Make copy
                        &MemberArray,
                        &MemberArraySize,
                        &MemberCount
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // For each member sid, copy it from old to new member
            // arrays if it is not the sid we're trying to delete
            //

            Member = MemberArray;

            for (i = 0; i < MemberCount ; i++ ) {

                NextMember = (PSID)(((PCHAR)Member) + RtlLengthSid(Member));

                if (RtlEqualSid(Member, AccountSid)) {

                    //
                    // Found the member to delete.  Shift subsequent members
                    //

                    while ((PCHAR)NextMember <
                        (((PCHAR)MemberArray) + MemberArraySize)) {

                        *((PCHAR)Member)++ = *((PCHAR)NextMember)++;
                    }

                    break;
                }

                //
                // Advance the old pointer
                //

                Member = NextMember;

                ASSERT((PCHAR)Member <= (((PCHAR)MemberArray) + MemberArraySize));
            }


            //
            // If nothing was removed, we didn't find the account
            //

            if (i == MemberCount) {

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;

            } else {

                //
                // The member has been removed, write out the new member list
                //

                ASSERT((PCHAR)Member ==
                    (((PCHAR)MemberArray)) + MemberArraySize - RemovedMemberSize);

                NtStatus = SampSetSidArrayAttribute(
                                AccountContext,
                                Attribute,
                                MemberArray,
                                MemberArraySize - RemovedMemberSize,
                                MemberCount - 1
                                );
            }

            //
            // Free up the member array
            //

            MIDL_user_free(MemberArray);
        }
    }

    //
    // audit this, if necessary.
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(AccountContext->DomainIndex)) {

        //
        // Audit the member remove operation
        //
        SampAuditGroupMemberChange(AccountContext,  // Alias Context
                                   FALSE,           // Remove Member
                                   MemberStringName,// Member Name
                                   NULL,            // Member RID
                                   AccountSid       // Member SID
                                   );
    }

    return(NtStatus);
}



NTSTATUS
SampAddAliasToAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    )

/*++

Routine Description:

    This service adds the specified alias to the account's membership
    list.  It is not assumed that the caller knows anything about
    the target account.  In particular, the caller doesn't know whether
    the account exists or not, nor whether the account is already a member
    of the alias.

    IN REGISTRY MODE THIS SERVICE MUST BE CALLED
    WITH THE TRANSACTION DOMAIN SET.

    It is a No-Op for DS based accounts, as no reverse membership list
    is being maintained.

Arguments:

    AliasContext - Object Context of the Alias

    AccountSid - The SID of the account.


Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_MEMBER_IN_ALIAS - The account is already a member of the
        specified alias.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()


--*/
{

    NTSTATUS                NtStatus = STATUS_SUCCESS, IgnoreStatus;
    UNICODE_STRING          DomainKeyName;
    UNICODE_STRING          AccountKeyName;
    HANDLE                  TempHandle;
    ULONG                   MembershipCount, KeyValueLength;
    ULONG                   DomainRidCount;
    ULONG                   i;
    ULONG                   AliasRid = AliasContext->TypeBody.Alias.Rid;
    PULONG                  MembershipArray = NULL;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    BOOLEAN                 NewAccount;


    SAMTRACE("SampAddAliasToAccountMembership");

  //
  // For the DS case this routine is a No Operation as , no reverse membership
  // list is ever maintained. We are guarenteed that the account Sid is in the DS
  // either locally or GC , if the alias is in the DS. If not the Samr Call will
  // fail anyhow
  //




    if (!IsDsObject(AliasContext))
    {

        //
        // Registry Case
        //

        //
        // Assume the account is a member of at least one of our aliases
        //

        NewAccount = FALSE;

        NtStatus = SampBuildAliasMembersKeyName(
                       AccountSid,
                       &DomainKeyName,
                       &AccountKeyName
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Try to open the domain alias/members/(domain) key for this account
            //

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DomainKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );

            if (NT_SUCCESS(NtStatus)) {

                //
                // Get the current domain rid count
                //

                NtStatus = RtlpNtQueryValueKey(
                                TempHandle,
                                &DomainRidCount,
                                NULL,
                                NULL,
                                NULL);

                SampDumpRtlpNtQueryValueKey(&DomainRidCount,
                                            NULL,
                                            NULL,
                                            NULL);

                IgnoreStatus = NtClose(TempHandle);
                ASSERT(NT_SUCCESS(IgnoreStatus));

            } else {

                if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                    //
                    // No other accounts in this domain are members of any of our
                    // aliases.
                    //
                    // Create a new key for this domain with no accounts (rids).
                    //

                    NewAccount = TRUE;

                    DomainRidCount = 0; // No accounts yet

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &DomainKeyName,
                                   DomainRidCount,
                                   NULL,
                                   0
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        //
                        // Keep our domain count uptodate
                        //

                        NtStatus = SampAdjustAliasDomainsCount(TRUE);
                    }
                }
            }



            if (NT_SUCCESS(NtStatus)) {

                if (!NewAccount) {

                    //
                    // Try to open the domain alias/members/(domain)/(account) key
                    //

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &AccountKeyName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

                    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

                    NtStatus = RtlpNtOpenKey(
                                   &TempHandle,
                                   (KEY_READ),
                                   &ObjectAttributes,
                                   0
                                   );
                }


                if (NewAccount || (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)) {

                    //
                    // This account is not a member of any of our aliases yet.
                    //

                    NewAccount = TRUE;

                    //
                    // Set up it's initial membership
                    //

                    MembershipCount = 1;
                    MembershipArray = &AliasRid;

                    NtStatus = STATUS_SUCCESS;  // We're doing fine
                }


                if (NT_SUCCESS(NtStatus) && !NewAccount) {

                    //
                    // This account already exists
                    //
                    // Get the current membership buffer and add the new alias
                    //

                    KeyValueLength = 0;

                    NtStatus = RtlpNtQueryValueKey(
                                    TempHandle,
                                    &MembershipCount,
                                    NULL,
                                    &KeyValueLength,
                                    NULL);

                    SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                                NULL,
                                                &KeyValueLength,
                                                NULL);

                    if (NT_SUCCESS(NtStatus) || (NtStatus == STATUS_BUFFER_OVERFLOW)) {

                        ASSERT(KeyValueLength == (MembershipCount * sizeof(ULONG)));

                        //
                        // Allocate a membership buffer large enough for an
                        // additional member.
                        //

                        KeyValueLength += sizeof(ULONG);
                        MembershipArray = MIDL_user_allocate( KeyValueLength );

                        if (MembershipArray == NULL) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        } else {

                            NtStatus = RtlpNtQueryValueKey(
                                           TempHandle,
                                           NULL,
                                           MembershipArray,
                                           &KeyValueLength,
                                           NULL);

                            SampDumpRtlpNtQueryValueKey(NULL,
                                                        MembershipArray,
                                                        &KeyValueLength,
                                                        NULL);

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // See if the account is already a member ...
                                //

                                for (i = 0; i<MembershipCount ; i++ ) {
                                    if ( MembershipArray[i] == AliasRid ) {
                                        MIDL_user_free(MembershipArray);
                                        MembershipArray = NULL;
                                        NtStatus = STATUS_MEMBER_IN_ALIAS;
                                        break;
                                    }
                                }

                                if (NT_SUCCESS(NtStatus)) {

                                    //
                                    // Add the new alias's RID to the end
                                    //

                                    MembershipCount += 1;
                                    MembershipArray[MembershipCount-1] = AliasRid;
                                }
                            }
                            else {
                                MIDL_user_free(MembershipArray);
                                MembershipArray = NULL;
                            }
                        }
                    }

                    //
                    // Close the account key handle
                    //

                    IgnoreStatus = NtClose( TempHandle );
                    ASSERT( NT_SUCCESS(IgnoreStatus) );

                }

                //
                // We now have a new membership list desribed by :
                // MembershipArray, MembershipCount
                //
                // Write it out and free it up
                //

                if (NT_SUCCESS(NtStatus)) {

                    KeyValueLength = MembershipCount * sizeof(ULONG);

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &AccountKeyName,
                                   MembershipCount,
                                   MembershipArray,
                                   KeyValueLength
                                   );

                    if (MembershipArray != &AliasRid) {
                        MIDL_user_free( MembershipArray );
                    }
                }

                //
                // If this is a new account, we need to increment the rid count
                // in the account domain.
                //

                if (NewAccount) {

                    //
                    // Increment the domain rid count
                    //

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &DomainKeyName,
                                   DomainRidCount + 1,
                                   NULL,
                                   0
                                   );
                }

            }

            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );

}



NTSTATUS
SampRemoveAliasFromAccountMembership(
    IN PSAMP_OBJECT AliasContext,
    IN PSID AccountSid
    )

/*++

Routine Description:

    This service removes the specified alias from the account's membership
    list.  It is not assumed that the caller knows anything about
    the target account.  In particular, the caller doesn't know whether
    the account exists or not, nor whether the account is really a member
    of the alias.

    This routine removes the reference to the alias from the account's
    membership list, removes the account key if there are no more aliases,
    and removes the domain-sid key if this is the last account in the
    domain.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

    This routine is a No Op for the case where the Alias is in a domain
    defined in the DS.

Arguments:

    AliasContext - Alias Object Context

    AccountSid - The SID of the account.


Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_USER - The account does not exist.

    STATUS_MEMBER_NOT_IN_ALIAS - The account is not a member of the
        specified alias.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus=STATUS_SUCCESS, IgnoreStatus;
    UNICODE_STRING          DomainKeyName;
    UNICODE_STRING          AccountKeyName;
    HANDLE                  TempHandle;
    ULONG                   MembershipCount, KeyValueLength, i;
    ULONG                   AliasRid = AliasContext->TypeBody.Alias.Rid;
    PULONG                  MembershipArray;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    SAMTRACE("SampRemoveAliasFromAccountMembership");


    //
    // For the DS case this routine is a No Operation as , no reverse membership
    // list is ever maintained. We are guarenteed that the account Sid is in the DS
    // either locally or GC , if the alias is in the DS. If not the Samr Call will
    // fail anyhow
    //

     if (!IsDsObject(AliasContext))
     {

        //
        // Get the account membership
        //

        NtStatus = SampBuildAliasMembersKeyName(
                       AccountSid,
                       &DomainKeyName,
                       &AccountKeyName
                       );
        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &AccountKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );


            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );
            if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND     ||
                NtStatus == STATUS_OBJECT_PATH_NOT_FOUND) {

                NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Retrieve the length of the membership buffer
                //

                KeyValueLength = 0;

                NtStatus = RtlpNtQueryValueKey(
                                TempHandle,
                                &MembershipCount,
                                NULL,
                                &KeyValueLength,
                                NULL);

                SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                            NULL,
                                            &KeyValueLength,
                                            NULL);

                if (NT_SUCCESS(NtStatus)) {
                    ASSERT(MembershipCount == 0);

                    NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
                }

                if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                    ASSERT(MembershipCount != 0);
                    ASSERT(KeyValueLength == (MembershipCount * sizeof(ULONG)));

                    MembershipArray = MIDL_user_allocate( KeyValueLength );

                    if (MembershipArray == NULL) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    } else {

                        NtStatus = RtlpNtQueryValueKey(
                                       TempHandle,
                                       NULL,
                                       MembershipArray,
                                       &KeyValueLength,
                                       NULL);

                        SampDumpRtlpNtQueryValueKey(NULL,
                                                    MembershipArray,
                                                    &KeyValueLength,
                                                    NULL);

                        if (NT_SUCCESS(NtStatus)) {

                            //
                            // See if the account is a member ...
                            //

                            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;

                            for (i = 0; i<MembershipCount ; i++ ) {
                                if ( MembershipArray[i] == AliasRid ) {
                                    NtStatus = STATUS_SUCCESS;
                                    break;
                                }
                            }

                            if (NT_SUCCESS(NtStatus)) {

                                //
                                // Replace the removed alias information
                                // with the last entry's information.
                                // Then add it to the RXACT transaction
                                // to be written out.
                                //

                                MembershipCount -= 1;
                                KeyValueLength -= sizeof(ULONG);

                                if (MembershipCount > 0) {

                                    MembershipArray[i] = MembershipArray[MembershipCount];

                                    ASSERT(KeyValueLength == (MembershipCount * sizeof(ULONG)));
                                    NtStatus = RtlAddActionToRXact(
                                                   SampRXactContext,
                                                   RtlRXactOperationSetValue,
                                                   &AccountKeyName,
                                                   MembershipCount,
                                                   MembershipArray,
                                                   KeyValueLength
                                                   );
                                } else {

                                    //
                                    // This is the last alias membership for
                                    // this account. Delete the keys.
                                    //

                                    NtStatus = SampDeleteAliasMembershipKeysForAccount(
                                                    AccountSid);
                                }
                            }
                        }

                        MIDL_user_free( MembershipArray );
                    }

                }

                IgnoreStatus = NtClose( TempHandle );
                ASSERT( NT_SUCCESS(IgnoreStatus) );
            }


            SampFreeUnicodeString( &DomainKeyName );
            SampFreeUnicodeString( &AccountKeyName );

        }
    }

    return( NtStatus );

}



NTSTATUS
SampRemoveAliasFromAllAccounts(
    IN PSAMP_OBJECT AliasContext
    )

/*++

Routine Description:

    This service removes the specified alias from all account memberships

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

    This service leaves the alias membership list intact. It is assumed
    that the caller will delete the alias member list as part of the
    current transaction.

    This routine is a No OP for the DS case

Arguments:

    AliasRid - The relative ID of the alias.

Return Value:


    STATUS_SUCCESS - The information has been updated and added to the
        RXACT.

    STATUS_NO_SUCH_ALIAS - The alias does not exist.


    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()



--*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS;
    ULONG                   MemberCount, i;
    PSID                    *MemberArray;




    SAMTRACE("SampRemoveAliasFromAllAccounts");

    if (!IsDsObject(AliasContext))
    {

        //
        // Get the list of members in this alias
        //

        MemberArray = NULL;

        NtStatus = SampRetrieveAliasMembers(
                        AliasContext,
                        &MemberCount,
                        &MemberArray);

        if (NT_SUCCESS(NtStatus)) {

            ASSERT((MemberCount != 0) == (MemberArray != NULL));

            //
            // Remove this alias from each of our members in turn
            //

            for (i = 0; i < MemberCount ; i++ ) {

                NtStatus = SampRemoveAliasFromAccountMembership(
                                        AliasContext,       // Alias Context
                                        MemberArray[i]      // Member Object SID
                                        );

                if (!NT_SUCCESS(NtStatus)) {
                    break;
                }
            }

            if (MemberArray != NULL) {
                MIDL_user_free( MemberArray );
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampRetrieveAliasMembers(
    IN PSAMP_OBJECT AliasContext,
    OUT PULONG MemberCount,
    OUT PSID **Members OPTIONAL
    )

/*++
Routine Description:

    This service retrieves the number of members in a alias.  If desired,
    it will also retrieve an array of SIDs of the members of the alias.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the account context whose alias members are to
        to be retrieved.

    MemberCount - Receives the number of members currently in the alias.

    Members - (Otional) Receives a pointer to a buffer containing an array
        of member PSIDs.  If this value is NULL, then this information
        is not returned.  The returned buffer is allocated using
        MIDL_user_allocate() and must be freed using MIDL_user_free() when
        no longer needed.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    STATUS_INSUFFICIENT_RESOURCES - Memory could not be allocated for the
        string to be returned in.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()

    If this routine returns failure, *MemberCount will be zero and
    *Members will be NULL.


--*/
{

    NTSTATUS    NtStatus=STATUS_SUCCESS;
    PSID        MemberArray;
    ULONG       MemberArraySize;
    ULONG       i;

    SAMTRACE("SampRetieveAliasMembers");

    ASSERT(MemberCount);

    if (IsDsObject(AliasContext))
    {


        //
        // DS case, this routine in DS layer does all the
        // work
        //

        NtStatus = SampDsGetAliasMembershipList(
                        AliasContext->ObjectNameInDs,
                        AliasContext->TypeBody.Alias.Rid,
                        MemberCount,
                        Members
                        );

    }
    else
    {

        //
        // Registry based case
        //
        //

        NtStatus = SampGetSidArrayAttribute(
                        AliasContext,
                        SAMP_ALIAS_MEMBERS,
                        FALSE,  // Reference directly
                        &MemberArray,
                        &MemberArraySize,
                        MemberCount
                        );

        if (NT_SUCCESS(NtStatus)) {

            if (ARGUMENT_PRESENT(Members)) {

                //
                // Allocate memory for the sid array and sid data
                //

                ULONG SidArraySize = *MemberCount * sizeof(PSID);
                ULONG SidDataSize = MemberArraySize;

                if ( *MemberCount == 0 ) {

                    //
                    // Nothing to copy, just return success.
                    //

                    *Members = NULL;
                    return( NtStatus );
                }

                (*Members) = (PSID *)MIDL_user_allocate(SidArraySize + SidDataSize);

                if ((*Members) == NULL) {

                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    //
                    // Copy the sid data into the last part of the block
                    //

                    PSID SidData = (PSID)(&((*Members)[*MemberCount]));

                    RtlCopyMemory(SidData, MemberArray, MemberArraySize);

                    //
                    // Fill in the sid pointer array
                    //

                    for (i = 0; i < *MemberCount ; i++) {

                        (*Members)[i] = SidData;

                        ((PCHAR)SidData) += RtlLengthSid(SidData);
                    }

                    ASSERT(SidData == ((PCHAR)(*Members)) + SidArraySize + SidDataSize);

                }
            }
        }
    }

    return( NtStatus );

}



NTSTATUS
SampDeleteAliasKeys(
    IN PSAMP_OBJECT Context
    )

/*++
Routine Description:

    This service deletes all registry keys related to a alias object.


Arguments:

    Context - Points to the alias context whose registry keys are
        being deleted.


Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        RtlAddActionToRXact()



--*/
{

    NTSTATUS                NtStatus;
    ULONG                   Rid;
    UNICODE_STRING          AccountName, KeyName;


    SAMTRACE("SampDeleteAliasKeys");

    Rid = Context->TypeBody.Alias.Rid;


    //
    // Aliases are arranged as follows:
    //
    //  +-- Aliases [Count]
    //      ---+--
    //         +--  Names
    //         |    --+--
    //         |      +--  (AliasName) [AliasRid,]
    //         |
    //         +--  (AliasRid) [Revision,SecurityDescriptor]
    //               ---+-----
    //                  +--  V1_Fixed [,SAM_V1_FIXED_LENGTH_ALIAS]
    //                  +--  Name [,Name]
    //                  +--  AdminComment [,unicode string]
    //                  +--  Members [Count,(Member0Sid, (...), MemberX-1Sid)]
    //
    // This all needs to be deleted from the bottom up.
    //


    //
    // Decrement the alias count
    //

    NtStatus = SampAdjustAccountCount(SampAliasObjectType, FALSE);




    //
    // Delete the registry key that has the alias's name to RID mapping.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // Get the name
        //

        NtStatus = SampGetUnicodeStringAttribute(
                       Context,
                       SAMP_ALIAS_NAME,
                       TRUE,    // Make copy
                       &AccountName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampBuildAccountKeyName(
                           SampAliasObjectType,
                           &KeyName,
                           &AccountName
                           );

            SampFreeUnicodeString( &AccountName );


            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );

                SampFreeUnicodeString( &KeyName );
            }
        }
    }



    //
    // Delete the attribute keys
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeleteAttributeKeys(
                        Context
                        );
    }


    //
    // Delete the RID key
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampBuildAccountSubKeyName(
                       SampAliasObjectType,
                       &KeyName,
                       Rid,
                       NULL
                       );

        if (NT_SUCCESS(NtStatus)) {


            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );

            SampFreeUnicodeString( &KeyName );
        }


    }



    return( NtStatus );

}



NTSTATUS
SampDeleteAliasMembershipKeysForAccount(
    IN PSID AccountSid
    )

/*++

Routine Description:

    This service deletes the alias membership keys for the specified account.

    This account rid key is deleted. If this was the last account-rid for
    the domain then the domain keys is deleted also.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

    It is assumed we are in the middle of a registry transaction.

Arguments:

    AccountSid - The SID of the account.


Return Value:


    STATUS_SUCCESS - The transactions have been added.

    Other status values that may be returned are those returned
    by:

            NtOpenKey()
            NtQueryValueKey()
            RtlAddActionToRXact()

--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    UNICODE_STRING          DomainKeyName;
    UNICODE_STRING          AccountKeyName;
    HANDLE                  TempHandle;
    ULONG                   MembershipCount;
    OBJECT_ATTRIBUTES       ObjectAttributes;

    SAMTRACE("SampDeleteAliasMembershipKeysForAccount");

    //
    // Get the account membership key names
    //

    NtStatus = SampBuildAliasMembersKeyName(
                   AccountSid,
                   &DomainKeyName,
                   &AccountKeyName
                   );
    if (NT_SUCCESS(NtStatus)) {


        //
        // Delete the account rid key
        //

        NtStatus = RtlAddActionToRXact(
                       SampRXactContext,
                       RtlRXactOperationDelete,
                       &AccountKeyName,
                       0,
                       NULL,
                       0
                       );

        //
        // Adjust the rid count for the domain
        //

        if (NT_SUCCESS(NtStatus)) {

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DomainKeyName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );


            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

            NtStatus = RtlpNtOpenKey(
                           &TempHandle,
                           (KEY_READ),
                           &ObjectAttributes,
                           0
                           );
            ASSERT(NT_SUCCESS(NtStatus)); // We just opened a sub-key successfully !

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlpNtQueryValueKey(
                               TempHandle,
                               &MembershipCount,
                               NULL,
                               NULL,
                               NULL);

                SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                            NULL,
                                            NULL,
                                            NULL);

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Decrement the rid count, write out or delete key if 0
                    //

                    MembershipCount -= 1;
                    if (MembershipCount > 0) {

                        //
                        // Decrement the domain rid count
                        //

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &DomainKeyName,
                                       MembershipCount,
                                       NULL,
                                       0
                                       );
                    } else {

                        //
                        // Delete the domain key
                        //

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationDelete,
                                       &DomainKeyName,
                                       0,
                                       NULL,
                                       0
                                       );

                        //
                        // Adjust the count of domain keys
                        //

                        if (NT_SUCCESS(NtStatus)) {

                            NtStatus = SampAdjustAliasDomainsCount(FALSE);
                        }
                    }

                }

                //
                // Close the domain key handle
                //

                IgnoreStatus = NtClose( TempHandle );
                ASSERT( NT_SUCCESS(IgnoreStatus) );
            }
        }


        SampFreeUnicodeString( &DomainKeyName );
        SampFreeUnicodeString( &AccountKeyName );

    }



    return( NtStatus );

}



NTSTATUS
SampAdjustAliasDomainsCount(
    IN BOOLEAN Increment
    )

/*++
Routine Description:

    This service increments or decrements the number of domains that have
    at least one account that is a member of one of our aliases.

    This value is contained in the type of \(domain)\ALIASES\MEMBERS



    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Arguments:

    Increment - TRUE to increment, FALSE to decrement

Return Value:

    STATUS_SUCCESS - The value has been adjusted and the new value added
        to the current RXACT transaction.

    STATUS_INSUFFICIENT_RESOURCES - Not enough memory could be allocated
        to perform the requested operation.

    Other values are unexpected errors.  These may originate from
    internal calls to:

            NtOpenKey()
            NtQueryInformationKey()
            RtlAddActionToRXact()



--*/
{

    //
    // Don't maintain a count of domains for now
    //


    SAMTRACE("SampAdjustAliasDomainsCount");

    return(STATUS_SUCCESS);

    DBG_UNREFERENCED_PARAMETER(Increment);
}



NTSTATUS
SampValidateNewAliasMember(
    IN PSAMP_OBJECT AccountContext,
    IN PSID MemberId,
    IN DSNAME * MemberName OPTIONAL
    )

/*++

Routine Description:

    This service checks the passed Sid is acceptable as a potential new
    member of one of the aliases in the current domain.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Arguments:

    AccountContext - SAM context describing the Alias
    MemberId - the full Sid of the member to validate
    MemberName - For the DS case OPTIONAL DS name parameter
                 specifying the member name

Return Value:


    STATUS_SUCCESS - MemberId is a valid potential alias member

    STATUS_INVALID_MEMBER - MemberId has the wrong account type.

    STATUS_NO_SUCH_MEMBER - MemberId is not a valid account.

    STATUS_INVALID_SID - MemberId is not a valid sid.

--*/
{
    NTSTATUS                NtStatus;
    PSID                    MemberDomainSid = NULL,
                            CurrentDomainSid = NULL;
    ULONG                   MemberRid;
    SAMP_OBJECT_TYPE        MemberType;

    SAMTRACE("SampValidateNewAliasMember");

    //
    // Check the new member sid for structural soundness
    //

    if ((MemberId == NULL) || !RtlValidSid(MemberId)) {
        return(STATUS_INVALID_SID);
    }

    //
    // Do the simple case
    //
    if ((AccountContext->TypeBody.Alias.NT5GroupType == NT5AppBasicGroup)
     || (AccountContext->TypeBody.Alias.NT5GroupType == NT5AppQueryGroup)) {
        ASSERT(IsDsObject(AccountContext));
        //
        // There are scoping rules for Application groups
        //
        return STATUS_SUCCESS;
    }

    //
    // Get the current domain sid
    //


    CurrentDomainSid = SampDefinedDomains[AccountContext->DomainIndex].Sid;

    //
    // Break up the new member into domain and rid
    //

    NtStatus = SampSplitSid(MemberId, &MemberDomainSid, &MemberRid);

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    //
    // Check if the member is in the same domain
    //

    if (!RtlEqualSid(CurrentDomainSid, MemberDomainSid))
    {

        //
        // Cross domain case ----
        //   1. On a workstation need not do any checks
        //   2. On a DS need to enforce the cross domain checks
        //

        if (IsDsObject(AccountContext))
        {
            BOOLEAN  WellKnownSid = FALSE;
            BOOLEAN  LocalSid = FALSE;
            BOOLEAN  ForiegnSid = FALSE;
            BOOLEAN  EnterpriseSid = FALSE;
            BOOLEAN  BuiltinDomainSid = FALSE;

            //
            // Examine the SID. We probably have gone through this route
            // before but we have not cached the results of that examination.
            // ( SampValidateDsName and SampDsResolveSids )
            // However examining a SID is very cheap, so again take a peek
            // at it to get the information we need.
            //

            NtStatus = SampDsExamineSid(
                            MemberId,
                            &WellKnownSid,
                            &BuiltinDomainSid,
                            &LocalSid,
                            &ForiegnSid,
                            &EnterpriseSid
                            );

            if (!NT_SUCCESS(NtStatus))
                goto Error;


            //
            // Call the cross domain reverse membership routine
            // to perform the check regarding membership rules.
            //


            NtStatus = SampEnforceCrossDomainGroupMembershipChecks(
                            AccountContext,
                            MemberId,
                            MemberName
                            );
        }
        else
        {
            //
            // Workstation case , anything and everything including well known
            // SIDS can be members of local groups in a workstation. This is
            // exactly what NT4 enforced, and we will enforce this no matter.
            //

            NtStatus = STATUS_SUCCESS;
        }

    } else {

        //
        // The member is in our domain - check that the type of
        // account is acceptable.
        //

        NtStatus = SampLookupAccountName(
                            AccountContext->DomainIndex,
                            MemberRid,
                            NULL,
                            &MemberType
                            );

        if (NT_SUCCESS(NtStatus)) {

            switch (MemberType) {
            case SampUserObjectType:

                //
                // Users are always accepted as members
                //

                NtStatus = STATUS_SUCCESS;
                break;

            case SampAliasObjectType:

                //
                // In the workstation case fail the call with STATUS_INVALID_MEMBER
                // In the DS case, fall over to the next case, that will validate
                // whether the member group satisfies the "Group Type" restrictions.
                //

                if (!IsDsObject(AccountContext))
                {
                    NtStatus = STATUS_INVALID_MEMBER;
                    break;
                }


            case SampGroupObjectType:

                //
                // In the DS case validate the correct type of membership
                //

                NtStatus = STATUS_SUCCESS;

                if (IsDsObject(AccountContext))
                {
                    NtStatus = SampEnforceSameDomainGroupMembershipChecks(
                                    AccountContext,
                                    MemberRid
                                    );
                }

                break;



            case SampUnknownObjectType:
                NtStatus = STATUS_NO_SUCH_MEMBER;
                break;

            default:
                NtStatus = STATUS_INVALID_MEMBER;
                break;
            }
        }

    }
Error:

    if (NULL!=MemberDomainSid)
    {
        MIDL_user_free(MemberDomainSid);
        MemberDomainSid = NULL;
    }
    return(NtStatus);
}




NTSTATUS
SampChangeAliasAccountName(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName,
    OUT PUNICODE_STRING OldAccountName
    )

/*++
Routine Description:

    This routine changes the account name of an alias account.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the account context whose name is to be changed.

    NewAccountName - New name to give this account

    OldAccountName - old name is returned here. The buffer should be freed
                     by calling MIDL_user_free.

Return Value:


    STATUS_SUCCESS - The information has been retrieved.


    Other status values that may be returned by:

        SampGetUnicodeStringAttribute()
        SampSetUnicodeStringAttribute()
        SampValidateAccountNameChange()
        RtlAddActionToRXact()



--*/
{

    NTSTATUS        NtStatus;
    UNICODE_STRING  KeyName;

    SAMTRACE("SampChangeAliasAccountName");




    //
    // Get the current name so we can delete the old Name->Rid
    // mapping key.
    //

    NtStatus = SampGetUnicodeStringAttribute(
                   Context,
                   SAMP_ALIAS_NAME,
                   TRUE, // Make copy
                   OldAccountName
                   );

    //
    // Make sure the name is valid and not already in use
    //

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampValidateAccountNameChange(
                       Context,
                       NewAccountName,
                       OldAccountName,
                       SampAliasObjectType
                       );

        if (!(IsDsObject(Context))) {

            //
            // For registry based Aliases re-create the
            // Name to Rid mapping keys
            //

            /////////////////////////////////////////////////////////////
            // There are two copies of the name of each account.       //
            // one is under the DOMAIN\(domainName)\ALIAS\NAMES key,   //
            // one is the value of the                                 //
            // DOMAIN\(DomainName)\ALIAS\(rid)\NAME key                //
            /////////////////////////////////////////////////////////////


            //
            // Delete the old name key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampAliasObjectType,
                               &KeyName,
                               OldAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationDelete,
                                   &KeyName,
                                   0,
                                   NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }

            }

            //
            //
            // Create the new Name->Rid mapping key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampBuildAccountKeyName(
                               SampAliasObjectType,
                               &KeyName,
                               NewAccountName
                               );

                if (NT_SUCCESS(NtStatus)) {

                    ULONG AliasRid = Context->TypeBody.Alias.Rid;

                    NtStatus = RtlAddActionToRXact(
                                   SampRXactContext,
                                   RtlRXactOperationSetValue,
                                   &KeyName,
                                   AliasRid,
                                   (PVOID)NULL,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );
                }
            }
        }

        //
        // replace the account's name
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                           Context,
                           SAMP_ALIAS_NAME,
                           NewAccountName
                           );
        }

        //
        // Free up the old account name if we failed
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampFreeUnicodeString(OldAccountName);
        }

    }


    return(NtStatus);
}


NTSTATUS
SampAddMemberToAliasActual(
    IN  PSAMP_OBJECT    AccountContext,
    IN  ULONG           Attribute,
    IN  PSID            MemberId,
    IN  OPTIONAL DSNAME *MemberName
    )
/*++

  Routine Description:

        This Routine does the actual work of adding the member to the Alias
        It does the following

                Updates any Reverse membership List
                Updates the Straight membership List
                Modifies ACL on Member if modification is required

    WARNING     This Routine must be called with the lock held for write access.

  Arguments:

        AccountContext  SAMP_OBJECT describing the Alias
        Attribute       The membership attribute to modify
        MemberId        Sid of Member
        MemberName      Specifies the Member for DS cases

  Return Values:

        STATUS_SUCCESS

--*/

{
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid = 0;
    SAMP_MEMBERSHIP_DELTA   AdminChange = NoChange;
    SAMP_MEMBERSHIP_DELTA   OperatorChange = NoChange;


    //
    // Check the potential new member is OK. This involves validating
    // the group membership rules etc.
    //

    NtStatus = SampValidateNewAliasMember(
                    AccountContext,
                    MemberId,
                    MemberName
                    );

    //
    // In registry mode if the member is being added to an ADMIN alias, we
    // must sure the member ACL(s) don't allow access by account operators.
    // Do not do this is DS mode, this operation is done by a background
    // task -- necessary because of support for nested groups.
    //

    if ( NT_SUCCESS( NtStatus ) && (!IsDsObject(AccountContext))) {
        if ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ADMINS ) {

            AdminChange = AddToAdmin;

        } else if ( ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_SYSTEM_OPS ) ||
                    ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_PRINT_OPS ) ||
                    ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_BACKUP_OPS ) ||
                    ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ACCOUNT_OPS ) ) {

            OperatorChange = AddToAdmin;
        }

        //
        // If either of these are changing, change account operator
        // access to this member
        //

        if ( ( OperatorChange != NoChange ) ||
             ( AdminChange != NoChange ) ) {

            NtStatus = SampChangeAccountOperatorAccessToMember(
                            MemberId,
                            AdminChange,
                            OperatorChange
                            );
        }

    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Perform the account object side of things
        // In registry mode explicit reverse memberships are
        // maintained -- this routine updates that reverse membership
        // DS mode does not maintain explicit reverse memberships,
        // therefore this routine is a No Op in DS mode
        //

        NtStatus = SampAddAliasToAccountMembership(
                       AccountContext,      // Alias Context
                       MemberId             // Member Object SID
                       );


        //
        // Now perform the alias side of things
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the user to the alias (should not fail)
            //

            NtStatus = SampAddAccountToAlias(
                           AccountContext,
                           Attribute,
                           MemberId,
                           MemberName
                           );

        }
    }

    return NtStatus;

}

NTSTATUS
SampRemoveMemberFromAliasActual(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        Attribute,
    IN PSID         MemberId,
    IN DSNAME *     MemberName OPTIONAL
    )
/*++

  Routine Description:

        This Routine does the actual work of removing the member from Alias
        It does the following

                Updates any Reverse membership List
                Updates the Straight membership List
                Modifies ACL on Member if modification is required

    WARNING     This Routine must be called with the lock held for write access.

  Arguments:

        AccountContext  SAMP_OBJECT describing the Alias
        Attribute       The membership attribute to modify
        MemberId        Sid of Member
        MemberName      DSNAME of Member , specifies the member for DS cases.

  Return Values:

        STATUS_SUCCESS

*/
{
    NTSTATUS                NtStatus=STATUS_SUCCESS, TmpStatus, IgnoreStatus;
    ULONG                   ObjectRid = 0;
    ULONG                   MemberRid;
    SAMP_MEMBERSHIP_DELTA   AdminChange = NoChange;
    SAMP_MEMBERSHIP_DELTA   OperatorChange = NoChange;


    //
    // Validate the sid of the member. Block the call for the case of
    // the constant well known Sid's
    // enforce WellKnown Sid check only in DS case.
    // in registry case, since we do not enforce WellKnownSid check when
    // adding a member, so we'd better do not enforce it when delete it.
    //

    if ((MemberId == NULL) || !RtlValidSid(MemberId))
    {
        return STATUS_INVALID_SID;
    }

    //
    // O.k If the account Administrator was being removed from the account Administrators
    // then fail the call, except if it were a trusted client
    //


    if (Attribute == SAMP_ALIAS_MEMBERS) {
        if ((DOMAIN_ALIAS_RID_ADMINS==AccountContext->TypeBody.Alias.Rid)
            && (RtlEqualSid(MemberId,SampAdministratorUserSid))
            && (!AccountContext->TrustedClient))
        {
            return STATUS_SPECIAL_ACCOUNT;
        }
    }

    if (NT_SUCCESS(NtStatus)) {

        //
        // Perform the user object side of things
        //

        NtStatus = SampRemoveAliasFromAccountMembership(
                       AccountContext,  // Alias Context
                       (PSID)MemberId   // Member Object SID
                       );



        //
        // Now perform the alias side of things
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // Remove the user from the alias (should not fail)
            //

            NtStatus = SampRemoveAccountFromAlias(
                           AccountContext,
                           Attribute,
                           (PSID)MemberId,
                           MemberName
                           );

            //
            // If the member is being removed from an ADMIN alias, we must make
            // sure the member ACL(s) allow access by account operators. In the
            // DS case no ACL modification is done, as transitive groups are supported
            // and it is a huge task to do this manually. Instead there is a background
            // task that periodically wakes up and lists out the set of security principals
            // that are members of administrative groups and modifies the security descriptors
            // on them
            //

            if ( NT_SUCCESS( NtStatus ) && (!IsDsObject(AccountContext))) {
                if ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ADMINS ) {

                    AdminChange = RemoveFromAdmin;

                } else if ( ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_SYSTEM_OPS ) ||
                            ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_PRINT_OPS ) ||
                            ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_BACKUP_OPS ) ||
                            ( AccountContext->TypeBody.Alias.Rid == DOMAIN_ALIAS_RID_ACCOUNT_OPS ) ) {

                    OperatorChange = RemoveFromAdmin;
                }

                //
                // If either of these are changing, change account operator
                // access to this member
                //

                if ( ( OperatorChange != NoChange ) ||
                     ( AdminChange != NoChange ) ) {

                    NtStatus = SampChangeAccountOperatorAccessToMember(
                                    MemberId,
                                    AdminChange,
                                    OperatorChange
                                    );
                }

            }
        }
    }



    return NtStatus;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Services Available to NT5 SAM In process clients                        //
//                                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamIAddDSNameToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG        Attribute,
    IN DSNAME   *   DSName
    )
/*++
    Routine Description

        Adds the given DSNAME to membership list of the alias specified by
        Alias Handle

    Arguments:

        AliasHandle -- SAMPR_HANDLE returned by an Open Alias
        Attribute   -- the membership attribute to modify
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             SameDomain;
    BOOLEAN             DifferentDomain;
    BOOLEAN             Not_a_Security_Principal;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName=NULL;

    SAMTRACE("SamIAddDSNameToAlias");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidAddMemberToAlias
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    //
    // Reference the context.
    //

    AccountContext = (PSAMP_OBJECT)(AliasHandle);
    SampReferenceContext(AccountContext);

    if (IsDsObject(AccountContext))
    {
       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {
           if (NULL==Sid)
           {
               //
               // This is the case of a non security principal.
               //

               NtStatus = SampDsAddMembershipOperationToCache(AccountContext,
                                                              Attribute,
                                                              ADD_VALUE,
                                                              ImprovedDSName
                                                              );

               if (NT_SUCCESS(NtStatus))
               {

                   //
                   // Commit Changes
                   //

                   SampCommitAndRetainWriteLock();
               }
           }
           else
           {
               DSNAME    DSNameBuffer;
               BOOLEAN   WellKnownSid = FALSE,
                         BuiltinDomainSid = FALSE,
                         LocalSid = FALSE,
                         ForeignSid = FALSE,
                         EnterpriseSid = FALSE;

               //
               // Check the type of the SID
               //

               NtStatus = SampDsExamineSid(
                                Sid,
                                &WellKnownSid,
                                &BuiltinDomainSid,
                                &LocalSid,
                                &ForeignSid,
                                &EnterpriseSid
                                );
                                

               if ((NT_SUCCESS(NtStatus)) && (ForeignSid || WellKnownSid))
               {
                   //
                   // The passed in DSNAME represents a Foreign or 
                   // WellKnown Sid.  Pass in a SID-only name to the DS
                   // so that the membership will be represented by an FPO
                   //
                   ASSERT(sizeof(DSNameBuffer) >= DSNameSizeFromLen(0));
                   RtlZeroMemory(&DSNameBuffer, sizeof(DSNameBuffer));
                   DSNameBuffer.structLen = DSNameSizeFromLen(0);
                   DSNameBuffer.SidLen = RtlLengthSid(Sid);
                   RtlCopyMemory(&DSNameBuffer.Sid, Sid, DSNameBuffer.SidLen);
                   ImprovedDSName = &DSNameBuffer;

               }

               if (NT_SUCCESS(NtStatus))
               {
                   //
                   // Call the worker routine to add the member to the
                   // local group.
                   //

                   NtStatus = SampAddMemberToAliasActual(
                                    AccountContext,
                                    Attribute,
                                    Sid,
                                    ImprovedDSName
                                    );
               }

           }

       }
    }
    else
    {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToAlias in Registry Mode !!!!");
       NtStatus = STATUS_INVALID_PARAMETER;
    }




    //
    // Dereference the context
    //

    SampDeReferenceContext(AccountContext,FALSE);

    SampTraceEvent(EVENT_TRACE_TYPE_END,
               SampGuidAddMemberToAlias
               );


    return NtStatus;

}

NTSTATUS
SamIRemoveDSNameFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG        Attribute,
    IN DSNAME   *   DSName
    )
/*++
    Routine Description

        Removes the given DSNAME to membership list of the alias specified by
        Alias Handle

    Arguments:

        AliasHandle -- SAMPR_HANDLE returned by an Open Alias
        Attribute   -- the membership attribute to modify
        DSName      -- Pointer to a DSNAME structure. The caller is responsible for
                       Allocating / freeing this structure

    Return Values:

            STATUS_SUCCESS
            Other error codes from DsLayer

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    NTSTATUS            TmpStatus;
    PSAMP_OBJECT        AccountContext;
    SAMP_OBJECT_TYPE    FoundType;
    PSID                Sid = NULL;
    DSNAME              *ImprovedDSName;


    SAMTRACE("SamIRemoveDSNameFromAlias");


    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidRemoveMemberFromAlias
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );


    //
    // Reference the context
    //

    AccountContext = (PSAMP_OBJECT)(AliasHandle);
    SampReferenceContext(AccountContext);

   if (IsDsObject(AccountContext))
   {
       //
       // See what the DSNAME represents.
       //

       NtStatus = SampValidateDSName(
                    AccountContext,
                    DSName,
                    &Sid,
                    &ImprovedDSName
                    );

       if ( NT_SUCCESS(NtStatus))
       {
           if (NULL==Sid)
           {

               //
               // This is the case of a non Security principal,
               // no further checking is required; directly perform the
               // update
               //

               NtStatus = SampDsAddMembershipOperationToCache(AccountContext,
                                                              Attribute,
                                                              REMOVE_VALUE,
                                                              ImprovedDSName
                                                              );


           }
           else
           {
               PDSNAME DSNameToAdd = ImprovedDSName;
               BOOLEAN   WellKnownSid =FALSE,
                         BuiltinDomainSid = FALSE,
                         LocalSid = FALSE,
                         ForeignSid = FALSE,
                         EnterpriseSid = FALSE;

               //
               // Check the type of the SID
               //

               NtStatus = SampDsExamineSid(
                                Sid,
                                &WellKnownSid,
                                &BuiltinDomainSid,
                                &LocalSid,
                                &ForeignSid,
                                &EnterpriseSid
                                );


               if ((NT_SUCCESS(NtStatus)) && (ForeignSid || WellKnownSid ))
               {

                   //
                   // The passed in DSName, could have just the SID field,
                   // filled, in not the GUID or the DSName. The foreignSid,
                   // or WellKnown SID case, require manipulation of corresponding
                   // FPO objects that have the corresponding SIDs. SID positioning
                   // in the DS does not work for FPO objects ( works for all
                   // security principals in the forest -- FPO's represent
                   // security principals in different forests. Therefore resolve
                   // the SID to the DSNAME of the object ie GUID and Name fields
                   // filled in before performing the Remove Member operation.
                   //

                   NtStatus = SampDsObjectFromSid(
                                    Sid,
                                    &DSNameToAdd
                                    );

               }

               if (NT_SUCCESS(NtStatus))
               {
                    //
                    // Call the worker routine to remove the member
                    //

                    NtStatus = SampRemoveMemberFromAliasActual(
                                    AccountContext,
                                    Attribute,
                                    Sid,
                                    DSNameToAdd
                                    );

                    if (ForeignSid || WellKnownSid )
                    {
                        MIDL_user_free(DSNameToAdd);
                        DSNameToAdd = NULL;
                    }
               }
           }

       }

   }
   else
   {
       //
       // Should never expect to hit this call in registry mode
       //

       ASSERT(FALSE && "SamIAddDSNameToAlias in Registry Mode !!!!");
       NtStatus = STATUS_INVALID_PARAMETER;
   }



    //
    // Dereference the context
    //

    SampDeReferenceContext(AccountContext,FALSE);

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromAlias
                   );

    return NtStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\assert.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    assert.c

Abstract:

    This module implements the SampAssert function that is referenced by the
    debugging version of the ASSERT macro defined in sampsrv.h

Author:

    Colin Brace (ColinBr) 06-Aug-1996

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>

#include <samsrvp.h>

#if (SAMP_PRIVATE_ASSERT == 1)

VOID
SampAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

#if defined(USER_MODE_SAM)

    //
    // Here the assumption that if SAM is being run as a standalone process
    // it is being debugged locally so we want the message and breakpoint
    // to be handled locally.
    //

    DbgPrint(
     "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );
   DbgUserBreakPoint();

#else

    //
    // This code works with a remote debugger, which is presumably the
    // debugger of choice when SAM is running as a loaded dll.
    //

    char Response[ 2 ];

    while (TRUE) {
        DbgPrint( "\n*** Assertion failed: %s%s\n***   Source File: %s, line %ld\n\n",
                  Message ? Message : "",
                  FailedAssertion,
                  FileName,
                  LineNumber
                );

        DbgPrompt( "Break, Ignore, Terminate Process or Terminate Thread (bipt)? ",
                   Response,
                   sizeof( Response )
                 );
        switch (Response[0]) {
            case 'B':
            case 'b':
                DbgBreakPoint();
                break;

            case 'I':
            case 'i':
                return;

            case 'P':
            case 'p':
                NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );
                break;

            case 'T':
            case 't':
                NtTerminateThread( NtCurrentThread(), STATUS_UNSUCCESSFUL );
                break;
            }
        }

    DbgBreakPoint();
    NtTerminateProcess( NtCurrentProcess(), STATUS_UNSUCCESSFUL );

#endif  // USER_MODE_SAM

}

#endif // SAMP_PRIVATE_ASSERT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\almember.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    almember.c

Abstract:

    This file contains utilities related to membership of aliases.
    Alternative design


Author:

    Scott Birrell          01-Apr-1993

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsmember.h>
#include <samtrace.h>
#include "validate.h"

#define SAMP_AL_FREE_OLD_LIST                         ((ULONG) 0x00000001L)
#define SAMP_AL_ERROR_IF_MEMBER                       ((ULONG) 0x00000002L)
#define SAMP_AL_ERROR_IF_NOT_MEMBER                   ((ULONG) 0x00000004L)
#define SAMP_AL_ASSIGN_NEW_REFERENCES                 ((ULONG) 0x00000008L)
#define SAMP_AL_LOOKUP_BY_SID                         ((ULONG) 0x00000010L)
#define SAMP_AL_LOOKUP_BY_REFERENCE                   ((ULONG) 0x00000020L)
#define SAMP_AL_VERIFY_NO_ALIASES_IN_ACCOUNT          ((ULONG) 0x00000040L)
#define SAMP_AL_VERIFY_ALL_ALIASES_IN_ACCOUNT         ((ULONG) 0x00000080L)
#define SAMP_AL_VERIFY_NO_MEMBERS_IN_ALIAS            ((ULONG) 0x00000100L)
#define SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS           ((ULONG) 0x00000200L)

#define SAMP_UNKNOWN_INDEX                            ((ULONG) 0xffffffffL)
#define SAMP_AL_ALIAS_LIST_DELTA                      ((ULONG) 0x00000100L)
#define SAMP_AL_ALIAS_DELTA                           ((ULONG) 0x00000040L)
#define SAMP_AL_REFERENCED_DOMAIN_LIST_DELTA          ((ULONG) 0x00000100L)
#define SAMP_AL_INITIAL_MEMBER_ALIAS_LIST_LENGTH      ((ULONG) 0x00001000L)
#define SAMP_AL_MAX_MEMBER_ALIAS_LIST_LENGTH          ((ULONG) 0x00010000L)
#define SAMP_AL_MEMBER_ALIAS_LIST_DELTA               ((ULONG) 0x00001000L)
#define SAMP_AL_INITIAL_REFERENCED_DOMAIN_LIST_LENGTH ((ULONG) 0x00000400L)
#define SAMP_AL_INITIAL_MEMBER_DOMAIN_LENGTH          ((ULONG) 0x00000040L)
#define SAMP_AL_INITIAL_MEMBER_ACCOUNT_ALIAS_CAPACITY ((ULONG) 0x00000004L)
#define SAMP_AL_ENUM_PREFERRED_LENGTH                 ((ULONG) 0x00001000L)
#define SAMP_AL_INITIAL_MEMBERSHIP_COUNT              ((ULONG) 0x0000000aL)
#define SAMP_AL_MEMBERSHIP_COUNT_DELTA                ((ULONG) 0x0000000aL)
#define SAMP_AL_MEMBER_ALIAS_LIST_SIGNATURE           ((ULONG) 0x53494c41)
#define SAMP_AL_MEMBER_DOMAIN_SIGNATURE               ((ULONG) 0x4d4f444d)
#define SAMP_AL_MEMBER_ACCOUNT_SIGNATURE              ((ULONG) 0x4343414d)

#define SAMP_AL_DR_ALIAS_LIST_KEY_NAME   L"Aliases\\Members\\AliasList"
#define SAMP_AL_DR_REFERENCED_DOMAIN_LIST_KEY_NAME \
    L"Aliases\\Members\\ReferencedDomainList"


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private macro functions                                                 //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define SampAlFirstMemberDomain( MemberAliasList )                          \
    (MemberAliasList->MemberDomains)

#define SampAlOffsetFirstMemberDomain( MemberAliasList )                      \
    (ULONG)(((PUCHAR) SampAlFirstMemberDomain(MemberAliasList)) - ((PUCHAR) MemberAliasList))

#define SampAlFirstMemberAccount( MemberDomain )                                \
    ((PSAMP_AL_MEMBER_ACCOUNT)                                                  \
    (((PUCHAR) &((MemberDomain)->DomainSid)) + RtlLengthSid(&((MemberDomain)->DomainSid))))

#define SampAlOffsetFirstMemberAccount( MemberDomain )                      \
    (ULONG)(((PUCHAR) SampAlFirstMemberAccount(MemberDomain)) - ((PUCHAR) MemberDomain))

#define SampAlNextMemberAccount( MemberAccount )                              \
    ((PSAMP_AL_MEMBER_ACCOUNT)(((PUCHAR) MemberAccount) + (MemberAccount)->MaximumLength))

#define SampAlOffsetFirstAlias( OutputMemberAccount )                       \
    ((ULONG) FIELD_OFFSET(SAMP_AL_MEMBER_ACCOUNT, AliasRids))

#define SampAlNextMemberDomain( MemberDomain )                              \
    ((PSAMP_AL_MEMBER_DOMAIN)(((PUCHAR) MemberDomain) + (MemberDomain)->MaximumLength))

#define SampAlNextNewAliasInMemberAccount( MemberAccount )                  \
    ((PULONG)(((PUCHAR) MemberAccount) + (MemberAccount)->UsedLength))

#define SampAlNextNewMemberAccount( MemberDomain )                                          \
    ((PSAMP_AL_MEMBER_ACCOUNT)(((PUCHAR) MemberDomain) + (MemberDomain)->UsedLength))

#define SampAlNextNewMemberDomain( MemberAliasList )                                          \
    ((PSAMP_AL_MEMBER_DOMAIN)(((PUCHAR) MemberAliasList) + (MemberAliasList)->UsedLength))

#define SampAlInfoIsValid(DomainIndex)                                      \
    ((SampDefinedDomains[DomainIndex].AliasInformation.Valid) ||            \
     (SampServiceState == SampServiceInitializing ))

#define SampAlInfoMakeValid(DomainIndex)                                                \
    (SampDefinedDomains[DomainIndex].AliasInformation.Valid = TRUE)

#define SampAlInfoMakeInvalid(DomainIndex)                                  \
    (SampDefinedDomains[DomainIndex].AliasInformation.Valid = FALSE)

#define SampAlDomainIndexToMemberAliasList( DomainIndex )                    \
    ((PSAMP_AL_MEMBER_ALIAS_LIST)                                            \
        SampDefinedDomains[ DomainIndex].AliasInformation.MemberAliasList)

#define SampAlDomainHandleToMemberAliasList( DomainHandle )                  \
    (SampAlDomainIndexToMemberAliasList(((PSAMP_OBJECT) DomainHandle)->DomainIndex))

#define SampAlAliasHandleToMemberAliasList( AliasHandle )                  \
    (SampAlDomainIndexToMemberAliasList(((PSAMP_OBJECT) AliasHandle)->DomainIndex))

#define SampAlMemberDomainToOffset( MemberAliasList, MemberDomain)          \
    (ULONG)(((PUCHAR) MemberDomain) - ((PUCHAR) MemberAliasList))

#define SampAlMemberDomainFromOffset( MemberDomain, MemberDomainOffset)  \
    ((PSAMP_AL_MEMBER_DOMAIN)(((PUCHAR) MemberDomain) + MemberDomainOffset))

#define SampAlMemberAccountToOffset( MemberDomain, MemberAccount)          \
    (ULONG)(((PUCHAR) MemberAccount) - ((PUCHAR) MemberDomain))

#define SampAlMemberAccountFromOffset( MemberDomain, MemberAccountOffset)  \
    ((PSAMP_AL_MEMBER_ACCOUNT)(((PUCHAR) MemberDomain) + MemberAccountOffset))

#define SampAlLengthRequiredMemberAccount( AliasCapacity )             \
    (sizeof(SAMP_AL_MEMBER_ACCOUNT) + ((AliasCapacity - 1) * sizeof(ULONG)))

#define SampAlUpdateMemberAliasList( AliasHandle, MemberAliasList )    \
    {                                                                  \
        PSAMP_OBJECT InternalAliasHandle = (PSAMP_OBJECT) AliasHandle; \
        SampDefinedDomains[InternalAliasHandle->DomainIndex].AliasInformation.MemberAliasList \
            = MemberAliasList;                                         \
    }

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Datatypes                                                               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// This datatype is not currently used.  It may be used if Alias information
// is every stored to Registry Keys.
//

typedef enum _SAMP_AL_LIST_TYPE {

    SampAlMemberAliasList = 1

} SAMP_AL_LIST_TYPE, *PSAMP_AL_LIST_TYPE;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Static Data                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

UNICODE_STRING SampAlDrMemberAliasListKeyName;
BOOLEAN SampAlEnableBuildingOfList[SAMP_DEFINED_DOMAINS_COUNT] = { TRUE, TRUE };

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Prototypes of functions private to this module                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampAlCreateMemberAliasList(
    IN LONG DomainIndex,
    IN ULONG InitialMemberAliasListLength,
    OUT OPTIONAL PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList
    );

NTSTATUS
SampAlGrowMemberAliasList(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG ExtraSpaceRequired
    );

NTSTATUS
SampAlRebuildMemberAliasList(
    IN PVOID Parameter
    );

NTSTATUS
SampAlBuildMemberAliasList(
    IN LONG DomainIndex
    );

NTSTATUS
SampAlFreeMemberAliasList(
    IN PVOID Parameter
    );

NTSTATUS
SampAlInvalidateMemberAliasList(
    IN ULONG DomainIndex
    );

NTSTATUS
SampAlCreateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    );

NTSTATUS
SampAlAllocateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG MaximumLengthMemberDomain,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    );

NTSTATUS
SampAlGrowMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG ExtraSpaceRequired
    );

NTSTATUS
SampAlDeleteMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN MemberDomain
    );

NTSTATUS
SampAlLookupMemberDomain(
    IN PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList,
    IN PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    );

NTSTATUS
SampAlCreateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG Rid,
    IN ULONG AliasCapacity,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    );

NTSTATUS
SampAlAllocateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG MaximumLengthMemberAccount,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    );

NTSTATUS
SampAlGrowMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG ExtraSpaceRequired
    );

NTSTATUS
SampAlDeleteMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    OUT    PBOOLEAN                MemberDomainDeleted
    );

NTSTATUS
SampAlLookupMemberAccount(
    IN PSAMP_AL_MEMBER_DOMAIN MemberDomain,
    IN ULONG MemberRid,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    );

NTSTATUS
SampAlAddAliasesToMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids
    );

NTSTATUS
SampAlRemoveAliasesFromMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT    PBOOLEAN MemberDomainDeleted,
    OUT    PBOOLEAN MemberAccountDeleted
    );

NTSTATUS
SampAlLookupAliasesInMemberAccount(
    IN PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT PULONG ExistingAliasCount
    );

NTSTATUS
SampAlSplitMemberSids(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids,
    OUT PSAMP_AL_SPLIT_MEMBER_SID_LIST SplitMemberSids
    );

BOOLEAN
SampAlInfoIsValidForDomain(
    IN SAMPR_HANDLE DomainHandle
    );

BOOLEAN
SampAlInfoIsValidForAlias(
    IN SAMPR_HANDLE AliasHandle
    );

VOID
SampInvalidateAliasNameCache(
    ULONG DomainIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Code of Exported Routines                                                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamrGetAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    )

/*++

Routine Description:

    This API searches the set of aliases in the specified domain to see
    which aliases, if any, the passed SIDs are members of.  Any aliases
    that any of the SIDs are found to be members of are returned.

    Note that any particular alias will appear only once in the returned list.

Parameters:

    DomainHandle - Handle from a SamOpenDomain call.

    PassedCount - Specifies the number of Sids being passed.

    Sids - Pointer to an arrray of Count pointers to Sids whose alias
        memberships are to be looked up.

    Membership - receives the array of rids rerpresenting the aliases
        in this domain that any of the sid(s) are members of.

Return Values:

    STATUS_SUCCESS - The combined alias membership is in Membership

    STATUS_INVALID_SID - One of the passed sids was invalid

--*/

{
    NTSTATUS                NtStatus=STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT            DomainContext = NULL;
    SAMP_OBJECT_TYPE        FoundType;
    ULONG                   i;
    ULONG                   SidCount;
    PSID                    *Sids;
    BOOLEAN                 ObjectReferenced = FALSE;
    BOOLEAN                 LockAttempted = FALSE;
    BOOLEAN                 LockHeld = FALSE;
    DSNAME                  **DsNameArray = NULL;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrGetAliasMembership");

    //
    // WMI Event Trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetAliasMembership
                   );


    ASSERT(Membership != NULL);
    ASSERT(Membership->Element == NULL);

    SidCount = SidArray->Count;
    Sids = (PSID *)(SidArray->Sids);

    //
    //  Validate Parameters
    //

    if( !SampValidateSIDArray( SidArray ) ) {

        NtStatus = STATUS_INVALID_PARAMETER;
        goto GetAliasMembershipFinish;
    }

    if ((0 == SidCount) || (NULL == Sids))
    {
        //
        // Nothing to resolve. Set return value properly.
        //

        Membership->Element = NULL;
        Membership->Count = 0;

        goto GetAliasMembershipFinish;
    }

    //
    // Resolve any Sids for the DS case. This function is a
    // No-Op for the non-DS case.
    //

    NtStatus = SampDsResolveSids(
                    (PSID) SidArray->Sids,
                    SidArray->Count,
                    RESOLVE_SIDS_SID_ONLY_NAMES_OK,
                    &DsNameArray
                    );

    if (NT_SUCCESS(NtStatus))
    {

        DomainContext = (PSAMP_OBJECT)DomainHandle;



        //
        // Grab the lock
        //

        SampMaybeAcquireReadLock(DomainContext,
                                 DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                                 &LockHeld);
        LockAttempted = TRUE;




        //
        // Validate type of, and access to object.
        //

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_GET_ALIAS_MEMBERSHIP,
                        SampDomainObjectType,
                        &FoundType
                        );

        if (STATUS_ACCESS_DENIED == NtStatus)
        {
            //
            // Fix Bug 403247. The NT4 Code checks DOMAIN_LOOKUP
            // access right, instead of GET_ALIAS_MEMBERSHIP.
            // We are correcting this by checking GET_ALIAS_MEMBERSHIP
            // first. But for backwards compatibility, we have to give
            // the caller a second try if they fail due to access denied.
            //

            if (SampCurrentThreadOwnsLock())
            {
                if(SampTransactionWithinDomain)
                {
                    // before calling into SampLookupContext again,
                    // we need to make sure TranactionWithinDomain is
                    // not set.
                    SampSetTransactionWithinDomain(FALSE);
                }
            }
            NtStatus = SampLookupContext(
                            DomainContext,
                            DOMAIN_LOOKUP,
                            SampDomainObjectType,
                            &FoundType
                            );
        }

        if (!NT_SUCCESS(NtStatus)) {

            goto GetAliasMembershipError;
        }

        ObjectReferenced = TRUE;

        //
        // Validate the Sids.  if any are invalid, return an error.
        //

        for (i=0; i < SidCount; i++) {

            //
            // Check for valid sid
            //

            if ( (Sids[i] == NULL) || !RtlValidSid(Sids[i]) ) {

                NtStatus = STATUS_INVALID_SID;
                break;
            }
        }

        if (!NT_SUCCESS(NtStatus)) {

            goto GetAliasMembershipError;
        }

        //
        // If the in-memory Alias Membership information for this domain is valid,
        // use it to retrieve the Alias members.
        //

        if (SampAlInfoIsValidForDomain(DomainHandle)) {

            SampDiagPrint(LOGON,("[SAMSS]   SampAlQueryAliasMembership\n"));
            NtStatus = SampAlQueryAliasMembership(
                           DomainHandle,
                           SidArray,
                           Membership
                           );
        } else {

            SampDiagPrint(LOGON,("[SAMSS]   SampAlSlowQueryAliasMembership\n"));
            NtStatus = SampAlSlowQueryAliasMembership(
                           DomainHandle,
                           SidArray,
                           DsNameArray,
                           Membership
                           );
        }



    }

GetAliasMembershipFinish:

    //
    // If necessary, dereference the SAM server object.
    //

    if (ObjectReferenced)
    {
        IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );
    }


    //
    // Free the read lock if required. Also ends transactions
    //

    if (LockAttempted)
    {
         SampMaybeReleaseReadLock(LockHeld);
    }

    //
    // Release any memory associated with the DSNAME array
    //

    if (NULL!=DsNameArray)
    {
        for (i=0; i<SidCount;i++)
        {
            if (NULL!=DsNameArray[i])
            {
                MIDL_user_free(DsNameArray[i]);
            }

        }

        MIDL_user_free(DsNameArray);
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetAliasMembership
                   );

    return(NtStatus);

GetAliasMembershipError:


    goto GetAliasMembershipFinish;
}


NTSTATUS
SampAlQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    OUT PSAMPR_ULONG_ARRAY Membership
    )

/*++

Routine Description:

    This function is one of two worker routines for the SamrGetAliasMembership
    API.  This worker uses the Member Alias List to determine which aliases,
    if any, the passed SIDs are members of.  Any aliases that any of the SIDs
    are found to be members of are returned.

    Note that any particular alias will appear only once in the returned list.

    See also SampAlSlowQueryAliasMembership()

    WARNING:  The SAM Read Lock must be held while this function executes.

Parameters:

    DomainHandle - Handle from a SamrOpenDomain call.

    SidArray - Pointer to a counted array of pointers to Sids whose alias
        memberships are to be looked up.

    Membership - Receives the array of rids rerpresenting the aliases
        in this domain that any of the sid(s) are members of.

Return Values:

    STATUS_SUCCESS - The combined alias membership is in Membership

    STATUS_INVALID_SID - One of the passed sids was invalid

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    ULONG Rid, AliasRid;
    ULONG AliasIndex, SidIndex;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN AliasAlreadyFound;
    ULONG AliasFoundIndex, MembershipMaximumCount;
    PSID DomainSid = NULL;
    PSID Sid = NULL;
    PULONG NewMembership = NULL;

    SAMTRACE("SampAlQueryAliasMembership");

    Membership->Count = 0;
    Membership->Element = NULL;

    //
    // Obtain pointer to Alias Member List.
    //

    MemberAliasList = SampAlDomainHandleToMemberAliasList( DomainHandle );

    ASSERT(MemberAliasList != NULL);

    //
    // If there are no Member Domains in this Member Alias List, then just
    // finish.
    //

    if (MemberAliasList->DomainCount == 0) {

        goto QueryAliasMembershipFinish;
    }

    //
    // Allocate Scratch Sid buffer.  We will use this same buffer for splitting
    // each Sid.
    //

    DomainSid = MIDL_user_allocate( RtlLengthRequiredSid( 256 ));

    Status = STATUS_NO_MEMORY;

    if (DomainSid == NULL) {

        goto QueryAliasMembershipError;
    }

    Status = STATUS_SUCCESS;

    //
    // Allocate output array with a nominal initial size.  Reallocate it
    // as necessary
    //

    MembershipMaximumCount = SAMP_AL_INITIAL_MEMBERSHIP_COUNT;

    Membership->Element = MIDL_user_allocate( MembershipMaximumCount * sizeof(ULONG));

    Status = STATUS_NO_MEMORY;

    if (Membership->Element == NULL) {

        goto QueryAliasMembershipError;
    }

    Status = STATUS_SUCCESS;

    //
    // Now query the membership of the array of split Sids.  For each
    // Sid, we skip the Sid if it has an unknown MemberDomain, because
    // it does not belong to any aliases.  For each surviving Sid, we scan the
    // Alias List, skipping entries for aliases we've already entered in the
    // output list.  We search for the Rid only in the section of the
    // Alias List pertinent to the Sid's domain.
    //

    for (SidIndex = 0; SidIndex < SidArray->Count; SidIndex++) {

        Sid = SidArray->Sids[ SidIndex ].SidPointer;

        //
        // Split this Sid into a DomainSid and a Rid.  Note that we re-use
        // the buffer containing the Domain Sid for the next Sid.
        //

        Status = SampSplitSid( Sid, &DomainSid, &Rid);

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Search the Member Alias List for the Sid's Member Domain
        // (if any).
        //

        Status = SampAlLookupMemberDomain(
                     MemberAliasList,
                     DomainSid,
                     &MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // The only expected error is STATUS_NO_SUCH_DOMAIN.  If we
            // don't get this error, fail the request.  Otherwise, the
            // Sid is not a member of any aliases in the SAM local domain, so
            // just skip to the next Sid.
            //

            if (Status != STATUS_NO_SUCH_DOMAIN) {

                break;
            }

            Status = STATUS_SUCCESS;
            continue;
        }

        //
        // We've found the Member Domain.  Now find the Member Account.
        //

        Status = SampAlLookupMemberAccount(
                     MemberDomain,
                     Rid,
                     &MemberAccount
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // The only expected error is STATUS_NO_SUCH_MEMBER.  If we
            // don't get this error, fail the request.  Otherwise, the
            // Sid is not a member of any aliases in the domain, so just
            // skip to the next Sid.
            //

            if (Status != STATUS_NO_SUCH_MEMBER) {

                break;
            }

            Status = STATUS_SUCCESS;
            continue;
        }

        //
        // We've found the Member Account.  For each of the aliases our Sid
        // belongs to, add the alias to the output list if not already there.
        //

        for (AliasIndex = 0; AliasIndex < MemberAccount->AliasCount; AliasIndex++) {

            AliasRid = MemberAccount->AliasRids[AliasIndex];

            AliasAlreadyFound = FALSE;

            for (AliasFoundIndex = 0;
                 AliasFoundIndex < Membership->Count;
                 AliasFoundIndex++) {

                if (AliasRid == Membership->Element[AliasFoundIndex]) {

                   AliasAlreadyFound = TRUE;
                   break;
                }
            }

            if (!AliasAlreadyFound) {

                //
                // If there isn't enough room in the output Membership
                // array, reallocate it.
                //

                if (Membership->Count == MembershipMaximumCount) {

                    MembershipMaximumCount += SAMP_AL_MEMBERSHIP_COUNT_DELTA;

                    NewMembership = MIDL_user_allocate(
                                        MembershipMaximumCount * sizeof(ULONG)
                                        );

                    Status = STATUS_NO_MEMORY;

                    if (NewMembership == NULL) {

                        break;
                    }

                    Status = STATUS_SUCCESS;

                    RtlMoveMemory(
                        NewMembership,
                        Membership->Element,
                        Membership->Count * sizeof(ULONG)
                        );

                    MIDL_user_free( Membership->Element);
                    Membership->Element = NewMembership;
                }

                Membership->Element[Membership->Count] = AliasRid;
                Membership->Count++;
            }
        }
    }

    //
    // If the buffer we've allocated turns out to be way overboard, allocate
    // a smaller one for the output.
    //

    // TBS

QueryAliasMembershipFinish:

    //
    // If we got as far as allocating a buffer for the DomainSids, free it.
    //

    if (DomainSid != NULL) {

        MIDL_user_free(DomainSid);
        DomainSid = NULL;
    }

    return(Status);

QueryAliasMembershipError:

    //
    // If necessary, free the output membership array.
    //

    if (Membership->Element != NULL) {

        MIDL_user_free( Membership->Element);
        Membership->Element = NULL;
    }

    goto QueryAliasMembershipFinish;
}


NTSTATUS
SampAlSlowQueryAliasMembership(
    IN SAMPR_HANDLE DomainHandle,
    IN PSAMPR_PSID_ARRAY SidArray,
    IN DSNAME   **DsNameArray OPTIONAL,
    OUT PSAMPR_ULONG_ARRAY Membership
    )

/*++

Routine Description:

    This function is the slow version of the worker routine for the
    SamrGetAliasMembership API searches.  It is called when the in-memory
    Alias Information is no longer valid.

    The NT4 version of this function used to make 2 passes at obtaining
    the reverse membership, the first phase will evaulate the reverse
    membership but use the results only to compute the amount of memory
    required, and the second phase will compute the reverse membership
    again, this time filling the buffer. This was acceptable in the NT4 version
    as the slow flavour routine was only used to build the alias membership
    cache and then logons were serviced from the cache.

    In the DS version there is no cache. So it is important that this routine
    be as fast as possible. Therefore this routine pre-allocates a chunk of memory
    and then tries to fill the buffer with the reverse membership. If the reverse
    membership is bigger than a certain number of entries then the call will fail
    with STATUS_TOO_MANY_CONTEXT_IDS. This in reality is not a problem as the
    logon token itself allows only about 1000 entries for Sids, and a reverse
    membership list bigger than that will anyway never fit into the token. Thus by
    allocating sufficient memory at the outset we can avoid evaluating reverse memberships
    twice without any real penalties

    WARNING! The caller of this function must hold the SAM Database Read
    Lock.

Parameters:

    DomainHandle - Handle from a SamOpenDomain call.

    SidArray - Pointer to a counted array of pointers to Sids whose alias
        memberships are to be looked up.

    DsNameArray - Pointer to an array of pointers to DSNm
    Membership - Receives the array of rids rerpresenting the aliases
        in this domain that any of the sid(s) are members of.

Return Values:

    STATUS_SUCCESS - The combined alias membership is in Membership

    STATUS_INVALID_SID - One of the passed sids was invalid

    STATUS_TOO_MANY_CONTEXT_IDS - The reverse membership list is too big to fit in a token

--*/

{
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   i;
    ULONG                   MembershipCount;
    ULONG                   TotalMembershipCount;
    ULONG                   MembershipIndex;
    ULONG                   BufferSize;
    ULONG                   TotalBufferSize;
    ULONG                   SidCount = SidArray->Count;
    PSID                    *Sids = (PSID *) &SidArray->Sids->SidPointer;

    SAMTRACE("SampAlSlowQueryAliasMembership");

    //
    // We preallocate a buffer of upto MAX_SECURITY_IDS defined in samsrvp.h If we reach
    // a buffer overflow condition we fail the call saying STATUS_TOO_MANY_CONTEXT_IDS
    //

    TotalMembershipCount = 0;
    TotalBufferSize = MAX_SECURITY_IDS * sizeof(ULONG);


    Membership->Element = MIDL_user_allocate(TotalBufferSize);

    if (Membership->Element == NULL)
    {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    }
    else
    {

        //
        // Fill in the allocated membership list
        //

        MembershipIndex = 0;

        for (i=0; i < SidCount; i++)
        {

            //
            // Get the membership list for this account
            //

            BufferSize = TotalBufferSize;

            if (IsDsObject(((PSAMP_OBJECT)DomainHandle)))
            {
                //
                // Ds mode, call the Ds API
                //

                ASSERT(ARGUMENT_PRESENT(DsNameArray));

                NtStatus = SampDsGetAliasMembershipOfAccount(
                            ((PSAMP_OBJECT)DomainHandle)->ObjectNameInDs,
                            DsNameArray[i],
                            &MembershipCount,
                            &BufferSize,
                            &(Membership->Element[MembershipIndex])
                            );
            }
            else
            {

                //
                // Call the registry API
                //

                ASSERT(SampCurrentThreadOwnsLock());
                ASSERT(TRUE==SampTransactionWithinDomain);
                ASSERT(SampTransactionDomainIndex==
                            ((PSAMP_OBJECT)DomainHandle)->DomainIndex);

                NtStatus = SampRetrieveAliasMembership(
                                Sids[i],
                                ARGUMENT_PRESENT(DsNameArray)?DsNameArray[i]:NULL,
                                &MembershipCount,
                                &BufferSize,
                                &(Membership->Element[MembershipIndex])
                                );
            }

            if (STATUS_BUFFER_OVERFLOW==NtStatus)
            {

                //
                // Buffer Overrun
                //

                NtStatus = STATUS_TOO_MANY_CONTEXT_IDS;
            }

            if (STATUS_OBJECT_NAME_NOT_FOUND==NtStatus)
            {
                //
                // If the object name was not found, its probaly O.K.
                // just that the Sid is not a member of anything. So
                // continue
                //
                NtStatus = STATUS_SUCCESS;
                continue;
            }
            else if (!NT_SUCCESS(NtStatus))
            {
                break;
            }

            ASSERT(BufferSize == (MembershipCount * sizeof(*(Membership->Element))));

            //
            // Remove duplicate aliases.
            // Membership Count is the number of members that were obtained in this call.
            // TotalShip is the total that we have found so far.
            //

            if (MembershipCount > 0)
            {

                ULONG   ExistingIndex, NewIndex;

                for (ExistingIndex = 0; ExistingIndex < MembershipIndex; ExistingIndex ++)
                {
                    //
                    // Walk through All existing reverse members
                    //

                    for (NewIndex = MembershipIndex; NewIndex < MembershipIndex + MembershipCount; NewIndex ++)
                    {

                        //
                        // Walk through all newly retrieved reverse members
                        //

                        if (Membership->Element[ExistingIndex]==Membership->Element[NewIndex])
                        {

                            //
                            // This alias is already in the list - forget it
                            //

                            //
                            // The way we forget is as follows, move the last element to the current one
                            // and decrement the current one such that we revisit the current element again.
                            //

                            if (NewIndex < MembershipIndex + MembershipCount - 1)
                            {

                                //
                                // Remove the duplicate alias
                                //

                                Membership->Element[NewIndex] =
                                  Membership->Element[MembershipIndex + MembershipCount - 1];

                                NewIndex --;    // So we come back to this alias again
                            }

                            MembershipCount --;
                        }

                    }
                }
            }

            MembershipIndex += MembershipCount;
            TotalMembershipCount = MembershipIndex;

            ASSERT(TotalBufferSize >= BufferSize);

            TotalBufferSize -= BufferSize;
        }

        if (!NT_SUCCESS(NtStatus)) {
            MIDL_user_free(Membership->Element);
            Membership->Element = NULL;
        } else {
            Membership->Count = TotalMembershipCount;
            if (0 == Membership->Count)
            {
                MIDL_user_free(Membership->Element);
                Membership->Element = NULL;
            }
        }
    }

    return NtStatus;
}


NTSTATUS
SampAlQueryMembersOfAlias(
    IN SAMPR_HANDLE AliasHandle,
    OUT PSAMPR_PSID_ARRAY MemberSids
    )

/*++

Routine Description:

    This function returns an array of Sids of accounts that are members of
    a specified alias.

Arguments:

    AliasHandle - Handle to an Alias object

    MemberSids - Receives an array of Sids that belong to the Alias

Return Value:

--*/

{
    NTSTATUS Status;
    PSID *Members = NULL;
    ULONG AliasMemberCount;

    SAMTRACE("SampAlQueryMembersOfAlias");

    Status = SampRetrieveAliasMembers(
                 AliasHandle,
                 &AliasMemberCount,
                 &Members
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryMembersOfAliasError;
    }

QueryMembersOfAliasFinish:

    MemberSids->Count = AliasMemberCount;
    MemberSids->Sids = (PSAMPR_SID_INFORMATION) Members;
    return(Status);

QueryMembersOfAliasError:

    AliasMemberCount = 0;
    Members = NULL;
    goto QueryMembersOfAliasFinish;
}


NTSTATUS
SampAlAddMembersToAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    )

/*++

Routine Description:

    This function adds one or more member to an alias.  Any failure results
    in the in-memory Alias Information being discarded.

    WARNING:  The calling function must perform all parameter validation and
    the SAM Database Write Lock must be held.

Parameters:

    AliasHandle - The handle of an opened alias to operate on.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_NO_MEMBERS_IN_ALIAS - Verify that none of the
            Members are already present in the Alias.

    MemberSids - Array of member Sids to be added.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_MEMBER_IN_ALIAS - The member already belongs to the alias.

--*/

{
    NTSTATUS Status=STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_ALIAS_LIST OldMemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    ULONG AliasRid = ((PSAMP_OBJECT) AliasHandle)->TypeBody.Alias.Rid;
    ULONG MemberRid, SidIndex, MembershipCount;
    PSID DomainSid = NULL;
    PSID MemberSid = NULL;
    SAMPR_ULONG_ARRAY AliasRids;

    SAMTRACE("SampAlAddMembersToAlias");

    AliasRids.Count = 0;
    AliasRids.Element = NULL;

    //
    // In Registry Mode, verify that the cached Alias Membership information is valid.
    // In DS Mode, it is NO-OP. but we would like to ASSERT MemberAliasList is invalid.
    // The reason is:
    //
    //     Registry Mode: We need to update MemeberAliasList.
    //                    Before update, MemberAliasList should be valid.
    //     DS Mode: We NEVER update on MemberAliasList.
    //              The ONLY chance we will call this function is because
    //              we want to build MemberAliasList from scratch.
    //
    //

    if ( IsDsObject(((PSAMP_OBJECT)AliasHandle)) )
    {
        ASSERT( FALSE == SampAlInfoIsValidForAlias(AliasHandle) );
    }
    else
    {
        if (!SampAlInfoIsValidForAlias(AliasHandle))
        {
            goto AddMembersToAliasFinish;
        }
    }

    if (!SampAlInfoIsValidForAlias(AliasHandle) &&
        !IsDsObject(((PSAMP_OBJECT)AliasHandle)) ) {
       goto AddMembersToAliasFinish;
    }

    //
    // If requested, verify that none of members already belong to the alias
    //

    if (Options & SAMP_AL_VERIFY_NO_MEMBERS_IN_ALIAS) {

        Status = SampAlLookupMembersInAlias(
                     AliasHandle,
                     AliasRid,
                     MemberSids,
                     &MembershipCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddMembersToAliasError;
        }

        Status = STATUS_MEMBER_NOT_IN_ALIAS;

        if (MembershipCount > 0) {

            goto AddMembersToAliasError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Allocate Scratch Sid buffer.  We will use this same buffer for splitting
    // each Sid.
    //

    DomainSid = MIDL_user_allocate( RtlLengthRequiredSid( 256 ));

    Status = STATUS_NO_MEMORY;

    if (DomainSid == NULL) {

        goto AddMembersToAliasError;
    }

    Status = STATUS_SUCCESS;

    //
    // Obtain pointer to Member Alias List.
    //

    MemberAliasList = SampAlAliasHandleToMemberAliasList( AliasHandle );

    if (NULL == MemberAliasList)
    {
        //
        // There should be only two possible cases under which 
        // MemberAliasList is NULL
        // 
        // 1. someone calls this routine before Alias Members Information cache
        //    gets initialized. (This should NEVER happen.)
        // 
        // 2. on domain controller, SAM is in DS mode, Builtin Domain alias 
        //    member information has been initialized, but during system 
        //    startup time, SAM switches to Registry mode to upgrade DS SAFE
        //    (restore) mode database. In this particular case, registry mode
        //    domains (in SampDefinedDomains[]) Alias Members Information cache
        //    has not been initialized. But we should not error out, because 
        //    we don't need or use SAFE boot hive in DS mode.
        //    --- Some may ask what if we boot into DS SAFE (restore) boot? in
        //        really SAFE boot case, the registry mode domains (in 
        //        SampDefinedDomains[]) will be initialized before anyone calls
        //        into this routine, we should never hit this in registry mode.
        //

        goto AddMembersToAliasFinish;
    }

    OldMemberAliasList = MemberAliasList;

    //
    // For each Sid, obtain its DomainSid and Rid.  Then lookup its
    // DomainSid to obtain the MemberDomain, creating one if necessary.
    // Then lookup its Rid to obtain its MemberAccount, creating one
    // if necessary.  Then add the Alias to the MemebrAccount.
    //

    for (SidIndex = 0; SidIndex < MemberSids->Count; SidIndex++ ) {

        MemberSid = MemberSids->Sids[ SidIndex ].SidPointer;

        Status = SampSplitSid( MemberSid, &DomainSid, &MemberRid );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Lookup the Member Domain for this DomainSid in the Member Alias
        // List.
        //

        Status = SampAlLookupMemberDomain(
                     MemberAliasList,
                     DomainSid,
                     &MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_SUCH_DOMAIN) {

                break;
            }

            Status = STATUS_SUCCESS;

            //
            // The Member Domain was not found.  Create a new Member Domain
            //

            Status = SampAlCreateMemberDomain(
                         &MemberAliasList,
                         DomainSid,
                         &MemberDomain
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Create a Member Account entry.
            //

            Status = SampAlCreateMemberAccount(
                         &MemberAliasList,
                         &MemberDomain,
                         MemberRid,
                         SAMP_AL_INITIAL_MEMBER_ACCOUNT_ALIAS_CAPACITY,
                         &MemberAccount
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

        } else {

            //
            // We found the domain.  This means that we have to lookup
            // each Member Account.  If a Member Account does not exist,
            // we'll create one.  Note that we may already have one due
            // to this account being a member of another Alias.
            //

            Status = SampAlLookupMemberAccount(
                         MemberDomain,
                         MemberRid,
                         &MemberAccount
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_NO_SUCH_MEMBER) {

                    break;
                }

                //
                // Create a Member Account for this Rid,
                //

                Status = SampAlCreateMemberAccount(
                             &MemberAliasList,
                             &MemberDomain,
                             MemberRid,
                             SAMP_AL_INITIAL_MEMBER_ACCOUNT_ALIAS_CAPACITY,
                             &MemberAccount
                             );

                if (!NT_SUCCESS(Status)) {

                    break;
                }
            }
        }

        //
        // We now have a MemberAccount.  Now add the Alias to it.
        //

        AliasRids.Count = 1;
        AliasRids.Element = &AliasRid;

        Status = SampAlAddAliasesToMemberAccount(
                     &MemberAliasList,
                     &MemberDomain,
                     &MemberAccount,
                     0,
                     &AliasRids
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Deal with next Member Sid for the Alias.
        //
    }



    //
    // If the Member Alias List has been reallocated, store its new address.
    //

    if (MemberAliasList != OldMemberAliasList) {

        SampAlUpdateMemberAliasList( AliasHandle, MemberAliasList );
    }

    if (!NT_SUCCESS(Status)) {

        goto AddMembersToAliasError;
    }

AddMembersToAliasFinish:

    //
    // If necessary, free the DomainSid.
    //

    if (DomainSid != NULL) {

        MIDL_user_free( DomainSid );
        DomainSid = NULL;
    }

    return(Status);

AddMembersToAliasError:

    goto AddMembersToAliasFinish;
}


NTSTATUS
SampAlRemoveMembersFromAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG Options,
    IN PSAMPR_PSID_ARRAY MemberSids
    )

/*++

Routine Description:

    This function removes a list of members from an Alias.

Arguments:

    AliasHandle - The handle of an opened alias to operate on.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS - Verify that all of the
            Members belong to the Alias.

    MemberSids - Array of member Sids to be removed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_ALIAS_LIST OldMemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN MemberDomainDeleted;
    BOOLEAN MemberAccountDeleted;
    ULONG AliasRid = ((PSAMP_OBJECT) AliasHandle)->TypeBody.Alias.Rid;
    ULONG MemberRid, SidIndex, MembershipCount;
    PSID DomainSid = NULL;
    PSID MemberSid = NULL;
    SAMPR_ULONG_ARRAY AliasRids;

    SAMTRACE("SampAlRemoveMembersFromAlias");

    AliasRids.Count = 0;
    AliasRids.Element = NULL;

    //
    // If requested, verify that all of members already belong to the alias
    //

    if (Options & SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS) {

        Status = SampAlLookupMembersInAlias(
                     AliasHandle,
                     AliasRid,
                     MemberSids,
                     &MembershipCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto RemoveMembersFromAliasError;
        }

        Status = STATUS_MEMBER_NOT_IN_ALIAS;

        if (MembershipCount < MemberSids->Count) {

            goto RemoveMembersFromAliasError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Obtain pointer to Member Alias List.
    //

    MemberAliasList = SampAlAliasHandleToMemberAliasList( AliasHandle );

    OldMemberAliasList = MemberAliasList;

    if (!NT_SUCCESS(Status)) {

        goto RemoveMembersFromAliasError;
    }

    if (NULL!=MemberAliasList)
    {
        //
        //  Go further only if our cache is functioning
        //

        //
        // For each Sid, obtain its DomainSid and Rid.  Then lookup its
        // DomainSid to obtain the MemberDomain.  Then lookup its Rid to obtain
        // its MemberAccount.  Then remove the Alias from the MemberAccount.
        //

        for (SidIndex = 0; SidIndex < MemberSids->Count; SidIndex++ ) {

            MemberSid = MemberSids->Sids[ SidIndex ].SidPointer;

            Status = SampSplitSid( MemberSid, &DomainSid, &MemberRid );
            if (!NT_SUCCESS(Status))
            {
                break;
            }

            //
            // Lookup the Member Domain for this DomainSid in the Member Alias
            // List.
            //

            Status = SampAlLookupMemberDomain(
                         MemberAliasList,
                         DomainSid,
                         &MemberDomain
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_MEMBER_NOT_IN_ALIAS) {

                    break;
                }

                if (Options & SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS) {

                    ASSERT( FALSE );
                }

                Status = STATUS_SUCCESS;
                if (NULL!=DomainSid)
                {
                    MIDL_user_free(DomainSid);
                    DomainSid = NULL;
                }
                continue;
            }

            //
            // We found the domain.  This means that we have to lookup
            // each Member Account.  If a Member Account does not exist,
            // we'll just skip this account unless we already checked existence.
            // If we checked existence and we can't find it now, its an
            // internal error.
            //

            Status = SampAlLookupMemberAccount(
                         MemberDomain,
                         MemberRid,
                         &MemberAccount
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_MEMBER_NOT_IN_ALIAS) {

                    break;
                }

                if (Options & SAMP_AL_VERIFY_ALL_MEMBERS_IN_ALIAS) {

                    ASSERT( FALSE);
                }

                Status = STATUS_SUCCESS;
                if (NULL!=DomainSid)
                {
                    MIDL_user_free(DomainSid);
                    DomainSid = NULL;
                }
                continue;
            }

            //
            // We now have the MemberAccount.  Now remove the Alias from it.
            //

            AliasRids.Count = 1;
            AliasRids.Element = &AliasRid;

            Status = SampAlRemoveAliasesFromMemberAccount(
                         &MemberAliasList,
                         &MemberDomain,
                         &MemberAccount,
                         0,
                         &AliasRids,
                         &MemberDomainDeleted,
                         &MemberAccountDeleted
                         );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Deal with next Member Sid for the Alias.
            //

            MIDL_user_free( DomainSid );
            DomainSid = NULL;
        }

        if (!NT_SUCCESS(Status)) {

            goto RemoveMembersFromAliasError;
        }

        //
        // If the Member Alias List has been reallocated, store its new address.
        //

        if (MemberAliasList != OldMemberAliasList) {

            SampAlUpdateMemberAliasList( AliasHandle, MemberAliasList );
        }
    }



RemoveMembersFromAliasFinish:

    return(Status);

RemoveMembersFromAliasError:

    if (NULL!=DomainSid)
        MIDL_user_free(DomainSid);

    goto RemoveMembersFromAliasFinish;
}


NTSTATUS
SampAlLookupMembersInAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN ULONG AliasRid,
    IN PSAMPR_PSID_ARRAY MemberSids,
    OUT PULONG MembershipCount
    )

/*++

Routine Description:

    This function checks how many of a given list of Member Sids belong
    to an Alias.  It is called prior to updating Alias Memberships.

Arguments:

    AliasHandle - Handle to Alias Object

    AliasRid - Specifies the Rid of the Alias

    MemberSids - Pointer to counted array of pointers to Member Sids

    MembershipCount - Receives count of member Sids in the given set
        that belong to the alias.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SAMPR_PSID_ARRAY AliasMemberSids;
    ULONG OutputMembershipCount = 0;
    ULONG SidIndex, AliasMemberSidIndex;
    PSID Sid = NULL;
    PSID AliasMemberSid = NULL;

    SAMTRACE("SampAlLookupMembersInAlias");

    //
    // First, query the members of the Alias.
    //

    Status = SampAlQueryMembersOfAlias(
                 AliasHandle,
                 &AliasMemberSids
                 );

    if (!NT_SUCCESS(Status)) {

        // if !NT_SUCCESS(Statys)
        // no memory allocated.

        goto LookupMembersInAliasError;
    }

    //
    // Now scan each of the given Member Sids and count it if it is a member
    // of the Alias.
    //

    for (SidIndex = 0; SidIndex < MemberSids->Count; SidIndex++) {

        Sid = MemberSids->Sids[ SidIndex].SidPointer;

        for (AliasMemberSidIndex = 0;
             AliasMemberSidIndex = AliasMemberSids.Count;
             AliasMemberSidIndex++) {

            AliasMemberSid = AliasMemberSids.Sids[ AliasMemberSidIndex].SidPointer;

            if (RtlEqualSid( Sid, AliasMemberSid)) {

                OutputMembershipCount++;
            }
        }
    }

    *MembershipCount = OutputMembershipCount;

    MIDL_user_free(AliasMemberSids.Sids);  // free the memory allocated

LookupMembersInAliasFinish:

    return(Status);

LookupMembersInAliasError:

    *MembershipCount =0;
    goto LookupMembersInAliasFinish;
}


NTSTATUS
SampAlDeleteAlias(
    IN SAMPR_HANDLE *AliasHandle
    )

/*++

Routine Description:

    This function deletes an alias.

Arguments:

    AliasHandle - Pointer to Handle to Alias

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN MemberDomainDeleted = FALSE;
    BOOLEAN MemberAccountDeleted = FALSE;
    ULONG AliasRid = ((PSAMP_OBJECT) *AliasHandle)->TypeBody.Alias.Rid;
    LONG DomainIndex;
    ULONG RidCount;
    LONG DomainCount;
    ULONG AccountIndex;
    SAMPR_ULONG_ARRAY AliasRids;
    AliasRids.Count = 1;
    AliasRids.Element = &AliasRid;

    SAMTRACE("SampAlDeleteAlias");

    //
    // Obtain pointer to Member Alias List.
    //

    MemberAliasList = SampAlAliasHandleToMemberAliasList( *AliasHandle );

    if (NULL!= MemberAliasList)
    {

        //
        // Traverse the Member Alias List.  Look in every Member Account for the
        // Alias and remove it if present.  This is rather slow if there is a
        // large number of alias relationships for diverse domains.
        //
        DomainCount = (LONG) MemberAliasList->DomainCount;
        for (DomainIndex = 0,
             MemberDomain = SampAlFirstMemberDomain( MemberAliasList );
             DomainIndex < DomainCount;
             DomainIndex++ ) {

            RidCount = MemberDomain->RidCount;
            for (AccountIndex = 0,
                MemberAccount = SampAlFirstMemberAccount( MemberDomain );
                AccountIndex < RidCount;
                AccountIndex++ ) {

                ASSERT(MemberAccount->Signature == SAMP_AL_MEMBER_ACCOUNT_SIGNATURE);
                //
                // We now have the MemberAccount.  Now remove the Alias from it.
                //

                Status = SampAlRemoveAliasesFromMemberAccount(
                             &MemberAliasList,
                             &MemberDomain,
                             &MemberAccount,
                             0,
                             &AliasRids,
                             &MemberDomainDeleted,
                             &MemberAccountDeleted
                             );

                if (!NT_SUCCESS(Status)) {

                    if (Status == STATUS_MEMBER_NOT_IN_ALIAS) {

                        Status = STATUS_SUCCESS;
                        continue;
                    }

                    break;
                }

                //
                // Move the the next member account unless the one we were pointing
                // to was deleted (in which case the next one moved to us).
                //

                if (!MemberAccountDeleted) {
                    MemberAccount = SampAlNextMemberAccount( MemberAccount );
                }

                //
                // If the member domain was deleted, then the count of members
                // is off as is the member account pointer.
                //

                if (MemberDomainDeleted) {
                    break;
                }
            }

            if (!NT_SUCCESS(Status)) {

                break;
            }

            //
            // Move the the next member domain unless the one we were pointing
            // to was deleted (in which case the next one moved to us).
            //

            if (!MemberDomainDeleted) {
                MemberDomain = SampAlNextMemberDomain( MemberDomain );
            }
        }

    }

    if (!NT_SUCCESS(Status)) {

        goto DeleteAliasError;
    }

DeleteAliasFinish:

    return(Status);

DeleteAliasError:

    goto DeleteAliasFinish;

}


NTSTATUS
SampAlRemoveAccountFromAllAliases(
    IN PSID AccountSid,
    IN BOOLEAN CheckAccess,
    IN SAMPR_HANDLE DomainHandle OPTIONAL,
    IN PULONG MembershipCount OPTIONAL,
    IN PULONG *Membership OPTIONAL
    )

/*++

Routine Description:

    This routine removes the specified account from the member list of all
    aliases in this domain.

Arguments:

    AccountSid - The SID of the account being Removed.

    CheckAccess - if TRUE, this routine will make sure that the caller
        is allowed REMOVE_ALIAS_MEMBER access to this alias.  If FALSE,
        the caller is already known to have proper access.

    DomainHandle - if CheckAccess is TRUE, this handle must be provided
        to allow access to be checked.

    MembershipCount - if CheckAccess is TRUE, this pointer must be
        provided to receive the number of aliases the account was
        deleted from.

    Membership - if CheckAccess is TRUE, this pointer must be provided
        to point to a list of aliases the account was removed from.  The
        caller must free this list with MIDL_user_free().

Return Value:


    STATUS_SUCCESS - The user has been Removed from all aliases.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;
    PSAMP_AL_MEMBER_DOMAIN MemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT MemberAccount = NULL;
    BOOLEAN MemberDomainDeleted;
    PSID DomainSid = NULL;
    LONG DomainIndex;
    ULONG MemberRid, AliasRid;
    SAMPR_ULONG_ARRAY AliasRids;
    AliasRids.Count = 1;
    AliasRids.Element = &AliasRid;

    SAMTRACE("SampAlRemoveAccountFromAllAliases");

    //
    // Obtain pointer to Member Alias List for the Current Transaction Domain.
    //

    DomainIndex = SampTransactionDomainIndex;
    MemberAliasList = SampAlDomainIndexToMemberAliasList( DomainIndex );

    if (NULL!=MemberAliasList)
    {
        //
        // We remove the Account from all aliases by locating its Member Account
        // structure and deleting it.  First, find the Member Domain.
        //

        Status = SampSplitSid( AccountSid, &DomainSid, &MemberRid );
        if (!NT_SUCCESS(Status))
        {
            goto RemoveAccountFromAllAliasesError;

        }

        //
        // Lookup the Member Domain for this DomainSid in the Member Alias
        // List.
        //

        Status = SampAlLookupMemberDomain(
                     MemberAliasList,
                     DomainSid,
                     &MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_SUCH_DOMAIN) {

                goto RemoveAccountFromAllAliasesError;
            }

            //
            // There is no member Domain object for this account.  This means
            // the account does not belong to any aliases.
            //

            Status = STATUS_SUCCESS;

            goto RemoveAccountFromAllAliasesFinish;
        }

        //
        // We found the Member Domain.  Now find the Member Account.
        //

        Status = SampAlLookupMemberAccount(
                     MemberDomain,
                     MemberRid,
                     &MemberAccount
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_SUCH_MEMBER) {

                goto RemoveAccountFromAllAliasesError;
            }

            Status = STATUS_SUCCESS;

            goto RemoveAccountFromAllAliasesFinish;
        }

        //
        // If CheckAccess = TRUE, return a list of Aliases that the account was
        // a member of.
        //

        if (CheckAccess) {

            *Membership = MIDL_user_allocate( MemberAccount->AliasCount * sizeof(ULONG));
            *MembershipCount = MemberAccount->AliasCount;

            Status = STATUS_NO_MEMORY;

            if (*Membership == NULL) {

                goto RemoveAccountFromAllAliasesError;
            }

            Status = STATUS_SUCCESS;
        }

        //
        // We now have the MemberAccount.  Now delete it, thereby removing the
        // account from all Aliases.
        //

        Status = SampAlDeleteMemberAccount(
                     &MemberAliasList,
                     &MemberDomain,
                     MemberAccount,
                     &MemberDomainDeleted
                     );

        if (!NT_SUCCESS(Status)) {

            goto RemoveAccountFromAllAliasesError;
        }
    }

RemoveAccountFromAllAliasesFinish:

    //
    // Free the Domain Sid buffer (if any)
    //

    if (DomainSid != NULL) {

        MIDL_user_free( DomainSid );
        DomainSid = NULL;
    }

    return(Status);

RemoveAccountFromAllAliasesError:

    if (CheckAccess) {

        if (NULL!=*Membership)
            MIDL_user_free(*Membership);
        *Membership = NULL;
        *MembershipCount = 0;
    }

    goto RemoveAccountFromAllAliasesFinish;
}


NTSTATUS
SampAlBuildAliasInformation(
    )

/*++

Routine Description:

    This function builds the Alias Information for each of the SAM Local
    Domains.  For each Domain, this information consists of the Member Alias
    List.

    NOTE: in both DS Mode and Registry Mode, we need to acquire SAM Read Lock.

Arguments:

    None.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG DomainIndex;

    SAMTRACE("SampAlBuildAliasInformation");

    SampAcquireReadLock();

    //
    // We need to Validate Domain Cache, because in SampAlBuildMemberAliasList(), we will
    // try to call SampSetTransactionDomain().
    //
    Status = SampValidateDomainCache();

    if (!NT_SUCCESS(Status))
    {
        goto BuildAliasInformationError;
    }

    for (DomainIndex = SampDsGetPrimaryDomainStart();
         DomainIndex < (LONG) SampDefinedDomainsCount;
         DomainIndex++) {

        if (SampUseDsData) {
            //
            // DS Mode, just enable Builtin Domain Alias Caching
            //

            if (IsBuiltinDomain(DomainIndex)) {


                Status = SampAlBuildMemberAliasList(DomainIndex);
            }
        }
        else {
            //
            // Register Mode, enable both Builtin Domain and Account Domain
            //

            if (SampAlEnableBuildingOfList[ DomainIndex]) {

                Status = SampAlBuildMemberAliasList(DomainIndex);

            }

        }

        //
        // if SampAlBuildMemberAliasList failed, do NOT try to build
        // Alias Cache Information any more. And free the memory
        // allocated.
        //

        if (!NT_SUCCESS(Status))
        {
            PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList =
                        SampAlDomainIndexToMemberAliasList(DomainIndex);

            //
            // if SampAlBuildMemberAliasList returns failure,
            // Alias Membership Information should already been marked as
            // invalid in SampAlBuildMemberAliasList.
            // ASSERT and make it invalid again just for safety reason.
            //

            ASSERT(FALSE==SampAlInfoIsValid(DomainIndex));
            SampAlInfoMakeInvalid(DomainIndex);

            if (MemberAliasList!=NULL)
            {
                SampDefinedDomains[DomainIndex].AliasInformation.MemberAliasList = NULL;
                MIDL_user_free(MemberAliasList);
                MemberAliasList = NULL;
            }

            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildAliasInformationError;
    }

BuildAliasInformationFinish:

    SampReleaseReadLock();

    return(Status);

BuildAliasInformationError:

    goto BuildAliasInformationFinish;
}

NTSTATUS
SampAlDelayedBuildAliasInformation(
    IN PVOID Parameter
    )
/*++

Routine Description:

    This function builds the Alias Information for each of the SAM Local
    Domains. For each Domain, this information consists of the Member Alias
    List. Because this rountine is called 10 mins after the system been
    booted, so we will acquire SAM Read lock in SampAlBuildAliasInformation.

    If the Alias Cache is not successfully built, we will reschedule
    this routine for another time.

Arguments:

    Parameter - NULL. Nothing passed by Parameter and we do not use it at all.
                Parameter exists because of LsaIRegisterNotification.

Return Values:

    NtStatus returned SampAlBuildAliasInformation.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;

    SAMTRACE("SampAlDelayedBuildAliasInformation");


    NtStatus = SampAlBuildAliasInformation();

    if (!NT_SUCCESS(NtStatus))
    {
        goto DelayedBuildAliasInfoError;
    }

DelayedBuildAliasInfoFinish:

    return(NtStatus);


DelayedBuildAliasInfoError:

    //
    // If SampAlBuildAliasInformation failed due to the buffer size
    // limitation, don't schedule next attemp. For all the other error
    // Hope we can recovery later.
    //

    if (STATUS_BUFFER_OVERFLOW != NtStatus)
    {
        LsaIRegisterNotification(
                SampAlDelayedBuildAliasInformation,
                NULL,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                600,          // wait for another 10 mins
                NULL          // no handle
                );
    }

    goto DelayedBuildAliasInfoFinish;

}


NTSTATUS
SampAlInvalidateAliasInformation(
    IN ULONG DomainIndex
    )
/*++

Routine Description:

    This function check the state of Member Alias List in the specified
    Member Domain for the specified Alias referenced by AliasHandle.
    If the Member Alias List is valid then call SampAlInvalidateMemberAliasList
    to invalidate it.

    This routine also invalidates all alias name caches.

    NOTE: The calling function should hold the SAM write lock.

Argument:

    AliasHandle - Pointer to an Alias Context

Return Value:


--*/
{

    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampAlInvalidateAliasInformation");

    ASSERT(SampCurrentThreadOwnsLock());

    SampInvalidateAliasNameCache(DomainIndex);

    //
    // if Alias Informaiton is invalid, return immediately.
    // this will prevent mutliple invalidations at the same time
    //

    if ( !SampAlInfoIsValid(DomainIndex) )
    {
        return( NtStatus );
    }

    NtStatus = SampAlInvalidateMemberAliasList( DomainIndex );

    return( NtStatus );

}



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Private functions                                                      //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampAlCreateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG Rid,
    IN ULONG AliasCapacity,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    )

/*++

Routine Description:

    This function creates an empty Member Account in the specified Member Domain
    for the specified Member Rid.  There must not already be al account for this
    Rid.  The Member Account is appended to the end of any existing ones in the
    Member Domain.

Arguments:

    MemberAliasList - Pointer to pointer to Member Alias List.

    MemberDomain - Pointer to Member Domain in which the Member Account is
        to be created.  The Member Domain must already exist.

    Rid - Specifies the Account Rid.

    AliasCapacity - Specifies the initial number of Alias Rids that the
        MemberAccount can hold.

    MemberAccount - Receives pointer to the newly created Member Account.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MaximumLengthMemberAccount;
    PSAMP_AL_MEMBER_ACCOUNT OutputMemberAccount = NULL;

    SAMTRACE("SampAlCreateMemberAccount");

    //
    // Calculate the length of data needed for the new member Account entry.
    //

    MaximumLengthMemberAccount = SampAlLengthRequiredMemberAccount( AliasCapacity );

    //
    // Allocate space for the Member Account.
    //

    Status = SampAlAllocateMemberAccount(
                 MemberAliasList,
                 MemberDomain,
                 MaximumLengthMemberAccount,
                 &OutputMemberAccount
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateMemberAccountError;
    }

    //
    // Scratch the new Member Account
    //

    OutputMemberAccount->Signature = SAMP_AL_MEMBER_ACCOUNT_SIGNATURE;
    OutputMemberAccount->MaximumLength = MaximumLengthMemberAccount;
    OutputMemberAccount->UsedLength =
        SampAlOffsetFirstAlias( OutputMemberAccount );
    ASSERT(OutputMemberAccount->MaximumLength >=
           OutputMemberAccount->UsedLength);
    OutputMemberAccount->Rid = Rid;
    OutputMemberAccount->AliasCount = 0;

    ((*MemberDomain)->RidCount)++;
    *MemberAccount = OutputMemberAccount;

CreateMemberAccountFinish:

    return(Status);

CreateMemberAccountError:

    *MemberAccount = NULL;
    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto CreateMemberAccountFinish;
}


NTSTATUS
SampAlAllocateMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG MaximumLengthMemberAccount,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    )

/*++

Routine Description:

    This function allocates the space for a new Member Account in a Member
    Domain.  If necessary, the Mmeber Domain and its associated Member Alias
    List will be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MaximumLengthMemberAccount - Initial Maximum Length required for the
        Member Account

    MemberAccount - receives pointer to the newly allocated Member Account

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable;

    SAMTRACE("SampAlAllocateMemberAccount");

    //
    // Calculate the space available in the Member Domain
    //

    SpaceAvailable = (*MemberDomain)->MaximumLength - (*MemberDomain)->UsedLength;

    if (MaximumLengthMemberAccount > SpaceAvailable) {

        Status = SampAlGrowMemberDomain(
                     MemberAliasList,
                     MemberDomain,
                     MaximumLengthMemberAccount - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto AllocateMemberAccountError;
        }
    }

    //
    // The Member Domain is now guaranteed to be large enough.  Reserve the
    // space for the new Member Account.
    //

    *MemberAccount = SampAlNextNewMemberAccount(*MemberDomain);
    (*MemberDomain)->UsedLength += MaximumLengthMemberAccount;
    ASSERT((*MemberDomain)->MaximumLength >=
           (*MemberDomain)->UsedLength);

AllocateMemberAccountFinish:

    return(Status);

AllocateMemberAccountError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );
    *MemberAccount = NULL;

    goto AllocateMemberAccountFinish;
}


NTSTATUS
SampAlGrowMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG ExtraSpaceRequired
    )

/*++

Routine Description:

    This function grows a Member Account by at least the requested amount.  If
    necessary, the containing Member Domain and Member Alias List will also be
    grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to Pointer to the Member Account.

    ExtraSpaceRequired - Extra space needed in the Member Account.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable, MemberAccountOffset, CopyLength;
    PUCHAR Destination = NULL;
    PUCHAR Source = NULL;

    SAMTRACE("SampAlGrowMemberAccount");

    //
    // Calculate the space available in the Member Domain
    //

    SpaceAvailable = (*MemberDomain)->MaximumLength - (*MemberDomain)->UsedLength;

    if (ExtraSpaceRequired > SpaceAvailable) {

        //
        // We need to grow the Member Domain.  Calculate the offset of the
        // Member Account in the old Member Domain, grow the Member Domain
        // and then calculate the new address of the Member Account.
        //

        MemberAccountOffset = SampAlMemberAccountToOffset(
                                  *MemberDomain,
                                  *MemberAccount
                                  );

        Status = SampAlGrowMemberDomain(
                     MemberAliasList,
                     MemberDomain,
                     ExtraSpaceRequired - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto GrowMemberAccountError;
        }

        *MemberAccount = SampAlMemberAccountFromOffset(
                             *MemberDomain,
                             MemberAccountOffset
                             );

    }

    //
    // The Member Domain is now guaranteed to be large enough.
    // Now shift any Member Accounts that follow the one being grown
    // up to make room for the expanded Member Account.  The source address
    // for the move is the address of the next Member Account (if any) based
    // on the existing size of the Member Account.  The destination address
    // of the move is the address of the next Member Account (if any) based
    // on the new size of the Member Account.
    //

    Source = (PUCHAR) SampAlNextMemberAccount( *MemberAccount );
    (*MemberAccount)->MaximumLength += ExtraSpaceRequired;
    Destination = (PUCHAR) SampAlNextMemberAccount( *MemberAccount );
    CopyLength =
        (ULONG)(((PUCHAR)(SampAlNextNewMemberAccount(*MemberDomain))) - Source);

    //
    // Reserve the space in the Member Domain.  If all's well, the
    // end of the destination buffer should match the updated end of the
    // used area of the Member Domain.
    //

    (*MemberDomain)->UsedLength += ExtraSpaceRequired;
    ASSERT((*MemberDomain)->MaximumLength >=
           (*MemberDomain)->UsedLength);

    ASSERT( Destination + CopyLength ==
            (PUCHAR) SampAlNextNewMemberAccount( *MemberDomain ));
    ASSERT( Destination + CopyLength <=
            (PUCHAR)(*MemberAliasList) + (*MemberAliasList)->MaximumLength );
    ASSERT( Destination + CopyLength <=
            (PUCHAR)(*MemberDomain) + (*MemberDomain)->MaximumLength );

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
    }

GrowMemberAccountFinish:

    return(Status);

GrowMemberAccountError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto GrowMemberAccountFinish;
}


NTSTATUS
SampAlLookupMemberAccount(
    IN PSAMP_AL_MEMBER_DOMAIN MemberDomain,
    IN ULONG MemberRid,
    OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount
    )

/*++

Routine Description:

    This function looks up an Account Rid in a Member Domain to see if there
    is a Member Account structure for it.

Arguments:

    MemberDomain - Pointer to Member Domain

    MemberRid - Specifies the Account Rid

    MemberAccount - Receives pointer to Member Account if found.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ACCOUNT NextMemberAccount = NULL;
    ULONG RidIndex;
    BOOLEAN AccountFound = FALSE;

    SAMTRACE("SampAlLookupMemberAccount");


    for (RidIndex = 0,
         NextMemberAccount = SampAlFirstMemberAccount( MemberDomain );
         RidIndex < MemberDomain->RidCount;
         RidIndex++, NextMemberAccount = SampAlNextMemberAccount( NextMemberAccount)) {

        if (MemberRid == NextMemberAccount->Rid) {

            AccountFound = TRUE;

            break;
        }
    }

    Status = STATUS_NO_SUCH_MEMBER;

    if (!AccountFound) {

        goto LookupMemberAccountError;
    }

    *MemberAccount = NextMemberAccount;
    Status = STATUS_SUCCESS;

LookupMemberAccountFinish:

    return(Status);

LookupMemberAccountError:

    goto LookupMemberAccountFinish;
}


NTSTATUS
SampAlAddAliasesToMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids
    )

/*++

Routine Description:

    This function adds an array of aliases to a Member Account.  An error
    will be returned if any of the aliases exist in the Member Account.
    If necessary, the containing Member Account, Member Domain and Member
    Alias List will also be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to Pointer to the Member Account.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_NO_ALIASES_IN_ACCOUNT - Verify that none of the
           Aliases presented belong to the various Member Accounts.

    AliasRids - Pointer to counted array of Alias Rids.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceRequired, SpaceAvailable, CopyLength;
    PUCHAR Source = NULL;
    PUCHAR Destination = NULL;
    ULONG ExistingAliasCount=0;

    SAMTRACE("SampAlAddAliasesToMemberAccount");

    //
    // If requested, verify that none of the Aliases are already
    // in the Member Account
    //

    if (Options & SAMP_AL_VERIFY_NO_ALIASES_IN_ACCOUNT) {

        Status = SampAlLookupAliasesInMemberAccount(
                     *MemberAccount,
                     AliasRids,
                     &ExistingAliasCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddAliasesToMemberAccountError;
        }

        Status = STATUS_MEMBER_IN_ALIAS;

        if (ExistingAliasCount > 0) {

            goto AddAliasesToMemberAccountError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Calculate the space required for the new Aliases.
    //

    SpaceRequired = AliasRids->Count * sizeof( ULONG );

    //
    // If there is not enough space available in the Member Account,
    // grow it.
    //

    SpaceAvailable = (*MemberAccount)->MaximumLength - (*MemberAccount)->UsedLength;

    if (SpaceRequired > SpaceAvailable) {

        Status = SampAlGrowMemberAccount(
                     MemberAliasList,
                     MemberDomain,
                     MemberAccount,
                     SpaceRequired - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto AddAliasesToMemberAccountError;
        }
    }

    //
    // The Member Account is now large enough.  Copy in the aliases.
    //

    Destination = (PUCHAR) SampAlNextNewAliasInMemberAccount( *MemberAccount );
    Source = (PUCHAR) AliasRids->Element;
    CopyLength = SpaceRequired;
    (*MemberAccount)->UsedLength += SpaceRequired;
    ASSERT((*MemberAccount)->MaximumLength >=
           (*MemberAccount)->UsedLength);
    RtlMoveMemory( Destination, Source, CopyLength );

    //
    // Update the count of Aliases both in this Member Account and in the
    // Member Alias List.
    //

    (*MemberAccount)->AliasCount += AliasRids->Count;

AddAliasesToMemberAccountFinish:

    return(Status);

AddAliasesToMemberAccountError:

    goto AddAliasesToMemberAccountFinish;
}


NTSTATUS
SampAlLookupAliasesInMemberAccount(
    IN PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT PULONG ExistingAliasCount
    )

/*++

Routine Description:

    This function checks a set of Alias Rids to see if any are present in a
    Member Account.

Arguments:

    MemberAccount - Pointer to Member Account

    AliasRids - Specifies counted array of Alias Rids.

    ExistingAliasCount - Receives a count of the Alias Rids presented that
        are already in the Member Account.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AliasIndex, AliasInMemberAccountIndex;

    SAMTRACE("SampAlLookupAliasesInMemberAccount");

    //
    // Scan the Alias Rids, looking each one up.
    //

    for (AliasIndex = 0; AliasIndex < AliasRids->Count; AliasRids++ ) {

        for (AliasInMemberAccountIndex = 0;
             AliasInMemberAccountIndex < MemberAccount->AliasCount;
             AliasInMemberAccountIndex++) {

            if (AliasRids->Element[ AliasIndex ] ==
                MemberAccount->AliasRids[ AliasInMemberAccountIndex ] ) {

                (*ExistingAliasCount)++;
            }
        }
    }

    return(Status);
}


NTSTATUS
SampAlRemoveAliasesFromMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT *MemberAccount,
    IN ULONG Options,
    IN PSAMPR_ULONG_ARRAY AliasRids,
    OUT    PBOOLEAN MemberDomainDeleted,
    OUT    PBOOLEAN MemberAccountDeleted
    )

/*++

Routine Description:

    This function removes aliases from a Member Account.  The Aliases need
    not already exist unless an option to check that they do exist is
    specified.  No down sizing of the Member Account occurs, but an
    empty one will be deleted.

    NOTE: I don't know why ScottBi made MemberAliasList, MemberDomain, and
          MemberAccount parameters pointers to pointers.  He never updates
          the pointers so he could have passed them in directly.  JK

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to Pointer to the Member Account.

    Options - Specifies optional actions to be taken

        SAMP_AL_VERIFY_ALL_ALIASES_IN_ACCOUNT - Verify that none of the
           Aliases presented belong to the Member Account.

    MemberDomainDeleted - Will be set to TRUE if the member domain
        pointed to by MemberDomain was deleted.  Otherwise FALSE is returned.

    MemberAccountDeleted - Will be set to TRUE if the member account
        pointed to by MemberAccount was deleted.  Otherwise FALSE is returned.

    AliasRids - Pointer to counted array of Alias Rids.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ExistingAliasIndex, LastAliasIndex, RemoveAliasIndex, ExistingAlias;
    ULONG ExistingAliasCount=0;

    SAMTRACE("SampAlRemoveAliasesFromMemberAccount");

    (*MemberDomainDeleted)  = FALSE;
    (*MemberAccountDeleted) = FALSE;

    //
    // If requested, verify that all of the Aliases are already
    // in the Member Account
    //

    if (Options & SAMP_AL_VERIFY_ALL_ALIASES_IN_ACCOUNT) {

        Status = SampAlLookupAliasesInMemberAccount(
                     *MemberAccount,
                     AliasRids,
                     &ExistingAliasCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto RemoveAliasesFromMemberAccountError;
        }

        Status = STATUS_MEMBER_IN_ALIAS;

        if (ExistingAliasCount < AliasRids->Count) {

            goto RemoveAliasesFromMemberAccountError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // If the Member Account is empty, then somebody forgot to delete it
    //

    ASSERT((*MemberAccount)->AliasCount != 0);


    LastAliasIndex = (*MemberAccount)->AliasCount - 1;

    for (ExistingAliasIndex = 0;
         ExistingAliasIndex < (*MemberAccount)->AliasCount;
         ExistingAliasIndex++) {

        ExistingAlias = (*MemberAccount)->AliasRids[ ExistingAliasIndex ];

        for (RemoveAliasIndex = 0;
             RemoveAliasIndex < AliasRids->Count;
             RemoveAliasIndex++) {

            if (ExistingAlias == AliasRids->Element[ RemoveAliasIndex ]) {

                //
                // We're to delete this Alias.  If this Alias Rid is not at the
                // end of the list contained in the Member Account, overwrite
                // it with the one at the end of the list.
                //

                if (ExistingAliasIndex < LastAliasIndex) {

                    (*MemberAccount)->AliasRids[ ExistingAliasIndex] =
                    (*MemberAccount)->AliasRids[ LastAliasIndex];
                }

                (*MemberAccount)->AliasCount--;
                (*MemberAccount)->UsedLength -= sizeof(ULONG);
                ASSERT((*MemberAccount)->MaximumLength >=
                       (*MemberAccount)->UsedLength);

                //
                // If the Member Account is now empty, quit.
                //

                if ((*MemberAccount)->AliasCount == 0) {

                    break;
                }

                LastAliasIndex--;
            }
        }

        //
        // If the Member Account is now empty, quit.
        //

        if ((*MemberAccount)->AliasCount == 0) {

            break;
        }
    }

    //
    // If the Member Account is now empty, delete it.
    //

    if ((*MemberAccount)->AliasCount == 0) {

        Status = SampAlDeleteMemberAccount(
                     MemberAliasList,
                     MemberDomain,
                     *MemberAccount,
                     MemberDomainDeleted
                     );
        if (NT_SUCCESS(Status)) {
            (*MemberAccountDeleted) = TRUE;
        }
    }

RemoveAliasesFromMemberAccountFinish:

    return(Status);

RemoveAliasesFromMemberAccountError:

    goto RemoveAliasesFromMemberAccountFinish;
}


NTSTATUS
SampAlDeleteMemberAccount(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN OUT PSAMP_AL_MEMBER_ACCOUNT MemberAccount,
    OUT    PBOOLEAN                MemberDomainDeleted
    )

/*++

Routine Description:

    This function deletes a Member Account.  Currently, the containing
    Member Domain and Member Alias List are not shrunk, but the containing
    Member Domain will be deleted if empty.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    MemberAccount - Pointer to the Member Account.

    MemberDomainDeleted - Will be set to TRUE if the member domain
        pointed to by MemberDomain was deleted.  Otherwise FALSE is returned.


Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Source = NULL;
    PUCHAR Destination = NULL;
    ULONG CopyLength;

    SAMTRACE("SampAlDeleteMemberAccount");

    (*MemberDomainDeleted) = FALSE;

    //
    // Calculate pointers for moving the residual portion of the Member
    // Domain down to close the gap left by the extant Member Account.
    // unused space.  The start of the residual portion is the end of the
    // Member Account being deleted.  The length of the residual portion is
    // the distance from the start to the end of the used portion of the
    // Member Domain.
    //

    Source = (PUCHAR) SampAlNextMemberAccount( MemberAccount );
    Destination = (PUCHAR) MemberAccount;
    CopyLength = (ULONG)((PUCHAR) SampAlNextNewMemberAccount( *MemberDomain ) - Source);

    (*MemberDomain)->UsedLength -= MemberAccount->MaximumLength;
    ASSERT((*MemberDomain)->MaximumLength >=
           (*MemberDomain)->UsedLength);
    (*MemberDomain)->RidCount--;

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
#if DBG
        {
            PSAMP_AL_MEMBER_ACCOUNT Member = (PSAMP_AL_MEMBER_ACCOUNT) Destination;
            ASSERT(Member->Signature == SAMP_AL_MEMBER_ACCOUNT_SIGNATURE);
        }

#endif
    }

    //
    // If the Member Domain now has no Member Accounts, delete it.
    //

    if ((*MemberDomain)->RidCount == 0) {

        Status = SampAlDeleteMemberDomain(
                     MemberAliasList,
                     *MemberDomain
                     );

        if (!NT_SUCCESS(Status)) {
            goto DeleteMemberAccountError;
        }
        (*MemberDomainDeleted) = TRUE;
    }

DeleteMemberAccountFinish:

    return(Status);

DeleteMemberAccountError:

    goto DeleteMemberAccountFinish;
}


NTSTATUS
SampAlCreateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    )

/*++

Routine Description:

    This function creates a new Member Domain in the specified Alias Member
    List.

Arguments:

    MemberAliasList - Pointer to pointer to Alias Member List.

    DomainSid - Pointer to Sid of Domain to which this MemberDomain
        relates.

    MemberDomain - Receives pointer to the newly created Member Domain.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_DOMAIN OutputMemberDomain = NULL;
    PSAMP_AL_MEMBER_ACCOUNT OutputMemberAccount = NULL;
    ULONG MaximumLengthMemberDomain;
    ULONG DomainSidLength = RtlLengthSid(DomainSid);
    ULONG AlternativeLength;

    SAMTRACE("SampAlCreateMemberDomain");


    //
    // Allocate the Member Domain.
    //

    MaximumLengthMemberDomain = SAMP_AL_INITIAL_MEMBER_DOMAIN_LENGTH;
    AlternativeLength = FIELD_OFFSET(SAMP_AL_MEMBER_DOMAIN, DomainSid)
                        + DomainSidLength;
    if (MaximumLengthMemberDomain < AlternativeLength) {
        MaximumLengthMemberDomain = AlternativeLength;
    }

    Status = SampAlAllocateMemberDomain(
                 MemberAliasList,
                 MaximumLengthMemberDomain,
                 &OutputMemberDomain
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateMemberDomainError;
    }

    //
    // Setup the new Member Domain entry.
    //

    OutputMemberDomain->MaximumLength = MaximumLengthMemberDomain;
    OutputMemberDomain->RidCount = 0;
    OutputMemberDomain->Signature = SAMP_AL_MEMBER_DOMAIN_SIGNATURE;

    RtlCopySid(
        DomainSidLength,
        &OutputMemberDomain->DomainSid,
        DomainSid
        );

    OutputMemberDomain->UsedLength = SampAlOffsetFirstMemberAccount(
                                         OutputMemberDomain
                                         );
    ASSERT(OutputMemberDomain->MaximumLength >=
           OutputMemberDomain->UsedLength);

    ((*MemberAliasList)->DomainCount)++;
    *MemberDomain = OutputMemberDomain;

CreateMemberDomainFinish:

    return(Status);

CreateMemberDomainError:

    *MemberDomain = NULL;
    goto CreateMemberDomainFinish;
}


NTSTATUS
SampAlAllocateMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG MaximumLengthMemberDomain,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    )

/*++

Routine Description:

    This function allocates the space for a new Member Domain in a Member
    Alias List.  If necessary, the Member Alias List will be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MaximumLengthMemberDomain - Initial Maximum Length required for the
        Member Domain

    MemberDomain - Receives pointer to the Member Domain

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable;

    SAMTRACE("SampAlAllocateMemberDomain");

    //
    // Calculate the space available in the Member Alias List
    //

    SpaceAvailable = (*MemberAliasList)->MaximumLength - (*MemberAliasList)->UsedLength;

    if (MaximumLengthMemberDomain > SpaceAvailable) {

        Status = SampAlGrowMemberAliasList(
                     MemberAliasList,
                     MaximumLengthMemberDomain - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto AllocateMemberDomainError;
        }
    }

    //
    // The Member Alias List is now guaranteed to be large enough.  Reserve the
    // space for the new Member Domain.
    //

    *MemberDomain = SampAlNextNewMemberDomain(*MemberAliasList);
    (*MemberAliasList)->UsedLength += MaximumLengthMemberDomain;
    ASSERT((*MemberAliasList)->MaximumLength >=
           (*MemberAliasList)->UsedLength);

AllocateMemberDomainFinish:

    return(Status);

AllocateMemberDomainError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );
    *MemberDomain = NULL;
    goto AllocateMemberDomainFinish;
}


NTSTATUS
SampAlGrowMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain,
    IN ULONG ExtraSpaceRequired
    )

/*++

Routine Description:

    This function grows a Member Domain by at least the requested amount.  If
    necessary, the Member Alias List will also be grown.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to pointer to the Member Domain

    ExtraSpaceRequired - Extra space needed in the Member Domain.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SpaceAvailable, MemberDomainOffset, CopyLength;
    PUCHAR Destination = NULL;
    PUCHAR Source = NULL;

    SAMTRACE("SampAlGrowMemberDomain");

    //
    // Calculate the space available in the Member Alias List
    //

    SpaceAvailable = (*MemberAliasList)->MaximumLength - (*MemberAliasList)->UsedLength;

    if (ExtraSpaceRequired > SpaceAvailable) {

        //
        // We need to grow the Member Alias List.  Calculate the offset of the
        // Member Domain in the old Member Alias List, grow the Member Alias
        // List and then calculate the new address of the Member Domain.
        //

        MemberDomainOffset = SampAlMemberDomainToOffset(
                                 *MemberAliasList,
                                 *MemberDomain
                                 );

        Status = SampAlGrowMemberAliasList(
                     MemberAliasList,
                     ExtraSpaceRequired - SpaceAvailable
                     );

        if (!NT_SUCCESS(Status)) {

            goto GrowMemberDomainError;
        }

        //
        // Calculate the new address of the Member Domain
        //

        *MemberDomain = SampAlMemberDomainFromOffset(
                            *MemberAliasList,
                            MemberDomainOffset
                            );
    }

    //
    // The Member Alias List is now guaranteed to be large enough.
    // Now shift any Member Domains that follow the one being grown
    // up to make room for the expanded Member Domain.  The source address
    // for the move is the address of the next Member Domain (if any) based
    // on the existing size of the Member Domain.  The destination address
    // of the move is the address of the next Member Domain (if any) based
    // on the new size of the Member Domain.
    //

    Source = (PUCHAR) SampAlNextMemberDomain( *MemberDomain );
    (*MemberDomain)->MaximumLength += ExtraSpaceRequired;
    Destination = (PUCHAR) SampAlNextMemberDomain( *MemberDomain );
    CopyLength =
        (ULONG)(((PUCHAR)(SampAlNextNewMemberDomain(*MemberAliasList))) - Source);

    //
    // Reserve the space in the Member Alias List.  If all's well, the
    // end of the destination buffer should match the updated end of the
    // used area of the member Alias List.
    //

    (*MemberAliasList)->UsedLength += ExtraSpaceRequired;
    ASSERT((*MemberAliasList)->MaximumLength >=
           (*MemberAliasList)->UsedLength);

    ASSERT( Destination + CopyLength ==
            (PUCHAR) SampAlNextNewMemberDomain( *MemberAliasList ));
    ASSERT( Destination + CopyLength <=
            (PUCHAR)(*MemberAliasList) + (*MemberAliasList)->MaximumLength );

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
    }

GrowMemberDomainFinish:

    return(Status);

GrowMemberDomainError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto GrowMemberDomainFinish;
}


NTSTATUS
SampAlLookupMemberDomain(
    IN PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList,
    IN PSID DomainSid,
    OUT PSAMP_AL_MEMBER_DOMAIN *MemberDomain
    )

/*++

Routine Description:

This function looks up a Domain Sid in a Member Alias List to find its
Member Domain structure (if any).

Arguments:

    MemberAliasList - Pointer to pointer to Member Alias List

    DomainSid - Domain Sid whose Member Domain is to be found.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PSAMP_AL_MEMBER_DOMAIN NextMemberDomain = NULL;
    LONG DomainIndex;
    BOOLEAN DomainFound = FALSE;

    SAMTRACE("SampAlLookupMemberDomain");


    for (DomainIndex = 0,
         NextMemberDomain = SampAlFirstMemberDomain( MemberAliasList );
         DomainIndex < (LONG) MemberAliasList->DomainCount;
         DomainIndex++, NextMemberDomain = SampAlNextMemberDomain( NextMemberDomain )
         ) {

        if (RtlEqualSid( DomainSid, &NextMemberDomain->DomainSid)) {

            DomainFound = TRUE;

            break;
        }
    }

    Status = STATUS_NO_SUCH_DOMAIN;

    if (!DomainFound) {

        goto LookupMemberDomainError;
    }

    *MemberDomain = NextMemberDomain;
    Status = STATUS_SUCCESS;

LookupMemberDomainFinish:

    return(Status);

LookupMemberDomainError:

    *MemberDomain = NULL;
    goto LookupMemberDomainFinish;
}


NTSTATUS
SampAlDeleteMemberDomain(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN OUT PSAMP_AL_MEMBER_DOMAIN MemberDomain
    )

/*++

Routine Description:

    This function deletes a Member Domain.  The Member Domain may contain
    zero or more Member Accounts.  The containing Member Alias List is shrunk.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    MemberDomain - Pointer to the Member Domain

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Source = NULL;
    PUCHAR Destination = NULL;
    ULONG CopyLength;

    SAMTRACE("SampAlDeleteMemberDomain");

    //
    // Calculate pointers for moving the residual portion of the
    // Member Alias List down to close the gap left by the extant Member
    // Domain.  The start of the residual portion is the next Member Domain.
    // The size of the portion is the distance between the start and the
    // used portion of the Member Alias List.
    //

    Source = (PUCHAR) SampAlNextMemberDomain( MemberDomain );
    Destination = (PUCHAR) MemberDomain;
    CopyLength = (ULONG)(((PUCHAR) SampAlNextNewMemberDomain( *MemberAliasList )) - Source);

    (*MemberAliasList)->UsedLength -= MemberDomain->MaximumLength;
    ASSERT((*MemberAliasList)->MaximumLength >=
           (*MemberAliasList)->UsedLength);
    (*MemberAliasList)->DomainCount--;

    if (CopyLength > 0) {

        RtlMoveMemory( Destination, Source, CopyLength );
    }

    return(Status);
}


NTSTATUS
SampAlCreateMemberAliasList(
    IN LONG DomainIndex,
    IN ULONG InitialMemberAliasListLength,
    OUT OPTIONAL PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList
    )

/*++

Routine Description:

    This function creates an empty Member Alias List for the specified SAM Local
    Domain.  The Member Alias List will be marked invalid.

Arguments:

    DomainIndex - Specifies the Local SAM Domain

    InitialMemberAliasListLength - Specifies the initial maximum length of the
        Member Alias List in bytes

    MemberAliasList - Optional pointer to location in which a pointer to the
        Member Alias List will be returned.  Note that the pointer can always
        be retrieved given the DomainIndex.

Return Values:

--*/

{
    NTSTATUS Status=STATUS_SUCCESS;
    PSAMP_AL_MEMBER_ALIAS_LIST OutputMemberAliasList = NULL;
    PSAMP_AL_ALIAS_INFORMATION AliasInformation = NULL;

    SAMTRACE("SampAlCreateMemberAliasList");

    //
    // Allocate memory for the list.
    //

    OutputMemberAliasList = MIDL_user_allocate( InitialMemberAliasListLength );


    if (OutputMemberAliasList == NULL) {

        Status = STATUS_NO_MEMORY;
        goto CreateMemberAliasListError;
    }


    //
    // Scratch the List header
    //

    OutputMemberAliasList->Signature = SAMP_AL_MEMBER_ALIAS_LIST_SIGNATURE;
    OutputMemberAliasList->MaximumLength = InitialMemberAliasListLength;
    OutputMemberAliasList->UsedLength = SampAlOffsetFirstMemberDomain(
                                            OutputMemberAliasList
                                            );
    ASSERT(OutputMemberAliasList->MaximumLength >=
           OutputMemberAliasList->UsedLength);

    OutputMemberAliasList->DomainIndex = DomainIndex;
    OutputMemberAliasList->DomainCount = 0;

    //
    // Link the Member Alias List to the SAM Local Domain info
    //

    AliasInformation = &(SampDefinedDomains[ DomainIndex].AliasInformation);
    AliasInformation->MemberAliasList = OutputMemberAliasList;

    *MemberAliasList = OutputMemberAliasList;

CreateMemberAliasListFinish:

    return(Status);

CreateMemberAliasListError:

    *MemberAliasList = NULL;
    goto CreateMemberAliasListFinish;
}


NTSTATUS
SampAlGrowMemberAliasList(
    IN OUT PSAMP_AL_MEMBER_ALIAS_LIST *MemberAliasList,
    IN ULONG ExtraSpaceRequired
    )

/*++

Routine Description:

    This function grows a Member Alias List by at least the requested amount.

Arguments:

    MemberAliasList - Pointer to pointer to the Member Alias List.

    ExtraSpaceRequired - Extra space needed in the Member Alias List.

Return Values:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NewMaximumLengthMemberAliasList;
    PSAMP_AL_MEMBER_ALIAS_LIST OutputMemberAliasList = NULL;

    SAMTRACE("SampAlGrowMemberAliasList");

    //
    // Calculate the new size of the Member Alias List needed.  Round up to
    // a multiple of the granularity.
    //

    NewMaximumLengthMemberAliasList = (*MemberAliasList)->MaximumLength +
        ExtraSpaceRequired;

    NewMaximumLengthMemberAliasList +=
        (SAMP_AL_MEMBER_ALIAS_LIST_DELTA - (ULONG) 1);

    NewMaximumLengthMemberAliasList &=
        ((ULONG)(~(SAMP_AL_MEMBER_ALIAS_LIST_DELTA - (ULONG) 1)));

    //
    // We need to check Size Limitation in this routine only in DS Case
    // no cache size limitation for Registry Mode.
    //

    if ( (NewMaximumLengthMemberAliasList > SAMP_AL_MAX_MEMBER_ALIAS_LIST_LENGTH) &&
         SampUseDsData )
    {
        //
        // in DS mode, enforce alias caching buffer size limitation.
        // use STATUS_BUFFER_OVERFLOW to specify this particular failure.
        // in Registry mode, no size limitation.
        //
        Status = STATUS_BUFFER_OVERFLOW;
        goto GrowMemberAliasListError;
    }


    //
    // Allocate memory for the grown Member Alias List.
    //

    OutputMemberAliasList = MIDL_user_allocate(
                                NewMaximumLengthMemberAliasList
                                );


    if (OutputMemberAliasList == NULL) {

        Status = STATUS_NO_MEMORY;
        goto GrowMemberAliasListError;
    }


    //
    // Copy the old list to the new list and the the new maximum length.
    // Return pointer to new list.
    //

    RtlMoveMemory(
        OutputMemberAliasList,
        *MemberAliasList,
        (*MemberAliasList)->UsedLength
        );

    OutputMemberAliasList->MaximumLength = NewMaximumLengthMemberAliasList;
    ASSERT(OutputMemberAliasList->MaximumLength >=
           OutputMemberAliasList->UsedLength);
    if (NULL!=*MemberAliasList)
    {
        MIDL_user_free(*MemberAliasList);
    }
    *MemberAliasList = OutputMemberAliasList;

GrowMemberAliasListFinish:

    return(Status);

GrowMemberAliasListError:

    SampAlInfoMakeInvalid( (*MemberAliasList)->DomainIndex );

    goto GrowMemberAliasListFinish;
}


NTSTATUS
SampAlRebuildMemberAliasList(
    IN PVOID Parameter
    )
/*++

Routine Description:

    This function will rebuild the Member Alias List for the specified
    SAM Local Domain. And free the old Member Alias List
    During Rebuild, the Member Alias List should have already been invalid state.


    NOTE:  need to acquire SAM read lock before doing anything.

Arguments:

    Parameter - Pointer to DomainIndex, which specified the SAM Local Domain
                that should rebuild the Member Alias List

Return Value:

    Values returned by SampAlBuildMemberAliasList.

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;
    ULONG       DomainIndex;
    PSAMP_AL_MEMBER_ALIAS_LIST OldMemberAliasList = NULL;
    PSAMP_AL_MEMBER_ALIAS_LIST MemberAliasList = NULL;

    SAMTRACE("SampAlRebuildMemberAliasList");

    ASSERT(SampUseDsData);

    SampAcquireReadLock();

    //
    // We need to Validate Domain Cache, because for loopback case, if the commit fails, the
    // Domain Cache will be marked invalid, so before we use it, we need to validate it.
    //
    NtStatus = SampValidateDomainCache();

    if (!NT_SUCCESS(NtStatus))
    {
        goto RebuildMemberAliasListError;
    }

    DomainIndex = *(PULONG)Parameter;

    OldMemberAliasList = SampAlDomainIndexToMemberAliasList( DomainIndex );

    if (NULL != OldMemberAliasList)
    {
        SampDefinedDomains[ DomainIndex ].AliasInformation.MemberAliasList = NULL;

        LsaIRegisterNotification(
                    SampAlFreeMemberAliasList,
                    OldMemberAliasList,
                    NOTIFIER_TYPE_INTERVAL,
                    0,
                    NOTIFIER_FLAG_ONE_SHOT,
                    600,        // wait for 10 minutes, then free
                    NULL
                    );
    }

    NtStatus = SampAlBuildMemberAliasList(DomainIndex);

    //
    // if SampAlBuildMemberAliasList failed because of
    // STATUS_BUFFER_OVERFLOW, do NOT try to build Alias Cache forever
    // and free the memory allocate by SampAlCreateMemberAliasList.
    //
    // if failure due to other reason, try to rebuild later.
    //

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // if SampAlBuildMemberAliasList returns failure,
        // Alias Membership Information should already been marked as invalid in SampAlBuildMemberAliasList
        // ASSERT and make it invalid again just for safety reason.
        //
        ASSERT( FALSE == SampAlInfoIsValid(DomainIndex) );
        SampAlInfoMakeInvalid( DomainIndex );

        if (NtStatus == STATUS_BUFFER_OVERFLOW)
        {
            MemberAliasList = SampAlDomainIndexToMemberAliasList( DomainIndex );

            if ( MemberAliasList != NULL)
            {
                SampDefinedDomains[ DomainIndex ].AliasInformation.MemberAliasList = NULL;
                MIDL_user_free(MemberAliasList);
                MemberAliasList = NULL;
            }

            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            goto RebuildMemberAliasListError;
        }
    }

    MIDL_user_free(Parameter);


RebuildMemberAliasListFinish:

    SampReleaseReadLock();

    return(NtStatus);


RebuildMemberAliasListError:

    // Reschedule rebuild Member Alias Cache routine
    LsaIRegisterNotification(
                SampAlRebuildMemberAliasList,
                Parameter,
                NOTIFIER_TYPE_INTERVAL,
                0,            // no class
                NOTIFIER_FLAG_ONE_SHOT,
                900,          // wait for another 15 mins
                NULL          // no handle
                );

    goto RebuildMemberAliasListFinish;

}



NTSTATUS
SampAlBuildMemberAliasList(
    IN LONG DomainIndex
    )

/*++

Routine Description:

    This function builds the Member Alias List for the specified SAM Local
    Domain.  For each Alias, its list of member Sids is read from backing
    storage and MemberDomain and MemberAccount blocks are created.

Arguments:

    DomainIndex - Specifies the SAM Local Domain

--*/

{
    NTSTATUS Status, EnumerationStatus;
    PSAMP_AL_MEMBER_ALIAS_LIST OutputMemberAliasList = NULL;
    SAMPR_ULONG_ARRAY AliasRids;
    ULONG Rids[1], EnumerationContext, AliasCount, AliasRid;
    ULONG AliasIndex;
    PSAMP_OBJECT AliasContext = NULL;
    SAMPR_PSID_ARRAY MemberSids;
    ULONG DomainSidMaximumLength = RtlLengthRequiredSid( 256 );
    PSAMPR_ENUMERATION_BUFFER EnumerationBuffer = NULL;

    SAMTRACE("SampAlBuildMemberAliasList");

    AliasRids.Element = Rids;

    SampAlInfoMakeInvalid( DomainIndex );

    //
    // Create an empty Member Alias List and connect it to the
    // local SAM Domain.
    //

    Status = SampAlCreateMemberAliasList(
                 DomainIndex,
                 SAMP_AL_INITIAL_MEMBER_ALIAS_LIST_LENGTH,
                 &OutputMemberAliasList
                 );

    if (!NT_SUCCESS(Status)) {

        goto BuildMemberAliasListError;
    }

    //
    // For each Alias in the SAM local domain, add its members to the
    // Alias List
    //

    EnumerationContext = 0;
    EnumerationStatus = STATUS_MORE_ENTRIES;

    //
    // It is currently necessary to set the Transaction Domain before
    // calling SampEnumerateAccountNames even though we're not modifying
    // anything.  The is because called routine SampBuildAccountKeyName()
    // uses this information.
    //

    SampSetTransactionWithinDomain(FALSE);
    SampSetTransactionDomain( DomainIndex );

    while (EnumerationStatus == STATUS_MORE_ENTRIES) {

        Status = SampEnumerateAccountNames(
                     SampAliasObjectType,
                     &EnumerationContext,
                     &EnumerationBuffer,
                     SAMP_AL_ENUM_PREFERRED_LENGTH,
                     0,
                     &AliasCount,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        EnumerationStatus = Status;

        for (AliasIndex = 0; AliasIndex < AliasCount; AliasIndex++) {

            AliasRid = EnumerationBuffer->Buffer[ AliasIndex ].RelativeId;

            //
            // Create a context for the account.
            //

            Status = SampCreateAccountContext(
                         SampAliasObjectType,
                         AliasRid,
                         TRUE,
                         FALSE,
                         TRUE,
                         &AliasContext
                         );

            if (NT_SUCCESS(Status)) {

                //
                // There is a rather ugly feature of the way the DomainIndex
                // field is used in context handles while initializing.  This
                // value is set to the count of SAM Local Domains!  So, I am
                // setting it to the DomainIndex for the SAM Local Domain we're
                // initializing, since this AliasContext is used only by me.
                //

                AliasContext->DomainIndex = DomainIndex;

                Status = SampAlQueryMembersOfAlias(
                             AliasContext,
                             &MemberSids
                             );

                if (NT_SUCCESS(Status)) {

                    //
                    // Add these members to the Alias.  No need to verify that
                    // they are already present since we're loading the Member Alias
                    // List from scratch.
                    //

                    Status = SampAlAddMembersToAlias(
                                 AliasContext,
                                 0,
                                 &MemberSids
                                 );
                }

                //
                // free the memory allocated
                //

                if (MemberSids.Sids!=NULL)
                {
                    MIDL_user_free(MemberSids.Sids);
                    MemberSids.Sids = NULL;
                }

                SampDeleteContext( AliasContext );
            }

            if (!NT_SUCCESS(Status)) {

                break;
            }
        }

        //
        // Enumerate next set of Aliases
        //

        if (!NT_SUCCESS(Status)) {

            break;
        }

        //
        // Dispose of the Enumeration Buffer returned by SampEnumerateAccountNames
        //

        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumerationBuffer );
        EnumerationBuffer = NULL;
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildMemberAliasListError;
    }

    //
    // Mark the Member Alias List valid
    //

    SampAlInfoMakeValid( DomainIndex );

BuildMemberAliasListFinish:

    if (NULL!=EnumerationBuffer)
        SamIFree_SAMPR_ENUMERATION_BUFFER( EnumerationBuffer );

    SampSetTransactionWithinDomain(FALSE);
    return(Status);

BuildMemberAliasListError:

    goto BuildMemberAliasListFinish;
}

NTSTATUS
SampAlFreeMemberAliasList(
    IN PVOID Parameter
    )

/*++

Routine Description:

    This function frees the Member Alias List for a specific SAM
    Local Domain.

    NOTE: we do not acquire SAM Write Lock, since when we free that memory, hopefully,
          no one else will still use it.

Argument:

    Parameter - pointer to SAMP_AL_MEMBER_ALIAS_LIST

Return Value:

    none.

--*/
{
    SAMTRACE("SampAlFreeMemberAliasList");

    ASSERT(Parameter != NULL);

    if (Parameter != NULL)
    {
        MIDL_user_free( (PSAMP_AL_MEMBER_ALIAS_LIST) Parameter);
    }

    return(STATUS_SUCCESS);
}



BOOLEAN
SampAlInfoIsValidForDomain(
    IN SAMPR_HANDLE DomainHandle
    )

/*++

Routine Description:

    This function checks whether Alias Information is valid for a specific
    SAM Local Domain

Arguments:

    DomainHandle - Handle to SAM Local Domain

Return Values:

    BOOLEAN - TRUE if Alias Information is valid.  The Alias Information may
        be used in place of the backing storage to determine Alias membership
        FALSE if the Alias Information is not valid.  The Alias Information
        does not exist, or is not reliable.

--*/

{
    LONG DomainIndex;

    SAMTRACE("SampAlInfoIsValidForDomain");

    //
    // Get the Domain Index for the SAM Local Domain specified by DomainHandle.

    DomainIndex = ((PSAMP_OBJECT) DomainHandle)->DomainIndex;

    return(SampAlInfoIsValid( DomainIndex ));
}


BOOLEAN
SampAlInfoIsValidForAlias(
    IN SAMPR_HANDLE AliasHandle
    )

/*++

Routine Description:

    This function checks whether Alias Information is valid for a specific
    Alias.  The information is valid if it is valid for the SAM Local Domain
    containing the Alias.

Arguments:

    AliasHandle - Handle to SAM Alias

Return Values:

    BOOLEAN - TRUE if Alias Information is valid.  The Alias Information may
        be used in place of the backing storage to determine Alias membership
        FALSE if the Alias Information is not valid.  The Alias Information
        does not exist, or is not reliable.

--*/

{
    LONG DomainIndex;

    SAMTRACE("SampAlInfoIsValidForAlias");

    //
    // Get the Domain Index for the SAM Local Domain specified by DomainHandle.

    DomainIndex = ((PSAMP_OBJECT) AliasHandle)->DomainIndex;

    return(SampAlInfoIsValid( DomainIndex ));
}


NTSTATUS
SampAlInvalidateMemberAliasList(
    IN ULONG DomainIndex
    )

/*++

Routine Description:

    This funtion invalidate Memeber Alias List, delay Member Alias List
    rebuild routine. This routine is called by SampAlInvalidateAliasInformation.
    The caller should hold Sam Write Lock.

Arguments:

    DomainIndex - Specify the SAM Local Domain

Return Value:

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PULONG      pDomainIndex;

    SAMTRACE("SampAlInvalidateMemberAliasList");

    //
    // Invalidate Member Alias List at once.
    //

    SampAlInfoMakeInvalid(DomainIndex);

    pDomainIndex = MIDL_user_allocate(sizeof(ULONG));

    if (pDomainIndex == NULL)
    {
        return(STATUS_NO_MEMORY);
    }

    *pDomainIndex = DomainIndex;

    LsaIRegisterNotification(
                SampAlRebuildMemberAliasList,
                pDomainIndex,
                NOTIFIER_TYPE_INTERVAL,
                0,         // no class
                NOTIFIER_FLAG_ONE_SHOT,
                900,      // wait for 15 minutes
                NULL       // no handle
                );

    return (NtStatus);

}

NTSTATUS
SampFreeAliasNameCache(
    PVOID p
    )
/*++

Routine Description:

    This routine frees p, which is assumed to be a SAMP_ACCOUNT_NAME_CACHE.

Arguments:

    p -- a PVOID so this routine can be used as a callback

Return Values:

    STATUS_SUCCESS

--*/
{
    PSAMP_ACCOUNT_NAME_CACHE NameCache = (PSAMP_ACCOUNT_NAME_CACHE) p;
    ULONG i;

    if (NameCache) {

        if (NameCache->Entries) {

            ASSERT( NameCache->Count > 0);
            for (i = 0; i < NameCache->Count; i++) {
                if ( NameCache->Entries[i].Name.Buffer ) {
                    MIDL_user_free(NameCache->Entries[i].Name.Buffer);
                }
            }

            MIDL_user_free(NameCache->Entries);

        } else {

            ASSERT(NameCache->Count == 0);

        }

        MIDL_user_free(NameCache);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampBuildAliasNameCache(
    ULONG DomainIndex
    )
/*++

Routine Description:

    This routine builds the account name cache for the domain at DomainIndex.
    This routine assumes that DomainIndex is a builtin domain since only
    the only accounts expected in the domain are a few aliases

Arguments:

    DomainIndex -- an index into the SampDefinedDomains structure

Return Values:

    STATUS_SUCCESS, or resource error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME *ObjectNameInDs;
    ULONG EnumerationContext = 0;
    PSAMPR_RID_ENUMERATION RidList;
    PSAMPR_ENUMERATION_BUFFER Buffer = NULL;
    PSAMP_ACCOUNT_NAME_CACHE AccountNameCache = NULL;
    ULONG CountReturned = 0;
    ULONG Length;
    ULONG i;
    PVOID PtrToFree;

    //
    // N.B. Since SampEnumerateAccountNames2 is a thread safe routine
    // and only fixed values are referred in this routine, no SAM
    // lock is necessary.
    //

    //
    // This is only valid for builtin DS domains
    //
    ASSERT(IsBuiltinDomain(DomainIndex));
    ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));
    ObjectNameInDs = SampDefinedDomains[DomainIndex].Context->ObjectNameInDs;

    //
    // Query for the aliases  (this routine handles all transactioning)
    //
    NtStatus = SampEnumerateAccountNames2(
                            SampDefinedDomains[DomainIndex].Context,
                            SampAliasObjectType,
                            (PULONG) &EnumerationContext,  // largely ignored
                            &Buffer,
                            0xFFFFFFFF,  // as much as possible
                            0, // no filter
                            &CountReturned,
                            TRUE // trusted client
                            );

    //
    // All the builtin aliases should be returned in one
    // call
    //
    ASSERT(NtStatus != STATUS_MORE_ENTRIES);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }
    ASSERT(CountReturned == Buffer->EntriesRead);
    RidList = Buffer->Buffer;

    //
    // Prepare the new cache structure
    //
    AccountNameCache = MIDL_user_allocate(sizeof(*AccountNameCache));
    if (NULL == AccountNameCache) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(AccountNameCache, sizeof(*AccountNameCache));

    Length = sizeof(*AccountNameCache->Entries) * CountReturned;
    AccountNameCache->Entries = MIDL_user_allocate(Length);
    if (NULL == AccountNameCache->Entries) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    RtlZeroMemory(AccountNameCache->Entries, Length);

    //
    // Copy the names and RID's into the cache
    //
    for (i = 0; i < CountReturned; i++) {
        AccountNameCache->Entries[i].Rid = RidList[i].RelativeId;
        // transfer the memory
        AccountNameCache->Entries[i].Name = *(PUNICODE_STRING)(&RidList[i].Name);
        RtlInitUnicodeString((PUNICODE_STRING)&RidList[i].Name, NULL);
    }
    AccountNameCache->Count = CountReturned;

    //
    // Carefully transfer to the global state
    //
    PtrToFree = InterlockedExchangePointer(&SampDefinedDomains[DomainIndex].AccountNameCache,
                                           AccountNameCache);
    AccountNameCache = NULL;

    if (PtrToFree) {
        //
        // In normal cases, PtrToFree will be NULL since the cache is only
        // build after it has been validated. However, in cases in which this
        // routine fails and is rescheduled and in the meantime a succesful
        // rebuild as occurred, there will be something to free.
        //
        LsaIRegisterNotification(
                SampFreeAliasNameCache,
                PtrToFree,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                3600,     // wait for 60 min
                NULL      // no handle
                );
        PtrToFree = NULL;
    }

Cleanup:

    if (Buffer) {
        SamIFree_SAMPR_ENUMERATION_BUFFER(Buffer);
    }

    if (AccountNameCache) {
        if (AccountNameCache->Entries) {
            for (i = 0; i < AccountNameCache->Count; i++) {
                if (AccountNameCache->Entries[i].Name.Buffer) {
                    MIDL_user_free(AccountNameCache->Entries[i].Name.Buffer);
                }
            }
            MIDL_user_free(AccountNameCache->Entries);
        }
        MIDL_user_free(AccountNameCache);
    }

    return NtStatus;
}


NTSTATUS
SampBuildAliasNameCacheCallback(
    PVOID p
    )
/*++

Routine Description:

    This routine is a callback wrapper for SampBuildAliasNameCache()

Arguments:

    p -- pointer to ULONG which represents which domain index to rebuild

Return Values:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status;
    ULONG DomainIndex = *(PULONG)p;

    Status = SampBuildAliasNameCache(DomainIndex);
    if ( NT_SUCCESS(Status) ) {

        MIDL_user_free(p);

    } else {

        //
        // Try again in 5 minutes
        //
        LsaIRegisterNotification(
                SampBuildAliasNameCacheCallback,
                p,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                5 * 60,   // wait for 5 min
                NULL      // no handle
                );
    }

    return STATUS_SUCCESS;
}

VOID
SampInvalidateAliasNameCache(
    ULONG DomainIndex
    )
/*++

Routine Description:

    This routine invalidates the AccountName cache on the DomainIndex
    SampDefinedDomains structure.  It does this by NULL'ing out the field.
    Also, if the cache was in fact invalidating, a refresh is scheduled.

Arguments:

    DomainIndex -- an index into SampDefinedDomains

Return Values:

    None

--*/
{
    PVOID PtrToFree;

    //
    // Invalidate the domain wide cache, by setting the cache ptr to NULL
    //
    PtrToFree = InterlockedExchangePointer(&SampDefinedDomains[DomainIndex].AccountNameCache,
                                           NULL);
    if ( PtrToFree ) {

        PULONG pDomainIndex;
        //
        // Free the existing information (in an hour)
        //
        LsaIRegisterNotification(
                SampFreeAliasNameCache,
                PtrToFree,
                NOTIFIER_TYPE_INTERVAL,
                0,        // no class
                NOTIFIER_FLAG_ONE_SHOT,
                3600,     // wait for 60 min
                NULL      // no handle
                );

        //
        // Schedule a rebuild
        //
        // N.B. A rebuild is only scheduled when an existing cache is
        // invalidated
        //
        pDomainIndex = MIDL_user_allocate(sizeof(ULONG));
        if (pDomainIndex) {

            *pDomainIndex = DomainIndex;

            LsaIRegisterNotification(
                    SampBuildAliasNameCacheCallback,
                    pDomainIndex,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    5,        // wait for 5 seconds
                    NULL      // no handle
                    );
        }
    }

    return;

}


NTSTATUS
SampInitAliasNameCache(
    VOID
    )
/*++

Routine Description:

    This routine schedules a building of the account name cache for
    all DS builtin domains.

    This cache is a performance optimization only.  It creates a list if
    SamAccountNames and RID's that hang off of the SampDefinedDomains structure
    (field, AccountNameCache).  Typically it is NULL and hence does not affect
    normal lookups.  However, for DS builtin domains the value will be non NULL
    as it is simply to cache in memory the 10-15 aliases that live in the
    builtin domain.  Whenever a change occurs in the builtin domain, via
    a SAM call, an LDAP call, replication, etc, the cache is invalidated
    by setting AccountNameCache to NULL and a (asynchronous) rebuild is
    scheduled.

Arguments:

    None

Return Values:

    STATUS_SUCCESS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG   DomainIndex;
    PULONG pDomainIndex;

    ASSERT(SampUseDsData);
    if (!SampUseDsData) {
        return STATUS_SUCCESS;
    }

    //
    // N.B. Since this routine only touches fixed fields of the
    // SampDefinedDomains structure, no lock is necessary.
    //
    for (DomainIndex = SampDsGetPrimaryDomainStart();
         DomainIndex < SampDefinedDomainsCount;
         DomainIndex++) {

        ASSERT(IsDsObject(SampDefinedDomains[DomainIndex].Context));
        if ( IsBuiltinDomain(DomainIndex) ) {

            pDomainIndex = MIDL_user_allocate(sizeof(ULONG));
            if ( NULL == pDomainIndex ) {
                Status = STATUS_NO_MEMORY;
                break;
            }
            *pDomainIndex = DomainIndex;

            LsaIRegisterNotification(
                    SampBuildAliasNameCacheCallback,
                    pDomainIndex,
                    NOTIFIER_TYPE_INTERVAL,
                    0,        // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    5,        // wait for 5 seconds
                    NULL      // no handle
                    );

            pDomainIndex = NULL;

        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\context.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This file contains services for operating on internal context blocks.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:
    31 - May 1996 Murlis
        Ported to use the NT5 DS.

    ChrisMay 10-Jun-96
        Added initialization of Context->ObjectNameInDs and IsDsObject data
        members. Note that this causes context objects to be created with a
        default storage of type registry (instead of DS).

    6-16-96
       Moved DS object decision to SampCreateContext for account objects.

    9-19-97
        Added full multi threading support for logons

--*/


//
// DESCRIPTION and brief History
//
//  Sam Context's in the NT4  time frame used to be created
//  with SampCreateContext. This used to create a context, initialize it and
//  and add it to the various list's of currently active context's. Delete
//  operations in SAM would then invalidate all the open context's for that
//  object by walking through the list of context's and checking for the
//  corresponding object. This scheme worked in NT4 and earlier SAM because
//  all services held the SAM lock for exclusive access. To improve performance
//  NT5 Sam multi-threads many operations. To allow for easy multi-threading
//  the CreateContextEx service was introduced. This service takes the NotSharedByMultiThreads 
//  parameter, and does not add ThreadSafe context's into any of the in-memory
//  Context lists in DS. This prevents any invalidations,if the object corresponding to
//  the context was deleted. Sam service calls in Ds mode, simply error out if
//  any Ds call would fail, as would happen when the object is deleted. The
//  CreateContextEx also allows setting of many parameters on the context, that
//  allow for more intelligent caching and updates of the object.
//

//
//  10-27-2000 (ShaoYin)
//  Change variable ThreadSafe to NotSharedByMultiThreads
//  
//      NotSharedByMultiThreads will be set for all user, group and alias contexts,
//      and all domain and server contexts that do not originate from in process
//      callers that share handles among threads.
//
// 



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dslayer.h>
#include <dsmember.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampCheckIfObjectExists(
                        IN  PSAMP_OBJECT    Context
                        );

BOOLEAN
SampIsObjectLocated(
                    IN  PSAMP_OBJECT Context
                    );

NTSTATUS
SampLocateObject(
                 IN PSAMP_OBJECT Context,
                 IN ULONG   Rid
                 );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





PSAMP_OBJECT
SampCreateContext(
    IN SAMP_OBJECT_TYPE Type,
    IN ULONG   DomainIndex,
    IN BOOLEAN TrustedClient
    )
/*++

  Routine Description

    This service creates a context, that is compatible with the context's
    created in NT4 SAM. This routine requires that a transaction domain be
    set, if the required context was user, group or alias object type. This
    service calls SampCreateContextEx with appropriate parameters to do the
    job.

    Note: 10/12/2000 (ShaoYin) 
        "Transaction Domain be set" is no longer a requirement for this 
        routine. Actually all it wants for "Transaction Domain" is "Domain
        Index". So just passing "DomainIndex" into this routine, we will
        no longer need "TransactionDomain be set", thus no lock is required
        for this routine. Just like SampCreateContextEx(). 

  Arguments

    Type  -- The type of the object.

    DomainIndex - set the domain index of this context
    
    TrustedClient -- Indicates whether this is a trusted client

  Return Values

    Address of valid context on success
    NULL on failure

--*/
{
    BOOLEAN NotSharedByMultiThreads = FALSE;


    // 
    // Comment this out, or let the caller calls SampCreateContextEx  10/12/2000
    // 
    // ASSERT(SampCurrentThreadOwnsLock() || (SampServiceState!=SampServiceEnabled)); 
    // 

    //
    // Account Context's are thread safe in DS mode
    //

    if ( (SampUserObjectType==Type) ||
         (SampGroupObjectType == Type) || 
         (SampAliasObjectType == Type) )
    {
        NotSharedByMultiThreads = TRUE;
    }

    return ( SampCreateContextEx(
                    Type,
                    TrustedClient,
                    SampUseDsData,
                    NotSharedByMultiThreads, // NotSharedByMultiThreads
                    FALSE, // loopback client
                    FALSE, // lazy commit
                    FALSE, // persis across across calls
                    FALSE, // Buffer Writes
                    FALSE, // Opened By DCPromo
                    DomainIndex
                    ));
}




PSAMP_OBJECT
SampCreateContextEx(
    IN SAMP_OBJECT_TYPE Type,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN DsMode,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN LazyCommit,
    IN BOOLEAN PersistAcrossCalls,
    IN BOOLEAN BufferWrites,
    IN BOOLEAN OpenedByDCPromo,
    IN ULONG   DomainIndex
    )

/*++

Routine Description:

    This service creates a new object context block of the specified type.

    If the context block is for either a user or group object type, then
    it will be added to the list of contexts for the domain specified by the
    context.


    Upon return:

         - The ObjectType field will be set to the passed value.

         - The Reference count field will be set to 1,

         - The GrantedAccess field will be zero.

         - The TrustedClient field will be set according to the passed
           value.

         - The Valid flag will be TRUE.

    All other fields must be filled in by the creator.


Arguments:

    Type - Specifies the type of context block being created.

    TrustedClient  Indicates whether the client is a trusted component
            of the operating syste.  If so, than all access checks are
            circumvented.

    DsMode   - Indicates that the given context is for DsMode operation

    NotSharedByMultiThreads - Allows the context to be marked as NotSharedByMultiThreads. 
             This allows many query API's in DS Mode to bypass the Sam lock 
             mechanism. NotSharedByMultiThreads context's in DS Mode are not 
             added to list of context's maintained in global data structures. 
             This keeps them safe from being invalidated because of deletions 
             to the object.

             This variable will be set for all User, Group and Alias contexts, 
             and all domain and server contexts that do not originate from in 
             process callers that share handles amongst threads. Routines 
             manipulating a domain context that is shared across multiple threads, 
             but do no real work on the domain context can still choose not to 
             lock and be careful about DerefernceContext2.


    LoopbackClient - Allows the context to be marked as Loopback Client. This
             allows LDAP clients to bypass the SAM lock mechanism. Loopback
             client context's are NOT added to list of the context's maintained
             in global data structures, since Loopback client does not share 
             context handle. And loopback clients are safe wrt object deletions.             

    LazyCommit - Will mark the context as such. This will let the commit code
                 do lazy commits on this context

    PersistAcrossCalls  -- Data cached in the context will be persisted across
                      Sam calls

    BufferWrites -- Writes will be made only to the SAM context and then will be
                    written out during close handle time

    OpenedByDCPromo -- Indicates whether this context is opened by DCPromo part or not                    

    DomainIndex  --   Index specifying the domain

Return Value:


    Non-Null - Pointer to a context block.

    NULL - Insufficient resources.  No context block allocated.


--*/
{

    PSAMP_OBJECT Context = NULL;
    NTSTATUS     NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampCreateContextEx");


    Context = MIDL_user_allocate( sizeof(SAMP_OBJECT) );
    if (Context != NULL) {

#if SAMP_DIAGNOSTICS
    IF_SAMP_GLOBAL( CONTEXT_TRACKING ) {
            SampDiagPrint( CONTEXT_TRACKING, ("Creating  ") );
            if (Type == SampServerObjectType) SampDiagPrint(CONTEXT_TRACKING, ("Server "));
            if (Type == SampDomainObjectType) SampDiagPrint(CONTEXT_TRACKING, (" Domain "));
            if (Type == SampGroupObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("  Group "));
            if (Type == SampAliasObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("   Alias "));
            if (Type == SampUserObjectType)   SampDiagPrint(CONTEXT_TRACKING, ("    User "));
            SampDiagPrint(CONTEXT_TRACKING, ("context : 0x%lx\n", Context ));
    }
#endif //SAMP_DIAGNOSTICS

        RtlZeroMemory( Context, sizeof(SAMP_OBJECT) );

        //
        // Check How many Active Contexts have been opened by 
        // this client so far
        // 

        if (!TrustedClient && !LoopbackClient) {

            //
            // Context has been passed into the following routine
            // so that the pointer to the element will be set when succeeded.
            // 
            NtStatus = SampIncrementActiveContextCount(Context);

            if (!NT_SUCCESS(NtStatus))
            {
                MIDL_user_free(Context);
                return(NULL);
            }
        }


        Context->ObjectType      = Type;
        Context->ReferenceCount  = 1;    // Represents RPCs held context handle value
        Context->GrantedAccess   = 0;

        Context->RootKey         = INVALID_HANDLE_VALUE;
        RtlInitUnicodeString(&Context->RootName, NULL);

        //
        // Here is my observation: for User / Group / Alias Object
        // 
        // In DS mode, 
        // the context should either be NotSharedByMultiThreads or LoopbackClient.
        //
        // So for those object contexts (User / Group / Alias)
        // Since they are either NotSharedByMultiThreads or Loopback Client, we
        // will not put them in the Global Context List,
        // therefore we don't need to invalidate the ContextList 
        // during Object Deletion.
        // 
        // Server and Domain Object are not included. However, no one
        // will try to (or allowed to) delete server or domain object.
        // 

        ASSERT(!DsMode || 
               (SampServerObjectType == Type) ||
               (SampDomainObjectType == Type) ||
               NotSharedByMultiThreads ||
               LoopbackClient);

        Context->TrustedClient   = TrustedClient;
        Context->LoopbackClient  = LoopbackClient;
        Context->MarkedForDelete = FALSE;
        Context->AuditOnClose    = FALSE;

        Context->OnDisk          = NULL;
        Context->PreviousOnDisk  = NULL;
        Context->OnDiskAllocated = 0;
        Context->FixedValid      = FALSE;
        Context->VariableValid   = FALSE;
        Context->NotSharedByMultiThreads      = NotSharedByMultiThreads || LoopbackClient;    // Loopback Client is also Thread Safe
        Context->RemoveAccountNameFromTable = FALSE;
        Context->LazyCommit      = LazyCommit;
        Context->PersistAcrossCalls = PersistAcrossCalls;
        Context->BufferWrites    = BufferWrites;
        Context->ReplicateUrgently  = FALSE;
        Context->OpenedBySystem     = FALSE;
        Context->OpenedByDCPromo = OpenedByDCPromo;

        //
        // The following are meaningless at this point because of the
        // values of the variables above, but we'll set them just to be
        // neat.
        //

        Context->FixedDirty      = FALSE;
        Context->VariableDirty   = FALSE;

        Context->OnDiskUsed      = 0;
        Context->OnDiskFree      = 0;

        //
        // Initialize the Client revision to pre-NT5 for safety
        //

        Context->ClientRevision = SAM_CLIENT_PRE_NT5;

        //
        // Initialize the Per attribute Dirty Bits
        //

        RtlInitializeBitMap(
            &Context->PerAttributeDirtyBits,
            Context->PerAttributeDirtyBitsBuffer,
            MAX_SAM_ATTRS
            );

        RtlClearAllBits(
            &Context->PerAttributeDirtyBits
            );

        Context->AttributesPartiallyValid = FALSE;

        //
        // Intialize the per attribute Invalid Bits
        //

        RtlInitializeBitMap(
            &Context->PerAttributeInvalidBits,
            Context->PerAttributeInvalidBitsBuffer,
            MAX_SAM_ATTRS
            );

        RtlClearAllBits(
            &Context->PerAttributeInvalidBits
            );

        //
        // Initialize the attributes granted bit map
        //
        RtlInitializeBitMap(
            &Context->WriteGrantedAccessAttributes,
            Context->WriteGrantedAccessAttributesBuffer,
            MAX_SAM_ATTRS
            );

        RtlClearAllBits(
            &Context->WriteGrantedAccessAttributes
            );

        //
        // Initialize the Type of context ( Registry or DS )
        // The root key in registry mode, and the object name in DS
        // in DsMode fields will be set later to indicate valid
        // database pointers to the object
        //

        if (DsMode)
        {
            SetDsObject(Context);
            Context->DsClassId = SampDsClassFromSamObjectType(Type);
        }
        else
        {
            SetRegistryObject(Context);
            Context->DsClassId = 0;
        }

        Context->ObjectNameInDs = NULL;


        //
        // Add this new context to the set of valid contexts ...
        //

        SampAddNewValidContextAddress( Context );


        //
        // User and group context blocks are kept on linked lists
        // from the domain's in-memory structure.  Insert in the
        // Appropriate List and then additionally for Account Objects
        // Make the DS/Registry decision by looking at the TransactionDomain
        //

        Context->DomainIndex = DomainIndex;

        switch (Type) {

        case SampDomainObjectType:

            Context->TypeBody.Domain.DsDisplayState.Restart = NULL;
            Context->TypeBody.Domain.DsDisplayState.TotalAvailable=0;
            Context->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
            Context->TypeBody.Domain.DsDisplayState.DisplayInformation = 0;
            Context->TypeBody.Domain.DsDisplayState.NextStartingOffset = 0;

            //////////////////////////////////////////////////////
            //                                                  //
            //   Warning This case falls into the next one      //
            //                                                  //
            //////////////////////////////////////////////////////
        case SampServerObjectType:

            //
            // Clients marked as NotSharedByMultiThreads are free
            // of object deletion. Do not need to put them into the ContextList
            // 
            // Don't put context opened by dcpromo to ContextList
            // 
            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }

            break;

        case SampUserObjectType:

            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                // Insert into List
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }

            // Set PrivilegedMachineAccountCreate to False
            Context->TypeBody.User.PrivilegedMachineAccountCreate = FALSE;

            // Initialize the supplemental credential information
            Context->TypeBody.User.CachedSupplementalCredentials = NULL;
            Context->TypeBody.User.CachedSupplementalCredentialLength = 0;
            Context->TypeBody.User.CachedSupplementalCredentialsValid = FALSE;
            Context->TypeBody.User.SupplementalCredentialsToWrite = NULL;

            // Initialize uparms accessible and DomainSidForNT4Conversion fields
            Context->TypeBody.User.UparmsInformationAccessible = FALSE;
            Context->TypeBody.User.DomainSidForNt4SdConversion = NULL;

            // Mark the Original UserParms invalid
            Context->TypeBody.User.CachedOrigUserParms = NULL;
            Context->TypeBody.User.CachedOrigUserParmsLength = 0;
            Context->TypeBody.User.CachedOrigUserParmsIsValid = FALSE;

            // Initialize the UPN in the context

            RtlZeroMemory(&Context->TypeBody.User.UPN, sizeof(UNICODE_STRING));
            Context->TypeBody.User.UpnDefaulted = TRUE;

            Context->TypeBody.User.fNoGcAvailable = FALSE;

            // Clear the A2D2 Attribute
            Context->TypeBody.User.A2D2List = NULL;
            Context->TypeBody.User.A2D2Present = FALSE;
            
            // Clear the SPN list Attribute

            Context->TypeBody.User.SPNList = NULL;
            Context->TypeBody.User.SPNPresent = FALSE;

            // set KVNO to 1

            Context->TypeBody.User.KVNO    = 1;
            Context->TypeBody.User.KVNOPresent = FALSE;

            break;

        case SampGroupObjectType:

            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                // Insert into List
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }

            Context->TypeBody.Group.SecurityEnabled = TRUE;
            Context->TypeBody.Group.NT4GroupType = NT4GlobalGroup;
            Context->TypeBody.Group.NT5GroupType = NT5AccountGroup;
            Context->TypeBody.Group.CachedMembershipOperationsListMaxLength = 0;
            Context->TypeBody.Group.CachedMembershipOperationsListLength = 0;
            Context->TypeBody.Group.CachedMembershipOperationsList = NULL;

            break;

        case SampAliasObjectType:

            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                // Insert into List
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }


            Context->TypeBody.Alias.SecurityEnabled = TRUE;
            Context->TypeBody.Alias.NT4GroupType = NT4LocalGroup;
            Context->TypeBody.Alias.NT5GroupType = NT5ResourceGroup;
            Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength = 0;
            Context->TypeBody.Alias.CachedMembershipOperationsListLength = 0;
            Context->TypeBody.Alias.CachedMembershipOperationsList = NULL;

            break;
        }

    }

    return(Context);
}


VOID
SampDeleteContext(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service marks a context object for delete and dereferences it.
    If this causes the reference count to go to zero, then the context
    block will be immediately deleted (deallocated).  Otherwise, the
    context block will be deleted when the reference count finally does
    go to zero.


    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to delete.

Return Value:

    None.



--*/
{
    NTSTATUS IgnoreStatus;
    BOOLEAN  ImpersonatingAnonymous = FALSE;
    BOOLEAN  Impersonating = FALSE;


    SAMTRACE("SampDeleteContext");

    Context->MarkedForDelete = TRUE;



    if (!Context->TrustedClient) 
    {
        IgnoreStatus = SampImpersonateClient(&ImpersonatingAnonymous );
        if (NT_SUCCESS(IgnoreStatus))
        {
            Impersonating = TRUE;
        }

        //
        // On a failure to impersonate do not fail the DelteContext
        // as that would cause the handle to be not closed and leak
        // memory. Instead proceed to audit the close as system if
        // possible
        //
    }
        
    //
    // Audit the close of this context.
    //

    (VOID) NtCloseObjectAuditAlarm (
               &SampSamSubsystem,
               (PVOID)Context,
               Context->AuditOnClose
               );

    if (Impersonating)
    {
        SampRevertToSelf(ImpersonatingAnonymous);
    }



    //
    // Remove this context from the valid context set.
    // Note that the context may have already been removed.  This is
    // not an error.
    //

    SampInvalidateContextAddress( Context );


    //
    // User and group context blocks are kept on linked lists
    // from the domain's in-memory structure.  Domain and
    // server context blocks are kept on a global in-memory list.
    // They are removed when they are marked for delete.
    //
    // Context opened by DCPromo is not in ContextList.
    // 

    if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
        && (!Context->OpenedByDCPromo))
    {
        SampRemoveEntryContextList(&Context->ContextListEntry);
    }

    //
    // We have to call dereference to counter the initial count of 1
    // put on by create.
    //


    IgnoreStatus = SampDeReferenceContext( Context, FALSE );


    return;

}


NTSTATUS
SampLookupContext(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    )
//
// See SampLookupContextEx
//
{

    return SampLookupContextEx(Context,
                               DesiredAccess,
                               NULL,
                               ExpectedType,
                               FoundType);
}




NTSTATUS
SampLookupContextEx(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN PRTL_BITMAP RequestedAttributeAccess OPTIONAL,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    )

/*++

Routine Description:

    This service:

        - Checks to make sure the Service state is one in which an
          object can be looked up (i.e., not Initializing or Terminating).

        - Makes sure the Service state is compatible with the lookup.
          Non-trusted clients can only perform lookups when the Service
          state is Enabled.  If the client isn't trusted and the context
          is for a group or user, then the state of that object's domain
          must also be enabled

        - Checks to make sure the context block represents the
          type of object expected, and, if so:

            - Checks to see that the caller has the requested (desired)
              access, and, if so:

                - Makes sure the object still exists, and opens it if it
                  does.  Servers and domains can't be deleted, and so
                  their handle is left open.

                - References the context block


    Note that if the block is marked as TrustedClient, then access will
    always be granted unless service state prevents it.

    Also, if the ExpectedType is specified to be unknown, then any type
    of context will be accepted.



    If the type of object is found to be , Domain, Group or User, then the
    this service will set the transaction domain.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.
    (For Loopback Client, the SAM Lock is not a requirement) 


Arguments:

    Context - Pointer to the context block to look-up.

    DesiredAccess - The type of access the client is requesting to this
        object.  A zero-valued access mask may be specified.  In this case,
        the calling routine must do access validation.

        Note: SAMP_CLOSE_OPERATION_ACCESS_MASK is a special value, which 
              indicates the caller is SamrCloseHandle, thus we should not 
              check Context->Valid Flag.

    RequestedAttributeAccess -- bit mask of requested attributes

    ExpectedType - The type of object expected.  This may be unknown.  In
        this case, the DesiredAccess should only include access types that
        apply to any type of object (e.g., Delete, WriteDacl, et cetera).

    FoundType - Receives the type of context actually found.

Return Value:

    STATUS_SUCCESS - The context was found to be the type expected (or any
        type if ExpectedType was unknown) and the DesiredAccesses are all
        granted.

    STATUS_OBJECT_TYPE_MISMATCH - Indicates the context was not the expected
        type.

    STATUS_ACCESS_DENIED - The desired access is not granted by this context.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  CloseOperation = FALSE;

    SAMTRACE("SampLookupContext");



    //
    // Make sure we are in a legitimate state to at least access
    // a context block.  If we are initializing we have somehow allowed
    // a connect through.  This should never happen.
    // If we are terminating, clients may still have handles (since we
    // have no way to tell RPC they are no longer valid without the client
    // calling us, Argh!).  However, since we are terminating, the blocks
    // are being cleaned up and may no longer be allocated.
    //

    ASSERT( (SampServiceState != SampServiceInitializing) || (SampUpgradeInProcess) );
    if ( SampServiceState == SampServiceTerminating ) {
        return(STATUS_INVALID_SERVER_STATE);
    }


    //
    // Make sure the passed context address is (still) valid.
    //

    NtStatus = SampValidateContextAddress( Context );
    if ( !NT_SUCCESS(NtStatus) ) {
        return(NtStatus);
    }

    //
    // if SAMP_CLOSE_OPERATION_ACCESS_MASK 1 is passed in as desired access, 
    // don't do any access check. 
    // otherwise, make sure this context is marked valid.
    // 

    if ( SAMP_CLOSE_OPERATION_ACCESS_MASK  == DesiredAccess) 
    {
        DesiredAccess = 0;
        CloseOperation = TRUE;
    }
    else
    {
        if (!Context->Valid)
        {
            return(STATUS_INVALID_HANDLE); 
        }
    }

    //
    // Check type
    //

    (*FoundType) = Context->ObjectType;
    if (ExpectedType != SampUnknownObjectType) {
        if (ExpectedType != (*FoundType)) {
            return(STATUS_OBJECT_TYPE_MISMATCH);
        }
    }


    //
    // If we own the lock, then set the transaction domain and also validate
    // the domain cache if necessary. If we are not holding the lock, the caller
    // is not expected to use transaction domains or refer to anything in the
    // domain cache.
    //

    if (SampCurrentThreadOwnsLock())
    {



        NtStatus = SampValidateDomainCache();
        if (!NT_SUCCESS(NtStatus))
            return(NtStatus);

        //
        // if the object is either user or group, then we need to set the
        // transaction domain. We also need to validate the Domain Cache ,
        // as a previous Write could have invalidated it.
        //

        if ((Context->ObjectType == SampDomainObjectType) ||
            (Context->ObjectType == SampGroupObjectType)  ||
            (Context->ObjectType == SampAliasObjectType)  ||
            (Context->ObjectType == SampUserObjectType) ) {

            SampSetTransactionWithinDomain(FALSE);
            SampSetTransactionDomain( Context->DomainIndex );
        }

    }
    else
    {
        //
        // If the SAM lock is not held then the context is either thread safe ( ie never
        // shared across multiple threads. Or it is the case of a domain context used
        // by a non loopback client in DS mode.
        //

        ASSERT((Context->NotSharedByMultiThreads)
                          || ( (SampDomainObjectType == Context->ObjectType)
                                   && (IsDsObject(Context))
                                   && (!Context->LoopbackClient))
              );
        ASSERT(IsDsObject(Context));


        //
        // NotSharedByMultiThread is always set for Loopback client
        // 

        ASSERT(!Context->LoopbackClient || Context->NotSharedByMultiThreads);
    }

    //
    // If the client isn't trusted, then there are a number of things
    // that will prevent them from continuing...
    //

    // If the service isn't enabled, we allow trusted clients to continue,
    // but reject non-trusted client lookups.
    //

    if ( !Context->TrustedClient ) {

        //
        // The SAM service must be enabled
        //

        if (SampServiceState != SampServiceEnabled) {
            return(STATUS_INVALID_SERVER_STATE);
        }


        //
        // If the access is to a USER or GROUP and the client isn't trusted
        // then the domain must be enabled or the operation is rejected.
        //

        if ( (Context->ObjectType == SampUserObjectType) ||
             (Context->ObjectType == SampAliasObjectType) ||
             (Context->ObjectType == SampGroupObjectType)    ) {
            if (SampDefinedDomains[Context->DomainIndex].CurrentFixed.ServerState
                != DomainServerEnabled) {
                return(STATUS_INVALID_DOMAIN_STATE);
            }
        }

    }

    //
    // Make sure the object is still around (that is, somebody didn't delete
    // it right out from under us). We will not do this check in DS mode, and
    // hope that a DS call failure will fail decently. This will reduce one
    // DirSearch per lookup context, and since lookup context is called almost
    // every time that someone makes a Sam Call, this will be a significant performance
    // improvement
    //

    if ((!IsDsObject(Context)) && !CloseOperation)
    {
        NtStatus = SampCheckIfObjectExists(Context);
        if (!NT_SUCCESS(NtStatus))
        {
            return(NtStatus);
        }
    }
    //
    // Check the desired access ...
    //
    // There are several special cases:
    //
    //  1) The client is trusted.  This is granted with no access check
    //     or role consistency check.
    //
    //  2) The caller specified 0 for desired access.  This is used
    //     to close handles and is granted with no access check.
    //
    //  3) If the caller wanted USER_CHANGE_PASSWORD_ACCESS, then the access is checked
    //     right here.
    //
    //  4) USER_FORCE_CHANGE_PASSWORD access for clients setting password through LDAP is
    //     checked here as a preventive measure against time of check, time of use problems
    //     in the loopback architecture.
    //
    //  If it were a necessity to fix time of check/time of use problems with SAM context
    //  handles then this would be the logical place to place a check. For now the mitigation
    //  is RPC session signing and encryption.
    //

    if ( (!Context->TrustedClient) ) {


        if (SampUserObjectType==Context->ObjectType) {


            if ( DesiredAccess & USER_CHANGE_PASSWORD)
            {
                //
                // If it is the user object, then special case the access ck for
                // password changes. The password change access ck is always done 
                // at password change time, vs at OpenUser time.
                //

                ACCESS_MASK SavedGrantedAccess;
                BOOLEAN     SavedAuditOnClose;
                SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes);
                SAMP_INIT_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes);
                
            
                DesiredAccess &= ~(USER_CHANGE_PASSWORD);

                SavedGrantedAccess = Context->GrantedAccess;
                SavedAuditOnClose  = Context->AuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes,
                    Context->WriteGrantedAccessAttributes);

                NtStatus = SampValidateObjectAccess2(
                                     Context,
                                     USER_CHANGE_PASSWORD,
                                     NULL,
                                     FALSE,
                                     TRUE,
                                     FALSE
                                     );

                Context->GrantedAccess = SavedGrantedAccess;
                Context->AuditOnClose = SavedAuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(Context->WriteGrantedAccessAttributes,
                    SavedWriteGrantedAccessAttributes);



                if (!NT_SUCCESS(NtStatus)) {
                    return(NtStatus);
                }
            }

            //
            // if this is ntdsa looping back and we are being asked for set password
            // operation then access ck here
            //

            if ((Context->LoopbackClient) && 
                (DesiredAccess & USER_FORCE_PASSWORD_CHANGE))
            {
                ACCESS_MASK SavedGrantedAccess;
                BOOLEAN     SavedAuditOnClose;
                SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes);
                SAMP_INIT_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes);
           

                DesiredAccess &= ~(USER_FORCE_PASSWORD_CHANGE);

                
                SavedGrantedAccess = Context->GrantedAccess;
                SavedAuditOnClose  = Context->AuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes,
                    Context->WriteGrantedAccessAttributes);

                NtStatus = SampValidateObjectAccess2(
                                     Context,
                                     USER_FORCE_PASSWORD_CHANGE,
                                     NULL,
                                     FALSE,
                                     FALSE,
                                     TRUE
                                     );

                
                Context->GrantedAccess = SavedGrantedAccess;
                Context->AuditOnClose  = SavedAuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(Context->WriteGrantedAccessAttributes,
                    SavedWriteGrantedAccessAttributes);

                if (!NT_SUCCESS(NtStatus)) {
                    return(NtStatus);
                }
            }

        }

        //
        // Validate the general SAM level accesses.
        //
        if (DesiredAccess != 0)  {

            if (!RtlAreAllAccessesGranted( Context->GrantedAccess, DesiredAccess)) {
                return(STATUS_ACCESS_DENIED);
            }
        }
        else if (!CloseOperation)
        { 
            //
            // This line is to prevent coding errors where someone forgets an access check
            // Comment this assert till all cases for asking for zero access is cleaned up.

            //ASSERT(FALSE && "Checking for zero access and client is not trusted");
            //return (STATUS_ACCESS_DENIED);
        }

        //
        // Validate attribute level accesses -- SAM access bits in domain controllers map to
        // read / write accesses on property sets in general. However there is a case with user
        // objects where only USER_WRITE_ACCOUNT access is applied to various attributes which
        // per the schema are in different property sets other than the account restrictions
        // property set. SamrSetInformationUser fixes this inconistency in access check by also 
        // causing a verification that access is additionally granted to the specified attribute.
        //

        if (RequestedAttributeAccess) {

            if (!SampIsAttributeAccessGranted(&Context->WriteGrantedAccessAttributes, 
                                              RequestedAttributeAccess)) {
                return(STATUS_ACCESS_DENIED);
            }

        }
    }


    if (NT_SUCCESS(NtStatus)) {

        ULONG ReferenceCount = 1;

        //
        // Reference the context
        //

        ReferenceCount = InterlockedIncrement(&Context->ReferenceCount);
        ASSERT(ReferenceCount>1);
    }


    return(NtStatus);

}





VOID
SampReferenceContext(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service increments a context block's reference count.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to dreference.

Return Value:

    None.

--*/
{
    SAMTRACE("SampReferenceContext");

    InterlockedIncrement(&Context->ReferenceCount);

    return;
}


NTSTATUS
SampDeReferenceContext2(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    )
/*++

  Routine Description

    This routine is a fast dereference that can be used for domain context's
    that can be potentially shared across multiple thread's and can be called
    without the SAM lock held, provided the caller is very careful never to
    modify any field of the domain context except the reference count. This
    routine cannot be used for other types of Context's. For lockless operation
    the only safe way for account context's is to not share the handles across
    calls. In registry mode this reverts to SampDeReferenceContext below.

    The only SAM API Calls that can call this are

        SamIGetUserLogonInformation
        SamIGetAliasMembership
        SamIGetResourceGroupsTransitive
        SamrGetAliasMembership
        SamrLookupNamesInDomain
        SamrLookupIdsInDomain
        SamIOpenAccount


   All of these API are very careful to not do anything to the domain handle except
   to reference or dereference.

   Arguments


     Context -- Open handle to a domain object
     Commit  -- Boolean specifying whether to commit or not.

   Return Values

    STATUS_SUCCESS - The service completed successfully.

    Errors may be returned from SampDereferenceContextInRegistryMode below

--*/
{

    ULONG    ReferenceCount=0;

    //
    // Registry mode => Call the normal API
    //

    if (!IsDsObject(Context))
    {
        return(SampDeReferenceContext(Context,Commit));
    }

    //
    // DS mode, assert that it is a domain context
    //

    ASSERT(SampDomainObjectType==Context->ObjectType);

    //
    // Drop the reference count by 1
    //

    ReferenceCount = InterlockedDecrement(&Context->ReferenceCount);

    //
    // The reference count should not drop to a 0
    //

    ASSERT(0!=ReferenceCount);

    return(STATUS_SUCCESS);
}



NTSTATUS
SampDeReferenceContext(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    )

/*++

Routine Description:

    This service decrements a context block's reference count.
    If the reference count drops to zero, then the MarkedForDelete
    flag is checked.  If it is true, then the context block is
    deallocated.

    The attribute buffers are always deleted.


Arguments:

    Context - Pointer to the context block to de-reference.

    Commit - if TRUE, the attribute buffers will be added to the RXACT.
        Otherwise, they will just be ignored.

Return Value:


    STATUS_SUCCESS - The service completed successfully.

    Errors may be returned from SampStoreObjectAttributes().


--*/
{
    NTSTATUS        NtStatus, IgnoreStatus;
    BOOLEAN         TrustedClient;
    BOOLEAN         LoopbackClient;
    BOOLEAN         PersistAcrossCalls;
    BOOLEAN         DirtyBuffers;
    BOOLEAN         FlushBuffers;

    SAMTRACE("SampDeReferenceContext");

    //
    // The following ASSERT is used to catch domain context dereference during
    // any lockless session. Currently, SAM allows sharing of Domain Context,
    // but only the thread owns SAM lock can call SampDereferenceContext to
    // delete attribute buffers. For any locklese thread, to dereference Domain
    // Context, they need to call SampDeReferenceContext2().
    //

    // 
    // either the lock is held, or the context is not shared across threads
    // 


    ASSERT(!IsDsObject(Context) ||
           SampCurrentThreadOwnsLock() || 
           Context->NotSharedByMultiThreads
           );

    ASSERT( Context->ReferenceCount != 0 );
    InterlockedDecrement(&Context->ReferenceCount);

    TrustedClient = Context->TrustedClient;
    LoopbackClient = Context->LoopbackClient;
    PersistAcrossCalls   = Context->PersistAcrossCalls;


    //
    // Buffers are dirty if either the fixed or the variable attributes
    // are dirty
    //

    DirtyBuffers  = (Context->FixedDirty)
                        || (Context->VariableDirty);


    //
    // We will flush buffers if
    //      1. Commit is specified AND
    //      2. Buffers are Dirty AND
    //      3. If no sticky cache is specified OR
    //      4. If sticky cache is specified then flush the buffer if its
    //         reference count drops to 0.
    //

    FlushBuffers  = ((Commit) &&  (DirtyBuffers) && (!Context->BufferWrites));

    NtStatus = STATUS_SUCCESS;

    if ( Context->OnDisk != NULL ) {

        //
        // There are attribute buffers for this context.  Flush them if
        // asked to do so.
        // Use existing open keys
        //

        if ( FlushBuffers ) {

            NtStatus = SampStoreObjectAttributes(Context, TRUE);

        } else if (!Commit) {

            //
            // If we aren't committing, then the data doesn't need to be flushed
            // hence reset the Dirty fields. Note that SampFreeAttributeBuffer 
            // will assert otherwise.
            //
            Context->FixedDirty = FALSE;
            Context->VariableDirty = FALSE;
        }

        //
        // Free the buffer that was being used to hold attributes.
        // If StickyCache was asked for in the context, perform the
        // free only if the reference count is about to go to 0, or
        // if the attribute buffers were dirty, or if the commit failed
        //

        if ((Context->ReferenceCount == 0) 
         || (!PersistAcrossCalls) 
         || (FlushBuffers) 
         || (!Commit && DirtyBuffers) ) 
        {

            SampFreeAttributeBuffer( Context );
            if (SampUserObjectType==Context->ObjectType)
            {
                if (NULL!=Context->TypeBody.User.CachedSupplementalCredentials)
                    MIDL_user_free(Context->TypeBody.User.CachedSupplementalCredentials);
                Context->TypeBody.User.CachedSupplementalCredentials
                    = NULL;
                Context->TypeBody.User.CachedSupplementalCredentialLength =0;
                Context->TypeBody.User.CachedSupplementalCredentialsValid = FALSE;
            }

        }
    }


    if (Context->ReferenceCount == 0) {

        //
        // ReferenceCount has dropped to 0, see if we should delete this
        // context.
        //

        ASSERT(Context->MarkedForDelete);

        if (Context->MarkedForDelete == TRUE) {

            PVOID    ElementInActiveContextTable = 
                            Context->ElementInActiveContextTable;

            Context->ElementInActiveContextTable = NULL; 

            //
            // For Group and Alias Object, release CachedMembershipOperationsList
            // for User Object, release CachedOrigUserParms
            //

            switch (Context->ObjectType) {

            case SampUserObjectType:

                if (NULL != Context->TypeBody.User.CachedOrigUserParms)
                {
                    MIDL_user_free(Context->TypeBody.User.CachedOrigUserParms);
                    Context->TypeBody.User.CachedOrigUserParms = NULL;
                }

                Context->TypeBody.User.CachedOrigUserParmsLength = 0;
                Context->TypeBody.User.CachedOrigUserParmsIsValid = FALSE;

                SampFreeSupplementalCredentialList(Context->TypeBody.User.SupplementalCredentialsToWrite);
                Context->TypeBody.User.SupplementalCredentialsToWrite = NULL;

                if (NULL!=Context->TypeBody.User.UPN.Buffer)
                {
                    MIDL_user_free(Context->TypeBody.User.UPN.Buffer);
                }

                if (NULL!=Context->TypeBody.User.A2D2List)
                {
                    MIDL_user_free(Context->TypeBody.User.A2D2List);
                }

                if (NULL!=Context->TypeBody.User.SPNList)
                {
                    MIDL_user_free(Context->TypeBody.User.SPNList);
                }

                if (NULL!=Context->TypeBody.User.PasswordInfo.Buffer)
                {
                    RtlZeroMemory(Context->TypeBody.User.PasswordInfo.Buffer,
                                  Context->TypeBody.User.PasswordInfo.MaximumLength);
                    MIDL_user_free(Context->TypeBody.User.PasswordInfo.Buffer);
                }

                break;

            case SampGroupObjectType:

                SampDsFreeCachedMembershipOperationsList(&Context->TypeBody.Group.CachedMembershipOperationsList,
                                                         &Context->TypeBody.Group.CachedMembershipOperationsListMaxLength,
                                                         &Context->TypeBody.Group.CachedMembershipOperationsListLength);

                break;

            case SampAliasObjectType:


                SampDsFreeCachedMembershipOperationsList(&Context->TypeBody.Alias.CachedMembershipOperationsList,
                                                         &Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength,
                                                         &Context->TypeBody.Alias.CachedMembershipOperationsListLength);


                SampDsFreeCachedMembershipOperationsList(&Context->TypeBody.Alias.CachedNonMembershipOperationsList,
                                                         &Context->TypeBody.Alias.CachedNonMembershipOperationsListMaxLength,
                                                         &Context->TypeBody.Alias.CachedNonMembershipOperationsListLength);
                break;

            default:
                ;
            }

            //
            // Close the context block's root key.
            // Domain and server contexts contain root key
            // handles that are shared - so don't clean-up these
            // if they match the ones in memory.
            //

            switch (Context->ObjectType) {

            case SampServerObjectType:

                if ((Context->RootKey != SampKey) &&
                    (Context->RootKey != INVALID_HANDLE_VALUE)) {

                    IgnoreStatus = NtClose( Context->RootKey );
                    ASSERT(NT_SUCCESS(IgnoreStatus));
                }
                break;

            case SampDomainObjectType:
                if (IsDsObject(Context))
                {

                    //
                    // Free the Restart structure in display state
                    //

                    if (NULL!=
                            Context->TypeBody.Domain.DsDisplayState.Restart)
                    {
                        MIDL_user_free(Context->TypeBody.Domain.DsDisplayState.Restart);
                        Context->TypeBody.Domain.DsDisplayState.Restart = NULL;
                    }

                    //  Do Not do this as the object name in
                    //  in Domain Context actually references the one in
                    //  PSAMP_DEFINED_DOMAINS
                    //
                    // Free the DsName
                    // MIDL_user_free(Context->ObjectNameInDs);
                    // Context->ObjectNameInDs = NULL;

                }
                else
                {

                    // Free all the Key Stuff
                    if ((Context->RootKey != SampDefinedDomains[Context->DomainIndex].Context->RootKey) &&
                        (Context->RootKey != INVALID_HANDLE_VALUE))
                    {

                        IgnoreStatus = NtClose( Context->RootKey );
                        ASSERT(NT_SUCCESS(IgnoreStatus));
                    }
                }

                break;

            default:

                if (IsDsObject(Context))
                {
                    // Free the DSName
                    MIDL_user_free(Context->ObjectNameInDs);
                    Context->ObjectNameInDs = NULL;
                }
                else
                {

                    //
                    // Close the root key handle
                    //

                    if (Context->RootKey != INVALID_HANDLE_VALUE)
                    {

                        IgnoreStatus = NtClose( Context->RootKey );
                        ASSERT(NT_SUCCESS(IgnoreStatus));
                    }

                    //
                    // Free the root key name
                    //

                    SampFreeUnicodeString( &(Context->RootName) );
                }
            }


#if SAMP_DIAGNOSTICS
            IF_SAMP_GLOBAL( CONTEXT_TRACKING ) {
                SampDiagPrint( CONTEXT_TRACKING, ("Deallocating  ") );
                if (Context->ObjectType == SampServerObjectType) SampDiagPrint(CONTEXT_TRACKING, ("Server "));
                if (Context->ObjectType == SampDomainObjectType) SampDiagPrint(CONTEXT_TRACKING, (" Domain "));
                if (Context->ObjectType == SampGroupObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("  Group "));
                if (Context->ObjectType == SampAliasObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("   Alias "));
                if (Context->ObjectType == SampUserObjectType)   SampDiagPrint(CONTEXT_TRACKING, ("    User "));
                SampDiagPrint(CONTEXT_TRACKING, ("context : 0x%lx\n", Context ));
    }
#endif //SAMP_DIAGNOSTICS

            MIDL_user_free( Context );


            //
            // For TrustedClient or LoopbackClient, ElementInActiveContextTable 
            // should be NULL
            // 
            ASSERT((!TrustedClient && !LoopbackClient) || 
                   (NULL == ElementInActiveContextTable) );

            //
            // Decrement the number of active opens
            //

            if (!TrustedClient && !LoopbackClient) {

                SampDecrementActiveContextCount(
                        ElementInActiveContextTable
                        );

            }

        }
    }

#if DBG
    //
    // Make sure a commit worked.
    //

    if (Commit) {
        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_STORAGE_FAIL,
                          ("SAM: Commit failure, status: 0x%lx\n",
                          NtStatus) );
            IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }
    }
#endif //DBG


    return( NtStatus );
}


VOID
SampInvalidateContextAddress(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service removes a context from the set of valid contexts.

    Note that we may have already removed the context.  This is not an
    error is expected to happen in the case where an object (like a user
    or group) is deleted out from under an open handle.



    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to be removed from the set
        of valid contexts.  The ObjectType field of this context must
        be valid.

Return Value:

    None.



--*/
{

    SAMTRACE("SampInvalidateContextAddress");


    ASSERT( (Context->ObjectType == SampUserObjectType)    ||
            (Context->ObjectType == SampGroupObjectType)   ||
            (Context->ObjectType == SampAliasObjectType)   ||
            (Context->ObjectType == SampDomainObjectType)  ||
            (Context->ObjectType == SampServerObjectType)
          );

    Context->Valid = FALSE;

}




#ifdef SAMP_DIAGNOSTICS
VOID
SampDumpContext(
    IN PSAMP_OBJECT Context
    )


/*++

Routine Description:

    This service prints out info on a context to debugger

Arguments:

    Context - a context

Return Value:

    None.



--*/
{
    PSTR Type = NULL;

    switch (Context->ObjectType) {
    case SampServerObjectType:
        Type = "S";
        break;
    case SampDomainObjectType:
        if (Context == SampDefinedDomains[Context->DomainIndex].Context) {
            Type = "d";
        } else {
            Type = "D";
        }
        break;
    case SampUserObjectType:
        Type = "U";
        break;
    case SampAliasObjectType:
        Type = "A";
        break;
    case SampGroupObjectType:
        Type = "G";
        break;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "%s 0x%8x  %2d  0x%8x  %s %s %s %wZ\n",
               Type,
               Context,
               Context->ReferenceCount,
               Context->RootKey,
               Context->MarkedForDelete ? "D": " ",
               Context->Valid ? "  ": "NV",
               Context->TrustedClient ? "TC": "  ",
               &Context->RootName));
}


VOID
SampDumpContexts(
    VOID
    )

/*++

Routine Description:

    Prints out info on all contexts

Arguments:


Return Value:

    None.

--*/
{
    PLIST_ENTRY     NextEntry;
    PLIST_ENTRY     Head;
    ULONG Servers = 0;
    ULONG Domains = 0;
    ULONG DomainUsers = 0;
    ULONG DomainAliases = 0;
    ULONG DomainGroups = 0;


    Head = &SampContextListHead;
    NextEntry = Head->Flink;
    while (NextEntry != Head) {

        PSAMP_OBJECT    NextContext;

        NextContext = CONTAINING_RECORD(
                          NextEntry,
                          SAMP_OBJECT,
                          ContextListEntry
                          );

        switch (NextContext->ObjectType) {
        case SampServerObjectType:
            (Servers)++;
            break;
        case SampDomainObjectType:
            (Domains)++;
            break;
        case SampUserObjectType:
            (DomainUsers)++;
            break;
        case SampGroupObjectType:
            (DomainGroups)++;
            break;
        case SampAliasObjectType:
            (DomainAliases)++;
            break;
        default:
            ASSERT(FALSE);
            break;
        }

        SampDumpContext(NextContext);

        NextEntry = NextEntry->Flink;
    }


    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "     Server = %4d Domain = %4d\n",
               Servers,
               Domains));

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "     Users = %4d Groups = %4d Aliases = %4d\n",
               DomainUsers,
               DomainAliases,
               DomainGroups));

}
#endif  //SAMP_DIAGNOSTICS



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service Implementations                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
SampAddNewValidContextAddress(
    IN PSAMP_OBJECT NewContext
    )


/*++

Routine Description:

    This service adds the new context to the set of valid contexts.


    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    NewContext - Pointer to the context block to be added to the set
        of valid contexts.  The ObjectType field of this context must
        be set.


Return Value:

    None.



--*/
{
    SAMTRACE("SampAddNewValidContextAddress");

    ASSERT( (NewContext->ObjectType == SampUserObjectType)    ||
            (NewContext->ObjectType == SampGroupObjectType)   ||
            (NewContext->ObjectType == SampAliasObjectType)   ||
            (NewContext->ObjectType == SampDomainObjectType)  ||
            (NewContext->ObjectType == SampServerObjectType)
          );


    NewContext->Valid = TRUE;
    NewContext->Signature = SAMP_CONTEXT_SIGNATURE;


}



NTSTATUS
SampValidateContextAddress(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service checks to make sure a context is still valid.

    Note that even though RPC still thinks we have a context related
    to a SAM_HANDLE, we may, in fact, have deleted it out from under
    the user.  Since there is no way to inform RPC of this, we must
    suffer, and wait until RPC calls us (either with a call by the client
    or to rundown the context handle). but there apparently
    isn't any other way around it.



    WARNING - IT IS ASSUMED THE CONTEXT WAS ONCE VALID.  IT MAY HAVE
              BEEN INVALIDATED, BUT IF  YOU ARE CALLING THIS ROUTINE
              IT BETTER STILL HAVE A NON-ZERO REFERENCE COUNT.  THIS
              COULD BE CHANGED IN THE FUTURE, BUT IT WOULD REQUIRE
              KEEPING A LIST OF VALID DOMAINS AND PERFORMING THE BULK
              OF THIS ROUTINE INSIDE A TRY-EXCEPT CLAUSE.  YOU COULD
              LOCATE THE CONTEXT'S DOMAIN (WHICH MIGHT ACCESS VIOLATE)
              AND THEN MAKE SURE THAT DOMAIN IS VALID.  THEN WALK THAT
              DOMAIN'S LIST TO ENSURE THE USER OR GROUP IS VALID.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to be validated as still being
        a valid context.  The ObjectType field of this context must
        be valid.

Return Value:

    STATUS_SUCCESS - The context is still valid.

    STATUS_INVALID_HANDLE - The context is no longer valid and the handle
        that caused the reference should be invalidated as well.  When the
        handle is invalidated, the context should be closed (deleted).

    STATUS_NO_SUCH_CONTEXT - This value is not yet returned by this routine.
        It may be added in the future to distinguish between an attempt to
        use a context that has been invalidated and an attempt to use a
        context that doesn't exist.  The prior being a legitimate condition,
        the later representing a bug-check condition.



--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampValidateContextAddress");


    __try {

         if (Context==NULL)
         {
             return(STATUS_INVALID_HANDLE);
         }

        if (!( (Context->ObjectType == SampUserObjectType)    ||
                (Context->ObjectType == SampGroupObjectType)   ||
                (Context->ObjectType == SampAliasObjectType)   ||
                (Context->ObjectType == SampDomainObjectType)  ||
                (Context->ObjectType == SampServerObjectType)
              ))
        {
            ASSERT(FALSE && "Invalid Object Type");

            return(STATUS_INVALID_HANDLE);
        }


        if (SAMP_CONTEXT_SIGNATURE != Context->Signature) {
            return(STATUS_INVALID_HANDLE);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_INVALID_HANDLE;
    }

    return(NtStatus);

}

NTSTATUS
SampCheckIfObjectExists(
                        IN  PSAMP_OBJECT    Context
                        )
/*++

  Routine Description:

        Checks to see if the object exists in the DS/ Registry.
        Will fill out the following information

            1. If DS object its DSNAME, which must exist
            2. If Registry object, Open its Root Key and fill out
               the handle of the Root Key in the registry.

  IMPORTANT NOTE:

     In the Registry Case of SAM once the key is open nobody can
     delete the object. However in the DS case this is not so. Currently
     we have only the DS Name of the Object in Hand, and we have no way
     of Locking the Object, for access. Since this is the case

  Arguments:
        Context -- Pointer to a Context block desribing the Object
            Rid -- Rid of the desired Object

  Return Values:
        STATUS_SUCCESS if everything succeeds
        Error codes from Registry Manipulation / DsLayer.
--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    Rid = 0;



    //
    // Check wether the Object is located or not.
    // Location is the process of finding out
    //      1. DSNAME of the object if it is in the DS. An object with this
    //         DSNAME must exist.
    //
    //      2. The Root Key HANDLE of the Object if it is in the Registry
    //

    if (!SampIsObjectLocated(Context)) {

        //
        // No we first need to locate the Object.
        // This is done by using the Rid for Account Objects
        // For Domain Objects we already cache all the defined domains, so fill out
        // From the Cache
        // BUG: For Server Objects Don't know what to do.
        //

        switch (Context->ObjectType) {

        case SampGroupObjectType:
            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Reopened group handle <%wZ>,", &Context->RootName));
            Rid = Context->TypeBody.Group.Rid;
            break;

        case SampAliasObjectType:
            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Reopened alias handle <%wZ>,", &Context->RootName));
            Rid = Context->TypeBody.Alias.Rid;
            break;

        case SampUserObjectType:
            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Reopened user handle <%wZ>,", &Context->RootName));
            Rid = Context->TypeBody.User.Rid;
            break;

        case SampDomainObjectType:

            //
            // Domain objects share the root key and the object name in the DS that
            // we keep around in the in memory domain context for each domain
            //


            ASSERT(Context != SampDefinedDomains[Context->DomainIndex].Context);

            Context->RootKey = SampDefinedDomains[Context->DomainIndex].Context->RootKey;
            Context->ObjectNameInDs = SampDefinedDomains[Context->DomainIndex].Context->ObjectNameInDs;
            Context->ObjectNameInDs = SampDefinedDomains[Context->DomainIndex].Context->ObjectNameInDs;

            ASSERT(SampIsObjectLocated(Context));

            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Recopied domain context handle <%wZ>, 0x%lx\n", &Context->RootName, Context->RootKey));
            goto ObjectLocated;

        case SampServerObjectType:

            //
            // Server objects share our global root key
            //


            Context->RootKey = SampKey;
            ASSERT(SampIsObjectLocated(Context));

            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Recopied server context handle <%wZ>, 0x%lx\n", &Context->RootName, Context->RootKey));
            goto ObjectLocated;

        default:
            
            ASSERT(FALSE && "Invalid Object Type\n");
            NtStatus = STATUS_INVALID_PARAMETER;
            goto ObjectLocated;

        }

        //
        // Go open the appropriate account key/ or find object Name from RID
        //
        ASSERT(Rid && "Rid not initialized\n");

        NtStatus = SampLocateObject(Context, Rid);

ObjectLocated:
        ;;



    }

    return NtStatus;
}


BOOLEAN
SampIsObjectLocated(
                    IN  PSAMP_OBJECT Context
                    )
/*++

  Description:
        Checks if an object has been located in the DS or in the registry
        An Object being Located implies the Following
            1. For a DS Object we have the DS Name
            2. For a Registry Object we have a Valid Open Registry Key for
               the Object.

  Arguments:
        Context -- Pointer to a Context block desribing the Object

  Return Values:
        TRUE -- If Conditions above are satisfied
        FALSE -- If Conditions above are not satisfied
--*/
{
    if (IsDsObject(Context))
        return (Context->ObjectNameInDs != NULL);
    else
        return (Context->RootKey != INVALID_HANDLE_VALUE);
}


NTSTATUS
SampLocateObject(
                 IN PSAMP_OBJECT Context,
                 IN ULONG   Rid
                 )
/*++

  Description:
        Uses the Rid to find the Object in either the DS or
        the Registry.


  NOTE:
        This routine is meaningful for Context's that represent
        Account Objects Only.

  Arguments:
        Context -- Pointer to a Context block desribing the Object
            Rid -- Rid of the desired Object

  Return Values:
        STATUS_SUCCESS if everything succeeds
        Error codes from Registry Manipulation / DsLayer.
--*/

{

   NTSTATUS Status = STATUS_SUCCESS;
   PSAMP_OBJECT  DomainContext = NULL;
   OBJECT_ATTRIBUTES ObjectAttributes;



   //
   //  This routine can be called only for Account Objects
   //

   ASSERT((Context->ObjectType == SampGroupObjectType)
            || (Context->ObjectType == SampAliasObjectType)
            || (Context->ObjectType == SampUserObjectType)
            );

   //
   // Get the Domain Object, as we will need this to find out
   // to find out in which domain we look for the Rid.
   //
   DomainContext = SampDefinedDomains[Context->DomainIndex].Context;

   // Now Make the Decision
   if (IsDsObject(Context))
   {
       //
       // Object is in the DS
       //

       // Look it up using the Rid
       Status = SampDsLookupObjectByRid(DomainContext->ObjectNameInDs, Rid, &Context->ObjectNameInDs);
       if (!NT_SUCCESS(Status))
       {
           Context->ObjectNameInDs = NULL;
       }

   }
   else
   {
       // Object Should be in Registry
       SetRegistryObject(Context);
       InitializeObjectAttributes(
                        &ObjectAttributes,
                        &Context->RootName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

       SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

       // Try opening the Key
       Status = RtlpNtOpenKey(
                           &Context->RootKey,
                           (KEY_READ | KEY_WRITE),
                           &ObjectAttributes,
                           0
                           );

        if (!NT_SUCCESS(Status))
        {
            Context->RootKey = INVALID_HANDLE_VALUE;
        }
   }

   return Status;

}







PVOID
SampActiveContextTableAllocate(
    ULONG   BufferSize
    )
/*++
Routine Description:

    This routine is used by RtlGenericTable2 to allocate memory
    
Parameters:

    BufferSize - indicates the size of memory to be allocated. 
    
Return Values:

    Address of the buffer

--*/
{
    PVOID   Buffer = NULL;

    Buffer = MIDL_user_allocate(BufferSize);

    return( Buffer );
}



VOID
SampActiveContextTableFree(
    PVOID   Buffer
    )
/*++
Routine Description:

    This routine frees the memory used by RtlGenericTable2
    
Arguments:
    
    Buffer - address of the buffer
    
Return Value:

    None

--*/
{
    MIDL_user_free(Buffer);

    return;
}


RTL_GENERIC_COMPARE_RESULTS
SampActiveContextTableCompare(
    PVOID   Node1,
    PVOID   Node2
    )
/*++
Routine Description:

    This routine is used by RtlGenericTable2 to compare two nodes. 
    We use SID to do the comparasion. 
    
Parameters:

    Node1 - first element in the table 
    Node2 - pointer to the second element in the table

Return Values:

    GenericEqual, GenericGreaterThan, GenericLessThan

--*/
{
    PSID    Sid1 = NULL;
    PSID    Sid2 = NULL;
    ULONG   Length1, Length2;

    Sid1 = ((SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT *)Node1)->ClientSid;
    Sid2 = ((SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT *)Node2)->ClientSid;

    Length1 = RtlLengthSid(Sid1);
    Length2 = RtlLengthSid(Sid2);

    if (Length1 <  Length2)
    {
        return GenericLessThan;
    }
    else if (Length1 > Length2)
    {
        return GenericGreaterThan;
    }
    else
    {
        LONG   Result;
        Result = memcmp(Sid1, Sid2, Length1);
        if (Result == 0)
        {
            return(GenericEqual);
        }
        else if (Result > 0 )
        {
            return(GenericGreaterThan);

        }
        else
        {
            return(GenericLessThan);
        }
    }
}


NTSTATUS
SampInitializeActiveContextTable(
    )
/*++
Routine Description:

    initialize Active Context Table 
    
Paramenters:

    None
    
Return Values:

    None

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    __try {
        NtStatus = RtlInitializeCriticalSectionAndSpinCount(
                        &SampActiveContextTableLock,
                        4000
                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(NtStatus)) {
        RtlInitializeGenericTable2(
                    &SampActiveContextTable,
                    SampActiveContextTableCompare,
                    SampActiveContextTableAllocate,
                    SampActiveContextTableFree
                    );
    }

    return NtStatus;
}

NTSTATUS
SampCreateActiveContextTableElement(
    IN PSID pSid, 
    OUT PSAMP_ACTIVE_CONTEXT_TABLE_ELEMENT  *ppElement
    )
/*++
Routine Description:

    This routine creates an element for the Active Context Table. 
    Allocate the memory for the element, also set the SID fields
    
Parameters:

    pSid - SID of the current client
    
    ppElement - returns the element is succeeded.
    
Return Values:

    NtStatus

    ppElement - caller is responsible to free it

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    *ppElement = MIDL_user_allocate(sizeof(SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT));

    if (NULL == *ppElement)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    memset(*ppElement, 0, sizeof(SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT));

    (*ppElement)->ActiveContextCount = 0;
    (*ppElement)->ClientSid = pSid;

    return( NtStatus );
}




PVOID
SampLookupElementInTable(
    IN RTL_GENERIC_TABLE2   *pTable, 
    IN PVOID    pElement, 
    IN ULONG    MaximumTableElements,
    OUT BOOLEAN *fNewElement
    )
/*++
Routine Description:

    This routine looks up the element in table. Returns the pointer to the 
    element in table if lookup succeeded. Otherwise, if failed to find 
    the element, then inserts this element into table. 
    
    We will check how much elements in the table before inserting the 
    new element 
     
Parameter:

    pTable - pointer to the table 
    
    pElement - pointer to the element needs to be looked up. or new element

    MaximumTableElements - Upper limits of the table entries.
    
    fNewElement - used to indicate whether the element is a new one or exists 
                  already


Return Values:

    if success, returns the pointer to the element in the table 
    if not. returns NULL

--*/
{
    PVOID   ReturnElement = NULL; 
    ULONG   MaxEntries = 0;
    

    *fNewElement = FALSE;

    //
    // lookup the element in the table first
    // 
    ReturnElement = RtlLookupElementGenericTable2(
                        pTable, 
                        pElement
                        );

    if (ReturnElement)
    {
        //
        // found an existing element in the table that matches the entry passed
        // in, return the pointer to the existing entry
        // 
        return(ReturnElement);
    }
    else
    {
        //
        // new element
        // check how many clients in table now
        // 
        MaxEntries = RtlNumberElementsGenericTable2(pTable);

        if (MaxEntries > MaximumTableElements)
        {
            //
            // Total number of elements (clients) in Table exceed
            // maximum allowed
            // 
            return( NULL );
        }

        //
        // insert the new element
        // ReturnElement will be set to the value of pElement, but in the case 
        // of resource failure, ReturnElement will be set to NULL. 
        // 
        ReturnElement = RtlInsertElementGenericTable2(
                            pTable, 
                            pElement, 
                            fNewElement
                            );

        ASSERT( (NULL == ReturnElement) || (pElement == ReturnElement) );

        return( ReturnElement );
    }
}



NTSTATUS
SampIncrementActiveContextCount(
    PSAMP_OBJECT    Context
    )
/*++

Routine Description:

    This routine impersonates client, gets the user's SID fromm the token
    and keep it is the active Context table. 
    
    if SID is already in table, need to increment ActiveContextCount. If 
    SID is not in the table yet, then add it. 
    
    This routine will fail in the following conditions, 
    
    1. this user's ActiveContextCount exceed the limit. 
    2. total elements in table exceed limit
    
    Note: 
    
    1. TrustedClient or LoopbackClient should not fall into this routine. 
    2. Need to acquire SAM Lock when doing any update

Parameters: 

    Context - pointer to the context to be created
    
Return Values:

    NtStatus

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     fNewElement = FALSE;
    BOOLEAN     fLockAcquired = FALSE;
    PSID        pSid = NULL;
    PSAMP_ACTIVE_CONTEXT_TABLE_ELEMENT   pElement = NULL, ElementInTable = NULL;
    BOOL        Administrator = FALSE;


    // 
    // Set initial value
    //  

    Context->ElementInActiveContextTable = NULL;


    //
    // Get current client SID 
    // 

    NtStatus = SampGetCurrentClientSid(NULL,&pSid, &Administrator);
    if (!NT_SUCCESS(NtStatus)) {

        goto Error;
    }


    //
    // do NOT apply this restriction on LocalSystem or Administrator Account
    // 

    if (RtlEqualSid(pSid, SampLocalSystemSid) || 
        RtlEqualSid(pSid, SampAdministratorUserSid) )
    {
        goto Error;
    }


    // 
    // Create a table element used to lookup or insert
    // 

    NtStatus = SampCreateActiveContextTableElement(
                    pSid, 
                    &pElement
                    );
    if (!NT_SUCCESS(NtStatus)) {

        goto Error;
    }


    //
    // Acquire lock 
    // 
    RtlEnterCriticalSection(&SampActiveContextTableLock);
    fLockAcquired = TRUE;


    //
    // Lookup or insert this element as a new client
    //

    ElementInTable = SampLookupElementInTable(
                            &SampActiveContextTable,
                            pElement,
                            SAMP_MAXIMUM_CLIENTS_COUNT,
                            &fNewElement
                            );

    if (NULL == ElementInTable)
    {
        //
        // failed due to SAMP_MAXIMUM_CLIENTS_COUNT exceeded 
        // or can't add this element to table
        // 
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        fNewElement = FALSE;
        goto Error;
    }


    if (ElementInTable->ActiveContextCount >= 
        SAMP_PER_CLIENT_MAXIMUM_ACTIVE_CONTEXTS)
    {
        //
        // Active Contexts exceed maximum allowed 
        // 

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        ASSERT(FALSE == fNewElement);
    }
    else
    {
        //
        // Increment Active Context Count by 1
        // And keep the pointer to the Element in Context
        // so that we can access this element without
        // lookup again during context dereference.
        // 

        ElementInTable->ActiveContextCount ++;
        Context->ElementInActiveContextTable = ElementInTable;
    }


Error:

    //
    //  Release lock if necessary
    // 
    if (fLockAcquired)
    {
        RtlLeaveCriticalSection(&SampActiveContextTableLock);
    }


    //
    // clean up
    // 
    if (!fNewElement)
    {
        if (pSid)
            MIDL_user_free(pSid);

        if (pElement)
            MIDL_user_free(pElement);
    }

    ASSERT(!fNewElement || (pElement == Context->ElementInActiveContextTable));

    return(NtStatus);
}




VOID
SampDecrementActiveContextCount(
    PVOID   ElementInActiveContextTable
    )
/*++

Routine Description: 

    This routines is called during Context deletion. It decrements
    ActiveContextCount, if ref count drops to 0 then remove if from the
    table.  


Parameters:

    ClientSid - pointer to the user SID
    
Return Value: 
    
    NtStatus

--*/
{
    BOOLEAN     Success, fLockAcquired = FALSE;
    SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT   *Element = ElementInActiveContextTable;
    BOOL        Administrator = FALSE;


    //
    // LocalSystem and Administrator 
    // 
    if (NULL == Element) {

#ifdef DBG
    {
        NTSTATUS    NtStatus = STATUS_SUCCESS;
        PSID        pSid = NULL;

        NtStatus = SampGetCurrentClientSid(NULL,&pSid, &Administrator);
        if (NT_SUCCESS(NtStatus))
        {
            ASSERT(RtlEqualSid(pSid, SampLocalSystemSid) ||
                   RtlEqualSid(pSid, SampAdministratorUserSid) );

            MIDL_user_free(pSid);
        }
    }
#endif // DBG

        return;
    }

    //
    // Acquire lock
    // 
    RtlEnterCriticalSection(&SampActiveContextTableLock);
    fLockAcquired = TRUE;


    //
    // Decresment active context count
    //

    Element->ActiveContextCount--;

    //
    // Remove this entry is ref count drops to 0
    // 
    if (Element->ActiveContextCount == 0)
    {
        Success = RtlDeleteElementGenericTable2(
                        &SampActiveContextTable, 
                        Element
                        );

        ASSERT(Success);

        MIDL_user_free(Element->ClientSid);
        MIDL_user_free(Element);
    }


    //
    // Release lock if neccessary
    // 
    if (fLockAcquired)
    {
        RtlLeaveCriticalSection(&SampActiveContextTableLock);
    }

    return;
}




VOID
SampInsertContextList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    )
/*++
Routine Description:

    This routine inserts an Entry to a double link list, pointed by 
    SampContextListHead. 
    
    To prevent multi clients contention, this routine use Critical Secition
    to guard this global link list. 
    
Parameters:

    ListHead - Pointer to the head of the link list. 

    Entry - Pointer to the entry to be inserted. 
    
Return Value:

    None

--*/
{
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    //
    // enter critical section
    //

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // insert the entry to list
    // 

    InsertTailList(ListHead, Entry);

    //
    // leave critical section
    //

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}



VOID
SampRemoveEntryContextList(
    PLIST_ENTRY Entry
    )
/*++
Routine Description:
    
    This routine removes an entry from SampContextList 

Parameter:

    Entry - pointer to the entry to be removed. 

Return Value:

    None

--*/
{
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    // 
    // enter critical section
    // 

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // the entry should be in the list already
    // 

    ASSERT((NULL != Entry->Flink) && (NULL != Entry->Blink));

    if ((NULL != Entry->Flink) && (NULL != Entry->Blink))
    {
        RemoveEntryList(Entry);
    }

    // 
    // leave critical section
    // 

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}




VOID
SampInvalidateObjectContexts(
    IN PSAMP_OBJECT ObjectContext,
    IN ULONG Rid
    )
/*++

Routine Description:

    This routine scans the SampContextList, find the matching object (with same
    object type and same Rid), then invalidate the context in ContextList.

Parameter: 

    ObjectContext - Pointer to object context

    Rid - Account Rid

Return Value:

    None

--*/
{
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE    ObjectType = ObjectContext->ObjectType;
    PLIST_ENTRY     Head, NextEntry;
    PSAMP_OBJECT    NextContext;


    //
    // do nothing in DS mode
    // 

    if (IsDsObject(ObjectContext))
    {
        return;
    }

    //
    // Check passed in parameter
    // 

    if ((SampUserObjectType != ObjectType) &&
        (SampGroupObjectType != ObjectType) &&
        (SampAliasObjectType != ObjectType))
    {
        ASSERT(FALSE && "Invalid parameter");
        return;
    }

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Walk the list of active contexts, check for contexts with matching 
    // ObjectType and RID
    //

    Head = &SampContextListHead;
    NextEntry = Head->Flink;

    while (NextEntry != Head) 
    {
        BOOLEAN     fContextMatched = FALSE;

        NextContext = CONTAINING_RECORD(
                          NextEntry,
                          SAMP_OBJECT,
                          ContextListEntry
                          );

        //
        // check whether the current entry matches the Context or not 
        //  1) Object Type matched And  
        //  2) Object Rid equals. 
        // 

        switch (ObjectType)
        {
        case SampUserObjectType:
            fContextMatched = ((ObjectType == NextContext->ObjectType) &&
                               (Rid == NextContext->TypeBody.User.Rid) &&
                               (TRUE == NextContext->Valid));
                              
            break;
        case SampGroupObjectType:
            fContextMatched = ((ObjectType == NextContext->ObjectType) &&
                               (Rid == NextContext->TypeBody.Group.Rid) &&
                               (TRUE == NextContext->Valid));

            break;
        case SampAliasObjectType:
            fContextMatched = ((ObjectType == NextContext->ObjectType) &&
                               (Rid == NextContext->TypeBody.Alias.Rid) &&
                               (TRUE == NextContext->Valid));

            break;
        default:
            ASSERT(FALSE && "Invalid Object Type");
        }

        if ( fContextMatched )
        {
            NextContext->Valid = FALSE;

            if (NextContext->RootKey != INVALID_HANDLE_VALUE) 
            {
                IgnoreStatus = NtClose(NextContext->RootKey);
                ASSERT(NT_SUCCESS(IgnoreStatus));
                NextContext->RootKey = INVALID_HANDLE_VALUE;
            }
        }

        NextEntry = NextEntry->Flink;
    }

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}


VOID
SampInvalidateContextListKeysByObjectType(
    IN SAMP_OBJECT_TYPE  ObjectType,
    IN BOOLEAN  Close
    )
/*++
Routine Description:

    this routine walks the SampContextList, and invalidates all contexts with
    the same ObjectType

Parameters: 

    ObjectType - indicates which object to be invalidated.

    Close - Tells whether close the registry key or not

Return Values:

    None

--*/
{
    NTSTATUS        IgnoreStatus = STATUS_SUCCESS;
    PLIST_ENTRY     Head, NextEntry;
    PSAMP_OBJECT    NextContext;

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // walk the active context list, invalidate the matching context 
    // 

    Head = &SampContextListHead;
    NextEntry = Head->Flink;

    while (NextEntry != Head) 
    {
        NextContext = CONTAINING_RECORD(
                          NextEntry,
                          SAMP_OBJECT,
                          ContextListEntry
                          );

        if ( ObjectType == NextContext->ObjectType )
        {
            //
            // close registry key if asked to do so.
            // 

            if (Close && (NextContext->RootKey != INVALID_HANDLE_VALUE)) 
            {
                IgnoreStatus = NtClose( NextContext->RootKey );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            NextContext->RootKey = INVALID_HANDLE_VALUE;
        }

        NextEntry = NextEntry->Flink;
    }

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\close.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This file contains the object close routine for SAM objects.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <samtrace.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






NTSTATUS
SamrCloseHandle(
    IN OUT SAMPR_HANDLE * SamHandle
    )

/*++

Routine Description:

    This service closes a handle for any type of SAM object.

    Any race conditions that may occur with respect to attempts to
    close a handle that is just becoming invalid by other means are
    expected to be handled by the RPC runtime.  That is, this service
    will never be called by the RPC runtime when the handle value is
    no longer valid.  It will also never call this routine when there
    is another call outstanding with this same context handle.

Arguments:

    SamHandle - A valid handle to a SAM object.

Return Value:


    STATUS_SUCCESS - The handle has successfully been closed.

    Others that might be returned by:

                SampLookupcontext()


--*/
{
    NTSTATUS            NtStatus=STATUS_SUCCESS;
    PSAMP_OBJECT        Context;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             fLockAcquired = FALSE;

    SAMTRACE_EX("SamrCloseHandle");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidCloseHandle
                   );

    if (NULL==SamHandle)
    {
        NtStatus = STATUS_INVALID_HANDLE;
        goto Error;
    }

    Context = (PSAMP_OBJECT)(* SamHandle);

    if (NULL==Context)
    {
        NtStatus = STATUS_INVALID_HANDLE;
        goto Error;
    }

    //
    // acquire lock is necessary
    // 

    SampMaybeAcquireReadLock(Context, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // should holds lock or the context is not shared among multi threads
    // 
    ASSERT(SampCurrentThreadOwnsLock() || Context->NotSharedByMultiThreads);

    //
    // pass -1 as DesiredAccess to indicate SampLookupContext() is called
    // during Context deletion phase.
    // 
    NtStatus = SampLookupContext(
                   Context,                     //Context
                   SAMP_CLOSE_OPERATION_ACCESS_MASK,  //DesiredAccess
                   SampUnknownObjectType,       //ExpectedType
                   &FoundType                   //FoundType
                  );


    if (NT_SUCCESS(NtStatus)) {

        ASSERT(Context->ReferenceCount>=2);

        //
        // Mark it for delete and remove the reference caused by
        // context creation (representing the handle reference).
        //

        SampDeleteContext( Context );

        //
        // And drop our reference from the lookup operation
        //

        SampDeReferenceContext( Context, FALSE );

        //
        // Tell RPC that the handle is no longer valid...
        //

        (*SamHandle) = NULL;
    }

    //
    // Free read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    if ( ( NT_SUCCESS( NtStatus ) ) &&
        ( FoundType == SampServerObjectType ) &&
        ( FALSE == SampUseDsData) &&
        ( !(LastUnflushedChange.QuadPart == SampHasNeverTime.QuadPart) ) ) {

        //
        // If we are registry mode and if 
        // Some app is closing the server object after having made
        // changes.  We should make sure that the changes get
        // flushed to disk before the app exits.  We need to get
        // the write lock for this.
        //

        FlushImmediately = TRUE;

        NtStatus = SampAcquireWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

            if ( !(LastUnflushedChange.QuadPart ==SampHasNeverTime.QuadPart) ) {

                //
                // Nobody flushed while we were waiting for the
                // write lock.  So flush the changes now.
                //

                NtStatus = NtFlushKey( SampKey );

                if ( NT_SUCCESS( NtStatus ) ) {

                    FlushImmediately = FALSE;
                    LastUnflushedChange = SampHasNeverTime;
                }
            }

            SampReleaseWriteLock( FALSE );
        }
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:
    
    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidCloseHandle
                   );

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\bldsam3.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    bldsam3.c

Abstract:

    This module provides an initialization capability to SAM.


    Approach
    --------

        This code has gone through a number of migrations that make it
        less than obvious what is going on.  To leverage off existing
        code and yet extend it to the initialization of two domains,
        with aliases, the following aproach has been taken:

           (1) Obtain the name and SID of the account domain.

           (2) Build the various security descriptors needed
               in the two domains.  These are kept in an array
               and the index is used to specify which applies
               to each new account.

           (3) Build up a list of alias memberships.  These, too,
               are selected by index, with one entry being the
               empty set.


Author:

    Jim Kelly  3-May-1991.

Revision History:

    08-Oct-1996 ChrisMay
        Added crash-recovery code, allowing SAM to initialize from the
        registry instead of the DS after a database corruption.

--*/

#include <nt.h>
#include <ntsam.h>
#include "ntlsa.h"
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "samsrvp.h"

//
// Constants used for Sam Global Data string buffers
//

#define SAMP_MAXIMUM_INTERNAL_NAME_LENGTH ((USHORT) 0x00000200L)





///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

static LSA_HANDLE SampBldPolicyHandle;  //Handle to LSA policy object

static NTSTATUS Status;

static BOOLEAN SampRealSetupWasRun;   //Indicates a real setup was run
static BOOLEAN SampDeveloperSetup;    //Indicates a developer setup is running

static NT_PRODUCT_TYPE SampBldProductType;
static DOMAIN_SERVER_ROLE SampServerRole;
static PPOLICY_PRIMARY_DOMAIN_INFO SampBldPrimaryDomain = NULL;



static PSID  WorldSid,
             LocalSystemSid,
             AdminsAliasSid,
             UsersAliasSid,
             PowerUsersAliasSid,
             AccountAliasSid,
             AnySidInAccountDomain;


static PACL  TokenDefaultDaclInformation;
static ULONG TokenDefaultDaclInformationSize;

//
// Handle to the registry key in which the SAM database resides
//

static HANDLE  SamParentKey = NULL;

//
// Handle to the root SAM key.
// This is the key that has the RXACT applied to it.
//

static HANDLE SamKey = NULL;

static PRTL_RXACT_CONTEXT SamRXactContext;

//
// Assorted names, buffers, and values used during registry key creation
//

static PSID    DomainSid;
static PUNICODE_STRING DomainNameU, FullDomainNameU;
static UNICODE_STRING  AccountInternalDomainNameU, BuiltinInternalDomainNameU;
static UNICODE_STRING  AccountExternalDomainNameU, BuiltinExternalDomainNameU;
static UNICODE_STRING  FullAccountInternalDomainNameU, FullBuiltinInternalDomainNameU;
static UNICODE_STRING  DomainNamePrefixU, TemporaryNamePrefixU, KeyNameU, TempStringU;

static WCHAR KeyNameBuffer[2000];
static WCHAR TempStringBuffer[2000];
static SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;




//
// Values that get placed in registry keys...
//

static LARGE_INTEGER DomainMaxPasswordAge = { 0, - 6L * 7L * 24L * 60L / 7L }; // 6 weeks
static LARGE_INTEGER ModifiedCount  = {0,0};
static UNICODE_STRING NullUnicodeString;

//
// Array of protection information for SAM objects
//

static SAMP_PROTECTION SampProtection[SAMP_PROT_TYPES];





//
// Internal routine definitions
//



NTSTATUS
SampGetDomainPolicy(
    IN PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL
    );

VOID
SampGetServerRole( VOID );

VOID
SampGetPrimaryDomainInfo(
    IN PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    );


VOID
GetDomainSids( VOID );

VOID
SetDomainName(
    IN BOOLEAN BuiltinDomain
    );


VOID
Usage ( VOID );



NTSTATUS
Initialize (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    );

BOOLEAN
InitializeSecurityDescriptors( VOID );

NTSTATUS
SampCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   SD
    );

NTSTATUS
SampBuildNewProtection(
    IN ULONG AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PSAMP_PROTECTION Result
    );

NTSTATUS
InitializeSam( VOID );

NTSTATUS
PrepDomain(
    IN SAMP_DOMAIN_SELECTOR Domain,
    IN BOOLEAN PreserveSyskeySettings
    );


VOID
SetCurrentDomain(
    IN SAMP_DOMAIN_SELECTOR Domain
    );


NTSTATUS
CreateBuiltinDomain( VOID );

NTSTATUS
CreateAccountDomain( IN BOOLEAN PreserveSyskeySettings );



NTSTATUS
CreateAlias(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN ULONG ProtectionIndex
    );


NTSTATUS
CreateGroup(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN BOOLEAN Admin
    );


NTSTATUS
CreateUser(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG UserRid,
    IN ULONG PrimaryGroup,
    IN BOOLEAN Admin,
    IN ULONG  UserControl,
    IN ULONG ProtectionIndex
    );



NTSTATUS
UpdateAliasXReference(
    IN ULONG AliasRid,
    IN PSID Sid
    );


NTSTATUS
OpenAliasMember(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    );


PSID
BuildPrimaryDomainSid(
    ULONG Rid
    );

PSID
BuildAccountSid(
    SAMP_DOMAIN_SELECTOR Domain,
    ULONG Rid
    );


NTSTATUS
OpenOrCreateAccountRidKey(
    IN PSID Sid,
    IN HANDLE AliasDomainHandle,
    OUT PHANDLE KeyHandle
    );

NTSTATUS
OpenOrCreateAliasDomainKey(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    );

NTSTATUS
AppendAliasDomainNameToUnicodeString(
    IN OUT PUNICODE_STRING Destination,
    IN PSID Sid
    );



NTSTATUS
SampInitilializeRegistry ( VOID );


NTSTATUS
SampDetermineSetupEnvironment( VOID );




///////////////////////////////////////////////////////////////////////
//                                                                   //
// Routines                                                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////


VOID
Usage (
    VOID
    )
/*++


Routine Description:

    This routine prints the "Usage:" message.

Arguments:

    None.

Return Value:

    None.

--*/
{

#if DBG
    BldPrint( "\n");
    BldPrint( "\n");

    BldPrint( "We offer no assistance in this suicide.\n");
    BldPrint( "\n");
    BldPrint( "\n");
    BldPrint( "\n");
#endif

    return;
}


VOID
UnexpectedProblem (
    VOID
    )
/*++


Routine Description:

    This routine prints a message indicating that an unexpected
    problem has occured.

Arguments:

    None.

Return Value:

    None.

--*/
{

#if DBG
    BldPrint( "\n");
    BldPrint( "\n");
    BldPrint( "  An unexpected problem has prevented the command from\n");
    BldPrint( "  completing successfully.  Please contact one of the\n");
    BldPrint( "  members of the security group for assistance.\n");
    BldPrint( "\n");
#endif

    return;

}


NTSTATUS
Initialize (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    )
/*++


Routine Description:

    This routine performs initialization operations before creating
    each domain.

    This includes:

        - Setting the correct default owner and DACL for registry key
          operations.

        - opening the parent registry key for the SAM database.


Arguments:

    SamParentKeyName  : the registry path to the parent of the SAM database

    ProductType       : the product type of the database to be created; if not
                        present, RtlGetNtProductType will be called

    ServerRole        : the role of the product; if not present, LSA will be queried

    AccountDomainInfo : name and sid of the account domain; if not present, LSA will be queried

    PrimaryDomainIndo : name and sid of the primary domain; if not present, LSA will be queried

Return Value:

    TRUE - Indicates initialization was successful.

    FALSE - Indicates initialization was not successful.

--*/

{
    OBJECT_ATTRIBUTES SamParentAttributes, PolicyObjectAttributes;
    UNICODE_STRING SamParentNameU;
    ULONG Disposition;
    HANDLE Token;
    TOKEN_OWNER LocalSystemOwner;
    SID_IDENTIFIER_AUTHORITY NtAuthority       = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PACL Dacl;
    TOKEN_DEFAULT_DACL DefaultDacl;
    BOOLEAN CompletionStatus;
    BOOLEAN ProductTypeRetrieved;
    BOOLEAN CrashRecoveryMode = FALSE;
    BOOLEAN RegistryMode = FALSE;

    SAMTRACE("Initialize");

    //
    // Set up some of the well known account SIDs for use...
    //

    WorldSid      = (PSID)RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT(WorldSid != NULL);
    if (NULL==WorldSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( WorldSid,      &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( WorldSid, 0 ))        = SECURITY_WORLD_RID;

    AdminsAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AdminsAliasSid != NULL);
    if (NULL==AdminsAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( AdminsAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AdminsAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AdminsAliasSid,  1 )) = DOMAIN_ALIAS_RID_ADMINS;

    PowerUsersAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(PowerUsersAliasSid != NULL);
    if (NULL==PowerUsersAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( PowerUsersAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( PowerUsersAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( PowerUsersAliasSid,  1 )) = DOMAIN_ALIAS_RID_POWER_USERS;

    UsersAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(UsersAliasSid != NULL);
    if (NULL==UsersAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( UsersAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( UsersAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( UsersAliasSid,  1 )) = DOMAIN_ALIAS_RID_USERS;

    AccountAliasSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 2 ));
    ASSERT(AccountAliasSid != NULL);
    if (NULL==AccountAliasSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( AccountAliasSid,   &BuiltinAuthority, 2 );
    *(RtlSubAuthoritySid( AccountAliasSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid( AccountAliasSid,  1 )) = DOMAIN_ALIAS_RID_ACCOUNT_OPS;

    LocalSystemSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT(LocalSystemSid != NULL);
    if (NULL==LocalSystemSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( LocalSystemSid,   &NtAuthority, 1 );
    *(RtlSubAuthoritySid( LocalSystemSid,  0 )) = SECURITY_LOCAL_SYSTEM_RID;

    //
    // Setup a buffer to use for all our key-name constructions
    //

    KeyNameU.MaximumLength = 2000;
    KeyNameU.Buffer = KeyNameBuffer;

    //
    // Setup temporary Unicode string buffer.
    //

    TempStringU.Buffer = TempStringBuffer;
    TempStringU.MaximumLength = 2000;

    //
    // Get a handle to the LSA Policy object
    //

    InitializeObjectAttributes(
        &PolicyObjectAttributes,
        NULL,             // Name
        0,                // Attributes
        NULL,             // Root
        NULL              // Security Descriptor
        );

    Status = LsaIOpenPolicyTrusted( &SampBldPolicyHandle );

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "newsam\\server\\bldsam3: Couldn't open LSA Policy object.\n"
                   "               Status: 0x%lx\n\n",
                   Status));

        return(Status);
    }

    //
    // Get the product type.
    //
    if (!ARGUMENT_PRESENT(ProductType)) {

        ProductTypeRetrieved = RtlGetNtProductType(&SampBldProductType);

        if (!ProductTypeRetrieved) {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Couldn't retrieve product type\n"));

            return(STATUS_UNSUCCESSFUL);
        }

    } else {

        SampBldProductType = *ProductType;

    }

    //
    // Figure out if we are being initialized following a real
    // setup, or it this is a developer setup.
    //

    SampDetermineSetupEnvironment();

    //
    // Domain name prefix is required by SampGetDomainPolicy() and
    // so must be initialized before that call.
    //

    RtlInitUnicodeString( &DomainNamePrefixU, L"Domains");

    //
    // Set up domain names/Sids.
    //

    Status = SampGetDomainPolicy(AccountDomainInfo);

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Get the role of this machine.
    //
    if (!ARGUMENT_PRESENT(ServerRole)) {

        if (NtProductLanManNt==SampBldProductType)
        {
            //
            // Domain Controllers are DS based. The server
            // role is set in them comes from the FSMO.
            // Therefore set their Server role here as a
            // Backup as a place holder
            //

            SampServerRole = DomainServerRoleBackup;
        }
        else
        {
            //
            // Else if we are a member server then the server
            // role is always set to primary. ServerRoles cannot
            // be backups in member servers or Workstations.
            //

            SampServerRole = DomainServerRolePrimary;
        }

    } else {

        SampServerRole = *ServerRole;
    }

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Get the primary domain info.
    //

    SampGetPrimaryDomainInfo(PrimaryDomainInfo);


    //
    // Open a handle to the parent of the SAM registry location.
    // This parent must already exist.
    //

    RtlInitUnicodeString( &SamParentNameU, SamParentKeyName );

    InitializeObjectAttributes(
        &SamParentAttributes,
        &SamParentNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = RtlpNtCreateKey(
                 &SamParentKey,
                 (KEY_READ | KEY_CREATE_SUB_KEY),
                 &SamParentAttributes,
                 0,
                 NULL,
                 &Disposition
                 );

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        BldPrint( "\n" );
        BldPrint( "\n" );
        BldPrint( "  We seem to be having trouble opening the registry\n" );
        BldPrint( "  database key in which the Security Account Manager\n" );
        BldPrint( "  information resides.  This registry key should have been\n" );
        BldPrint( "  created at system startup time.  Please see one of the\n" );
        BldPrint( "  security group developers for assistance in analyzing the\n" );
        BldPrint( "  the problem.\n" );
        BldPrint( "  Indicate that the registry key creation status is 0x%lx \n", Status);
        BldPrint( "\n" );
        BldPrint( "\n" );
#endif

        return(Status);
    }

    //
    // Set up some values, names, and buffers for later use
    //


    NullUnicodeString.Buffer        = NULL;
    NullUnicodeString.Length        = 0;
    NullUnicodeString.MaximumLength = 0;



    TemporaryNamePrefixU.Buffer        = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    TemporaryNamePrefixU.Length        = 0;
    TemporaryNamePrefixU.MaximumLength = 256;

    KeyNameU.Buffer               = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    KeyNameU.Length               = 0;
    KeyNameU.MaximumLength        = 256;

    //
    // Set up Security Descriptors needed for initialization...
    //

    CompletionStatus = InitializeSecurityDescriptors();

    if (CompletionStatus) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return(Status);
}


BOOLEAN
InitializeSecurityDescriptors(
    VOID
    )

/*++

Routine Description:

    This routine initializes security descriptors needed to create
    a SAM database.

    This routine expects all SIDs to be previously initialized.

Arguments:

    None.

Return Value:

    TRUE - Indicates initialization was successful.

    FALSE - Indicates initialization was not successful.


    The security descriptors are pointed to by global variables.

--*/

{
    PSID AceSid[10];          // Don't expect more than 10 ACEs in any of these.
    ACCESS_MASK AceMask[10];  // Access masks corresponding to Sids

    ACCESS_MASK NotForThisProductType; // Used to mask product-specific access restrictions

    GENERIC_MAPPING  SamServerMap =  {SAM_SERVER_READ,
                                      SAM_SERVER_WRITE,
                                      SAM_SERVER_EXECUTE,
                                      SAM_SERVER_ALL_ACCESS
                                      };

    GENERIC_MAPPING  DomainMap    =  {DOMAIN_READ,
                                      DOMAIN_WRITE,
                                      DOMAIN_EXECUTE,
                                      DOMAIN_ALL_ACCESS
                                      };

    GENERIC_MAPPING  AliasMap     =  {ALIAS_READ,
                                      ALIAS_WRITE,
                                      ALIAS_EXECUTE,
                                      ALIAS_ALL_ACCESS
                                      };

    GENERIC_MAPPING  GroupMap     =  {GROUP_READ,
                                      GROUP_WRITE,
                                      GROUP_EXECUTE,
                                      GROUP_ALL_ACCESS
                                      };

    GENERIC_MAPPING  UserMap      =  {USER_READ,
                                      USER_WRITE,
                                      USER_EXECUTE,
                                      USER_ALL_ACCESS
                                      };

    SAMTRACE("InitializeSecurityDescriptors");

    //
    // We need a number of different security descriptors:
    //

    //
    //
    //   The following security is assigned to
    //
    //             - Builtin DOMAIN objects
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant
    //              WORLD               Administrators
    //              (Execute | Read)    GenericRead    |
    //                                  GenericExecute |
    //                                  DOMAIN_READ_OTHER_PARAMETERS |
    //                                  DOMAIN_ADMINISTER_SERVER     |
    //                                  DOMAIN_CREATE_ALIAS
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //
    //   The following security is assigned to
    //
    //             - SAM_SERVER object
    //             - Account DOMAIN objects
    //             - The Administrators alias.
    //             - All groups in the ACCOUNT or BUILTIN domain that are
    //               made a member of the Administrators alias.
    //
    //    Note: on WinNt systems, the ACLs do not grant DOMAIN_CREATE_GROUP.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant
    //              WORLD               Administrators
    //              (Execute | Read)    GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //   All other aliases and groups must be assigned the following
    //   security:
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant           Grant
    //              WORLD               Administrators  AccountOperators Alias
    //              (Execute | Read)    GenericAll      GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //             - All users in the ACCOUNT or BUILTIN domain that are
    //               made a member of the Administratos alias.  This includes
    //               direct inclusion or indirect inclusion through group
    //               membership.
    //
    //
    //   The following security is assigned to:
    //
    //             - All users in the ACCOUNT or BUILTIN domain that are
    //               made a member of the Administrators alias.  This includes
    //               direct inclusion or indirect inclusion through group
    //               membership.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant            Grant          Grant
    //              WORLD            Administrators User's SID
    //              (Execute | Read) GenericAll     GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //   All other users must be assigned the following
    //   security:
    //
    //      Owner: AccountOperators Alias
    //      Group: AccountOperators Alias
    //
    //      Dacl:   Grant            Grant          Grant                   Grant
    //              WORLD            Administrators Account Operators Alias User's SID
    //              (Execute | Read) GenericAll     GenericAll              GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //   except builtin GUEST, who can't change their own account info.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //
    // Note, however, that because we are going to cram these ACLs
    // directly into the backing store, we must map the generic accesses
    // beforehand.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //






    //
    // Sam Server SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (SAM_SERVER_EXECUTE | SAM_SERVER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (SAM_SERVER_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &SamServerMap,                         // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_SAM_SERVER]  // Result
                 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Builtin Domain SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (DOMAIN_EXECUTE | DOMAIN_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (DOMAIN_EXECUTE | DOMAIN_READ |
                  DOMAIN_READ_OTHER_PARAMETERS |
                  DOMAIN_ADMINISTER_SERVER     |
                  DOMAIN_CREATE_ALIAS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &DomainMap,                            // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_BUILTIN_DOMAIN]      // Result
                 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Account Domain SD
    //

    if (SampBldProductType == NtProductLanManNt) {
        NotForThisProductType = 0;
    } else {
        NotForThisProductType = DOMAIN_CREATE_GROUP;
    }

    AceSid[0]  = WorldSid;
    AceMask[0] = (DOMAIN_EXECUTE | DOMAIN_READ) & ~NotForThisProductType;

    AceSid[1]  = UsersAliasSid;
    AceMask[1] = (DOMAIN_EXECUTE | DOMAIN_READ)
                 & ~NotForThisProductType;

    AceSid[2]  = AdminsAliasSid;
    AceMask[2] = (DOMAIN_ALL_ACCESS) & ~NotForThisProductType;

    AceSid[3]  = PowerUsersAliasSid;
    AceMask[3] = (DOMAIN_EXECUTE | DOMAIN_READ | DOMAIN_CREATE_USER |
                                                 DOMAIN_CREATE_ALIAS)
                                                 & ~NotForThisProductType;

    AceSid[4]  = AccountAliasSid;
    AceMask[4] = (DOMAIN_EXECUTE | DOMAIN_READ | DOMAIN_CREATE_USER  |
                                                 DOMAIN_CREATE_GROUP |
                                                 DOMAIN_CREATE_ALIAS)
                                                 & ~NotForThisProductType;


    Status = SampBuildNewProtection(
                 5,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &DomainMap,                            // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_ACCOUNT_DOMAIN]      // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Admin Alias SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_ADMIN_ALIAS] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Normal Alias SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (ALIAS_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_NORMAL_ALIAS] // Result
                 );
    ASSERT(NT_SUCCESS(Status));




    //
    // Power User accessible Alias SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (ALIAS_ALL_ACCESS);

    AceSid[3]  = PowerUsersAliasSid;
    AceMask[3] = (ALIAS_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 4,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS] // Result
                 );
    ASSERT(NT_SUCCESS(Status));




    //
    // Admin Group SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_ADMIN_GROUP] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Normal GROUP SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (GROUP_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_NORMAL_GROUP] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Admin User SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AnySidInAccountDomain;
    AceMask[2] = (USER_WRITE);


    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // user object (rid replacement)
                 &SampProtection[SAMP_PROT_ADMIN_USER]  // Result
                 );
    ASSERT(NT_SUCCESS(Status));


    //
    // Normal User SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (USER_ALL_ACCESS);

    AceSid[3]  = AnySidInAccountDomain;
    AceMask[3] = (USER_WRITE);


    Status = SampBuildNewProtection(
                 4,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // user object (rid replacement)
                 &SampProtection[SAMP_PROT_NORMAL_USER] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Builtin Guest Account SD
    // Can't change own password or other setable fields
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (USER_READ | USER_EXECUTE & ~(USER_CHANGE_PASSWORD));

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (USER_ALL_ACCESS);




    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 FALSE,                                 // no rid replacement
                 &SampProtection[SAMP_PROT_GUEST_ACCOUNT]  // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    return(TRUE);

}


NTSTATUS
SampBuildNewProtection(
    IN ULONG AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PSAMP_PROTECTION Result
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the SAM objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.

    The owner and group of each security descriptor will be set
    to:

                    Owner:  Administrators Alias
                    Group:  Administrators Alias


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity) & !ReadControl



Arguments:

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    GenericMap - Points to a generic mapping for the target object type.


    UserObject - Indicates whether the target SAM object is a User object
        or not.  If TRUE (it is a User object), then the resultant
        protection will be set up indicating Rid replacement is necessary.

    Result - Receives a pointer to the resultant protection information.
        All access masks in ACLs in the result are mapped to standard and
        specific accesses.


Return Value:

    TBS.

--*/
{



    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative;
    PACL                    TmpAcl;
    PACCESS_ALLOWED_ACE     TmpAce;
    PSID                    TmpSid;
    ULONG                   Length, i;
    PULONG                  RidLocation = NULL;
    BOOLEAN                 IgnoreBoolean;
    ACCESS_MASK             MappedMask;

    SAMTRACE("SampBuildNewProtection");

    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //


    Status = RtlCreateSecurityDescriptor(
                 &Absolute,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );



    //
    // Owner
    //

    Status = RtlSetOwnerSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));



    //
    // Group
    //

    Status = RtlSetGroupSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));




    //
    // Discretionary ACL
    //
    //      Calculate its length,
    //      Allocate it,
    //      Initialize it,
    //      Add each ACE
    //      Add it to the security descriptor
    //

    Length = (ULONG)sizeof(ACL);
    for (i=0; i<AceCount; i++) {

        Length += RtlLengthSid( AceSid[i] ) +
                  (ULONG)sizeof(ACCESS_ALLOWED_ACE) -
                  (ULONG)sizeof(ULONG);  //Subtract out SidStart field length
    }

    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL==TmpAcl)
    {
        return(STATUS_NO_MEMORY);
    }


    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    for (i=0; i<AceCount; i++) {
        MappedMask = AceMask[i];
        RtlMapGenericMask( &MappedMask, GenericMap );
        Status = RtlAddAccessAllowedAce (
                     TmpAcl,
                     ACL_REVISION2,
                     MappedMask,
                     AceSid[i]
                     );
        ASSERT( NT_SUCCESS(Status) );
    }

    Status = RtlSetDaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));




    //
    // Sacl
    //


    Length = (ULONG)sizeof(ACL) +
             RtlLengthSid( WorldSid ) +
             RtlLengthSid( SampAnonymousSid ) +
             2*((ULONG)sizeof(SYSTEM_AUDIT_ACE) - (ULONG)sizeof(ULONG));  //Subtract out SidStart field length
    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL == TmpAcl)
    {
        return(STATUS_NO_MEMORY);
    }

    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 (GenericMap->GenericWrite | DELETE | WRITE_DAC | ACCESS_SYSTEM_SECURITY) & ~READ_CONTROL,
                 WorldSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 GenericMap->GenericWrite | STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                 SampAnonymousSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetSaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));






    //
    // Convert the Security Descriptor to Self-Relative
    //
    //      Get the length needed
    //      Allocate that much memory
    //      Copy it
    //      Free the generated absolute ACLs
    //

    Length = 0;
    Status = RtlAbsoluteToSelfRelativeSD( &Absolute, NULL, &Length );
    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    Relative = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(Relative != NULL);
    if (NULL==Relative)
    {
        return(STATUS_NO_MEMORY);
    }
    Status = RtlAbsoluteToSelfRelativeSD(&Absolute, Relative, &Length );
    ASSERT(NT_SUCCESS(Status));


    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Dacl );
    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Sacl );




    //
    // If the object is a user object, then get the address of the
    // last RID of the SID in the last ACE in the DACL.
    //

    if (UserObject == TRUE) {

        Status = RtlGetDaclSecurityDescriptor(
                    Relative,
                    &IgnoreBoolean,
                    &TmpAcl,
                    &IgnoreBoolean
                    );
        ASSERT(NT_SUCCESS(Status));
        Status = RtlGetAce ( TmpAcl, AceCount-1, (PVOID *)&TmpAce );
        ASSERT(NT_SUCCESS(Status));
        TmpSid = (PSID)(&TmpAce->SidStart),

        RidLocation = RtlSubAuthoritySid(
                          TmpSid,
                          (ULONG)(*RtlSubAuthorityCountSid( TmpSid ) - 1)
                          );
    }







    //
    // Set the result information
    //

    Result->Length = Length;
    Result->Descriptor = Relative;
    Result->RidToReplace = RidLocation;
    Result->RidReplacementRequired = UserObject;



    return(Status);

}

NTSTATUS
SampGetDomainPolicy(
    IN PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL
    )
/*++


Routine Description:

    This routine builds the name strings for domains.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Size;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;

    SAMTRACE("SampGetDomainPolicy");

    //
    // Builtin domain - Well-known External Name and Sid
    //                - Internal Name matches External Name

    RtlInitUnicodeString( &BuiltinInternalDomainNameU, L"Builtin");
    FullBuiltinInternalDomainNameU.Buffer        = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    if(NULL==FullBuiltinInternalDomainNameU.Buffer)
    {
        return(STATUS_NO_MEMORY);
    }
    FullBuiltinInternalDomainNameU.Length        = 0;
    FullBuiltinInternalDomainNameU.MaximumLength = 256;
    RtlCopyUnicodeString( &FullBuiltinInternalDomainNameU, &DomainNamePrefixU );
    Status = RtlAppendUnicodeToString( &FullBuiltinInternalDomainNameU, L"\\" );
    RtlAppendUnicodeStringToString( &FullBuiltinInternalDomainNameU, &BuiltinInternalDomainNameU );

    BuiltinExternalDomainNameU = BuiltinInternalDomainNameU;

    SampBuiltinDomainSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( SampBuiltinDomainSid != NULL );
    if(NULL==SampBuiltinDomainSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( SampBuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( SampBuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Account domain - Configurable External Name and Sid.
    //
    //                  The External Name and Sid are obtained from the
    //                  Lsa Policy Object (PolicyAccountDomainInformation
    //                  information class).  For a DC, the External Name
    //                  is the Domain Name and for a Wksta, the External
    //                  Name is the Computer Name as at the time of the
    //                  system load.
    //
    //                  For DC's the Internal Name is the Domain Name
    //                - For Wksta's the Internal Name is the constant name
    //                  "Account".
    //
    //                NOTE:  The reason for these choices of Internal Name
    //                       is to avoid having to change the SAM Database.
    //

    if (!ARGUMENT_PRESENT(AccountDomainInfo)) {
        Status = SampGetAccountDomainInfo( &PolicyAccountDomainInfo );
    } else {
        PolicyAccountDomainInfo = AccountDomainInfo;
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "BLDSAM3:  Couldn't retrieve policy information from LSA.\n"
                   "          Status = 0x%lx\n",
                   Status));

        return Status;
    }

    SampAccountDomainSid = PolicyAccountDomainInfo->DomainSid;

    AccountExternalDomainNameU = PolicyAccountDomainInfo->DomainName;

    RtlInitUnicodeString( &AccountInternalDomainNameU, L"Account");

    FullAccountInternalDomainNameU.Buffer        = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    if(NULL==FullAccountInternalDomainNameU.Buffer)
    {
        return(STATUS_NO_MEMORY);
    }
    FullAccountInternalDomainNameU.Length        = 0;
    FullAccountInternalDomainNameU.MaximumLength = SAMP_MAXIMUM_INTERNAL_NAME_LENGTH;
    RtlCopyUnicodeString( &FullAccountInternalDomainNameU, &DomainNamePrefixU );
    Status = RtlAppendUnicodeToString( &FullAccountInternalDomainNameU, L"\\" );
    RtlAppendUnicodeStringToString( &FullAccountInternalDomainNameU, &AccountInternalDomainNameU );

    //
    // Now initialize a SID that can be used to represent accounts
    // in this domain.  Same as SampAccountDomainSid except with one
    // extra sub-authority.  It doesn't matter what the value of the
    // last RID is because it is always replaced before use.
    //

    Size = RtlLengthSid( SampAccountDomainSid ) + sizeof(ULONG);
    AnySidInAccountDomain = RtlAllocateHeap( RtlProcessHeap(), 0, Size);
    ASSERT( AnySidInAccountDomain != NULL );
    if(NULL==AnySidInAccountDomain)
    {
        return(STATUS_NO_MEMORY);
    }
    Status = RtlCopySid( Size, AnySidInAccountDomain, SampAccountDomainSid );
    ASSERT(NT_SUCCESS(Status));
    (*RtlSubAuthorityCountSid( AnySidInAccountDomain )) += 1;


    //
    // Set builtin as "current" domain
    //

    SetCurrentDomain( DomainBuiltin );

    return(STATUS_SUCCESS);
}


VOID
SetCurrentDomain(
    IN SAMP_DOMAIN_SELECTOR Domain
    )
/*++


Routine Description:

    This routine sets the current domain to be
    either the account or builtin domain.

Arguments:

    Domain - Specifies either builtin or account domain.
             (DomainBuiltin or DomainAccount).


Return Value:

    None.

--*/
{

    SAMTRACE("SetCurrentDomain");


    if (Domain == DomainBuiltin) {

        DomainNameU = &BuiltinInternalDomainNameU;
        FullDomainNameU = &FullBuiltinInternalDomainNameU;
        DomainSid = SampBuiltinDomainSid;

    } else {

        DomainNameU = &AccountInternalDomainNameU;
        FullDomainNameU = &FullAccountInternalDomainNameU;
        DomainSid = SampAccountDomainSid;

    }



    return;
}

NTSTATUS
InitializeSam(
    )

/*++

Routine Description:

    This routine initializes the SAM-level registry information.
    It does not initialize any domains in the SAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE ServerVariableAttributeArray;
    PVOID ServerVariableData;
    OBJECT_ATTRIBUTES SamAttributes;
    UNICODE_STRING SamNameU;
    ULONG Disposition;
    ULONG ServerAttributeLength;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    BOOLEAN IgnoreBoolean;
    PACL Dacl;

    SAMTRACE("InitializeSam");

    //
    // Build a system default Dacl to protect the SAM database
    // with.
    //

    Status = SampCreateDatabaseProtection( &SecurityDescriptor );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // See if a remnant of a SAM database already exists
    //

    RtlInitUnicodeString( &SamNameU, L"SAM" );

    InitializeObjectAttributes(
        &SamAttributes,
        &SamNameU,
        OBJ_CASE_INSENSITIVE,
        SamParentKey,
        &SecurityDescriptor
        );
    Status = RtlpNtCreateKey(
                 &SamKey,
                 (KEY_READ | KEY_CREATE_SUB_KEY | KEY_WRITE),
                 &SamAttributes,
                 0,
                 NULL,
                 &Disposition
                 );

    Status = RtlGetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 &IgnoreBoolean,
                 &Dacl,
                 &IgnoreBoolean
                 );

    if (Dacl != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, Dacl );
    }
    ASSERT(SecurityDescriptor.Sacl == NULL);
    ASSERT(SecurityDescriptor.Owner == NULL);
    ASSERT(SecurityDescriptor.Group == NULL);

    if ( !NT_SUCCESS(Status) ) {

#if DBG
        BldPrint( "\n" );
        BldPrint( "\n" );
        BldPrint( "  We seem to  be having trouble creating  the registry\n" );
        BldPrint( "  database key in which  the  Security Account Manager\n" );
        BldPrint( "  information resides.  Please see one of the security\n" );
        BldPrint( "  group  developers  for  assistance in  analyzing the\n" );
        BldPrint( "  the problem.\n" );
        BldPrint( "\n" );
        BldPrint( "\n" );
#endif

        return(Status);
    }

    if ( Disposition != REG_CREATED_NEW_KEY ) {

#if DBG
        BldPrint( "\n" );
        BldPrint( "\n" );
        BldPrint( "  I'm terribly sorry, but you have specified that a SAM\n" );
        BldPrint( "  database be initialized and yet there is already a SAM\n" );
        BldPrint( "  database in existance.  If the SAM database is corrupt\n" );
        BldPrint( "  or you would like to replace the existing domain anyway,\n" );
        BldPrint( "  please delnode the existing database and re-issue this \n");
        BldPrint( "  command.  \n");
        BldPrint( "  The SAM database is in ...\\registry\\Machine\\security\\sam.\n" );
        BldPrint( "  Thank you.\n" );
        BldPrint( "\n" );
        BldPrint( "\n" );
#endif

        Usage();

        Status = NtClose( SamKey );


        return(Status);
    }


    //
    // Initialize the registry transaction structure for SAM.
    //

    Status = RtlInitializeRXact( SamKey, FALSE, &SamRXactContext );

    if ( Status != STATUS_RXACT_STATE_CREATED ) {
#if DBG
        BldPrint("\n");
        BldPrint("  The SAM database already has a structure in place.\n");
        BldPrint("  This indicates multiple initializations being performed\n");
        BldPrint("  simultaneously.  Please be sure no other initializations\n");
        BldPrint("  are being performed and issue this command again.\n");
        BldPrint("\n");
        BldPrint("\n");
#endif

        if ( Status == STATUS_SUCCESS ) {

            //
            // Shouldn't happen, but let's program defensively.
            //

            Status = STATUS_RXACT_INVALID_STATE;
        }

        return(Status);
    }

    //
    // Start an RXACT to do the rest in ...
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Starting transaction\n");

    //
    // Set the server's fixed and variable attributes
    //

    ServerAttributeLength = sizeof( SAMP_V1_FIXED_LENGTH_SERVER ) +
                                ( SAMP_SERVER_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampProtection[SAMP_PROT_SAM_SERVER].Length;

    ServerFixedAttributes = (PSAMP_V1_FIXED_LENGTH_SERVER)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                ServerAttributeLength
                                );

    if ( ServerFixedAttributes == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create server attributes\n");

    //
    // The server revision on the a new SAM database may not be the same
    // as the revision on the rest of SAM.  This allows the server revision
    // to indicate which bugs have been fixed in this SAM.
    //

    ServerFixedAttributes->RevisionLevel = SAMP_NT4_SERVER_REVISION;

    ServerVariableAttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   ((PUCHAR)(ServerFixedAttributes) +
                                   sizeof( SAMP_V1_FIXED_LENGTH_SERVER ) );

    ServerVariableAttributeArray->Offset = 0;
    ServerVariableAttributeArray->Length =
        SampProtection[SAMP_PROT_SAM_SERVER].Length;
    ServerVariableAttributeArray->Qualifier = SAMP_REVISION;

    ServerVariableData = (PVOID)( (PUCHAR)(ServerVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        ServerVariableData,
        SampProtection[SAMP_PROT_SAM_SERVER].Descriptor,
        SampProtection[SAMP_PROT_SAM_SERVER].Length
        );

    //
    // Now write out the attributes via the RXACT.
    //

    RtlInitUnicodeString( &SamNameU, NULL );

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &SamNameU,
                  INVALID_HANDLE_VALUE,
                  &SampCombinedAttributeName,
                  REG_BINARY,
                  (PVOID)ServerFixedAttributes,
                  ServerAttributeLength,
                  FIXED_LENGTH_SERVER_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &SamNameU,
                 INVALID_HANDLE_VALUE,
                 &SampCombinedAttributeName,
                 REG_BINARY,
                 (PVOID)ServerFixedAttributes,
                 ServerAttributeLength
                 );

    SUCCESS_ASSERT(Status, "  Failed to write out server attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, ServerFixedAttributes );

    //
    // Create SAM\Domains
    //

    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &DomainNamePrefixU,
                 0,
                 NULL,
                 0
                 );

    SUCCESS_ASSERT(Status, "  Failed to add domain key to log\n");

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Committing SAM INIT transaction\n");

    return(Status);
}


NTSTATUS
SampCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   Sd
    )


/*++

Routine Description:

    This function allocates and initializes protection to assign to
    the SAM database.

    Upon return, any non-zero pointers in the security descriptors
    point to memory allocated from process heap.  It is the caller's
    responsibility to free this memory.


    Protection is:

                        System: All Access
                        Admin:  ReadControl | WriteDac

Arguments:

    Sd - Address of a security descriptor to initialize.

Return Value:

    STATUS_SUCCESS - The Security descriptor has been initialize.

    STATUS_NO_MEMORY - couldn't allocate memory for the protection info.

--*/


{
    NTSTATUS
        Status;

    ULONG
        Length;

    USHORT
        i;

    PACL
        Dacl;

    PACE_HEADER
        Ace;

    SAMTRACE("SampCreateDatabaseProtection");


    //
    // Initialize the security descriptor.
    // This call should not fail.
    //

    Status = RtlCreateSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION1 );
    ASSERT(NT_SUCCESS(Status));

    Length = (ULONG)sizeof(ACL) +
                 (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                 RtlLengthSid( LocalSystemSid ) +
                 RtlLengthSid( AdminsAliasSid ) +
                 8; // The 8 is just for good measure


    Dacl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

    if (Dacl == NULL) {
        return(STATUS_NO_MEMORY);
    }


    Status = RtlCreateAcl (Dacl, Length, ACL_REVISION2 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Add ACEs to the ACL...
    // These calls should not be able to fail.
    //

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (GENERIC_ALL ),
                 LocalSystemSid
                 );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (READ_CONTROL | WRITE_DAC),
                 AdminsAliasSid
                 );
    ASSERT(NT_SUCCESS(Status));


    //
    // Now mark the ACEs as inheritable...
    //

    for ( i=0; i<Dacl->AceCount; i++) {

        //
        // Get the address of the next ACE
        // (Shouldn't fail)
        //

        Status = RtlGetAce( Dacl, (ULONG)i, &Ace );
        ASSERT(NT_SUCCESS(Status));

        Ace->AceFlags |= (CONTAINER_INHERIT_ACE);

    }


    //
    // And add the ACL to the security descriptor.
    // This call should not fail.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 Sd,
                 TRUE,              // DaclPresent
                 Dacl,              // Dacl OPTIONAL
                 FALSE              // DaclDefaulted OPTIONAL
                 );
    ASSERT(NT_SUCCESS(Status));



    return(STATUS_SUCCESS);

}


NTSTATUS
CreateBuiltinDomain (
    )

/*++

Routine Description:

    This routine creates a new builtin domain.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name, Comment;
    HMODULE AccountNamesResource;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("CreateBuiltinDomain");


    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL));


    //
    // Get the message resource we need to get the account names from
    //

    AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if (AccountNamesResource == NULL) {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }




    //
    // Prep the standard domain registry structure for this domain
    //

    Status = PrepDomain(DomainBuiltin,FALSE);

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Create the alias accounts with no members
    // (Common to LanManNT and WinNT products)
    //

    if (fPersonalSKU)
    {
        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_ADMINS_PERS,
                    &Name,
                    SAMP_ALIAS_COMMENT_ADMINS_PERS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

    }
    else
    {

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_ADMINS,
                    &Name,
                    SAMP_ALIAS_COMMENT_ADMINS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));
    }

    Status = CreateAlias(&Name,                          // AccountName
                         &Comment,                       // AccountComment
                         TRUE,                           // SpecialAccount
                         DOMAIN_ALIAS_RID_ADMINS,        // Rid
                         SAMP_PROT_ADMIN_ALIAS           // Protection
                         ); ASSERT(NT_SUCCESS(Status));
    LocalFree( Name.Buffer );
    LocalFree( Comment.Buffer );

    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_ALIAS_NAME_USERS,
                &Name,
                SAMP_ALIAS_COMMENT_USERS,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    Status = CreateAlias(&Name,                   // AccountName
                        &Comment,                // AccountComment
                        TRUE,                           // SpecialAccount
                        DOMAIN_ALIAS_RID_USERS,         // Rid
                        SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS // Protection
                        ); ASSERT(NT_SUCCESS(Status));

    LocalFree( Name.Buffer );
    LocalFree( Comment.Buffer );

    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_ALIAS_NAME_GUESTS,
                &Name,
                SAMP_ALIAS_COMMENT_GUESTS,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    Status = CreateAlias(&Name,                   // AccountName
                        &Comment,                // AccountComment
                        TRUE,                           // SpecialAccount
                        DOMAIN_ALIAS_RID_GUESTS,        // Rid
                        SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS // Protection
                        ); ASSERT(NT_SUCCESS(Status));

    LocalFree( Name.Buffer );
    LocalFree( Comment.Buffer );


    if (!fPersonalSKU)
    {
        // Personal SKU doesn't have Backup Operators or Replicators

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_BACKUP_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_BACKUP_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_BACKUP_OPS,    // Rid
                            SAMP_PROT_ADMIN_ALIAS          // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_REPLICATOR,
                    &Name,
                    SAMP_ALIAS_COMMENT_REPLICATOR,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_REPLICATOR,    // Rid
                            SAMP_PROT_NORMAL_ALIAS          // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );
    }


    if (SampBldProductType == NtProductLanManNt) {

        //
        // specific to LanManNT products
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_SERVER_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_SERVER_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_SYSTEM_OPS,    // Rid
                            SAMP_PROT_ADMIN_ALIAS           // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_ACCOUNT_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_ACCOUNT_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_ACCOUNT_OPS,   // Rid
                            SAMP_PROT_ADMIN_ALIAS           // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_PRINT_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_PRINT_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_PRINT_OPS,     // Rid
                            SAMP_PROT_ADMIN_ALIAS           // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


    } else {

        //
        // specific to WinNT products
        //
        if (!fPersonalSKU)
        {

            Status = SampGetMessageStrings(
                        AccountNamesResource,
                        SAMP_ALIAS_NAME_POWER_USERS,
                        &Name,
                        SAMP_ALIAS_COMMENT_POWER_USERS,
                        &Comment
                        ); ASSERT(NT_SUCCESS(Status));

            Status = CreateAlias(&Name,                   // AccountName
                                &Comment,                // AccountComment
                                TRUE,                           // SpecialAccount
                                DOMAIN_ALIAS_RID_POWER_USERS,   // Rid
                                SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS // Protection
                                ); ASSERT(NT_SUCCESS(Status));

            LocalFree( Name.Buffer );
            LocalFree( Comment.Buffer );
        }


    }

    return(Status);
}



NTSTATUS
CreateAccountDomain (
    IN BOOLEAN PreserveSyskeySettings
    )
/*++


Routine Description:

    This routine creates a new account domain using information
    from the configuration database and based upon the system's
    product type.

    If the product is a WinNt system, then the domain's name is
    "Account".  If the product is a LanManNT system, then the
    domain's name is retrieved from the configuration information.

Arguments:

    None.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING Name, Comment;
    HMODULE AccountNamesResource;
    ULONG AccountControl;
    ULONG PrimaryGroup;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("CreateAccountDomain");


    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask && VER_SUITE_PERSONAL));


    //
    // Get the message resource we need to get the account names from
    //

    AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if (AccountNamesResource == NULL) {
        DbgPrint("BLDSAM3: Error loading library - error is 0x%lx", GetLastError());
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }



    //
    // Prep the standard domain registry structure for this domain
    //

    Status = PrepDomain(DomainAccount,PreserveSyskeySettings);

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Create the group accounts with no members
    //

    if ((SampBldProductType == NtProductWinNt) ||
        (SampBldProductType == NtProductServer)) {

        //
        // WinNt systems only have one group (called 'None').
        // This group has the same RID as the 'Domain Users' group.
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_NONE,
                    &Name,
                    SAMP_GROUP_COMMENT_NONE,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_USERS,         // Rid
                             FALSE                           // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

    } else {

        //
        // LanManNT
        //

        //
        // USERS global group
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_USERS,
                    &Name,
                    SAMP_GROUP_COMMENT_USERS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_USERS,         // Rid
                             FALSE                           // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

        //
        // ADMINS global group
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_ADMINS,
                    &Name,
                    SAMP_GROUP_COMMENT_ADMINS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_ADMINS,        // Rid
                             TRUE                            // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        //
        // GUESTS global group
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_GUESTS,
                    &Name,
                    SAMP_GROUP_COMMENT_GUESTS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_GUESTS,        // Rid
                             FALSE                           // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

    }

    //
    // create the user accounts ...
    // These are automatically added to the "Domain Users" group
    // (except for Guest).
    //

    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_USER_NAME_ADMIN,
                &Name,
                SAMP_USER_COMMENT_ADMIN,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    Status = CreateUser( &Name,                         // AccountName
                         &Comment,                      // AccountComment
                         TRUE,                          // SpecialAccount
                         DOMAIN_USER_RID_ADMIN,         // UserRid
                         DOMAIN_GROUP_RID_USERS,        // PrimaryGroup
                         TRUE,                          // Admin flag
                         USER_NORMAL_ACCOUNT |
                             USER_DONT_EXPIRE_PASSWORD, // AccountControl
                         SAMP_PROT_ADMIN_USER           // ProtectionIndex
                         ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_USER_NAME_GUEST,
                &Name,
                SAMP_USER_COMMENT_GUEST,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    //
    // Only Enable Guest user account on Personal systems, all others disable
    //

    
    AccountControl = USER_NORMAL_ACCOUNT |
                     USER_DONT_EXPIRE_PASSWORD |
                     USER_PASSWORD_NOT_REQUIRED;

    if ( !fPersonalSKU )
        AccountControl |= USER_ACCOUNT_DISABLED;


    if (SampBldProductType == NtProductLanManNt) {

        //
        // Guest group is in GUESTS global group for LmNT systems.
        //

        PrimaryGroup = DOMAIN_GROUP_RID_GUESTS;

    } else {

        //
        // There isn't a GUESTS global group on WinNt systems.
        // Put the guest in the NONE group (same as USERS group).
        //

        PrimaryGroup = DOMAIN_GROUP_RID_USERS;

    }


    Status = CreateUser( &Name,                         // AccountName
                         &Comment,                      // AccountComment
                         TRUE,                          // SpecialAccount
                         DOMAIN_USER_RID_GUEST,         // UserRid
                         PrimaryGroup,                  // PrimaryGroup
                         FALSE,                         // Admin flag
                         AccountControl,                // AccountControl
                         SAMP_PROT_GUEST_ACCOUNT        // ProtectionIndex
                         ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

    return(Status);
}


NTSTATUS
PrepDomain(
    IN SAMP_DOMAIN_SELECTOR Domain,
    IN BOOLEAN PreserveSyskeySettings
    )

/*++

Routine Description:

    This routine adds the domain level definitions to the operation log.

Arguments:

    Domain - Indicates which domain is being prep'd
    PreserveSyskeySettings -- Indicates that current syskey settings needs to
                              be preserved


Return Value:

    TBS

--*/

{
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN DomainFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE DomainVariableAttributeArray;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE DomainVariableAttributeArrayStart;
    PVOID DomainVariableData;
    ULONG DomainAttributeLength;
    ULONG ProtectionIndex;
    ULONG UserCount, GroupCount, AliasCount;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("PrepDomain");

    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask && VER_SUITE_PERSONAL));


    //
    // Set current domain
    //

    SetCurrentDomain( Domain );

    //
    // Select correct protection, and the number of accounts we're going
    // to create
    //

    if (Domain == DomainBuiltin) {

        ProtectionIndex = SAMP_PROT_BUILTIN_DOMAIN;

        UserCount = 0;
        GroupCount = 0;

        if (SampBldProductType == NtProductLanManNt) {

            //
            // Admins, BackupOps, Guests, Replicator, Users, SysOps,
            // AcctOps, PrintOps
            //

            AliasCount = 8;

        } else {
            if (fPersonalSKU)
            {
                //
                // Admins, Guests, Users
                //
                AliasCount = 3;
            }
            else
            {
                //
                // Admins, BackupOps, Guests, Replicator, Users, Power Users
                //
                AliasCount = 6;
            }
        }

    } else {

        ProtectionIndex = SAMP_PROT_ACCOUNT_DOMAIN;

        AliasCount = 0;
        UserCount = 2;  // Administrator, Guest

        if (SampBldProductType == NtProductLanManNt) {

            GroupCount = 3; // Users, Administrators, Guests

        } else {

            GroupCount = 1; // "None"
        }
    }

    //
    // Use a transaction.
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Starting transaction\n");

    //
    // Create SAM\Domains\(DomainName) (KeyValueType is revision level)
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );

    //
    // Set the domain's fixed and variable attributes.
    //

    DomainFixedAttributes = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN )
                                );

    if ( DomainFixedAttributes == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create domain fixed attributes\n");

    RtlZeroMemory(
        DomainFixedAttributes,
        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN));

    DomainFixedAttributes->Revision                  = SAMP_REVISION;
    DomainFixedAttributes->MinPasswordLength         = 0;
    DomainFixedAttributes->PasswordHistoryLength     = 0;
    DomainFixedAttributes->PasswordProperties        = 0L;
    DomainFixedAttributes->NextRid                   = 1000;
    DomainFixedAttributes->ServerState               = DomainServerEnabled;
    DomainFixedAttributes->ServerRole                = SampServerRole;
    NtQuerySystemTime( &(DomainFixedAttributes->CreationTime) );
    DomainFixedAttributes->ModifiedCount             = ModifiedCount;
    DomainFixedAttributes->MaxPasswordAge            = DomainMaxPasswordAge;
    DomainFixedAttributes->MinPasswordAge            = SampImmediatelyDeltaTime;
    DomainFixedAttributes->ForceLogoff               = SampNeverDeltaTime;
    DomainFixedAttributes->UasCompatibilityRequired  = TRUE;
    DomainFixedAttributes->LockoutDuration.LowPart   = 0xCF1DCC00; // 30 minutes - low part
    DomainFixedAttributes->LockoutDuration.HighPart  = 0XFFFFFFFB; // 30 minutes - high part
    DomainFixedAttributes->LockoutObservationWindow.LowPart  = 0xCF1DCC00; // 30 minutes - low part
    DomainFixedAttributes->LockoutObservationWindow.HighPart = 0XFFFFFFFB; // 30 minutes - high part
    DomainFixedAttributes->LockoutThreshold          = 0;   // Disabled
    DomainFixedAttributes->ModifiedCountAtLastPromotion = ModifiedCount;
    if (PreserveSyskeySettings)
    {
        ASSERT(SampSecretEncryptionEnabled);
        ASSERT(NULL!=SampDefinedDomains);
        ASSERT(SampDefinedDomainsCount>=2);

        DomainFixedAttributes->DomainKeyAuthType
                 = SampDefinedDomains[1].UnmodifiedFixed.DomainKeyAuthType;
        DomainFixedAttributes->DomainKeyFlags =
                   SampDefinedDomains[1].UnmodifiedFixed.DomainKeyFlags|
                     SAMP_DOMAIN_KEY_AUTH_FLAG_UPGRADE ;

        RtlCopyMemory(
          &DomainFixedAttributes->DomainKeyInformation,
          &SampDefinedDomains[1].UnmodifiedFixed.DomainKeyInformation,
          SAMP_DOMAIN_KEY_INFO_LENGTH
          );

        DomainFixedAttributes->CurrentKeyId = 
                   SampDefinedDomains[1].UnmodifiedFixed.CurrentKeyId;
        DomainFixedAttributes->PreviousKeyId =
                   SampDefinedDomains[1].UnmodifiedFixed.PreviousKeyId;

        RtlCopyMemory(
         &DomainFixedAttributes->DomainKeyInformationPrevious,
         &SampDefinedDomains[1].UnmodifiedFixed.DomainKeyInformationPrevious,
         SAMP_DOMAIN_KEY_INFO_LENGTH
         );

    }

    DomainAttributeLength = SampDwordAlignUlong(RtlLengthSid( DomainSid ) ) +
                                ( SAMP_DOMAIN_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);

    DomainVariableAttributeArrayStart = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   RtlAllocateHeap(
                                       RtlProcessHeap(), 0,
                                       DomainAttributeLength
                                       );

    if ( DomainVariableAttributeArrayStart == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create domain variable attributes\n");

    DomainVariableAttributeArray = DomainVariableAttributeArrayStart;

    DomainVariableAttributeArray->Offset = 0;
    DomainVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    DomainVariableAttributeArray->Qualifier = SAMP_REVISION;

    DomainVariableAttributeArray++;

    DomainVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    DomainVariableAttributeArray->Length =
        RtlLengthSid( DomainSid );
    DomainVariableAttributeArray->Qualifier = 0;

    DomainVariableAttributeArray++;

    DomainVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(RtlLengthSid( DomainSid ));
    DomainVariableAttributeArray->Length = 0;
    DomainVariableAttributeArray->Qualifier = 0;

    DomainVariableAttributeArray++;

    DomainVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(RtlLengthSid( DomainSid ));
    DomainVariableAttributeArray->Length = 0;
    DomainVariableAttributeArray->Qualifier = 0;

    DomainVariableData = (PVOID)( (PUCHAR)(DomainVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        DomainVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(DomainVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        DomainSid,
        RtlLengthSid( DomainSid )
        );

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampFixedAttributeName,
                  REG_BINARY,
                  (PVOID)DomainFixedAttributes,
                  sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN ),
                  FIXED_LENGTH_DOMAIN_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampFixedAttributeName,
                 REG_BINARY,
                 (PVOID)DomainFixedAttributes,
                 sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN )
                 );

    SUCCESS_ASSERT(Status, "  Failed to write out domain fixed attributes\n" );
    RtlFreeHeap( RtlProcessHeap(), 0, DomainFixedAttributes );

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampVariableAttributeName,
                  REG_BINARY,
                  (PUCHAR)DomainVariableAttributeArrayStart,
                  sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN ),
                  VARIABLE_LENGTH_ATTRIBUTE_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampVariableAttributeName,
                 REG_BINARY,
                 (PVOID)DomainVariableAttributeArrayStart,
                 DomainAttributeLength
                 );

    RtlFreeHeap( RtlProcessHeap(), 0, DomainVariableAttributeArrayStart );
    SUCCESS_ASSERT(Status, "  Failed to write out domain variable attributes\n" );

    //
    // Create SAM\Domains\(DomainName)\Users
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users" );
    SUCCESS_ASSERT(Status, "  Failed to append to unicode: \\Users\n" );

    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 UserCount,
                 NULL,
                 0
                 );

    SUCCESS_ASSERT(Status, "  Failed to add Users key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Users\Names
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users\\Names" );
    SUCCESS_ASSERT(Status, "  Failed to append to unicode: \\Users\\Names\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Users/Names key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Groups
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups" );
    SUCCESS_ASSERT(Status, "  Failed to append Groups key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 GroupCount,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Groups key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Groups\Names
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups\\Names" );
    SUCCESS_ASSERT(Status, "  Failed to append Groups key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Groups key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Aliases
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases" );
    SUCCESS_ASSERT(Status, "  Failed to append Aliases key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 AliasCount,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add aliases key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Aliases\Names
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\Names" );
    SUCCESS_ASSERT(Status, "  Failed to append Aliases key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Aliases\\Names key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Aliases\Members
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\Members" );
    SUCCESS_ASSERT(Status, "  Failed to append Aliases\\Members key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,             // Domain Count
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Aliases\\Members key to log\n");

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit domain initialization.\n");

    return Status;
}


NTSTATUS
CreateAlias(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN ULONG ProtectionIndex
    )

/*++

Routine Description:

    This routine adds the keys necessary to create an alias.  It also applies
    the appropriate protection to the alias.

Arguments:

    AccountNameU - The Unicode name of the Alias.

    AccountCommentU - A Unicode comment to put in the object's variable data.

    SpecialAccount - A boolean indicating whether or not the account
        is special.  Special accounts are marked as such and can not
        be deleted.

    Rid - The RID of the account.


    Admin - Indicates whether the account is in the Administrators alias
        or not. TRUE means it is, FALSE means it isn't.

Return Value:

    TBS

--*/

{
    PSAMP_V1_FIXED_LENGTH_ALIAS AliasFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AliasVariableAttributeArray;
    PVOID AliasVariableData;
    PSID Sid1 = NULL, Sid2 = NULL;
    PSID AliasMembers = NULL;
    ULONG MemberCount, TotalLength, AliasAttributeLength;
    UNICODE_STRING AliasNameU, AliasCommentU;

    SAMTRACE("CreateAlias");

    AliasNameU = *AccountNameU;
    AliasCommentU = *AccountCommentU;

    //
    // Set the account specific RID in the DACL's if necessary
    //

    if ( SampProtection[ProtectionIndex].RidReplacementRequired == TRUE ) {

        (*SampProtection[ProtectionIndex].RidToReplace) = Rid;
    }

    //
    // Use a transaction.
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to start Alias addition transaction\n");

    //
    // Add Aliases\Names\(AccountName) [ Rid, ]
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\Names\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\aliases\\names to keyname\n");
    Status = RtlAppendUnicodeStringToString( &KeyNameU, &AliasNameU);
    SUCCESS_ASSERT(Status, "  Failed to append Alias account name to\n");
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 Rid,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Aliases\\Names\\(AliasName) to log\n");


    //
    // Set the Members attribute.  We know which accounts are supposed
    // to be members of which aliases, so we'll build the memberships in
    // automatically.
    //
    // Each domain has a list of SIDs that are members of its aliases.
    // We'll update these values at the same time that we set the alias
    // members by calling UpdateAliasXReference().  Currently, that only
    // happens in the builtin domain, where things look like this:
    //
    //    BuiltinDomainSid
    //        AdminUserRid  - Admins alias (WinNt + primary domain)
    //        UserUserRid   - Users alias (WinNt + developer setup),
    //                        Power users alias (WinNt + developer setup)
    //    AccountDomainSid
    //        AdminUserRid  - Admins alias (always)
    //        GuestUserRid  - Guests alias (always)
    //        UserGroupRid  - Users alias, (always)
    //                        Power users alias (WinNt + developer setup)
    //        AdminGroupRid - Admins alias (LanManNt only)
    //

    MemberCount = 0;
    TotalLength = 0;

    switch ( Rid ) {

        case DOMAIN_ALIAS_RID_ADMINS: {

            MemberCount = 1;

            Sid1 = BuildAccountSid( DomainAccount, DOMAIN_USER_RID_ADMIN );
            if ( Sid1 == NULL ) {
                SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, "  Could not allocate Sid\n" );
            }

            if ( SampBldProductType == NtProductLanManNt ) {

                MemberCount = 2;

                Sid2 = BuildAccountSid( DomainAccount, DOMAIN_GROUP_RID_ADMINS );
                if ( Sid2 == NULL ) {
                    SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, "  Could not allocate Sid\n" );
                }
            }

            if ( ( SampBldProductType != NtProductLanManNt ) &&
                 ( SampBldPrimaryDomain != NULL ) ) {

                MemberCount = 2;

                Sid2 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_ADMINS );
                if ( Sid2 == NULL ) {
                    SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                }
            }

            break;
        }

        case DOMAIN_ALIAS_RID_USERS: {

            MemberCount = 0;

            if ( (SampBldProductType == NtProductWinNt)
               || (SampBldProductType == NtProductServer) ) {

                if ( SampBldPrimaryDomain != NULL ) {

                    MemberCount = 1;
                    Sid1 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_USERS );

                    if ( Sid1 == NULL ) {

                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                }

            } else {

                //
                //
                if (SampBldProductType == NtProductLanManNt ) {

                    //
                    // NTAS systems have the USERS global group in
                    // the USERS alias.
                    //

                    MemberCount = 1;
                    Sid1 = BuildAccountSid(
                               DomainAccount,
                               DOMAIN_GROUP_RID_USERS
                               );

                    if ( Sid1 == NULL ) {
                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                } else {

                    //
                    // WinNT systems have the ADMINISTRATOR user account
                    // in the USERS alias.  The None group is NOT in this
                    // alias because even guests are in the None group.
                    //

                    MemberCount = 1;
                    Sid1 = BuildAccountSid(
                               DomainAccount,
                               DOMAIN_USER_RID_ADMIN
                               );

                    if ( Sid1 == NULL ) {
                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                }
            }

            break;
        }

        case DOMAIN_ALIAS_RID_GUESTS: {


            if ( (SampBldProductType == NtProductWinNt)
                || (SampBldProductType == NtProductServer) ) {

                //
                // WinNT system - make our GUEST user account a member of
                //                the GUESTS alias.
                //

                MemberCount = 1;
                Sid1 = BuildAccountSid( DomainAccount, DOMAIN_USER_RID_GUEST );
                if (Sid1 == NULL ) {
                    SUCCESS_ASSERT(STATUS_INSUFFICIENT_RESOURCES, "Could not allocate Sid\n");
                }


                //
                // If we are in a primary domain, then add that domain's
                // GUESTS global group to the alias as well.
                //

                if ( SampBldPrimaryDomain != NULL ) {

                    MemberCount += 1;
                    Sid2 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_GUESTS );
                    if ( Sid2 == NULL ) {
                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                }
            } else {

                //
                // NTAS System - Just make the GUESTS global group
                //               a member of the GUESTS alias.
                //

                MemberCount = 1;
                Sid1 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_GUESTS );
                if ( Sid1 == NULL ) {
                    SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                }
            }


            break;
        }


        case DOMAIN_ALIAS_RID_POWER_USERS:
        case DOMAIN_ALIAS_RID_ACCOUNT_OPS:
        case DOMAIN_ALIAS_RID_SYSTEM_OPS:
        case DOMAIN_ALIAS_RID_PRINT_OPS:
        case DOMAIN_ALIAS_RID_BACKUP_OPS:
        case DOMAIN_ALIAS_RID_REPLICATOR: {

            break;
        }

        default: {

            SUCCESS_ASSERT(STATUS_UNSUCCESSFUL, "  Bad Alias RID\n");
            break;
        }
    };

    if ( MemberCount > 0 ) {

        TotalLength = RtlLengthSid( Sid1 );
        if ( MemberCount == 2 ) {

            TotalLength += RtlLengthSid( Sid2 );
        }

        AliasMembers = RtlAllocateHeap( RtlProcessHeap(), 0, TotalLength );
        if ( AliasMembers == NULL ) {
            SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, "  Could not allocate AliasMembers\n" );
        }

        Status = RtlCopySid( RtlLengthSid( Sid1 ), AliasMembers, Sid1 );
        SUCCESS_ASSERT( Status, "  Couldn't copy Sid1\n" );

        Status = UpdateAliasXReference( Rid, Sid1 );
        SUCCESS_ASSERT( Status, "  Couldn't update alias xref\n" );

        if ( MemberCount == 2 ) {

            Status = RtlCopySid(
                         RtlLengthSid( Sid2 ),
                         (PSID)((PUCHAR)AliasMembers + RtlLengthSid( Sid1 ) ),
                         Sid2 );
            SUCCESS_ASSERT( Status, "  Couldn't copy Sid2\n" );

            Status = UpdateAliasXReference( Rid, Sid2 );
            RtlFreeHeap( RtlProcessHeap(), 0, Sid2 );
            SUCCESS_ASSERT( Status, "  Couldn't update alias xref\n" );
        }

        RtlFreeHeap( RtlProcessHeap(), 0, Sid1 );
    }


    //
    // Set the alias's fixed and variable attributes
    //

    AliasAttributeLength = sizeof( SAMP_V1_FIXED_LENGTH_ALIAS ) +
                                ( SAMP_ALIAS_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
                                SampDwordAlignUlong(AccountNameU->Length) +
                                SampDwordAlignUlong(AccountCommentU->Length) +
                                TotalLength;

    AliasFixedAttributes = (PSAMP_V1_FIXED_LENGTH_ALIAS)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                AliasAttributeLength
                                );

    if ( AliasFixedAttributes == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    SUCCESS_ASSERT(Status, "  Failed to create alias attributes\n");

    AliasFixedAttributes->RelativeId   = Rid;

    AliasVariableAttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   ((PUCHAR)(AliasFixedAttributes) +
                                   sizeof( SAMP_V1_FIXED_LENGTH_ALIAS ) );

    AliasVariableAttributeArray->Offset = 0;
    AliasVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    AliasVariableAttributeArray->Qualifier = SAMP_REVISION;

    AliasVariableAttributeArray++;

    AliasVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    AliasVariableAttributeArray->Length = AliasNameU.Length;
    AliasVariableAttributeArray->Qualifier = 0;

    AliasVariableAttributeArray++;

    AliasVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(AccountNameU->Length);
    AliasVariableAttributeArray->Length = AliasCommentU.Length;
    AliasVariableAttributeArray->Qualifier = 0;

    AliasVariableAttributeArray++;

    AliasVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(AliasNameU.Length) +
        SampDwordAlignUlong(AliasCommentU.Length);
    AliasVariableAttributeArray->Length = TotalLength;
    AliasVariableAttributeArray->Qualifier = MemberCount;

    AliasVariableData = (PVOID)( (PUCHAR)(AliasVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        AliasVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(AliasVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        AccountNameU->Buffer,
        AccountNameU->Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(AliasVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(AliasNameU.Length)),
        AccountCommentU->Buffer,
        AccountCommentU->Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(AliasVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(AliasNameU.Length) +
            SampDwordAlignUlong(AliasCommentU.Length)),
        AliasMembers,
        TotalLength
        );

    if ( AliasMembers != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, AliasMembers );
    }

    //
    // Create Aliases\(AliasRid) [Revision,]  key
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\aliases\\ to keyname\n");

    //
    // Convert the Rid to a Unicode String with leading zero's
    //

    Status = SampRtlConvertUlongToUnicodeString(
                 Rid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    SUCCESS_ASSERT(Status, "  CreateAlias' SampRtlConvertUlongToUnicodeString failed\n");

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampCombinedAttributeName,
                  REG_BINARY,
                  (PVOID)AliasFixedAttributes,
                  AliasAttributeLength,
                  FIXED_LENGTH_ALIAS_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampCombinedAttributeName,
                 REG_BINARY,
                 (PVOID)AliasFixedAttributes,
                 AliasAttributeLength
                 );

    SUCCESS_ASSERT(Status, "  Failed to write out alias attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, AliasFixedAttributes );

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit Alias addition.\n");

    return Status;
    DBG_UNREFERENCED_PARAMETER(SpecialAccount);

}


NTSTATUS
CreateGroup(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN BOOLEAN Admin
    )

/*++

Routine Description:

    This routine adds the keys necessary to create a group.  It also applies
    the appropriate protection to the group.

Arguments:

    AccountNameU - The Unicode name of the group.

    AccountCommentU - A Unicode comment to put in the object's variable data.

    SpecialAccount - A boolean indicating whether or not the account
        is special.  Special accounts are marked as such and can not
        be deleted.

    Rid - The RID of the account.

    Admin - Indicates whether the account is in the Administrators alias
        or not. TRUE means it is, FALSE means it isn't.

Return Value:

    TBS

--*/

{
    PSAMP_V1_0A_FIXED_LENGTH_GROUP GroupFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE GroupVariableAttributeArray;
    PVOID GroupVariableData;

    ULONG Attributes, ProtectionIndex, GroupCount, GroupAttributeLength;
    ULONG GroupMembers[2];

    UNICODE_STRING GroupNameU, GroupCommentU;

    SAMTRACE("CreateGroup");

    GroupNameU = *AccountNameU;
    GroupCommentU = *AccountCommentU;

    Attributes = (SE_GROUP_MANDATORY          |
                  SE_GROUP_ENABLED_BY_DEFAULT |
                  SE_GROUP_ENABLED);

    //
    // Set the correct protection.
    //

    if (Admin == TRUE) {

        ProtectionIndex = SAMP_PROT_ADMIN_GROUP;

    } else {

        ProtectionIndex = SAMP_PROT_NORMAL_GROUP;
    }

    //
    // Set the account specific RID in the DACL's if necessary
    //

    if ( SampProtection[ProtectionIndex].RidReplacementRequired == TRUE ) {

        (*SampProtection[ProtectionIndex].RidToReplace) = Rid;
    }

    //
    // Use a transaction
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to start group addition transaction\n");

    //
    // Add Groups\Names\(GroupName) [ Rid, ]
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups\\Names\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Groups\\Names\n");
    Status = RtlAppendUnicodeStringToString( &KeyNameU, AccountNameU);
    SUCCESS_ASSERT(Status, "  Failed to append AccountName\n");

    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 Rid,
                 NULL,
                 0
                 );

    SUCCESS_ASSERT(Status, "  Failed to add Groups\\Names\\(GroupName) to log\n");

    //
    // Create Groups\(GroupRid) [Revision,]  key
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Groups\\\n");

    Status = SampRtlConvertUlongToUnicodeString(
                 Rid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    SUCCESS_ASSERT(Status, "CreateGroup:  Failed to append Rid Name\n");

    //
    // Set the Members attribute.  The Admin and Guest users are always
    // members of the Users group.  If there is an Admins group, then the
    // Admin user is a member of it.
    //

    GroupCount = 0;
    if ( (Rid == DOMAIN_GROUP_RID_USERS) ||
         (Rid == DOMAIN_GROUP_RID_ADMINS) ) {

        GroupMembers[GroupCount] = DOMAIN_USER_RID_ADMIN;
        GroupCount++;

    }

    //
    // Guests are only members of the Guest group on NTAS systems.
    // On WinNT systems they are members of NONE (which is the sam
    // as USERS
    //

    if ( (Rid == DOMAIN_GROUP_RID_GUESTS)  &&
         (SampBldProductType == NtProductLanManNt) ) {

        GroupMembers[GroupCount] = DOMAIN_USER_RID_GUEST;
        GroupCount++;
    }

    if ( (Rid == DOMAIN_GROUP_RID_USERS)  &&
         ((SampBldProductType == NtProductWinNt)
           || (SampBldProductType == NtProductServer)) ) {

        GroupMembers[GroupCount] = DOMAIN_USER_RID_GUEST;
        GroupCount++;
    }

    //
    // Set the group's fixed and variable attributes
    //

    GroupAttributeLength = sizeof( SAMP_V1_0A_FIXED_LENGTH_GROUP ) +
                                ( SAMP_GROUP_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)
                                + SampDwordAlignUlong(GroupNameU.Length) +
                                SampDwordAlignUlong(GroupCommentU.Length) +
                                ( GroupCount * sizeof( ULONG ) );

    GroupFixedAttributes = (PSAMP_V1_0A_FIXED_LENGTH_GROUP)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                GroupAttributeLength
                                );

    if ( GroupFixedAttributes == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create group attributes\n");

    GroupFixedAttributes->RelativeId   = Rid;
    GroupFixedAttributes->Attributes   = Attributes;
    GroupFixedAttributes->AdminCount   = Admin ? 1 : 0;
    GroupFixedAttributes->OperatorCount = 0;
    GroupFixedAttributes->Revision     = SAMP_REVISION;

    GroupVariableAttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   ((PUCHAR)(GroupFixedAttributes) +
                                   sizeof( SAMP_V1_0A_FIXED_LENGTH_GROUP ) );

    GroupVariableAttributeArray->Offset = 0;
    GroupVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    GroupVariableAttributeArray->Qualifier = SAMP_REVISION;

    GroupVariableAttributeArray++;

    GroupVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    GroupVariableAttributeArray->Length = GroupNameU.Length;
    GroupVariableAttributeArray->Qualifier = 0;

    GroupVariableAttributeArray++;

    GroupVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(GroupNameU.Length);
    GroupVariableAttributeArray->Length = GroupCommentU.Length;
    GroupVariableAttributeArray->Qualifier = 0;

    GroupVariableAttributeArray++;

    GroupVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(GroupNameU.Length) +
        SampDwordAlignUlong(GroupCommentU.Length);
    GroupVariableAttributeArray->Length = GroupCount * sizeof( ULONG );
    GroupVariableAttributeArray->Qualifier = GroupCount;

    GroupVariableData = (PVOID)( (PUCHAR)(GroupVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        GroupVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(GroupVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        GroupNameU.Buffer,
        GroupNameU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(GroupVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(GroupNameU.Length)),
        GroupCommentU.Buffer,
        GroupCommentU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(GroupVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(GroupNameU.Length) +
            SampDwordAlignUlong(GroupCommentU.Length)),
        GroupMembers,
        GroupCount * sizeof( ULONG )
        );

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampCombinedAttributeName,
                  REG_BINARY,
                  (PVOID)GroupFixedAttributes,
                  GroupAttributeLength,
                  FIXED_LENGTH_GROUP_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampCombinedAttributeName,
                 REG_BINARY,
                 (PVOID)GroupFixedAttributes,
                 GroupAttributeLength
                 );
    SUCCESS_ASSERT(Status, "  Failed to write out group attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, GroupFixedAttributes );

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit group addition.\n");

    return Status;
    DBG_UNREFERENCED_PARAMETER(SpecialAccount);
}


NTSTATUS
CreateUser(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG UserRid,
    IN ULONG PrimaryGroup,
    IN BOOLEAN Admin,
    IN ULONG  UserControl,
    IN ULONG ProtectionIndex
    )

/*++


Routine Description:

    This routine adds keys for a single user.
    This routine adds the keys necessary to create a user.  It also applies
    the appropriate protection to the user (protection differs for some
    standard users).


Arguments:

    AccountNameU - The Unicode name of the user.

    AccountCommentU - A Unicode comment to put in the object's variable data.

    SpecialAccount - A boolean indicating whether or not the account
        is special.  Special accounts are marked as such and can not
        be deleted.

    UserRid - The RID of the user account.

    PrimaryGroup - The RID of the account's primary group.  The user
        does not have to be a member of the group.  In fact, it doesn't
        have to be a group.  In fact, no checking is done to see if it
        is even a valid account.

    Admin - Indicates whether the account is in the Administrators alias
        or not. TRUE means it is, FALSE means it isn't.

    ProtectionIndex - Indicates which security descriptor to use to protect
        this object.


Return Value:

    TBS

--*/

{
    PSAMP_V1_0A_FIXED_LENGTH_USER UserFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE UserVariableAttributeArray;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE UserVariableAttributeArrayStart;
    PVOID UserVariableData;
    GROUP_MEMBERSHIP GroupMembership[2];

    WCHAR RidNameBuffer[9], GroupIndexNameBuffer[9];
    ULONG GroupCount, UserAttributeLength;

    // SAM BUG 42367 FIX - ChrisMay 7/1/96.

    BOOLEAN DomainAdminMember = FALSE;

    UNICODE_STRING UserNameU, UserCommentU;

    SAMTRACE("CreateUser");

    UserNameU = *AccountNameU;
    UserCommentU = *AccountCommentU;


    //
    // Set the account specific RID in the DACL's if necessary
    //

    if ( SampProtection[ProtectionIndex].RidReplacementRequired == TRUE ) {

        (*SampProtection[ProtectionIndex].RidToReplace) = UserRid;
    }

    //
    // Use a transaction.
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to start user addition transaction\n");

    RidNameBuffer[8] = 0;
    GroupIndexNameBuffer[8] = 0;

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users\\Names\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Users\\Names\\\n");
    Status = RtlAppendUnicodeStringToString( &KeyNameU, &UserNameU);
    SUCCESS_ASSERT(Status, "  Failed to append User Account Name\n");
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 UserRid,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Users\\Names\\(Name) to log\n");

    //
    // Create Users\(UserRid)  key
    // (KeyValueType is revision, KeyValue is SecurityDescriptor)
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Users\\\n");

    Status = SampRtlConvertUlongToUnicodeString(
                 UserRid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    SUCCESS_ASSERT(Status, "  CreateUser: Failed to append UserRid Name\n");

    //
    // Set the Groups attribute.
    // Everybody except GUEST is a member of the Users group.
    // On WindowsNT systems (as opposed to NTAS systems) even GUEST
    // is a member of the Users group.
    // On LanManNt systems, the Admin is a member of the Admins group.
    //

    GroupCount = 0;

    if ( (UserRid != DOMAIN_USER_RID_GUEST) ||
         (SampBldProductType != NtProductLanManNt)      ) {

        GroupMembership[GroupCount].RelativeId = DOMAIN_GROUP_RID_USERS;
        GroupMembership[GroupCount].Attributes = SE_GROUP_MANDATORY          |
                                                 SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED;
        GroupCount++;
    }

    if ( (UserRid == DOMAIN_USER_RID_GUEST) &&
         (SampBldProductType == NtProductLanManNt)      ) {

        GroupMembership[GroupCount].RelativeId = DOMAIN_GROUP_RID_GUESTS;
        GroupMembership[GroupCount].Attributes = SE_GROUP_MANDATORY          |
                                                 SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED;
        GroupCount++;
    }


    if ( ( UserRid == DOMAIN_USER_RID_ADMIN ) &&
        ( SampBldProductType == NtProductLanManNt ) ) {

        GroupMembership[GroupCount].RelativeId = DOMAIN_GROUP_RID_ADMINS;
        GroupMembership[GroupCount].Attributes = SE_GROUP_MANDATORY          |
                                                 SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED;
        GroupCount++;

        // SAM BUG 42367 FIX - ChrisMay 7/1/96.

        DomainAdminMember = TRUE;
    }

    //
    // Set the user's fixed and variable attributes
    //

    UserFixedAttributes = (PSAMP_V1_0A_FIXED_LENGTH_USER)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                sizeof( SAMP_V1_0A_FIXED_LENGTH_USER )
                                );

    if ( UserFixedAttributes == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create user fixed attributes\n");

    UserFixedAttributes->Revision            = SAMP_REVISION;

    UserFixedAttributes->CountryCode         = 0;
    UserFixedAttributes->CodePage            = 0;
    UserFixedAttributes->BadPasswordCount    = 0;
    UserFixedAttributes->LogonCount          = 0;
    UserFixedAttributes->OperatorCount       = 0;
    UserFixedAttributes->Unused1             = 0;
    UserFixedAttributes->Unused2             = 0;

    if ( Admin ) {

        // SAM BUG 42367 FIX - ChrisMay 7/1/96.

        // UserFixedAttributes->AdminCount      = 1;

        // If the user is an admin and a member of Domain Admins, set the
        // count to two.

        if (DomainAdminMember)
        {
            UserFixedAttributes->AdminCount  = 2;
        }
        else
        {
            UserFixedAttributes->AdminCount  = 1;
        }

    } else {

        UserFixedAttributes->AdminCount      = 0;
    }

    UserFixedAttributes->UserAccountControl  = UserControl;
    UserFixedAttributes->UserId              = UserRid;
    UserFixedAttributes->PrimaryGroupId      = PrimaryGroup;
    UserFixedAttributes->LastLogon           = SampHasNeverTime;
    UserFixedAttributes->LastLogoff          = SampHasNeverTime;
    UserFixedAttributes->PasswordLastSet     = SampHasNeverTime;
    UserFixedAttributes->AccountExpires      = SampWillNeverTime;
    UserFixedAttributes->LastBadPasswordTime = SampHasNeverTime;


    UserAttributeLength =  SampDwordAlignUlong(UserNameU.Length) +
                                SampDwordAlignUlong(UserCommentU.Length) +
                                SampDwordAlignUlong( GroupCount *
                                sizeof( GROUP_MEMBERSHIP ) ) +
                                ( SAMP_USER_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);

    UserVariableAttributeArrayStart = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   RtlAllocateHeap(
                                       RtlProcessHeap(), 0,
                                       UserAttributeLength
                                       );

    if ( UserVariableAttributeArrayStart == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    SUCCESS_ASSERT(Status, "  Failed to create user variable attributes\n");

    UserVariableAttributeArray = UserVariableAttributeArrayStart;

    UserVariableAttributeArray->Offset = 0;
    UserVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    UserVariableAttributeArray->Qualifier = SAMP_REVISION;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    UserVariableAttributeArray->Length = UserNameU.Length;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length);
    UserVariableAttributeArray->Length = UserCommentU.Length;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = GroupCount * sizeof( GROUP_MEMBERSHIP );
    UserVariableAttributeArray->Qualifier = GroupCount;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableData = (PVOID)( (PUCHAR)(UserVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        UserVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(UserVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        UserNameU.Buffer,
        UserNameU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(UserVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(UserNameU.Length)),
        UserCommentU.Buffer,
        UserCommentU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(UserVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(UserNameU.Length) +
            SampDwordAlignUlong(UserCommentU.Length)),
        &GroupMembership,
        GroupCount * sizeof( GROUP_MEMBERSHIP )
        );

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampFixedAttributeName,
                  REG_BINARY,
                  (PVOID)UserFixedAttributes,
                  sizeof( SAMP_V1_0A_FIXED_LENGTH_USER ),
                  FIXED_LENGTH_USER_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampFixedAttributeName,
                 REG_BINARY,
                 (PVOID)UserFixedAttributes,
                 sizeof( SAMP_V1_0A_FIXED_LENGTH_USER )
                 );
    SUCCESS_ASSERT(Status, "  Failed to write out user fixed attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, UserFixedAttributes );

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampVariableAttributeName,
                  REG_BINARY,
                  (PVOID)UserVariableAttributeArrayStart,
                  UserAttributeLength,
                  VARIABLE_LENGTH_ATTRIBUTE_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampVariableAttributeName,
                 REG_BINARY,
                 (PVOID)UserVariableAttributeArrayStart,
                 UserAttributeLength
                 );
    SUCCESS_ASSERT(Status, "  Failed to write out user variable attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, UserVariableAttributeArrayStart );

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit user addition.\n");

    return Status;

    DBG_UNREFERENCED_PARAMETER(SpecialAccount);
    DBG_UNREFERENCED_PARAMETER(UserControl);
}



PSID
BuildPrimaryDomainSid(
    ULONG Rid
    )
{
    NTSTATUS Status;
    PSID SourceDomainSid, NewSid;
    ULONG SidLength, SubAuthorityCount;

    SourceDomainSid = SampBldPrimaryDomain->Sid;

    SidLength = RtlLengthSid( SourceDomainSid ) + sizeof(ULONG);
    NewSid = RtlAllocateHeap( RtlProcessHeap(), 0, SidLength );
    if (NewSid != NULL) {

        Status = RtlCopySid (SidLength, NewSid, SourceDomainSid );
        ASSERT(NT_SUCCESS(Status));

        (*RtlSubAuthorityCountSid( NewSid )) += 1;
        SubAuthorityCount = (ULONG)(*RtlSubAuthorityCountSid( NewSid ));
        (*RtlSubAuthoritySid( NewSid, SubAuthorityCount-1)) = Rid;

    }


    return(NewSid);


}




PSID
BuildAccountSid(
    SAMP_DOMAIN_SELECTOR Domain,
    ULONG Rid
    )
{
    NTSTATUS Status;
    PSID SourceDomainSid, NewSid;
    ULONG SidLength, SubAuthorityCount;


    if (Domain == DomainBuiltin) {
        SourceDomainSid = SampBuiltinDomainSid;
    } else {
        SourceDomainSid = SampAccountDomainSid;
    }

    SidLength = RtlLengthSid( SourceDomainSid ) + sizeof(ULONG);
    NewSid = RtlAllocateHeap( RtlProcessHeap(), 0, SidLength );
    if (NewSid != NULL) {

        Status = RtlCopySid (SidLength, NewSid, SourceDomainSid );
        ASSERT(NT_SUCCESS(Status));

        (*RtlSubAuthorityCountSid( NewSid )) += 1;
        SubAuthorityCount = (ULONG)(*RtlSubAuthorityCountSid( NewSid ));
        (*RtlSubAuthoritySid( NewSid, SubAuthorityCount-1)) = Rid;

    }


    return(NewSid);


}



NTSTATUS
UpdateAliasXReference(
    IN ULONG AliasRid,
    IN PSID Sid
    )

/*++


Routine Description:

    This routine updates the set of alias member SIDs either by adding
    specified SID (if it isn't already an alias member) or incrementing
    its count (if it is already an alias member).


    The BUILTIN domain is updated.



Arguments:


    Sid - member Sid to update.




Return Value:

    TBS

--*/

{
    NTSTATUS                IgnoreStatus;

    HANDLE                  KeyHandle;

    SAMTRACE("UpdateAliasXReference");



    if (RtlSubAuthorityCountSid( Sid ) == 0) {
        return(STATUS_INVALID_SID);
    }


    //
    // Open the domain key for this alias member.
    //

    SetCurrentDomain( DomainBuiltin );
    Status = OpenAliasMember( Sid, &KeyHandle );


    if (NT_SUCCESS(Status)) {

        ULONG                   MembershipCount,
                                KeyValueLength,
                                OldKeyValueLength,
                                i;
        PULONG                  MembershipArray;

        //
        // Retrieve the length of the current membership buffer
        // and allocate one large enough for that plus another member.
        //

        KeyValueLength = 0;
        Status = RtlpNtQueryValueKey( KeyHandle,
                                      &MembershipCount,
                                      NULL,
                                      &KeyValueLength,
                                      NULL);

        SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                    NULL,
                                    &KeyValueLength,
                                    NULL);

        if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW)) {

            KeyValueLength +=  sizeof(ULONG);
            MembershipArray = RtlAllocateHeap( RtlProcessHeap(), 0, KeyValueLength );


            if (MembershipArray == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                OldKeyValueLength = KeyValueLength;
                Status = RtlpNtQueryValueKey(
                               KeyHandle,
                               NULL,
                               MembershipArray,
                               &OldKeyValueLength,
                               NULL);

                SampDumpRtlpNtQueryValueKey(NULL,
                                            MembershipArray,
                                            &OldKeyValueLength,
                                            NULL);

                if (NT_SUCCESS(Status)) {

                    //
                    // See if the account is already a member ...
                    //

                    for (i = 0; i<MembershipCount ; i++ ) {
                        if ( MembershipArray[i] == AliasRid )
                        {
                            Status = STATUS_MEMBER_IN_ALIAS;
                        }
                    }

                    if (NT_SUCCESS(Status)) {

                        //
                        // Add the Aliasrid to the end
                        //

                        MembershipCount += 1;
                        MembershipArray[MembershipCount-1] = AliasRid;

                        //
                        // And write it out.
                        //

                        Status = RtlpNtSetValueKey(
                                       KeyHandle,
                                       MembershipCount,
                                       MembershipArray,
                                       KeyValueLength
                                       );

                        SampDumpRtlpNtSetValueKey(MembershipCount,
                                                  MembershipArray,
                                                  KeyValueLength);
                    }
                }

                RtlFreeHeap(RtlProcessHeap(), 0, MembershipArray);
            }

        }

        IgnoreStatus = NtClose( KeyHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

    }



    return( Status );

}


NTSTATUS
OpenAliasMember(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This routine opens the registry key containing the alias
    xreference for the specified SID.  If either this key, or
    its corresponding parent key doesn't exist, it (they) will
    be created.

    If a new domain-level key is created, the DomainCount in the
    ALIASES\MEMBERS key is incremented as well.


Arguments:

    Sid - The SID that is an alias member.

    KeyHandle - Receives a handle to the registry key for this alias
        member account xreference.

Return Value:

    None.

--*/

{

    NTSTATUS IgnoreStatus;
    HANDLE AliasDomainHandle;

    SAMTRACE("OpenAliasMember");

    //
    // Open or create the domain-level key.
    //


    Status = OpenOrCreateAliasDomainKey( Sid, &AliasDomainHandle );

    if (NT_SUCCESS(Status)) {


        //
        // Open or create the account-rid key
        //

        Status = OpenOrCreateAccountRidKey( Sid,
                                            AliasDomainHandle,
                                            KeyHandle
                                            );

        IgnoreStatus = NtClose( AliasDomainHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(Status);


}



NTSTATUS
OpenOrCreateAccountRidKey(
    IN PSID Sid,
    IN HANDLE AliasDomainHandle,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This routine opens an account xreference key for an alias
    member SID.

    If this key doesn't exist, it will be created.

    If a new key is created, the RidCount in the AliasDomainHandle
    key is incremented as well.


Arguments:

    Sid - The SID that is an alias member.

    AliasDomainHandle

    KeyHandle - Receives a handle to the registry key for this alias
        member domain xreference.

Return Value:

    None.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    ULONG Rid;

    SAMTRACE("OpenOrCreateAccountRidKey");

    if (RtlSubAuthorityCountSid( Sid ) == 0) {
        return(STATUS_INVALID_SID);
    }

    Rid = (*RtlSubAuthoritySid(Sid, (ULONG)(*RtlSubAuthorityCountSid(Sid))-1));

    //
    // Build the Unicode Key for this Rid.
    //

    KeyNameU.Length = (USHORT) 0;

    Status = SampRtlConvertUlongToUnicodeString(
                 Rid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    //
    // Open this key relative to the alias domain key
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyNameU,
        OBJ_CASE_INSENSITIVE,
        AliasDomainHandle,
        NULL
        );
    Status = RtlpNtCreateKey(
                 KeyHandle,
                 (KEY_READ | KEY_WRITE),
                 &ObjectAttributes,
                 0,                 //Options
                 NULL,              //Provider
                 &Disposition
                 );

    if (NT_SUCCESS(Status)) {

        if (Disposition == REG_CREATED_NEW_KEY) {

            //
            // Update the AccountRid count in the alias domain key
            //

            ULONG                    MembershipCount;


            //
            // Retrieve the current domain count and increment it by 1.
            //

            Status = RtlpNtQueryValueKey( AliasDomainHandle,
                                          &MembershipCount,
                                          NULL,
                                          NULL,
                                          NULL);

            SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                        NULL,
                                        NULL,
                                        NULL);

            if (NT_SUCCESS(Status)) {

                MembershipCount += 1;

                //
                // Write it back out.
                //

                Status = RtlpNtSetValueKey(
                               AliasDomainHandle,
                               MembershipCount,
                               NULL,
                               0
                               );

                SampDumpRtlpNtSetValueKey(MembershipCount,
                                          NULL,
                                          0);
            }

            //
            // Now write out the AccountRid key info
            //

            Status = RtlpNtSetValueKey(
                         *KeyHandle,
                         0,                 //Not yet a member of any aliases
                         NULL,
                         0
                         );

            SampDumpRtlpNtSetValueKey(0,
                                      NULL,
                                      0);
        }
    }

    return(Status);
}



NTSTATUS
OpenOrCreateAliasDomainKey(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This routine opens a domain xreference key for an alias
    member SID.

    If this key doesn't exist, it will be created.

    If a new key is created, the DomainCount in the
    ALIASES\MEMBERS key is incremented as well.


Arguments:

    Sid - The SID that is an alias member.

    KeyHandle - Receives a handle to the registry key for this alias
        member domain xreference.

Return Value:

    None.

--*/

{
    NTSTATUS IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;

    SAMTRACE("OpenOrCreateAliasDomainKey");

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases" );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Members\\" );
    Status = AppendAliasDomainNameToUnicodeString( &KeyNameU, Sid );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyNameU,
        OBJ_CASE_INSENSITIVE,
        SamKey,
        NULL
        );
    Status = RtlpNtCreateKey(
                 KeyHandle,
                 (KEY_READ | KEY_WRITE),
                 &ObjectAttributes,
                 0,                 //Options
                 NULL,              //Provider
                 &Disposition
                 );

    if (NT_SUCCESS(Status)) {

        if (Disposition == REG_CREATED_NEW_KEY) {

            HANDLE TmpHandle;

            //
            // Update the Domain count
            //

            RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
            Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases" );
            Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Members\\" );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyNameU,
                OBJ_CASE_INSENSITIVE,
                SamKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

            Status = RtlpNtOpenKey(
                           &TmpHandle,
                           (KEY_READ | KEY_WRITE),
                           &ObjectAttributes,
                           0
                           );
            ASSERT(NT_SUCCESS(Status));

            if (NT_SUCCESS(Status)) {

                ULONG                    MembershipCount;


                //
                // Retrieve the current domain count and increment it by 1.
                //

                Status = RtlpNtQueryValueKey( TmpHandle,
                                              &MembershipCount,
                                              NULL,
                                              NULL,
                                              NULL);

                SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                            NULL,
                                            NULL,
                                            NULL);

                if (NT_SUCCESS(Status)) {

                    MembershipCount += 1;

                    //
                    // Write it back out.
                    //

                    Status = RtlpNtSetValueKey(
                                   TmpHandle,
                                   MembershipCount,
                                   NULL,
                                   0
                                   );

                    SampDumpRtlpNtSetValueKey(MembershipCount,
                                              NULL,
                                              0);
                }

                IgnoreStatus = NtClose( TmpHandle );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            }
        }
    }

    return(Status);
}


NTSTATUS
AppendAliasDomainNameToUnicodeString(
    IN OUT PUNICODE_STRING Destination,
    IN PSID Sid
    )

{
    UCHAR OriginalCount;

    SAMTRACE("AppendAliasDomainNameToUnicodeString");

    //
    // Save the current sub-authority count and decrement it by one.
    //

    OriginalCount = (*RtlSubAuthorityCountSid(Sid));
    (*RtlSubAuthorityCountSid(Sid)) = OriginalCount -1;

    //
    // Convert the Sid to a Unicode String and place it in the global
    // temporary Unicode String buffer.
    //

    Status = RtlConvertSidToUnicodeString( &TempStringU, Sid, TRUE);

    (*RtlSubAuthorityCountSid(Sid)) = OriginalCount;

    if (NT_SUCCESS(Status)) {

        Status = RtlAppendUnicodeStringToString( Destination, &TempStringU );
    }

    return(Status);
}



VOID
SampGetServerRole(
    VOID
    )

/*++

Routine Description:

    This routine retrieves the server role from the LSA policy database
    and places it in the global variable SampServerRole.

Arguments:

    None.


Return Value:

    (placed in the global variable (Status) )

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

        LsarQueryInformationPolicy()
--*/

{
    NTSTATUS IgnoreStatus;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo = NULL;

    SAMTRACE("SampGetServerRole");

    //
    // Query the server role information
    //

    Status = LsarQueryInformationPolicy(
                 SampBldPolicyHandle,
                 PolicyLsaServerRoleInformation,
                 (PLSAPR_POLICY_INFORMATION *)&ServerRoleInfo
                 );

    if (NT_SUCCESS(Status)) {

        if (ServerRoleInfo->LsaServerRole == PolicyServerRolePrimary) {

            SampServerRole = DomainServerRolePrimary;

        } else {

            SampServerRole = DomainServerRoleBackup;
        }

        IgnoreStatus = LsaFreeMemory( ServerRoleInfo );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return;
}




VOID
SampGetPrimaryDomainInfo(
    IN PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the primary domain name/sid from the
    LSA policy database and places it in the global variable
    SampBldPrimaryDomain.


Arguments:

    None.


Return Value:

    (placed in the global variable (Status) )

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

        LsarQueryInformationPolicy()

    NOTE:  The Rdr and Bowser components of the LanmanWorkstation
           service rely on there always being a primary domain name.
           For this reason Network SETUP always supplies a default
           "workgroup" name, which is set as the primary domain name.
           In this case, the name is present but the SID is NULL;
           this is equivalent to NOT having a primary domain at all.

--*/

{
    SAMTRACE("SampGetPrimaryDomainInfo");

    SampBldPrimaryDomain = NULL;

    if (!ARGUMENT_PRESENT(PrimaryDomainInfo)) {
        Status = LsarQueryInformationPolicy(
                     SampBldPolicyHandle,
                     PolicyPrimaryDomainInformation,
                     (PLSAPR_POLICY_INFORMATION *) &SampBldPrimaryDomain
                     );
    } else {

        SampBldPrimaryDomain = PrimaryDomainInfo;
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status) && ( SampBldPrimaryDomain->Sid == NULL )) {

        if (!ARGUMENT_PRESENT(PrimaryDomainInfo)) {

            LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyPrimaryDomainInformation,
                (PLSAPR_POLICY_INFORMATION) SampBldPrimaryDomain
                );

        }

        SampBldPrimaryDomain = NULL;
    }

    return;
}


NTSTATUS
SampDetermineSetupEnvironment( VOID )


/*++

Routine Description:

    This function checks to see whether we are running folloing
    a formal SETUP.  If not, it is assumed we are running to
    perform a developer's setup.

    Global variables are set to indicate our setup environment.


        BOOLEAN SampRealSetupWasRun;   //Indicates a real setup was run
        BOOLEAN SampDeveloperSetup;    //Indicates a developer setup is running


Arguments:

    None.

Return Value:


--*/

{
    NTSTATUS NtStatus, TmpStatus;
    HANDLE InstallationEvent;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventName;

    SAMTRACE("SampDetermineSetupEnvironment");

    SampRealSetupWasRun = FALSE;
    SampDeveloperSetup = FALSE;

    //
    // If the following event exists, it is an indication that
    // a real setup was run.
    //

    RtlInitUnicodeString( &EventName, L"\\INSTALLATION_SECURITY_HOLD");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    NtStatus = NtOpenEvent(
                   &InstallationEvent,
                   SYNCHRONIZE,
                   &EventAttributes
                   );

    if ( NT_SUCCESS(NtStatus)) {

        //
        // The event exists - installation created it and will signal it
        // when it is ok to proceed with security initialization.
        //

        SampRealSetupWasRun = TRUE;

        TmpStatus = NtClose( InstallationEvent );
        ASSERT(NT_SUCCESS(TmpStatus));

    } else {
        SampDeveloperSetup = TRUE;
    }



    return(NtStatus);

}



NTSTATUS
SampInitializeRegistry (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL,
    BOOLEAN                     PreserveSyskeySettings
    )
/*++

Routine Description:

    This routine initializes a SAM database in the registry.

Arguments:

    NONE

Return Value:

    STATUS_SUCCESS or an error received along the way.

--*/

{
    NTSTATUS IgnoreStatus;

    SAMTRACE("SampInitializeRegistry");

    Status = Initialize(SamParentKeyName,
                        ProductType,
                        ServerRole,
                        AccountDomainInfo,
                        PrimaryDomainInfo);

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    //
    // Initialize SAM-level registry structures
    //

    Status = InitializeSam( );
    if (!NT_SUCCESS(Status)) {return(Status);}

    //
    // OK, we have a SAM key.
    // Create each of the domains.
    //

    Status = CreateBuiltinDomain( );  if (!NT_SUCCESS(Status)) {return(Status);}
    Status = CreateAccountDomain(PreserveSyskeySettings);  if (!NT_SUCCESS(Status)) {return(Status);}

    //
    // all done
    //

    //
    // Close our handle to LSA.  Ignore any errors.
    //

    IgnoreStatus = LsarClose( (PLSAPR_HANDLE) &SampBldPolicyHandle );
    SampBldPolicyHandle = NULL;


    //
    // Free up the transaction context we created
    //

    RtlFreeHeap( RtlProcessHeap(), 0, SamRXactContext );
    SamRXactContext = NULL;

    //
    // Close the database root key after flushing all the changes we made.
    //

    Status = NtFlushKey( SamKey );

    if (NT_SUCCESS(Status)) {

        IgnoreStatus = NtClose( SamKey );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSRV:  FlushKey failed, database not built.  Status: 0x%lx\n",
                   Status));

        IgnoreStatus = NtClose( SamKey );
    }

    SamKey = NULL;

    //
    // Close the database root parent key
    //

    if (SamParentKey != NULL) {
        IgnoreStatus = NtClose( SamParentKey );
    }

    return( Status );
}


NTSTATUS
SampGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    )


/*++

Routine Description:

    This gets 1 or 2 message strings values from a resource message table.
    The string buffers are allocated and the strings initialized properly.

    The string buffers must be freed using LocalFree() when no longer needed.

Arguments:

    Resource - points to the resource table.

    Index1 - Index of first message to retrieve.

    String1 - Points to a UNICODE_STRING structure to receive the first
        message string.

    Index2 - Index of second message to retrieve.

    String2 - Points to a UNICODE_STRING structure to receive the first
        message string.  If this parameter is NULL, then only one message
        string is retrieved.

Return Value:

    None.

--*/


{

    SAMTRACE("SampGetMessageStrings");

    String1->Buffer    = NULL;

    String1->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index1,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String1->Buffer),
                                          0,
                                          NULL
                                          );

    if (String1->Buffer == NULL) {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  Also note that FormatMessage() returns a character
        // count, not a byte count.  So, we have to do some adjusting
        // to make the string lengths correct.
        //

        String1->MaximumLength -=  2; // For the cr/lf we don't want.
        String1->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String1->Length = String1->MaximumLength;
    }


    if (!ARGUMENT_PRESENT(String2)) {
        return(STATUS_SUCCESS);
    }

    String2->Buffer = NULL;
    String2->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index2,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String2->Buffer),
                                          0,
                                          NULL
                                          );

    if (String2->Buffer == NULL) {
        LocalFree( String1->Buffer );
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  Also note that FormatMessage() returns a character
        // count, not a byte count.  So, we have to do some adjusting
        // to make the string lengths correct.
        //

        String2->MaximumLength -=  2; // For the cr/lf we don't want.
        String2->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String2->Length = String2->MaximumLength;
    }



    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dbgutil.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dbgutil.c

Abstract:

    This file contains supplimental debugging and diagnostic routines for SAM.


Author:

    Chris Mayhall (ChrisMay) 04-Apr-1996

Environment:

    User Mode - Win32

Revision History:

    04-Apr-1996 ChrisMay
        Created.
    08-Apr-1996 ChrisMay
        Added enumeration routines.
    15-Apr-1996 ChrisMay
        Added query routines.
    03-Dec-1996 ChrisMay
        Documented how to use trace tags and added global for filtered KD
        output.

--*/

//
// Includes
//

#include <samsrvp.h>

#if DBG

//
// Constants
//

#define DBG_BUFFER_SIZE                     512


//
// Private Helper Routines
//

// Trace table contains the set of flags (masks) that SampTraceFileTags can
// be set to, in order to control the debug verbosity during a call trace.
// To use this facility, the value of SampTraceTags is set to 2 (SAMP_TRACE-
// FILE_BASIS), from the debugger, and SampTraceFileTags is set to one or more
// of the following values depending on which files you want to trace:

TRACE_TABLE_ENTRY TraceTable[] =
{

    {"alias.c",    0x00000001},
    {"almember.c", 0x00000002},
    {"attr.c",     0x00000004},
    {"bldsam3.c",  0x00000008},
    {"close.c",    0x00000010},
    {"context.c",  0x00000020},
    {"dbgutil.c",  0x00000040},
    {"display.c",  0x00000080},
    {"domain.c",   0x00000100},
    {"dslayer.c",  0x00000200},
    {"dsmember.c", 0x00000400},
    {"dsutil.c",   0x00000800},
    {"enum.c",     0x00001000},
    {"gentab2.c",  0x00002000},
    {"global.c",   0x00004000},
    {"group.c",    0x00008000},
    {"notify.c",   0x00010000},
    {"oldstub.c",  0x00020000},
    {"rundown.c",  0x00040000},
    {"samifree.c", 0x00080000},
    {"samrpc_s.c", 0x00100000},
    {"samss.c",    0x00200000},
    {"secdescr.c", 0x00400000},
    {"security.c", 0x00800000},
    {"server.c",   0x01000000},
    {"string.c",   0x02000000},
    {"upgrade.c",  0x04000000},
    {"user.c",     0x08000000},
    {"utility.c",  0x10000000}
};

//
// Tick Stack. This is a stack of tick counts, used to time
// calls when SamTraceTicks is enabled. Define variables and
// macros 
//

#define MAX_TICK_STACK_SIZE     32
ULONG   TickStack[MAX_TICK_STACK_SIZE];
int     TickStackPointer=0;

#define PUSH_TICK_STACK(x)\
        {\
           TickStack[TickStackPointer++]=x;\
           if (TickStackPointer>=MAX_TICK_STACK_SIZE)\
           {\
                TickStackPointer = MAX_TICK_STACK_SIZE-1;\
           }\
        }

#define POP_TICK_STACK()    (TickStack[(TickStackPointer>0)?(--TickStackPointer):0])


LPSTR
GetBaseFileName(
    LPSTR   FileName
    )
/*

  Routine Description:

    This routine removes the path components from the filename

  Arguments:

    FileName - Full File Name

  Return Values

    LPSTR giving just the base file name

*/
{
    LPSTR BaseFileName = FileName;

    if (NULL!=FileName)
    {
        while(0!=*FileName)
        {
            if ('\\'==*FileName)
                BaseFileName= FileName +1;
            FileName ++;
        }
    }

    return BaseFileName;
}


BOOLEAN
SamIsTraceEnabled(
    IN LPSTR FileName,
    IN ULONG TraceLevel
    )
/*

  Routine Description:

    This routine checks wether tracing is enabled
    on a per file name basis.

        This routine uses the Global variable SamTraceLevel
        to check wether or not Tracing is enabled. The Trace
        Table defines the bit that is used to check for tracing
        on that file.

  Parameters:

     FileName -- The filename to check wether tracing is
                 enabled.

     Trace level -- Trace level with which trace was requested

  Return Values

    TRUE - Tracing is enabled
    FALSE - Tracing is disabled
*/
{
    ULONG Index;
    BOOLEAN RetValue = FALSE;
    LPSTR   BaseFileName;


    if ( TraceLevel & SampTraceTag & (~SAM_TRACE_FILE_BASIS))
    {
        //
        // Non file based tracing succeeds
        //

        RetValue = TRUE;
    }
    else if ( TraceLevel & SampTraceTag & SAM_TRACE_FILE_BASIS )
    {

        //
        // Use the Trace Flag to find out if all functions need to br
        // Traced
        //

	BaseFileName = GetBaseFileName(FileName);

        for (Index=0;Index<ARRAY_COUNT(TraceTable);Index++)
        {
            if ((NULL != BaseFileName) && 
                (0==(_stricmp(BaseFileName,TraceTable[Index].FileName))))
            {
                //
                // We have met match
                //

                if (SampTraceFileTag & (TraceTable[Index].TraceBit))
                {
                    //
                    // Tracing is enabled
                    //

                    RetValue = TRUE;
                }
            }
        }
    }

    return RetValue;
}

//
// The following are the tracing routines. Each routine checks whether 
// tracing is enabled and then calls a worker routine ( named xxxActual)
// that will do the actual debug output. This is so that no stack space is
// allocated for the debug buffer when no tracing is enabled. 
//


VOID
SamIDebugOutputActual(
    IN LPSTR FileName,
    IN LPSTR DebugMessage,
    IN ULONG TraceLevel
    )

/*++

Routine Description:

    This routine displays a message on the debugger.
    The File Name paramter is used to check wether tracing
    id enabled for the given File.

Parameters:

    FileName - Pointer to the name of the file
    DebugMessage - Pointer to the message string.
    TraceLevel   - Trace level at which trace needs to emerge

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE, "[SAMSS] %-30s", DebugMessage);
    OutputDebugStringA(Buffer);

    if (SampTraceTag & SAM_TRACE_TICKS)
    {
        //
        // Control what may be measuerd
        //

        if (TraceLevel & (SAM_TRACE_DS | SAM_TRACE_EXPORTS))
        {
            ULONG   CurrentTick = GetTickCount();

            PUSH_TICK_STACK(CurrentTick);
        }
    }
        
}


VOID
SamIDebugOutput(
    IN LPSTR FileName,
    IN LPSTR DebugMessage,
    IN ULONG TraceLevel
    )

{
    if (SamIsTraceEnabled(FileName, TraceLevel))
    {
        SamIDebugOutputActual(
            FileName,
            DebugMessage,
            TraceLevel
            );
    }
}



VOID
SamIDebugFileLineOutputActual(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN ULONG TraceLevel
    )
{

    CHAR Buffer[DBG_BUFFER_SIZE];
    
    _snprintf(Buffer,DBG_BUFFER_SIZE, "[File = %s Line = %lu]\n", FileName, LineNumber);
    OutputDebugStringA(Buffer);
   
}


VOID
SamIDebugFileLineOutput(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN ULONG TraceLevel
    )

{
    if (SamIsTraceEnabled(FileName, TraceLevel))
    {
        SamIDebugFileLineOutputActual(
            FileName,
            LineNumber,
            TraceLevel
            );
    }
}


VOID
SamIDebugOutputReturnCodeActual(
    IN  LPSTR   FileName,
    IN  ULONG   ReturnCode,
    IN  ULONG   TraceLevel
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
   
    if (SampTraceTag & SAM_TRACE_TICKS)
    {
        ULONG   CurrentTickCount = GetTickCount();
        ULONG   TicksConsumed = CurrentTickCount-POP_TICK_STACK();

        _snprintf(Buffer,DBG_BUFFER_SIZE, "[SAMSS] Returned %x, Ticks= %d", ReturnCode,TicksConsumed);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE, "[SAMSS] Returned %x", ReturnCode);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDebugOutputReturnCode(
    IN LPSTR FileName,
    IN ULONG ReturnCode,
    IN ULONG TraceLevel
    )

{
    if (SamIsTraceEnabled(FileName, TraceLevel))
    {
        SamIDebugOutputReturnCodeActual(
            FileName,
            ReturnCode,
            TraceLevel
            );
    }
}


VOID
wcstombsp(
    IN LPSTR Destination,
    IN LPWSTR Source,
    IN ULONG Size
    )
{
    ULONG Index;

    for (Index = 0; Index < Size; Index++)
    {
        if (Source[Index] != L'\0')
        {
            Destination[Index] = (CHAR)(Source[Index]);
        }
    }
    Destination[Size] = '\0';
}


VOID
SampDumpBinaryData(
    PBYTE   pData,
    DWORD   cbData
    )
{
    DWORD i;
    BYTE AsciiLine[16];
    BYTE BinaryLine[16];
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (0 == cbData)
    {
        OutputDebugStringA("Zero-Length Data\n");
        return;
    }

    if (cbData > DBG_BUFFER_SIZE)
    {
        OutputDebugStringA("ShowBinaryData - truncating display to 256 bytes\n");
        cbData = 256;
    }

    for (; cbData > 0 ;)
    {
        for (i = 0; i < 16 && cbData > 0 ; i++, cbData--)
        {
            BinaryLine[i] = *pData;
            (isprint(*pData)) ? (AsciiLine[i] = *pData) : (AsciiLine[i] = '.');
            pData++;
        }

        if (i < 15)
        {
            for (; i < 16 ; i++)
            {
                BinaryLine[i] = ' ';
                AsciiLine[i] = ' ';
            }
        }

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x\t",
                BinaryLine[0],
                BinaryLine[1],
                BinaryLine[2],
                BinaryLine[3],
                BinaryLine[4],
                BinaryLine[5],
                BinaryLine[6],
                BinaryLine[7],
                BinaryLine[8],
                BinaryLine[9],
                BinaryLine[10],
                BinaryLine[11],
                BinaryLine[12],
                BinaryLine[13],
                BinaryLine[14],
                BinaryLine[15]);

        OutputDebugStringA(Buffer);

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%c%c%c%c%c%c%c%c - %c%c%c%c%c%c%c%c\n",
                AsciiLine[0],
                AsciiLine[1],
                AsciiLine[2],
                AsciiLine[3],
                AsciiLine[4],
                AsciiLine[5],
                AsciiLine[6],
                AsciiLine[7],
                AsciiLine[8],
                AsciiLine[9],
                AsciiLine[10],
                AsciiLine[11],
                AsciiLine[12],
                AsciiLine[13],
                AsciiLine[14],
                AsciiLine[15]);

        OutputDebugStringA(Buffer);
    }
}


//
// Set Value Key Routines
//

VOID
SamIDumpNtSetValueKey(
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != ValueName)
    {
        ANSI_STRING AnsiString;

        RtlUnicodeStringToAnsiString(&AnsiString,
                                     ValueName,
                                     TRUE);

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Set Value Key:",
                "ValueName",
                AnsiString.Buffer);

        RtlFreeAnsiString(&AnsiString);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Set Value Key:",
                "ValueName",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "TitleIndex",
            TitleIndex);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Type",
            Type);

    OutputDebugStringA(Buffer);

    if (NULL != Data)
    {
        // BUG: Need a display routine for the data.

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                "BINARY DATA");
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n\n",
            "DataSize",
            DataSize);

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRtlpNtSetValueKey(
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "Set Value Key:",
            "Type",
            Type);

    OutputDebugStringA(Buffer);

    if (NULL != Data)
    {
        // BUG: Need a display routine for the data.

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                "ARRAY OF ULONG");
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n\n",
            "DataSize",
            DataSize);

    OutputDebugStringA(Buffer);
}


//
// Query Routines
//

VOID
SamIDumpNtQueryKey(
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    // This routine dumps the parameters after returning from the NtQueryKey
    // routine. The KeyInformation is a PVOID buffer that is mapped to one of
    // the KeyInformationClass structures. The case-label values correspond
    // to the values in the KEY_INFORMATION_CLASS enum. Note that the Length
    // parameter is used to specify the buffer length. This is done because
    // the data-length member inside each structure seems to always be set to
    // zero--why?

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "Query Key:",
            "KeyInformationClass",
            KeyInformationClass);

    OutputDebugStringA(Buffer);

    if (NULL != KeyInformation)
    {
        CHAR BufferTmp[DBG_BUFFER_SIZE];
        PKEY_BASIC_INFORMATION KeyBasicInformation;
        PKEY_FULL_INFORMATION KeyFullInformation;
        PKEY_NODE_INFORMATION KeyNodeInformation;

        switch(KeyInformationClass)
        {
        case 0: // KeyBasicInformation
            // Basic information's Name member is an array of WCHAR.
            KeyBasicInformation = KeyInformation;
            wcstombsp(BufferTmp,
                     KeyBasicInformation->Name,
                     wcslen(KeyBasicInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%s\n%-30s = 0x%lx:0x%lx\n%-30s = %lu\n%-30s = %lu\n%-30s\n%-30s\n",
                    "KeyInformation:",
                    "LastWriteTime",
                    KeyBasicInformation->LastWriteTime.HighPart,
                    KeyBasicInformation->LastWriteTime.LowPart,
                    "TitleIndex",
                    KeyBasicInformation->TitleIndex,
                    "NameLength",
                    KeyBasicInformation->NameLength,
                    "Name",
                    // BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);

            SampDumpBinaryData((PBYTE)KeyBasicInformation->Name,
                               // KeyBasicInformation->NameLength);
                               Length);

            break;

        case 1: // KeyNodeInformation
            // Node information's Name member is an array of WCHAR.
            KeyNodeInformation = KeyInformation;
            wcstombsp(BufferTmp,
                      (LPWSTR)KeyNodeInformation->Name,
                      wcslen((LPWSTR)KeyNodeInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%s\n%-30s = 0x%lx:0x%lx\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "KeyInformation:",
                    "LastWriteTime",
                    KeyNodeInformation->LastWriteTime.HighPart,
                    KeyNodeInformation->LastWriteTime.LowPart,
                    "TitleIndex",
                    KeyNodeInformation->TitleIndex,
                    "ClassOffset",
                    KeyNodeInformation->ClassOffset,
                    "ClassLength",
                    KeyNodeInformation->ClassLength,
                    "NameLength",
                    KeyNodeInformation->NameLength,
                    "Name",
                    // BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);

            SampDumpBinaryData((PBYTE)KeyNodeInformation->Name,
                               // KeyNodeInformation->NameLength);
                               Length);

            break;

        case 2: // KeyFullInformation

            KeyFullInformation = KeyInformation;

            // Full information's Class member is an array of WCHAR.

            // wcstombsp(BufferTmp,
            //          KeyFullInformation->Class,
            //          wcslen(KeyFullInformation->Class));

            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%s\n%-30s = 0x%lx:0x%lx\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "KeyInformation:",
                    "LastWriteTime",
                    KeyFullInformation->LastWriteTime.HighPart,
                    KeyFullInformation->LastWriteTime.LowPart,
                    "TitleIndex",
                    KeyFullInformation->TitleIndex,
                    "ClassOffset",
                    KeyFullInformation->ClassOffset,
                    "ClassLength",
                    KeyFullInformation->ClassLength,
                    "SubKeys",
                    KeyFullInformation->SubKeys,
                    "MaxNameLen",
                    KeyFullInformation->MaxNameLen,
                    "MaxClassLen",
                    KeyFullInformation->MaxClassLen,
                    "Values",
                    KeyFullInformation->Values,
                    "MaxValueNameLen",
                    KeyFullInformation->MaxValueNameLen,
                    "MaxValueDataLen",
                    KeyFullInformation->MaxValueDataLen,
                    "Class",
                    // BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);

            SampDumpBinaryData((PBYTE)KeyFullInformation->Class,
                               // KeyFullInformation->ClassLength);
                               Length);

            break;

        default:
            break;
        }
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyInformation",
                NULL);

        OutputDebugStringA(Buffer);
    }

    // OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Length",
            Length);

    OutputDebugStringA(Buffer);

    if (NULL != ResultLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n\n",
                "ResultLength",
                *ResultLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "ResultLength",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpNtQueryValueKey(
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    // This routine dumps the parameters after returning from NtQueryValueKey
    // routine. The KeyValueInformation is a PVOID buffer that is mapped to
    // one of the KeyInformationClass structures. The case-label values corre-
    // spond to the values in the KEY_VALUE_INFORMATION_CLASS enum.

    if (NULL != ValueName)
    {
        ANSI_STRING AnsiString;

        RtlUnicodeStringToAnsiString(&AnsiString,
                                     ValueName,
                                     TRUE);

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Query Value Key:",
                "ValueName",
                AnsiString.Buffer);

        RtlFreeAnsiString(&AnsiString);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Query Value Key:",
                "ValueName",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "KeyValueInformationClass",
            KeyValueInformationClass);

    OutputDebugStringA(Buffer);

    if (NULL != KeyValueInformation)
    {
        CHAR BufferTmp[DBG_BUFFER_SIZE];
        PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInformation;
        PKEY_VALUE_FULL_INFORMATION KeyValueFullInformation;
        PKEY_VALUE_PARTIAL_INFORMATION KeyValuePartialInformation;

        switch(KeyValueInformationClass)
        {
        case 0: // KeyValueBasicInformation
            // Basic information's Name member is an array of WCHAR.
            KeyValueBasicInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueBasicInformation->Name,
                     wcslen(KeyValueBasicInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueBasicInformation->TitleIndex,
                    "Type",
                    KeyValueBasicInformation->Type,
                    "NameLength",
                    KeyValueBasicInformation->NameLength,
                    "Name",
                    //BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);
            SampDumpBinaryData((PBYTE)KeyValueBasicInformation->Name,
                               KeyValueBasicInformation->NameLength);
            break;

        case 1: // KeyValueFullInformation
            // Full information's Name member is an array of WCHAR.
            KeyValueFullInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueFullInformation->Name,
                     wcslen(KeyValueFullInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueFullInformation->TitleIndex,
                    "Type",
                    KeyValueFullInformation->Type,
                    "DataOffset",
                    KeyValueFullInformation->DataOffset,
                    "DataLength",
                    KeyValueFullInformation->DataLength,
                    "NameLength",
                    KeyValueFullInformation->NameLength,
                    "Name",
                    //BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);
            SampDumpBinaryData((PBYTE)KeyValueFullInformation->Name,
                               KeyValueFullInformation->NameLength);
            break;

        case 2: // KeyValuePartialInformation

            KeyValuePartialInformation = KeyValueInformation;

            // Partial information's Data member is an array of UCHAR.

            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValuePartialInformation->TitleIndex,
                    "Type",
                    KeyValuePartialInformation->Type,
                    "DataLength",
                    KeyValuePartialInformation->DataLength,
                    "Data",
                    // KeyValuePartialInformation->Data);
                    "BINARY DATA FOLLOWS:");

            OutputDebugStringA(Buffer);

            // First, dump the buffer as a raw byte stream.

            SampDumpBinaryData(KeyValuePartialInformation->Data,
                               KeyValuePartialInformation->DataLength);

            // Then, determine object type and dump the data in SAM struct
            // format.

            switch(KeyValuePartialInformation->Type)
            {

            case 0: // Server Object
                break;

            case 1: // Domain Object
                break;

            case 2: // Group Object
                break;

            case 3: // Alias Object

                // Dump the alias object's fixed attributes.

                // BUG: What about Basic and Full information?

                // SampDumpPSAMP_V1_FIXED_LENGTH_ALIAS(
                //     KeyValuePartialInformation->Data,
                //     0);

                // Dump the alias object's variable attribute array.

                //SampDumpAliasVariableAttributeArray(
                //    KeyValuePartialInformation->Data);

                // Dump the alias object's Variable attributes.


                break;

            case 4: // User Object
                break;

            default: // Unknown Object
                break;

            }

            break;

        default:
            break;
        }
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValueInformation",
                NULL);

        OutputDebugStringA(Buffer);
    }

    // OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Length",
            Length);

    OutputDebugStringA(Buffer);

    if (NULL != ResultLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n\n",
                "ResultLength",
                *ResultLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "ResultLength",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRtlpNtQueryValueKey(
    IN PULONG KeyValueType,
    IN PVOID KeyValue,
    IN PULONG KeyValueLength,
    IN PLARGE_INTEGER LastWriteTime
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != KeyValueType)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = 0x%lx\n",
                "Query Value Key:",
                "KeyValueType",
                *KeyValueType);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Query Value Key:",
                "KeyValueType",
                NULL);
    }

    OutputDebugStringA(Buffer);

    if (NULL != KeyValue)
    {
        SampDumpBinaryData((PBYTE)KeyValue, *KeyValueLength);
        OutputDebugStringA("\n");
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValue",
                NULL);
    }

    OutputDebugStringA(Buffer);

    if (NULL != KeyValueLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n",
                "KeyValueLength",
                *KeyValueLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValueLength",
                NULL);
    }

    OutputDebugStringA(Buffer);

    if (NULL != LastWriteTime)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = 0x%lx:0x%lx\n\n",
                "LastWriteTime",
                LastWriteTime->HighPart,
                LastWriteTime->LowPart);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "LastWriteTime",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


//
// Enumeration Routines
//

VOID
SamIDumpNtEnumerateKey(
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "Enumerate Key:",
            "Index",
            Index);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "KeyValueInformationClass",
            KeyValueInformationClass);

    OutputDebugStringA(Buffer);

    if (NULL != KeyValueInformation)
    {
        CHAR BufferTmp[DBG_BUFFER_SIZE];
        PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInformation;
        PKEY_VALUE_FULL_INFORMATION KeyValueFullInformation;
        PKEY_VALUE_PARTIAL_INFORMATION KeyValuePartialInformation;

        switch(KeyValueInformationClass)
        {
        case 0: // KeyValueBasicInformation
            // Full information's Name member is an array of WCHAR.
            KeyValueBasicInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueBasicInformation->Name,
                     wcslen(KeyValueBasicInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueBasicInformation->TitleIndex,
                    "Type",
                    KeyValueBasicInformation->Type,
                    "NameLength",
                    KeyValueBasicInformation->NameLength,
                    "Name",
                    BufferTmp);
            break;

        case 1: // KeyValueFullInformation
            // Full information's Name member is an array of WCHAR.
            KeyValueFullInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueFullInformation->Name,
                     wcslen(KeyValueFullInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueFullInformation->TitleIndex,
                    "Type",
                    KeyValueFullInformation->Type,
                    "DataOffset",
                    KeyValueFullInformation->DataOffset,
                    "DataLength",
                    KeyValueFullInformation->DataLength,
                    "NameLength",
                    KeyValueFullInformation->NameLength,
                    "Name",
                    BufferTmp);
            break;

        case 2: // KeyValuePartialInformation
            // Partial information's Data member is an array of UCHAR.
            KeyValuePartialInformation = KeyValueInformation;

            // BUG: Need a display routine for the data.

            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValuePartialInformation->TitleIndex,
                    "Type",
                    KeyValuePartialInformation->Type,
                    "DataLength",
                    KeyValuePartialInformation->DataLength,
                    "Data",
                    // KeyValuePartialInformation->Data);
                    "BINARY DATA FOLLOWS:");
            OutputDebugStringA(Buffer);
            SampDumpBinaryData(KeyValuePartialInformation->Data,
                               KeyValuePartialInformation->DataLength);
            break;

        default:
            break;
        }
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValueInformation",
                NULL);

        OutputDebugStringA(Buffer);
    }

    // OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Length",
            Length);

    OutputDebugStringA(Buffer);

    if (NULL != ResultLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n\n",
                "ResultLength",
                *ResultLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "ResultLength",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRtlpNtEnumerateSubKey(
    IN PUNICODE_STRING SubKeyName,
    IN PSAM_ENUMERATE_HANDLE Index,
    IN LARGE_INTEGER LastWriteTime
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString,
                                 SubKeyName,
                                 TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %s\n%-30s = %lu\n%-30s = 0x%lx:0x%lx\n\n",
            "Enumerate SubKey:",
            "SubKeyName",
            AnsiString.Buffer,
            "Index",
            *Index,
            "LastWriteTime",
            LastWriteTime.HighPart,
            LastWriteTime.LowPart);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);
}


//
// Security Descriptor Component Routines
//

VOID
SampDumpSecurityDescriptorSubAuthority(
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority[]
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    INT Count = (INT)SubAuthorityCount;
    INT Index = 0;

    for (Index = 0; Index < Count; Index++)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %lu\n",
                "SubAuthority:",
                "SubAuthority Element",
                SubAuthority[Index]);
    }

    OutputDebugStringA(Buffer);
}


VOID
SampDumpSecurityDescriptorOwner(
    IN PISID Owner
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du%du%du%du%du%du\n",
            "Owner:",
            "Revision",
            Owner->Revision,
            "SubAuthorityCount",
            Owner->SubAuthorityCount,
            "IdentifierAuthority",
            Owner->IdentifierAuthority.Value[0],
            Owner->IdentifierAuthority.Value[1],
            Owner->IdentifierAuthority.Value[2],
            Owner->IdentifierAuthority.Value[3],
            Owner->IdentifierAuthority.Value[4],
            Owner->IdentifierAuthority.Value[5]);

    OutputDebugStringA(Buffer);

    SampDumpSecurityDescriptorSubAuthority(Owner->SubAuthorityCount,
                                           Owner->SubAuthority);
}


VOID
SampDumpSecurityDescriptorGroup(
    IN PISID Group
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du%du%du%du%du%du\n",
            "Group:",
            "Revision",
            Group->Revision,
            "SubAuthorityCount",
            Group->SubAuthorityCount,
            "IdentifierAuthority",
            Group->IdentifierAuthority.Value[0],
            Group->IdentifierAuthority.Value[1],
            Group->IdentifierAuthority.Value[2],
            Group->IdentifierAuthority.Value[3],
            Group->IdentifierAuthority.Value[4],
            Group->IdentifierAuthority.Value[5]);

    OutputDebugStringA(Buffer);

    SampDumpSecurityDescriptorSubAuthority(Group->SubAuthorityCount,
                                           Group->SubAuthority);
}


//
// ACL Routines
//

VOID
SampDumpAcl(
    IN PACL Acl
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n",
            "Acl:",
            "AclRevision",
            Acl->AclRevision,
            "Sbz1",
            Acl->Sbz1,
            "ACL Size",
            Acl->AclSize,
            "ACE Count",
            Acl->AceCount,
            "Sbz2",
            Acl->Sbz2);

    OutputDebugStringA(Buffer);
}


//
// Security Descriptor Routines
//

VOID
SampDumpSecurityDescriptor(
    IN PISECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != SecurityDescriptor)
    {
        // Note that the SECURITY_DESCRIPTOR is intended to be treated as an
        // opaque blob so that future changes are compatible with previous
        // versions.

        // Revision is actually represented as a UCHAR, but it is displayed as
        // a "du" in this routine.

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du\n",
                "SecurityDescriptor:",
                "Revision",
                SecurityDescriptor->Revision,
                "Sbz1",
                SecurityDescriptor->Sbz1,
                "Control",
                SecurityDescriptor->Control);

        OutputDebugStringA(Buffer);

        SampDumpSecurityDescriptorOwner(SecurityDescriptor->Owner);
        SampDumpSecurityDescriptorGroup(SecurityDescriptor->Group);
        SampDumpAcl(SecurityDescriptor->Sacl);
        SampDumpAcl(SecurityDescriptor->Dacl);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE, "%-30s = %s\n", "SecurityDescriptor:", NULL);
        OutputDebugStringA(Buffer);
    }

}


//
// Quality Of Service Routines
//

VOID
SampDumpSecurityQualityOfService(
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != SecurityQualityOfService)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %lu\n%-30s = %du\n%-30s = %du\n%-30s = %du\n",
                "SecurityQualityOfService:",
                "Length",
                SecurityQualityOfService->Length,
                "ImpersonationLevel",
                SecurityQualityOfService->ImpersonationLevel,
                "ContextTrackingMode",
                SecurityQualityOfService->ContextTrackingMode,
                "EffectiveOnly",
                SecurityQualityOfService->EffectiveOnly);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE, "%-30s = %s\n", "SecurityQualityOfService:", NULL);
    }

    OutputDebugStringA(Buffer);
}


//
// Object Attribute Routines
//

VOID
SampDumpObjectAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString,
                                 ObjectAttributes->ObjectName,
                                 TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n%-30s = %p\n%-30s = %s\n%-30s = 0x%lx\n",
            "ObjectAttributes:",
            "Length",
            ObjectAttributes->Length,
            "RootDirectory Handle",
            ObjectAttributes->RootDirectory,
            "ObjectName",
            AnsiString.Buffer,
            "Attributes",
            ObjectAttributes->Attributes);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);

    SampDumpSecurityDescriptor(ObjectAttributes->SecurityDescriptor);
    SampDumpSecurityQualityOfService(ObjectAttributes->SecurityQualityOfService);
}


//
// Open Key Routines
//

VOID
SamIDumpNtOpenKey(
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Options
    )
{

    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = 0x%lx\n%-30s = 0x%lx\n",
            "Open Registry Key:",
            "DesiredAccess",
            DesiredAccess,
            "Options",
            Options);

    OutputDebugStringA(Buffer);

    SampDumpObjectAttributes(ObjectAttributes);

    OutputDebugStringA("\n");
}


//
// V1_0A Routines
//

VOID
SampDumpPSAMP_V1_FIXED_LENGTH_SERVER(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_FIXED_LENGTH_SERVER TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "SAMP_V1_FIXED_LENGTH_SERVER Buffer:",
            "RevisionLevel",
            TempBuffer->RevisionLevel);

    OutputDebugStringA(Buffer);

    OutputDebugStringA("\n");
}


VOID
SampDumpPSAMP_V1_0A_FIXED_LENGTH_DOMAIN(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,

            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %du\n\
%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n\n",

            "SAMP_V1_OA_FIXED_LENGTH_DOMAIN Buffer:",

            "Revision",
            TempBuffer->Revision,

            "Unused1",
            TempBuffer->Unused1,

            "Creation Time",
            TempBuffer->CreationTime.HighPart,
            TempBuffer->CreationTime.LowPart,

            "Modified Count",
            TempBuffer->ModifiedCount.HighPart,
            TempBuffer->ModifiedCount.LowPart,

            "MaxPasswordAge",
            TempBuffer->MaxPasswordAge.HighPart,
            TempBuffer->MaxPasswordAge.LowPart,

            "MinPasswordAge",
            TempBuffer->MinPasswordAge.HighPart,
            TempBuffer->MinPasswordAge.LowPart,

            "ForceLogoff",
            TempBuffer->ForceLogoff.HighPart,
            TempBuffer->ForceLogoff.LowPart,

            "LockoutDuration",
            TempBuffer->LockoutDuration.HighPart,
            TempBuffer->LockoutDuration.LowPart,

            "LockoutObservationWindow",
            TempBuffer->LockoutObservationWindow.HighPart,
            TempBuffer->LockoutObservationWindow.LowPart,

            "ModifiedCountAtLastPromotion",
            TempBuffer->ModifiedCountAtLastPromotion.HighPart,
            TempBuffer->ModifiedCountAtLastPromotion.LowPart,

            "NextRid",
            TempBuffer->NextRid,

            "PasswordProperties",
            TempBuffer->PasswordProperties,

            "MinPasswordLength",
            TempBuffer->MinPasswordLength,

            "PasswordHistoryLength",
            TempBuffer->PasswordHistoryLength,

            "LockoutThreshold",
            TempBuffer->LockoutThreshold,

            "ServerState",
            TempBuffer->ServerState,

            "ServerRole",
            TempBuffer->ServerRole,

            "UasCompatibilityRequired",
            TempBuffer->UasCompatibilityRequired);

    OutputDebugStringA(Buffer);
}


//
// Variable Length Attribute Routines
//

VOID
SampDumpSAMP_VARIABLE_LENGTH_ATTRIBUTE(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    BYTE *TempBuffer = NewValue;


    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n\n",
            "NewValueLength",
            NewValueLength);

    OutputDebugStringA(Buffer);
}


//
// Fixed Length Attribute Routines
//

#if 0

VOID
SampDumpPSAMP_V1_FIXED_LENGTH_ALIAS(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_FIXED_LENGTH_ALIAS TempBuffer = NewValue;

    // BUG: NewValueLength is unnecessary for this fixed length attribute.

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n\n",
            "SAMP_V1_FIXED_LENGTH_ALIAS Buffer:",
            "RelativeId",
            TempBuffer->RelativeId);

    OutputDebugStringA(Buffer);
}

#endif


VOID
SampDumpPSAMP_V1_0A_FIXED_LENGTH_GROUP(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_FIXED_LENGTH_GROUP TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n\n",
            "SAMP_V1_OA_FIXED_LENGTH_GROUP Buffer:",
            "RelativeId",
            TempBuffer->RelativeId,
            "Attributes",
            TempBuffer->Attributes,
            "AdminGroup",
            TempBuffer->AdminGroup);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpPSAMP_V1_0A_FIXED_LENGTH_USER(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_0A_FIXED_LENGTH_USER TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,

            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %ul:%lu\n%-30s = %lu:%lu\n%-30s = %lu:%lu\n%-30s = %lu:%lu\n%-30s = %lu:%lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %du\n%-30s = %du\n\
%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n\n",

            "SAMP_V1_OA_FIXED_LENGTH_USER Buffer:",

            "Revision",
            TempBuffer->Revision,

            "Unused1",
            TempBuffer->Unused1,

            "LastLogon",
            TempBuffer->LastLogon.HighPart,
            TempBuffer->LastLogon.LowPart,

            "LastLogoff",
            TempBuffer->LastLogoff.HighPart,
            TempBuffer->LastLogoff.LowPart,

            "PasswordLastSet",
            TempBuffer->PasswordLastSet.HighPart,
            TempBuffer->PasswordLastSet.LowPart,

            "AccountExpires",
            TempBuffer->AccountExpires.HighPart,
            TempBuffer->AccountExpires.LowPart,

            "LastBadPasswordTime",
            TempBuffer->LastBadPasswordTime.HighPart,
            TempBuffer->LastBadPasswordTime.LowPart,

            "UserId",
            TempBuffer->UserId,

            "PrimaryGroupId",
            TempBuffer->PrimaryGroupId,

            "UserAccountControl",
            TempBuffer->UserAccountControl,

            "CountryCode",
            TempBuffer->CountryCode,

            "CodePage",
            TempBuffer->CodePage,

            "BadPasswordCount",
            TempBuffer->BadPasswordCount,

            "LogonCount",
            TempBuffer->LogonCount,

            "AdminCount",
            TempBuffer->AdminCount,

            "Unused2",
            TempBuffer->Unused2,

            "OperatorCount",
            TempBuffer->OperatorCount);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpSampFixedBufferAddress(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %p\n%-30s = %lu\n%-30s = %s\n",
            "BufferAddress",
            NewValue,
            "BufferLength",
            NewValueLength,
            "Buffer",
            "BINARY DATA FOLLOWS:");

    OutputDebugStringA(Buffer);

    SampDumpBinaryData((PBYTE)NewValue, NewValueLength);
    OutputDebugStringA("\n");
}


VOID
SampDumpBuffer(
    IN PVOID BufferAddress,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine dumps the address and length of the attribute buffer.

Parameters:

    BufferAddress - self explanatory.

    BufferLength - self explanatory.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %p\n",
            "BufferAddress",
            BufferAddress);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "BufferLength",
            BufferLength);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %s\n\n",
            "Buffer Content",
            BufferAddress);

    OutputDebugStringA(Buffer);
}


//
// RXact Routines
//

VOID
SampDumpRXactLog(
    IN PRTL_RXACT_LOG TransactionLog
    )

/*++

Routine Description:

    This routine dumps a (registry) transaction log structure.

Parameters:

    TransactionLog - Pointer to the transaction log.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n",
            "Transaction Log:",
            "OperationCount",
            TransactionLog->OperationCount,
            "LogSize",
            TransactionLog->LogSize,
            "LogSizeInUse",
            TransactionLog->LogSizeInUse);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpRXactContext(
    IN PRTL_RXACT_CONTEXT TransactionContext
    )

/*++

Routine Description:

    This routine dumps a (registry) transaction context.

Parameters:

    TransactionContext - Pointer to the transaction context.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %p\n%-30s = %p\n%-30s = %d\n",
            "Transaction Context:",
            "RootRegistryKey Handle",
            TransactionContext->RootRegistryKey,
            "RXactKey Handle",
            TransactionContext->RXactKey,
            "HandlesValid",
            TransactionContext->HandlesValid);

    OutputDebugStringA(Buffer);

    SampDumpRXactLog(TransactionContext->RXactLog);
}


VOID
SampDumpRXactOperation(
    IN RTL_RXACT_OPERATION Operation
    )

/*++

Routine Description:

    This routine dumps an operation value.

Parameters:

    Operation - The operation value.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Operation",
            Operation);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpSubKeyNameAndKey(
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This routine dumps the registry root name and root-key handle value.

Parameters:

    SubKeyName - Pointer to a counted string that is the root name.

    KeyHandle - Handle of the registry's root key.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString, SubKeyName, TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %s\n",
            "SubKeyName",
            AnsiString.Buffer);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %p\n",
            "KeyHandle",
            KeyHandle);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpAttributeName(
    IN PUNICODE_STRING AttributeName
    )

/*++

Routine Description:

    This routine dumps a combined-attribute name.

Parameters:

    AttributeName - Pointer to the string containing the name.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString, AttributeName, TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %s\n",
            "AttributeName",
            AnsiString.Buffer);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);
}


VOID
SampDumpKeyType(
    IN ULONG RegistryKeyType
    )

/*++

Routine Description:

    This routine dumps a registry key type.

Parameters:

    RegistryKeyType - self explanatory.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "RegistryKeyType",
            RegistryKeyType);

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRXact(
    IN PRTL_RXACT_CONTEXT TransactionContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG RegistryKeyType,
    IN PVOID NewValue,
    IN ULONG NewValueLength,
    IN ULONG NewValueType
    )

/*++

Routine Description:

    This routine dumps a (registry) transaction, just before the call to
    RtlAddAttributeActionToRXact.

Parameters:

    (See individual output routines above for the descriptions)

Return Values:

    None.

--*/

{
    SampDumpRXactContext(TransactionContext);
    SampDumpRXactOperation(Operation);
    SampDumpSubKeyNameAndKey(SubKeyName, KeyHandle);
    SampDumpAttributeName(AttributeName);
    SampDumpKeyType(RegistryKeyType);

    switch(NewValueType)
    {
    case FIXED_LENGTH_SERVER_FLAG:
        SampDumpPSAMP_V1_FIXED_LENGTH_SERVER(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_DOMAIN_FLAG:
        SampDumpPSAMP_V1_0A_FIXED_LENGTH_DOMAIN(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_ALIAS_FLAG:
        // SampDumpPSAMP_V1_FIXED_LENGTH_ALIAS(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_GROUP_FLAG:
        SampDumpPSAMP_V1_0A_FIXED_LENGTH_GROUP(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_USER_FLAG:
        SampDumpPSAMP_V1_0A_FIXED_LENGTH_USER(NewValue, NewValueLength);
        break;

    case VARIABLE_LENGTH_ATTRIBUTE_FLAG:
        SampDumpSAMP_VARIABLE_LENGTH_ATTRIBUTE(NewValue, NewValueLength);
        break;

    case FixedBufferAddressFlag:
        SampDumpSampFixedBufferAddress(NewValue, NewValueLength);
        break;

    default:
        SampDumpBuffer(NewValue, NewValueLength);
        break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\credman.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credman.cxx
//
// Contents:    Scaffolding for credential management APIs built on NT4 sam
//
//
// History:     16-Aug-1996     MikeSw          Created
//              29-Apr-1999     ShaoYin         Changed the way of storing
//                                              0 length Credentials 
//               
//  The New Logic about storing / retrieving zero lenth credentials is 
//  described as followings:
// 
//  Store Credentials:  (Changed)
//      1. Always add the PackageName into PackageList
//      2. If the value of credentials is NULL (or zero length), the do not 
//         store this credentials. Only store this credentials when the value
//         is not NULL
//
//  Retrieve Credentials:   (Changed)
//      1. First get the PackageList from user's SupplementalCredentials 
//         attribute.
//      2. If the PackageName of the desired Credentials presented in the
//         PackageList, then it means our client has store the Credentials
//         at least once. Go to step 3. 
//         Otherwise, if the PackageName is not presented in the PackageName, 
//         then return STATUS_DS_NO_ATTRIBUTE_OR_VALUE immediately.
//      3. If we find the PackageName from the PackageList, then query the
//         Credentials value from this user's SupplementalCredentials attribute
//         according to the PackageName. 
//         If we find the value, return it.
//         If we can't find the value, that means the value of that 
//         credentials is NULL or zero Length. 
//      4. If CLEARTEXT is not allowed. 
//         return STATUS_DS_CLEAR_PWD_NOT_ALLOWED error
//
// Remove Credentials:  (New Function)
//      1. Remove the PackageName from the PackageList
//      2. Remove the Credentials's value from the SupplementalCredentials
//         attribute.
//
//------------------------------------------------------------------------
#include <ntdspchx.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntsam.h>
#include <samrpc.h>
#include <ntsamp.h>
extern "C"
{

#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <dslayer.h>
#include <attids.h>
#include "usrprop.h"
}

#define PACKAGE_LIST L"Packages"
#define PRIMARY_CRED_PREFIX L"Primary:"
#define SUPP_CRED_PREFIX L"Supplemental:"


#include <pshpack1.h>
typedef struct
{
    ULONG  Format;
    ULONG  ActualLength;
    SAMP_SECRET_DATA    SecretData;
} CREDENTIAL_DATA, * PCREDENTIAL_DATA;
#include <poppack.h>

// Definitions for Format
#define SAMP_USER_PARAMETERS_FORMAT 0

//+------------------------------------------------------------------------
//
//  Function   SampEncryptCredentialData
//
//  Synopsis: Encrypts Credetial Data
//
//
//  Effects:
//
//  Arguments:
//
//
//+-------------------------------------------------------------------------
NTSTATUS
SampEncryptCredentialData(
    IN ULONG Format,
    IN ULONG Length,
    IN ULONG Rid,
    IN PVOID Data,
    IN BOOLEAN EncryptForUpgrade,
    OUT PULONG EncryptedLength,
    OUT PCREDENTIAL_DATA *EncryptedData
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    USHORT      KeyId;
    PVOID       PaddedData=NULL;
    ULONG       PaddedLength=0;
    UNICODE_STRING ClearData;
    UNICODE_STRING SecretData;





    KeyId = SampGetEncryptionKeyType();
    RtlSecureZeroMemory(&SecretData,sizeof(UNICODE_STRING));

    if ((SAMP_NO_ENCRYPTION==KeyId) || (EncryptForUpgrade))
    {

        //
        // We hit this case either if we are in DS mode ( ie win2k 
        // domain controller, where the DS performs this encryption
        // or during dcpromo time ( EncryptForUpgrade is true ) where
        // we are righting to a DS that is still in the installation
        // phase. In these cases the DS adds a layer of encryption
        //

        *EncryptedLength= SampSecretDataSize(Length)
            + sizeof(CREDENTIAL_DATA) - SampSecretDataSize(0);

        *EncryptedData= (PCREDENTIAL_DATA) LocalAlloc(0,*EncryptedLength);

        if (NULL==*EncryptedData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        (*EncryptedData)->Format= Format;
        (*EncryptedData)->ActualLength = Length;
        (*EncryptedData)->SecretData.Flags = 0;
        (*EncryptedData)->SecretData.KeyId = SAMP_NO_ENCRYPTION;
        RtlCopyMemory(&((*EncryptedData)->SecretData.Data),
                        Data,
                        Length);
    }
    else
    {

        //
        // Since the Secret data encryption routines
        // expect the data to encrypt to be an integral
        // multiple of NT_OWF_PASSWORD, pad the data to
        // zero's till it is that length.
        //

        PaddedLength = (Length / ENCRYPTED_LM_OWF_PASSWORD_LENGTH + 1)
                                * ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        PaddedData = MIDL_user_allocate(PaddedLength);
        if (NULL==PaddedData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Copy Over and then Pad the data
        //
        RtlSecureZeroMemory(PaddedData,PaddedLength);
        RtlCopyMemory(PaddedData,Data,Length);

        //
        // Encrypt the Data.
        //

        ClearData.Length = (USHORT)PaddedLength;
        ClearData.MaximumLength = (USHORT)PaddedLength;
        ClearData.Buffer = (USHORT *) PaddedData;

        NtStatus = SampEncryptSecretData(
                        &SecretData,
                        KeyId,
                        MiscCredentialData,
                        &ClearData,
                        Rid
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Alloc Space for the credential Data Header + padded Data
        //

        ASSERT(SecretData.Length==SampSecretDataSize(PaddedLength));
        *EncryptedLength= SecretData.Length + FIELD_OFFSET(CREDENTIAL_DATA,SecretData);
        *EncryptedData= (PCREDENTIAL_DATA) LocalAlloc(0,*EncryptedLength);

        if (NULL==*EncryptedData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Set the fields in the Credential Data and Copy over the secret
        // data structure
        //

        (*EncryptedData)->Format= Format;
        (*EncryptedData)->ActualLength = Length;
         RtlCopyMemory(&((*EncryptedData)->SecretData),
                        SecretData.Buffer,
                        SecretData.Length);

    }

Error:

    //
    // Free any Padded Data
    //

    if ((NULL!=PaddedData) && (0!=PaddedLength))
    {
        // Zero out memory, remember this contains clear
        // password
        RtlSecureZeroMemory(PaddedData,PaddedLength);
        MIDL_user_free(PaddedData);
    }


     //
     // Free the Secret Data returned by the Encryption routine
     //

     if (SecretData.Buffer) {
         RtlSecureZeroMemory(SecretData.Buffer, SecretData.MaximumLength);
     }
     SampFreeUnicodeString(&SecretData);


    return NtStatus;
}


NTSTATUS
SampDecryptCredentialData(
    IN ULONG EncryptedLength,
    IN ULONG Rid,
    IN PCREDENTIAL_DATA CredentialData,
    OUT PULONG ActualLength,
    OUT PULONG Format,
    OUT PVOID  *ActualData
    )
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    USHORT      KeyId;

   *Format = CredentialData->Format;
    KeyId = CredentialData->SecretData.KeyId;

    if (SAMP_NO_ENCRYPTION==KeyId)
    {
        *ActualLength=CredentialData->ActualLength;
        *ActualData = LocalAlloc(0,*ActualLength);
        if (NULL==*ActualData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(*ActualData,&(CredentialData->SecretData.Data),*ActualLength);
    }
    else
    {
        UNICODE_STRING ClearData;
        UNICODE_STRING SecretData;

        SecretData.Length = (USHORT) (EncryptedLength - FIELD_OFFSET(CREDENTIAL_DATA,SecretData));
        SecretData.MaximumLength = (USHORT) (EncryptedLength - FIELD_OFFSET(CREDENTIAL_DATA,SecretData));
        SecretData.Buffer = (USHORT *)&(CredentialData->SecretData);

        NtStatus = SampDecryptSecretData(
                        &ClearData,
                        MiscCredentialData,
                        &SecretData,
                        Rid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        ASSERT(CredentialData->ActualLength<=ClearData.Length);
        *ActualLength = CredentialData->ActualLength;
        *ActualData = ClearData.Buffer;
    }
Error:

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   BuildNewPackageList
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
BuildNewPackageList(
    IN PUNICODE_STRING OldPackageList,
    IN PUNICODE_STRING PackageName,
    OUT PUNICODE_STRING NewPackageList,
    IN BOOLEAN RemovePackage
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NewPackageLength;
    UNICODE_STRING TempPackageName;
    LPWSTR NewPackageString;
    ULONG Offset;
    UNICODE_STRING OldPackageListNull;

    //
    // Build a null terminated version of the old list
    //

    OldPackageListNull.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,OldPackageList->Length + sizeof(WCHAR));
    if (OldPackageListNull.Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlCopyMemory(
        OldPackageListNull.Buffer,
        OldPackageList->Buffer,
        OldPackageList->Length
        );
    OldPackageListNull.Length = OldPackageList->Length;
    OldPackageListNull.MaximumLength = sizeof(WCHAR) + OldPackageList->Length;



    //
    // Compute the name of the new package list
    //

    NewPackageLength = OldPackageListNull.Length;

    //
    // add a null separator
    //

    if (NewPackageLength != 0)
    {
        NewPackageLength += sizeof(WCHAR);
    }

    if (RemovePackage)
    {
        NewPackageLength -= PackageName->Length + sizeof(WCHAR);
    }
    else
    {
        NewPackageLength += PackageName->Length + sizeof(WCHAR);
    }

    //
    // If the resulting string is empty, add null terminator
    //

    if (NewPackageLength == 0)
    {
        NewPackageLength += sizeof(WCHAR);
    }
    NewPackageList->Buffer = (LPWSTR) LocalAlloc(0,NewPackageLength);
    if (NewPackageList->Buffer == NULL)
    {
        LocalFree(OldPackageListNull.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NewPackageList->MaximumLength = (USHORT) NewPackageLength;


    if (!RemovePackage)
    {
        //
        // If we are adding the package, copy the old package list and add
        // the new one.
        //

        if (OldPackageListNull.Length > 0)
        {
            RtlCopyMemory(
                NewPackageList->Buffer,
                OldPackageListNull.Buffer,
                OldPackageListNull.Length
                );
            NewPackageList->Buffer[OldPackageListNull.Length/sizeof(WCHAR)] = L'\0';
            Offset = OldPackageListNull.Length + sizeof(WCHAR);
        }
        else
        {
             Offset = 0;
        }
        RtlCopyMemory(
            NewPackageList->Buffer + Offset/sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        NewPackageList->Buffer[NewPackageLength/sizeof(WCHAR) - 1] = L'\0';
    }
    else
    {
#if DBG
        BOOLEAN FoundEntry = FALSE;
#endif

        TempPackageName.Buffer = OldPackageListNull.Buffer;

        NewPackageString = NewPackageList->Buffer;

        while (TempPackageName.Buffer < OldPackageListNull.Buffer + OldPackageListNull.Length/sizeof(WCHAR))
        {
            RtlInitUnicodeString(
                &TempPackageName,
                TempPackageName.Buffer
                );

            //
            // If the packageName doesn't match, copy it to the new string.
            //

            // NewPackageString = NewPackageList->Buffer;
            if (!RtlEqualUnicodeString(
                    PackageName,
                    &TempPackageName,
                    TRUE
                    ))
            {
                RtlCopyMemory(
                    NewPackageString,
                    TempPackageName.Buffer,
                    TempPackageName.MaximumLength
                    );
                NewPackageString += TempPackageName.MaximumLength/sizeof(WCHAR);
            }
            else
            {
#if DBG
                FoundEntry = TRUE;
#endif
            }
            TempPackageName.Buffer += TempPackageName.MaximumLength / sizeof(WCHAR);
        }
        ASSERT(FoundEntry);
    }

    if (NewPackageLength-sizeof(WCHAR) > MAXUSHORT) {
        if (NewPackageList->Buffer) {
            LocalFree(NewPackageList->Buffer);
            NewPackageList->Buffer = NULL;
        }
        Status = STATUS_INVALID_PARAMETER;
    } else {
        NewPackageList->Length = (USHORT) NewPackageLength-sizeof(WCHAR);
        NewPackageList->MaximumLength = (USHORT) NewPackageLength;
    }
    LocalFree(OldPackageListNull.Buffer);
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
FindPackageName(
    IN PUNICODE_STRING PackageList,
    IN PUNICODE_STRING PackageName
    )
{
    UNICODE_STRING TempString;

    TempString.Buffer = PackageList->Buffer;
    TempString.Length = 0;
    TempString.MaximumLength = PackageList->MaximumLength;

    //
    // Search through looking for '\0'
    //
    while (((TempString.Buffer + (TempString.Length / sizeof(WCHAR))) <
            (PackageList->Buffer + PackageList->Length/sizeof(WCHAR))) &&
            (TempString.Buffer[TempString.Length/sizeof(WCHAR)] != L'\0'))
    {
        TempString.Length += sizeof(WCHAR);

    }



    while (TempString.Buffer < PackageList->Buffer + PackageList->Length/sizeof(WCHAR))
    {
        //
        // If the packageName doesn't match, copy it to the new string.
        //

        if (RtlEqualUnicodeString(
                PackageName,
                &TempString,
                TRUE
                ))
        {
            return(TRUE);
        }

        TempString.Buffer = TempString.Buffer + (TempString.Length/sizeof(WCHAR)) + 1;
        TempString.Length = 0;

        while (((TempString.Buffer + (TempString.Length / sizeof(WCHAR))) <
                (PackageList->Buffer + PackageList->Length/sizeof(WCHAR))) &&
                (TempString.Buffer[TempString.Length/sizeof(WCHAR)] != L'\0'))
        {
            TempString.Length += sizeof(WCHAR);

        }


    }
    return(FALSE);

}


NTSTATUS
SampQueryUserSupplementalCredentials(
    IN PSAMP_OBJECT UserContext,
    OUT PUNICODE_STRING SupplementalCredentials
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       EncryptedSupplementalCredentialLength=0;
    PVOID       EncryptedSupplementalCredentials=NULL;
    ATTRTYP     AttrTyp[] = {SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS};
    ATTRVAL     AttrVals[] = {1, NULL};
    DEFINE_ATTRBLOCK1(AttrsToRead,AttrTyp,AttrVals);
    ATTRBLOCK   ReadAttrs;


    //
    // Parameter Validation
    //

    if (!IsDsObject(UserContext))
         return STATUS_INVALID_PARAMETER;

    //
    // Initialize Return Values
    //

    RtlSecureZeroMemory(SupplementalCredentials,sizeof(UNICODE_STRING));

     //
     // Check the context to see if any supplemental credentials are
     // already cached
     //
     if (UserContext->TypeBody.User.CachedSupplementalCredentialsValid)
     {
         EncryptedSupplementalCredentials =
             UserContext->TypeBody.User.CachedSupplementalCredentials;
         EncryptedSupplementalCredentialLength =
             UserContext->TypeBody.User.CachedSupplementalCredentialLength;
     }
     else
     {
         //
         // Read the Database for the supplemental credentials
         //

        NtStatus = SampDsRead(
                        UserContext->ObjectNameInDs,
                        0,
                        SampUserObjectType,
                        &AttrsToRead,
                        &ReadAttrs
                        );
        if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
        {
            //
            // Attribute has never been set, in which case ignore the
            // error
            //

            NtStatus = STATUS_SUCCESS;
            EncryptedSupplementalCredentialLength = 0;
            EncryptedSupplementalCredentials = NULL;
        }
        else if (NT_SUCCESS(NtStatus))
        {
            if ((1==ReadAttrs.attrCount)
                && (NULL!=ReadAttrs.pAttr)
                && (1== ReadAttrs.pAttr[0].AttrVal.valCount)
                && (NULL!=ReadAttrs.pAttr[0].AttrVal.pAVal))
            {
                EncryptedSupplementalCredentials =
                    ReadAttrs.pAttr[0].AttrVal.pAVal[0].pVal;
                EncryptedSupplementalCredentialLength =
                    ReadAttrs.pAttr[0].AttrVal.pAVal[0].valLen;

            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
     }

     //
     // If we successfully read any supplemental credentials, then
     // decrypt it.
     //

     if ((NT_SUCCESS(NtStatus)) && (EncryptedSupplementalCredentialLength>0))
     {
         ULONG Length;
         ULONG Format;


         NtStatus = SampDecryptCredentialData(
                       EncryptedSupplementalCredentialLength,
                       UserContext->TypeBody.User.Rid,
                       (PCREDENTIAL_DATA)EncryptedSupplementalCredentials,
                       &Length,
                       &Format,
                       (PVOID *) &SupplementalCredentials->Buffer
                       );

         ASSERT(SAMP_USER_PARAMETERS_FORMAT==Format);
         if (!NT_SUCCESS(NtStatus))
         {
             goto Error;
         }

         SupplementalCredentials->Length = (USHORT) Length;
         SupplementalCredentials->MaximumLength = (USHORT) Length;

     }

Error:

     return NtStatus;
}



NTSTATUS
SampSetUserSupplementalCredentials(
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING SupplementalCredentials
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRTYP     AttrTyp[] = {SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS};
    ATTRVAL     AttrVals[] = {SupplementalCredentials->Length, (UCHAR *)SupplementalCredentials->Buffer};
    DEFINE_ATTRBLOCK1(AttrsToSet,AttrTyp,AttrVals);
    ATTRBLOCK   ReadAttrs;
    ULONG       EncryptedLength;
    PCREDENTIAL_DATA  EncryptedData = NULL;


    //
    // Parameter Validation
    //
     if (!IsDsObject(UserContext))
         return STATUS_INVALID_PARAMETER;

     //
     // Encrypt this Data
     //

     NtStatus = SampEncryptCredentialData(
                    SAMP_USER_PARAMETERS_FORMAT,
                    SupplementalCredentials->Length,
                    UserContext->TypeBody.User.Rid,
                    (PVOID) SupplementalCredentials->Buffer,
                    FALSE,
                    &EncryptedLength,
                    &EncryptedData
                    );

     if (!NT_SUCCESS(NtStatus))
     {
         goto Error;
     }

     //
     // patch up the attr block
     //

     AttrsToSet.pAttr[0].AttrVal.pAVal[0].pVal = (PUCHAR) EncryptedData;
     AttrsToSet.pAttr[0].AttrVal.pAVal[0].valLen = EncryptedLength;



     //
     // Store this in the DS
     //

     NtStatus = SampDsSetAttributes(
                    UserContext->ObjectNameInDs,
                    0,
                    REPLACE_ATT,
                    SampUserObjectType,
                    &AttrsToSet
                    );



Error:

    if (NULL!=EncryptedData) {
        RtlSecureZeroMemory(EncryptedData, EncryptedLength);
        LocalFree(EncryptedData);
    }

    return NtStatus;
}






//+-------------------------------------------------------------------------
//
//  Function:   SamIStorePrimaryCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SampStoreCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials,
    IN BOOLEAN Primary
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING OldPackageList;
    UNICODE_STRING NewPackageList;
    UNICODE_STRING OldUserParameters;
    UNICODE_STRING NewUserParameters;
    UNICODE_STRING UserParameters;
    UNICODE_STRING EmptyString;
    UNICODE_STRING NewCredentials;
    BOOL Update = FALSE;
    WCHAR Flags;
    LPWSTR PackageName = NULL;
    LPWSTR CredentialTag = NULL;

    //
    // Initialize local variables
    // 
    memset(&OldPackageList, 0, sizeof(UNICODE_STRING));
    memset(&NewPackageList, 0, sizeof(UNICODE_STRING));
    memset(&OldUserParameters, 0, sizeof(UNICODE_STRING));
    memset(&NewUserParameters, 0, sizeof(UNICODE_STRING));
    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
    memset(&NewCredentials, 0, sizeof(UNICODE_STRING));

    RtlInitUnicodeString(
        &EmptyString,
        NULL
        );


    //
    // Get the old user parameters
    //


    Status = SampQueryUserSupplementalCredentials(
                (PSAMP_OBJECT) UserHandle,
                &OldUserParameters
                );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Build the package cred tag
    //

    if (Primary)
    {
        PackageName = (LPWSTR) LocalAlloc(0,sizeof(PRIMARY_CRED_PREFIX) + Credentials->PackageName.Length);
        if (PackageName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            PackageName,
            PRIMARY_CRED_PREFIX,
            sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            PackageName + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            Credentials->PackageName.Buffer,
            Credentials->PackageName.Length
            );
        PackageName[(sizeof(PRIMARY_CRED_PREFIX) + Credentials->PackageName.Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        PackageName = (LPWSTR) LocalAlloc(0,sizeof(SUPP_CRED_PREFIX) + Credentials->PackageName.Length);
        if (PackageName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            PackageName,
            SUPP_CRED_PREFIX,
            sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            PackageName + (sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            Credentials->PackageName.Buffer,
            Credentials->PackageName.Length
            );
        PackageName[(sizeof(SUPP_CRED_PREFIX) + Credentials->PackageName.Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }

    //
    // Get the list of package names out of the PrimaryCred value
    //

    Status = QueryUserPropertyWithLength(
                (PUNICODE_STRING) &OldUserParameters,
                PACKAGE_LIST,
                &Flags,
                &OldPackageList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Check whether the credentials' Package Name is in the PackagList or not
    // 

    if (!FindPackageName(
            &OldPackageList, 
            &Credentials->PackageName))
    {
        //
        // Package Name not in the PackageList, add it and 
        // store the new PackageList
        // 
        Status = BuildNewPackageList(
                    &OldPackageList, 
                    &Credentials->PackageName, 
                    &NewPackageList, 
                    FALSE
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SetUserPropertyWithLength(
                    (PUNICODE_STRING) &OldUserParameters, 
                    PACKAGE_LIST, 
                    &NewPackageList, 
                    USER_PROPERTY_TYPE_SET, 
                    &UserParameters.Buffer, 
                    &Update
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        RtlInitUnicodeString(
            &UserParameters, 
            UserParameters.Buffer
            );
    }
    else
    {
        UserParameters = *(PUNICODE_STRING) &OldUserParameters;
    }


    //
    // Now store the new credentials.
    // If the new credentials is NULL or 0 length. Then the worker 
    // routine - SetUserPropertyWithLength() will remove the 
    // Credentials from the intern structure. However, we still 
    // Have the PackageName in the PackageList field. So we know
    // this is a 0 Length value Credentials.
    //

    if (Credentials->CredentialSize > 0xffff)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    NewCredentials.Buffer = (LPWSTR) Credentials->Credentials;
    NewCredentials.Length = NewCredentials.MaximumLength = (USHORT) Credentials->CredentialSize;

    Status = SetUserPropertyWithLength(
                &UserParameters,
                PackageName,
                &NewCredentials,
                USER_PROPERTY_TYPE_ITEM,
                &NewUserParameters.Buffer,
                &Update
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the parameters changed, write them back to SAM
    //

    if (Update)
    {
        RtlInitUnicodeString(
            &NewUserParameters,
            NewUserParameters.Buffer
            );

        Status = SampSetUserSupplementalCredentials(
                    (PSAMP_OBJECT) UserHandle,
                    &NewUserParameters
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


Cleanup:
    if (OldPackageList.Buffer != NULL)
    {
        LocalFree(OldPackageList.Buffer);
    }
    if (NewPackageList.Buffer != NULL)
    {
        LocalFree(NewPackageList.Buffer);
    }

    if (NewUserParameters.Buffer != NULL)
    {
        RtlSecureZeroMemory(NewUserParameters.Buffer, NewUserParameters.MaximumLength);
        LocalFree(NewUserParameters.Buffer);
    }
    if ((UserParameters.Buffer != NULL) &&
        (UserParameters.Buffer != OldUserParameters.Buffer))

    {
        RtlSecureZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
        LocalFree(UserParameters.Buffer);
    }
    if (OldUserParameters.Buffer!=NULL)
    {
        RtlSecureZeroMemory(OldUserParameters.Buffer, OldUserParameters.MaximumLength);
        LocalFree(OldUserParameters.Buffer);
    }

    if (PackageName != NULL)
    {
        LocalFree(PackageName);
    }


    return(Status);
}




NTSTATUS
SampRemoveCredentials(
    IN PUNICODE_STRING SupplementalCredentials,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT BOOL *Update,
    OUT PUNICODE_STRING NewSupplementalCredentials
    )
{

    NTSTATUS    Status;
    
    UNICODE_STRING  OldPackageList;
    UNICODE_STRING  NewPackageList;
    UNICODE_STRING  EmptyString;
    LPWSTR  CredentialTag = NULL ;
    WCHAR   *Buffer = NULL;
    WCHAR   Flags;


    //
    // Initialize local variables.
    // 
    
    memset(&OldPackageList, 0, sizeof(UNICODE_STRING));
    memset(&NewPackageList, 0, sizeof(UNICODE_STRING));

    RtlInitUnicodeString( &EmptyString, NULL );

    *Update = FALSE;


    //
    // Build the package cred tag
    //

    if (Primary)
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag, 
            PRIMARY_CRED_PREFIX,
            sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(SUPP_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag,
            SUPP_CRED_PREFIX,
            sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(SUPP_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }

    //
    // Get the list of package names out of the PrimaryCred value
    //

    Status = QueryUserPropertyWithLength(
                SupplementalCredentials,
                PACKAGE_LIST,
                &Flags,
                &OldPackageList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Remove the PackageName from the PackageList field, 
    // then store the updated PackageList
    // 
    if (FindPackageName(
            &OldPackageList, 
            PackageName))
    {
        Status = BuildNewPackageList(
                    &OldPackageList, 
                    PackageName, 
                    &NewPackageList, 
                    TRUE        // remove package
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SetUserPropertyWithLength(
                    SupplementalCredentials, 
                    PACKAGE_LIST, 
                    &NewPackageList, 
                    USER_PROPERTY_TYPE_SET, 
                    &Buffer, 
                    Update
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        RtlInitUnicodeString(
            NewSupplementalCredentials, 
            Buffer
            );
    }
    else
    {
        //
        // PackageName is not in the PackageList 
        // Nothing further to do.
        // 

        //
        // N.B. When Update is set to FALSE, NewSupplementalCredentials
        // doesn't need to be set.
        //
        *Update = FALSE;
        goto Cleanup;
    }


    //
    // Now remove the value of the Credentials from the 
    // SupplementalCredentials attribute. 
    //

    Status = SetUserPropertyWithLength(
                NewSupplementalCredentials,
                CredentialTag,
                &EmptyString,
                USER_PROPERTY_TYPE_ITEM,
                &NewSupplementalCredentials->Buffer,
                Update
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the parameters changed, write them back to SAM
    //

    if (*Update)
    {
        RtlInitUnicodeString(
            NewSupplementalCredentials,
            NewSupplementalCredentials->Buffer
            );

    }


Cleanup:
    if (OldPackageList.Buffer != NULL)
    {
        LocalFree(OldPackageList.Buffer);
    }
    if (NewPackageList.Buffer != NULL)
    {
        LocalFree(NewPackageList.Buffer);
    }

    if (CredentialTag != NULL)
    {
        LocalFree(CredentialTag);
    }

    //
    // N.B. Buffer is freed in SetUserPropertyWithLength if necessary
    //

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SamIRetrievePrimaryCredentiala
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"

NTSTATUS
SampRetrieveCredentialsFromList(
    IN OUT PUNICODE_STRING CredentialList,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    LPWSTR CredentialTag = NULL;
    WCHAR Flags;
    UNICODE_STRING PackageList;
    UNICODE_STRING PackageCreds;
    UNICODE_STRING ClearTextPackageName;
    UNICODE_STRING OldUserParameters;

    memset(&PackageList, 0, sizeof(UNICODE_STRING));
    memset(&PackageCreds, 0, sizeof(UNICODE_STRING));
    memset(&ClearTextPackageName,0,sizeof(UNICODE_STRING));
    memset(&OldUserParameters,0,sizeof(UNICODE_STRING));

    //
    // Build the package cred tag
    //

    if (Primary)
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag,
            PRIMARY_CRED_PREFIX,
            sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(SUPP_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag,
            SUPP_CRED_PREFIX,
            sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(SUPP_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }

    OldUserParameters.Buffer = (WCHAR*)LocalAlloc(0, CredentialList->Length);
    if (NULL == OldUserParameters.Buffer) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlCopyMemory(OldUserParameters.Buffer,
                  CredentialList->Buffer,
                  CredentialList->Length);
    OldUserParameters.Length = CredentialList->Length;
    OldUserParameters.MaximumLength = CredentialList->MaximumLength;


    //
    // Get the Package List 
    //

    Status = QueryUserPropertyWithLength(
                &OldUserParameters, 
                PACKAGE_LIST, 
                &Flags, 
                &PackageList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (FindPackageName(
            &PackageList, 
            PackageName)
        )
    {
        //
        // Get the credentials from the parameters
        //

        Status = QueryUserPropertyWithLength(
                    &OldUserParameters,
                    CredentialTag,
                    &Flags,
                    &PackageCreds
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        *Credentials = PackageCreds.Buffer;
        *CredentialSize = PackageCreds.Length;
    }
    else
    {               
        //
        // PackageName is presented in the PackageList, 
        // it means this credentials is not stored previously.
        // 
        *Credentials = NULL;
        *CredentialSize = 0;
        Status = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
    }

Cleanup:

    if (OldUserParameters.Buffer != NULL)
    {
        RtlSecureZeroMemory(OldUserParameters.Buffer, OldUserParameters.MaximumLength);
        LocalFree(OldUserParameters.Buffer);
    }
    if (PackageList.Buffer != NULL)
    {
        LocalFree(PackageList.Buffer);
    }
    if (CredentialTag != NULL)
    {
        LocalFree(CredentialTag);
    }

    return(Status);
}


NTSTATUS
SampRetrieveCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
    NTSTATUS Status;
    LPWSTR CredentialTag = NULL;
    WCHAR Flags;
    UNICODE_STRING OldUserParameters;
    UNICODE_STRING PackageList;
    UNICODE_STRING PackageCreds;
    UNICODE_STRING ClearTextPackageName;
    PSAMP_OBJECT    AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN fClearTextRequired = FALSE;


    memset(&OldUserParameters, 0, sizeof(UNICODE_STRING));
    memset(&PackageList, 0, sizeof(UNICODE_STRING));
    memset(&PackageCreds, 0, sizeof(UNICODE_STRING));
    
    RtlInitUnicodeString(&ClearTextPackageName, L"CLEARTEXT");
    fClearTextRequired =  RtlEqualUnicodeString(&ClearTextPackageName, 
                                                 PackageName, 
                                                 TRUE  // Case Insensitive 
                                                 );

    // check the Domain User settings
    if ( fClearTextRequired )
    {
        AccountContext = (PSAMP_OBJECT)UserHandle;
        Status = SampRetrieveUserV1aFixed(
                        AccountContext,
                        &V1aFixed
                        );
        if (!NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }
    
        Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

        if ( ((Domain->UnmodifiedFixed.PasswordProperties & DOMAIN_PASSWORD_STORE_CLEARTEXT) == 0) 
             && ((V1aFixed.UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED) == 0)) {
            *Credentials = NULL;
            *CredentialSize = 0;
            Status = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
            goto Cleanup;
        }

    }

    //
    // Get the old supplemental credentials
    //
    Status = SampQueryUserSupplementalCredentials(
                (PSAMP_OBJECT) UserHandle,
                &OldUserParameters
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SampRetrieveCredentialsFromList(&OldUserParameters,
                                             PackageName,
                                             Primary,
                                             Credentials,
                                             CredentialSize);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    if (OldUserParameters.Buffer != NULL)
    {
        RtlSecureZeroMemory(OldUserParameters.Buffer, OldUserParameters.MaximumLength);
        LocalFree(OldUserParameters.Buffer);
    }

    return(Status);
}

NTSTATUS
SamIStorePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    )
{
  NTSTATUS NtStatus = STATUS_SUCCESS;
  BOOLEAN  fLockAcquired = FALSE;
  BOOLEAN  fDereferenceContext = FALSE;
  SAMP_OBJECT_TYPE  FoundType;

  SAMTRACE("SamIStorePriamryCredentials");

  if (!SampUseDsData)
  {
      return(STATUS_NOT_SUPPORTED);
  }

  //
  // Acquire Write Lock
  // 
  NtStatus = SampAcquireWriteLock();
  if (!NT_SUCCESS(NtStatus))
  {
      goto Cleanup;
  }

  fLockAcquired = TRUE;
  
  //
  // Validate the Passed in context
  //

  NtStatus = SampLookupContext(
                (PSAMP_OBJECT) UserHandle, 
                0, 
                SampUserObjectType, 
                &FoundType
                );

  if (!NT_SUCCESS(NtStatus))
  {
      goto Cleanup;
  }

  fDereferenceContext = TRUE;

  NtStatus = SampStoreCredentials(
                UserHandle,
                Credentials,
                TRUE
                );

  if (NT_SUCCESS(NtStatus))
  {
      //
      // Commite and release write lock
      // 
      NtStatus = SampReleaseWriteLock(TRUE);
      fLockAcquired = FALSE;
  }

Cleanup:

    if (fDereferenceContext)
    {
        SampDeReferenceContext((PSAMP_OBJECT) UserHandle, FALSE);
    }

    if (fLockAcquired)
    {
        SampReleaseWriteLock(FALSE);
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}



NTSTATUS
SamIRetrievePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
  NTSTATUS NtStatus = STATUS_SUCCESS;

  BOOLEAN  fLockAcquired = FALSE;
  BOOLEAN  fContextReferenced = FALSE;
  NTSTATUS IgnoreStatus;
  SAMP_OBJECT_TYPE FoundType;

  SAMTRACE("SamIRetrievePrimaryCredentials");

    //
    // Additional credential types are supported only in DS mode.
    //

    if (!IsDsObject(((PSAMP_OBJECT)UserHandle)))
    {
        NtStatus = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Acquire the read lock if necessary
    //

    SampMaybeAcquireReadLock((PSAMP_OBJECT)UserHandle,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Lookup the context
    //

    NtStatus = SampLookupContext(
                    (PSAMP_OBJECT) UserHandle,
                    0,
                    SampUserObjectType,
                    &FoundType
                    );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    fContextReferenced = TRUE;

    //
    // Retrieve the credentials
    //

    NtStatus = SampRetrieveCredentials(
                    UserHandle,
                    PackageName,
                    TRUE,
                    Credentials,
                    CredentialSize
                    );


Cleanup:

    //
    // Derefence the context
    //

    if (fContextReferenced)
    {
        IgnoreStatus = SampDeReferenceContext((PSAMP_OBJECT) UserHandle, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }
        
    SampMaybeReleaseReadLock(fLockAcquired);


    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}

extern "C" 
{

NTSTATUS
SampAddSupplementalCredentials(
    IN PSECPKG_SUPPLEMENTAL_CRED Credential,
    IN PUNICODE_STRING OldUserParameters,
    OUT PUNICODE_STRING NewUserParameters,
    OUT BOOL  * Update
    )
    
/*++

Routine Description:

    This routine add one Credential data to OldUserParameters, return the NewUserParameters.
    
Arguments:
    
    Credential - Pointer, to the supplemental crdentials.
    
    OldUserParameters - Pointer, to the old data.
    
    NewUserParameters - Pointer, return the new data.
    
    Update - Indicate whether the data is changed or not.
    
    
    Note: --- We use OldUserParameters, NewUserParameters, but the actual data in OldUserParameters
              and NewUserParameter is Credential Data ! OldUserParameter is used because of following
              the old naming convention. 

Return Values:

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    UNICODE_STRING OldPackageList;
    UNICODE_STRING NewPackageList;
    UNICODE_STRING UserParameters;
    UNICODE_STRING EmptyString;
    UNICODE_STRING NewCredential;
    WCHAR       Flags;
    LPWSTR      PackageName = NULL;
     
    
    SAMTRACE("SampAddSupplementalCredentials");
    
    // 
    // initialize
    // 
    
    *Update = FALSE; 
    memset(&OldPackageList, 0, sizeof(UNICODE_STRING));
    memset(&NewPackageList, 0, sizeof(UNICODE_STRING));
    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
    memset(&NewCredential, 0, sizeof(UNICODE_STRING));
    
    RtlInitUnicodeString(
            &EmptyString,
            NULL
            );
    
    // 
    // Build the package cred tag
    //
    // SAM stored PrimaryCredentials and Supplemental Credentials is one continue 
    // blob. To discriminate Primary and Supplemental credentials, SAM put a tag 
    // of either "Primary" or "Supplemental" before the credential package name to 
    // distinguish them. Thus if you store a credential as primary credentials, it 
    // will show up in the blob as "Primary:Package Name ....". So you won't retrieve 
    // it by issue SamIRetrieveSupplementalCredentials. Client needs to use corresponding 
    // API to retrieve credentials as they store them. 
    // 
    // Think about RAS, they always use SamIRetrievePrimaryCredentials to retrieve 
    // password, so we'd better store any encrypted attribute in Primary credentials. 
    // 
    PackageName = (LPWSTR) LocalAlloc(LPTR, sizeof(PRIMARY_CRED_PREFIX) + Credential->PackageName.Length);
    
    if (NULL == PackageName)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    RtlCopyMemory(PackageName, 
                  PRIMARY_CRED_PREFIX,
                  sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
                  );
                  
    RtlCopyMemory(PackageName + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
                  Credential->PackageName.Buffer,
                  Credential->PackageName.Length
                  );
                  
    PackageName[(sizeof(PRIMARY_CRED_PREFIX) + Credential->PackageName.Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    
    
    //
    // Get the list of package names out the SupplementalCred value
    //
    NtStatus = QueryUserPropertyWithLength(
                        (PUNICODE_STRING) OldUserParameters,
                        PACKAGE_LIST,
                        &Flags,
                        &OldPackageList
                        );
                        
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    
    // 
    // if the buffer of the credential is NULL, then we are deleting 
    // the credential. Otherwise we are adding them.
    //
    
    //
    // Add the package name to the list
    // 
    if (!FindPackageName(
                    &OldPackageList,
                    &Credential->PackageName)
       )
    {
        NtStatus = BuildNewPackageList(
                        &OldPackageList,
                        &Credential->PackageName,
                        &NewPackageList,
                        FALSE                   // Don't remove package
                        );
                            
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
            
        NtStatus = SetUserPropertyWithLength(
                        OldUserParameters,
                        PACKAGE_LIST,
                        &NewPackageList,
                        USER_PROPERTY_TYPE_SET,
                        &UserParameters.Buffer,
                        Update
                        );
                                            
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
            
        RtlInitUnicodeString(
                &UserParameters,
                UserParameters.Buffer
                );
            
    }
    else
    {
        UserParameters = * OldUserParameters; 
    }
        
    //
    // Now store the new credentials
    //
        
    if (Credential->CredentialSize > 0xffff)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
        
    NewCredential.Buffer = (LPWSTR) Credential->Credentials;
    NewCredential.Length = (USHORT) Credential->CredentialSize;
    NewCredential.MaximumLength = (USHORT) Credential->CredentialSize;
    
    NtStatus = SetUserPropertyWithLength(
                        &UserParameters,
                        PackageName,
                        &NewCredential,
                        USER_PROPERTY_TYPE_ITEM,
                        &NewUserParameters->Buffer,
                        Update
                        );
        
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    
    
    if (*Update)
    {
        RtlInitUnicodeString(NewUserParameters,
                             NewUserParameters->Buffer
                             );
    }

Cleanup:

    if (NULL != UserParameters.Buffer &&
        UserParameters.Buffer != OldUserParameters->Buffer)
    {
        RtlSecureZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
        LocalFree(UserParameters.Buffer);
    }
    
    if (NULL != PackageName)
    {
        LocalFree(PackageName);
    }
    
    
    if (NULL != OldPackageList.Buffer)
    {
        LocalFree(OldPackageList.Buffer);
    }
    
    if (NULL != NewPackageList.Buffer)
    {
        LocalFree(NewPackageList.Buffer);
    }

    
    return NtStatus;

}




NTSTATUS
SampConvertCredentialsFromListToAttr(
    IN OUT PUNICODE_STRING UserParameters,
    IN ULONG   Flags,
    IN ULONG   ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr 
    )
    
/*++

Routine Description:

    This routine packs all supplemental credentials into single ATTR structure

Arguments:

    Context - Pointer, to SAM User object's context.
    
    Flags - Indicate where during NT4->NT5 upgrade dcpromote or not.
    
    ObjectRid - Object's Relative ID, used to encrypt credential data.
    
    SupplementalCredentials - link list, contains all supplemental credentials to set.
    
    CredentialAttr - Pointer, used to return the single ATTR structure. 

Return Values:

    STATUS_SUCCESS - CredentialAttr will contain the well-constructed ATTR structure to set.
    
    STATUS_NO_MEMORY.

--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  TmpUserParameters;
    BOOL            Update = FALSE;
    ULONG             EncryptedLength;
    PCREDENTIAL_DATA  EncryptedData = NULL;
    PSAMP_SUPPLEMENTAL_CRED  Credential = SupplementalCredentials;  
    
    SAMTRACE("SampConvertCredentialsToAttr");
    
    // 
    // initialize
    //  
    memset(&TmpUserParameters, 0, sizeof(UNICODE_STRING));
    
    // 
    // Add Supplemental Credentials one by one
    //
    while (Credential)
    {
        if (Credential->Remove)
        {

            NtStatus = SampRemoveCredentials(
                            UserParameters,
                            & Credential->SupplementalCred.PackageName,
                            TRUE,
                            &Update,
                            &TmpUserParameters
                            );
        }
        else
        {
            NtStatus = SampAddSupplementalCredentials(&(Credential->SupplementalCred),
                                                  UserParameters,
                                                  &TmpUserParameters, 
                                                  &Update
                                                  );
        }
                                                    
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
        else
        {
            if (Update)
            {
                ASSERT(NULL != TmpUserParameters.Buffer);
                
                if (NULL != UserParameters->Buffer)
                {
                    RtlSecureZeroMemory(UserParameters->Buffer, UserParameters->MaximumLength);
                    LocalFree(UserParameters->Buffer);
                    memset(UserParameters, 0, sizeof(UNICODE_STRING));
                }
                
                *UserParameters = TmpUserParameters;
                memset(&TmpUserParameters, 0, sizeof(UNICODE_STRING));
            }
            else
            {
                if (NULL != TmpUserParameters.Buffer)
                {
                    RtlSecureZeroMemory(TmpUserParameters.Buffer, TmpUserParameters.MaximumLength);
                    LocalFree(TmpUserParameters.Buffer);
                }
                memset(&TmpUserParameters, 0, sizeof(UNICODE_STRING));
            }
        }
    
        Credential = Credential->Next;
    }

    //
    // Encrypt credential data
    //
    NtStatus = SampEncryptCredentialData(
                   SAMP_USER_PARAMETERS_FORMAT,
                   UserParameters->Length,
                   ObjectRid,
                   (PVOID) UserParameters->Buffer,
                   (Flags & SAM_USERPARMS_DURING_UPGRADE)?TRUE:FALSE,
                   &EncryptedLength,
                   &EncryptedData
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // patch up the attr 
    //
    CredentialAttr->AttrVal.pAVal = (ATTRVAL *) MIDL_user_allocate(sizeof(ATTRVAL)); 
    
    if (NULL == CredentialAttr->AttrVal.pAVal)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    RtlSecureZeroMemory(CredentialAttr->AttrVal.pAVal, sizeof(ATTRVAL));
    
    CredentialAttr->attrTyp = ATT_SUPPLEMENTAL_CREDENTIALS;
    CredentialAttr->AttrVal.valCount = 1;
    
    CredentialAttr->AttrVal.pAVal[0].pVal = (PUCHAR) MIDL_user_allocate(EncryptedLength);
    
    if (NULL == CredentialAttr->AttrVal.pAVal[0].pVal)
    {
        MIDL_user_free(CredentialAttr->AttrVal.pAVal);
        CredentialAttr->AttrVal.pAVal = NULL;
        CredentialAttr->AttrVal.valCount = 0;
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    CredentialAttr->AttrVal.pAVal[0].valLen = EncryptedLength;
    
    RtlSecureZeroMemory(CredentialAttr->AttrVal.pAVal[0].pVal, EncryptedLength);
    
    RtlCopyMemory(CredentialAttr->AttrVal.pAVal[0].pVal, 
                  EncryptedData, 
                  EncryptedLength
                  );


Cleanup:

    if (NULL != UserParameters->Buffer)
    {
        RtlSecureZeroMemory(UserParameters->Buffer, UserParameters->MaximumLength);
        LocalFree(UserParameters->Buffer);
        RtlSecureZeroMemory(UserParameters, sizeof(*UserParameters));
    }

    if (NULL != TmpUserParameters.Buffer)
    {
        RtlSecureZeroMemory(TmpUserParameters.Buffer, TmpUserParameters.MaximumLength);
        LocalFree(TmpUserParameters.Buffer);
    }
    
    if (NULL != EncryptedData)
    {
        RtlSecureZeroMemory(EncryptedData, EncryptedLength);
        LocalFree(EncryptedData);
    }
    
    return NtStatus;    

}


NTSTATUS
SampConvertCredentialsToAttr(
    IN PSAMP_OBJECT Context,
    IN ULONG   Flags,
    IN ULONG   ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr 
    )
    
/*++

Routine Description:

    This routine packs all supplemental credentials into single ATTR structure

Arguments:

    Context - Pointer, to SAM User object's context.
    
    Flags - Indicate where during NT4->NT5 upgrade dcpromote or not.
    
    ObjectRid - Object's Relative ID, used to encrypt credential data.
    
    SupplementalCredentials - link list, contains all supplemental credentials to set.
    
    CredentialAttr - Pointer, used to return the single ATTR structure. 

Return Values:

    STATUS_SUCCESS - CredentialAttr will contain the well-constructed ATTR structure to set.
    
    STATUS_NO_MEMORY.

--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  UserParameters;
    
    // Note: --- We use OldUserParameters, TmpUserParameters, but the actual data in OldUserParameters
    //           and TmpUserParameter is Credential Data! 
    //           OldUserParameter is used because of following the old naming convention. 
    
    
    SAMTRACE("SampConvertCredentialsToAttr");
    
    ASSERT(ARGUMENT_PRESENT(Context) || (Flags & SAM_USERPARMS_DURING_UPGRADE)); 

    // 
    // initialize
    //  
    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
    
    //
    // in NT4->NT5 upgrade case the Context is not well-constructed, 
    // and there is not SupplementalCredential attribute in NT4 scenario, so no need to 
    // QueryUserSupplementCredentials
    // 
    if ( !(Flags & SAM_USERPARMS_DURING_UPGRADE) )
    {
        NtStatus = SampQueryUserSupplementalCredentials(
                                Context, 
                                &UserParameters
                                );
        
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
            
        Context->TypeBody.User.CachedSupplementalCredentialsValid = FALSE;
    }

    NtStatus = SampConvertCredentialsFromListToAttr(&UserParameters,
                                                    Flags,
                                                    ObjectRid,
                                                    SupplementalCredentials,
                                                    CredentialAttr);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    
Cleanup:

    if (NULL != UserParameters.Buffer)
    {
        RtlSecureZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
        LocalFree(UserParameters.Buffer);
    }

    return NtStatus;    

}

NTSTATUS
SampDecryptSupplementalCredentials(
    IN PUNICODE_STRING  EncryptedSupplementalCreds,
    IN ULONG            Rid,
    OUT PUNICODE_STRING ClearSupplementalCreds
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    // Init the out parameter
    //
    RtlSecureZeroMemory(ClearSupplementalCreds, sizeof(*ClearSupplementalCreds));

    if (EncryptedSupplementalCreds->Length > 0) {

        ULONG Length;
        ULONG Format;
    
        NtStatus = SampDecryptCredentialData(EncryptedSupplementalCreds->Length,
                                             Rid,
                                             (PCREDENTIAL_DATA)EncryptedSupplementalCreds->Buffer,
                                             &Length,
                                             &Format,
                                            (PVOID *) &ClearSupplementalCreds->Buffer
                                            );
        if (!NT_SUCCESS(NtStatus)) {
            goto Error;
        }
        ASSERT(SAMP_USER_PARAMETERS_FORMAT == Format);
        ClearSupplementalCreds->Length = (USHORT) Length;
        ClearSupplementalCreds->MaximumLength = (USHORT) Length;

    }

Error:

     return NtStatus;
}


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\attr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    attr.c

Abstract:

    This file contains services that manipulate SAM object attributes.


    WARNING: Terminology can sometimes be confusing.  SAM objects have
             attributes (e.g., users have LogonHours, FullName, AcctName,
             et cetera).  These attributes are stored in the registry
             in registry-key-attributes.  There is NOT a one-to-one
             correllation between object-attributes and registry-key-
             attributes.  For example, all the fixed-length attributes
             of an object are stored in a single registry-key-attribute
             (whose name is pointed to by SampFixedAttributeName).


Author:

    Jim Kelly    (JimK)  26-June-1992

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    04-Jun-96
        Added routines for DS data manipulation.
    ChrisMay    10-Jun-96
        Rewrote SampStoreObjectAttributes to branch to either the registry
        or DS backing store, based on the value of Context->ObjectFlags. Note
        that when a context object is created, this member is set to indicate
        registry storage by default.
    ChrisMay    18-Jun-96
        Set FlushVariable flag correctly in SampStoreDsObjectAttributes. Add-
        ed routines to validate DS data by making SampValidateAttributes a
        wrapper for SampValidateRegAttributes and SampValidateDsAttributes.
        Moved SAMP_FIXED/VARIABLE_ATTRIBUTES into dsutilp.h.
    ChrisMay    25-Jun-96
        Added code to SampValidateDsAttributes to update the SAM context
        OnDisk member if the attributes are invalid. Added code to handle
        initial case when OnDisk is NULL (new context).
    ChrisMay    26-Jun-96
        Added code to update the buffer lengths and offsets in the SAMP_-
        OBJECT and SAMP_OBJECT_INFORMATION structures after the attribute
        buffer (Context.OnDisk) has been updated during SampDsValidateAttri-
        butes.
    ChrisMay    28-Jun-96
        Finished separating the attribute accessor macros to handle both
        the registry and DS versions of the attribute buffers.
    ChrisMay    02-Jul-96
        Corrected attribute-address computation in SampObjectAttributeAddress
        for DS attributes. Corrected attribute-offset computation in Samp-
        VariableAttributeOffset for DS attributes.
    ChrisMay    19-Jul-96
        Corrected buffer-length computation in SampDsUpdateContextFixed-
        Attributes.

--*/



/*

    Each SAM object-type has an Object-type descriptor.  This is in a
    data structure called SAMP_OBJECT_INFORMATION.  This structure
    contains information that applies to all instances of that object
    type.  This includes things like a mask of write operations for
    the object type, and a name for the object type to be used in
    auditing.

    Each instance of an open SAM object has another data structure
    used to identify it (called SAMP_OBJECT).  The header of this
    structure contains information that is common to all object-types
    and is there to allow unified object manipulation.  This includes
    things like the handle to the object's registry key.

    There are fields in each of these structures that are there to
    allow generic object-attribute support routines to operate.  In
    SAMP_OBJECT, there is a pointer to a block of allocated memory
    housing a copy of the object's attributes as they are stored on-disk.
    These attributes are arbitrarily divided into two groups: fixed-length
    and variable-length.

    One of the fields in SAMP_OBJECT_INFORMATION indicates whether the
    fixed-length and variable-length attributes for that object-type
    are stored together in a single registry-key-attribute or separately
    in two registry-key-attributes.


    The registry api for querying and setting registry-key attributes are
    rather peculiar in that they require the I/O buffer to include a
    description of the data.  Even the simplest data structure for reading
    attribute values (KEY_VALUE_PARTIAL_INFORMATION) includes 3 ULONGs
    before the actual data (TitleIndex, value Type, data length,
    and then, finally, the data).  To efficiently perform registry i/o,
    the in-memory copy of the on-disk object attributes includes room
    for this information preceeding the fixed and variable-length attribute
    sections of the data.


        NOTE: For object classes that store fixed and variable-length
              data together, only the KEY_VALUE_PARTIAL_INFORMATION
              structure preceeding the fixed-length attributes is used.
              The one preceeding the variable-length attributes is
              #ifdef'd out.


    The structures related to object-attributes look like:


                        On-Disk Image
                       +-------------+               SAMP_OBJECT_INFORMATION
                   +-->|KEY_VALUE_   |              +-----------------------+
     SAMP_OBJECT   |   |PARTIAL_     |              |                       |
    +-----------+  |   |INFORMATION  |              |  (header)             |
    |           |  |   |-------------|              |                       |
    | (header)  |  |   | Fixed-Length|<-----+       |                       |
    |           |  |   | Attributes  |      |       |-----------------------|
    |-----------|  |   |             |      +-------|-< FixedAttrsOffset    |
    |  OnDisk >-|--+   |-------------+              |-----------------------|
    |-----------|      |KEY_VALUE_   |<-------------|-< VariableBuffOffset  |
    |  OnDisk   |      |PARTIAL_     |              |-----------------------|
    |  Control  |      |INFORMATION  |      +-------|-< VariableArrayOffset |
    |  Flags    |      |(Optional)   |      |       |-----------------------|
    |-----------|      |-------------|      |  +----|-< VariableDataOffset  |
    |           |      | Variable-   |<-----+  |    |-----------------------|
    |  type-    |      | Length      |         |    |VariableAttributeCount |
    |  specific |      | Attributes  |         |    |-----------------------|
    |  body     |      | Array       |         |    |FixedStoredSeparately  |
    |           |      |-------------|         |    |-----------------------|
    +-----------+      | Variable-   |<--------+    |                       |
                       | Length      |              |                       |
                       | Attributes  |              |          o            |
                       | Data        |              |          o            |
                       |             |              +-----------------------+
                       |             |
                       +-------------+




    The KEY_VALUE_PARTIAL_INFORMATION preceeding the VariableLengthAttributes
    array is marked optional because it is only present if fixed-length and
    variable-length attribute information is stored separately.  In this case,
    the VariableBufferOffset field in the SAMP_OBJECT_INFORMATION structure
    is set to be zero.

*/



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <sdconvrt.h>
#include <lmcons.h>
#include <nturtl.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <attids.h>

#include <ntlsa.h>
//#include <nlrepl.h>



//
// This value indicates the minumum size block of memory to allocate
// when retrieving object attributes from disk.

#define SAMP_MINIMUM_ATTRIBUTE_ALLOC    (1000)

//
// This value is used when growing the size of the buffer containing
// object attributes.  It represents the amount of free space that
// should be left (approximately) for future growth in the buffer.
//

#define SAMP_MINIMUM_ATTRIBUTE_PAD      (200)

//
// The following line enables attribute debugging code
//

//#define SAM_DEBUG_ATTRIBUTES
//#ifdef SAM_DEBUG_ATTRIBUTES
//Boolean that allows us to turn off debugging output
//BOOLEAN SampDebugAttributes = FALSE;
//#endif

// Private debugging display routine is enabled when ATTR_DBG_PRINTF = 1.

#define ATTR_DBG_PRINTF                     0

#if (ATTR_DBG_PRINTF == 1)
#define DebugPrint printf
#else
#define DebugPrint
#endif



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Make sure an object type and corresponding variable-length attribute
// index are legitimate.
//

#define SampValidateAttributeIndex( c, i )   {                                      \
    ASSERT( ((c)->ObjectType < SampUnknownObjectType) );                            \
    ASSERT(((i) < SampObjectInformation[(c)->ObjectType].VariableAttributeCount) ); \
}

//
// Test to see if an object's fixed or variable-length attributes
// are in memory.
//

#define SampFixedAttributesValid( c )    ((c)->FixedValid)

#define SampVariableAttributesValid( c ) ((c)->VariableValid)

//
// Get the number of variable-length attributes defined for the
// specified object
//

#define SampVariableAttributeCount( c )                                     \
    (SampObjectInformation[(c)->ObjectType].VariableAttributeCount)

//
// Get the offset of the beginning of the attribute buffers
//

#define SampRegFixedBufferOffset( c )                                       \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].FixedAttributesOffset        \
    )

#define SampDsFixedBufferOffset( c )                                        \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].FixedDsAttributesOffset      \
    )

#define SampFixedBufferOffset( c )                                          \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFixedBufferOffset(c) : SampRegFixedBufferOffset(c)        \
    )

#define SampRegVariableBufferOffset( c )                                    \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableBufferOffset         \
    )

#define SampDsVariableBufferOffset( c )                                     \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDsBufferOffset       \
    )

#define SampVariableBufferOffset( c )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferOffset(c) : SampRegVariableBufferOffset(c)  \
    )

//
// Get the offset of the beginning of the variable data i/o buffer.
// If the fixed and variable-length attributes  are stored separately,
// then this will be the lower half of the buffer.
// Otherwise, there is only one buffer, so it is the entire allocated buffer.
//

#define SampRegFixedBufferAddress( c )                                      \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampFixedBufferOffset( c )                \
    )

#define SampDsFixedBufferAddress( c )                                       \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampDsFixedBufferOffset( c )              \
    )

#define SampFixedBufferAddress( c )                                         \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFixedBufferAddress(c): SampRegFixedBufferAddress(c)       \
    )

#define SampRegVariableBufferAddress( c )                                   \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampVariableBufferOffset( c )             \
    )

#define SampDsVariableBufferAddress( c )                                    \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampDsVariableBufferOffset( c )           \
    )

#define SampVariableBufferAddress( c )                                      \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferAddress(c) : SampRegVariableBufferAddress(c)\
    )

//
// Get the offset of the beginning of the variable-length
// attributes discriptors array.  This address is dword-aligned.
//

#define SampRegVariableArrayOffset( c )                                     \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableArrayOffset          \
    )

#define SampDsVariableArrayOffset( c )                                      \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDsArrayOffset        \
    )

#define SampVariableArrayOffset( c )                                        \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableArrayOffset(c) : SampRegVariableArrayOffset(c)    \
    )

//
// Calculate the address of the beginning of the variable-length
// attributes array.
//

#define SampRegVariableArrayAddress( c )                                    \
    (                                                                       \
        (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)((PUCHAR)((c)->OnDisk) +           \
            SampVariableArrayOffset( c ) )                                  \
    )

#define SampDsVariableArrayAddress( c )                                     \
    (                                                                       \
        (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)((PUCHAR)((c)->OnDisk) +           \
            SampDsVariableArrayOffset( c ) )                                \
    )

#define SampVariableArrayAddress( c )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableArrayAddress(c) : SampRegVariableArrayAddress(c)  \
    )

//
// Get the offset of the beginning of the variable-length
// attributes data.
//

#define SampRegVariableDataOffset( c )                                      \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDataOffset           \
    )

#define SampDsVariableDataOffset( c )                                       \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDsDataOffset         \
    )

#define SampVariableDataOffset( c )                                         \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableDataOffset(c) : SampRegVariableDataOffset(c)      \
    )

//
// Get the length of the on-disk buffer for holding the variable-length
// attribute array and data.  If the fixed and variable-length attributes
// are stored separately, then this will be the lower half of the buffer.
// Otherwise, there is only one buffer, so it is the entire allocated buffer.
//

#define SampRegFixedBufferLength( c )                                       \
    (                                                                       \
            SampObjectInformation[(c)->ObjectType].FixedLengthSize          \
    )

#define SampDsFixedBufferLength( c )                                        \
    (                                                                       \
            SampObjectInformation[(c)->ObjectType].FixedDsLengthSize        \
    )

#define SampFixedBufferLength( c )                                          \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFixedBufferLength(c) : SampRegFixedBufferLength(c)        \
    )

#define SampRegVariableBufferLength( c )                                    \
    (                                                                       \
            (c)->OnDiskAllocated - SampVariableBufferOffset( c )            \
    )

#define SampDsVariableBufferLength( c )                                     \
    (                                                                       \
            (c)->OnDiskAllocated - SampDsVariableBufferOffset( c )          \
    )

#define SampVariableBufferLength( c )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferLength(c) : SampRegVariableBufferLength(c)  \
    )

//
// Return the address of a Qualifier field within the variable-length
// attribute descriptor array.
//

#define SampRegVariableQualifier( c, i )                                    \
    (                                                                       \
        SampVariableArrayAddress( c ) +                                     \
        (sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE) * i)                        \
        + FIELD_OFFSET(SAMP_VARIABLE_LENGTH_ATTRIBUTE, Qualifier)           \
    )

#define SampDsVariableQualifier( c, i )                                     \
    (                                                                       \
        SampDsVariableArrayAddress( c ) +                                   \
        (sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE) * i)                        \
        + FIELD_OFFSET(SAMP_VARIABLE_LENGTH_ATTRIBUTE, Qualifier)           \
    )

#define SampVariableQualifier( c, i )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableQualifier(c, i) : SampRegVariableQualifier(c, i)  \
    )

//
// Return the address of the first byte of free space
// in an object's attribute data buffer.
// This will be dword aligned.
//

#define SampRegFirstFreeVariableAddress( c )                                \
         (PUCHAR)(((PUCHAR)((c)->OnDisk)) + (c)->OnDiskUsed)

#define SampDsFirstFreeVariableAddress( c )                                 \
         (PUCHAR)(((PUCHAR)((c)->OnDisk)) + (c)->OnDiskUsed)

#define SampFirstFreeVariableAddress( c )                                   \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFirstFreeVariableAddress(c) :                             \
            SampRegFirstFreeVariableAddress(c)                              \
    )

//
// Get the number of bytes needed to store the entire variable-length
// attribute information on disk.
//

#define SampRegVariableBufferUsedLength( c )                                \
    (                                                                       \
        (ULONG)((PUCHAR)SampFirstFreeVariableAddress(c) -                   \
        (PUCHAR)SampVariableArrayAddress(c))                                \
    )

#define SampDsVariableBufferUsedLength( c )                                 \
    (                                                                       \
        (ULONG)((PUCHAR)SampDsFirstFreeVariableAddress(c) -                 \
        (PUCHAR)SampDsVariableArrayAddress(c))                              \
    )

#define SampVariableBufferUsedLength( c )                                   \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferUsedLength(c):                              \
            SampRegVariableBufferUsedLength(c)                              \
    )

#define ClearPerAttributeDirtyBits( c )                                     \
    (RtlClearAllBits(&c->PerAttributeDirtyBits))

#define SetPerAttributeDirtyBit(c,a)                                        \
    (RtlSetBits(&c->PerAttributeDirtyBits,a,1))

#define SetAllPerAttributeDirtyBits( c )                                    \
    (RtlSetAllBits(&c->PerAttributeDirtyBits))

#define SetPerAttributeInvalidBit(c,a)                                      \
    (RtlSetBits(&c->PerAttributeInvalidBits,a,1))

#define ClearPerAttributeInvalidBit(c,a)                                    \
    (RtlSetBits(&c->PerAttributeInvalidBits,a,0))

#define SampIsAttributeInvalid( context, attribute )                        \
    (RtlCheckBit(&Context->PerAttributeInvalidBits, attribute ))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampValidateAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN ULONG Attribute,
    IN BOOLEAN SetOperation
    );

PUCHAR
SampObjectAttributeAddress(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    );

ULONG
SampObjectAttributeLength(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    );

PULONG
SampObjectAttributeQualifier(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    );

NTSTATUS
SampGetAttributeBufferReadInfo(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    OUT PUCHAR *Buffer,
    OUT PULONG BufferLength,
    OUT PUNICODE_STRING *KeyAttributeName
    );

NTSTATUS
SampExtendAttributeBuffer(
    IN PSAMP_OBJECT Context,
    IN ULONG NewSize
    );

NTSTATUS
SampReadRegistryAttribute(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    IN ULONG  BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG RequiredLength
    );

NTSTATUS
SampSetVariableAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN ULONG Qualifier,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

NTSTATUS
SampUpgradeToCurrentRevision(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN PUCHAR Buffer,
    IN ULONG  LengthOfDataRead,
    IN PULONG  TotalRequiredLength
    );

//
// extern from usrparms.c
//

NTSTATUS
SampConvertUserParmsToDsAttrBlock(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG Flags,
    IN PSID  DomainSid,
    IN ULONG ObjectRid,
    IN ULONG UserParmsLengthOrig,
    IN PVOID UserParmsOrig,
    IN ULONG UserParmsLengthNew,
    IN PVOID UserParmsNew,
    IN PDSATTRBLOCK InAttrBlock,
    OUT PDSATTRBLOCK *OutAttrBlock
    );

NTSTATUS
SampMergeDsAttrBlocks(
    IN PDSATTRBLOCK FirstAttrBlock,
    IN PDSATTRBLOCK SecondAttrBlock,
    OUT PDSATTRBLOCK * AttrBlock
    );



#ifdef SAM_DEBUG_ATTRIBUTES
VOID
SampDumpAttributes(
    IN PSAMP_OBJECT Context
    );

VOID
SampDumpData(
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Routines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SampInitDsObjectInfoAttributes(
    )

/*++

Routine Description:

    This routine initializes the offset and length information fields of the
    SAM_OBJECT_INFORMATION structure for DS attributes. This structure con-
    tains offset and length information for two sets of attributes:

    -Those attributes stored in the registry (workstation account info)

    -Those attributes stored in the DS (domain or DC account info)

    The former set are initialized by SampInitObjectInfoAttriubtes, while this
    routine inializes the latter set of information. Regardless of whether the
    attributes are persistently stored in the registry or the DS, their in-
    memory representation always uses the SAM fixed-length and variable-length
    data buffers.

    Note that DS data buffers do not contain the KEY_VALUE_PARTIAL_INFORMATION
    data because this is registry-specific, hence unnecessary for the DS-based
    attributes.

Parameters:

    None.

Return Values:

    None.

--*/

{
    PSAMP_OBJECT_INFORMATION Object;

    SAMTRACE("SampInitDsObjectInfoAttributes");

    //
    // SERVER object attribute information
    //

    Object = &SampObjectInformation[SampServerObjectType];

    // Object->FixedStoredSeparately = SAMP_SERVER_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_SERVER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // DOMAIN object attribute information
    //

    Object = &SampObjectInformation[SampDomainObjectType];

    // Object->FixedStoredSeparately = SAMP_DOMAIN_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_DOMAIN_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // USER object attribute information
    //

    Object = &SampObjectInformation[SampUserObjectType];

    // Object->FixedStoredSeparately = SAMP_USER_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_USER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // GROUP object attribute information
    //

    Object = &SampObjectInformation[SampGroupObjectType];

    // Object->FixedStoredSeparately = SAMP_GROUP_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_GROUP_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // ALIAS object attribute information
    //

    Object = &SampObjectInformation[SampAliasObjectType];

    // Object->FixedStoredSeparately = SAMP_ALIAS_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_ALIAS_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    return;
}



VOID
SampInitObjectInfoAttributes(
    )


/*++

    This API initializes the attribute field information
    of the various object information structures.

    Attribute information includes:

            FixedStoredSeparately   (BOOLEAN)

            FixedAttributeOffset    (ULONG)
            VariableBufferOffset    (ULONG)
            VariableArrayOffset     (ULONG)
            VariableDataOffset      (ULONG)

            FixedLengthSize         (ULONG)
            VariableAttributeCount  (ULONG)


Parameters:

    None.



Return Values:

    None.


--*/
{


    //
    // Define the size of the header that is in front of our data when
    // we read it back out of the registry.
    //

#define KEY_VALUE_HEADER_SIZE (SampDwordAlignUlong( \
              FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)))


    PSAMP_OBJECT_INFORMATION Object;

    SAMTRACE("SampInitObjectInfoAttributes");

    //
    // SERVER object attribute information
    //

    Object = &SampObjectInformation[SampServerObjectType];

    Object->FixedStoredSeparately = SAMP_SERVER_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);

#if SAMP_SERVER_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_SERVER_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_SERVER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // DOMAIN object attribute information
    //

    Object = &SampObjectInformation[SampDomainObjectType];

    Object->FixedStoredSeparately = SAMP_DOMAIN_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);

#if SAMP_DOMAIN_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_DOMAIN_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_DOMAIN_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // USER object attribute information
    //

    Object = &SampObjectInformation[SampUserObjectType];

    Object->FixedStoredSeparately = SAMP_USER_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);

#if SAMP_USER_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_USER_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_USER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // GROUP object attribute information
    //

    Object = &SampObjectInformation[SampGroupObjectType];

    Object->FixedStoredSeparately = SAMP_GROUP_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);

#if SAMP_GROUP_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_GROUP_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_GROUP_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // ALIAS object attribute information
    //

    Object = &SampObjectInformation[SampAliasObjectType];

    Object->FixedStoredSeparately = SAMP_ALIAS_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);

#if SAMP_ALIAS_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_ALIAS_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_ALIAS_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    // Initialize the DS-specific buffer offsets and lengths.

    SampInitDsObjectInfoAttributes();

    return;
}





NTSTATUS
SampUpgradeUserParmsActual(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG        Flags,
    IN PSID         DomainSid,
    IN ULONG        ObjectRid,
    IN OUT PDSATTRBLOCK * AttributesBlock
    )

/*++
Routine Description:

    This routine is the worker routine to converts SampUserObject's
    ATT_USER_PARAMETERS attribute to AttrBlock through Notification Package.

Arguments:

    Context - pointer to user object's context, optional.
              however, the caller must provide Context if "Upgrade == FALSE"

    Flags -   Values:

          SAM_USERPARMS_DURING_UPGRADE:

              Indicates whether this routine is called because of DCPROMOTE upgrade
              or because of down level compatibility

              The reason why we need this parameter (Flags) is that: in SampConvertCredenialToAttr
              we will call SampQueryUserSupplementalCredentials to get this User's old credential
              data. While, during DCPromote, the DS object representing the SAM User Object is not
              created yet. So we do not want to Query User's credential during the DCpromote.
              We use Upgrade to indicate it during DCpromote or keep down level SAM API compatibly.
              if SAM_USERPARMS_DURING_UPGRADE bit is set on: during DCPromote.

              Another reason is that: RAS group needs to know their converting routine --
              UserParmsConvert is called during upgrade or not to decide to do different things.


    DomainSid - Pointer to Parent Domain Sid.

    ObjectRid - This object's relative ID.

    AttributesBlock - DSATTRBLOCK, passed in DSATTRBLOCK structure which MAY or MAY NOT include
                      ATT_USER_PARAMETERS attribute,

                      if success, AttributesBlock will return the new Attributes Block which
                      contains converted attributes from UserParms.

                      if failure, AttributesBlock keeps unchanged.

Return Values:

    STATUS_SUCCESS


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       UserParmsLengthOrig = 0;
    PVOID       UserParmsOrig = NULL;
    ULONG       UserParmsLengthNew = 0;
    PVOID       UserParmsNew = NULL;
    ULONG       Index = 0;
    PDSATTRBLOCK TmpAttrBlock = NULL;
    PDSATTRBLOCK UserParmsAttrBlock = NULL;


    SAMTRACE("SampUpgradeUserParmsActual");


    ASSERT(ARGUMENT_PRESENT(Context) || (Flags & SAM_USERPARMS_DURING_UPGRADE));
    ASSERT(DomainSid);
    ASSERT(ObjectRid);
    ASSERT(*AttributesBlock);

    if (NULL == *AttributesBlock)
    {
        return NtStatus;
    }

    //
    // search NON zero value ATT_USER_PARAMETERS
    //
    for (Index = 0; Index < (*AttributesBlock)->attrCount; Index ++)
    {
        if ( ATT_USER_PARAMETERS == (*AttributesBlock)->pAttr[Index].attrTyp &&
             0 != (*AttributesBlock)->pAttr[Index].AttrVal.pAVal[0].valLen)
        {

            ASSERT(1 == (*AttributesBlock)->pAttr[Index].AttrVal.valCount);

            if ( !(Flags & SAM_USERPARMS_DURING_UPGRADE) )
            {
                // not a upgrade case, so we need to provide the old UserParms Value
                ASSERT(Context->TypeBody.User.CachedOrigUserParmsIsValid);

                UserParmsLengthOrig = Context->TypeBody.User.CachedOrigUserParmsLength;
                UserParmsOrig = Context->TypeBody.User.CachedOrigUserParms;
            }

            UserParmsLengthNew = (*AttributesBlock)->pAttr[Index].AttrVal.pAVal[0].valLen;
            UserParmsNew = (*AttributesBlock)->pAttr[Index].AttrVal.pAVal[0].pVal;

            NtStatus = SampConvertUserParmsToDsAttrBlock(Context,
                                                         Flags,
                                                         DomainSid,
                                                         ObjectRid,
                                                         UserParmsLengthOrig,
                                                         UserParmsOrig,
                                                         UserParmsLengthNew,
                                                         UserParmsNew,
                                                         *AttributesBlock,
                                                         &UserParmsAttrBlock
                                                         );

            if (NT_SUCCESS(NtStatus) && NULL != UserParmsAttrBlock)
            {
                NtStatus = SampMergeDsAttrBlocks(*AttributesBlock,
                                                 UserParmsAttrBlock,
                                                 &TmpAttrBlock
                                                 );

                if (NT_SUCCESS(NtStatus))
                {
                    *AttributesBlock = TmpAttrBlock;
                    TmpAttrBlock = NULL;
                    UserParmsAttrBlock = NULL;
                }
            }

            break;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto UpgradeUserParmsActualError;
    }


    return NtStatus;

UpgradeUserParmsActualError:


    if (UserParmsAttrBlock)
    {
        SampFreeAttributeBlock(UserParmsAttrBlock);
    }

    return NtStatus;

}





NTSTATUS
SampUpgradeUserParms(
    IN PSAMP_OBJECT Context,
    IN OUT PDSATTRBLOCK * AttributesBlock
    )

/*++

Routine Description:

    This routine retrieves Domain SID and ObjectRid from Context, then call
    SampUpgradeUserParmsActual. if failure, also log error in System Event Log.

    Note: this routine is only called by UserParms Migration (Normal Operation),
          and not called during either Upgrade or Fresh Install, so this routine
          does not need to provide Flags as one Parameter.

Arguments:

    Context - pointer to a User Object's context block.

    AttributeBlock - pointer to DSATTRBLOCK structure, passed in original attributes block,
                     and used to return the updated attribute block to set.

Return Values:

    STATUS_SUCCESS - complete successfully.

    STATUS_NO_MEMORY - no resources.

    STATUS_INVALID_PARAMETERS - notification package trying to set invalid attribute.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSID        DomainSid = NULL;
    ULONG       ObjectRid;


    SAMTRACE("SampUpgradeUserParms");

    ASSERT(Context);
    ASSERT(SampCurrentThreadOwnsLock());

    DomainSid = SampDefinedDomains[Context->DomainIndex].Sid;
    ObjectRid = Context->TypeBody.User.Rid;

    NtStatus = SampUpgradeUserParmsActual(Context,
                                          0,            // not during Upgrade(DCPromote), flags set to 0
                                          DomainSid,
                                          ObjectRid,
                                          AttributesBlock
                                          );

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // if failure to upgrade UserParms attribute, log ERROR, and fail this operation.
        //
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,     // Event Type
                          0,                       // Category
                          SAMMSG_ERROR_SET_USERPARMS,
                          &(Context->ObjectNameInDs->Sid),      // SID
                          0,                       // Num of String
                          sizeof(NTSTATUS),        // Data Size
                          NULL,                    // String Array -- User Name
                          (PVOID) &NtStatus        // Data
                          );
    }

    return NtStatus;
}




NTSTATUS
SampStoreDsObjectAttributes(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This routine does the work of writing the SAM attributes out to the DS
    backing store. Determination is made as to whether the fixed, or vari-
    able, or both sets of attributes are dirty and valid. If so, then they
    are updated in the backing store. The SAM attributes are first converted
    into a DSATTRBLOCK so that they can be written to storage. The dirty
    flags are updated accordingly.

Arguments:

    Context - Pointer, the object's SAM context.

Return Value:

    STATUS_SUCCESS - storage was updated without a problem, otherwise an
        error code is returned.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN FlushFixed = FALSE;
    BOOLEAN FlushVariable = FALSE;
    INT ObjectType = Context->ObjectType;
    ULONG Flags = 0;
    PDSNAME DsObjectName = Context->ObjectNameInDs;
    PDSATTRBLOCK AttributeBlock = NULL;
    PDSATTRBLOCK SAAttrBlock = NULL;
    ULONG   *Operations = NULL;

    SAMTRACE("SampStoreDsObjectAttributes");

    // Determine which attributes (fixed or variable) need to be written to
    // storage.

    if (Context->FixedValid && Context->FixedDirty)
    {
        FlushFixed = TRUE;
    }

    if (Context->VariableValid && Context->VariableDirty)
    {
        FlushVariable = TRUE;
    }

    //
    // Return right away if nothing is dirty
    //

    if (!FlushFixed && !FlushVariable)
    {
        return STATUS_SUCCESS;
    }

    //
    // Do a lazy commit, if lazy commit is specified
    //

    if (Context->LazyCommit)
    {
        Flags|=SAM_LAZY_COMMIT;
    }

    //
    // If an On disk exists proceed on writing
    //

    if (NULL!=Context->OnDisk)
    {

        if ((FlushFixed)&&(FlushVariable))
        {


            // If both Fixed and Variable Attributes need to be flushed ...
            // Get a pointer to the combined (i.e. fixed and variable-
            // length) attributes and convert them into a DSATTRBLOCK.

            NtStatus = SampConvertCombinedAttributesToAttrBlock(
                            Context,
                            SampDsFixedBufferLength(Context),
                            SampDsVariableBufferLength(Context),
                            &AttributeBlock);


        }
        else if (FlushFixed)
        {
            //
            // Only Fixed attributes have been modified. Therefore just flush them
            //

            NtStatus = SampConvertFixedLengthAttributesToAttrBlock(
                            Context->ObjectType,
                            SampDsFixedBufferAddress(Context),
                            &AttributeBlock);
        }
        else if (FlushVariable)
        {
            //
            // Only variable attributes are modified
            //

            NtStatus = SampConvertVarLengthAttributesToAttrBlock(
                            Context,
                            SampDsVariableArrayAddress(Context),
                            &AttributeBlock);
        }

        if (NT_SUCCESS(NtStatus))
        {
            ATTR    CredentialAttr;

            //
            // Map SAM attribute ID to DS attribute ID, should have NO problem.
            //
            SampMapSamAttrIdToDsAttrId(Context->ObjectType,
                                       AttributeBlock
                                       );

            //
            // Upgrade the User Parameters Attribute through Notification Package
            // when the User Parms change is trigger by down level SAM API.
            //

            if ((SampUserObjectType == Context->ObjectType) &&
                (!Context->LoopbackClient) &&
                (RtlCheckBit(&Context->PerAttributeDirtyBits, SAMP_USER_PARAMETERS))
                )
            {
                ASSERT(SampCurrentThreadOwnsLock());

                NtStatus = SampUpgradeUserParms(Context,
                                                &AttributeBlock
                                                );
            }

            //
            // If the context has a list of supplemental credentials to be set, then merge that in
            //

            if ((SampUserObjectType==Context->ObjectType ) &&
                (NULL != Context->TypeBody.User.SupplementalCredentialsToWrite))
            {
                NtStatus = SampConvertCredentialsToAttr(Context,
                                            0,
                                            Context->TypeBody.User.Rid,
                                            Context->TypeBody.User.SupplementalCredentialsToWrite,
                                            &CredentialAttr
                                            );

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Free the supplemenal credentials in the context
                    //

                    SampFreeSupplementalCredentialList(
                         Context->TypeBody.User.SupplementalCredentialsToWrite);

                    Context->TypeBody.User.SupplementalCredentialsToWrite = NULL;

                    NtStatus = SampAppendAttrToAttrBlock(CredentialAttr,
                                             &AttributeBlock
                                             );
                }

            }

            if (  (SampUserObjectType==Context->ObjectType)
               && (Context->TypeBody.User.fCheckForSiteAffinityUpdate))
            {
                SAMP_SITE_AFFINITY NewSA;
                BOOLEAN            fDeleteOld;
                SAMP_SITE_AFFINITY *TempSA = NULL;

                if (SampCheckForSiteAffinityUpdate(Context,
                                                   0, 
                                                  &Context->TypeBody.User.SiteAffinity,
                                                  &NewSA,
                                                  &fDeleteOld))
                {
                    //
                    // Site Affinity needs updating -- create an attrblock
                    // for the changes.  There will be at least on addition,
                    // and possible a removal if a value already exists
                    // for this site.
                    //

                    ULONG SAAttrCount;
                    ULONG Index, i;
                    PDSATTRBLOCK NewAttributeBlock;
                    ATTRVAL *AttrVal = NULL;

    
                    SAAttrCount = 1;
                    if (fDeleteOld) {
                        SAAttrCount++;
                    }

                    SAAttrBlock = MIDL_user_allocate(sizeof(DSATTRBLOCK));
                    if (NULL == SAAttrBlock) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    RtlZeroMemory(SAAttrBlock, sizeof(DSATTRBLOCK));

                    SAAttrBlock->pAttr = MIDL_user_allocate(SAAttrCount * sizeof(DSATTR));
                    if (NULL == SAAttrBlock->pAttr) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    RtlZeroMemory(SAAttrBlock->pAttr, SAAttrCount * sizeof(DSATTR));
                    SAAttrBlock->attrCount = SAAttrCount;

                    Index = 0;
                    if (fDeleteOld) {
                        AttrVal = MIDL_user_allocate(sizeof(*AttrVal));
                        if (NULL == AttrVal) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            goto Error;
                        }
                        TempSA = MIDL_user_allocate(sizeof(SAMP_SITE_AFFINITY));
                        if (NULL == TempSA) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            goto Error;
                        }
                        *TempSA = Context->TypeBody.User.SiteAffinity;

                        AttrVal->valLen = sizeof(SAMP_SITE_AFFINITY);
                        AttrVal->pVal = (UCHAR*)TempSA;
                        TempSA = NULL;

                        SAAttrBlock->pAttr[Index].attrTyp = ATT_MS_DS_SITE_AFFINITY;
                        SAAttrBlock->pAttr[Index].AttrVal.valCount = 1;
                        SAAttrBlock->pAttr[Index].AttrVal.pAVal = AttrVal;
                        Index++;
                    }

                    AttrVal = MIDL_user_allocate(sizeof(*AttrVal));
                    if (NULL == AttrVal) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    TempSA = MIDL_user_allocate(sizeof(SAMP_SITE_AFFINITY));
                    if (NULL == TempSA) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    *TempSA = NewSA;
                    AttrVal->valLen = sizeof(SAMP_SITE_AFFINITY);
                    AttrVal->pVal = (UCHAR*)TempSA;
                    TempSA = NULL;
                    SAAttrBlock->pAttr[Index].attrTyp = ATT_MS_DS_SITE_AFFINITY;
                    SAAttrBlock->pAttr[Index].AttrVal.valCount = 1;
                    SAAttrBlock->pAttr[Index].AttrVal.pAVal = AttrVal;

                    //
                    // Now merge the attrblock's together
                    //
                    NtStatus = SampMergeDsAttrBlocks(AttributeBlock,
                                                     SAAttrBlock,
                                                     &NewAttributeBlock);

                    if (!NT_SUCCESS(NtStatus)) {
                        goto Error;
                    }
                    // SampMergeDsAttrBlocks frees both IN parameters
                    AttributeBlock = NewAttributeBlock;
                    SAAttrBlock = NULL;
                    NewAttributeBlock = NULL;

                    //
                    // Now prepare an operation array 
                    //
                    Operations = MIDL_user_allocate(AttributeBlock->attrCount * sizeof(ULONG));
                    if (NULL == Operations) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }

                    //
                    // Most SAM attr's are simply to replace
                    //
                    for (i = 0; i < AttributeBlock->attrCount; i++) {
                        Operations[i] = REPLACE_ATT;
                    }

                    //
                    // Since SA is multi valued, we have to remove and add
                    //
                    if (fDeleteOld) {
                        Operations[AttributeBlock->attrCount-2] = REMOVE_VALUE;
                        ASSERT(AttributeBlock->pAttr[AttributeBlock->attrCount-2].attrTyp = ATT_MS_DS_SITE_AFFINITY);
                    }
                    Operations[AttributeBlock->attrCount-1] = ADD_VALUE;
                    ASSERT(AttributeBlock->pAttr[AttributeBlock->attrCount-1].attrTyp = ATT_MS_DS_SITE_AFFINITY);
                }
            }

            //
            // Replicate urgently if requested to do so
            //
            if ( Context->ReplicateUrgently )
            {
                Flags |= SAM_URGENT_REPLICATION;
            }

            //
            // An Attr block is ready to be written.
            // Go Ahead and write it !
            //
            if (NT_SUCCESS(NtStatus))
            {
                ULONG NewFlags = Flags | ALREADY_MAPPED_ATTRIBUTE_TYPES;
                if (Operations) {

                    NtStatus = SampDsSetAttributesEx(DsObjectName,
                                                     NewFlags,
                                                     Operations,
                                                     ObjectType,
                                                     AttributeBlock);

                } else {

                    NtStatus = SampDsSetAttributes(DsObjectName,
                                                   NewFlags,
                                                   REPLACE_ATT,
                                                   ObjectType,
                                                   AttributeBlock);

                }
            }

            //
            // Mark FixedDirtyand VariableDirty any way, since we do not want hit the
            // ASSERT in SampFreeAttributeBuffer.
            //
            Context->FixedDirty = FALSE;
            Context->VariableDirty = FALSE;
            ClearPerAttributeDirtyBits(Context);

            //
            // Also clear the urgently replicated bit
            //
            Context->ReplicateUrgently = FALSE;

        }
    }
    
    //
    // Update the Supplemental Creds
    //
    if (NT_SUCCESS(NtStatus) &&
        (SampUserObjectType==Context->ObjectType ) &&
        (NULL != Context->TypeBody.User.PasswordInfo.Buffer))
    {
        PVOID           Result    = NULL;
        SAMP_DS_CTRL_OP DsCtrlOp;

        DsCtrlOp.OpBody.UpdateSupCreds.UpdateInfo = 
            MIDL_user_allocate(Context->TypeBody.User.PasswordInfo.Length);
        if (!DsCtrlOp.OpBody.UpdateSupCreds.UpdateInfo) {

            NtStatus = STATUS_NO_MEMORY;

        } else {

            RtlCopyMemory(DsCtrlOp.OpBody.UpdateSupCreds.UpdateInfo,
                          Context->TypeBody.User.PasswordInfo.Buffer,
                          Context->TypeBody.User.PasswordInfo.Length);
    
            DsCtrlOp.OpType = SampDsCtrlOpTypeClearPwdForSupplementalCreds;
            DsCtrlOp.OpBody.UpdateSupCreds.pUserName = Context->ObjectNameInDs;
            
            NtStatus = SampDsControl(&DsCtrlOp,
                                     &Result);
            
        }

        //
        // Eat and free the password information
        //
        RtlSecureZeroMemory(Context->TypeBody.User.PasswordInfo.Buffer,
                      Context->TypeBody.User.PasswordInfo.Length);
        MIDL_user_free(Context->TypeBody.User.PasswordInfo.Buffer);
        RtlSecureZeroMemory(&Context->TypeBody.User.PasswordInfo,
                      sizeof(Context->TypeBody.User.PasswordInfo));

        if (DsCtrlOp.OpBody.UpdateSupCreds.UpdateInfo) {

            MIDL_user_free(DsCtrlOp.OpBody.UpdateSupCreds.UpdateInfo);

        }

    }

Error:

    if (NULL!=AttributeBlock)
    {
        SampFreeAttributeBlock(AttributeBlock);
        AttributeBlock = NULL;
    }

    if (Operations) {
        MIDL_user_free(Operations);
    }

    if (SAAttrBlock) {
        SampFreeAttributeBlock(SAAttrBlock);
    }

    return(NtStatus);
}





NTSTATUS
SampStoreRegObjectAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN UseKeyHandle
    )

/*++

    This API is used to store an object's attributes onto
    backing store.

    The object attributes are not flushed to disk with this
    routine.  They are just added to the RXACT.




Parameters:

    Context - Pointer to an object context block.

    UseKeyHandle - If TRUE, the RootKey in the context block is passed
        to the transaction code - this assumes that the key
        will still be open when the transaction is committed.
        If FALSE, the RootKey will be ignored and the transaction code will
        open a key for itself.


Return Values:

    STATUS_SUCCESS - The service completed successfully.


    Other status values as may be returned by the RXACT services.


--*/
{
    NTSTATUS
        NtStatus;

    BOOLEAN
        FlushFixed        = FALSE,
        FlushVariable     = FALSE;

    HANDLE
        RootKey;

    SAMTRACE("SampStoreRegObjectAttributes");

    //
    // See if anything is dirty and needs to be stored
    //

    if (Context->FixedValid  &&  Context->FixedDirty) {

        FlushFixed = TRUE;
    }

    if (Context->VariableValid  &&  Context->VariableDirty) {

        FlushVariable = TRUE;
    }


    if (!(FlushFixed || FlushVariable)) {

        return(STATUS_SUCCESS);
    }


    //
    // Calculate the RootKey to pass to the transaction code
    //

    if (UseKeyHandle) {
        RootKey = Context->RootKey;
    } else {
        RootKey = INVALID_HANDLE_VALUE;
    }

    //
    // We keep an open domain context that is used to modify the change
    // count whenever a change is made.  But if this is a domain change
    // here, then that change will overwrite this one.  Check for that
    // case, and copy this fixed data to the open domain context.  Note
    // that the open domain's variable data never gets changed.
    //

    if ( ( Context->ObjectType == SampDomainObjectType ) &&
         ( Context != SampDefinedDomains[Context->DomainIndex].Context ) ) {

        PSAMP_OBJECT DefinedContext;

        //
        // Get a pointer to the corresponding open defined domain.
        // No changes should have been made to its data.
        //

        DefinedContext = SampDefinedDomains[Context->DomainIndex].Context;

        ASSERT( DefinedContext->FixedValid == TRUE );
        ASSERT( DefinedContext->FixedDirty == FALSE );

#if DBG
        if ( DefinedContext->VariableValid ) {
            ASSERT( DefinedContext->VariableDirty == FALSE );
        }
#endif
        DefinedContext->VariableDirty = FALSE;
        ClearPerAttributeDirtyBits(DefinedContext);

        //
        // Copy our fixed data over the defined domain's fixed data.
        // Note that we're assuming that the fixed and variable data are
        // stored separately.
        //

        ASSERT(SampObjectInformation[SampDomainObjectType].FixedStoredSeparately);

        RtlCopyMemory(
            SampFixedBufferAddress( DefinedContext ),
            SampFixedBufferAddress( Context ),
            SampFixedBufferLength( Context )
            );

        //
        // No need to flush this context's fixed data, since the commit
        // code will flush the same stuff (plus an altered modified count).
        //

        FlushFixed = FALSE;
        Context->FixedDirty    = FALSE;
    }

    //
    // One or more of the attributes needs to be stored.
    //

    if (!SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

        //
        // fixed and variable-length attributes stored together.
        // Note - strip off the partial key info struct from the start
        //

        SampDumpRXact(SampRXactContext,
                      RtlRXactOperationSetValue,
                      &(Context->RootName),
                      RootKey,
                      &SampCombinedAttributeName,
                      REG_BINARY,
                      SampFixedBufferAddress(Context),
                      Context->OnDiskUsed - SampFixedBufferOffset(Context),
                      FixedBufferAddressFlag);

        NtStatus = RtlAddAttributeActionToRXact(
                       SampRXactContext,
                       RtlRXactOperationSetValue,
                       &(Context->RootName),
                       RootKey,
                       &SampCombinedAttributeName,
                       REG_BINARY,
                       SampFixedBufferAddress(Context),
                       Context->OnDiskUsed - SampFixedBufferOffset(Context)
                       );
#if SAMP_DIAGNOSTICS
        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint( DISPLAY_STORAGE_FAIL,
                           ("SAM: Failed to add action to RXact (0x%lx)\n",
                           NtStatus) );
            IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }
#endif //SAMP_DIAGNOSTICS


        if ( NT_SUCCESS( NtStatus ) ) {

            Context->FixedDirty    = FALSE;
            Context->VariableDirty = FALSE;
            ClearPerAttributeDirtyBits(Context);
        }

    } else {

        //
        // fixed and variable-length attributes stored separately.
        // Only update the one(s) we need to.
        //

        NtStatus = STATUS_SUCCESS;
        if (FlushFixed) {

            SampDumpRXact(SampRXactContext,
                          RtlRXactOperationSetValue,
                          &(Context->RootName),
                          RootKey,
                          &SampFixedAttributeName,
                          REG_BINARY,
                          SampFixedBufferAddress(Context),
                          SampVariableBufferOffset(Context) - SampFixedBufferOffset(Context),
                          FixedBufferAddressFlag);

            NtStatus = RtlAddAttributeActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationSetValue,
                           &(Context->RootName),
                           RootKey,
                           &SampFixedAttributeName,
                           REG_BINARY,
                           SampFixedBufferAddress(Context),
                           SampVariableBufferOffset(Context) - SampFixedBufferOffset(Context)
                           );

#if SAMP_DIAGNOSTICS
            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint( DISPLAY_STORAGE_FAIL,
                               ("SAM: Failed to add action to RXact (0x%lx)\n",
                               NtStatus) );
                IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                    ASSERT(NT_SUCCESS(NtStatus));
                }
            }
#endif //SAMP_DIAGNOSTICS

            if ( NT_SUCCESS( NtStatus ) ) {

                Context->FixedDirty = FALSE;
            }
        }

        if (NT_SUCCESS(NtStatus) && FlushVariable) {

            SampDumpRXact(SampRXactContext,
                          RtlRXactOperationSetValue,
                          &(Context->RootName),
                          RootKey,
                          &SampVariableAttributeName,
                          REG_BINARY,
                          (PUCHAR)SampVariableArrayAddress(Context),
                          SampVariableBufferUsedLength(Context),
                          VARIABLE_LENGTH_ATTRIBUTE_FLAG);

            NtStatus = RtlAddAttributeActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationSetValue,
                           &(Context->RootName),
                           RootKey,
                           &SampVariableAttributeName,
                           REG_BINARY,
                           SampVariableArrayAddress( Context ),
                           SampVariableBufferUsedLength(Context)
                           );

#if SAMP_DIAGNOSTICS
            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint( DISPLAY_STORAGE_FAIL,
                               ("SAM: Failed to add action to RXact (0x%lx)\n",
                               NtStatus) );
                IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                    ASSERT(NT_SUCCESS(NtStatus));
                }
            }
#endif //SAMP_DIAGNOSTICS


            if ( NT_SUCCESS( NtStatus ) ) {
                Context->VariableDirty = FALSE;
                ClearPerAttributeDirtyBits(Context);
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampStoreObjectAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN UseKeyHandle
    )

/*++

Routine Description:

    This routine determines from the object context whether to update object
    attributes residing in the registry or in the DS backing store, and then
    calls the appropriate routine to do the work.

Arguments:

    Context - Pointer, the object's SAM context.

    UseKeyHandle - Flag indicating that the registry key handle should be
        used (if this is a registry update--it is not used in DS updates).

Return Value:

    STATUS_SUCCESS - storage was updated without a problem, otherwise an
        error code is returned.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampStoreObjectAttributes");

    if (NULL != Context)
    {
        if (IsDsObject(Context))
        {
            NtStatus = SampStoreDsObjectAttributes(Context);
        }
        else
        {
            NtStatus = SampStoreRegObjectAttributes(Context, UseKeyHandle);
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



NTSTATUS
SampDeleteAttributeKeys(
    IN PSAMP_OBJECT Context
    )

/*++

    This API is used to delete the attribute keys that are created in the
    registry underneath a SAM object.



Parameters:

    Context - Pointer to an object context block.



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    Error status may be returned by registry calls.

--*/
{
    UNICODE_STRING
        KeyName;

    NTSTATUS
        NtStatus;

    SAMTRACE("SampDeleteAttributeKeys");

    if (SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

        //
        // Must delete both fixed and variable attribute keys.
        //

        NtStatus = SampBuildAccountSubKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Context->TypeBody.User.Rid,
                       &SampFixedAttributeName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );
            SampFreeUnicodeString( &KeyName );

            NtStatus = SampBuildAccountSubKeyName(
                           SampUserObjectType,
                           &KeyName,
                           Context->TypeBody.User.Rid,
                           &SampVariableAttributeName
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );
                SampFreeUnicodeString( &KeyName );
            }
        }

    } else {

        //
        // Must delete the combined attribute key.
        //

        NtStatus = SampBuildAccountSubKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Context->TypeBody.User.Rid,
                       &SampCombinedAttributeName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );

            SampFreeUnicodeString( &KeyName );
        }
    }

    return( NtStatus );
}



NTSTATUS
SamIGetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    )

/*++

    This API is an exported wrapper for SampGetFixedAttributes that is used
    in samwrite.c, in ntdsa.dll.

Parameters:

    Refer to SampGetFixedAttributes.

Return Values:

    Refer to SampGetFixedAttributes.

--*/

{
    return(SampGetFixedAttributes(Context, MakeCopy, FixedData));
}


NTSTATUS
SampGetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    )

/*++

    This API is used to get a pointer to the fixed-length attributes.




Parameters:

    Context - Pointer to an object context block.

    FixedData - Receives a pointer to the fixed-length data.



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampGetFixedAttributes");

    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_FIXED_ATTRIBUTES, 0, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Return a pointer to the fixed-length attributes.
    //

    if (MakeCopy == FALSE) {
        *FixedData = (PVOID)SampFixedBufferAddress( Context );
        return(STATUS_SUCCESS);
    }

    //
    // Need to make a copy of the fixed data
    //

    *FixedData = (PVOID)MIDL_user_allocate( SampFixedBufferLength( Context ) );
    if ((*FixedData) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory( *FixedData,
                   SampFixedBufferAddress( Context ),
                   SampFixedBufferLength( Context ) );

    return(STATUS_SUCCESS);
}




NTSTATUS
SampSetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN PVOID FixedData
    )

/*++

    This API is used to replace the fixed-length data attribute.



Parameters:

    Context - Pointer to an object context block.




Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetFixedAttributes");

    //
    // Make the fixed-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_FIXED_ATTRIBUTES, 0, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    if (SampUserObjectType == Context->ObjectType)
    {
        PSAMP_V1_0A_FIXED_LENGTH_USER   V1aFixed = NULL;

        //
        // Minimize the passed in structure to not include computed user
        // account control flags
        //
        V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_USER) FixedData;
        ASSERT((V1aFixed->UserAccountControl & USER_COMPUTED_ACCOUNT_CONTROL_BITS) == 0);

        V1aFixed->UserAccountControl &= ~((ULONG)USER_COMPUTED_ACCOUNT_CONTROL_BITS);
    }

    if ( FixedData != SampFixedBufferAddress( Context ) ) {

        //
        // The caller had a copy of the data, so we must copy the changes
        // over our data buffer.
        //

        RtlCopyMemory( SampFixedBufferAddress( Context ),
                       FixedData,
                       SampFixedBufferLength( Context ) );
    }

    //
    // Mark the buffer dirty now and it will get flushed when the
    // changes are committed.
    //

    Context->FixedDirty = TRUE;

    return( NtStatus );
}




NTSTATUS
SampGetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PUNICODE_STRING UnicodeAttribute
    )


/*++

    This API is used to get a copy of a UNICODE_STRING attribute or a
    pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing the
    object again.

    If MakeCopy is FALSE, indicating the string is to be referenced rather
    than copied, then only the body of the string is referenced.  The lengths
    and pointer are set in the provided argument.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved as a UNICODE_STRING.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    UnicodeAttribute - Receives a pointer to the UNICODE_STRING.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/

{
    NTSTATUS NtStatus;
    ULONG Length;

    SAMTRACE("SampGetUnicodeStringAttribute");

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );
    ASSERT(Length <= 0xFFFF);

    UnicodeAttribute->MaximumLength = (USHORT)Length;
    UnicodeAttribute->Length = (USHORT)Length;

    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        UnicodeAttribute->Buffer =
            (PWSTR)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }

    //
    // Need to make a copy of the attribute
    //
    // NOTE: We should test for zero length here and return a NULL pointer
    // in that case, but this change would require verification of all of the
    // callers of this routine, so I'm leaving it as is.
    //

    UnicodeAttribute->Buffer = (PSID)MIDL_user_allocate( Length );
    if ((UnicodeAttribute->Buffer) == NULL) {
        UnicodeAttribute->Length = 0;
        UnicodeAttribute->MaximumLength = 0;
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory(
        UnicodeAttribute->Buffer,
        SampObjectAttributeAddress( Context, AttributeIndex ),
        Length
        );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PUNICODE_STRING Attribute
    )


/*++

    This API is used to replace a UNICODE_STRING attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set as a UNICODE_STRING.


    Attribute - Points to the new UNICODE_STRING value.




Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetUnicodeStringAttribute");


    //
    // Verify that the passed in unicode string is not malformed
    //

    if ((Attribute->Length>0) && (NULL==Attribute->Buffer))
    {
       return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   0,                   // Qualifier not used
                   (PUCHAR)Attribute->Buffer,
                   Attribute->Length
                   );

    return(NtStatus);

}


NTSTATUS
SampGetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *Sid
    )


/*++

    This API is used to get a copy of a SID attribute or a pointer to
    the attribute.  If a pointer to the attribute is sought, care must
    be taken to ensure the pointer is not used after it becomes invalid.
    Actions that may cause an attribute pointer to become invalid include
    setting an attribute value or dereferencing and then referencing the
    object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved as a SID.

    MakeCopy - If TRUE, indicates that a copy of the SID is to be made.
        If FALSE, indicates a pointer to the SID is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the SID remains in place.
        Addition or replacement of any variable length attribute may
        cause the SID to be moved, and previously returned pointers
        invalidated.

    Sid - Receives a pointer to the SID.  If MakeCopy was specified, then
        this pointer points to a block of memory allocated with
        MIDL_user_allocate() which the caller is responsible for freeing
        (using MIDL_user_free()).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;

    PSID
        SidAttribute;


    SAMTRACE("SampGetSidAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }



    //
    // Get the address of the attribute in question
    //

    SidAttribute = (PSID)SampObjectAttributeAddress( Context, AttributeIndex );

    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*Sid) = SidAttribute;
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the SID
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );
    ASSERT(Length == RtlLengthSid( SidAttribute ) );

    (*Sid) = (PSID)MIDL_user_allocate( Length );
    if ((*Sid) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    NtStatus = RtlCopySid( Length, (*Sid), SidAttribute );
    ASSERT(NT_SUCCESS(NtStatus));

    return(NtStatus);

}



NTSTATUS
SampSetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute
    )


/*++

    This API is used to replace a SID attribute in an object's variable
    length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set as a SID.


    Attribute - Points to the new SID value.

    Length - The length of the new attribute value (in bytes).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetSidAttribute");

    //
    // Validate the passed SID
    //

    ASSERT(RtlValidSid(Attribute));


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   0,                   // Qualifier not used
                   (PUCHAR)Attribute,
                   RtlLengthSid(Attribute)
                   );

    return(NtStatus);

}


NTSTATUS
SampGetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG Revision,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )


/*++

    This API is used to get a copy of the object access information.
    This includes the security descriptor and revision level of the
    object.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    Revision - Receives the revision level from the access information.

    SecurityDescriptor - Receives a pointer to the attribute.  If MakeCopy
        was specified as TRUE, then this pointer points to a block of memory
        allocated with MIDL_user_allocate() which the caller is responsible
        for freeing (using MIDL_user_free()).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;

    PVOID
        RawAttribute;

    SAMTRACE("SampGetAccessAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }



    //
    // Get the revision level from the qualifier field of the variable
    // array entry.
    //

    (*Revision) = *(SampObjectAttributeQualifier( Context, AttributeIndex ));


    //
    // Get the address of the attribute in question
    //

    RawAttribute = (PVOID)SampObjectAttributeAddress( Context, AttributeIndex );


    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*SecurityDescriptor) = (PSECURITY_DESCRIPTOR)RawAttribute;
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );

    (*SecurityDescriptor) = (PSECURITY_DESCRIPTOR)MIDL_user_allocate( Length );
    if ((*SecurityDescriptor) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory( (*SecurityDescriptor), RawAttribute, Length );

    return(STATUS_SUCCESS);

}



NTSTATUS
SampSetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSECURITY_DESCRIPTOR Attribute,
    IN ULONG Length
    )


/*++

    This API is used to replace a SECURITY_DESCRIPTOR attribute in
    an object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set as a SECURITY_DESCRIPTOR.


    Attribute - Points to the new SECURITY_DESCRIPTOR value.

    Length - The length of the new attribute value (in bytes).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetAccessAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   SAMP_REVISION,
                   (PUCHAR)Attribute,
                   Length
                   );

    return(NtStatus);

}


NTSTATUS
SampGetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG *UlongArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    )


/*++

    This API is used to get a copy of an array of ULONGs attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved as a ULONG array.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    UlongArray - Receives a pointer to the array of ULONGS.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).

    UsedCount - Receives the number of elements used in the array.

    LengthCount - Receives the total number of elements in the array (some
        at the end may be unused).  If this value is zero, then
        UlongArray will be returned as NULL.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;


    SAMTRACE("SampGetUlongArrayAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the count of array elements.
    // If this is zero, then return will a null buffer pointer.
    //

    (*UsedCount) = *(SampObjectAttributeQualifier( Context, AttributeIndex));




    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );

    (*LengthCount) = Length / sizeof(ULONG);

    ASSERT( (*UsedCount) <= (*LengthCount) );

    if ((*LengthCount) == 0) {
        (*UlongArray) = NULL;
        return(STATUS_SUCCESS);
    }


    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*UlongArray) =
            (PULONG)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    (*UlongArray) = (PULONG)MIDL_user_allocate( Length );
    if ((*UlongArray) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( (*UlongArray),
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   Length );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PULONG Attribute,
    IN ULONG UsedCount,
    IN ULONG LengthCount
    )


/*++

    This API is used to replace a ULONG array attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new ULONG array value.

    UsedCount - The number of used elements in the array.

    LengthCount - the total number of elements in the array (some at the
        end may be unused).


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetUlongArrayAttribute");

    ASSERT( LengthCount >= UsedCount );

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   UsedCount,           // Qualifier contains used element count
                   (PUCHAR)Attribute,
                   (LengthCount * sizeof(ULONG))
                   );

    return(NtStatus);

}


NTSTATUS
SampGetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLARGE_INTEGER *LargeIntArray,
    OUT PULONG Count
    )


/*++

    This API is used to get a copy of an array of LARGE_INTEGERs attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    LargeIntArray - Receives a pointer to the array of ULONGS.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).


    Count - Receives the number of elements in the array.  If this value
        is zero, then LargeIntArray will be returned as NULL.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;


    SAMTRACE("SampGetLargeIntArrayAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the count of array elements.
    // If this is zero, then return will a null buffer pointer.
    //

    (*Count) = *(SampObjectAttributeQualifier( Context, AttributeIndex));

    if ((*Count) == 0) {
        (*LargeIntArray) = NULL;
        return(STATUS_SUCCESS);
    }



    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );

    ASSERT((*Count) == (Length / sizeof(LARGE_INTEGER)) );



    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*LargeIntArray) =
            (PLARGE_INTEGER)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    (*LargeIntArray) = (PLARGE_INTEGER)MIDL_user_allocate( Length );
    if ((*LargeIntArray) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( (*LargeIntArray),
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   Length );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLARGE_INTEGER Attribute,
    IN ULONG Count
    )


/*++

    This API is used to replace a LARGE_INTEGER array attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new LARGE_INTEGER array value.

    Count - The number of elements in the array.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetLargeIntArrayAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   Count,                   // Qualifier contains element count
                   (PUCHAR)Attribute,
                   (Count * sizeof(LARGE_INTEGER))
                   );

    return(NtStatus);

}


NTSTATUS
SampGetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *SidArray,
    OUT PULONG Length,
    OUT PULONG Count
    )


/*++

    This API is used to get a copy of an array of SIDs attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.


    NOTE: This routine does not define the structure of a SID array,
          so this effectively is a GetRawDataAttribute routine.



Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    SidArray - Receives a pointer to the array of SIDs.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).


    Count - Receives the number of elements in the array.  If this value
        is zero, then SidArray will be returned as NULL.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;


    SAMTRACE("SampGetSidArrayAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the count of array elements.
    // If this is zero, then return will a null buffer pointer.
    //

    (*Count) = *(SampObjectAttributeQualifier( Context, AttributeIndex));

    if ((*Count) == 0) {
        (*SidArray) = NULL;
        (*Length) = 0;
        return(STATUS_SUCCESS);
    }



    //
    // Get the length of the attribute
    //

    (*Length) = SampObjectAttributeLength( Context, AttributeIndex );




    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*SidArray) =
            (PSID)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    (*SidArray) = (PSID)MIDL_user_allocate( (*Length) );
    if ((*SidArray) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( (*SidArray),
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   (*Length) );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute,
    IN ULONG Length,
    IN ULONG Count
    )


/*++

    This API is used to replace a SID array attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new SID array value.

    Length - Number of byte in the attribute buffer.

    Count - Number of SIDs in the array.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetSidArrayAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   Count,                   // Qualifier contains element count
                   (PUCHAR)Attribute,
                   Length
                   );

    return(NtStatus);

}


NTSTATUS
SampGetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLOGON_HOURS LogonHours
    )


/*++

    This API is used to get a copy of a logon hours attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    LogonHours - Receives the logon hours information.  If MakeCopy is TRUE
        then the bitmap pointed to from within this structure will be a copy
        of the attribute and must be deallocated uing MIDL_user_free().
        Otherwise, this same field will point to the bitmap in the on-disk
        buffer.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length,
        Units;


    SAMTRACE("SampGetLogonHoursAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the time units.
    // If this is zero, then return will a null buffer pointer.
    //

    Units = *(SampObjectAttributeQualifier( Context, AttributeIndex));
    ASSERT(Units <= 0xFFFF);
    LogonHours->UnitsPerWeek = (USHORT)Units;

    if (Units == 0) {
        LogonHours->LogonHours = NULL;
        return(STATUS_SUCCESS);
    }




    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        LogonHours->LogonHours =
            (PUCHAR)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );
    ASSERT(Length <= 0xFFFF);


    //
    // Need to make a copy of the attribute
    //

    LogonHours->LogonHours =
        (PUCHAR)MIDL_user_allocate( Length );
    if (LogonHours->LogonHours == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( LogonHours->LogonHours,
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   Length );

    return(STATUS_SUCCESS);

}



NTSTATUS
SampPreventTimeUnitChange(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLOGON_HOURS Attribute
    )
/*++

    This routine prevents clients from changing the logon-hours TIME UNITS
    for the specified account.

    Note: In the NT5 Beta 1 release, support for changing the time units of
    the account's logon hours is missing, pending further work. Because this
    is not supported, this routine is called by SampSetLogonHoursAttribute
    to disallow any changes to the time units.

    Since very few, if any, clients actually know how to/desire changing
    this attribute, it may not be supported in future releases of NT. If
    this is not the case, then this routine is temporary and should be re-
    moved when support for this operation is available. Also note that the
    utilities, usrmgr.exe and "net user" do not support this type of change.

Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.

    Attribute - Points to the new LOGON_HOURS value.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS NtStatus = STATUS_NOT_SUPPORTED;
    ULONG CurrentUnits = 0;
    ULONG CurrentLength = 0;
    ULONG NewUnits = 0;
    ULONG NewLength = 0;
    PUCHAR LogonHours = NULL;

    ASSERT(NULL != Attribute);

    // It is invalid to specify non-zero units and a NULL bitmask for the
    // logon hours. SAM accounts, however, are initially created with a NULL
    // logon-hours attribute and units equal to zero, which is legal and
    // allows the account to logon at any time (the default). If the bitmask
    // is NULL, this means that the caller does not want to change the logon
    // hours (or time units).

    if (NULL == Attribute->LogonHours)
    {
        if (0 != Attribute->UnitsPerWeek)
        {
            return(STATUS_INVALID_PARAMETER);
        }

        // No change in logon hours (or time units) requested by caller.

        return(STATUS_SUCCESS);
    }

    // Get the current time units and logon-hours buffer length from the
    // specified account. Compare these values to the input time units and
    // length specified in the logon hours parameter. If they are the same,
    // return status success, otherwise return STATUS_NOT_SUPPORTED to dis-
    // allow this kind of modification.
    //
    // Days per week    = 7,        SAM_DAYS_PER_WEEK
    // Hours per week   = 168,      SAM_HOURS_PER_WEEK
    // Minutes per week = 10080,    SAM_MINUTES_PER_WEEK

    LogonHours = (PUCHAR)SampObjectAttributeAddress(Context, AttributeIndex);
    CurrentUnits = *(SampObjectAttributeQualifier(Context, AttributeIndex));
    CurrentLength = SampObjectAttributeLength(Context, AttributeIndex);

    ASSERT(CurrentUnits <= SAM_MINUTES_PER_WEEK);
    ASSERT(CurrentLength <= SAM_MINUTES_PER_WEEK);

    if (NULL == LogonHours)
    {
        if ((0 != CurrentUnits) || (0 != CurrentLength))
        {
            return(STATUS_INTERNAL_ERROR);
        }
    }

    // The account's logon hours are non-NULL and non-zero time units have
    // been specified, so perform further validation.

    NewUnits = Attribute->UnitsPerWeek;
    NewLength = ((NewUnits + 7) / 8);

    ASSERT(NewUnits <= SAM_MINUTES_PER_WEEK);
    ASSERT(NewLength <= SAM_MINUTES_PER_WEEK);

    if ((CurrentUnits == NewUnits) && (CurrentLength == NewLength))
    {
        // If the time units are the same then there is no change being asked
        // for in logon hours time units.

        return(STATUS_SUCCESS);
    }

    if ((0 == CurrentUnits) &&
        (0 == CurrentLength) &&
        (SAM_HOURS_PER_WEEK == NewUnits) &&
        ((SAM_HOURS_PER_WEEK / 8) == NewLength))
    {
        // Creating new users with usrmgr.exe hits a case where the logon
        // time units are zero, but the requested new units are the default
        // SAM_HOURS_PER_WEEK. Let this case return successfully, otherwise
        // usrmgr.exe cannot be used to create accounts or modify logon
        // hours.

        return(STATUS_SUCCESS);
    }

    return(NtStatus);
}


NTSTATUS
SampSetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLOGON_HOURS Attribute
    )


/*++

    This API is used to replace a LOGON_HOURS attribute in an
    object's variable length attributes.

    UnitsPerWeek are stored in the Qualifier field of the attribute.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new LOGON_HOURS value.




Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS NtStatus;
    PUCHAR LogonHours;
    ULONG Length;
    USHORT UnitsPerWeek;

    SAMTRACE("SampSetLogonHoursAttribute");

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the UnitsPerWeek value for the logon_hours structure.
    // We use this to calculate the length of the data.
    //

    // If the input logon hours (Attribute) is NULL, the caller is not
    // changing the logon hours or time unit. Otherwise, the caller has
    // specified explicit logon-hours data, so verify that the unit of
    // time in the logon hours is not changing. If it is not changing,
    // continue processing the request.

    if ( Attribute == NULL ) {

        UnitsPerWeek = 0;
        LogonHours = NULL;

    } else {

        // BUG: Temporarily disable logon-hours-time-unit modification.

        // For the NT5 Beta, the little-used capability that allows the user
        // to change the time units for logon hours will not be enabled.
        // Supporting this feature in the DS version is a significant enough
        // change to the underlying code as to make it too risky for Beta
        // (and given that it is probably not used--usrmgr.exe and "net user"
        // do not use this feature--it is not worth the risk.

        NtStatus = SampPreventTimeUnitChange(Context,
                                             AttributeIndex,
                                             Attribute);

        if (!NT_SUCCESS(NtStatus)) {

            // The caller is attempting to change the logon-hours time units,
            // which is unsupported in the Beta release, so return the error.

            return(NtStatus);
        }

        UnitsPerWeek = Attribute->UnitsPerWeek;
        LogonHours = Attribute->LogonHours;

    }

    //
    // Validate the data - make sure that if the units per week are non-zero
    // then the logon hours buffer is non-NULL.
    //

    if ( (UnitsPerWeek != 0) && (LogonHours == NULL) ) {

        return(STATUS_INVALID_PARAMETER);
    }
    //
    // Calculate length of logon_hours structure
    //

    Length = (ULONG)((UnitsPerWeek + 7) / 8);

    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   (ULONG)UnitsPerWeek, // Qualifier contains units per week
                   LogonHours,
                   Length
                   );

    return(NtStatus);

}

NTSTATUS
SampUpgradeSecretDataToDSAndSetClassId(
     IN OUT  PSAMP_OBJECT  UserContext
     )
/*+

    Upgrades all Encrypted properties from the Encryption
    system used in the Registry to the Encryption System in
    the DS. Also sets the Correct Class Id for Computer accounts
    for computers

    Parameters:

        UserContext -- Context to the User Object

    Return Values:

        STATUS_SUCCESS
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  Buffer, TempString,TempString2;
    ULONG           i;
    ULONG  SecretDataAttributes[] = {
                                        SAMP_USER_DBCS_PWD,
                                        SAMP_USER_UNICODE_PWD,
                                        SAMP_USER_LM_PWD_HISTORY,
                                        SAMP_USER_NT_PWD_HISTORY
                                    };
    SAMP_ENCRYPTED_DATA_TYPE DataType[] = {
                                        LmPassword,
                                        NtPassword,
                                        LmPasswordHistory,
                                        NtPasswordHistory
                                        };

    PVOID                           FixedData;
    SAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed;
    ULONG   Rid;
    BOOLEAN fSetFixedAttributes = FALSE;

    RtlZeroMemory(&TempString,sizeof(UNICODE_STRING));
    RtlZeroMemory(&TempString2,sizeof(UNICODE_STRING));

    //
    // Get the Rid, note that DS upgrade code does not
    // initialize TypeBody.Rid, so fetch the Rid from
    // Context->OnDisk
    //

    NtStatus = SampGetFixedAttributes(
                    UserContext,
                    FALSE, // Don't make Copy
                    &FixedData
                    );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    RtlCopyMemory(&V1aFixed,FixedData,sizeof(SAMP_V1_0A_FIXED_LENGTH_USER));
    Rid = V1aFixed.UserId;

    //
    // Set the Class Id based on User account Control
    //

    if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
    {
        //
        // Computer Account
        //


        //
        // Change the Class Id to class computer
        //

        UserContext->DsClassId = CLASS_COMPUTER;

        //
        // Change the primary group Id to DOMAIN_COMPUTERS
        // (or DOMAIN_CONTROLLERS )
        //

        //
        // We determine the primary group id only in DS case,
        // so turn the object's flags to DS_OBJECT, after
        // we use it, set it back to REGISTRY_OBJECT in case
        // some other routines need that flags.
        //

        SetDsObject(UserContext);
        V1aFixed.PrimaryGroupId = SampDefaultPrimaryGroup(
                                     UserContext,
                                     V1aFixed.UserAccountControl
                                    );
        SetRegistryObject(UserContext);


        fSetFixedAttributes = TRUE;

    }
    else if (V1aFixed.UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT) 
    {
        //
        // Eliminate the concept of temp duplicate accounts from SAM.
        // Migrate them as normal user accounts
        //

        V1aFixed.UserAccountControl &= ~((ULONG)USER_TEMP_DUPLICATE_ACCOUNT);
        V1aFixed.UserAccountControl |=USER_NORMAL_ACCOUNT|USER_ACCOUNT_DISABLED;

        fSetFixedAttributes = TRUE;
    }

    //
    //  Administrator on Domain Controller can't be disabled
    // 
    if ((DOMAIN_USER_RID_ADMIN) == Rid &&
        (V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED)) 
    {
        V1aFixed.UserAccountControl &= ~USER_ACCOUNT_DISABLED;

        fSetFixedAttributes = TRUE;
    }

    if (fSetFixedAttributes)
    {
        NtStatus = SampReplaceUserV1aFixed(
                        UserContext,
                        &V1aFixed
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;
    }

    for (i=0;i<ARRAY_COUNT(SecretDataAttributes);i++)
    {


        RtlZeroMemory(&TempString,sizeof(UNICODE_STRING));
        RtlZeroMemory(&TempString2,sizeof(UNICODE_STRING));

        //
        // Read The Secret Data Attribute From Registry
        //

        NtStatus = SampGetUnicodeStringAttribute(
                        UserContext,
                        SecretDataAttributes[i],
                        FALSE,
                        &Buffer
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }


        //
        // Decrypt It
        //

        NtStatus = SampDecryptSecretData(
                   &TempString,
                   DataType[i],
                   &Buffer,
                   Rid
                   );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Re Encrypt It
        //

        NtStatus = SampEncryptSecretData(
                        &TempString2,
                        SAMP_NO_ENCRYPTION,
                        DataType[i],
                        &TempString,
                        Rid
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Write it Back
        //

        NtStatus = SampSetUnicodeStringAttribute(
                        UserContext,
                        SecretDataAttributes[i],
                        &TempString2
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;


        SampFreeUnicodeString(&TempString);
        TempString.Buffer = NULL;
        SampFreeUnicodeString(&TempString2);
        TempString2.Buffer = NULL;

    }

Error:

    if (NULL!=TempString.Buffer)
        SampFreeUnicodeString(&TempString);

    if (NULL!=TempString2.Buffer)
        SampFreeUnicodeString(&TempString2);

    return NtStatus;
}



NTSTATUS
SampNt4ToNt5Object (
     IN OUT  PSAMP_OBJECT     pObject
     )
/*++

    This routine upgrades the security descriptor of the passed in object
    and sets the SAMP_*_MEMBERS field to zero length.

    This routine is only called during the process of transferring SAM objects
    from the registry to the DS.

Parameters:

    pObject - a non pointer to the SAM object to be converted

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS NtStatus;
    ULONG SdRevision, SdLength;
    ULONG SdIndex = 0;

    //
    // These resources must be released
    //
    PVOID Nt4SecDescr = NULL;
    PVOID Nt5SecDescr = NULL;

    //
    //  Parameter check
    //
    ASSERT(pObject);

    //
    // Set The DS Class id on the context. This is needed by
    // security descriptor conversion routines.
    //

    pObject->DsClassId = SampDsClassFromSamObjectType(pObject->ObjectType);

    //
    // Determine the attribute index of the security descriptor
    // and wipe out the GROUP_MEMBERS_UNUSED field
    //

    NtStatus = STATUS_SUCCESS;
    switch ( pObject->ObjectType ) {

        case SampUserObjectType:

            // Upgrade all the Password Properties
            NtStatus = SampUpgradeSecretDataToDSAndSetClassId(pObject);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampSetVariableAttribute(pObject,
                                                SAMP_USER_GROUPS,
                                                0, NULL, 0);

                if (NT_SUCCESS(NtStatus)) {
    
                    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;

                    NtStatus = SampRetrieveUserV1aFixed(
                                   pObject,
                                   &V1aFixed);

                    if (NT_SUCCESS(NtStatus)) {

                        if (!SampNT4UpgradeInProgress
                        &&  (V1aFixed.UserId == DOMAIN_USER_RID_GUEST)
                        &&  (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_USERS)  ) {

                            //
                            // This is the Guest account.  On domain controllers, their
                            // primary group should be Domain Guests.
                            //

                            V1aFixed.PrimaryGroupId = DOMAIN_GROUP_RID_GUESTS;

                            NtStatus = SampReplaceUserV1aFixed(pObject,
                                                               &V1aFixed);
                        }
                    }
                }
            }

            SdIndex = SAMP_USER_SECURITY_DESCRIPTOR;

            break;

        case SampGroupObjectType:

            NtStatus = SampSetVariableAttribute(pObject,
                                                SAMP_GROUP_MEMBERS,
                                                0, NULL, 0);


            SdIndex = SAMP_GROUP_SECURITY_DESCRIPTOR;

            break;


        case SampAliasObjectType:

            NtStatus = SampSetVariableAttribute(pObject,
                                                SAMP_ALIAS_MEMBERS,
                                                0, NULL, 0);

            SdIndex = SAMP_ALIAS_SECURITY_DESCRIPTOR;

            break;

        case SampDomainObjectType:

            SdIndex = SAMP_DOMAIN_SECURITY_DESCRIPTOR;
            break;

    case SampServerObjectType:

            SdIndex = SAMP_SERVER_SECURITY_DESCRIPTOR;
            break;

        default:

            ASSERT(FALSE&&"Unknown Object Type");
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Get the Nt5 security descriptor
    //
    NtStatus  =  SampGetObjectSD(pObject,
                                 &SdLength,
                                 &Nt4SecDescr);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus =  SampConvertNt4SdToNt5Sd(Nt4SecDescr,
                                        pObject->ObjectType,
                                        pObject,
                                        &Nt5SecDescr
                                       );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    SdLength = GetSecurityDescriptorLength(Nt5SecDescr);

    NtStatus = SampSetAccessAttribute(pObject,
                                      SdIndex,
                                      Nt5SecDescr,
                                      SdLength);

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Check all per attribute Dirty Bits in the
        // context
        //

        RtlSetAllBits(&pObject->PerAttributeDirtyBits);
    }


Cleanup:

    if ( Nt4SecDescr ) {
        MIDL_user_free(Nt4SecDescr);
    }

    if ( Nt5SecDescr ) {
        MIDL_user_free(Nt5SecDescr);
    }

    return NtStatus;

}


NTSTATUS
SampRegObjToDsObj(
     IN OUT  PSAMP_OBJECT     pObject,
     OUT     ATTRBLOCK**      ppAttrBlock
     )
/*++

    This routine changes pObject from a Registry Object to a DS Object; as well
    it creates a ATTRBLOCK from the data in pObject.

Parameters:

    pObject - a non pointer to the SAM object to be converted

    ppAttrBlock - a non null pointer to location where a pointer to the attrblock
                  can be placed

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/

{
    NTSTATUS NtStatus;

    ULONG TotalLength      = 0,
          FixedLength      = 0,
          VarArrayLength   = 0,
          VarLength        = 0;

    PSAMP_VARIABLE_LENGTH_ATTRIBUTE pVarLengthAttr;
    PBYTE  pNewOnDisk, pTemp;
    ULONG i;

    PSAMP_VARIABLE_LENGTH_ATTRIBUTE pVarLengthAttrTemp;

    SAMTRACE("SampRegObjToDsObj");

    //
    // Begin lazy thread transactioning.
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Adjust attributes so object have NT5 style properties
    //
    NtStatus = SampNt4ToNt5Object(pObject);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Convert SAM registry object to a SAM ds object
    //

    //
    // Determine the length of all of the data
    //

    FixedLength = SampObjectInformation[pObject->ObjectType].FixedLengthSize;

    VarArrayLength = SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount *
                   sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE);

    pVarLengthAttr = SampVariableArrayAddress(pObject);

    VarLength = pVarLengthAttr[SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount-1].Offset +
                pVarLengthAttr[SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount-1].Length;

    //
    //  Adjust the offset since SAM/DS objects' offsets are based from the beginning of the
    // variable attribute array.
    //
    for ( i = 0; i < SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount; i++ ) {
        pVarLengthAttr[i].Offset += VarArrayLength;
    }

    TotalLength = FixedLength + VarArrayLength + VarLength;

    // Reserve the space for the new OnDisk buffer
    pNewOnDisk = RtlAllocateHeap(RtlProcessHeap(), 0, TotalLength);
    if ( !pNewOnDisk ) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(pNewOnDisk, TotalLength);

    //
    // Now copy over the attributes into the new buffer
    //

    pTemp = pNewOnDisk;
    RtlCopyMemory(pTemp, SampFixedBufferAddress(pObject), FixedLength);

    pTemp = pNewOnDisk + SampDwordAlignUlong(FixedLength);
    RtlCopyMemory(pTemp, SampVariableArrayAddress(pObject), VarArrayLength);

    pTemp = pNewOnDisk + SampDwordAlignUlong(FixedLength + VarArrayLength);
    RtlCopyMemory(pTemp, (PBYTE)pObject->OnDisk + SampVariableDataOffset(pObject), VarLength);

    //
    // Transfer the memory
    //
    RtlFreeHeap(RtlProcessHeap(), 0, pObject->OnDisk);
    pObject->OnDisk = pNewOnDisk;

    pObject->OnDiskAllocated = TotalLength;
    pObject->OnDiskUsed = TotalLength;
    pObject->OnDiskFree = 0;
    SetDsObject(pObject);

    //
    // Now convert into ATTRBLOCK for DS
    //

    NtStatus = SampConvertCombinedAttributesToAttrBlock(
                   pObject,
                   SampDsFixedBufferLength(pObject),
                   SampDsVariableBufferLength(pObject),
                   ppAttrBlock);


    return NtStatus;


}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private routines                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
SampDsIsAlreadyValidData(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    )

/*++

Description:

    This routine determines whether or not the attributes are in memory or
    not (i.e. valid or not). OnDisk should only be NULL for a newly created
    context that has just been initialized, otherwise it is non-NULL.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

Return Values:

    This routine returns a flag, TRUE if the attributes are in memory, FALSE
    otherwise.

--*/

{
    BOOLEAN Flag = FALSE;

    SAMTRACE("SampDsIsAlreadyValidData");

    if (NULL != Context->OnDisk)
    {
        if (AttributeGroup == SAMP_FIXED_ATTRIBUTES)
        {
            if (SampFixedAttributesValid(Context))
            {
                Flag = TRUE;
            }
        }
        else
        {
            ASSERT(AttributeGroup == SAMP_VARIABLE_ATTRIBUTES);

            if (SampVariableAttributesValid(Context))
            {
                Flag = TRUE;
            }
        }
    }

    return(Flag);
}



NTSTATUS
SampDsPrepareAttrBlock(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG FixedCount,
    IN PSAMP_FIXED_ATTRIBUTE_TYPE_INFO FixedAttrIds[],
    IN ULONG VarCount,
    IN ULONG WhichFields,
    IN PSAMP_VAR_ATTRIBUTE_TYPE_INFO VarAttrIds[],
    OUT PDSATTRBLOCK AttrBlock
    )

/*++

Description:

    This routine sets up a DSATTRBLOCK in preparation to read the DS. An
    attribute block is created containaing the attribute identifiers for
    the attributes to read.

Parameters:

    FixedCount - Number of fixed-length attributes.

    FixedAttrIds - Array of attribute IDs of the fixed-length attributes.

    VarCount - Number of variable-length attributes.

    VarAttrIds - Array of attribute IDs of the fixed-length attributes.

    AttrBlock - Pointer, the generated attribute block with IDs.

Return Values:

    STATUS_SUCCESS if successful, error otherwise.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG i = 0;
    ULONG Index=0;
    ULONG AttrCount = FixedCount + VarCount;
    PDSATTR Attributes = NULL;

    SAMTRACE("SampDsPrepareAttrBlock");

    Attributes = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 AttrCount * sizeof(DSATTR));

    if (NULL != Attributes)
    {
        RtlZeroMemory(Attributes, (AttrCount * sizeof(DSATTR)));

        // This loop is set up to handle the case where both fixed-length
        // and variable-length attribute buffers are passed in (which may
        // be needed for combined attribute conversion).

        AttrBlock->attrCount=0;
        for (i = 0; i < AttrCount; i++)
        {
            if (i < FixedCount)
            {
                // Set the fixed-length attribute type/id.

                Attributes[Index].attrTyp = FixedAttrIds[i].Type;
            }
            else
            {
                // ASSERT(0 <= (i - FixedCount));

                // Set the variable-length attribute type/id.
                // Do not request the group membership attributes

                if ((0!=WhichFields) && 
                   (VarAttrIds[i-FixedCount].FieldIdentifier !=0) &
                   ((VarAttrIds[i-FixedCount].FieldIdentifier & WhichFields)==0))
                {
                    continue;
                }

                if (VarAttrIds[i-FixedCount].IsGroupMembershipAttr)
                {
                    continue;
                }



                Attributes[Index].attrTyp = VarAttrIds[i - FixedCount].Type;
            }

            // The read operation does not require setting up valCount or
            // pAVal.

            Attributes[Index].AttrVal.valCount = 0;
            Attributes[Index].AttrVal.pAVal = NULL;
            AttrBlock->attrCount++;
            Index++;
        }

        // Hook up the attributes to the top-level attrblock and return.

        AttrBlock->pAttr = Attributes;

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampDsMakeAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN ULONG WhichFields,
    OUT PDSATTRBLOCK AttrBlock
    )

/*++

Description:

    This routine determines the object type and sets the count of fixed-
    length and variable-length attributes for the object. SampDsPrepare-
    AttrBlock to set up the DSATTRBLOCK.

Parameters:

    ObjectType - SAM object ID.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

    AttrBlock - Pointer, generated attribute block.

Return Values:

    STATUS_SUCCESS if no errors.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG FixedLenAttrCount = 0;
    ULONG VarLenAttrCount = 0;

    SAMTRACE("SampDsMakeAttrBlock");

    switch(ObjectType)
    {

    case SampServerObjectType:
        FixedLenAttrCount = SAMP_SERVER_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:
        FixedLenAttrCount = SAMP_DOMAIN_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:
        FixedLenAttrCount = SAMP_GROUP_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:
        FixedLenAttrCount = SAMP_ALIAS_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:
        FixedLenAttrCount = SAMP_USER_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        ASSERT(FALSE && "Invalid SampObjectType");
        break;

    }

    if ((0 < FixedLenAttrCount) && (0 < VarLenAttrCount))
    {
        if (SAMP_FIXED_ATTRIBUTES == AttributeGroup)
        {
            NtStatus = SampDsPrepareAttrBlock(
                            ObjectType,
                            FixedLenAttrCount,
                            &SampFixedAttributeInfo[ObjectType][0],
                            0,
                            WhichFields,
                            NULL,
                            AttrBlock);
        }
        else
        {
            NtStatus = SampDsPrepareAttrBlock(
                            ObjectType,
                            0,
                            NULL,
                            VarLenAttrCount,
                            WhichFields,
                            &SampVarAttributeInfo[ObjectType][0],
                            AttrBlock);
        }
    }

    return(NtStatus);
}



NTSTATUS
SampDsConvertReadAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN PDSATTRBLOCK AttrBlock,
    OUT PVOID *SamAttributes,
    OUT PULONG FixedLength,
    OUT PULONG VariableLength
    )

/*++

Description:

    This routine converts an attribute block (DSATTRBLOCK) into a SAM attri-
    bute buffer. This is used to convert the resultant attributes from a DS
    read into the SAM attribute format.

Parameters:

    ObjectType - SAM object ID.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

    AttrBlock - Pointer, input attribute block.

    SamAttributes - Pointer, returned SAM attributes.

    FixedLength - Pointer, byte count of the fixed-length attributes size.

    VariableLength - Pointer, byte count of the variable-length attributes
        size.

Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampDsConvertReadData");

    // Initialize the returned lengths and buffer.

    *FixedLength = 0;
    *VariableLength = 0;
    *SamAttributes = NULL;

    if (SAMP_FIXED_ATTRIBUTES == AttributeGroup)
    {
        NtStatus = SampConvertAttrBlockToFixedLengthAttributes(
                        ObjectType,
                        AttrBlock,
                        SamAttributes,
                        FixedLength);
    }
    else
    {
        NtStatus = SampConvertAttrBlockToVarLengthAttributes(
                        ObjectType,
                        AttrBlock,
                        (SAMP_VARIABLE_LENGTH_ATTRIBUTE**)SamAttributes,
                        VariableLength);
    }

    return(NtStatus);
}



NTSTATUS
SampDsUpdateContextFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG FixedLength,
    IN PVOID SamAttributes
    )

/*++

Description:

    This routine updates the SAM context fixed-length attributes if the size
    of the attributes have changed. For fixed-length attributes, this only
    occurs when a revision of the fixed-length data structures has caused a
    size change in the structures.

Parameters:

    Context - Pointer to an object context block.

    FixedLength - Byte count of the fixed-length attributes.

    SamAttributes - Pointer, the SAM fixed-length attributes.


Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NewLength = 0;
    PBYTE Buffer = NULL;
    PBYTE VariableData = NULL;
    ULONG VariableLength = 0;

    SAMTRACE("SampDsUpdateContextFixedAttributes");

    // The first time through, the variable-buffer length will be zero, so
    // the new length is only the fixed length. Note that OnDiskAllocated is
    // also zero (a global) so don't attempt to use the variable-buffer
    // offset in the calculation.


    NewLength = FixedLength;


    Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, NewLength);

    if (NULL != Buffer)
    {
        // Zero the new buffer and copy the fixed-length attributes into it.

        RtlZeroMemory(Buffer, NewLength);
        RtlCopyMemory(Buffer, SamAttributes, FixedLength);

        if (NULL != Context->OnDisk)
        {
            // Save the current address and length of the variable data, if
            // it exists. The first time through, the variable data is NULL.
            // Release the old buffer.

            VariableData = SampDsVariableBufferAddress(Context);
            VariableLength = SampDsVariableBufferLength(Context);
            RtlCopyMemory(Buffer + FixedLength, VariableData, VariableLength);

            // Free the old OnDisk buffer.

            RtlFreeHeap(RtlProcessHeap(), 0, Context->OnDisk);
        }

        // Reset the context attribute buffer to the new buffer.

        Context->OnDisk = Buffer;

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampDsUpdateContextVariableAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG VariableLength,
    IN PVOID SamAttributes
    )

/*++

Description:

    This routine updates the SAM context variable-length attributes if the
    size of the attributes has changed. Unlike the fixed-length attributes,
    this will occur frequently due to fact that these attributes are vari-
    able length.

Parameters:

    Context - Pointer to an object context block.

    FixedLength - Byte count of the fixed-length attributes.

    SamAttributes - Pointer, the SAM fixed-length attributes.

Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG NewLength = 0;
    PBYTE Buffer = NULL;
    PBYTE FixedData = NULL;
    ULONG FixedLength = 0;

    SAMTRACE("SampDsUpdateContextVariableAttributes");

    // Get the current fixed-buffer length, add the new variable length, and
    // allocate the new buffer.

    NewLength = SampDsFixedBufferLength(Context) + VariableLength;
    Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, NewLength);

    if (NULL != Buffer)
    {
        RtlZeroMemory(Buffer, NewLength);

        // Context->OnDisk should never be NULL in this routine.

        ASSERT(NULL != Context->OnDisk);


        // Get the fixed-length buffer address and length...

        FixedData = SampDsFixedBufferAddress(Context);
        FixedLength = SampDsFixedBufferLength(Context);

        ASSERT(NULL!=FixedData);
        ASSERT(FixedLength>0);


        // Copy the fixed data into the new buffer and append the
        // variable-length data.

        RtlCopyMemory(Buffer, FixedData, FixedLength);

        RtlCopyMemory(Buffer + FixedLength,
                      SamAttributes,
                      VariableLength);

        // Release the old attribute buffer and reset OnDisk to
        // point at the new buffer.

        RtlFreeHeap(RtlProcessHeap(), 0, Context->OnDisk);
        Context->OnDisk = Buffer;

        NtStatus = STATUS_SUCCESS;

    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampUpdateOffsets(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN FirstTimeInitialization
    )

/*++

Description:

    This routine updates the buffer (OnDisk) offset and length information
    that is stored in the object information (SAMP_OBJECT_INFORMATION) and
    in the instance information (SAMP_OBJECT), after the attributes have
    been successfully updated.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    INT ObjectType = Context->ObjectType;
    ULONG FixedDataLength = 0;
    ULONG VariableArrayLength = 0;
    ULONG VariableDataOffset = 0;
    ULONG VariableDataLength = 0;
    ULONG TotalBufferLength = 0;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE VariableArray = NULL;
    ULONG i = 0;
    ULONG AttributeCount = 0;

    // Determine the SAM object type and compute the length of the fixed-
    // length attributes and the length of the variable-length attribute
    // array, which will be used as buffer offsets.

    SAMTRACE("SampUpdateOffsets");

    switch(ObjectType)
    {

    case SampServerObjectType:

        FixedDataLength = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);
        AttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:

        FixedDataLength = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);
        AttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:

        FixedDataLength = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);
        AttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:

        FixedDataLength = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);
        AttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:

        FixedDataLength = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);
        AttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        // Invalid object type specified.

        ASSERT(FALSE && "Invalid Object Type");
        NtStatus = STATUS_INTERNAL_ERROR;
        break;

    }

    VariableArrayLength = (AttributeCount *
                           sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE));

    if (NT_SUCCESS(NtStatus))
    {
        // First, update the object information offsets and lengths.

        SampObjectInformation[ObjectType].FixedDsAttributesOffset =
            0;

        SampObjectInformation[ObjectType].FixedDsLengthSize =
            FixedDataLength;

        SampObjectInformation[ObjectType].VariableDsBufferOffset =
            FixedDataLength;

        SampObjectInformation[ObjectType].VariableDsArrayOffset =
            FixedDataLength;

        SampObjectInformation[ObjectType].VariableDsDataOffset =
            FixedDataLength + VariableArrayLength;

        if (FALSE == FirstTimeInitialization)
        {
            // Get a pointer to the array of variable-length information and
            // total up the lengths of these attributes.

            VariableArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                            ((PBYTE)(Context->OnDisk) + FixedDataLength);

            for (i = 0; i < AttributeCount; i++)
            {
                VariableDataLength = VariableDataLength + SampDwordAlignUlong(VariableArray[i].Length);
            }
        }
        else
        {
            // The first time through, the attribute buffer only contains
            // the fixed-length attributes, so make sure the lengths for
            // the variable attributes are zero.

            VariableArrayLength = 0;
            VariableDataLength = 0;
        }

        TotalBufferLength = FixedDataLength +
                            VariableArrayLength +
                            VariableDataLength;
    }

    // Finally, update the instance information of the object's context.

    Context->OnDiskAllocated = TotalBufferLength;
    Context->OnDiskUsed = TotalBufferLength;

    // The DS routines do not allocate extra space at the end of the SAM
    // OnDisk buffer, hence OnDiskFree is always zero.

    // BUG: Should allocate extra OnDisk buffer free space for growth.

    Context->OnDiskFree = 0;

    DebugPrint("OnDiskAllocated = %lu\n", Context->OnDiskAllocated);
    DebugPrint("OnDiskUsed = %lu\n", Context->OnDiskUsed);
    DebugPrint("OnDiskFree = %lu\n", Context->OnDiskFree);

    return(NtStatus);
}



NTSTATUS
SampDsUpdateContextAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN PVOID SamAttributes,
    IN ULONG FixedLength,
    IN ULONG VariableLength
    )

/*++

Description:

    This routine updates an object's attribute buffer (OnDisk) for the given
    context. If the new buffer size is the same as the old size, as in the
    case of modifications, then a simple memory copy is performed, otherwise
    helper routines are called to resize the buffer and copy the data. A sub-
    sequent helper routine is called to update the context buffer lengths
    and offsets.

Parameters:

    Context - Pointer to an object context block.

Return Values:

    STATUS_SUCCESS

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    INT ObjectType = Context->ObjectType;
    PBYTE FixedLengthData = NULL;
    PBYTE VariableLengthData = NULL;
    BOOLEAN FirstTimeInitialization = FALSE;

    SAMTRACE("SampDsUpdateContextAttributes");

    // The current version of SAM contains a hack that resets all attributes
    // whenever the variable-length ones are asked for. This allows both the
    // fixed and variable attributes to be set even if FixedStoredSeparately
    // is TRUE. This routine does not maintain that behavior, which may create
    // problems for SAM. If so, the caller of this routine will need to call
    // it twice, once for fixed and once for variable attributes in the cases
    // where FixedStoredSeparately is TRUE.

    if (SAMP_FIXED_ATTRIBUTES == AttributeGroup)
    {
        // Update the fixed-length attributes. The first time through, OnDisk
        // will be NULL.

        //
        // In DS Mode the size of the fixed length attribute structure is
        // constant. There is never a case where less data is returned.
        //

        ASSERT(SampDsFixedBufferLength(Context) == FixedLength);

        if (NULL != Context->OnDisk)
        {
            // The fixed-length data is the same size (i.e. not
            // doing an upgrade), so copy the new attributes and
            // release the buffer.

            FixedLengthData = SampDsFixedBufferAddress(Context);

            RtlCopyMemory(FixedLengthData,
                          (PBYTE)SamAttributes,
                          FixedLength);

            NtStatus = STATUS_SUCCESS;
        }
        else
        {


            // The new attributes are not the same size as the old ones.

            NtStatus = SampDsUpdateContextFixedAttributes(Context,
                                                          FixedLength,
                                                          SamAttributes
                                                          );

            // Fixed-attribute size changes when the context attributes
            // have been set for the first time (i.e. changed from zero to
            // actual sizes), or when the fixed-length structures are
            // changed in an upgrade scenario.

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampUpdateOffsets(
                                Context,
                                TRUE //FirstTimeInitialization
                                );


            }
        }

        if(NT_SUCCESS(NtStatus))
        {
            Context->FixedValid = TRUE;
        }
        else
        {
            Context->FixedValid = FALSE;
        }

    }
    else
    {
        //
        // Update the variable-length attributes. In the event that the
        //


        //
        // ASSERT that Context->OnDisk is not NULL. This is because we will
        // always ask for a refresh of the fixed attributes before we refresh
        // the variable attributes.
        //

        ASSERT(NULL!=Context->OnDisk);

        // The new attributes are not the same size as the old
        // ones.

        NtStatus = SampDsUpdateContextVariableAttributes(
                        Context,
                        VariableLength,
                        SamAttributes);

        // Variable-attribute size changes when the context attributes
        // have been set for the first time (i.e. changed from zero to
        // actual sizes), or when the variable-length data has changed
        // size.

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampUpdateOffsets(Context, FirstTimeInitialization);
        }

        if(NT_SUCCESS(NtStatus))
        {
            Context->VariableValid = TRUE;
        }
        else
        {
            Context->VariableValid = FALSE;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampValidateDsAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    )

/*++

Description:

    Ensure specified attributes are in-memory. If they are not, then read
    them from the DS backing store. This routine fetches all of the stored
    attributes for a given SAM object. To read a single attribute, or a
    subset of attributes, SampDsRead should be used to selectively fetch
    attributes. Context->OnDisk is updated with the new attributes.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - identifies which kind of attributes are being validated
        (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).

Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.
        This routine returns a flag, TRUE if the attributes are in memory, FALSE
        otherwise.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Flags = 0;
    INT ObjectType = -1;
    DSATTRBLOCK ReadAttrBlock;
    DSATTRBLOCK ResultAttrBlock;
    ULONG FixedLength = 0;
    ULONG VariableLength = 0;
    PVOID SamAttributes = NULL;

    SAMTRACE("SampValidateDsAttributes");

    // The data might already be in memory, so check it out.

    if (!SampDsIsAlreadyValidData(Context, AttributeGroup))
    {
        ASSERT(NULL!=Context->ObjectNameInDs);

        ObjectType = Context->ObjectType;

        RtlZeroMemory(&ReadAttrBlock, sizeof(DSATTRBLOCK));
        RtlZeroMemory(&ResultAttrBlock, sizeof(DSATTRBLOCK));

        // Construct the input ATTRBLOCK used to specify which attributes
        // should be read from the DS.

        NtStatus = SampDsMakeAttrBlock(ObjectType,
                                       AttributeGroup,
                                       0,
                                       &ReadAttrBlock);

        if (NT_SUCCESS(NtStatus))
        {

            ASSERT(NULL != ReadAttrBlock.pAttr);

            // Read the attributes from the DS, flags is currently unused.

            NtStatus = SampDsRead(Context->ObjectNameInDs,
                                  Flags,
                                  ObjectType,
                                  &ReadAttrBlock,
                                  &ResultAttrBlock);

            if (NT_SUCCESS(NtStatus))
            {
                // Convert the ATTRBLOCK into the appropriate SAM attri-
                // butes, returning them in the SamAttributes buffer. Note
                // that the returned lengths are as follows:
                //
                // FixedLength - The byte count of the returned fixed-
                // length buffer
                //
                // VariableLength - The byte count of the returned var-
                // able-length buffer.

                ASSERT(NULL != ResultAttrBlock.pAttr);


                NtStatus = SampDsConvertReadAttrBlock(ObjectType,
                                                      AttributeGroup,
                                                      &ResultAttrBlock,
                                                      &SamAttributes,
                                                      &FixedLength,
                                                      &VariableLength);

                if (NT_SUCCESS(NtStatus))
                {

                    ASSERT(NULL!=SamAttributes);

                    NtStatus = SampDsUpdateContextAttributes(
                                    Context,
                                    AttributeGroup,
                                    SamAttributes,
                                    FixedLength,
                                    VariableLength);

                    RtlFreeHeap(RtlProcessHeap(), 0, SamAttributes);

                }
            }
        }

        RtlFreeHeap(RtlProcessHeap(),0,ReadAttrBlock.pAttr);
    }
    else
    {
        NtStatus = STATUS_SUCCESS;
        ASSERT(NULL!=Context->OnDisk);
    }

    //
    // If we succeeded then Context->OnDisk must not be NULL.
    //

    ASSERT(((NT_SUCCESS(NtStatus)) && (NULL != Context->OnDisk)) ||
           (!NT_SUCCESS(NtStatus)));

    if ((NT_SUCCESS(NtStatus)) && (NULL == Context->OnDisk))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampValidateDsAttributes status = 0x%lx OnDisk address = 0x%lx\n",
                   NtStatus,
                   Context->OnDisk));

        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampValidateRegAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    )

/*++

    Ensure specified attributes are in-memory.
    If they are not, then read them from backing store.



Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - identifies which kind of attributes are being
        validated (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).



Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        RequiredLength,
        TotalRequiredLength,
        BufferLength;

    PUCHAR
        Buffer;

    PUNICODE_STRING
        KeyAttributeName;

    BOOLEAN
        CreatedObject = FALSE;

    SAMTRACE("SampValidateRegAttributes");


    //
    // The data might already be in memory.
    //

    if (AttributeGroup == SAMP_FIXED_ATTRIBUTES) {
        if (SampFixedAttributesValid( Context )) {
            ASSERT(Context->OnDisk != NULL);
            return(STATUS_SUCCESS);
        }

    } else {

        ASSERT( AttributeGroup == SAMP_VARIABLE_ATTRIBUTES );
        if (SampVariableAttributesValid( Context )) {
            ASSERT(Context->OnDisk != NULL);
            return(STATUS_SUCCESS);
        }
    }



    //
    // Retrieve it from the registry, or allocate it if new.
    //


    NtStatus = SampGetAttributeBufferReadInfo(
                   Context,
                   AttributeGroup,
                   &Buffer,
                   &BufferLength,
                   &KeyAttributeName
                   );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    if ( Context->RootKey != INVALID_HANDLE_VALUE ) {

        //
        // Account exists on disk, so read in the attributes.
        //

        NtStatus = SampReadRegistryAttribute( Context->RootKey,
                                              Buffer,
                                              BufferLength,
                                              KeyAttributeName,
                                              &RequiredLength
                                              );

        RequiredLength = SampDwordAlignUlong(RequiredLength);

        if ( ( SampObjectInformation[Context->ObjectType].FixedStoredSeparately ) &&
            ( AttributeGroup == SAMP_VARIABLE_ATTRIBUTES ) ) {

            //
            // RequiredLength was returned to us as the length of the
            // variable attributes on the disk.  However, we're going
            // to be using it to determine the total buffer size as well
            // as to set how much of the buffer is in use, so we must add
            // the size of the fixed stuff that preceeds the variable
            // buffer.
            //

            TotalRequiredLength = RequiredLength +
                                  SampVariableBufferOffset( Context );

        } else {

            //
            // Either the attribute groups are read together, or we're
            // reading in the fixed attribute group.  Either way, we
            // already have the total size we need.
            //

            TotalRequiredLength = RequiredLength;
        }

        if ((NtStatus == STATUS_BUFFER_TOO_SMALL) ||
            ( NtStatus == STATUS_BUFFER_OVERFLOW ) ) {

            NtStatus = SampExtendAttributeBuffer( Context, TotalRequiredLength );
            if (!NT_SUCCESS(NtStatus)) {
                return(NtStatus);
            }

            NtStatus = SampGetAttributeBufferReadInfo(
                           Context,
                           AttributeGroup,
                           &Buffer,
                           &BufferLength,
                           &KeyAttributeName
                           );
            if (!NT_SUCCESS(NtStatus)) {
                return(NtStatus);
            }

            NtStatus = SampReadRegistryAttribute( Context->RootKey,
                                                  Buffer,
                                                  BufferLength,
                                                  KeyAttributeName,
                                                  &RequiredLength
                                                  );

        }

    } else {

        //
        // We're creating a new object.
        //
        // Initialize the requiredlength to the amount of the buffer
        // we have used when we created the empty attributes. This will
        // be the value stored in OnDiskUsed.
        //
        // Note OnDiskUsed is only used by operations on the variable
        // length attributes.
        //

        TotalRequiredLength = SampVariableDataOffset(Context);

        ASSERT(TotalRequiredLength <= Context->OnDiskAllocated);

        CreatedObject = TRUE;
    }



    //
    // if we read something, indicate that the corresponding buffer
    // (and maybe both) are now valid.
    //
    // Also set the used and free information for the buffer if necessary.
    //

    if (NT_SUCCESS(NtStatus)) {
        if (SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

            //
            // only one attribute group was read in
            //

            if (AttributeGroup == SAMP_FIXED_ATTRIBUTES) {
                Context->FixedValid = TRUE;
                Context->FixedDirty = FALSE;
            } else {

                ASSERT(AttributeGroup == SAMP_VARIABLE_ATTRIBUTES);
                Context->VariableValid = TRUE;
                Context->VariableDirty = FALSE;
                ClearPerAttributeDirtyBits(Context);

                Context->OnDiskUsed = SampDwordAlignUlong(TotalRequiredLength);
                Context->OnDiskFree = Context->OnDiskAllocated -
                                      Context->OnDiskUsed;
            }
        } else {

            //
            // Both attribute groups read in.
            //

            Context->FixedValid = TRUE;
            Context->FixedDirty = FALSE;

            Context->VariableValid = TRUE;
            Context->VariableDirty = FALSE;
            ClearPerAttributeDirtyBits(Context);

            Context->OnDiskUsed = SampDwordAlignUlong(TotalRequiredLength);
            Context->OnDiskFree = Context->OnDiskAllocated -
                                  Context->OnDiskUsed;
        }
    }

    if (NT_SUCCESS(NtStatus) && !CreatedObject) {

        //
        // make any adjustments necessary to bring the data
        // just read in up to current revision format.
        //

        NtStatus = SampUpgradeToCurrentRevision(
                        Context,
                        AttributeGroup,
                        Buffer,
                        RequiredLength,
                        &TotalRequiredLength
                        );
    }

#ifdef SAM_DEBUG_ATTRIBUTES
    if (SampDebugAttributes) {
        DbgPrint("SampValidateAttributes - initialized the context :\n\n");
        SampDumpAttributes(Context);
    }
#endif

    return(NtStatus);
}



NTSTATUS
SampValidateAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN ULONG Attribute,
    IN BOOLEAN SetOperation
    )

/*++

Routine Description:

    This routine determines from the object context whether to validate object
    attributes residing in the registry or in the DS backing store, and then
    calls the appropriate routine to do the work.

Arguments:

    Context - Pointer, the object's SAM context.

    AttributeGroup - identifies which kind of attributes are being validated
        (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).

Return Value:

    STATUS_SUCCESS - attributes were checked and read from storage if neces-
        sary without a problem, otherwise an error code is returned.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampValidateAttributes");

    if (NULL != Context)
    {
        if (IsDsObject(Context))
        {
            if (NULL != Context->OnDisk)
            {
                // The SAM object attributes have been set atleast once, so
                // update them if needed. If variable attributes are present 
                // and are only partially valid, then we need to go back 
                // and fetch the full set



                if ((Context->AttributesPartiallyValid && SetOperation)
                    || ((SAMP_VARIABLE_ATTRIBUTES==AttributeGroup) &&
                        ( SampIsAttributeInvalid(Context, Attribute) )))
                {
                    //
                    // Context->OnDisk is non NULL but it is unfortunately missing
                    // some attributes. There are 2 cases of this
                    //
                    //  1. We want to read and the attribute that we are interested 
                    //     in has not been prefetched
                    //
                    //  2. We want to write and some attribute has not been prefetched
                    //     Since we do not want to handle the complexity of prefetching
                    //     another attribute, when he have changes in the on disk and
                    //     hence will not be able to discard the on disk, we will
                    //     prefetch again all the attributes.
                    //
                    // We do not discard the OnDisk in the context, right now -- 
                    // would be bad to free the OnDisk as there is plenty of code that
                    // that references and keeps temporary pointers to the ondisk structure
                    // till the context is dereferenced. Note we will never need to buffer
                    // up more than one on disk in the context because when we detect an
                    // attribute to be missing we fetch all attributes
                    //


                    ASSERT(Context->PreviousOnDisk == NULL);

                    if (Context->PreviousOnDisk!=NULL)
                    {
                        MIDL_user_free(Context->PreviousOnDisk);
                        Context->PreviousOnDisk = NULL;
                    }

                    Context->FixedValid = FALSE;
                    Context->VariableValid = FALSE;
                    Context->FixedDirty = FALSE;
                    Context->VariableDirty = FALSE;
                    Context->PreviousOnDisk = Context->OnDisk;
                    Context->OnDisk = NULL;
                    Context->OnDiskAllocated = 0;
                    Context->OnDiskUsed = 0;
                    Context->OnDiskFree = 0;


    #if DBG
                    if ((SAMP_VARIABLE_ATTRIBUTES==AttributeGroup) &&
                            ( SampIsAttributeInvalid(Context, Attribute) ))
                    {
                        ASSERT(FALSE && "Ignorable assert;catches additional DS reads due to incorrect prefetch hints");
                    }
    #endif

                    NtStatus = SampValidateDsAttributes(Context, SAMP_FIXED_ATTRIBUTES);
                    if (NT_SUCCESS(NtStatus))
                    {
                        NtStatus = SampValidateDsAttributes(Context,SAMP_VARIABLE_ATTRIBUTES);
                        if (NT_SUCCESS(NtStatus))
                        {
                            SampMarkPerAttributeInvalidFromWhichFields(Context, 0);
                            Context->AttributesPartiallyValid = FALSE;
                        }
                    }
                }
                else
                {
                    NtStatus = SampValidateDsAttributes(Context,AttributeGroup);
                }
            }
            else if ( SAMP_FIXED_ATTRIBUTES == AttributeGroup)
            {
                //
                // Set the fixed length attributes
                //

                NtStatus = SampValidateDsAttributes(
                                Context,
                                SAMP_FIXED_ATTRIBUTES);

            }
            else
            {
                // The SAM object attributes have never been set because this
                // is a new context. First set the fixed-length attributes and
                // then the variable-length ones.



                // If the OnDisk buffer is NULL, make sure that the fixed-
                // length attributes are loaded first.

                NtStatus = SampValidateDsAttributes(
                                Context,
                                SAMP_FIXED_ATTRIBUTES);

                if (NT_SUCCESS(NtStatus))
                {


                     NtStatus = SampValidateDsAttributes(
                                     Context,
                                     SAMP_VARIABLE_ATTRIBUTES);
                }
            }
        }
        else
        {
            NtStatus = SampValidateRegAttributes(Context, AttributeGroup);
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



NTSTATUS
SampUpgradeToCurrentRevision(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN OUT PUCHAR Buffer,
    IN ULONG  LengthOfDataRead,
    IN OUT PULONG TotalRequiredLength
    )

/*++

    Make any changes necessary bring attributes just read in
    from disk up to the current revision level format.

    When we upgrade our attribute format, we don't bother changing
    all data on disk.  We take a lazy update approach, and only change
    the data as it is changed for other operations.  This means that
    data we read from disk may be from revision 1.  When this is
    detected, the data is copied into a current revision structure,
    and a pointer to that buffer is returned.




    NOTE: For future reference, GROUP and ALIAS objects have
          a revision level stored as a "Qualifier" value associated
          with the security descriptor attribute.  The SERVER object
          stores the revision level in its fixed length attributes.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - identifies which kind of attributes are being
        validated (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).

    Buffer - Pointer to the buffer containing the attributes.

    LengthOfDataRead - This is an important value.  It must be the value
        returned from the registry on the read operation.  This tells us
        exactly how many bytes of data were retrieved from disk.

    TotalRequiredLength - Will be left unchanged if no update was
        was required.  If an updated was made, this will be adjusted
        to reflect the new length of the data.

Return Values:

    None.


--*/

{

    LARGE_INTEGER
        ZeroModifiedCount  = {0,0};
    PULONG
        Pointer;
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampUpgradeToCurrentRevision");


    //
    // Note that Buffer points inside a buffer that is
    // hung off the Context block.  We don't need to re-allocate
    // a new attributes buffer because we are only changing
    // fixed-length attributes in this release (and the variable
    // length attributes were placed beyond the end of the new
    // format fixed-length data).
    //
    // The approach we take is to copy the current fixed-length
    // contents into a temporary buffer, and then copy them back
    // into the attribute buffer.  This can be done with stack
    // variables.
    //

    //
    // Switch on the type of objects that have gone through revision
    // changes.
    //

    switch (Context->ObjectType) {
        case SampDomainObjectType:

            //
            // Domain FIXED_LENGTH attributes have had the following
            // revisions:
            //
            //       Revision 0x00010001 -  NT1.0  (Revision NOT stored in  )
            //                                     (record.                 )
            //                                     (Must ascertain revision )
            //                                     (by record length.       )
            //
            //       Revision 0x00010002 -  NT1.0a (Revision is first ULONG )
            //                                     (in record.              )
            //       Revision 0x00010003 -  NT 3.5 - 4.0
            //       Revision 0x00010003 -  NT 4.0 SP3 ( Revision is ascertained
            //                                      by record length ).
            //       Revision 0x00010003 - Win2k ( Revision is ascertained 
            //                                      by record length )
            //

            if (LengthOfDataRead ==
                (sizeof(SAMP_V1_0_FIXED_LENGTH_DOMAIN) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) ) {

                PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
                    V1aFixed;

                SAMP_V1_0_FIXED_LENGTH_DOMAIN
                    V1Fixed, *OldV1Fixed;


                //
                // Update from revision 0x00010001
                //
                // First, copy the current buffer contents into a temporary
                // buffer.
                //

                OldV1Fixed = (PSAMP_V1_0_FIXED_LENGTH_DOMAIN)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                RtlMoveMemory(&V1Fixed, OldV1Fixed, sizeof(SAMP_V1_0_FIXED_LENGTH_DOMAIN));


                //
                // Now copy it back in the new format
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)OldV1Fixed;

                V1aFixed->CreationTime             = V1Fixed.CreationTime;
                V1aFixed->ModifiedCount            = V1Fixed.ModifiedCount;
                V1aFixed->MaxPasswordAge           = V1Fixed.MaxPasswordAge;
                V1aFixed->MinPasswordAge           = V1Fixed.MinPasswordAge;
                V1aFixed->ForceLogoff              = V1Fixed.ForceLogoff;
                V1aFixed->NextRid                  = V1Fixed.NextRid;
                V1aFixed->PasswordProperties       = V1Fixed.PasswordProperties;
                V1aFixed->MinPasswordLength        = V1Fixed.MinPasswordLength;
                V1aFixed->PasswordHistoryLength    = V1Fixed.PasswordHistoryLength;
                V1aFixed->ServerState              = V1Fixed.ServerState;
                V1aFixed->ServerRole               = V1Fixed.ServerRole;
                V1aFixed->UasCompatibilityRequired = V1Fixed.UasCompatibilityRequired;


                //
                // And initialize fields new for this revision
                //

                V1aFixed->Revision                 = SAMP_REVISION;
                V1aFixed->LockoutDuration.LowPart  = 0xCF1DCC00; // 30 minutes - low part
                V1aFixed->LockoutDuration.HighPart = 0XFFFFFFFB; // 30 minutes - high part
                V1aFixed->LockoutObservationWindow.LowPart  = 0xCF1DCC00; // 30 minutes - low part
                V1aFixed->LockoutObservationWindow.HighPart = 0XFFFFFFFB; // 30 minutes - high part
                V1aFixed->LockoutThreshold         = 0; // Disabled

                // Initialize Session Key Info
                V1aFixed->Unused2[0] = 0;
                V1aFixed->Unused2[1] = 0;
                V1aFixed->Unused2[2] = 0;

                V1aFixed->DomainKeyAuthType = 0;
                V1aFixed->DomainKeyFlags = 0;

                RtlSecureZeroMemory(
                    V1aFixed->DomainKeyInformation,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                if (V1aFixed->ServerRole == DomainServerRolePrimary) {
                    V1aFixed->ModifiedCountAtLastPromotion = V1Fixed.ModifiedCount;
                } else {
                    V1aFixed->ModifiedCountAtLastPromotion = ZeroModifiedCount;
                }

                RtlSecureZeroMemory(
                    &V1aFixed->DomainKeyInformationPrevious,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                V1aFixed->CurrentKeyId = 1;
                V1aFixed->PreviousKeyId = 0;

            } else if (LengthOfDataRead ==
                (sizeof(SAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)))  {

                PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
                    V1aFixed;

                //
                // Handle the upgrade for NT4 SP3 to include domain key
                // information
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                V1aFixed->Unused2[0] = 0;
                V1aFixed->Unused2[1] = 0;
                V1aFixed->Unused2[2] = 0;
                V1aFixed->DomainKeyAuthType = 0;
                V1aFixed->DomainKeyFlags = 0;
                RtlSecureZeroMemory(
                    V1aFixed->DomainKeyInformation,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                RtlSecureZeroMemory(
                    &V1aFixed->DomainKeyInformationPrevious,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                V1aFixed->CurrentKeyId = 1;
                V1aFixed->PreviousKeyId = 0;

            } else if (LengthOfDataRead ==
                (sizeof(SAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)))  {

                PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
                    V1aFixed;

                //
                // Handle the upgrade for NT4 SP3 to include domain key
                // information
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                RtlSecureZeroMemory(
                    &V1aFixed->DomainKeyInformationPrevious,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                V1aFixed->CurrentKeyId = 1;
                V1aFixed->PreviousKeyId = 0;
            }


            break;  //out of switch



        case SampUserObjectType:

            //
            // User FIXED_LENGTH attributes have had the following
            // revisions:
            //
            //       Revision 0x00010001 -  NT1.0  (Revision NOT stored in  )
            //                                     (record.                 )
            //                                     (Must ascertain revision )
            //                                     (by record length.       )
            //
            //       Revision 0x00010002 -  NT1.0a (Revision is first ULONG )
            //                                     (in record.              )
            //       Revision 0x00010002a - NT3.5  (Revision is first ULONG )
            //                                     (in record, still        )
            //                                     (0x00010002.  Must       )
            //                                     (ascertain revison by    )
            //                                     (by record length        )

            if (LengthOfDataRead ==
                (sizeof(SAMP_V1_FIXED_LENGTH_USER) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) ) {

                PSAMP_V1_0A_FIXED_LENGTH_USER
                    V1aFixed;

                SAMP_V1_FIXED_LENGTH_USER
                    V1Fixed, *OldV1Fixed;


                //
                // Update from revision 0x00010001
                //
                // First, copy the current buffer contents into a temporary
                // buffer.
                //

                OldV1Fixed = (PSAMP_V1_FIXED_LENGTH_USER)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                RtlMoveMemory(&V1Fixed, OldV1Fixed, sizeof(SAMP_V1_FIXED_LENGTH_USER));


                //
                // Now copy it back in the new format
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_USER)OldV1Fixed;


                V1aFixed->LastLogon           = V1Fixed.LastLogon;
                V1aFixed->LastLogoff          = V1Fixed.LastLogoff;
                V1aFixed->PasswordLastSet     = V1Fixed.PasswordLastSet;
                V1aFixed->AccountExpires      = V1Fixed.AccountExpires;
                V1aFixed->UserId              = V1Fixed.UserId;
                V1aFixed->PrimaryGroupId      = V1Fixed.PrimaryGroupId;
                V1aFixed->UserAccountControl  = V1Fixed.UserAccountControl;
                V1aFixed->CountryCode         = V1Fixed.CountryCode;
                V1aFixed->CodePage            = V1Fixed.CodePage;
                V1aFixed->BadPasswordCount    = V1Fixed.BadPasswordCount;
                V1aFixed->LogonCount          = V1Fixed.LogonCount;
                V1aFixed->AdminCount          = V1Fixed.AdminCount;

                //
                // And initialize fields new for this revision
                //

                V1aFixed->Revision            = SAMP_REVISION;
                V1aFixed->LastBadPasswordTime = SampHasNeverTime;
                V1aFixed->OperatorCount       = 0;
                V1aFixed->Unused2             = 0;

            } else if ((LengthOfDataRead ==
                (sizeof(SAMP_V1_0_FIXED_LENGTH_USER) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) ) &&
                 (AttributeGroup == SAMP_FIXED_ATTRIBUTES)) {

                PSAMP_V1_0A_FIXED_LENGTH_USER
                    V1aFixed;

                //
                // Update from revision 0x00010002
                //
                // Just set the added field at the end to 0.
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_USER)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                V1aFixed->OperatorCount       = 0;
                V1aFixed->Unused2             = 0;
            }

            break;  //out of switch

    case SampGroupObjectType:
            //
            // Group FIXED_LENGTH attributes have had the following
            // revisions:
            //
            //       Revision 0x00010001 -  NT1.0  (Revision NOT stored in  )
            //                                     (record.                 )
            //                                     (Must ascertain revision )
            //                                     (by first few ULONGs.    )
            //
            //       Revision 0x00010002 -  NT1.0a (Revision is first ULONG )
            //                                     (in record.              )

            Pointer = (PULONG) (Buffer + FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

            //
            // The old fixed length group had a RID in the first ULONG and
            // an attributes field in the second. The attributes are in the
            // first and last nibble of the field.  Currently, the RID is in
            // the second ULONG. Since all RIDs are more than one nibble,
            // a rid will always have something set in the middle six nibbles.
            //

            if ( ( Pointer[0] != SAMP_REVISION ) &&
                 ( ( Pointer[1] & 0x0ffffff0 ) == 0 ) ) {

                PSAMP_V1_0A_FIXED_LENGTH_GROUP
                    V1aFixed;

                SAMP_V1_FIXED_LENGTH_GROUP
                    V1Fixed, *OldV1Fixed;

                ULONG TotalLengthRequired;

                //
                // Calculate the length required for the new group information.
                // It is the size of the old group plus enough space for the
                // new fields in the new fixed attributes.
                //

                TotalLengthRequired = SampDwordAlignUlong(
                                        LengthOfDataRead +
                                        sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP) -
                                        sizeof(SAMP_V1_FIXED_LENGTH_GROUP)
                                        );


                NtStatus = SampExtendAttributeBuffer(
                                Context,
                                TotalLengthRequired
                                );

                if (!NT_SUCCESS(NtStatus)) {
                    return(NtStatus);
                }

                //
                // Get the new buffer pointer
                //

                Buffer = Context->OnDisk;

                //
                // Move the variable information up to make space for the
                // fixed information
                //

                RtlMoveMemory(
                    Buffer + SampFixedBufferOffset( Context ) + sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP),
                    Buffer + SampFixedBufferOffset( Context) + sizeof(SAMP_V1_FIXED_LENGTH_GROUP),
                    LengthOfDataRead - SampFixedBufferOffset( Context) - sizeof(SAMP_V1_FIXED_LENGTH_GROUP)
                    );

                //
                // Update from revision 0x00010001
                //
                // First, copy the current buffer contents into a temporary
                // buffer.
                //

                OldV1Fixed = (PSAMP_V1_FIXED_LENGTH_GROUP)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                RtlCopyMemory(&V1Fixed, OldV1Fixed, sizeof(SAMP_V1_FIXED_LENGTH_GROUP));

                //
                // Now copy it back in the new format
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_GROUP)OldV1Fixed;

                V1aFixed->Revision = SAMP_REVISION;
                V1aFixed->Unused1 = 0;
                V1aFixed->RelativeId = V1Fixed.RelativeId;
                V1aFixed->Attributes = V1Fixed.Attributes;
                V1aFixed->AdminCount = (V1Fixed.AdminGroup) ? TRUE : FALSE;
                V1aFixed->OperatorCount = 0;

                //
                // Update the indicator of how long the on disk structure
                // is.
                //

                Context->OnDiskUsed += (sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP) - sizeof(SAMP_V1_FIXED_LENGTH_GROUP));
                Context->OnDiskFree = Context->OnDiskAllocated - Context->OnDiskUsed;
            }

        break;

        default:

            //
            // The rest of the object types have not changed format
            // and so need not be updated.
            //

            break;  //out of switch

    }

    return(NtStatus);
}


PUCHAR
SampObjectAttributeAddress(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    )

/*++

    Retrieve the address of a variable-length attribute. The attributes are
    assumed to already be in-memory. The NT3.51-4.0 SAM stores attribute
    offsets differently from the NT5 SAM. In the earlier versions (which
    exclusively used the registry as the backing store), the attribute offset
    value (in SAMP_VARIABLE_LENGTH_ATTRIBUTE) was self-relative to the end
    of the attribute array. The NT5 version is self-relative from the start
    of the array.

Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.

--*/

{
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AttributeArray;
    PUCHAR AttributeAddress;

    SAMTRACE("SampObjectAttributeAddress");

    ASSERT(SampVariableAttributesValid(Context));

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                        SampVariableArrayAddress(Context);

    if (IsDsObject(Context))
    {
        // DS based attribute offsets are relative to the start of the
        // attribute array.

        AttributeAddress = (PUCHAR)Context->OnDisk +
                                (SampVariableBufferOffset(Context) +
                                AttributeArray[AttributeIndex].Offset);
    }
    else
    {
        // Registry based attribute offsets are relative to the end of the
        // attribute array.

        AttributeAddress = (PUCHAR)Context->OnDisk +
                                (SampVariableDataOffset(Context) +
                                AttributeArray[AttributeIndex].Offset);
    }

    return(AttributeAddress);
}



ULONG
SampObjectAttributeLength(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    )

/*++

    Retrieve the length of a variable-length attribute.


    The attributes are assumed to already be in-memory.



Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute whose length is to be retrieved.




Return Values:

    The length of the attribute (in bytes).

--*/
{
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE
        AttributeArray;

    SAMTRACE("SampObjectAttributeLength");


    ASSERT( SampVariableAttributesValid( Context ) );

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                     SampVariableArrayAddress( Context );

    return( AttributeArray[AttributeIndex].Length );

}


PULONG
SampObjectAttributeQualifier(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    )

/*++

    Retrieve the address of the qualifier field of a variable-length
    attribute.

    The attributes are assumed to already be in-memory.



Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute whose qualifier address is to be returned.




Return Values:

    The address of the specifed attribute's qualifier field.

--*/
{
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE
        AttributeArray;

    SAMTRACE("SampObjectAttributeQualifier");


    ASSERT( SampVariableAttributesValid( Context ) );

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                     SampVariableArrayAddress( Context );

    return( &(AttributeArray[AttributeIndex].Qualifier) );

}


NTSTATUS
SampGetAttributeBufferReadInfo(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    OUT PUCHAR *Buffer,
    OUT PULONG BufferLength,
    OUT PUNICODE_STRING *KeyAttributeName
    )

/*++

    Get attribute buffer information needed to read data from
    backing store.

    If there is currently no attribute buffer, then allocate one.


Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - Indicates which attribute grouping you are
        interested in.  This is only interesting if the fixed and
        variable-length attributes are stored separately.

    Buffer - Receives a pointer to the beginning of the appropriate
        buffer (fixed or variable).  This will be dword aligned.
        If the attributes are stored together, this will point
        to the beginning of the fixed-length attributes.

    BufferLength - Receives the number of bytes in the buffer.

    KeyAttributeName - Receives a pointer to the unicode name of the
        attribute to read the attributes from.




Return Values:

    STATUS_SUCCESS - The attributes have been read.

    STATUS_NO_MEMORY - Memory could not be allocated to receive the
        data from disk.

    Other values as may be returned reading from disk.


--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampGetAttributeBufferReadInfo");


    //
    // If the context block currently has no buffer info, then
    // "extend" (create) it so we can return buffer information.
    //

    if (Context->OnDiskAllocated == 0) {

        NtStatus = SampExtendAttributeBuffer(
                       Context,
                       SAMP_MINIMUM_ATTRIBUTE_ALLOC
                       );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }



    //
    // Get the buffer address and length
    //

    if (SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

        //
        // stored separately.  Address and length is dependent upon
        // what is being asked for.  Source registry attribute name
        // is also.
        //

        if (AttributeGroup == SAMP_FIXED_ATTRIBUTES) {
            (*Buffer)           = Context->OnDisk;
            (*BufferLength)     = SampVariableBufferOffset( Context );
            (*KeyAttributeName) = &SampFixedAttributeName;
        } else {
            (*Buffer)           = SampVariableBufferAddress( Context );
            (*BufferLength)     = SampVariableBufferLength( Context );
            (*KeyAttributeName) = &SampVariableAttributeName;
        }

    } else {

        //
        // Attributes stored together - doesn't matter which is being
        // asked for.
        //

        (*Buffer)           = Context->OnDisk;
        (*BufferLength)     = Context->OnDiskAllocated;
        (*KeyAttributeName) = &SampCombinedAttributeName;
    }


    return(NtStatus);
}





NTSTATUS
SampExtendAttributeBuffer(
    IN PSAMP_OBJECT Context,
    IN ULONG NewSize
    )


/*++

    This routine extends (or creates) an attribute buffer by allocating
    a larger one.  It then copies the existing buffer's contents into
    the new buffer, if there is an existing buffer.

    If a new buffer can not be allocated, then the context block is
    returned with the old buffer intact.

    If this call succeeds, the buffer will be at least as large as
    that asked for (and perhaps larger).


Parameters:

    Context - Pointer to an object context block.

    NewSize - The number of bytes to allocate for the new buffer.
        This value can not be less than the number of bytes currently
        in use.





Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.

--*/

{

    PUCHAR
        OldBuffer;

    ULONG
        AllocationSize;

    SAMTRACE("SampExtendAttributeBuffer");


#if DBG
    if ( Context->VariableValid ) {
        ASSERT(NewSize >= Context->OnDiskUsed);
    }
#endif


    //
    // Is an allocation necessary?
    //

    if (NewSize <= Context->OnDiskAllocated) {
        return(STATUS_SUCCESS);
    }



    OldBuffer = Context->OnDisk;


    //
    // Pad the extend to allow for future edits efficiently.
    //

    AllocationSize = SampDwordAlignUlong(NewSize + SAMP_MINIMUM_ATTRIBUTE_PAD);
    Context->OnDisk = RtlAllocateHeap(
                         RtlProcessHeap(), 0,
                         AllocationSize
                         );

    if (Context->OnDisk == NULL) {
        Context->OnDisk = OldBuffer;
        return(STATUS_NO_MEMORY);
    }


    //
    // Set the new allocated size

    Context->OnDiskAllocated = AllocationSize;

    //
    // If there was no buffer originally, then zero the new buffer, mark
    // it as being invalid, and return.
    //

    if (OldBuffer == NULL) {

        RtlZeroMemory( (PVOID)Context->OnDisk, AllocationSize );

        Context->FixedDirty    = TRUE;
        Context->VariableDirty = TRUE;
        SetAllPerAttributeDirtyBits(Context);

        Context->FixedValid    = FALSE;
        Context->VariableValid = FALSE;

        return(STATUS_SUCCESS);
    }


    //
    // Set the free size.  Note that this information is only set if
    // the variable data is valid.
    // Used size remains the same.
    //

    if (Context->VariableValid == TRUE) {
        Context->OnDiskFree = AllocationSize - Context->OnDiskUsed;
        ASSERT(Context->OnDiskUsed == SampDwordAlignUlong(Context->OnDiskUsed));
    }


    //
    // There was an old buffer (or else we would have exited earlier).
    // If any data in it was valid, copy it to the new buffer.  Free the
    // old buffer.
    //

    if ( Context->FixedValid ) {

        RtlCopyMemory(
            Context->OnDisk,
            OldBuffer,
            SampFixedBufferLength( Context ) + SampFixedBufferOffset( Context )
            );
    }

    //
    // Note: in thise case we may copy the fixed data twice, since if the
    // variable data is not stored separately then SampVariableBufferOffset
    // is zero.
    //

    if ( Context->VariableValid ) {

        RtlCopyMemory(
            SampVariableBufferAddress( Context ),
            OldBuffer + SampVariableBufferOffset( Context ),
            Context->OnDiskUsed - SampVariableBufferOffset( Context )
            );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, OldBuffer );

    return(STATUS_SUCCESS);
}



NTSTATUS
SampReadRegistryAttribute(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    IN ULONG  BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG RequiredLength
    )

/*++


    Retrieve the address of a variable-length attribute.

    The attributes are assumed to already be in-memory.



Parameters:

    Key - Handle to the key whose attribute is to be read.

    Buffer - Pointer to the buffer to receive the information.

    BufferLength - Length of the buffer receiving the information.

    AttributeName - The name of the attribute.



Return Values:

    STATUS_SUCCESS - Successful completion.


    STATUS_BUFFER_TOO_SMALL - The data could not be read because the
        buffer was too small.

    Other values as may be returned by registry API trying to retrieve
        the attribute from backing store.

--*/

{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampReadRegistryAttribute");


    //
    // Try to read the attribute
    //

    NtStatus = NtQueryValueKey( Key,
                                AttributeName,              //ValueName,
                                KeyValuePartialInformation, //KeyValueInformationClass
                                (PVOID)Buffer,
                                BufferLength,
                                RequiredLength
                                );

    SampDumpNtQueryValueKey(AttributeName,
                            KeyValuePartialInformation,
                            Buffer,
                            BufferLength,
                            RequiredLength);

    return(NtStatus);

}




NTSTATUS
SampSetVariableAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN ULONG Qualifier,
    IN PUCHAR Buffer,
    IN ULONG Length
    )


/*++

    This API is used to set a new attribute value.  The new attribute
    value may be longer, shorter, or the same size as the current
    attribute.  The data in the attribute buffer will be shifted to
    make room for a larger attribute value or to fill in room left by
    a smaller attribute value.

    PERFORMANCE CONCERN:  If you have a lot of attributes to set, it
        is worthwhile to start with the smallest indexed attribute
        and work up to the largest indexed attribute.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.  Typically, all attributes beyond
        this one will have their data shifted.

    Buffer - The address of the buffer containing the new attribute value.
        May be NULL if Length is zero.

    Length - The length (in bytes) of the new attribute value.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to expand the attribute buffer could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;


    ULONG
        OriginalAttributeLength,
        AdditionalSpaceNeeded,
        NewBufferLength,
        MaximumAttributeIndex,
        MoveLength,
        i;

    LONG
        OffsetDelta;

    PSAMP_VARIABLE_LENGTH_ATTRIBUTE
        AttributeArray;


    PUCHAR
        NewStart,
        OriginalStart;

    SAMTRACE("SampSetVariableAttribute");

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // If the caller want to set User Object's SAMP_USER_PARAMETERS attribute and
    // is not a loopback client. And this is the first time the client tries to set
    // this attribute. we should cache the old UserParms value,
    // We do not cache any inter-update changes.
    //

    OriginalAttributeLength =  SampObjectAttributeLength(Context, AttributeIndex);

    if (SampUserObjectType == Context->ObjectType &&            // User Object
        SAMP_USER_PARAMETERS == AttributeIndex &&               // desired attribute
        !Context->LoopbackClient &&                             // not Loopback client
        !Context->TypeBody.User.CachedOrigUserParmsIsValid)     // First time to set this attribute
    {

        ASSERT(SampCurrentThreadOwnsLock());

        //
        // followings are two cases we will meet:
        // first: OriginalUserParms just does not exist, set the pointer to NULL
        // second: allocate memory to cache the old value
        //
        if (OriginalAttributeLength)
        {
            Context->TypeBody.User.CachedOrigUserParms = MIDL_user_allocate(OriginalAttributeLength);

            if (NULL == Context->TypeBody.User.CachedOrigUserParms)
            {
                return (STATUS_NO_MEMORY);
            }

            RtlZeroMemory(Context->TypeBody.User.CachedOrigUserParms,
                          OriginalAttributeLength
                          );

            RtlCopyMemory(Context->TypeBody.User.CachedOrigUserParms,
                          SampObjectAttributeAddress(Context, AttributeIndex),
                          OriginalAttributeLength
                          );
        }
        else
        {
            Context->TypeBody.User.CachedOrigUserParms = NULL;
        }

        Context->TypeBody.User.CachedOrigUserParmsLength = OriginalAttributeLength;
        Context->TypeBody.User.CachedOrigUserParmsIsValid = TRUE;
    }


    //
    // Allocate a new buffer if necessary
    //


    if (OriginalAttributeLength < Length) {

        AdditionalSpaceNeeded = Length - OriginalAttributeLength;

        if (Context->OnDiskFree < AdditionalSpaceNeeded) {

            NewBufferLength = Context->OnDiskUsed + AdditionalSpaceNeeded;
            ASSERT(NewBufferLength > Context->OnDiskAllocated);

            NtStatus = SampExtendAttributeBuffer( Context, NewBufferLength );
            if (!NT_SUCCESS(NtStatus)) {
                return(NtStatus);
            }
        }
    }

    //
    // Get the address of the attribute array.
    //

    AttributeArray = SampVariableArrayAddress( Context );

    //
    // Now shift following attribute values
    //

    OffsetDelta = (LONG)(SampDwordAlignUlong(Length) -
                         SampDwordAlignUlong(OriginalAttributeLength));

    MaximumAttributeIndex = SampVariableAttributeCount( Context );

    if ((OffsetDelta != 0) && (AttributeIndex+1 < MaximumAttributeIndex)) {

        //
        // Shift all attributes above this one up or down by the OffsetDelta
        //

        if (IsDsObject(Context))
        {
            // DS variable-length attribute offsets are relative to the start
            // of the variable-length array.

            MoveLength = Context->OnDiskUsed -
                         ( SampVariableBufferOffset( Context ) +
                         AttributeArray[AttributeIndex+1].Offset );
        }
        else
        {
            // Registry variable-length attribute offsets are relative to the
            // end of the variable-length array.

            MoveLength = Context->OnDiskUsed -
                         ( SampVariableDataOffset( Context ) +
                         AttributeArray[AttributeIndex+1].Offset );
        }

        //
        // Shift the data (if there is any)
        //

        if (MoveLength != 0) {

            OriginalStart = SampObjectAttributeAddress( Context, AttributeIndex+1);
            NewStart = (PUCHAR)(OriginalStart + OffsetDelta);
            RtlMoveMemory( NewStart, OriginalStart, MoveLength );
        }


        //
        // Adjust the offset pointers
        //

        for ( i=AttributeIndex+1; i<MaximumAttributeIndex; i++) {
            AttributeArray[i].Offset =
                (ULONG)(OffsetDelta + (LONG)(AttributeArray[i].Offset));
        }
    }



    //
    // Now set the length and qualifier, and copy in the new attribute value
    // (if it is non-zero length)
    //

    AttributeArray[AttributeIndex].Length    = Length;
    AttributeArray[AttributeIndex].Qualifier = Qualifier;

    if (Length != 0) {

        RtlCopyMemory( SampObjectAttributeAddress( Context, AttributeIndex ),
                       Buffer,
                       Length
                       );
    }



    //
    // Adjust the Used and Free values
    //
    Context->OnDiskUsed += OffsetDelta;
    Context->OnDiskFree -= OffsetDelta;

    ASSERT(Context->OnDiskFree == Context->OnDiskAllocated - Context->OnDiskUsed);

    //
    // Mark the variable attributes dirty
    //

    Context->VariableDirty = TRUE;

    //
    // Mark the per attribute DirtyBit
    //

    SetPerAttributeDirtyBit(Context,AttributeIndex);




#ifdef SAM_DEBUG_ATTRIBUTES
    if (SampDebugAttributes) {
        DbgPrint("SampSetVariableAttribute %d to length %#x, qualifier %#x:\n", AttributeIndex, Length, Qualifier);
        SampDumpAttributes(Context);
    }
#endif


    return(STATUS_SUCCESS);

}


VOID
SampFreeAttributeBuffer(
    IN PSAMP_OBJECT Context
    )

/*++


    Free the buffer used to keep in-memory copies of the on-disk
    object attributes.


Parameters:

    Context - Pointer to the object context whose buffer is to
        be freed.


Return Values:

    None.

--*/

{
#if DBG
    if ( Context->FixedValid ) { ASSERT(Context->FixedDirty == FALSE); }
    if ( Context->VariableValid) { ASSERT(Context->VariableDirty == FALSE); }
    ASSERT(Context->OnDisk != NULL);
    ASSERT(Context->OnDiskAllocated != 0);
#endif

    SAMTRACE("SampFreeAttributeBuffer");

    MIDL_user_free(Context->OnDisk );

    Context->OnDisk = NULL;
    Context->OnDiskAllocated = 0;

    //
    // Mark all attributes as invalid
    //

    Context->FixedValid = FALSE;
    Context->VariableValid = FALSE;
    Context->FixedDirty = FALSE;
    Context->VariableDirty = FALSE;
    ClearPerAttributeDirtyBits(Context);

    if (Context->PreviousOnDisk!=NULL)
    {
        MIDL_user_free(Context->PreviousOnDisk);
        Context->PreviousOnDisk = NULL;
    }


    return;
}

VOID
SampMarkPerAttributeInvalidFromWhichFields(
    IN PSAMP_OBJECT Context,
    IN ULONG        WhichFields
    )
{
    ULONG AttrCount = 0;
    ULONG i;


    switch(Context->ObjectType)
    {

    case SampServerObjectType:
        AttrCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:
        AttrCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:
        AttrCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:
        AttrCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:
        AttrCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        ASSERT(FALSE && "Invalid SampObjectType");
        break;

    }


    //
    // First Clear all the bits
    //

    RtlClearAllBits(
            &Context->PerAttributeInvalidBits
            );

    //
    // Now mark certain bits invalid per the specified WhichFields.
    //

    for (i=0;i<AttrCount;i++)
    {
        if ((0!=WhichFields)
            && (SampVarAttributeInfo[Context->ObjectType][i].FieldIdentifier!=0)
            && ((SampVarAttributeInfo[Context->ObjectType][i].FieldIdentifier & WhichFields)==0))
        {
            SetPerAttributeInvalidBit(Context,i);
        }
       
    }

}



#ifdef SAM_DEBUG_ATTRIBUTES
VOID
SampDumpAttributes(
    IN PSAMP_OBJECT Context
    )


/*++

    This is a debug-only API to dump out the attributes for a context
    to the kernel debugger.

Parameters:

    Context - Pointer to an object context block.

Return Values:

    None.

--*/
{
    ULONG   Index;
    PSAMP_OBJECT_INFORMATION ObjectTypeInfo = &SampObjectInformation[Context->ObjectType];
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AttributeArray;

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                     SampVariableArrayAddress( Context );


    DbgPrint("Dumping context 0x%x\n", Context);
    DbgPrint("\n");
    DbgPrint("TYPE INFO\n");
    DbgPrint("Object type name = %wZ\n", &ObjectTypeInfo->ObjectTypeName);
    DbgPrint("Fixed stored separately  = %s\n", ObjectTypeInfo->FixedStoredSeparately ? "TRUE" : "FALSE");
    DbgPrint("Fixed attributes offset  = %#x\n", ObjectTypeInfo->FixedAttributesOffset);
    DbgPrint("Fixed attributes size    = %#x\n", ObjectTypeInfo->FixedLengthSize);
    DbgPrint("Variable buffer offset   = %#x\n", ObjectTypeInfo->VariableBufferOffset);
    DbgPrint("Variable array offset    = %#x\n", ObjectTypeInfo->VariableArrayOffset);
    DbgPrint("Variable data offset     = %#x\n", ObjectTypeInfo->VariableDataOffset);
    DbgPrint("Variable attribute count = %d\n", ObjectTypeInfo->VariableAttributeCount);
    DbgPrint("\n");
    DbgPrint("INSTANCE INFO\n");
    DbgPrint("RootName        = %wZ\n", &Context->RootName);
    DbgPrint("Fixed Valid     = %s\n", Context->FixedValid ? "TRUE" : "FALSE");
    DbgPrint("Variable Valid  = %s\n", Context->VariableValid ? "TRUE" : "FALSE");
    DbgPrint("Fixed Dirty     = %s\n", Context->FixedDirty ? "TRUE" : "FALSE");
    DbgPrint("Variable Dirty  = %s\n", Context->VariableDirty ? "TRUE" : "FALSE");
    DbgPrint("OnDiskAllocated = %#x\n", Context->OnDiskAllocated);
    DbgPrint("OnDiskUsed      = %#x\n", Context->OnDiskUsed);
    DbgPrint("OnDiskFree      = %#x\n", Context->OnDiskFree);
    DbgPrint("\n");

    if ( Context->VariableValid ) {

        for (Index = 0; Index < ObjectTypeInfo->VariableAttributeCount; Index ++) {

            DbgPrint("Attr %d: Qualifier = %#6x, Offset = %#6x, Length = %#6x\n",
                                        Index,
                                        AttributeArray[Index].Qualifier,
                                        AttributeArray[Index].Offset,
                                        AttributeArray[Index].Length
                                        );
            SampDumpData(SampObjectAttributeAddress(Context, Index),
                         SampObjectAttributeLength(Context, Index));
        }
    }

    DbgPrint("\n\n");
}


VOID
SampDumpData(
    IN PVOID Buffer,
    IN ULONG Length
    )


/*++

    This is a debug-only API to dump out a buffer in hex

Parameters:

    Buffer - Pointer to data

    Length - number of bytes in data

Return Values:

    None.

--*/
{
    ULONG   Index;

    for (Index = 0; Index < Length; Index ++) {

        ULONG Value = (ULONG)(((PBYTE)Buffer)[Index]);

        if ((Index % 16) == 0) {
            DbgPrint("\n      ");
        }

        DbgPrint("%02x ", Value & 0xff);
    }

    if (Length > 0) {
        DbgPrint("\n\n");
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsdsply.h ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsdsply.h

Abstract:

    Header file for SAM Private API Routines to access the DS
    for display information. This file contains prototypes of
    the routines that implement display API for the DS case

Author:
    MURLIS

Revision History

    12-18-96 Murlis Created

--*/

#ifndef DSDSPLY_H

#define DSDSPLY_H

#include <samsrvp.h>
#include <dslayer.h>



//////////////////////////////////////////////////////////////////////
//
//
//  Functions Prototypes
//
//
//
//////////////////////////////////////////////////////////////////////




NTSTATUS
SampDsEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    );


NTSTATUS
SampDsQueryDisplayInformation (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampInitializeUserInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_USER *UserInfo,
    BOOLEAN CopyData
    );

NTSTATUS
SampInitializeMachineInfo(          // Also used for Interdomain trust accounts
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_MACHINE *MachineInfo,
    BOOLEAN CopyData
    );

NTSTATUS
SampInitializeGroupInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_GROUP *GroupInfo,
    BOOLEAN CopyData
    );

NTSTATUS
SampDuplicateUserInfo(
    PDOMAIN_DISPLAY_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    );

NTSTATUS
SampDuplicateMachineInfo(           // Also used for Interdomain trust accounts
    PDOMAIN_DISPLAY_MACHINE Destination,
    PDOMAIN_DISPLAY_MACHINE Source,
    ULONG                   Index

    );

NTSTATUS
SampDuplicateGroupInfo(
    PDOMAIN_DISPLAY_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                 Index
    );

NTSTATUS
SampDuplicateOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    );

NTSTATUS
SampDuplicateOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                 Index
    );


VOID
SampFreeUserInfo(
    PDOMAIN_DISPLAY_USER UserInfo
    );

VOID
SampFreeMachineInfo(
    PDOMAIN_DISPLAY_MACHINE MachineInfo
    );

VOID
SampFreeGroupInfo(
    PDOMAIN_DISPLAY_GROUP GroupInfo
    );

VOID
SampFreeOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER UserInfo
    );

VOID
SampFreeOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP GroupInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsdomain.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    dsdomain.c

Abstract:

    This file contains services related to the SAM "domain" object. The NT5
    SAM stores domain account information in the registry (see domain.c) and
    account information in the directory service (DS). This latter case is
    handled by the routines in this file, which know how to read/write DS
    data. This file also contains routines for dynamic domain creation and
    deletion.

    NOTE: Dynamic domain creation/deletion is work in progress.

Author:

    Chris Mayhall (ChrisMay) 11-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    11-Jul-1996 ChrisMay
        Created initial file.
    25-Jul-1996 ChrisMay
        Added domain initialization and corresponding changes in ntds.exe.
    23-Aug-1996 ChrisMay
        Made domain initialization work for multiple hosted domains and for
        domain information stored in the DS.
    08-Oct-1996 ChrisMay
        Miscellaneous cleanup.
    09-Dec-1996 ChrisMay
        Remove dead/obsolete code, further clean up needed to support mult-
        iple hosted domains.
    31-Jan-1997 ChrisMay
        Added multi-master RID manager routines.

--*/


// Includes

#include <samsrvp.h>
#include "ntlsa.h"
#include "lmcons.h"         // LM20_PWLEN
#include "msaudite.h"
#include <ntlsa.h>
#include <nlrepl.h>         // I_NetNotifyMachineAccount prototype
#include <dslayer.h>        // SampDsCreateObject, etc.
#include <dsutilp.h>
#include <dsdomain.h>
#include <objids.h>
#include <dsconfig.h>
#include <stdlib.h>
#include <ridmgr.h>
#include <dns.h>

// Private (to this file) debug buffer.

#define DBG_BUFFER_SIZE     256



NTSTATUS
SampInitializeWellKnownSids(
    VOID
    );

// Constants (used only in this file)

#define SAMP_DOMAIN_COUNT   2

NTSTATUS
SampGetDsDomainCrossRefSettings(
    UNICODE_STRING * DnsName,
    UNICODE_STRING * NetbiosName
    );


NTSTATUS
SampDsGetDomainInitInfoEx(
    PSAMP_DOMAIN_INIT_INFO DomainInitInfo
    )

/*++

Routine Description:

    This routine obtains the SAM domain information from the DS for each
    hosted domain. Each hosted domain contains both Builtin and Account
    domains.

Arguments:

    DomainInitInfo - Pointer, domain boostrap information.

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_NO_MEMORY - Insufficient memory available.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DOMAIN_INFO DomainInfo = NULL;

    ULONG i=0;

    // BUG: How is the count of hosted domains determined from the DS?

    ULONG HostedDomainCount = 1;

    // DomainCount should always equal 2 (Builtin and Account).

    ULONG DomainCount = SAMP_DOMAIN_COUNT;
    ULONG TotalDomainCount = HostedDomainCount * DomainCount;
    ULONG Length = TotalDomainCount * sizeof(SAMP_DOMAIN_INFO);

    static WCHAR SamBuiltinName[] = L"Builtin";
    static WCHAR SamDomainName[]  = L"Account";

    ULONG Size = 0;
    ULONG DirError = 0;

    SAMTRACE("SampDsGetDomainInitInfoEx");

    //
    // Initialize the output parameters.
    //

    DomainInitInfo->DomainCount = 0;
    DomainInitInfo->DomainInfo = NULL;

    // This routine assumes the ROOT_OBJECT has been created
    ASSERT( ROOT_OBJECT );

    SampDiagPrint(INFORM,
                  ("SAMSS: RootDomain Name is %S\n", ROOT_OBJECT->StringName));

    // Allocate space for the domain-information array.

    DomainInfo = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

    if (NULL != DomainInfo)
    {
        RtlZeroMemory(DomainInfo, Length);

        // Initialize the array with each hosted domain's information. Note,
        // each hosted domain contains both Builtin and a Account domains.

        while (i < HostedDomainCount)
        {
            // For each hosted domain, setup the Builtin domain initialization
            // information.

            // DSNameSizeFromLen adds 1 for the NULL
            Size = (ULONG)DSNameSizeFromLen( ROOT_OBJECT->NameLen
                                    + wcslen( SamBuiltinName )
                                    + wcslen( L"CN=," ) );  // the common name part

            DomainInfo[i].DomainDsName = RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);

            if (NULL != DomainInfo[i].DomainDsName)
            {
                RtlZeroMemory(DomainInfo[i].DomainDsName, Size);

                DirError = AppendRDN( ROOT_OBJECT,
                                      DomainInfo[i].DomainDsName,
                                      Size,
                                      SamBuiltinName,
                                      wcslen(SamBuiltinName),  // don't include the NULL
                                      ATT_COMMON_NAME );

                // DirError is 0 or !0
                ASSERT( 0 == DirError );

                SampDiagPrint(INFORM,
                              ("SAMSS: Builtin Domain Name is %S\n",
                               DomainInfo[i].DomainDsName->StringName));

                DomainInitInfo->DomainCount++;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }

            // BUG: Setting domain display name to internal name.

            // Set the "display name" for the Builtin domain.

            RtlInitUnicodeString(&(DomainInfo[i].DomainName),
                                 SamBuiltinName);

            // Setup the Account domain initialization information.
            Size = ROOT_OBJECT->structLen;

            DomainInfo[i + 1].DomainDsName = RtlAllocateHeap(
                                                        RtlProcessHeap(),
                                                        0,
                                                        Size);

            if (NULL != DomainInfo[i + 1].DomainDsName)
            {
                RtlCopyMemory(DomainInfo[i + 1].DomainDsName, ROOT_OBJECT, Size);

                DomainInitInfo->DomainCount++;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }

            // Set the "display name" for the Account domain.

            RtlInitUnicodeString(&(DomainInfo[i + 1].DomainName),
                                 SamDomainName);

            // Process the next hosted domain, if there is another.

            i++;
        }

        // Set the domain-info pointer. If an error occurred, return the
        // domain information up to that point. The caller should always
        // use DomainCount to determine how many domains were found.

        DomainInitInfo->DomainInfo = DomainInfo;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}


NTSTATUS
SampExtendDefinedDomains(
    ULONG DomainCount
    )

/*++

Routine Description:

    This routine grows the SampDefinedDomains array. It is written so that
    a memory allocation failure will not corrupt the original array. If the
    memory cannot be allocated, the original array is left in tact.

Arguments:

    DomainCount - The number of entries to grow the array by.

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_NO_MEMORY - Insufficient memory available.

--*/

{
    SAMTRACE("SampExtendDefinedDomains");

    //
    // N.B.  This routine was originally meant to grow the SampDefinedDomains
    // array to hold the domains held in the ds.  This is a
    // unstable architecture since each existing element in the
    // SampDefinedDomains array would need to be reinitialized.  So, the fix is
    // to simply allocate the amount necessary for the entire array in
    // SampInitializeDomainObject.  It is expected that the number of domains
    // in the ds is only 2 (valid for win2k release: builtin and account
    // domain). If this value changes then we need to change the amount
    // allocated in SampInitializeDomainObject.
    //

    ASSERT( DomainCount == 2 );

    SampDefinedDomainsCount += DomainCount;

    return(STATUS_SUCCESS);
}


NTSTATUS
SampDsSetBuiltinDomainPolicy(
    ULONG Index
    )

/*++

Routine Description:

    This routine sets the names and SIDs for the Builtin domain. The builtin
    account domain has a well known name and SID.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - successful completion.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    SAMTRACE("SampDsSetBuiltinDomainPolicy");

    // BUG: NT5 will need per-hosted domain Builtin policy.

    // Builtin domain - Well-known external name and SID constant internal
    // name. NT4 SAM defined one Builtin domain per DC. The Builtin domain
    // has customarily contained hard-wired, constant SID and name in order
    // to simplify inter-DC communication about changes to Builtin data.
    // This premise may need to change for NT5, as each Builtin will have
    // a different policy per hosted domain.

    RtlInitUnicodeString(&SampDefinedDomains[Index].InternalName, L"Builtin");
    RtlInitUnicodeString(&SampDefinedDomains[Index].ExternalName, L"Builtin");

    SampDefinedDomains[Index].Sid = RtlAllocateHeap(RtlProcessHeap(),
                                                    0,
                                                    RtlLengthRequiredSid(1));

    ASSERT(SampDefinedDomains[Index].Sid != NULL);
    if (NULL==SampDefinedDomains[Index].Sid)
    {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitializeSid(SampDefinedDomains[Index].Sid, &BuiltinAuthority, 1);

    *(RtlSubAuthoritySid(SampDefinedDomains[Index].Sid, 0)) =
        SECURITY_BUILTIN_DOMAIN_RID;

    SampDefinedDomains[Index].IsBuiltinDomain = TRUE;

    SampDefinedDomains[Index].IsForestRootDomain = FALSE;

    return(NtStatus);
}


NTSTATUS
SampDsGetDomainInfo(
    PPOLICY_DNS_DOMAIN_INFO *PolicyDomainInfo,
    UNICODE_STRING * DnsName,
    UNICODE_STRING * NetbiosName,
    BOOLEAN * IsForestRootDomain
    )

/*++

Routine Description:

    This routine obtains the domain policy information from LSA.

Arguments:

    PolicyDomainInfo - Pointer, policy information for the domain.

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_INVALID_SID - LSA returned a NULL SID.

    Other codes from LSA.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS IgnoreStatus = STATUS_INTERNAL_ERROR;
    LSAPR_HANDLE PolicyHandle = NULL;
    LPWSTR   DnsDomainNameString = NULL;
    LPWSTR   DnsForestNameString = NULL;


    SAMTRACE("SampDsGetDomainInfo");

    // init return value
    *IsForestRootDomain = FALSE;

    NtStatus = LsaIOpenPolicyTrusted(&PolicyHandle);

    if (NT_SUCCESS(NtStatus)) {

        // Query the account domain information

        // BUG: Need to get the correct policy information - using "Account Domain" for now.

        // LSA will need to export a routine that allows for the retrieval of
        // per-hosted-domain policy. For now, it is assumed that the returned
        // policy is the only one present on the DC (a.k.a. NT4 policy).

        NtStatus = LsarQueryInformationPolicy(
                       PolicyHandle,
                       PolicyDnsDomainInformation,
                       (PLSAPR_POLICY_INFORMATION *)PolicyDomainInfo);

        SampDiagPrint(INFORM,
                      ("SAMSS: LsaIQueryInformationPolicy status = 0x%lx\n",
                       NtStatus));


        if (NT_SUCCESS(NtStatus))
        {
            if ((*PolicyDomainInfo)->Sid == NULL)
            {
                NtStatus = STATUS_INVALID_SID;
            }
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampGetDsDomainCrossRefSettings(
                            DnsName,
                            NetbiosName
                            );
        }

        //
        // tells whether this domain is Forest Root Domain by comparing
        // ForestName and DomainName retrieved from LSA
        // 
        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampMakeNullTerminateString(
                                &((*PolicyDomainInfo)->DnsDomainName), 
                                &DnsDomainNameString
                                );

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampMakeNullTerminateString(
                                &((*PolicyDomainInfo)->DnsForestName), 
                                &DnsForestNameString
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    if (DnsNameCompareEqual == 
                            DnsNameCompareEx_W(DnsDomainNameString, 
                                               DnsForestNameString, 0) 
                        )
                    {
                        // this domain is the ForestRootDomain
                        *IsForestRootDomain = TRUE;
                    }
                }
            }
        }

        //
        // close the LSA handle
        // 
        IgnoreStatus = LsarClose(&PolicyHandle);
    }


    if (DnsDomainNameString) {
        RtlFreeHeap(RtlProcessHeap(), 0, DnsDomainNameString);
    }

    if (DnsForestNameString) {
        RtlFreeHeap(RtlProcessHeap(), 0, DnsForestNameString);
    }


    return(NtStatus);
}


NTSTATUS
SampDsSetDomainPolicy(
    PDSNAME DsName,
    ULONG Index
    )

/*++

Routine Description:

    This routine sets the domain SID and name as obtained from LSA.

Arguments:

    DsName - Pointer, DS name of the domain.

    Index - Current entry in the SampDefinedDomains array.

Return Value:

    STATUS_SUCCESS - Successful completion.

    Other error codes from SampDsGetDomainInfo.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    UNICODE_STRING  DnsName;
    UNICODE_STRING  NetbiosName;
    PPOLICY_DNS_DOMAIN_INFO PolicyDomainInfo = NULL;
    BOOLEAN         IsForestRootDomain = FALSE;
    

    SAMTRACE("SampDsSetDomainPolicy");

    NtStatus = SampDsGetDomainInfo(&PolicyDomainInfo,&DnsName,&NetbiosName, &IsForestRootDomain);

    if (NT_SUCCESS(NtStatus))
    {
        // Set the domain's SID, internal, and external names. The NT5
        // naming convention must continue to use SAM/LSA names, namely
        // the netbios names that LSA and NetLogon understand, so that
        // actions such as replication continue to work (with down-level
        // BDCs). These names are passed in via the policy information.

        // In addition, SampDefinedDomains contains a SAM context struct
        // which in turn contains the DS distinguished name of the account
        // object. Consequently, all three names (internal, external, and
        // DN) are available via SampDefinedDomains.

        SampDefinedDomains[Index].Sid = PolicyDomainInfo->Sid;
        SampDefinedDomains[Index].IsBuiltinDomain = FALSE;

        RtlInitUnicodeString(&SampDefinedDomains[Index].InternalName,
                             L"Account");

        SampDefinedDomains[Index].ExternalName = NetbiosName;
        SampDefinedDomains[Index].DnsDomainName = DnsName;

        SampDefinedDomains[Index].IsForestRootDomain = IsForestRootDomain;
    }

    return(NtStatus);
}


NTSTATUS
SampDsInitializeSingleDomain(
    PDSNAME DsName,
    ULONG Index,
    BOOLEAN MixedDomain,
    ULONG   BehaviorVersion,
    DOMAIN_SERVER_ROLE ServerRole,
    ULONG   LastLogonTimeStampSyncInterval
    )

/*++

Routine Description:

    This routine initializes a Builtin or an Account domain object. A context
    is created for the domain, the fixed-length attributes and the SID for
    the domain are obtained. This information is stored in the SampDefined-
    Domains array. If the domain SID matches the one previously obtained from
    LSA, then the domain security descriptor is setup.

Arguments:

    DsName - Pointer, DS domain name.

    Index - Index into the SampDefinedDomains array.

    MixedDomain - Indicates that the given domain is a Mixed Domain

    ServerRole  Indicates the PDCness / BDCness of this server in the domain

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient memory, etc.

    STATUS_INVALID_ID_AUTHORITY - ?

    Other return codes from subroutines.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PSAMP_OBJECT DomainContext = NULL;
    BOOLEAN MakeCopy = FALSE;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN FixedAttributes = NULL;
    PSID Sid = NULL;

    #if DBG

    SID *Sid1 = NULL, *Sid2 = NULL;

    #endif

    SAMTRACE("SampDsInitializeSingleDomain");


    // Create a context for this domain object. This context is kept around
    // until SAM is shut down. Call with TrustedClient equal TRUE.

    DomainContext = SampCreateContext(SampDomainObjectType, Index, TRUE);

    if (NULL != DomainContext)
    {
        // Store the defined-domains index in the context and set the DS-
        // object flag, indicating that this context corresponds to a DS-
        // domain account object.

        DomainContext->DomainIndex = Index;
        SetDsObject(DomainContext);

        // Set the domain object's DS name in order to lookup the fixed
        // attributes in the DS.

        // BUG: What is the lifetime of the DsName object?

        DomainContext->ObjectNameInDs = DsName;

        SampDiagPrint(INFORM,
                      ("SAMSS: Domain DsName = %ws\n", DsName->StringName));

        // Get the fixed-length data for this domain and store it in the
        // defined-domain structure.

        NtStatus = SampGetFixedAttributes(DomainContext,
                                          MakeCopy,
                                          (PVOID *)&FixedAttributes);

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Get the DS Domain Handle for the Domain
            //

            SampDefinedDomains[Index].DsDomainHandle = DirGetDomainHandle(DsName);

        }
        else
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampGetFixedAttributes status = 0x%lx\n",
                       NtStatus));
        }

        if (NT_SUCCESS(NtStatus))
        {

            ASSERT(1 < Index);

            //
            // Set the correct Fixed attributes in the defined domains structure
            //

            RtlMoveMemory(&SampDefinedDomains[Index].UnmodifiedFixed,
                          FixedAttributes,
                          sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN));

            RtlMoveMemory(&SampDefinedDomains[Index].CurrentFixed,
                          FixedAttributes,
                          sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN));

            SampDefinedDomains[Index].FixedValid = TRUE;

            //
            // Set the server role
            //

            SampDefinedDomains[Index].ServerRole = ServerRole;


            //
            // Set the mixed domain flag and other domain settings
            //

            SampDefinedDomains[Index].IsMixedDomain = MixedDomain;
            SampDefinedDomains[Index].BehaviorVersion = BehaviorVersion;
            SampDefinedDomains[Index].LastLogonTimeStampSyncInterval = LastLogonTimeStampSyncInterval;


            //
            // Get the SID attribute of the domain
            //

            NtStatus = SampGetSidAttribute(DomainContext,
                                           SAMP_DOMAIN_SID,
                                           MakeCopy,
                                           &Sid);


            SampDiagPrint(INFORM,
                          ("SAMSS: SampGetSidAttribute status = 0x%lx\n",
                           NtStatus));

            SampDefinedDomains[Index ].AliasInformation.MemberAliasList = NULL;
        }
    }
    else
    {
        ASSERT(!SampExistsDsTransaction());
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCreateContext failed, NULL context returned\n"));

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        return(NtStatus);
    }

    if (NT_SUCCESS(NtStatus))
    {
        // Verify that this domain SID is the same as the one obtained
        // earlier (from LSA policy info) in the defined-domains array.

        if (RtlEqualSid(Sid, SampDefinedDomains[Index].Sid) == TRUE)
        {
            // Build security descriptors for use in user and group account
            // creations in this domain.

            NtStatus = SampInitializeDomainDescriptors(Index);

            if (NT_SUCCESS(NtStatus))
            {
                // Intialize the cached display information

                SampDefinedDomains[Index].Context = DomainContext;
                SampDefinedDomains[Index].AliasInformation.Valid = FALSE;

                NtStatus = SampInitializeDisplayInformation(Index);
            }
            else
            {
                SampDefinedDomains[Index].Context = NULL;
            }
        }
        else
        {
            NtStatus = STATUS_INVALID_ID_AUTHORITY;

            #if DBG

            DbgPrint("SAMSS: Database corruption for %Z Domain.\n",
            &SampDefinedDomains[Index].ExternalName);

            Sid1 = Sid; Sid2 = SampDefinedDomains[Index].Sid;

            DbgPrint("Sid1 Revision = %d\n", Sid1->Revision);
            DbgPrint("Sid1 SubAuthorityCount = %d\n", Sid1->SubAuthorityCount);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[0]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[1]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[2]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[3]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[4]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[5]);
            DbgPrint("Sid1 SubAuthority = %lu\n", Sid1->SubAuthority[0]);

            DbgPrint("Sid2 Revision = %d\n", Sid2->Revision);
            DbgPrint("Sid2 SubAuthorityCount = %d\n", Sid2->SubAuthorityCount);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[0]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[1]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[2]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[3]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[4]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[5]);
            DbgPrint("Sid2 SubAuthority = %lu\n", Sid2->SubAuthority[0]);

            #endif //DBG
        }
    }

    if (SampDefinedDomains[Index].IsBuiltinDomain) {
        SampDefinedDomains[Index].IsExtendedSidDomain = FALSE;
    } else {
        //
        // Note -- when the extended SID support is complete, this will be
        // replaced with domain wide state, not a registry setting
        //
        SampDefinedDomains[Index].IsExtendedSidDomain = SampIsExtendedSidModeEmulated(NULL);
    }

    //
    // End any Open DS tansaction
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    return(NtStatus);
}


NTSTATUS
SampDsInitializeDomainObject(
    PSAMP_DOMAIN_INFO DomainInfo,
    ULONG Index,
    BOOLEAN MixedDomain,
    IN      ULONG BehaviorVersion,
    DOMAIN_SERVER_ROLE ServerRole,
    ULONG   LastLogonTimeStampSyncInterval
    )

/*++

Routine Description:

    This routine initializes a domain object within a hosted domain by set-
    ting its domain policy information and descriptors.

    Note that NT4 SAM assumes a single domain policy, because there are only
    the Builtin and Account domains per DC. NT5 supports multiple domains
    per DC, hence the need to obtain policy for each hosted domain. Each of
    the hosted domains contains Builtin and Account domains.

Arguments:

    DomainInfo - Pointer, domain information.

    Index - Index into the SampDefinedDomains array.

    MixedDomain -- Indicates that the given domain is a Mixed Domain

    ServerRole  -- Indicates the role of the server in the domain ( PDC/BDC)
Return Value:

    STATUS_SUCCESS - Successful completion.

    Other error codes from the subroutines.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS IgnoreStatus = STATUS_INTERNAL_ERROR;
    ULONG SampDefinedDomainsIndex = 0;
    PDSNAME DsName = NULL;
    PWCHAR RelativeName = NULL;

    SAMTRACE("SampDsInitializeDomainObject");

    ASSERT(1 < Index);
    ASSERT(NULL != DomainInfo->DomainDsName);

    // Because the first two slots in the SampDefinedDomains array are
    // currently (temporarily) filled with information from the registry,
    // the Index is "off by 2", so subtract 2 in order get the correct
    // index into the DomainInfo array.

    DsName = DomainInfo[Index - 2].DomainDsName;

    if (NULL != DsName)
    {
        // An index value of 0, 2, 4,...correspond to the Builtin domains,
        // while 1, 3, 5,... correspond to the Account domains. Each pair
        // is a single hosted domain.

        if (0 == (Index % 2))
        {
            SampDiagPrint(INFORM,
                          ("SAMSS: Setting Builtin domain policy\n"));

            NtStatus = SampDsSetBuiltinDomainPolicy(Index);

            SampDiagPrint(INFORM,
                          ("SAMSS: SampDsSetBuiltinDomainPolicy status = 0x%lx\n",
                           NtStatus));
        }
        else
        {
            SampDiagPrint(INFORM,
                          ("SAMSS: Setting Account domain policy\n"));

            NtStatus = SampDsSetDomainPolicy(DsName, Index);

            SampDiagPrint(INFORM,
                          ("SAMSS: SampDsSetDomainPolicy status = 0x%lx\n",
                           NtStatus));
        }
    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Null or invalid domain DS name\n"));
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampDsInitializeSingleDomain(DsName,
                                                Index,
                                                MixedDomain,
                                                BehaviorVersion,
                                                ServerRole,
                                                LastLogonTimeStampSyncInterval
                                                );

        SampDiagPrint(INFORM,
                      ("SAMSS: SampDsInitializeSingleDomain status = 0x%lx\n",
                       NtStatus));
    }

    return(NtStatus);
}


NTSTATUS
SampStartDirectoryService(
    VOID
    )

/*++

Routine Description:

    This routine starts the Direcotry Service during system initialization on
    a domain controller. This routine should never be called on a workstation
    or member server.

    NOTE: We may want to add code to perform the first-time conversion of NT4
    SAM registry data to NT5 SAM DS data in this routine, so that upgrades
    are made automatically the first time the NT5 DC is booted.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or RTL error otherwise.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    DWORD StartTime = 0;
    DWORD StopTime = 0;

    SAMTRACE("SampStartDirectoryService");

    // Should only be here if this is a domain controller.

    ASSERT(NtProductLanManNt == SampProductType);


    StartTime = GetTickCount();
    NtStatus = SampDsInitialize(TRUE);      // SAM loopback enabled
    StopTime = GetTickCount();

   

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAMSS: SampDsInitialize status = 0x%lx\n",
               NtStatus));

    if (NT_SUCCESS(NtStatus))
    {
        #ifndef USER_MODE_SAM

        SampDiagPrint(INFORM,
                      ("SAMSS: DsInitialize took %lu seconds to complete\n",
                       ((StopTime - StartTime) / 1000)));

        #endif

        if (NT_SUCCESS(NtStatus))
        {
            // BUG: Where is this defined, and what is it used for?

            // DirectoryInitialized = TRUE;
        }
    }

    return(NtStatus);
}


NTSTATUS
SampDsInitializeDomainObjects(
    VOID
    )

/*++

Routine Description:

    This routine is the top-level domain initialization routine for the NT5
    DC. For each domain object, the array SampDefinedDomains is grown and
    corresponding domain information is placed in the array.

    An NT5 DC has the notion of "hosted domains", each of which contains
    two domains (domain objects): the Builtin and the Account domains.

    An NT5 DC can host multiple domains, so there will be pairs of domain
    objects representing each hosted domain. This routine is responsible
    for initializing the hosted domains.

Arguments:

    None.

Return Value:

    TRUE if successful, else FALSE indicating that one or more domains were
    not initialized.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    SAMP_DOMAIN_INIT_INFO DomainInitInfo;
    BOOLEAN MixedDomain = FALSE;
    ULONG i = 0;
    DOMAIN_SERVER_ROLE ServerRole;
    POLICY_LSA_SERVER_ROLE LsaServerRole;
    ULONG              BehaviorVersion;
    ULONG              LastLogonTimeStampSyncInterval;

    // Call the routine to start and initialize the DS bootstrap information
    // needed to start SAM on the DS.

    // BUG: This routine needs to move into LSA initialization.

    // At the point where LSA is converted to use the DS backing store, it
    // will need to call this routine (or similar), hence, should no longer
    // be called from SAM.

    NtStatus = SampStartDirectoryService();

    if (!NT_SUCCESS(NtStatus))
    {
        // If the directory service could not be started for any reason,
        // SAM server assumes that it will not use the DS for account data,
        // and instead fall back to the registry account data to bring the
        // system "back to life".

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampStartDirectoryService status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Find out the authoritative domain the ds hosts
    //
    NtStatus = SampDsBuildRootObjectName();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampDsBuildRootObjectName failed with 0x%x\n",
                   NtStatus));

        return (NtStatus);
    }

    NtStatus = SampInitWellKnownContainersDsName(RootObjectName);
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampInitWellKnownContainersDsName failed with 0x%x\n",
                   NtStatus));

        return (NtStatus);
    }

    //
    // Get the server role ( PDC/BDC) of this server in the domain
    // We do this by making a call to the DS and looking at the FSMO.
    //

    NtStatus = SampGetServerRoleFromFSMO(&ServerRole);
    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampGetServerRole status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Tell the static half of netlogon regarding the server role.
    //

    switch (ServerRole)
    {
    case DomainServerRolePrimary:
        LsaServerRole=
            PolicyServerRolePrimary;
        break;

    case DomainServerRoleBackup:
         LsaServerRole=
            PolicyServerRoleBackup;
        break;

    default:
        ASSERT(FALSE && "InvalidServerRole");
        return (STATUS_INTERNAL_ERROR);
    }

    IgnoreStatus = I_NetNotifyRole(
                        LsaServerRole
                        );

    //
    // Retrieve domain settings from root domainDNS object. Need information 
    // like IsMixedDomain, DomainBehaviorVersion, LastLogonTimeStampSyncInterval. 
    //


    NtStatus = SampGetDsDomainSettings(&MixedDomain, 
                                       &BehaviorVersion, 
                                       &LastLogonTimeStampSyncInterval
                                       );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampIsMixedDomain status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Read our DNS domain Name Information
    //

    //                      INITIALIZE NT5 DS DOMAINS
    //
    // If this domain controller hosts multiple domains, continue initializing
    // the defined-domains array with these domains. Start by getting domain
    // information from the DS, corresponding to the remaining domains.
    //
    // During the period of transition from NT4-to-NT5 domain initialization,
    // this overall routine assumes that the original registry-based domains
    // (Builtin and Account) exist and are initialized as in NT4 -- that is
    // what has happened up to this point of execution.
    //
    // The following code continues the initialization process by setting up
    // any further domains that exist in the DS backing store.
    //
    // Conceptually, each hosted domain contains both the Builtin and Account
    // domains in order to faithfully emulate and support the existing SAM and
    // LSA code.

    // BUG: Should this "bootstrap" info come from the registry instead?
    //
    // The NT4 SAM-LSA account and policy information is created by a variety
    // of procedures (setup, bldsam3.c, etc.) and ensure that enough "boot-
    // strap" information is in the database before SAM initialization. The
    // NT5 SAM initialization (and in particular, domain initialization) also
    // requires similar bootstrapping information, which is not yet implement-
    // ed.

    // Get the startup domain-initialization information from the DS.
    //
    // SampDsGetDomainInitInfoEx presumes a DIT created with dsupgrad and also
    // currently assumes /o=Microsoft/cn=BootstrapDomain as the prefix.

    NtStatus = SampDsGetDomainInitInfoEx(&DomainInitInfo);

    if (NT_SUCCESS(NtStatus) && (NULL != DomainInitInfo.DomainInfo))
    {
        if (0 < DomainInitInfo.DomainCount)
        {
            // There are additional domains, grow the defined-domains array.

            NtStatus = SampExtendDefinedDomains(DomainInitInfo.DomainCount);

            if (NT_SUCCESS(NtStatus))
            {
                // The first two domains are the default Builtin and Account
                // domains of NT4, and were initialized previously. Any re-
                // maining domains are discovered in the DS along with their
                // policy.

                // BUG: Need to disable NT4 registry-based initialization.

                // When the DS/schema/data is fully ready to support the NT5
                // DC, then we can disable the registry-based initialization.

                for (i = 2; i < DomainInitInfo.DomainCount + 2; i++)
                {
                    // Set up each additional domain. This loop iterates over
                    // the domains (there are two domains for each hosted do-
                    // main: Builtin and Account).

                    NtStatus = SampDsInitializeDomainObject(
                                    DomainInitInfo.DomainInfo,
                                    i,
                                    MixedDomain,
                                    BehaviorVersion,
                                    ServerRole,
                                    LastLogonTimeStampSyncInterval
                                    );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        // Error initializing one of the domains in the DS.

                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampDsInitializeDomainObject status = 0x%lx\n",
                                   NtStatus));

                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: Defined domain index = %lu\n",
                                   i));

                        return(NtStatus);
                    }
                }
            }
            else
            {
                return(NtStatus);
            }
            // comment: Should we catch this failure ???
            // SampExtendDefinedDomains
        }

        SampDiagPrint(INFORM,
                      ("SAMSS: Initialized %lu DS domain(s)\n",
                       DomainInitInfo.DomainCount));
    }
    else
    {
        // Even if there are zero domains, shouldn't get NULL domain
        // information.

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDsGetDomainInitInfo status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampGetDsDomainSettings(
    BOOLEAN * MixedDomain,
    ULONG   * BehaviorVersion,
    ULONG   * LastLogonTimeStampSyncInterval
    )
/*++

        This routine checks the Root domain object, to see if
        that it is a mixed NT4 - NT5 Domain

        Parameters:

                None: Today there is only a single hosted domain. When multiple hosted
                domain support is incorporated, then the domain initilization code needs
                to be revisted, to perform mixed domain initialization, appropriately.

        Return Values

                TRUE -- Is a Mixed Domain
                FALE -- Is a pure NT5 or above Domain

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    ATTRTYP         MixedDomainAttrTyp[] = { 
                                             ATT_NT_MIXED_DOMAIN, 
                                             ATT_MS_DS_BEHAVIOR_VERSION, 
                                             ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL
                                           };
    ATTRVAL     MixedDomainAttrVal[] = {{ 1, NULL }, {1,NULL}, {1,NULL}};
    DEFINE_ATTRBLOCK3(MixedDomainAttr,MixedDomainAttrTyp,MixedDomainAttrVal);
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    COMMARG     *pCommArg;
    READRES     *pReadRes;
    ULONG       RetValue;
    ULONG       i;


    SAMTRACE("SampGetDsDomainSettings");

    //
    // Initialize Return Values
    //

    *MixedDomain = FALSE;
    *BehaviorVersion = 0;
    *LastLogonTimeStampSyncInterval = SAMP_DEFAULT_LASTLOGON_TIMESTAMP_SYNC_INTERVAL;

    //
    // Begin a Lazy Transactioning
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Init ReadArg
    //
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.AttrTypBlock = MixedDomainAttr;

    //
    // Build the commarg structure
    //

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the Read Arg Structure
    //

    ReadArg.pObject = ROOT_OBJECT;
    ReadArg.pSel    = & EntInf;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirRead");

    RetValue = DirRead(& ReadArg, & pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue,&pReadRes->CommRes);
    }


    //
    // Process Return values from the DS calls
    //

    if (STATUS_SUCCESS==NtStatus)
    {
        //
        // Successful Read
        //

        for (i=0;i<pReadRes->entry.AttrBlock.attrCount;i++)
        {
            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_NT_MIXED_DOMAIN)
            {
                if (*((ULONG *) (pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)))
                {
                    *MixedDomain = TRUE;
                }
                else
                {
                    *MixedDomain = FALSE;
                }
            }

            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_BEHAVIOR_VERSION)
            {
                *BehaviorVersion = 
                    (*((ULONG *) (pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)));
            }

            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL)
            {
                *LastLogonTimeStampSyncInterval = 
                    (*((ULONG *) (pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)));
            }
        }
    }
    else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        *MixedDomain = FALSE;
        NtStatus = STATUS_SUCCESS;
    }

    //
    // To prevent data overflow, if the value is greater than 100000. 
    // Set it to 100000 (it is 274 years, customer will not notice that). 
    // 

    if (*LastLogonTimeStampSyncInterval > 100000)
    {
        *LastLogonTimeStampSyncInterval = 100000;
    }


    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Close the Transaction
    //

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SampDiagPrint(INFORM,("SAMSS: Query For Mixed NT Domain,Mixed Domain=%d,Error Code=%d\n",
                                                                    *MixedDomain,NtStatus));
#if DBG

    //
    // This is for checked build only. If this regkey is set, 
    // LastLogonTimeStampSyncInterval will be a "unit" by minute instead 
    // of "days", which helps to test this feature.
    // 

    {
        ULONG   WinError = ERROR_SUCCESS;
        HKEY    LsaKey;
        DWORD   dwType, dwSize = sizeof(DWORD), dwValue = 0;

        WinError = RegOpenKey(HKEY_LOCAL_MACHINE,
                              __TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                              &LsaKey
                              );

        if (ERROR_SUCCESS == WinError)
        {
            WinError = RegQueryValueEx(LsaKey,
                                       __TEXT("UpdateLastLogonTSByMinute"),
                                       NULL,
                                       &dwType,
                                       (LPBYTE)&dwValue,
                                       &dwSize
                                       );

            if ((ERROR_SUCCESS == WinError) && 
                (REG_DWORD == dwType) &&
                (1 == dwValue))
            {
                SampLastLogonTimeStampSyncByMinute = TRUE;
            }

            RegCloseKey(LsaKey);
        }
    }
#endif

    return NtStatus;
}

NTSTATUS
SampGetDsDomainCrossRefSettings(
    UNICODE_STRING * DnsName,
    UNICODE_STRING * NetbiosName
    )
/*++

    This routine checks the domain cross ref to retrieve the DNS name and net bios name

    Parameters:

            DnsName: Out parameter indicating the DNS domain name
            Netbiosname: Out parameter indicating the netbios domain name

    Return Values

            NTSTATUS code returning the result of the operation.

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    ATTRTYP         CrossRefAttrTyp[] = {    ATT_DNS_ROOT, 
                                             ATT_NETBIOS_NAME
                                        };
    ATTRVAL         CrossRefAttrVal[] = {{1,NULL}, {1,NULL}};
    DEFINE_ATTRBLOCK2(CrossRefAttr,CrossRefAttrTyp,CrossRefAttrVal);
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    COMMARG     *pCommArg;
    READRES     *pReadRes;
    ULONG       RetValue;
    ULONG       i;
    PDSNAME     DomainCrossRef=NULL;
    ULONG       DomainCrossRefLen=0;


    SAMTRACE("SampGetDsDomainCrossRefSettings");

    //
    // Initialize Return Values
    //

    RtlZeroMemory(DnsName,sizeof(UNICODE_STRING));
    RtlZeroMemory(NetbiosName, sizeof(UNICODE_STRING));
    //
    // Begin a Lazy Transactioning
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Get the domain cross ref
    //

    NtStatus = GetConfigurationName(
                DSCONFIGNAME_DOMAIN_CR,
                &DomainCrossRefLen,
                NULL
                );

    if (STATUS_BUFFER_TOO_SMALL==NtStatus)
    {
       DomainCrossRef = MIDL_user_allocate(DomainCrossRefLen);
       if (NULL==DomainCrossRef)
       {
           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
           goto Cleanup;
       }

       NtStatus = GetConfigurationName(
                        DSCONFIGNAME_DOMAIN_CR,
                        &DomainCrossRefLen,
                        DomainCrossRef
                        );
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // Init ReadArg
    //
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.AttrTypBlock = CrossRefAttr;

    //
    // Build the commarg structure
    //

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the Read Arg Structure
    //

    ReadArg.pObject = DomainCrossRef;
    ReadArg.pSel    = & EntInf;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirRead");

    RetValue = DirRead(& ReadArg, & pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue,&pReadRes->CommRes);
    }

    //
    // Process Return values from the DS calls
    //
    if (STATUS_SUCCESS==NtStatus)
    {
        //
        // Successful Read
        //

        for (i=0;i<pReadRes->entry.AttrBlock.attrCount;i++)
        {
            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_DNS_ROOT)
            {
                DnsName->Length = (USHORT) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
                DnsName->MaximumLength = DnsName->Length;

                DnsName->Buffer = MIDL_user_allocate(DnsName->Length);
                if (NULL==DnsName->Buffer)
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                RtlCopyMemory(DnsName->Buffer,
                                pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal,
                                DnsName->Length
                                );
            }

            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_NETBIOS_NAME)
            {
                NetbiosName->Length = (USHORT) pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].valLen;
                NetbiosName->MaximumLength = NetbiosName->Length;

                NetbiosName->Buffer = MIDL_user_allocate(NetbiosName->Length);
                if (NULL==NetbiosName->Buffer)
                {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                RtlCopyMemory(NetbiosName->Buffer,
                                pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal,
                                NetbiosName->Length
                                );
            }
             
        }
    }
    

Cleanup:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Close the Transaction
    //

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=DnsName->Buffer)
        {
            MIDL_user_free(DnsName->Buffer);
        }

        if (NULL!=NetbiosName->Buffer)
        {
            MIDL_user_free(NetbiosName->Buffer);
        }
    }

    if (NULL!=DomainCrossRef)
    {
        MIDL_user_free(DomainCrossRef);
    }

    return NtStatus;
}

BOOLEAN
SamIMixedDomain(
  IN SAMPR_HANDLE DomainHandle
  )
/*++

    Routine Description

          Tells in process clients wether we are in a mixed domain
          environment. No Validation of the domain handle is performed

    Parameters:

          DomainHandle -- Handle to the Domain

    Return Values

         TRUE means mixed domain
         FALSE means non mixed domain
--*/
{

      if (!SampUseDsData)
      {
         //
         // Registry Mode, we are always mixed domain
         //

         return (TRUE);
      }

      return ( DownLevelDomainControllersPresent(
                  ((PSAMP_OBJECT) DomainHandle)->DomainIndex));
}

NTSTATUS
SamIMixedDomain2(
  IN PSID DomainSid,
  OUT BOOLEAN *MixedDomain
  )
/*++

    Routine Description

          Tells in process clients wether we are in a mixed domain
          environment. No Validation of the domain handle is performed

    Parameters:

          DomainSid -- Sid of the Domain
          MixedDomain --- Result is returned in here. TRUE means the domain
                          is in mixed mode

    Return Values

         STATUS_SUCCESS
         STATUS_INVALID_PARAMETER
         STATUS_NO_SUCH_DOMAIN
--*/
{
      ULONG DomainIndex;

      if (!RtlValidSid(DomainSid))
          return STATUS_INVALID_PARAMETER;

      if (!SampUseDsData)
      {
         //
         // Registry Mode, we are always mixed domain
         //

         *MixedDomain=TRUE;
         return STATUS_SUCCESS;
      }

      for (DomainIndex=SampDsGetPrimaryDomainStart();
                DomainIndex<SampDefinedDomainsCount;DomainIndex++)
      {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid,
                            DomainSid))
        {
            break;
        }
      }

      if (DomainIndex>=SampDefinedDomainsCount)
          return STATUS_NO_SUCH_DOMAIN;



      if ( DownLevelDomainControllersPresent(
                  DomainIndex))
      {
          *MixedDomain = TRUE;
      }
      else
      {
          *MixedDomain = FALSE;
      }

      return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\domain.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    domain.c

Abstract:

    This file contains services related to the SAM "domain" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    16-Aug-96
        Added initial code for DS-based domain initialization.
    ChrisMay    08-Oct-96
        Added crash-recovery code.
    ChrisMay    31-Jan-97
        Added multi-master RID management routines for account creation.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include "ntlsa.h"
#include "lmcons.h"                                    // LM20_PWLEN
#include "msaudite.h"
#include <nlrepl.h>                   // I_NetNotifyMachineAccount prototype
#include <ridmgr.h>
#include <enckey.h>
#include <wxlpc.h>
#include <cryptdll.h>
#include "dslayer.h"
#include "attids.h"
#include "filtypes.h"
#include "sdconvrt.h"
#include <dnsapi.h>
#include <samtrace.h>



//
// When performing Name/Id lookups via SamrLookupNamesInDomain or
// SamrLookupIdsInDomain this is the maximum number of lookups to 
// perform within one transaction.
//
#ifdef DBG
#define SAM_MAX_LOOKUPS_PER_TRANSACTION ((ULONG)10)
#else
#define SAM_MAX_LOOKUPS_PER_TRANSACTION ((ULONG)2000)
#endif

//
// Bound the maximum number of Ids that can be looked up in
// one call, this value is consistent with 
// LSAP_DB_TRIAL_MAXIMUM_SID_COUNT in lsa\uclient\rpcapi.c
//                                          
#define SAM_MAXIMUM_SID_LOOKUP_COUNT    ((ULONG)20480)   // 0x5000 


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampInitializeSingleDomain(
    ULONG Index
    );

NTSTATUS
SampSetDomainPolicy(
    VOID
    );

NTSTATUS
SampSetDcDomainPolicy(
    VOID
    );

NTSTATUS
SampBuildDomainKeyName(
    OUT PUNICODE_STRING DomainKeyName,
    IN PUNICODE_STRING DomainName OPTIONAL
    );

NTSTATUS
SampDoGroupCreationChecks(
    IN PSAMP_OBJECT DomainContext
    );

NTSTATUS
SampDoAliasCreationChecks(
    IN PSAMP_OBJECT DomainContext
    );

NTSTATUS
SampDoUserCreationChecks(
    IN PSAMP_OBJECT DomainContext,
    IN  ULONG   AccountType,
    OUT BOOLEAN *CreateByPrivilege,
    OUT ULONG   *pAccessRestriction
    );


NTSTATUS
SampCheckForDuplicateSids(
    PSAMP_OBJECT DomainContext,
    ULONG   NewAccountRid
    );

NTSTATUS
SampGetAccountNameFromRid(
    OUT PRPC_UNICODE_STRING AccountName,
    IN ULONG Rid
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RPC Dispatch routines                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SamrOpenDomain(
    IN SAMPR_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PRPC_SID DomainId,
    OUT SAMPR_HANDLE *DomainHandle
    )

/*++

Routine Description:

    This service is the RPC dispatch routine for SamrOpenDomain().

Arguments:

    ServerHandle - An active context handle to a Server object.

    Access desired to the domain.

    DomainId - The SID of the domain to open.

    DomainHandle - If successful, will receive the context handle value
        for the newly opened domain.  Otherwise, NULL is returned.

Return Value:

    STATUS_SUCCESS - The object has been successfully openned.

    STATUS_INSUFFICIENT_RESOURCES - The SAM server processes doesn't
        have sufficient resources to process or accept another connection
        at this time.

    Other values as may be returned from:

            NtAccessCheckAndAuditAlarm()


--*/
{
    NTSTATUS            NtStatus, IgnoreStatus;
    PSAMP_OBJECT        DomainContext, ServerContext = (PSAMP_OBJECT)ServerHandle;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             fLockAcquired = FALSE; 
    DECLARE_CLIENT_REVISION(ServerHandle);

    SAMTRACE_EX("SamrOpenDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenDomain
                   );

    //
    // Parameter Validation
    //   1. Lookup Context will validate ServerHandle
    //   2. Desired Access need not be validated. Invalid combinations will
    //      be failed by access check
    //       3. DomainId and DomainHandle are validated here
    //

    if (!RtlValidSid(DomainId))
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
    }



    //
    // Grab a read lock (if necessary). Lock is not required for loopback client
    //
    
    SampMaybeAcquireReadLock(ServerContext, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);


    //
    // Validate type of, and access to server object.
    //

    NtStatus = SampLookupContext(
                   ServerContext,
                   SAM_SERVER_LOOKUP_DOMAIN,       // DesiredAccess
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Try to create a context for the domain.
        //

        DomainContext = SampCreateContextEx(
                            SampDomainObjectType,
                            ServerContext->TrustedClient,
                            IsDsObject(ServerContext),
                            ServerContext->NotSharedByMultiThreads, 
                            ServerContext->LoopbackClient,
                            FALSE,          // lazy commit
                            FALSE,          // persistaccrosscall
                            FALSE,          // buffered write 
                            FALSE,          // Opened By DCPromo
                            SampDsGetPrimaryDomainStart()
                            );
                    
        if (DomainContext != NULL) {

            //
            // Set the client revision appropriately
            //

            DomainContext->ClientRevision = ServerContext->ClientRevision;

            //
            // Open the specified domain's registry key in Registry mode
            // In DS mode this sets the object's DS Name
            //

            //
            // Do not set transaction in domain for if we in DS mode
            //
            NtStatus = SampOpenDomainKey(
                           DomainContext,
                           DomainId,
                           IsDsObject(ServerContext)?FALSE:TRUE
                           );

            if (NT_SUCCESS(NtStatus)) {


                //
                // Reference the object for the validation
                //

                SampReferenceContext(DomainContext);



                //
                // Validate the caller's access.
                //

                NtStatus = SampValidateObjectAccess(
                               DomainContext,                //Context
                               DesiredAccess,                //DesiredAccess
                               FALSE                         //ObjectCreation
                               );

                if ( NT_SUCCESS(NtStatus) ) {

                    //
                    // Validate the client's ability to understand this domain
                    //
                    if ( SampIsContextFromExtendedSidDomain(DomainContext)
                      && DomainContext->ClientRevision < SAM_NETWORK_REVISION_3 ) {

                        NtStatus = STATUS_NOT_SUPPORTED;
                    }
                }

                //
                // Dereference object, discarding any changes
                //

                if (fLockAcquired)
                {
                    IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
                }
                else
                {
                    IgnoreStatus = SampDeReferenceContext2(DomainContext, FALSE);
                }
                ASSERT(NT_SUCCESS(IgnoreStatus));

                //
                // if we didn't pass the access test, then free up the context
                // block and return the error status returned from the access
                // validation routine.  Otherwise, return the context handle
                // value.
                //

                if (!NT_SUCCESS(NtStatus)) {
                    SampDeleteContext( DomainContext );
                } else {
                    (*DomainHandle) = DomainContext;
                }
            } else {
                //
                // SampOpenDomainKey failed
                //

                SampDeleteContext( DomainContext );
            }

        } else {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // De-reference the server object
        //

        IgnoreStatus = SampDeReferenceContext( ServerContext, FALSE );
    }

    //
    // Free the read lock
    //


    SampMaybeReleaseReadLock(fLockAcquired);


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenDomain
                   );


    return(NtStatus);


}


NTSTATUS
SamrQueryInformationDomain2(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    )
{
    //
    // This is a thin veil to SamrQueryInformationDomain().
    // This is needed so that new-release systems can call
    // this routine without the danger of passing an info
    // level that release 1.0 systems didn't understand.
    //

    return( SamrQueryInformationDomain(DomainHandle, DomainInformationClass, Buffer ) );
}

NTSTATUS
SamrQueryInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    This service retrieves information about a domain object.

Arguments:

    DomainHandle - A handle obtained via a previous call to SamrOpenDomain().

    DomainInformationClass - Indicates the type of information to retrieve.

    Buffer - Receives the requested information.  Several blocks of memory
        will be returned: (one) containing a pointer to the (second) which
        contains the requested information structure.  This block may contain
        pointers, which will point to other blocks of allocated memory, such
        as string buffers.  All of these blocks of memory must be
        (independently) deallocated using MIDL_user_free().

Return Value:


    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_ACCESS_DENIED - Caller's handle does not have the appropriate
        access to the object.


--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG                   i;


    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                      ||
    //                                      vv
    PVOID                   AllocatedBuffer[10];
    ULONG                   AllocatedBufferCount = 0;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrQueryInformationDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationDomain
                   );


#define RegisterBuffer(Buffer)                               \
    if ((Buffer) != NULL) {                                  \
        ASSERT(AllocatedBufferCount < sizeof(AllocatedBuffer)/sizeof(*AllocatedBuffer)); \
        AllocatedBuffer[AllocatedBufferCount++] = (Buffer);  \
    }

#define AllocateBuffer(BufferPointer, Size)                  \
    (BufferPointer) = MIDL_user_allocate((Size));            \
    RegisterBuffer((BufferPointer));


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL) && (*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // Set the desired access based upon the Info class
    //

    switch (DomainInformationClass) {

    case DomainPasswordInformation:
    case DomainLockoutInformation:

        DesiredAccess = DOMAIN_READ_PASSWORD_PARAMETERS;
        break;


    case DomainGeneralInformation:
    case DomainLogoffInformation:
    case DomainOemInformation:
    case DomainNameInformation:
    case DomainServerRoleInformation:
    case DomainReplicationInformation:
    case DomainModifiedInformation:
    case DomainStateInformation:
    case DomainUasInformation:
    case DomainModifiedInformation2:

        DesiredAccess = DOMAIN_READ_OTHER_PARAMETERS;
        break;


    case DomainGeneralInformation2:

        DesiredAccess = DOMAIN_READ_PASSWORD_PARAMETERS |
                        DOMAIN_READ_OTHER_PARAMETERS;
        break;

    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        goto Error;
    } // end_switch



    //
    // Allocate the info structure
    //

    AllocateBuffer(*Buffer, sizeof(SAMPR_DOMAIN_INFO_BUFFER) );
    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    SampAcquireReadLock();


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DesiredAccess,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    ClientRevision = DomainContext->ClientRevision;

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];


        //
        // case on the type information requested
        //

        switch (DomainInformationClass) {

        case DomainUasInformation:

            (*Buffer)->General.UasCompatibilityRequired =
                Domain->UnmodifiedFixed.UasCompatibilityRequired;

            break;


        case DomainGeneralInformation2:


            (*Buffer)->General2.LockoutDuration =
                Domain->UnmodifiedFixed.LockoutDuration;

            (*Buffer)->General2.LockoutObservationWindow =
                Domain->UnmodifiedFixed.LockoutObservationWindow;

            (*Buffer)->General2.LockoutThreshold =
                Domain->UnmodifiedFixed.LockoutThreshold;



            //
            // WARNING - GeneralInformation2 falls into the
            // GeneralInformation code for the rest of its processing.
            // This action assumes that the beginning of a GeneralInformation2
            // structure is a GeneralInformation structure !!!
            //

            // don't break;

        case DomainGeneralInformation:

            ///////////////////////////////////////////////////////
            //                                                   //
            // Warning, the previous case falls into this case.  //
            // Be aware of this when working on this code.       //
            //                                                   //
            ///////////////////////////////////////////////////////

            (*Buffer)->General.ForceLogoff =
                *((POLD_LARGE_INTEGER)&Domain->UnmodifiedFixed.ForceLogoff);

            (*Buffer)->General.DomainModifiedCount =
                *((POLD_LARGE_INTEGER)&Domain->NetLogonChangeLogSerialNumber);

            (*Buffer)->General.DomainServerState =
                Domain->UnmodifiedFixed.ServerState;

            //
            // In DS case,
            //      UnmodifiedFixed will not correctly reflect the domain role.
            //      because Server Role is not stored in disk. it is being set during
            //      SAM initialization time by looking DS and FSMO
            //
            // In Registry case, both UnmoidiedFixed and Domain->ServerRole are correct,
            //      they are consistent.
            //

            (*Buffer)->General.DomainServerRole =
                Domain->ServerRole;

            (*Buffer)->General.UasCompatibilityRequired =
                Domain->UnmodifiedFixed.UasCompatibilityRequired;


            //
            // Copy the domain name from our in-memory structure.
            //

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;   // Default status if the allocate fails

            AllocateBuffer((*Buffer)->General.DomainName.Buffer,
                            Domain->ExternalName.MaximumLength );

            if ((*Buffer)->General.DomainName.Buffer != NULL) {

                NtStatus = STATUS_SUCCESS;

                (*Buffer)->General.DomainName.Length = Domain->ExternalName.Length;
                (*Buffer)->General.DomainName.MaximumLength = Domain->ExternalName.MaximumLength;

                RtlCopyMemory((*Buffer)->General.DomainName.Buffer,
                              Domain->ExternalName.Buffer,
                              Domain->ExternalName.MaximumLength
                              );

                //
                // Now get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               DomainContext,
                               SAMP_DOMAIN_OEM_INFORMATION,
                               TRUE,
                               (PUNICODE_STRING)&((*Buffer)->General.OemInformation)
                               );

                if (NT_SUCCESS(NtStatus)) {
                    RegisterBuffer((*Buffer)->General.OemInformation.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   DomainContext,
                                   SAMP_DOMAIN_REPLICA,
                                   TRUE,
                                   (PUNICODE_STRING)&((*Buffer)->General.ReplicaSourceNodeName) // Body
                                   );

                    if (NT_SUCCESS(NtStatus)) {
                        RegisterBuffer((*Buffer)->General.ReplicaSourceNodeName.Buffer);
                    }
                }
            }


            //
            // Get the count of users and groups
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampRetrieveAccountCounts(
                               &(*Buffer)->General.UserCount,
                               &(*Buffer)->General.GroupCount,
                               &(*Buffer)->General.AliasCount );
            }



            break;


        case DomainPasswordInformation:

            (*Buffer)->Password.MinPasswordLength       =
                Domain->UnmodifiedFixed.MinPasswordLength;
            (*Buffer)->Password.PasswordHistoryLength   =
                Domain->UnmodifiedFixed.PasswordHistoryLength;
            (*Buffer)->Password.PasswordProperties   =
                Domain->UnmodifiedFixed.PasswordProperties;
            (*Buffer)->Password.MaxPasswordAge          =
                Domain->UnmodifiedFixed.MaxPasswordAge;
            (*Buffer)->Password.MinPasswordAge          =
                Domain->UnmodifiedFixed.MinPasswordAge;

            break;


        case DomainLogoffInformation:

            (*Buffer)->Logoff.ForceLogoff =
                Domain->UnmodifiedFixed.ForceLogoff;

            break;

        case DomainOemInformation:

            RtlZeroMemory(&((*Buffer)->Oem.OemInformation), sizeof(UNICODE_STRING));

            NtStatus = SampGetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_OEM_INFORMATION,
                           TRUE,
                           (PUNICODE_STRING)&((*Buffer)->Oem.OemInformation)
                           );

            if (!NT_SUCCESS(NtStatus) &&
                (*Buffer)->Oem.OemInformation.Buffer ) {
                RegisterBuffer((*Buffer)->Oem.OemInformation.Buffer);
            }

            break;

        case DomainNameInformation:

            //
            // Copy the domain name from our in-memory structure.
            //

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;   // Default status if the allocate fails

            AllocateBuffer((*Buffer)->Name.DomainName.Buffer,
                           Domain->ExternalName.MaximumLength);

            if ((*Buffer)->Name.DomainName.Buffer != NULL) {

                NtStatus = STATUS_SUCCESS;

                (*Buffer)->Name.DomainName.Length = Domain->ExternalName.Length;
                (*Buffer)->Name.DomainName.MaximumLength = Domain->ExternalName.MaximumLength;

                RtlCopyMemory((*Buffer)->Name.DomainName.Buffer,
                              Domain->ExternalName.Buffer,
                              Domain->ExternalName.MaximumLength
                              );
            }

            break;

        case DomainServerRoleInformation:

            (*Buffer)->Role.DomainServerRole =
                Domain->ServerRole;

            break;

        case DomainReplicationInformation:

            NtStatus = SampGetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_REPLICA,
                           TRUE,
                           (PUNICODE_STRING)&((*Buffer)->Replication.ReplicaSourceNodeName) // Body
                           );

            if (NT_SUCCESS(NtStatus)) {
                RegisterBuffer((*Buffer)->Replication.ReplicaSourceNodeName.Buffer);
            }

            break;

        case DomainModifiedInformation2:

            (*Buffer)->Modified2.ModifiedCountAtLastPromotion =
                Domain->UnmodifiedFixed.ModifiedCountAtLastPromotion;

            //
            //  This case falls through to DomainModifiedInformation
            //


        case DomainModifiedInformation:

            /////////////////////////////////
            //                             //
            //          WARNING            //
            //                             //
            //  The previous case falls    //
            //  into this one.             //
            //                             //
            /////////////////////////////////

            (*Buffer)->Modified.DomainModifiedCount =
                Domain->NetLogonChangeLogSerialNumber;
            (*Buffer)->Modified.CreationTime =
                Domain->UnmodifiedFixed.CreationTime;

            break;

        case DomainStateInformation:

            (*Buffer)->State.DomainServerState =
                Domain->UnmodifiedFixed.ServerState;

            break;


        case DomainLockoutInformation:

            (*Buffer)->Lockout.LockoutDuration          =
                Domain->UnmodifiedFixed.LockoutDuration;
            (*Buffer)->Lockout.LockoutObservationWindow =
                Domain->UnmodifiedFixed.LockoutObservationWindow;
            (*Buffer)->Lockout.LockoutThreshold         =
                Domain->UnmodifiedFixed.LockoutThreshold;

            break;

        }






        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }
        *Buffer = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationDomain
                   );


    return(NtStatus);
}

NTSTATUS
SamIDoFSMORoleChange(
 IN SAMPR_HANDLE DomainHandle
 )
/*++

  Routine Description:


   This routine requests the FSMO role change from the PDC

  Return Values

    STATUS_SUCCESS
    Other Error Codes

--*/
{
    OPARG OpArg;
    OPRES *OpRes;
    ULONG RetCode;
    PSID  DomainSid;
    PSAMP_OBJECT DomainContext = (PSAMP_OBJECT)DomainHandle;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Return a STATUS_SUCCESS right upfront if we are
    // in registry mode. The LSA might call this function in
    // registry mode
    //

    if (!SampUseDsData)
    {
        return (STATUS_SUCCESS);
    }


    //
    // We must be in DS Mode, not hold sam lock,
    // not having an open transaction.
    //

    ASSERT(IsDsObject(DomainContext));
    ASSERT(!SampCurrentThreadOwnsLock());
    ASSERT(!SampExistsDsTransaction());

    //
    // If it is the builtin domain, then smile and
    // return success
    //

    if (SampDefinedDomains[DomainContext->DomainIndex].IsBuiltinDomain)
    {
        return STATUS_SUCCESS;
    }

    //
    // Create a Thread state in the DS
    //

    RetCode = THCreate( CALLERTYPE_SAM );
    if (0!=RetCode)
    {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Error;
    }

    //
    // Grab the FSMO for promotion
    //

    RtlZeroMemory(&OpArg, sizeof(OPARG));
    OpArg.eOp = OP_CTRL_BECOME_PDC;
    DomainSid =  SampDefinedDomains[DomainContext->DomainIndex].Sid;
    OpArg.pBuf = DomainSid;
    OpArg.cbBuf = RtlLengthSid(DomainSid);

    //
    // When the NT4 tool server manager is used there is a case where 
    // DirOperationControl is failed. This happens if a fresh binding
    // handle needs to be generated. Generating a fresh binding handle
    // requires a fresh authentication to be performed. Server manager 
    // stops the netlogon service on both DC's -- because NT4 DC's could
    // not handle the role change without bouncing the netlogon service.
    // In windows 2000 and above  this stops advertising of the DC's. 
    // Since windows 2000 uses kerberos to authenticate if there are no 
    // other DC's available then the authentication may fail. 
    //
    // This is not a major issue for customers, customers use windows 2000
    // administrative tools to administer windows 2000. Use of NT4 server
    // manager agains windows 2000 and higher DC's is not recommended.
    //

    RetCode = DirOperationControl(&OpArg, &OpRes);

    if (NULL==OpRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&OpRes->CommRes);
    }


Error:

    //
    // Clean up any open thread states etc.
    //

    ASSERT(!SampExistsDsTransaction());
    THDestroy();

    return NtStatus;

}

NTSTATUS
SamINotifyRoleChange(
    IN PSID   DomainSid,
    IN DOMAIN_SERVER_ROLE NewRole
    )
/*++

    This function is used to set the new role information
    on the server. The role of the server, indicates wether
    the server is a PDC or BDC.

    Parameters

        DomainSid -- The SID of the domain, whose role we want to change
        NewRole   -- The new server role

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    LSAPR_HANDLE       PolicyHandle=INVALID_HANDLE_VALUE;
    LSAPR_POLICY_INFORMATION PolicyInformation;
    ULONG   DomainIndex;
    LARGE_INTEGER LsaCreationTime;
    LARGE_INTEGER LsaModifiedCount;
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH+2];
    ULONG   ComputerNameLength=0;
    BOOLEAN   CheckAndAddWellKnownAccounts = FALSE;

    //
    // Check the new role parameter
    //

    switch (NewRole)
    {
    case DomainServerRolePrimary:
        PolicyInformation.PolicyServerRoleInfo.LsaServerRole=
            PolicyServerRolePrimary;
        break;

    case DomainServerRoleBackup:
         PolicyInformation.PolicyServerRoleInfo.LsaServerRole=
            PolicyServerRoleBackup;
        break;

    default:
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }
    //
    // Lookup the domain SID
    //
    for (DomainIndex=SampDsGetPrimaryDomainStart();
                DomainIndex<SampDefinedDomainsCount;
                    DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid,DomainSid))
        {
            break;
        }

    }

    //
    // If specified domain is not in the in-mmeory defined domains
    // return a distinguished error code
    //

    if (DomainIndex>=SampDefinedDomainsCount)
    {
        NtStatus = STATUS_NO_SUCH_DOMAIN;
        goto Error;
    }

    if (SampDefinedDomains[DomainIndex].IsBuiltinDomain)
    {
        //
        // It is useless to specify a builtin domain SID
        // in here
        //

        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Set the Role in SAM, First acquire the lock
    //

    SampAcquireWriteLock();

    //
    // Print informative debugger messages about role changes
    //

    if ((SampDefinedDomains[DomainIndex].ServerRole==DomainServerRoleBackup)
        && (NewRole==DomainServerRolePrimary))
    {

         CheckAndAddWellKnownAccounts = TRUE;

         SampDiagPrint( DISPLAY_ROLE_CHANGES,
                               ("SAM: Role Change: Promoting to primary\n")
                            );

    }
    else if ((SampDefinedDomains[DomainIndex].ServerRole==DomainServerRolePrimary)
        && (NewRole==DomainServerRoleBackup))
    {

            SampDiagPrint( DISPLAY_ROLE_CHANGES,
                           ("SAM: Role Change: Demoting to backup\n")
                          );
    }

    //
    // Set the Role on to the account domain
    //

    SampDefinedDomains[DomainIndex].ServerRole = NewRole;
    SampDefinedDomains[DomainIndex].CurrentFixed.ServerRole = NewRole;
    SampDefinedDomains[DomainIndex].UnmodifiedFixed.ServerRole = NewRole;

    //
    // Set the Role onto the corresponding builtin domain
    //

    SampDefinedDomains[DomainIndex-1].ServerRole = NewRole;
    SampDefinedDomains[DomainIndex-1].CurrentFixed.ServerRole = NewRole;
    SampDefinedDomains[DomainIndex-1].UnmodifiedFixed.ServerRole = NewRole;



    SampReleaseWriteLock(FALSE);


    //
    // We are promoted to PDC from BDC, kick off the account upgrade
    // 

    if ( CheckAndAddWellKnownAccounts )
    {
        ASSERT( SampUseDsData );
        LsaIRegisterNotification(
                    SampDoAccountsUpgradeDuringPDCTransfer,
                    (PVOID) NULL,   // no parameter
                    NOTIFIER_TYPE_IMMEDIATE,
                    0,              // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    0,              // do it now
                    NULL            // no handle
                    );
    }

    //
    // Force a Full sync of the LSA database
    //

    NtStatus = LsaIOpenPolicyTrusted(&PolicyHandle);
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Set the role in the LSA
    //

    NtStatus = NtQuerySystemTime(&LsaCreationTime);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    LsaModifiedCount.QuadPart = 1;

    NtStatus = LsaISetSerialNumberPolicy(
                    PolicyHandle,
                    &LsaModifiedCount,
                    &LsaCreationTime,
                    TRUE
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Tell Netlogon regarding our server role
    //

    IgnoreStatus = I_NetNotifyRole(
                        PolicyInformation.PolicyServerRoleInfo.LsaServerRole
                        );

    //
    // Finally event log that we are now the PDC
    //
    // Only log this event if we are now the new PDC.
    // Otherwise, we don't say anything so that we do not leave
    // erroneous logs.
    // 

    if ( NewRole == DomainServerRolePrimary )
    {
        ComputerNameLength = sizeof(ComputerName)/sizeof(WCHAR);
        RtlZeroMemory(ComputerName,ComputerNameLength*sizeof(WCHAR));
        if (GetComputerName(ComputerName, &ComputerNameLength))
        {
            PUNICODE_STRING StringsToLog[1];
            UNICODE_STRING ComputerNameU;

            ComputerNameU.Buffer = ComputerName;
            ComputerNameU.Length = ComputerNameU.MaximumLength
                                = (USHORT) ComputerNameLength * sizeof(WCHAR);

            StringsToLog[0]=&ComputerNameU;

            SampWriteEventLog(
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SAMMSG_PROMOTED_TO_PDC,
                    NULL,
                    1,
                    0,
                    StringsToLog,
                    NULL
                    );
        }
    }

    LsaINotifyChangeNotification( PolicyNotifyServerRoleInformation );

Error:

    if (INVALID_HANDLE_VALUE!=PolicyHandle)
    {
        LsarClose(&PolicyHandle);
    }

    return NtStatus;
}


NTSTATUS
SamIQueryServerRole(
    IN SAMPR_HANDLE DomainHandle,
    OUT DOMAIN_SERVER_ROLE *ServerRole
    )
/*++

  Routine Description

    This routine queries the server role from the in memory
    variable and returns it to the caller.

  Parameters

    DomainHandle -- Describes the Domain
    ServerRole   -- Out parameter specifies the server role

  Return Values

    STATUS_SUCCESS
--*/
{
    PSAMP_OBJECT DomainContext = (PSAMP_OBJECT)DomainHandle;
    ULONG        DomainIndex;

    //
    // The SAM service must be enabled
    //

    if (SampServiceState == SampServiceTerminating)
    {

        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Reference the Context.
    //

    SampReferenceContext(DomainContext);

    DomainIndex = DomainContext->DomainIndex;

    if (IsBuiltinDomain(DomainIndex))
    {
        //
        // Make it point to the corresponding account domain
        //

        DomainIndex++;
    }

    //
    // return the server role
    //

    *ServerRole = SampDefinedDomains[DomainIndex].ServerRole;

    //
    // Dereference the context.
    //

    SampDeReferenceContext2(DomainContext,FALSE);

    return (STATUS_SUCCESS);
}

NTSTATUS
SamIQueryServerRole2(
    IN PSID DomainSid,
    OUT DOMAIN_SERVER_ROLE *ServerRole
    )
/*++

  Routine Description

    This routine queries the server role from the in memory
    variable and returns it to the caller. This is the domain
    SID version of the above call

  Parameters

    DomainSid -- Describes the Domain
    ServerRole   -- Out parameter specifies the server role

  Return Values

    STATUS_SUCCESS
--*/
{
    ULONG   DomainIndex=0;
    BOOLEAN DomainFound = FALSE;

    //
    // The SAM service must be enabled
    //

    if (SampServiceState != SampServiceEnabled)
    {

        return(STATUS_INVALID_SERVER_STATE);
    }


    for (DomainIndex=SampDsGetPrimaryDomainStart();DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid))
        {
            DomainFound = TRUE;
            break;
        }
    }

    if (!DomainFound)
    {
        return(STATUS_NO_SUCH_DOMAIN);
    }

    if (IsBuiltinDomain(DomainIndex))
    {
        //
        // Make it point to the corresponding account domain
        //

        DomainIndex++;
    }

    //
    // return the server role
    //

    *ServerRole = SampDefinedDomains[DomainIndex].ServerRole;


    return (STATUS_SUCCESS);
}


NTSTATUS SamrSetInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PSAMPR_DOMAIN_INFO_BUFFER DomainInformation
    )

/*++

Routine Description:

    This API sets the domain information to the values passed in the
    buffer.


Arguments:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DomainInformationClass - Class of information desired.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -------------------------       ----------------------------

        DomainPasswordInformation       DOMAIN_WRITE_PASSWORD_PARAMS

        DomainGeneralInformation        (not setable)

        DomainLogoffInformation         DOMAIN_WRITE_OTHER_PARAMETERS

        DomainOemInformation            DOMAIN_WRITE_OTHER_PARAMETERS

        DomainNameInformation           (Not valid for set operations.)

        DomainServerRoleInformation     DOMAIN_ADMINISTER_SERVER

        DomainReplicationInformation    DOMAIN_ADMINISTER_SERVER

        DomainModifiedInformation       (not valid for set operations)

        DomainStateInformation          DOMAIN_ADMINISTER_SERVER

        DomainUasInformation            DOMAIN_WRITE_OTHER_PARAMETERS

        DomainGeneralInformation2       (not setable)

        DomainLockoutInformation        DOMAIN_WRITE_PASSWORD_PARAMS


    DomainInformation - Buffer where the domain information can be
        found.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be disabled before role
        changes can be made.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.



--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    PSAMP_DEFINED_DOMAINS   Domain;
    BOOLEAN                 ReplicateImmediately = FALSE;
    ULONG                   DomainIndex;
    LARGE_INTEGER           PromotionIncrement = DOMAIN_PROMOTION_INCREMENT;
    

#if DBG

    LARGE_INTEGER
        TmpTime;

    TIME_FIELDS
        DT1, DT2, DT3, DT4;

#endif //DBG
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrSetInformationDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationDomain
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (DomainInformation != NULL);



    //
    // Set the desired access based upon the Info class
    //

    switch (DomainInformationClass) {

    case DomainPasswordInformation:
    case DomainLockoutInformation:

        ReplicateImmediately = TRUE;
        DesiredAccess = DOMAIN_WRITE_PASSWORD_PARAMS;
        break;


    case DomainLogoffInformation:
    case DomainOemInformation:
    case DomainUasInformation:

        DesiredAccess = DOMAIN_WRITE_OTHER_PARAMETERS;
        break;


    case DomainReplicationInformation:
    case DomainStateInformation:
    case DomainServerRoleInformation:

        DesiredAccess = DOMAIN_ADMINISTER_SERVER;
        break;


    case DomainModifiedInformation:
    case DomainNameInformation:
    case DomainGeneralInformation:
    case DomainGeneralInformation2:
    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    } // end_switch


    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DesiredAccess,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );
    
    if ( ( NtStatus == STATUS_INVALID_DOMAIN_ROLE ) &&
        ( DomainInformationClass == DomainServerRoleInformation ) ) {


        //
        // Non-trusted client isn't being allowed to write to backup
        // server.  But admin MUST be able to set the server role back
        // to primary.  So temporarily pretend that administering the
        // server isn't a write operation, just long enough for the
        // LookupContext to succeed.
        //
        // Note that before returning INVALID_DOMAIN_ROLE, LookupContext
        // verified that the caller otherwise has proper access - if the
        // caller didn't, then we would have gotten a different error.
        //

        SampObjectInformation[ SampDomainObjectType ].WriteOperations &=
            ~DOMAIN_ADMINISTER_SERVER;

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                       DomainContext,
                       DesiredAccess,
                       SampDomainObjectType,           // ExpectedType
                       &FoundType
                       );

        SampObjectInformation[ SampDomainObjectType ].WriteOperations |=
            DOMAIN_ADMINISTER_SERVER;
    }


    if (NT_SUCCESS(NtStatus)) {


        ClientRevision = DomainContext->ClientRevision;

        DomainIndex = DomainContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // case on the type information provided
        //

        switch (DomainInformationClass) {

        case DomainPasswordInformation:

            if (
                ( DomainInformation->Password.PasswordHistoryLength >
                SAMP_MAXIMUM_PASSWORD_HISTORY_LENGTH ) ||

                ( DomainInformation->Password.MinPasswordAge.QuadPart > 0) ||

                ( DomainInformation->Password.MaxPasswordAge.QuadPart > 0) ||

                ( DomainInformation->Password.MaxPasswordAge.QuadPart >=
                    DomainInformation->Password.MinPasswordAge.QuadPart) ||

                ( DomainInformation->Password.MinPasswordLength > PWLEN ) ||

                ( ( Domain->UnmodifiedFixed.UasCompatibilityRequired ) &&
                ( DomainInformation->Password.MinPasswordLength > LM20_PWLEN ) )
                ) {

                //
                // One of the following is wrong:
                //
                // 1.  The history length is larger than we can allow (and
                //     still ensure everything will fit in a string)
                // 2.  The MinPasswordAge isn't a delta time
                // 3.  The MaxPasswordAge isn't a delta time
                // 4.  The MaxPasswordAge isn't greater than the
                //     MinPasswordAge (they're negative delta times)
                // 5.  UAS compatibility is required, but MinPasswordLength
                //     is greater than LM's max password length.
                //

                NtStatus = STATUS_INVALID_PARAMETER;

            } else {

                Domain->CurrentFixed.MinPasswordLength      =
                    DomainInformation->Password.MinPasswordLength;

                Domain->CurrentFixed.PasswordHistoryLength  =
                    DomainInformation->Password.PasswordHistoryLength;

                Domain->CurrentFixed.PasswordProperties     =
                    DomainInformation->Password.PasswordProperties;

                Domain->CurrentFixed.MaxPasswordAge         =
                    DomainInformation->Password.MaxPasswordAge;

                Domain->CurrentFixed.MinPasswordAge         =
                    DomainInformation->Password.MinPasswordAge;
            }

            break;


        case DomainLogoffInformation:

            Domain->CurrentFixed.ForceLogoff    =
                DomainInformation->Logoff.ForceLogoff;

            break;

        case DomainOemInformation:

            NtStatus = SampSetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_OEM_INFORMATION,
                           (PUNICODE_STRING)&(DomainInformation->Oem.OemInformation)
                           );
            break;

        case DomainServerRoleInformation:

            //
            // Perform the role change operation
            //

            //
            // Only NTAS systems can be demoted.
            //

            if (SampProductType != NtProductLanManNt) {

                if ( (DomainInformation->Role.DomainServerRole ==
                     DomainServerRoleBackup)      //Trying to demote
                   ) {

                        NtStatus = STATUS_INVALID_DOMAIN_ROLE;
                        break;

                   }
            }

            //
            // Are we being promoted to primary?
            //

            if ( (Domain->UnmodifiedFixed.ServerRole == DomainServerRoleBackup)
                 && (DomainInformation->Role.DomainServerRole == DomainServerRolePrimary)
               )
            {

                //
                // We are a domain controller, therefore assert that we must be in DS mode
                // Member server's or workstations can never have their server role set to
                // backup, therefore the question of promoting them to domain controller never
                // arises
                //

                ASSERT(IsDsObject(Domain->Context));

                //
                // Close any Open Transactions, and release locks
                //

                IgnoreStatus = SampReleaseWriteLock(FALSE);

                ASSERT(NT_SUCCESS(IgnoreStatus));

                //
                // Do the FSMO operation to grab role ownership
                // if we are a domain controller. Note the behaviour
                // in a NT5 Domain Controller is different than that
                // of NT4, that is the promotion process will not succeed
                // if the old PDC cannot be reached.
                //


                NtStatus = SamIDoFSMORoleChange(DomainHandle);



                //
                // Grab the SAM lock again, only for de reference
                // the domain context. Because SampDeReferenceContext()
                // requires the caller holds the lock.
                //

                SampAcquireSamLockExclusive();

                // Dereference the context and return the status
                // from the FSMO operation

                SampDeReferenceContext(DomainContext,FALSE);

                //
                // Release it immediately.
                //
                SampReleaseSamLockExclusive();


                goto Error;
            }
            else
            {
                //
                // We are being demoted. This means that some one else will be promoted.
                // Just smile and say yes, but don't change anything. When the other PDC, is
                // promoted, he will come around and change our role as part of the FSMO
                // operation
                //
            }

            break;

        case DomainReplicationInformation:

            NtStatus = SampSetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_REPLICA,
                           (PUNICODE_STRING)&(DomainInformation->Replication.ReplicaSourceNodeName) // Body
                           );
            break;

        case DomainStateInformation:

            //
            // Never let anyone set a disabled state
            //

            Domain->CurrentFixed.ServerState = DomainServerEnabled;

            break;

        case DomainUasInformation:

            Domain->CurrentFixed.UasCompatibilityRequired =
                DomainInformation->General.UasCompatibilityRequired;

            break;

        case DomainLockoutInformation:

            if (
                (DomainInformation->Lockout.LockoutDuration.QuadPart >
                    DomainInformation->Lockout.LockoutObservationWindow.QuadPart ) ||

                ( DomainInformation->Lockout.LockoutDuration.QuadPart > 0) ||

                ( DomainInformation->Lockout.LockoutObservationWindow.QuadPart > 0 )


               ) {

                //
                // One of the following is wrong:
                //
                // 0.  The LockoutDuration is less than the 
                //     LockoutObservationWindows.  
                // 1.  The LockoutDuration isn't a delta time (or zero).
                // 2.  The LockoutObservationWindow isn't a delta time (or zero).
                //

                NtStatus = STATUS_INVALID_PARAMETER;

            } else {

#if DBG
                TmpTime.QuadPart = -Domain->CurrentFixed.LockoutObservationWindow.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT1 );
                TmpTime.QuadPart = -Domain->CurrentFixed.LockoutDuration.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT2 );
                TmpTime.QuadPart = -DomainInformation->Lockout.LockoutObservationWindow.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT3 );
                TmpTime.QuadPart = -DomainInformation->Lockout.LockoutDuration.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT4 );

                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("SAM: SetInformationDomain: Changing Lockout values.\n"
                                "          Old:\n"
                                "              Window   : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Duration : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Threshold: %ld\n"
                                "          New:\n"
                                "              Window   : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Duration : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Threshold: %ld\n",
                    Domain->CurrentFixed.LockoutObservationWindow.HighPart,
                    Domain->CurrentFixed.LockoutObservationWindow.LowPart,
                    DT1.Hour, DT1.Minute, DT1.Second,
                    Domain->CurrentFixed.LockoutDuration.HighPart,
                    Domain->CurrentFixed.LockoutDuration.LowPart,
                    DT2.Hour, DT2.Minute, DT2.Second,
                    Domain->CurrentFixed.LockoutThreshold,
                    DomainInformation->Lockout.LockoutObservationWindow.HighPart,
                    DomainInformation->Lockout.LockoutObservationWindow.LowPart,
                    DT3.Hour, DT3.Minute, DT3.Second,
                    DomainInformation->Lockout.LockoutDuration.HighPart,
                    DomainInformation->Lockout.LockoutDuration.LowPart,
                    DT4.Hour, DT4.Minute, DT4.Second,
                    DomainInformation->Lockout.LockoutThreshold)
                            );
#endif //DBG

                Domain->CurrentFixed.LockoutDuration      =
                    DomainInformation->Lockout.LockoutDuration;

                Domain->CurrentFixed.LockoutObservationWindow  =
                    DomainInformation->Lockout.LockoutObservationWindow;

                Domain->CurrentFixed.LockoutThreshold     =
                    DomainInformation->Lockout.LockoutThreshold;

            }

            break;
        }

        //
        // Have the changes written out to the RXACT, and
        // de-reference the object.
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampDeReferenceContext( DomainContext, TRUE );

        } else {

            IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        }
    }


    //
    // Commit changes, if successful, and notify Netlogon of changes.
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // Generate an audit if necessary
        //

        if (NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(DomainIndex)) {

            SampAuditDomainChange(
                STATUS_SUCCESS,
                Domain->Sid,
                &Domain->ExternalName,
                DomainInformationClass,
                DomainContext
                );
        }

        
        if ( NT_SUCCESS( NtStatus ) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChange,
                SecurityDbObjectSamDomain,
                0L,
                (PUNICODE_STRING) NULL,
                (DWORD) ReplicateImmediately,
                NULL            // Delta data
                );
        }
    }

    IgnoreStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationDomain
                   );

    return(NtStatus);
}


NTSTATUS
SampCreateGroupInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *GroupHandle,
    IN OUT PULONG RelativeId
    )

/*++

Routine Description:

    This API creates a new group in the account database.  Initially,
    this group does not contain any users.  Note that creating a group
    is a protected operation, and requires the DOMAIN_CREATE_GROUP
    access type.

    This call returns a handle to the newly created group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.

    A newly created group will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the group object manipulation services.


        Name - The name of the group will be as specified in the
               creation API.

        Attributes - The following attributes will be set:

                                Mandatory
                                EnabledByDefault

        MemberCount - Zero.  Initially the group has no members.

        RelativeId - will be a uniquelly allocated ID.



Arguments:


    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.


    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find a group or user with this name already defined.


    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.

    GroupHandle - Receives a handle referencing the newly created
        group.  This handle will be required in successive calls to
        operate on the group.

    RelativeId - Receives the relative ID of the newly created group
        account.  The SID of the new group account is this relative ID
        value prefixed with the domain's SID value.  This RID will be a
        new, uniquely allocated value - unless a non-zero RID was passed
        in, in which case that RID is used (nothing is done if a group
        with that RID already exists).


Return Value:

    STATUS_SUCCESS - The group was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before groups
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create group accounts.




--*/

{
    NTSTATUS                NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT            DomainContext = (PSAMP_OBJECT) DomainHandle,
                            GroupContext = NULL;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;

    ULONG                   NewAccountRid, NewSecurityDescriptorLength;
    UNICODE_STRING          KeyName;
    PSECURITY_DESCRIPTOR    NewSecurityDescriptor;
    SAMP_V1_0A_FIXED_LENGTH_GROUP  V1Fixed;
    PRIVILEGE_SET           PrivilegeSet;
    DSNAME                  *LoopbackName;
    BOOLEAN                 fLockAcquired = FALSE,
                            AccountNameDefaulted = FALSE,
                            RemoveAccountNameFromTable = FALSE;
                            
    SAMTRACE("SampCreateGroupInDomain");

    if (GroupHandle == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }

    //
    // Initialize the privilege set.
    //

    PrivilegeSet.PrivilegeCount = 0;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(0L);
    PrivilegeSet.Privilege[0].Attributes = 0;

    //
    // Make sure a name was provided. It is legal to request that the account name
    // be defaulted if this were from the DS
    //

    
    if (AccountName == NULL) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if (AccountName->Length > AccountName->MaximumLength) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if ((AccountName->Buffer == NULL ) || (AccountName->Length==0)) 
    {

        if (!LoopbackClient)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
        else
        {
            //
            // For loopback cases passing in a NULL account name
            // requests defaulting of the account name
            //

            AccountNameDefaulted = TRUE;
        }
    }
    
    

    //
    // Do WMI start type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidCreateGroupInDomain
                   );


    if ( !WriteLockHeld )  {

        NtStatus = SampMaybeAcquireWriteLock( DomainContext, &fLockAcquired );
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateGroupInDomainError;
        }
    }


    //
    // Validate the passed in Domain Handle
    //

    GroupContext = NULL;

    //
    // Non trusted clients can not create pricipals in Builtin Domain
    //

    if (IsBuiltinDomain(DomainContext->DomainIndex) &&
        !DomainContext->TrustedClient )
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto SampCreateGroupInDomainError;
    }

    //
    // Do Any access Checks
    //

    NtStatus = SampDoGroupCreationChecks(DomainContext);

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        //
        if (!AccountNameDefaulted)
        {
            //
            // Make sure the name is valid and not already in use before we
            // use it to create the new group.
            //

            NtStatus = SampValidateNewAccountName(
                             DomainContext,
                             (PUNICODE_STRING)AccountName,
                             SampGroupObjectType
                             );

            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 

            RemoveAccountNameFromTable = 
                            DomainContext->RemoveAccountNameFromTable;

            //
            // reset 
            //  
            DomainContext->RemoveAccountNameFromTable = FALSE;
        }

        if ( NT_SUCCESS(NtStatus) ) {


            if ( (*RelativeId) == 0 ) {

                //
                // No RID specified, so allocate a new (group) account RID
                //

                if (IsDsObject(DomainContext))
                {
                    // This is a DS domain, so use the multi-master RID
                    // allocator to get the next RID.

                    NtStatus = SampGetNextRid(DomainContext,
                                              &NewAccountRid);
                    SampDiagPrint(INFORM,
                                  ("SAMSS: New Group RID = %lu\n",
                                   NewAccountRid));

                    if (!NT_SUCCESS(NtStatus))
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampGetNextRid status = 0x%lx\n",
                                   NtStatus));
                    }

                }
                else
                {
                    // This is not a DS domain, use the registry RID infor-
                    // mation.

                    NewAccountRid = Domain->CurrentFixed.NextRid;
                    Domain->CurrentFixed.NextRid += 1;
                }

                (*RelativeId) = NewAccountRid;

            } else {

                //
                // A RID was passed in, so we want to use that rather than
                // selecting a new one.
                //

                ASSERT(TRUE == Domain->Context->TrustedClient);
                NewAccountRid = (*RelativeId);
            }

            SampDiagPrint(RID_TRACE,("SAMSS RID_TRACE New Rid %d\n",NewAccountRid));

            //
            // Default the account name if necessary
            //

            if ((NT_SUCCESS(NtStatus)) && (AccountNameDefaulted))
            {
                NtStatus = SampGetAccountNameFromRid(AccountName,NewAccountRid);
            }

            //
            // Check For Duplicate Sids. Currently we leave this check on in both
            // the checked as well as the free builds. Sometime in the future we can
            // remove it in the free builds
            //

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampCheckForDuplicateSids(
                                DomainContext,
                                NewAccountRid
                                );
            }

            //
            // Increment the group count ONLY in Registry case
            //

            if (NT_SUCCESS(NtStatus) && (!IsDsObject(DomainContext)) )
            {
                NtStatus = SampAdjustAccountCount(SampGroupObjectType, TRUE);
            }

            if ( !IsDsObject(Domain->Context) ) {

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Create the registry key that has the group's name.
                    // This simply serves as a name to RID mapping.  Save
                    // the name when done; we'll put it in the context.
                    //

                    NtStatus = SampBuildAccountKeyName(
                                   SampGroupObjectType,
                                   &KeyName,
                                   (PUNICODE_STRING)AccountName
                                   );



                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &KeyName,
                                       NewAccountRid,
                                       NULL,
                                       0
                                       );

                        SampFreeUnicodeString(&KeyName);
                    }
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now create a group context block
                //

                NtStatus = SampCreateAccountContext2(
                               DomainContext,
                               SampGroupObjectType,
                               NewAccountRid,
                               NULL,
                               (PUNICODE_STRING)AccountName,
                               DomainContext->ClientRevision,
                               DomainContext->TrustedClient,
                               DomainContext->LoopbackClient,
                               FALSE, // Privileged Machine account create
                               FALSE, // Account exists
                               FALSE, // Override local group check
                               &GroupType,
                               &GroupContext
                               );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // The existing reference count of 1 is for RPC.
                    // Reference the context again for the writes we're
                    // about to do to initialize it.
                    //

                    SampReferenceContext( GroupContext );

                    //
                    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
                    //

                    if (DesiredAccess & MAXIMUM_ALLOWED) {

                        DesiredAccess |= GENERIC_ALL;
                    }

                    //
                    // If ACCESS_SYSTEM_SECURITY is requested and we are
                    // a non-trusted client, check that we have
                    // SE_SECURITY_PRIVILEGE.
                    //

                    if ((DesiredAccess & ACCESS_SYSTEM_SECURITY) &&
                        (!DomainContext->TrustedClient) &&
                        (!DomainContext->LoopbackClient)) {

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                       TRUE,
                                       SE_SECURITY_PRIVILEGE,
                                       NULL
                                       );

                        if (!NT_SUCCESS(NtStatus)) {

                            if (NtStatus == STATUS_PRIVILEGE_NOT_HELD) {

                                NtStatus = STATUS_ACCESS_DENIED;
                            }

                        } else {

                            PrivilegeSet.PrivilegeCount = 1;
                            PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
                            PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
                            PrivilegeSet.Privilege[0].Attributes = 0;
                        }
                    }

                    //
                    // Make sure the caller can be given the requested access
                    // to the new object
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        GroupContext->GrantedAccess = DesiredAccess;

                        RtlMapGenericMask(
                            &GroupContext->GrantedAccess,
                            &SampObjectInformation[SampGroupObjectType].GenericMapping
                            );


                        if ((SampObjectInformation[SampGroupObjectType].InvalidMappedAccess
                            & GroupContext->GrantedAccess) != 0) {

                            NtStatus = STATUS_ACCESS_DENIED;
                        }
                    }

                }
            }



            //
            // Set the V1_fixed attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Create the V1_Fixed key
                //

                V1Fixed.RelativeId = NewAccountRid;
                V1Fixed.Attributes = (SE_GROUP_MANDATORY |
                                      SE_GROUP_ENABLED_BY_DEFAULT);
                V1Fixed.AdminCount = 0;
                V1Fixed.OperatorCount = 0;
                V1Fixed.Revision = SAMP_REVISION;

                NtStatus = SampSetFixedAttributes(
                               GroupContext,
                               (PVOID)&V1Fixed
                               );
            }


            //
            // Set the SecurityDescriptor attribute, only in the registry case
            // In the DS case the act of creating the object itself sets the
            // security descriptor on the object. The reason for this is that'
            // the security descriptor has to go through the merge process in the
            // DS and the Ace's from the parent are not inherited during a modify
            // entry
            //

            if (NT_SUCCESS(NtStatus)) {

                if (!IsDsObject(GroupContext))
                {

                      NtStatus = SampGetNewAccountSecurity(
                               SampGroupObjectType,
                               FALSE, // Not member of ADMINISTRATORS alias
                               DomainContext->TrustedClient,
                               FALSE,           //RestrictCreatorAccess
                               NewAccountRid,
                               GroupContext,
                               &NewSecurityDescriptor,
                               &NewSecurityDescriptorLength
                               );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampSetAccessAttribute(
                                        GroupContext,
                                        SAMP_GROUP_SECURITY_DESCRIPTOR,
                                        NewSecurityDescriptor,
                                        NewSecurityDescriptorLength
                                        );

                        MIDL_user_free( NewSecurityDescriptor );
                    }
                }
            }


            //
            // Set the NAME attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               GroupContext,
                               SAMP_GROUP_NAME,
                               (PUNICODE_STRING)AccountName
                               );
            }



            //
            // Set the AdminComment attribute
            //

            if ((NT_SUCCESS(NtStatus)) && !GroupContext->LoopbackClient) {

                NtStatus = SampSetUnicodeStringAttribute(
                               GroupContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               &SampNullString
                               );
            }


            //
            // Set the MEMBERS attribute (with no members)
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUlongArrayAttribute(
                               GroupContext,
                               SAMP_GROUP_MEMBERS,
                               NULL,
                               0,
                               0
                               );
            }
        }

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }
    
    
    //
    // For DS mode auditing, store the privileges on the audit notification
    //
    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(GroupContext->DomainIndex)) {
                    
        PSID GroupSid = NULL;
        
        NtStatus = SampCreateAccountSid(GroupContext, &GroupSid);
    
        if (NT_SUCCESS(NtStatus)) {
            
            NtStatus = SampAuditUpdateAuditNotificationDs(
                       SampAuditUpdateTypePrivileges,
                       GroupSid,
                       (PVOID)&PrivilegeSet
                       );
            
            MIDL_user_free(GroupSid);
        }                       
        
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateGroupInDomainError;
        }
    }


    //
    // If we created an object, dereference it.  Write out its attributes
    // if everything was created OK.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        ASSERT(GroupContext != NULL);
        NtStatus = SampDeReferenceContext( GroupContext, TRUE );

    } else {

        if (GroupContext != NULL) {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( GroupContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }


    //
    // Commit changes and notify netlogon
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (NT_SUCCESS(NtStatus)) {

            if(!IsDsObject(DomainContext))
            {
                SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                //
                // Update the display information
                //

                AccountInfo.Name = *((PUNICODE_STRING)AccountName);
                AccountInfo.Rid = NewAccountRid;
                AccountInfo.AccountControl = V1Fixed.Attributes;
                RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                IgnoreStatus = SampUpdateDisplayInformation(
                                                NULL,
                                                &AccountInfo,
                                                SampGroupObjectType
                                                );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            if (GroupContext->TypeBody.Group.SecurityEnabled)
            {
                SampNotifyNetlogonOfDelta(
                    SecurityDbNew,
                    SecurityDbObjectSamGroup,
                    *RelativeId,
                    (PUNICODE_STRING) NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );
            }

            //
            // Generate Audit
            //

            if (SampDoAccountAuditing(DomainContext->DomainIndex)) {

                GROUP_INFORMATION_CLASS InfoClass = GroupNameInformation;
                
                SampAuditGroupChange(GroupContext->DomainIndex,
                                     GroupContext,
                                     (PVOID)&InfoClass,
                                     FALSE,   // Group not alias
                                     (PUNICODE_STRING) AccountName,     
                                     &GroupContext->TypeBody.Group.Rid, 
                                     GroupType,
                                     &PrivilegeSet,                      
                                     TRUE     // Group creation           
                                     );
            }
        }
    }

    //
    // Return the context handle on success
    // Delete the context block and return a NULL handle on failure
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(GroupContext != NULL);
        (*GroupHandle) = GroupContext;

    } else {

        if (GroupContext != NULL) {
            SampDeleteContext(GroupContext);
        }

        (*GroupHandle) = (SAMPR_HANDLE)0;
    }

SampCreateGroupInDomainError:

    //
    // cleanup the account name table
    // 

    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)AccountName,
                            SampGroupObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if ((AccountNameDefaulted) && (NULL!=AccountName->Buffer))
    {
        MIDL_user_free(AccountName->Buffer);
    }

    //
    // Release the lock
    //

    if ( (!WriteLockHeld) ) {
        IgnoreStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Do a WMI end type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidCreateGroupInDomain
                   );

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}


NTSTATUS
SamrCreateGroupInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *GroupHandle,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateGroupInDomain() that ensures that
    RelativeId points to a RID of zero first.

    A non-zero RID means that SampCreateGroupInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateGroupInDomain().

Return Values:

    Same as SampCreateGroupInDomain().

--*/

{
    NTSTATUS NtStatus;
    ULONG    GroupType =  GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_ACCOUNT_GROUP;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateGroupInDomain");

    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==GroupHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    NtStatus = SampCreateGroupInDomain(
                   DomainHandle,
                   AccountName,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   GroupType,
                   GroupHandle,
                   RelativeId
                   );

Error:

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return( NtStatus );
}



NTSTATUS SamrEnumerateGroupsInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the groups defined in the account database.
    Since there may be more groups than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the context becomes invalid for
    future use.

    This API requires DOMAIN_LIST_GROUPS access to the Domain object.

Arguments:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see below).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{

    NTSTATUS                    NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrEnumerateGroupsInDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateGroupsInDomain
                   );

    NtStatus = SampEnumerateAccountNamesCommon(
                  DomainHandle,
                  SampGroupObjectType,
                  EnumerationContext,
                  Buffer,
                  PreferedMaximumLength,
                  0L,  // no filter
                  CountReturned
                  );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateGroupsInDomain
                   );

    return(NtStatus);

}



NTSTATUS
SampCreateAliasInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *AliasHandle,
    IN OUT PULONG RelativeId
    )

/*++

Routine Description:

    This API creates a new alias in the account database.  Initially,
    this alias does not contain any users.  Note that creating a alias
    is a protected operation, and requires the DOMAIN_CREATE_ALIAS
    access type.

    This call returns a handle to the newly created alias that may be
    used for successive operations on the alias.  This handle may be
    closed with the SamCloseHandle API.

    A newly created alias will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the alias object manipulation services.


        Name - The name of the alias will be as specified in the
               creation API.

        MemberCount - Zero.  Initially the alias has no members.

        RelativeId - will be a uniquelly allocated ID.



Arguments:


    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.


    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find an alias or user with this name already defined.


    DesiredAccess - Is an access mask indicating which access types
        are desired to the alias.

    AliasHandle - Receives a handle referencing the newly created
        alias.  This handle will be required in successive calls to
        operate on the alias.

    RelativeId - Receives the relative ID of the newly created alias
        account.  The SID of the new alias account is this relative
        ID value prefixed with the domain's SID value.



Return Value:

    STATUS_SUCCESS - The alias was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before aliases
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create alias accounts.



--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT            DomainContext = (PSAMP_OBJECT) DomainHandle, 
                            AliasContext = NULL;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   NewAccountRid, NewSecurityDescriptorLength;
    UNICODE_STRING          KeyName;
    PSECURITY_DESCRIPTOR    NewSecurityDescriptor;
    SAMP_V1_FIXED_LENGTH_ALIAS V1Fixed;
    PRIVILEGE_SET           Privileges;
    DSNAME                  *LoopbackName;
    BOOLEAN                 fLockAcquired = FALSE,
                            AccountNameDefaulted = FALSE,
                            RemoveAccountNameFromTable = FALSE;

    SAMTRACE_EX("SampCreateAliasInDomain");

    if (AliasHandle == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize the privilege set.
    //

    Privileges.PrivilegeCount = 0;
    Privileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privileges.Privilege[0].Luid = RtlConvertLongToLuid(0L);
    Privileges.Privilege[0].Attributes = 0;

    //
    // Make sure a name was provided
    //

    
    if (AccountName == NULL) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if (AccountName->Length > AccountName->MaximumLength) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if ((AccountName->Buffer == NULL ) || (AccountName->Length==0)) 
    {

        if (!LoopbackClient)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
        else
        {
            //
            // For loopback cases passing in a NULL account name
            // requests defaulting of the account name
            //

            AccountNameDefaulted = TRUE;
        }
    }
    
    //
    // Do a start type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidCreateAliasInDomain
                   );


    if ( !WriteLockHeld ) {

        NtStatus = SampMaybeAcquireWriteLock(DomainContext, &fLockAcquired);
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateAliasInDomainError;
        }
    }


    //
    // Validate the domain handle
    //

    AliasContext = NULL;

    //
    // Non trusted clients can not create pricipals in Builtin Domain
    //

    if (IsBuiltinDomain(DomainContext->DomainIndex) &&
        !DomainContext->TrustedClient )
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto SampCreateAliasInDomainError;
    }

    //
    // Perform Any Access Checks
    //

    NtStatus = SampDoAliasCreationChecks(DomainContext);




    if (NT_SUCCESS(NtStatus)) {


        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        if (!AccountNameDefaulted)
        {
            //
            // Make sure the name is valid and not already in use before we
            // use it to create the new alias.
            //

            NtStatus = SampValidateNewAccountName(
                            DomainContext,
                            (PUNICODE_STRING)AccountName,
                            SampAliasObjectType
                            );
            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 

            RemoveAccountNameFromTable = 
                            DomainContext->RemoveAccountNameFromTable;

            //
            // reset 
            //  
            DomainContext->RemoveAccountNameFromTable = FALSE;
        }

        if ( NT_SUCCESS(NtStatus) ) {


            if ( (*RelativeId) == 0 ) {

                //
                // Allocate a new (alias) account RID
                //

                if (IsDsObject(DomainContext))
                {
                    // This is a DS domain, so use the multi-master RID
                    // allocator to get the next RID.

                    NtStatus = SampGetNextRid(DomainContext,
                                              &NewAccountRid);
                    SampDiagPrint(INFORM,
                                  ("SAMSS: New Alias RID = %lu\n",
                                   NewAccountRid));

                    if (!NT_SUCCESS(NtStatus))
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampGetNextRid status = 0x%lx\n",
                                   NtStatus));
                    }

                }
                else
                {
                    // This is not a DS domain, use the registry RID infor-
                    // mation.

                    NewAccountRid = Domain->CurrentFixed.NextRid;
                    Domain->CurrentFixed.NextRid += 1;
                }

                (*RelativeId) = NewAccountRid;

            } else {

                //
                // Use the RID that was passed in.
                //

                ASSERT(TRUE == Domain->Context->TrustedClient);
                NewAccountRid = (*RelativeId);
            }

            SampDiagPrint(RID_TRACE,("SAMSS RID_TRACE New Rid %d\n",NewAccountRid));


            if ((NT_SUCCESS(NtStatus)) && (AccountNameDefaulted))
            {
                NtStatus = SampGetAccountNameFromRid(AccountName,NewAccountRid);
            }

            //
            // Check For Duplicate Sids. Currently we leave this check on in both
            // the checked as well as the free builds. Sometime in the future we can
            // remove it in the free builds
            //

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampCheckForDuplicateSids(
                                DomainContext,
                                NewAccountRid
                                );
            }

            //
            // Increment the alias count ONLY in Registry case.
            //

            if (NT_SUCCESS(NtStatus) && (!IsDsObject(DomainContext)) )
            {
                NtStatus = SampAdjustAccountCount(SampAliasObjectType, TRUE);
            }


            if ( !IsDsObject(Domain->Context)) {

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Create the registry key that has the alias's name.
                    // This simply serves as a name to RID mapping.  Save
                    // the name when done; we'll put it in the context.
                    //

                    NtStatus = SampBuildAccountKeyName(
                                   SampAliasObjectType,
                                   &KeyName,
                                   (PUNICODE_STRING)AccountName
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &KeyName,
                                       NewAccountRid,
                                       NULL,
                                       0
                                       );

                        SampFreeUnicodeString(&KeyName);
                    }
                }

            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now create an alias context block
                //

                NtStatus = SampCreateAccountContext2(
                                   DomainContext,
                                   SampAliasObjectType,
                                   NewAccountRid,
                                   NULL,
                                   (PUNICODE_STRING)AccountName,
                                   DomainContext->ClientRevision,
                                   DomainContext->TrustedClient,
                                   DomainContext->LoopbackClient,
                                   FALSE,  // Privileged Machine Account Create
                                   FALSE,  // Account exists
                                   FALSE,  // Override Local Group Check
                                   &GroupType,
                                   &AliasContext
                                   );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // The existing reference count of 1 is for RPC.
                    // Reference the context again for the writes we're
                    // about to do to initialize it.
                    //

                    SampReferenceContext( AliasContext );

                    //
                    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
                    //

                    if (DesiredAccess & MAXIMUM_ALLOWED) {

                        DesiredAccess |= GENERIC_ALL;
                    }

                    //
                    // If ACCESS_SYSTEM_SECURITY is requested and we are
                    // a non-trusted client, check that we have
                    // SE_SECURITY_PRIVILEGE.
                    //

                    if ((DesiredAccess & ACCESS_SYSTEM_SECURITY) &&
                        (!DomainContext->TrustedClient) &&
                        (!DomainContext->LoopbackClient)) {

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                       TRUE,
                                       SE_SECURITY_PRIVILEGE,
                                       NULL
                                       );

                        if (!NT_SUCCESS(NtStatus)) {

                            if (NtStatus == STATUS_PRIVILEGE_NOT_HELD) {

                                NtStatus = STATUS_ACCESS_DENIED;
                            }

                        } else {

                            Privileges.PrivilegeCount = 1;
                            Privileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
                            Privileges.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
                            Privileges.Privilege[0].Attributes = 0;
                        }
                    }

                    //
                    // Make sure the caller can be given the requested access
                    // to the new object
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        AliasContext->GrantedAccess = DesiredAccess;

                        RtlMapGenericMask(
                            &AliasContext->GrantedAccess,
                            &SampObjectInformation[SampAliasObjectType].GenericMapping
                            );


                        if ((SampObjectInformation[SampAliasObjectType].InvalidMappedAccess &
                            AliasContext->GrantedAccess) != 0) {
                            NtStatus = STATUS_ACCESS_DENIED;
                        }
                    }

                }
            }


            //
            // Set the V1_fixed attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                V1Fixed.RelativeId = NewAccountRid;

                NtStatus = SampSetFixedAttributes(
                               AliasContext,
                               (PVOID )&V1Fixed
                               );
            }

            //
            // Set the SECURITY DESCRIPTOR attribute
            //
            // Set the SecurityDescriptor attribute, only in the registry case
                        // In the DS case the act of creating the object itself sets the
                        // security descriptor on the object. The reason for this is that'
                        // the security descriptor has to go through the merge process in the
                        // DS and the Ace's from the parent are not inherited during a modify
                        // entry
            //

            if (NT_SUCCESS(NtStatus)) {

                                if (!IsDsObject(DomainContext))
                                {
                                        NtStatus = SampGetNewAccountSecurity(
                                                                   SampAliasObjectType,
                                                                   FALSE, // Not member of ADMINISTRATORS alias
                                                                   DomainContext->TrustedClient,
                                                                   FALSE,           //RestrictCreatorAccess
                                                                   NewAccountRid,
                                                                   AliasContext,
                                                                   &NewSecurityDescriptor,
                                                                   &NewSecurityDescriptorLength
                                                                   );

                                        if (NT_SUCCESS(NtStatus)) {

                                                NtStatus = SampSetAccessAttribute(
                                                                           AliasContext,
                                                                           SAMP_ALIAS_SECURITY_DESCRIPTOR,
                                                                           NewSecurityDescriptor,
                                                                           NewSecurityDescriptorLength
                                                                           );

                                                MIDL_user_free( NewSecurityDescriptor );
                                        }
                                }
                        }


            //
            // Set the NAME attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               AliasContext,
                               SAMP_ALIAS_NAME,
                               (PUNICODE_STRING)AccountName
                               );
            }


            //
            // Set the AdminComment attribute
            //

            if ((NT_SUCCESS(NtStatus)) && !AliasContext->LoopbackClient) {

                NtStatus = SampSetUnicodeStringAttribute(
                               AliasContext,
                               SAMP_ALIAS_ADMIN_COMMENT,
                               &SampNullString
                               );
            }


            //
            // Set the MEMBERS attribute (with no members)
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUlongArrayAttribute(
                               AliasContext,
                               SAMP_ALIAS_MEMBERS,
                               NULL,
                               0,
                               0
                               );
            }
        }


        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }
    
    //
    // For DS mode auditing, store the privileges on the notification
    //
    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(AliasContext->DomainIndex)) {
                
        PSID AliasSid = NULL;
        
        NtStatus = SampCreateAccountSid(AliasContext, &AliasSid);
    
        if (NT_SUCCESS(NtStatus)) {
            
            NtStatus = SampAuditUpdateAuditNotificationDs(
                       SampAuditUpdateTypePrivileges,
                       AliasSid,
                       (PVOID)&Privileges
                       );
            
            MIDL_user_free(AliasSid);
        }                       
        
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateAliasInDomainError;
        }                                
    }      

    //
    // If we created an object, dereference it.  Write out its attributes
    // if everything was created OK.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        ASSERT(AliasContext != NULL);
        NtStatus = SampDeReferenceContext( AliasContext, TRUE );

    } else {

        if (AliasContext != NULL) {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AliasContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }



    //
    // Commit changes and notify netlogon
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (NT_SUCCESS(NtStatus)) {

            if (AliasContext->TypeBody.Alias.SecurityEnabled)
            {
                SampNotifyNetlogonOfDelta(
                    SecurityDbNew,
                    SecurityDbObjectSamAlias,
                    *RelativeId,
                    (PUNICODE_STRING) NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );
            }

            //
            // Generate audit here for local group creation
            // here.
            //

            if (SampDoAccountAuditing(DomainContext->DomainIndex)) {

                ALIAS_INFORMATION_CLASS InfoClass = AliasNameInformation;
                
                SampAuditGroupChange(AliasContext->DomainIndex,
                                     AliasContext,
                                     (PVOID)&InfoClass,
                                     TRUE,
                                     (PUNICODE_STRING) AccountName,     
                                     &AliasContext->TypeBody.Alias.Rid, 
                                     GroupType,
                                     &Privileges,                      
                                     TRUE     // Group creation           
                                     );
            }
        }
    }

    //
    // Return the context handle on success
    // Delete the context block and return a NULL handle on failure
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(AliasContext != NULL);
        (*AliasHandle) = AliasContext;

    } else {

        if (AliasContext != NULL) {
            SampDeleteContext(AliasContext);
        }

        (*AliasHandle) = (SAMPR_HANDLE)0;
    }

SampCreateAliasInDomainError:

    //
    // clean up the account name table
    // 
    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)AccountName,
                            SampAliasObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        RemoveAccountNameFromTable = FALSE;
    }

    if ((AccountNameDefaulted) && (NULL!=AccountName->Buffer))
    {
        MIDL_user_free(AccountName->Buffer);
    }


    //
    // Release the lock
    //

    if ( (!WriteLockHeld) ) {
        IgnoreStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Do a End type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidCreateAliasInDomain
                   );

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}



NTSTATUS
SamrCreateAliasInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *AliasHandle,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateAliasInDomain() that ensures that
    RelativeId points to a RID of zero first.

    A non-zero RID means that SampCreateAliasInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateAliasInDomain().

Return Values:

    Same as SampCreateAliasInDomain().

--*/

{
    NTSTATUS NtStatus;
    ULONG    GroupType = GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_RESOURCE_GROUP;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateAliasInDomain");

    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==AliasHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    NtStatus = SampCreateAliasInDomain(
                   DomainHandle,
                   AccountName,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   GroupType,
                   AliasHandle,
                   RelativeId
                   );
Error:

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return( NtStatus );
}



NTSTATUS SamrEnumerateAliasesInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the aliases defined in the account database.
    Since there may be more aliass than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the context becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ALIASES access to the Domain object.

Arguments:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see below).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{

    NTSTATUS NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrEnumerateAliasesInDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateAliasesInDomain
                   );

    NtStatus = SampEnumerateAccountNamesCommon(
                  DomainHandle,
                  SampAliasObjectType,
                  EnumerationContext,
                  Buffer,
                  PreferedMaximumLength,
                  0L, // no filter
                  CountReturned
                  );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateAliasesInDomain
                   );

    return(NtStatus);

}



NTSTATUS SamrRemoveMemberFromForeignDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_SID MemberId
    )

/*++

Routine Description:

    This routine removes an account (group or user) from all aliases in
    the given domain.  It is meant to be called in domains OTHER than
    domain in which the account was created.

    This is typically called just before deleting the account from the
    domain in which it was created.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    MemberId - The SID of the account being removed.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_SPECIAL_ACCOUNT - This operation may not be performed on
        builtin accounts.


--*/

{
    NTSTATUS         NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;
    PSAMP_OBJECT     DomainContext = NULL;
    PULONG           Membership = NULL;
    PSID             DomainSid = NULL;
    ULONG            MembershipCount, MemberRid, i;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrRemoveMemberFromForiegnDomain");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidRemoveMemberFromForeignDomain
                   );

    if (!RtlValidSid(MemberId))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // Validate type of, and access to domain object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,                   // DesiredAccess
                   SampDomainObjectType,            // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Remove Member from Foriegn Domain Is Called by the Net API to
        // remove memberships from the aliases in the builtin domain while
        // deleting users or groups. This functionality is not required in
        // the DS case, because the Link Table maintains consistency automatically
        // Therefore Do Nothing and Just Return a Status Success.
        //

        if (IsDsObject(DomainContext))
        {
            NtStatus = STATUS_SUCCESS;
            SampDeReferenceContext(DomainContext,FALSE);
            goto Finish;
        }

        if ( !DomainContext->TrustedClient ) {

            //
            // Return error if the SID passed in is for a builtin account.
            // This may seem overly restrictive, but this API is meant to
            // be called before deleting a user, and since deleting
            // builtin accounts isn't allowed, it makes sense for this to
            // fail too.
            //

            NtStatus = SampSplitSid(
                           MemberId,
                           &DomainSid,
                           &MemberRid );

            if ( NT_SUCCESS( NtStatus ) ) {

                MIDL_user_free( DomainSid );
                DomainSid = NULL;

                NtStatus = SampIsAccountBuiltIn( MemberRid );
            }
        }

        if (NT_SUCCESS(NtStatus)) {

             NtStatus = SampRemoveAccountFromAllAliases(
                            MemberId,
                            NULL,
                            TRUE,    // verify caller is allowed to do this
                            DomainHandle,
                            &MembershipCount,
                            &Membership
                            );

        }

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
    }

    if (NT_SUCCESS(NtStatus)) {

        IgnoreStatus = STATUS_SUCCESS;

        for ( i = 0;
            ( ( i < MembershipCount ) && ( NT_SUCCESS( IgnoreStatus ) ) );
            i++ ) {

            //
            // Notify netlogon once for each alias that the account was
            // removed from.  Netlogon requires that ModifiedCount be
            // incremented each time; Commit increments ModifiedCount,
            // so we do each notification after a commit.
            //

            NtStatus = SampCommitAndRetainWriteLock();
            if (!NT_SUCCESS(NtStatus))
            {
                goto Finish;
            }

            if ( i == 0 ) {

                //
                // The first commit is the one that commits all the
                // important changes, so we'll save it's status to return
                // to the caller.
                //

                NtStatus = IgnoreStatus;

                //
                // Update the Cached Alias Information if necessary in Registry Mode.
                // In DS Mode, we can invalidate Alias Information by SampNotifyRepicatedInChange
                //

                if (!IsDsObject(DomainContext))
                {
                    IgnoreStatus = SampAlRemoveAccountFromAllAliases(
                                       MemberId,
                                       FALSE,
                                       DomainHandle,
                                       NULL,
                                       NULL
                                       );
                }
            }

            if ( NT_SUCCESS( IgnoreStatus ) ) {

                //
                // Notify if we were able to increment the modified count
                // (which is done by SampCommitAndRetainWriteLock()).
                //

                SAM_DELTA_DATA DeltaData;

                //
                // Fill in id of member being removed
                //

                DeltaData.AliasMemberId.MemberSid = MemberId;

                SampNotifyNetlogonOfDelta(
                    SecurityDbChangeMemberDel,
                    SecurityDbObjectSamAlias,
                    Membership[i],
                    (PUNICODE_STRING) NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    &DeltaData
                    );
            }
        }
    }


Finish:

    if ( Membership != NULL ) {

        MIDL_user_free( Membership );
    }



    IgnoreStatus = SampReleaseWriteLock( FALSE );

    SAMTRACE_RETURN_CODE_EX(NtStatus);
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromForeignDomain
                   );

    return( NtStatus );
}


NTSTATUS
SampCreateUserInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG GrantedAccess,
    IN OUT PULONG RelativeId
    )

/*++

Routine Description:

    This API adds a new user to the account database.  The account is
    created in a disabled state.  Default information is assigned to all
    fields except the account name.  A password must be provided before
    the account may be enabled, unless the PasswordNotRequired control
    field is set.

    This api may be used in either of two ways:

        1) An administrative utility may use this api to create
           any type of user account.  In this case, the DomainHandle
           is expected to be open for DOMAIN_CREATE_USER access.

        2) A non-administrative user may use this api to create
           a machine account.  In this case, the caller is expected
           to have the SE_CREATE_MACHINE_ACCOUNT_PRIV privilege
           and the DomainHandle is expected to be open for DOMAIN_LOOKUP
           access.


    For the normal administrative model ( #1 above), the creator will
    be assigned as the owner of the created user account.  Furthermore,
    the new account will be give USER_WRITE access to itself.

    For the special machine-account creation model (#2 above), the
    "Administrators" will be assigned as the owner of the account.
    Furthermore, the new account will be given NO access to itself.
    Instead, the creator of the account will be give USER_WRITE and
    DELETE access to the account.


    This call returns a handle to the newly created user that may be
    used for successive operations on the user.  This handle may be
    closed with the SamCloseHandle() API.  If a machine account is
    being created using model #2 above, then this handle will have
    only USER_WRITE and DELETE access.  Otherwise, it will be open
    for USER_ALL_ACCESS.


    A newly created user will automatically be made a member of the
    DOMAIN_USERS group.

    A newly created user will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the user object manipulation services.

        UserName - the name of the account will be as specified in the
             creation API.

        FullName - will be null.

        UserComment - will be null.

        Parameters - will be null.

        CountryCode - will be zero.

        UserId - will be a uniquelly allocated ID.

        PrimaryGroupId - Will be DOMAIN_USERS.

        PasswordLastSet - will be the time the account was created.

        HomeDirectory - will be null.

        HomeDirectoryDrive - will be null.

        UserAccountControl - will have the following flags set:

              UserAccountDisable,
              UserPasswordNotRequired,
              and the passed account type.


        ScriptPath - will be null.

        WorkStations - will be null.

        CaseInsensitiveDbcs - will be null.

        CaseSensitiveUnicode - will be null.

        LastLogon - will be zero delta time.

        LastLogoff - will be zero delta time

        AccountExpires - will be very far into the future.

        BadPasswordCount - will be negative 1 (-1).

        LastBadPasswordTime - will be SampHasNeverTime ( [High,Low] = [0,0] ).

        LogonCount - will be negative 1 (-1).

        AdminCount - will be zero.

        AdminComment - will be null.

        Password - will be "".


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find a group or user with this name already defined.

    AccountType - Indicates what type of account is being created.
        Exactly one account type must be provided:

              USER_INTERDOMAIN_TRUST_ACCOUNT
              USER_WORKSTATION_TRUST_ACCOUNT
              USER_SERVER_TRUST_ACCOUNT
              USER_TEMP_DUPLICATE_ACCOUNT
              USER_NORMAL_ACCOUNT
              USER_MACHINE_ACCOUNT_MASK


    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.

    UserHandle - Receives a handle referencing the newly created
        user.  This handle will be required in successive calls to
        operate on the user.

    GrantedAccess - Receives the accesses actually granted to via
        the UserHandle.

    RelativeId - Receives the relative ID of the newly created user
        account.  The SID of the new user account is this relative ID
        value prefixed with the domain's SID value.



Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before users
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create user accounts.



--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext = (PSAMP_OBJECT)DomainHandle,
        UserContext,
        GroupContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain = NULL;

    SAMP_V1_0A_FIXED_LENGTH_GROUP
        GroupV1Fixed;

    ULONG
        DomainIndex = 0,
        NewAccountRid = 0,
        NewSecurityDescriptorLength;

    UNICODE_STRING
        KeyName;

    PSECURITY_DESCRIPTOR
        NewSecurityDescriptor;

    SAMP_V1_0A_FIXED_LENGTH_USER
        V1aFixed;

    GROUP_MEMBERSHIP
        DomainUsersMember;

    BOOLEAN
        DomainPasswordInformationAccessible = FALSE,
        PrivilegedMachineAccountCreate = FALSE,
        CanSetPasswordNotRequiredBit = TRUE,
        LockAttempted = FALSE,
        AccountNameDefaulted = FALSE,
        RemoveAccountNameFromTable = FALSE;

    PRIVILEGE_SET
        Privileges;

    PPRIVILEGE_SET
        PPrivileges = NULL;     // No privileges in audit by default


    ACCESS_MASK
        AccessRestriction = USER_ALL_ACCESS |
                            ACCESS_SYSTEM_SECURITY;  // No access restrictions by default

    DSNAME  *LoopbackName;
    UNICODE_STRING  TempString;

    SAMTRACE("SampCreateUserInDomain");



    DomainUsersMember.RelativeId = DOMAIN_GROUP_RID_USERS;
    DomainUsersMember.Attributes = (SE_GROUP_MANDATORY |
                                    SE_GROUP_ENABLED |
                                    SE_GROUP_ENABLED_BY_DEFAULT);


    if (UserHandle == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure a name was provided
    //

    
    if (AccountName == NULL) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if (AccountName->Length > AccountName->MaximumLength) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if ((AccountName->Buffer == NULL) || (AccountName->Length==0)) 
    {

        if (!LoopbackClient)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
        else
        {
            //
            // For loopback cases passing in a NULL account name
            // requests defaulting of the account name
            //

            AccountNameDefaulted = TRUE;
        }
    }
    

    //
    // do a WMI event (start) trace. don't forget do a END type event trace
    // at the end of this routine.
    //

    if (AccountType & USER_MACHINE_ACCOUNT_MASK)
    {
        SampTraceEvent(EVENT_TRACE_TYPE_START,
                       SampGuidCreateComputerInDomain
                       );
    }
    else
    {
        SampTraceEvent(EVENT_TRACE_TYPE_START,
                       SampGuidCreateUserInDomain
                       );
    }

    SampUpdatePerformanceCounters(
        ( AccountType & USER_MACHINE_ACCOUNT_MASK ) ?
            DSSTAT_CREATEMACHINETRIES :
            DSSTAT_CREATEUSERTRIES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    if ( !WriteLockHeld ) {

        NtStatus = SampMaybeAcquireWriteLock(DomainContext, &LockAttempted);
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateUserInDomainError;
        }
    }


    //
    // Validate the handle to the Domain Object that is passed in by the client.
    // We do different access checks depending upon DS mode or registry mode. In
    // DS mode we do not require create access on the Domain Handle, but rather let
    // the DS do the access check. In Registry Mode we will do access checks , just
    // the way NT4 Sam used to do access checks
    //

    UserContext = NULL;

    //
    // Non trusted clients can not create pricipals in Builtin Domain
    //

    if (IsBuiltinDomain(DomainContext->DomainIndex) &&
        !DomainContext->TrustedClient )
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto SampCreateUserInDomainError;
    }

    //
    // This is a valid Context handle. Do appropriate access checks
    //

    NtStatus = SampDoUserCreationChecks(
                DomainContext,
                AccountType,
                &PrivilegedMachineAccountCreate,
                &AccessRestriction
                );

    if (NT_SUCCESS(NtStatus)) {

        //
        // If the domain handle allows reading the password parameters,
        // note that now (best to call LookupContext early because of
        // side effects; data will be copied to the user's context later)
        // to make life easy for SampGetUserDomainPasswordInformation().
        //

        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext conditionally.
        // 
        IgnoreStatus = SampLookupContext(
                           DomainHandle,
                           DOMAIN_READ_PASSWORD_PARAMETERS, // DesiredAccess
                           SampDomainObjectType,            // ExpectedType
                           &FoundType
                           );

        if ( NT_SUCCESS( IgnoreStatus ) ) {

            DomainIndex = DomainContext->DomainIndex;

            DomainPasswordInformationAccessible = TRUE;

            IgnoreStatus = SampDeReferenceContext( DomainHandle, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }


        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        if (!AccountNameDefaulted)
        {
            //
            // Make sure the name is valid and not already in use before we
            // use it to create the new alias.
            //

            NtStatus = SampValidateNewAccountName(
                        DomainContext,
                        (PUNICODE_STRING)AccountName,
                        SampUserObjectType
                        );

            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 

            RemoveAccountNameFromTable = 
                            DomainContext->RemoveAccountNameFromTable;

            //
            // reset 
            //  
            DomainContext->RemoveAccountNameFromTable = FALSE;
        }


        if ( NT_SUCCESS(NtStatus) ) {

            if ( (*RelativeId) == 0 ) {

                //
                // Allocate a new (user) account RID
                //

                if (IsDsObject(DomainContext))
                {
                    // This is a DS domain, so use the multi-master RID
                    // allocator to get the next RID.

                    NtStatus = SampGetNextRid(DomainContext,
                                              &(NewAccountRid));
                    SampDiagPrint(INFORM,
                                  ("SAMSS: New User RID = %lu\n",
                                   NewAccountRid));

                    if (!NT_SUCCESS(NtStatus))
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampGetNextRid status = 0x%lx\n",
                                   NtStatus));
                    }

                }
                else
                {
                    // This is not a DS domain, use the registry RID infor-
                    // mation.

                    NewAccountRid = Domain->CurrentFixed.NextRid;
                    Domain->CurrentFixed.NextRid += 1;
                }

                (*RelativeId) = NewAccountRid;

            } else {

                //
                // A RID was passed in, so we want to use that rather than
                // select a new one.
                //

                ASSERT(TRUE == Domain->Context->TrustedClient);
                NewAccountRid = (*RelativeId);
            }

            SampDiagPrint(RID_TRACE,("SAMSS RID_TRACE New Rid %d\n",NewAccountRid));

            if ((NT_SUCCESS(NtStatus)) && (AccountNameDefaulted))
            {
                NtStatus = SampGetAccountNameFromRid(AccountName,NewAccountRid);
            }

            //
            // Check For Duplicate Sids. Currently we leave this check on in both
            // the checked as well as the free builds. Sometime in the future we can
            // remove it in the free builds
            //

            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampCheckForDuplicateSids(
                                DomainContext,
                                NewAccountRid
                                );
            }

            //
            // Increment the User count ONLY in Registry case
            //

            if (NT_SUCCESS(NtStatus) && (!IsDsObject(DomainContext)) )
            {
                NtStatus = SampAdjustAccountCount(SampUserObjectType, TRUE);
            }

            if ( !IsDsObject(Domain->Context) ) {

                if (NT_SUCCESS(NtStatus)) {

                //
                // Create the registry key that has the User's name.
                // This simply serves as a name to RID mapping.  Save
                // the name when finished; we'll put it in the context.
                //

                    NtStatus = SampBuildAccountKeyName(
                                   SampUserObjectType,
                                   &KeyName,
                                   (PUNICODE_STRING)AccountName
                                   );



                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &KeyName,
                                       NewAccountRid,
                                       NULL,
                                       0
                                       );

                        SampFreeUnicodeString(&KeyName);
                    }
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now create a User context block
                //

                NtStatus = SampCreateAccountContext2(
                                   DomainContext,
                                   SampUserObjectType,
                                   NewAccountRid,
                                   &AccountType,
                                   (PUNICODE_STRING)AccountName,
                                   DomainContext->ClientRevision,
                                   DomainContext->TrustedClient,
                                   DomainContext->LoopbackClient,
                                   PrivilegedMachineAccountCreate,
                                   FALSE, // Account exists
                                   FALSE, // Override Local Group Check
                                   NULL,
                                   &UserContext
                                   );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // The existing reference count of 1 is for RPC.
                    // Reference the context again for the writes we're
                    // about to do to initialize it.
                    //

                    SampReferenceContext( UserContext );

                    //
                    // Stash away the password info accessible flag
                    //

                    UserContext->TypeBody.User.DomainPasswordInformationAccessible =
                        DomainPasswordInformationAccessible;

                    //
                    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
                    //

                    if (DesiredAccess & MAXIMUM_ALLOWED) {

                        DesiredAccess |= GENERIC_ALL;
                    }

                    //
                    // If ACCESS_SYSTEM_SECURITY is requested and we are
                    // a non-trusted client, check that we have
                    // SE_SECURITY_PRIVILEGE.
                    //

                    if ((DesiredAccess & ACCESS_SYSTEM_SECURITY) &&
                        (!DomainContext->TrustedClient)&&
                        (!DomainContext->LoopbackClient)) {

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                       TRUE,
                                       SE_SECURITY_PRIVILEGE,
                                       NULL
                                       );

                        if (!NT_SUCCESS(NtStatus)) {

                            if (NtStatus == STATUS_PRIVILEGE_NOT_HELD) {

                                NtStatus = STATUS_ACCESS_DENIED;
                            }
                        }
                    }

                    //
                    // Make sure the caller can be given the requested access
                    // to the new object
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        UserContext->GrantedAccess = DesiredAccess;

                        RtlMapGenericMask(
                            &UserContext->GrantedAccess,
                            &SampObjectInformation[SampUserObjectType].GenericMapping
                            );

                        //
                        // Grant the attribute level rights
                        //
                        SampNt4AccessToWritableAttributes(SampUserObjectType,
                                                          UserContext->GrantedAccess,
                                                         &UserContext->WriteGrantedAccessAttributes);


                        if ((SampObjectInformation[SampUserObjectType].InvalidMappedAccess
                            & UserContext->GrantedAccess) != 0) {

                            NtStatus = STATUS_ACCESS_DENIED;
                        } else {

                            //
                            // Restrict access if necessary
                            //

                            UserContext->GrantedAccess &= AccessRestriction;
                            (*GrantedAccess) = UserContext->GrantedAccess;
                        }
                    }

                }
            }

            //
            // If the GROUP we're going to put this user in
            // is part of an ADMIN alias, we must set the ACL
            // on this user account to disallow access by
            // account operators.  Get group info to determine
            // whether it's in an ADMIN alias or not. DS mode does not
            // require any special ACLs based on Admin or Non Admin. Therefore
            // this operation need not be performed on DS mode and the
            // the CreateAccountContext call can be saved.
            //


            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(DomainContext))) {

                NtStatus = SampCreateAccountContext(
                                   SampGroupObjectType,
                                   DOMAIN_GROUP_RID_USERS,
                                   TRUE, // TrustedClient,
                                   FALSE,// Loopback Client
                                   TRUE, // Account exists
                                   &GroupContext
                                   );

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = SampRetrieveGroupV1Fixed(
                                   GroupContext,
                                   &GroupV1Fixed
                                   );

                    SampDeleteContext(GroupContext);
                }
            }


            //
            // check if the client can set USER_PASSWORD_NOT_REQUIRED bit  
            // 
            // 1. in REGISTRY mode, (or trusted) client can always set this
            //    flag in userAccountControl. because DS control access right 
            //    is not enforced. 
            //
            // 2. in DS mode, if the access ck will be checked against domain 
            //    NC head object.
            //
            // 3. computer accounts are not subjest to this access check.
            //

            if (NT_SUCCESS(NtStatus))
            {
                CanSetPasswordNotRequiredBit = TRUE;

                NtStatus = SampValidatePwdSettingAttempt(
                                    DomainContext,  // Context
                                    NULL,           // Client Token
                                    AccountType,
                                    (GUID *) &GUID_CONTROL_UpdatePasswordNotRequiredBit
                                    );

                if (STATUS_ACCESS_DENIED == NtStatus)
                {
                    //
                    // client can't not set this bit
                    // 
                    CanSetPasswordNotRequiredBit = FALSE;

                    if (USER_PASSWORD_NOT_REQUIRED & AccountType)
                    {
                        //
                        // if client explicitly wants to set this bit,
                        // but doesn't have this right, 
                        // Error out --- don't change status code
                        // 
                    }
                    else
                    {
                        //
                        // if client doesn't want this bit. 
                        // we will change error code and continue
                        // 
                        NtStatus = STATUS_SUCCESS;
                    }
                }
            }

            //
            // Set the V1_fixed attribute
            //


            if (NT_SUCCESS(NtStatus)) {

                ULONG PrevUserAccountControl = 0;
                
                V1aFixed.Revision            = SAMP_REVISION;

                V1aFixed.CountryCode         = 0;
                V1aFixed.CodePage            = 0;
                V1aFixed.BadPasswordCount    = 0;
                V1aFixed.LogonCount          = 0;
                V1aFixed.AdminCount          = 0;
                V1aFixed.OperatorCount       = 0;
                V1aFixed.Unused1             = 0;
                V1aFixed.Unused2             = 0;
                  
                //
                // If we're auditing store the original account control
                //
                if (SampDoAccountAuditing(UserContext->DomainIndex)) {
                    
                    PSID UserSid = NULL;
        
                    NtStatus = SampCreateAccountSid(UserContext, &UserSid);
                
                    if (NT_SUCCESS(NtStatus)) {
                        
                        NtStatus = SampAuditUpdateAuditNotificationDs(
                                   SampAuditUpdateTypeUserAccountControl,
                                   UserSid,
                                   (PVOID)&PrevUserAccountControl
                                   );
                        
                        MIDL_user_free(UserSid);
                    }                       
                    
                    if (!NT_SUCCESS(NtStatus)) {
                        goto SampCreateUserInDomainError;
                    }                      
                }
                                                
                V1aFixed.UserAccountControl = AccountType;

                //
                // set USER_PASSWORD_NOT_REQUIRED bit only when the client
                // has the ControlAccessRight to do so. 
                // 
                
                if (CanSetPasswordNotRequiredBit)
                {
                    V1aFixed.UserAccountControl  = (USER_PASSWORD_NOT_REQUIRED |
                                                    AccountType);
                }

                ASSERT( CanSetPasswordNotRequiredBit || 
                        !(AccountType & USER_PASSWORD_NOT_REQUIRED) ); 


                //
                // Disable the account unless this is a special creation
                // in which the creator won't be able to enable the account.
                //

                if (!UserContext->TypeBody.User.PrivilegedMachineAccountCreate) {
                    V1aFixed.UserAccountControl |= USER_ACCOUNT_DISABLED;
                }

                V1aFixed.UserId              = NewAccountRid;

                //
                // For Computers set the primary group id to DOMAIN_GROUP_RID_COMPUTERS
                // For others this should be DOMAIN_GROUP_RID_USERS
                //

                V1aFixed.PrimaryGroupId = SampDefaultPrimaryGroup(
                                                UserContext,
                                                AccountType
                                                );



                V1aFixed.LastLogon           = SampHasNeverTime;
                V1aFixed.LastLogoff          = SampHasNeverTime;
                V1aFixed.PasswordLastSet     = SampHasNeverTime;
                V1aFixed.AccountExpires      = SampWillNeverTime;
                V1aFixed.LastBadPasswordTime = SampHasNeverTime;

                NtStatus = SampReplaceUserV1aFixed(
                               UserContext,
                               &V1aFixed
                               );
            }

            //
            // Set the SECURITY_DESCRIPTOR attribute
            //
            // Set the SecurityDescriptor attribute, only in the registry case
            // In the DS case the act of creating the object itself sets the
            // security descriptor on the object. The reason for this is that'
            // the security descriptor has to go through the merge process in the
            // DS and the Ace's from the parent are not inherited during a modify
            // entry
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Build a security descriptor to protect the User.
                //

                if (!IsDsObject(DomainContext))
                {
                    NtStatus = SampGetNewAccountSecurity(
                                    SampUserObjectType,
                                    (BOOLEAN) ((GroupV1Fixed.AdminCount == 0) ? FALSE : TRUE),
                                    DomainContext->TrustedClient,
                                    UserContext->TypeBody.User.PrivilegedMachineAccountCreate,
                                    NewAccountRid,
                                    UserContext,
                                    &NewSecurityDescriptor,
                                    &NewSecurityDescriptorLength
                                    );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampSetAccessAttribute(
                                       UserContext,
                                       SAMP_USER_SECURITY_DESCRIPTOR,
                                       NewSecurityDescriptor,
                                       NewSecurityDescriptorLength
                                      );

                        MIDL_user_free( NewSecurityDescriptor );

                    }
                }
            }


            //
            // Set the ACCOUNT_NAME attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               UserContext,
                               SAMP_USER_ACCOUNT_NAME,
                               (PUNICODE_STRING)AccountName
                               );
            }


            //
            // Don't set these attribute in loopback case
            // 

            if (NT_SUCCESS(NtStatus) &&
                !UserContext->LoopbackClient)
            {
                //
                // Set the FULL_NAME attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_FULL_NAME,
                                   &SampNullString
                                   );
                }


                //
                // Set the AdminComment attribute
                //

                if (NT_SUCCESS(NtStatus)) {
        
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   &SampNullString
                                   );
                }


                //
                // Set the UserComment attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_USER_COMMENT,
                                   &SampNullString
                                   );
                }


                //
                // Set the Parameters attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_PARAMETERS,
                                   &SampNullString
                                   );
                }


                //
                // Set the HomeDirectory attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   &SampNullString
                                   );
                }


                //
                // Set the HomeDirectoryDrive attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   &SampNullString
                                   );
                }


                //
                // Set the ScriptPath attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   &SampNullString
                                   );
                }


                //
                // Set the ProfilePath attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_PROFILE_PATH,
                                   &SampNullString
                                   );
                }


                //
                // Set the WorkStations attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_WORKSTATIONS,
                                   &SampNullString
                                   );
                }
            }


            //
            // Set the LogonHours attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                LOGON_HOURS LogonHours;

                LogonHours.UnitsPerWeek = 0;
                LogonHours.LogonHours = NULL;

                NtStatus = SampSetLogonHoursAttribute(
                               UserContext,
                               SAMP_USER_LOGON_HOURS,
                               &LogonHours
                               );
            }


            //
            // Set the Groups attribute (with membership in DomainUsers only)
            //

            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext))) {

                NtStatus = SampSetLargeIntArrayAttribute(
                               UserContext,
                               SAMP_USER_GROUPS,
                               (PLARGE_INTEGER)&DomainUsersMember,
                               1
                               );
            }

            //
            // Set the CaseInsensitiveDbcs attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               LmPassword,
                               &SampNullString,
                               NewAccountRid
                               );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_DBCS_PWD,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }


            //
            // Create the CaseSensitiveUnicode key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               NtPassword,
                               &SampNullString,
                               NewAccountRid
                               );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_UNICODE_PWD,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }


            //
            // Set the NtPasswordHistory attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               NtPasswordHistory,
                               &SampNullString,
                               NewAccountRid
                               );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_NT_PWD_HISTORY,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }


            //
            // Set the LmPasswordHistory attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               LmPasswordHistory,
                               &SampNullString,
                               NewAccountRid
                               );

                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_LM_PWD_HISTORY,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }



            //
            // Add this new user to the DomainUsers group
            //

            if ((NT_SUCCESS(NtStatus)) && (!(IsDsObject(UserContext)))) {

                //
                // This addition is done only in the registry case. In the DS case,
                // membership in the primary group is maintained implicitly in the
                // primary group Id property.
                //

                NtStatus = SampAddUserToGroup(
                                    DomainContext,
                                    DOMAIN_GROUP_RID_USERS, 
                                    NewAccountRid
                                    );
            }



        }

        IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);

        ASSERT(NT_SUCCESS(IgnoreStatus));

    }
                                
    if (NT_SUCCESS(NtStatus) && 
        SampDoAccountAuditing(UserContext->DomainIndex)) {
            
        //
        // Set up the privilege set for auditing
        // 
        if (UserContext->TypeBody.User.PrivilegedMachineAccountCreate) {
            
            PSID UserSid = NULL;
            
            Privileges.PrivilegeCount = 1;
            Privileges.Control = 0;
            ASSERT(ANYSIZE_ARRAY >= 1);
            Privileges.Privilege[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
            Privileges.Privilege[0].Luid = RtlConvertUlongToLuid( SE_MACHINE_ACCOUNT_PRIVILEGE);
            PPrivileges = &Privileges;
            
            NtStatus = SampCreateAccountSid(UserContext, &UserSid);
        
            if (NT_SUCCESS(NtStatus)) {
                
                NtStatus = SampAuditUpdateAuditNotificationDs(
                           SampAuditUpdateTypePrivileges,
                           UserSid,
                           (PVOID)PPrivileges
                           );
                
                MIDL_user_free(UserSid);
            }                       
            
            if (!NT_SUCCESS(NtStatus)) {
                goto SampCreateUserInDomainError;
            }
        }
    }    

    //
    // If we created an object, dereference it.  Write out its attributes
    // if everything was created OK.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        ASSERT(UserContext != NULL);
        NtStatus = SampDeReferenceContext( UserContext, TRUE );

    } else {

        if (UserContext != NULL) {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( UserContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }




    //
    // Commit changes and notify netlogon
    //

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Commit the changes; hold on to the write lock for now.
        //

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // If we can't commit the mess for some reason, then delete
        // the new context block and return null for the context handle.
        //

        if (NT_SUCCESS(NtStatus)) {


            if (!IsDsObject(UserContext))
            {
                SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                //
                // Update the display information
                //

                AccountInfo.Name = *((PUNICODE_STRING)AccountName);
                AccountInfo.Rid = NewAccountRid;
                AccountInfo.AccountControl = V1aFixed.UserAccountControl;
                RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                IgnoreStatus = SampUpdateDisplayInformation(
                                                NULL,
                                                &AccountInfo,
                                                SampUserObjectType
                                                );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
            //
            // Audit the creation before we free the write lock
            // so that we have access to the context block.
            //

            if (!SampUseDsData &&
                SampDoAccountAuditing(UserContext->DomainIndex)) {
                
                SampAuditUserChange(
                    UserContext,
                    UserAllInformation,
                    (PUNICODE_STRING)AccountName,
                    &NewAccountRid, 
                    0,
                    V1aFixed.UserAccountControl,
                    PPrivileges,
                    TRUE
                    );

            }

            //
            // Notify netlogon if a machine account was created.
            //

            if ( ( V1aFixed.UserAccountControl &
                USER_MACHINE_ACCOUNT_MASK ) != 0 ) {

                //
                // This was a machine account.  Let
                // NetLogon know of the change.
                //

                IgnoreStatus = I_NetNotifyMachineAccount(
                                   NewAccountRid,
                                   SampDefinedDomains[DomainIndex].Sid,
                                   0,
                                   V1aFixed.UserAccountControl,
                                   (PUNICODE_STRING)AccountName
                                   );
            }

            //
            // Notify netlogon of changes
            //

            SampNotifyNetlogonOfDelta(
                SecurityDbNew,
                SecurityDbObjectSamUser,
                *RelativeId,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,  // Replicate immediately
                NULL            // Delta data
                );

        }

    }



    //
    // Return the context handle on success
    // Delete the context block and return a NULL handle on failure
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(UserContext != NULL);
        (*UserHandle) = UserContext;

        SampUpdatePerformanceCounters(
           ( AccountType & USER_MACHINE_ACCOUNT_MASK ) ?
                DSSTAT_CREATEMACHINESUCCESSFUL :
                DSSTAT_CREATEUSERSUCCESSFUL,
            FLAG_COUNTER_INCREMENT,
            0
            );

    } else {

        if (UserContext != NULL) {
            SampDeleteContext(UserContext);
        }

        (*UserHandle) = (SAMPR_HANDLE)0;
    }


SampCreateUserInDomainError:

    //
    // clean up the account name table
    // 

    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)AccountName,
                            SampUserObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        RemoveAccountNameFromTable = FALSE;
    }

    if ((AccountNameDefaulted) && (NULL!=AccountName->Buffer))
    {
        MIDL_user_free(AccountName->Buffer);
    }


    //
    // Release the lock
    //

    if ( !WriteLockHeld ) {
        IgnoreStatus = SampMaybeReleaseWriteLock( LockAttempted, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Do a WMI event (END type) trace
    //

    if (AccountType & USER_MACHINE_ACCOUNT_MASK)
    {
        SampTraceEvent(EVENT_TRACE_TYPE_END,
                       SampGuidCreateComputerInDomain
                       );
    }
    else
    {
        SampTraceEvent(EVENT_TRACE_TYPE_END,
                       SampGuidCreateUserInDomain 
                       );
    }

    return(NtStatus);
}


NTSTATUS
SamrCreateUser2InDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateUserInDomain() that ensures
    RelativeId points to a RID of zero first.  It also guarantees
    that AccountType is valid.

    A non-zero RID means that SampCreateUserInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateUserInDomain() except AccountType maps to
    AccountControl.

Return Values:

    Same as SampCreateUserInDomain().

--*/

{
    NTSTATUS NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateUser2InDomain");


    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==UserHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    //
    // Make sure one, and only one, account type flag is set.
    //

    switch (AccountType) {

        case USER_NORMAL_ACCOUNT            :
        case USER_WORKSTATION_TRUST_ACCOUNT :
        case USER_INTERDOMAIN_TRUST_ACCOUNT :
        case USER_SERVER_TRUST_ACCOUNT      :
        case USER_TEMP_DUPLICATE_ACCOUNT    :

            //
            // AccountType is valid
            //

            break;

        default :

            //
            // Bad account type value specified
            //

            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            return( NtStatus );
    }




    NtStatus = SampCreateUserInDomain(
                   DomainHandle,
                   AccountName,
                   AccountType,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   UserHandle,
                   GrantedAccess,
                   RelativeId
                   );

Error:

    SAMTRACE_RETURN_CODE_EX(NtStatus);
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);

    return( NtStatus );
}


NTSTATUS SamrCreateUserInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateUserInDomain() that ensures that
    RelativeId points to a RID of zero first.

    A non-zero RID means that SampCreateUserInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateUserInDomain() except AccountType is NORMAL_USER.

Return Values:

    Same as SampCreateUserInDomain().

--*/

{
    NTSTATUS
        NtStatus;

    ULONG
        GrantedAccess;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateUserInDomain");

    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==UserHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    NtStatus = SampCreateUserInDomain(
                   DomainHandle,
                   AccountName,
                   USER_NORMAL_ACCOUNT,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   UserHandle,
                   &GrantedAccess,
                   RelativeId
                   );

Error:
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    return( NtStatus );
}



NTSTATUS SamrEnumerateUsersInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the users defined in the account database.  Since
    there may be more users than can fit into a buffer, the caller is
    provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_USERS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls.
        This is a zero based index.

    UserAccountControl - Provides enumeration filtering information.  Any
        characteristics specified here will cause that type of User account
        to be included in the enumeration process.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/

{

    NTSTATUS                    NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrEnumerateUsersInDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateUsersInDomain
                   );

    NtStatus = SampEnumerateAccountNamesCommon(
                  DomainHandle,
                  SampUserObjectType,
                  EnumerationContext,
                  Buffer,
                  PreferedMaximumLength,
                  UserAccountControl,
                  CountReturned
                  );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateUsersInDomain
                   );

    return(NtStatus);
}





NTSTATUS SamrLookupNamesInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN ULONG Count,
    IN RPC_UNICODE_STRING Names[],
    OUT PSAMPR_ULONG_ARRAY RelativeIds,
    OUT PSAMPR_ULONG_ARRAY Use
    )

/*++

Routine Description:

    This API attempts to find relative IDs corresponding to name
    strings.  If a name can not be mapped to a relative ID, a zero is
    placed in the corresponding relative ID array entry, and translation
    continues.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Number of names to translate.

    Names - Pointer to an array of Count UNICODE_STRINGs that contain
        the names to map to relative IDs.  Case-insensitive
        comparisons of these names will be performed for the lookup
        operation.

    RelativeIds - Receives an array of Count Relative IDs.
        The relative ID of the nth name will be the nth entry in this
        array.  Any names that could not be translated will have a
        zero relative ID.

    RelativeIds - Receives a pointer to a SAMPR_RETURNED_ULONG_ARRAY structure.
        The nth entry in the array associated with this structure
        contains the RID of the nth name looked up.
        When this information is no longer needed, the caller is responsible
        for deallocating each returned block (including the
        SAMPR_ULONG_ARRAY structure itself) using SamFreeMemory().

    Use - Receives a pointer to a SAMPR_RETURNED_ULONG_ARRAY structure.
        The nth entry in the array associated with this structure
        contains the SID_NAME_USE of the nth name looked up.
        When this information is no longer needed, the caller is responsible
        for deallocating each returned block (including the
        SAMPR_ULONG_ARRAY structure itself) using SamFreeMemory().



Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.

--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    UNICODE_STRING          KeyName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    HANDLE                  TempHandle;
    LARGE_INTEGER           IgnoreTimeStamp;
    ULONG                   i, KeyValueLength, UnMappedCount;
    ULONG                   ApproximateTotalLength;
    BOOLEAN                 fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrLookupNamesInDomain");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidLookupNamesInDomain
                   );


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Use != NULL);
    ASSERT (Use->Element == NULL);
    ASSERT (RelativeIds != NULL);
    ASSERT (RelativeIds->Element == NULL);

    if (!((Use!=NULL) && (Use->Element==NULL)
            && (RelativeIds != NULL) && (RelativeIds->Element == NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    Use->Count           = 0;
    RelativeIds->Count   = 0;


    if (Count == 0) {
        NtStatus = STATUS_SUCCESS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }


    //
    // Make sure the parameter values are within reasonable bounds
    //

    if (Count > SAM_MAXIMUM_LOOKUP_COUNT) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    ApproximateTotalLength = (Count*(sizeof(ULONG) + sizeof(SID_NAME_USE)));
    
    //
    // Validate all the names that are passed in to us and perform the
    // maximum memory usage check inside this loop to avoid overflow
    // problems summing up the name lengths.
    //

    for (i=0;i<Count;i++)
    {
        if (NULL==Names[i].Buffer)
        {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto EndOfTrace;
        }
        
        ApproximateTotalLength += (ULONG)Names[i].MaximumLength;
        
        if ( ApproximateTotalLength > SAMP_MAXIMUM_MEMORY_TO_USE ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto EndOfTrace;
        }                                      
    }  
    
    //
    // Acquire the READ lock if necessary
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    SampMaybeAcquireReadLock(DomainContext,
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );
    
    if (NT_SUCCESS(NtStatus)) {
            
        //
        // Allocate the return buffers
        //

        Use->Element = MIDL_user_allocate( Count * sizeof(ULONG) );
        if (Use->Element == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto unexpected_error;
        }

        RelativeIds->Element = MIDL_user_allocate( Count * sizeof(ULONG) );
        if (RelativeIds->Element == NULL) {
            MIDL_user_free( Use->Element);
            Use->Element = NULL;  // required to RPC doesn't free it again.
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto unexpected_error;
        }                         

        Use->Count         = Count;
        RelativeIds->Count = Count;

        UnMappedCount = Count;
        for ( i=0; i<Count; i++) {


            if (IsDsObject(DomainContext))
            {
                //
                // Every SAM_MAX_LOOKUPS_PER_TRANSACTION names we cycle 
                // the transaction to bound the transaction lifetime.  
                //
                
                if ( 0 != i && 0 == (i % SAM_MAX_LOOKUPS_PER_TRANSACTION) )
                {
                    NtStatus = SampMaybeEndDsTransaction(TransactionCommitAndKeepThreadState);
                    
                    if ( !NT_SUCCESS( NtStatus ) ) {
                        
                        goto unexpected_error;
                    }

                    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
                    
                    if ( !NT_SUCCESS( NtStatus ) ) {

                        goto unexpected_error;
                    }    
                }

                NtStatus = SampLookupAccountRid(
                                DomainContext,
                                SampUnknownObjectType,
                                (PUNICODE_STRING)&(Names[i]),
                                STATUS_OBJECT_NAME_NOT_FOUND,
                                &(RelativeIds->Element[i]),
                                (PSID_NAME_USE)&(Use->Element[i])
                                );


                if (NT_SUCCESS(NtStatus))
                {
                    UnMappedCount -=1;
                }
                else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                    //
                    // This is fine.  It just means that we don't
                    // have an account with the name being looked up.
                    //

                    Use->Element[i]         = SidTypeUnknown;
                    RelativeIds->Element[i] = 0;
                    SampDiagPrint(LOGON,("[SAMSS] Name Not Found %S \n",Names[i].Buffer));
                    NtStatus = STATUS_SUCCESS;
                }
                else if (!NT_SUCCESS(NtStatus))
                {
                    SampDiagPrint(LOGON,("[SAMSS] Looking up Name %S Unexpected Error %d\n",
                                            Names[i].Buffer,
                                            NtStatus));
                    goto unexpected_error;
                }

            }
            else
            {

                //
                // Registry Case
                //

                //
                // Search the groups for a match
                //

                NtStatus = SampBuildAccountKeyName(
                               SampGroupObjectType,
                               &KeyName,
                               (PUNICODE_STRING)&Names[i]
                               );
                if (NT_SUCCESS(NtStatus)) {

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &KeyName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

                    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

                    NtStatus = RtlpNtOpenKey(
                                   &TempHandle,
                                   (KEY_READ),
                                   &ObjectAttributes,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );

                    if (NT_SUCCESS(NtStatus)) {

                        UnMappedCount  -= 1;
                        Use->Element[i] = SidTypeGroup;
                        KeyValueLength  = 0;
                        NtStatus = RtlpNtQueryValueKey(
                                       TempHandle,
                                       &RelativeIds->Element[i],
                                       NULL,
                                       &KeyValueLength,
                                       &IgnoreTimeStamp
                                       );

                        SampDumpRtlpNtQueryValueKey(&RelativeIds->Element[i],
                                                    NULL,
                                                    &KeyValueLength,
                                                    &IgnoreTimeStamp);

                        IgnoreStatus = NtClose( TempHandle );
                        ASSERT( NT_SUCCESS(IgnoreStatus) );
                        if (!NT_SUCCESS(NtStatus)) {
                            goto unexpected_error;
                        }
                        ASSERT(KeyValueLength == 0);


                    } else {

                        //
                        // Search the aliases for a match
                        //

                        NtStatus = SampBuildAccountKeyName(
                                       SampAliasObjectType,
                                       &KeyName,
                                       (PUNICODE_STRING)&Names[i]
                                       );
                        if (NT_SUCCESS(NtStatus)) {

                            InitializeObjectAttributes(
                                &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                SampKey,
                                NULL
                                );

                            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

                            NtStatus = RtlpNtOpenKey(
                                           &TempHandle,
                                           (KEY_READ),
                                           &ObjectAttributes,
                                           0
                                           );
                            SampFreeUnicodeString( &KeyName );

                            if (NT_SUCCESS(NtStatus)) {

                                UnMappedCount  -= 1;
                                Use->Element[i] = SidTypeAlias;
                                KeyValueLength  = 0;
                                NtStatus = RtlpNtQueryValueKey(
                                               TempHandle,
                                               &RelativeIds->Element[i],
                                               NULL,
                                               &KeyValueLength,
                                               &IgnoreTimeStamp
                                               );

                                SampDumpRtlpNtQueryValueKey(&RelativeIds->Element[i],
                                                    NULL,
                                                    &KeyValueLength,
                                                    &IgnoreTimeStamp);

                                IgnoreStatus = NtClose( TempHandle );
                                ASSERT( NT_SUCCESS(IgnoreStatus) );
                                if (!NT_SUCCESS(NtStatus)) {
                                    goto unexpected_error;
                                }
                                ASSERT(KeyValueLength == 0);


                            } else {

                                //
                                // Search the user for a match
                                //

                                NtStatus = SampBuildAccountKeyName(
                                               SampUserObjectType,
                                               &KeyName,
                                               (PUNICODE_STRING)&Names[i]
                                               );
                                if (NT_SUCCESS(NtStatus)) {

                                    InitializeObjectAttributes(
                                        &ObjectAttributes,
                                        &KeyName,
                                        OBJ_CASE_INSENSITIVE,
                                        SampKey,
                                        NULL
                                        );


                                    SampDumpNtOpenKey((KEY_READ),
                                                      &ObjectAttributes,
                                                      0);

                                    NtStatus = RtlpNtOpenKey(
                                                   &TempHandle,
                                                   (KEY_READ),
                                                   &ObjectAttributes,
                                                   0
                                                   );
                                    SampFreeUnicodeString( &KeyName );

                                    if (NT_SUCCESS(NtStatus)) {

                                        UnMappedCount  -= 1;
                                        Use->Element[i] = SidTypeUser;
                                        KeyValueLength  = 0;
                                        NtStatus = RtlpNtQueryValueKey(
                                                       TempHandle,
                                                       &RelativeIds->Element[i],
                                                       NULL,
                                                       &KeyValueLength,
                                                       &IgnoreTimeStamp
                                                       );

                                        SampDumpRtlpNtQueryValueKey(&RelativeIds->Element[i],
                                                    NULL,
                                                    &KeyValueLength,
                                                    &IgnoreTimeStamp);

                                        IgnoreStatus = NtClose( TempHandle );
                                        ASSERT( NT_SUCCESS(IgnoreStatus) );
                                        if (!NT_SUCCESS(NtStatus)) {
                                            goto unexpected_error;
                                        }
                                        ASSERT(KeyValueLength == 0);

                                    } else if(NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                                        //
                                        // This is fine.  It just means that we don't
                                        // have an account with the name being looked up.
                                        //

                                        Use->Element[i]         = SidTypeUnknown;
                                        RelativeIds->Element[i] = 0;
                                        NtStatus = STATUS_SUCCESS;

                                    }

                                }
                            }
                        }
                    }
                }
            } // End of Registry Case


            if (!NT_SUCCESS(NtStatus) &&
                NtStatus != STATUS_INVALID_ACCOUNT_NAME) {
                goto unexpected_error;
            }

        } // end_for


        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );

        if (UnMappedCount == Count) {
            NtStatus = STATUS_NONE_MAPPED;
        } else {
            if (UnMappedCount > 0) {
                NtStatus = STATUS_SOME_NOT_MAPPED;
            } else {
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    //
    // If the status isn't one of the expected return values,
    // then deallocate the return memory block
    //

    if ( ( NtStatus != STATUS_SUCCESS )         &&
         ( NtStatus != STATUS_SOME_NOT_MAPPED ) ) {

        Use->Count = 0;
        MIDL_user_free( Use->Element );
        Use->Element = NULL;
        RelativeIds->Count = 0;
        MIDL_user_free( RelativeIds->Element );
        RelativeIds->Element = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    goto EndOfTrace;


unexpected_error:

    //
    // De-reference the object
    //

    IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    //
    // Don't return any memory
    //

    Use->Count = 0;
    
    if (Use->Element) {
        MIDL_user_free( Use->Element );
        // Required so RPC doesn't try to free the element    
        Use->Element = NULL;  
    }
    
    RelativeIds->Count = 0;
    
    if (RelativeIds->Element) {
        MIDL_user_free( RelativeIds->Element );
        // Required so RPC doesn't try to free the element    
        RelativeIds->Element = NULL;  
    }
    
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

EndOfTrace:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidLookupNamesInDomain
                   );

    return( NtStatus );

}



NTSTATUS SamrLookupIdsInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PSAMPR_RETURNED_USTRING_ARRAY Names,
    OUT PSAMPR_ULONG_ARRAY Use
    )


/*++

Routine Description:

    This API maps a number of relative IDs to their corresponding names.
    If a relative ID can not be mapped, a NULL value is placed in the slot
    for the UNICODE_STRING, and STATUS_SOME_NOT_MAPPED is returned.
    If none of the IDs can be mapped, then all array entries will contain
    NULL values and STATUS_NONE_MAPPED is returned.

    DOMAIN_LOOKUP access to the domain is needed to use this service.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Provides the number of relative IDs to translate.

    RelativeIds - Array of Count relative IDs to be mapped.

    Names - Receives a pointer to an allocated SAMPR_UNICODE_STRING_ARRAY.
        The nth entry in the array of names pointed to by this structure
        corresonds to the nth relative id looked up.
        Each name string buffer will be in a separate block of memory
        allocated by this routine.  When these names are no longer
        needed, the caller is responsible for deallocating each
        returned block (including the SAMPR_RETURNED_USTRING_ARRAY structure
        itself) using SamFreeMemory().

    Use - Receives a pointer to a SAMPR_ULONG_ARRAY structure.
        The nth entry in the array associated with this structure
        contains the SID_NAME_USE of the nth relative ID looked up.
        When this information is no longer needed, the caller is responsible
        for deallocating this memory using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.


--*/
{

    NTSTATUS                    NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE            ObjectType;
    PSAMP_OBJECT                DomainContext;
    PSAMP_DEFINED_DOMAINS       Domain;
    SAMP_OBJECT_TYPE            FoundType;
    ULONG                       i, UnMappedCount;
    ULONG                       TotalLength;
    PSAMP_MEMORY                NextMemory;
    SAMP_MEMORY                 MemoryHead;
    PSID                        DomainSid;
    BOOLEAN                     fReadLockAcquired = FALSE;
    BOOLEAN                     LengthLimitReached = FALSE;
    ULONG                       DomainIndex=0;
    BOOLEAN                     fInDsMode = FALSE;

    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrLookupIdsInDomain");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidLookupIdsInDomain
                   );

    //
    // Used for tracking allocated memory so we can deallocate it on
    // error
    //

    MemoryHead.Memory = NULL;
    MemoryHead.Next   = NULL;


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (RelativeIds != NULL);
    ASSERT (Use != NULL);
    ASSERT (Use->Element == NULL);
    ASSERT (Names != NULL);
    ASSERT (Names->Element == NULL);

    if (!((RelativeIds!=NULL)&&(Use!=NULL)
            && (Use->Element==NULL) && (Names!=NULL)
            && (Names->Element == NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    Use->Count     = 0;
    Names->Count   = 0;

    if (Count == 0) {
        NtStatus = STATUS_SUCCESS;
        goto EndOfTrace;
    }

    if (Count > SAM_MAXIMUM_SID_LOOKUP_COUNT) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }                         

    TotalLength = (Count*(sizeof(ULONG) + sizeof(UNICODE_STRING)));

    if ( TotalLength > SAMP_MAXIMUM_MEMORY_TO_USE ) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    //
    // Acquire the READ Lock if necessary
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    SampMaybeAcquireReadLock(DomainContext,
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fReadLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    if ( !NT_SUCCESS( NtStatus ) ) {

        goto unexpected_error;

    }
    
    //
    // Grab the Domain SID. Note a given Domain's domain SID will never change
    // therefore safe to just refer to the pointer in SampDefinedDomains.
    //

    DomainSid = SampDefinedDomains[DomainContext->DomainIndex].Sid;
    DomainIndex = DomainContext->DomainIndex;
    
    fInDsMode = IsDsObject( DomainContext );

    //
    // We are done with the context; therefore de reference it
    //

    IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE ); 

    //
    // Allocate the return buffers
    //

    Use->Element = MIDL_user_allocate( Count * sizeof(ULONG) );
    if (Use->Element == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto unexpected_error;
    }
    RtlZeroMemory(Use->Element, Count * sizeof(ULONG) );


    Names->Element = MIDL_user_allocate( Count * sizeof(UNICODE_STRING) );
    if (Names->Element == NULL) {
        MIDL_user_free( Use->Element);
        Use->Element = NULL;
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto unexpected_error;
    }
    RtlZeroMemory(Names->Element, Count * sizeof(UNICODE_STRING) );
    
    Use->Count = Count;
    Names->Count = Count;
    
    UnMappedCount = Count;
    for ( i=0; i<Count; i++) {
        
        //
        // Every SAM_MAX_LOOKUPS_PER_TRANSACTION IDs we cycle the 
        // transaction to bound the transaction lifetime.  
        //
        
        if ( fInDsMode && 
             0 != i && 
             0 == (i % SAM_MAX_LOOKUPS_PER_TRANSACTION) )
        {
            NtStatus = SampMaybeEndDsTransaction(TransactionCommitAndKeepThreadState);
            
            if ( !NT_SUCCESS( NtStatus ) ) {
                
                goto unexpected_error;
            }

            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            
            if ( !NT_SUCCESS( NtStatus ) ) {

                goto unexpected_error;
            }    
        }

        //
        // allocate a block to track a name allocated for this mapping
        //

        NextMemory = MIDL_user_allocate( sizeof(SAMP_MEMORY) );
        if (NextMemory == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto unexpected_error;
        }


        //
        // Lookup the SID.
        //

        NtStatus = SampLookupAccountName(
                        DomainIndex,
                        RelativeIds[i],
                        (PUNICODE_STRING)&Names->Element[i],
                        &ObjectType
                        );
        

        if (!NT_SUCCESS(NtStatus)) {
            //
            // Free the memory that we just allocated.
            //

            MIDL_user_free(NextMemory);
            NextMemory = NULL;
            goto unexpected_error;
        }


        switch (ObjectType) {

        case SampUserObjectType:
        case SampGroupObjectType:
        case SampAliasObjectType:

            //
            // We found the account
            //

            UnMappedCount -= 1;

            NextMemory->Memory = (PVOID)Names->Element[i].Buffer;
            NextMemory->Next = MemoryHead.Next;
            MemoryHead.Next = NextMemory;

            switch (ObjectType) {

            case SampUserObjectType:
                Use->Element[i] = SidTypeUser;
                break;

            case SampGroupObjectType:
                Use->Element[i] = SidTypeGroup;
                break;

            case SampAliasObjectType:
                Use->Element[i] = SidTypeAlias;
                break;
            }

            break;


        case SampUnknownObjectType:

            //
            // NT4 and earlier versions of samsrv.dll used to be able
            // to perform a check whether the SID was a deleted account
            // or unknown. They did this by assuming that the RID range
            // was continuously allocated and therefore a RID value below
            // the domain RID high water mark would represent a deleted
            // account. In NT5 RID allocation is non monotonic hence this
            // assumption is no longer correct. We therefore simply return
            // SidTypeUnknown

            Use->Element[i]                 = SidTypeUnknown;


            Names->Element[i].Length        = 0;
            Names->Element[i].MaximumLength = 0;
            Names->Element[i].Buffer        = NULL;
            MIDL_user_free( NextMemory );

            break;

        default:

            ASSERT(FALSE); // unexpected object type returned
            break;
        }

    } // end_for    


    if (UnMappedCount == Count) {
        NtStatus = STATUS_NONE_MAPPED;
    } else {
        if (UnMappedCount > 0) {
            NtStatus = STATUS_SOME_NOT_MAPPED;
        } else {
            NtStatus = STATUS_SUCCESS;
        }
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fReadLockAcquired);


    //
    // Free all the memory tracking blocks
    //

    NextMemory = MemoryHead.Next;
    while ( NextMemory != NULL ) {
        MemoryHead.Next = NextMemory->Next;
        MIDL_user_free( NextMemory );
        NextMemory = MemoryHead.Next;
    }


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    goto EndOfTrace;


unexpected_error:



    //
    // Free the read lock
    //


    SampMaybeReleaseReadLock(fReadLockAcquired);



    //
    // Free all the memory tracking blocks - and the memory they point to.
    //

    Use->Count = 0;
    
    if (Use->Element) {
        MIDL_user_free( Use->Element );
        Use->Element = NULL;    
    }
    
    Names->Count = 0;
    
    if (Names->Element) {
        MIDL_user_free( Names->Element );
        Names->Element = NULL;    
    }
    
    NextMemory = MemoryHead.Next;
    while ( NextMemory != NULL ) {
        if (NextMemory->Memory != NULL) {
            MIDL_user_free( NextMemory->Memory );
        }
        MemoryHead.Next = NextMemory->Next;
        MIDL_user_free( NextMemory );
        NextMemory = MemoryHead.Next;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);



EndOfTrace:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidLookupIdsInDomain
                   );

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private services                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampOpenDomainKey(
    IN PSAMP_OBJECT DomainContext,
    IN PRPC_SID DomainId,
    IN BOOLEAN SetTransactionDomain
    )

/*++

Routine Description:

    This service attempts to open the root registry key of the domain with
    the specified SID. The root name and key handle are put in the
    passed domain context.


    If successful, and the domain key is opened, then the opened domain is
    established as the transaction domain (using SampSetTransactionDomain()).

    THIS SERVICE MUST BE CALLED WITH THE SampLock() HELD FOR READ OR
    WRITE ACCESS.

Arguments:

    DomainContext - Context in which root namd and handle are stored.

    DomainId - Specifies the SID of the domain to open.

Return Value:

    STATUS_SUCCESS - The domain has been openned.

    STATUS_NO_SUCH_DOMAIN - The domain object could not be found.

    STATUS_INSUFFICIENT_RESOURCES - The domain object could not be openned
       due to the lack of some resource (probably memory).

    STATUS_INVALID_SID - The sid provided as the domain identifier is not
        a valid SID structure.

    Other errors that might be returned are values returned by:

--*/
{
    NTSTATUS    NtStatus;
    ULONG       i;
    ULONG       DomainStart;



    SAMTRACE("SampOpenDomainKey");

    //
    // Get the start domain in the defined domains structure.
    //

    DomainStart = SampDsGetPrimaryDomainStart();

    //
    // Make sure the SID provided is legitimate...
    //

    if ( !RtlValidSid(DomainId)) {
        NtStatus = STATUS_INVALID_SID;
    } else {

        //
        // Set our default completion status
        //

        NtStatus = STATUS_NO_SUCH_DOMAIN;


        //
        // Search the list of defined domains for a match.
        //

        //
        // Use the Variable SampDomainStart. This is used to offset the
        // defined domains structure by 2, when the DS domain intializes
        //

        for (i = DomainStart; i<SampDefinedDomainsCount; i++ ) {

             if (RtlEqualSid( DomainId, SampDefinedDomains[i].Sid)) {


                 if (IsDsObject(SampDefinedDomains[i].Context))
                 {
                     //
                     // Copy Object Flags and Object Name in DS
                     //
                     //

                     DomainContext->ObjectNameInDs =
                                    SampDefinedDomains[i].Context->ObjectNameInDs;
                     DomainContext->ObjectFlags =
                                    SampDefinedDomains[i].Context->ObjectFlags;
                 }
                 else
                 {
                     //
                     // Copy the found name and handle into the context
                     // Note we reference the key handle in the defined_domains
                     // structure directly since it is not closed
                     // when the context is deleted.
                     //

                     DomainContext->RootKey  = SampDefinedDomains[i].Context->RootKey;
                     DomainContext->RootName = SampDefinedDomains[i].Context->RootName;
                 }

                 DomainContext->DomainIndex = i;

                 //
                 // Set the transaction domain to the one found
                 //

                if (SetTransactionDomain) {
                    SampSetTransactionDomain( i );
                }


                 NtStatus = STATUS_SUCCESS;
                 break; // out of for
             }
        }
    }


    return(NtStatus);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available to other SAM modules                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SampInitializeDomainObject( VOID )

/*++

Routine Description:

    This service performs initialization functions related to the Domain
    object class.

    This involves:

        1) Openning the DOMAINS registry key.

        2) Obtaining the name of each domain (builtin and account)
           and opening that domain.

Arguments:

    None.

Return Value:

    TRUE - Indicates initialization was performed successfully.

    FALSE - Indicates initialization was not performed successfully.


--*/

{

    NTSTATUS        NtStatus;
    ULONG           DefinedDomainsSize, i, j, k;
    BOOLEAN         ReturnStatus = TRUE;


    SAMTRACE("SampInitializeDomainObject");

    // Open all domains and keep information about each in memory for some-
    // what fast processing and less complicated code strewn throughout.

    // SAM's domain array, SampDefinedDomains, is initially set up with two
    // elements: the registry-based Builtin and Account domains. In the case
    // of a workstation or server, these elements contain the account infor-
    // mation for those domains. In the case of a domain controller, these
    // two elements contain the "crash-recovery" accounts, which are also
    // persistently stored in the registry instead of the DS. It is assumed
    // that the crash will prevent the DS from starting or properly running,
    // hence the need to store the data in the registry.
    //
    // The crash-recovery accounts are always setup on a DC. Disabling this
    // initialization may lead to problems later in the domain initialization
    // sequence.

    SampDefinedDomainsCount = 2;

    if ( NtProductLanManNt == SampProductType ) {

        //
        // We are going to need another 2 later when initializing the
        // ds domains,  so allocate now
        //
        DefinedDomainsSize = (SampDefinedDomainsCount + 2) * sizeof(SAMP_DEFINED_DOMAINS);

    } else {

        DefinedDomainsSize = SampDefinedDomainsCount * sizeof(SAMP_DEFINED_DOMAINS);

    }

    SampDefinedDomains = MIDL_user_allocate( DefinedDomainsSize );
    if (NULL==SampDefinedDomains)
    {
       return(FALSE);
    }

    //
    // Zero out the defined domains field, so that any fields that are important for
    // DS mode only do not remain uninitialized
    //

    RtlZeroMemory(SampDefinedDomains,DefinedDomainsSize);

    //
    // Get the BUILTIN and ACCOUNT domain information from the LSA
    //

    if (NtProductLanManNt == SampProductType)
    {
        // BUG: Need to call SampSetDcDomainPolicy for multiple hosted Builtin domains.

        // NtStatus = SampSetDcDomainPolicy();

        NtStatus = SampSetDomainPolicy();
    }
    else
    {
        NtStatus = SampSetDomainPolicy();
    }

    if (!NT_SUCCESS(NtStatus)) {
        return(FALSE);
    }

    //
    // Now prepare each of these domains
    //

    i = 0;      // Index into DefinedDomains array

    // BUG: Need to do both so that Account domain reg key is set for logon.

    // If the domain reg key is not set, MsvpSamValidate will fault during the
    // logon sequence.

    k = SampDefinedDomainsCount;

    for (j=0; j<k; j++) {

        NtStatus = SampInitializeSingleDomain( i );

        if (NT_SUCCESS(NtStatus)) {

            i++;

        } else {

            //
            // If a domain didn't initialize, shift the last
            // domain into its slot (assuming this isn't the last
            // domain).  Don't try to free the name buffers on error.
            // The builtin domain's name is not in an allocated buffer.
            //
            //

            if (i != (SampDefinedDomainsCount-1)) {

                SampDefinedDomains[i] =
                    SampDefinedDomains[SampDefinedDomainsCount-1];

                SampDefinedDomains[SampDefinedDomainsCount-1].ExternalName.Buffer = NULL;
                SampDefinedDomains[SampDefinedDomainsCount-1].InternalName.Buffer = NULL;
                SampDefinedDomains[SampDefinedDomainsCount-1].Sid  = NULL;
            }

            //
            // And reduce the number of defined domains we have
            //

            SampDefinedDomainsCount --;
        }
    }

    return(TRUE);

}


NTSTATUS
SampInitializeSingleDomain(
    ULONG Index
    )

/*++

Routine Description:

    This service opens a single domain that is expected to be in the
    SAM database.

    The name and SID of the DefinedDomains array entry are expected
    to be filled in by the caller.

Arguments:

    Index - An index into the DefinedDomains array.  This array
        contains information about the domain being openned,
        including its name.  The remainder of this array entry
        is filled in by this routine.


Return Value:



--*/
{
    NTSTATUS        NtStatus, IgnoreStatus;
    PSAMP_OBJECT    DomainContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSID            Sid;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed;

#if DBG
    SID *Sid1, *Sid2;
#endif

    SAMTRACE("SampInitializeSingleDomain");


    //
    // Initialize everything we might have to cleanup on error
    //

    DomainContext = NULL;


    //
    // Create a context for this domain object.
    // We'll keep this context around until SAM is shutdown
    // We store the context handle in the defined_domains structure.
    //

    DomainContext = SampCreateContext( SampDomainObjectType, Index, TRUE);

    if ( DomainContext == NULL ) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto error_cleanup;
    }

    DomainContext->DomainIndex = Index;

    //
    // Create the name of the root key name of this domain in the registry.
    //

    NtStatus = SampBuildDomainKeyName(
                   &DomainContext->RootName,
                   &SampDefinedDomains[Index].InternalName
                   );

    if (!NT_SUCCESS(NtStatus)) {
        DomainContext->RootName.Buffer = NULL;
        goto error_cleanup;
    }


    //
    // Open the root key and store the handle in the context
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DomainContext->RootName,
        OBJ_CASE_INSENSITIVE,
        SampKey,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &DomainContext->RootKey,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("SAMSS: Failed to open %Z Domain.\n",
             &SampDefinedDomains[Index].ExternalName);
#endif //DBG
        DomainContext->RootKey = INVALID_HANDLE_VALUE;
        return(NtStatus);
    }


    //
    // Get the fixed length data for the domain and store in
    // the defined_domain structure
    //

    NtStatus = SampGetFixedAttributes(
                   DomainContext,
                   FALSE, // Don't make copy
                   (PVOID *)&V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("SAMSS: Failed to get fixed attributes for %Z Domain.\n",
            &SampDefinedDomains[Index].ExternalName);
#endif //DBG

        goto error_cleanup;
    }


    RtlMoveMemory(
        &SampDefinedDomains[Index].UnmodifiedFixed,
        V1aFixed,
        sizeof(*V1aFixed)
        );

    RtlCopyMemory(
        &SampDefinedDomains[Index].CurrentFixed,
        &SampDefinedDomains[Index].UnmodifiedFixed,
        sizeof(SampDefinedDomains[Index].UnmodifiedFixed)
        );


    //
    // Marked the Fixed Length Data as Valid
    //

    SampDefinedDomains[Index].FixedValid = TRUE;

    //
    // Mark the server role information in the defined domain structure
    //

    SampDefinedDomains[Index].ServerRole =
           SampDefinedDomains[Index].UnmodifiedFixed.ServerRole;

    //
    //
    // Get the sid attribute of the domain
    //

    NtStatus = SampGetSidAttribute(
                   DomainContext,
                   SAMP_DOMAIN_SID,
                   FALSE,
                   &Sid
                   );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("SAMSS: Failed to get SID attribute for %Z Domain.\n",
            &SampDefinedDomains[Index].ExternalName);
#endif //DBG
        goto error_cleanup;
    }


    //
    // Make sure this sid agrees with the one we were passed
    //

    if (RtlEqualSid(Sid, SampDefinedDomains[Index].Sid) != TRUE) {

        //
        // Ok, the LSA is out of sorts.  We've got to set it straight
        //

        //
        // Note: SampDefinedDomains[Index].Sid points to memory allocated
        // from the LSA which is never freed.  We could theoretically free
        // it now, but the struct from which it was packaged is long gone.
        //
        // Sid is a copy of the sid from the domain context which is never
        // released either.
        //
        SampDefinedDomains[Index].Sid = Sid;

        NtStatus = SampSetAccountDomainPolicy( &SampDefinedDomains[Index].ExternalName,
                                               SampDefinedDomains[Index].Sid );

        if ( !NT_SUCCESS( NtStatus ) ) {

            //
            // This is fatal
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                        "SAMSS: SampSetAccountDomainPolicy failed with 0x%x\n",
                        NtStatus));

            NtStatus = STATUS_INVALID_ID_AUTHORITY;
            goto error_cleanup;
        }

    }


    //
    // Build security descriptors for use in user and group account creations
    // in this domain.
    //

    NtStatus = SampInitializeDomainDescriptors( Index );
    if (!NT_SUCCESS(NtStatus)) {
        goto error_cleanup;
    }

    //
    // Intialize the cached display information
    //

    // MURLIS 6/11/96 -- Store the Context handle in the
    // defined domains structure, before calling Initialize Display
    // information as Enumerate Account Names will need this information
    // to make the decision wether the domain is in the DS or in
    // Registry.

    SampDefinedDomains[Index].Context = DomainContext;

    NtStatus = SampInitializeDisplayInformation( Index );



    if (!NT_SUCCESS(NtStatus)) {

        //
        // NULL out the context handle in the defined_domain structure
        //

        SampDefinedDomains[Index].Context = NULL;
        goto error_cleanup;
    }

    if (SampDefinedDomains[Index].IsBuiltinDomain) {
        SampDefinedDomains[Index].IsExtendedSidDomain = FALSE;
    } else {
        //
        // Note -- when the extended SID support is complete, this will be
        // replaced with domain wide state, not a registry setting
        //
        SampDefinedDomains[Index].IsExtendedSidDomain = SampIsExtendedSidModeEmulated(NULL);
    }


    return(NtStatus);


error_cleanup:

#if DBG
    DbgPrint("       Status is 0x%lx \n", NtStatus);
#endif //DBG


    if (DomainContext != 0) {

        SampFreeUnicodeString(&DomainContext->RootName);

        if (DomainContext->RootKey != INVALID_HANDLE_VALUE) {

            IgnoreStatus = NtClose(DomainContext->RootKey);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }

    return(NtStatus);

}



NTSTATUS
SampSetDomainPolicy(
    )
/*++


Routine Description:

    This routine sets the names and SIDs for the builtin and account domains.
    The builtin account domain has a well known name and SID.
    The account domain has these stored in the Policy database.


    It places the information for the builtin domain in
    SampDefinedDomains[0] and the information for the account
    domain in SampDefinedDomains[1].


Arguments:

    None.

Return Value:



--*/
{
    NTSTATUS NtStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    SAMTRACE("SampSetDomainPolicy");

    //
    // Builtin domain - Well-known External Name and SID
    //                  Constant Internal Name

    RtlInitUnicodeString( &SampDefinedDomains[0].InternalName, L"Builtin");
    RtlInitUnicodeString( &SampDefinedDomains[0].ExternalName, L"Builtin");

    SampDefinedDomains[0].Sid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( SampDefinedDomains[0].Sid != NULL );
    if (NULL==SampDefinedDomains[0].Sid)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlInitializeSid(
     SampDefinedDomains[0].Sid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( SampDefinedDomains[0].Sid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    SampDefinedDomains[0].IsBuiltinDomain = TRUE;
 
    //
    // Account domain - Configurable External Name and Sid
    //                  The External Name is held in the LSA Policy
    //                  Database.  It is equal to the Domain Name for DC's
    //                  or the Computer Name for Workstations.
    //                  Constant Internal Name
    //

    NtStatus = SampGetAccountDomainInfo( &PolicyAccountDomainInfo );

    if (NT_SUCCESS(NtStatus)) {

        ULONG len = DNS_MAX_NAME_BUFFER_LENGTH+1;
        WCHAR tmpBuffer[DNS_MAX_NAME_BUFFER_LENGTH+1];
        ULONG BufLength = 0;

        //
        // copy account Domain SID
        //
        BufLength = RtlLengthSid( PolicyAccountDomainInfo->DomainSid );
        SampDefinedDomains[1].Sid = RtlAllocateHeap( RtlProcessHeap(), 0, BufLength );
        if (NULL == SampDefinedDomains[1].Sid)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(SampDefinedDomains[1].Sid, BufLength);
        RtlCopyMemory(SampDefinedDomains[1].Sid, PolicyAccountDomainInfo->DomainSid, BufLength);
        
        //
        // copy Account Domain Name 
        // 
        BufLength = PolicyAccountDomainInfo->DomainName.MaximumLength;
        SampDefinedDomains[1].ExternalName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, BufLength );
        if (NULL == SampDefinedDomains[1].ExternalName.Buffer)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(SampDefinedDomains[1].ExternalName.Buffer, BufLength);
        RtlCopyMemory(SampDefinedDomains[1].ExternalName.Buffer, 
                      PolicyAccountDomainInfo->DomainName.Buffer,
                      PolicyAccountDomainInfo->DomainName.Length
                      );
        SampDefinedDomains[1].ExternalName.Length = PolicyAccountDomainInfo->DomainName.Length;
        SampDefinedDomains[1].ExternalName.MaximumLength = PolicyAccountDomainInfo->DomainName.MaximumLength;
        

        RtlInitUnicodeString( &SampDefinedDomains[1].InternalName, L"Account");

        //
        // Set the DNS domain name to be as returned by GetComputerNameEx
        //

        if ( !GetComputerNameExW(
                    ComputerNameDnsFullyQualified,
                    tmpBuffer,
                    &len) ) 
        {

            len = 0; // for the NULL terminator
            tmpBuffer[0] = L'\0';
        }

        // Add 1 for the NULL terminator
        len++;

        SampDefinedDomains[1].DnsDomainName.Buffer 
                       = RtlAllocateHeap(RtlProcessHeap(), 0, len * sizeof(WCHAR));
        if (NULL==SampDefinedDomains[1].DnsDomainName.Buffer)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        RtlCopyMemory(SampDefinedDomains[1].DnsDomainName.Buffer,
                                      tmpBuffer,len*sizeof(WCHAR));
        SampDefinedDomains[1].DnsDomainName.Length = 
                                     (USHORT) (len -1) * sizeof(WCHAR);
        SampDefinedDomains[1].DnsDomainName.MaximumLength = 
                                     (USHORT) (len -1) * sizeof(WCHAR);
        


    } 

    SampDefinedDomains[1].IsBuiltinDomain = FALSE;

Error:

    if (NULL != PolicyAccountDomainInfo)
    {
        LsaFreeMemory( PolicyAccountDomainInfo );
    }

    return(NtStatus);;
}


NTSTATUS
SampSetDcDomainPolicy(
    )

/*++

Routine Description:

    This routine sets the names and SIDs for the builtin domain. The builtin
    account domain has a well known name and SID. The account domain has these
    stored in the Policy database.

    It places the information for the builtin domain in SampDefinedDomains[0].

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    // BUG: This routine assumes the same Builtin domain for each hosted dom.

    // The purpose of this routine is to separate out the Builtin domain
    // policy initialization from the Account domain initialization. Because
    // each hosted domain will have a different Builtin policy, this routine
    // should be called from SampDsInitializeDomainObjects.

    SAMTRACE("SampSetDcDomainPolicy");

    //
    // Builtin domain - Well-known External Name and SID
    //                  Constant Internal Name

    RtlInitUnicodeString( &SampDefinedDomains[0].InternalName, L"Builtin");
    RtlInitUnicodeString( &SampDefinedDomains[0].ExternalName, L"Builtin");

    SampDefinedDomains[0].Sid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( SampDefinedDomains[0].Sid != NULL );
    if (NULL==SampDefinedDomains[0].Sid)
    {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlInitializeSid(
     SampDefinedDomains[0].Sid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( SampDefinedDomains[0].Sid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    return(NtStatus);;
}


NTSTATUS
SampReInitializeSingleDomain(
    ULONG Index
    )

/*++

Routine Description:

    This service reinitializes a single domain after a registry hive refresh.

Arguments:

    Index - An index into the DefinedDomains array.

Return Value:

    STATUS_SUCCESS : The domain was re-initialized successfully.

    Other failure codes.

--*/
{
    NTSTATUS        NtStatus;
    PSAMP_DEFINED_DOMAINS Domain;
    PSAMP_OBJECT    DomainContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed;

    SAMTRACE("SampReinitializeSingleDomain");

    ASSERT(SampCurrentThreadOwnsLock());

    Domain = &SampDefinedDomains[Index];

    //
    // Create a context for this domain object.
    // We'll keep this context around until SAM is shutdown
    // We store the context handle in the defined_domains structure.
    //

    DomainContext = SampCreateContext( SampDomainObjectType, Index, TRUE );

    if ( DomainContext == NULL ) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto error_cleanup;
    }

    DomainContext->DomainIndex = Index;

    //
    // Create the name of the root key name of this domain in the registry.
    //

    NtStatus = SampBuildDomainKeyName(
                   &DomainContext->RootName,
                   &SampDefinedDomains[Index].InternalName
                   );

    if (!NT_SUCCESS(NtStatus)) {
        RtlInitUnicodeString(&DomainContext->RootName, NULL);
        goto error_cleanup;
    }


    //
    // Open the root key and store the handle in the context
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DomainContext->RootName,
        OBJ_CASE_INSENSITIVE,
        SampKey,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &DomainContext->RootKey,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Failed to open %Z Domain.\n",
                   &SampDefinedDomains[Index].ExternalName));

        DomainContext->RootKey = INVALID_HANDLE_VALUE;
        goto error_cleanup;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAMSS: SAM New domain %d key : 0x%lx\n",
               Index,
               DomainContext->RootKey));

    //
    // Get the fixed length data for the domain and store in
    // the defined_domain structure
    //

    NtStatus = SampGetFixedAttributes(
                   DomainContext,
                   FALSE, // Don't make copy
                   (PVOID *)&V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Failed to get fixed attributes for %Z Domain.\n",
                   &SampDefinedDomains[Index].ExternalName));

        goto error_cleanup;
    }

    //
    // Copy the fixed-length data into our in-memory data area for this domain.
    //

    RtlMoveMemory(
        &SampDefinedDomains[Index].UnmodifiedFixed,
        V1aFixed,
        sizeof(*V1aFixed)
        );


    //
    // Delete any cached display information
    //

    {
        ULONG OldTransactionDomainIndex = SampTransactionDomainIndex;
        SampTransactionDomainIndexGlobal = Index;

        NtStatus = SampMarkDisplayInformationInvalid(SampUserObjectType);
        NtStatus = SampMarkDisplayInformationInvalid(SampGroupObjectType);

        SampTransactionDomainIndexGlobal = OldTransactionDomainIndex;
    }



    if (NT_SUCCESS(NtStatus)) {

        //
        // Store the context handle in the defined_domain structure
        //

        SampDeleteContext(Domain->Context);
        Domain->Context = DomainContext;

    }


    return(NtStatus);


error_cleanup:

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "       Status is 0x%lx \n",
               NtStatus));

    if (DomainContext != NULL) {
        SampDeleteContext(DomainContext);
    }

    return(NtStatus);

}


NTSTATUS
SampCollisionError(
    IN SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine is called by SamICreateAccountByRid when there is a
    name or RID collision.  It accepts the type of account which caused
    the collision, and returns the appropriate error status.

Arguments:

    ObjectType - The type of account that has the same Rid or Name (but
        not both) as the account that was to be created.

Return Value:

    STATUS_USER_EXISTS - An object with the specified name could not be
        created because a User account with that name or RID already exists.

    STATUS_GROUP_EXISTS - An object with the specified name could not be
        created because a Group account with that name or RID already exists.

    STATUS_ALIAS_EXISTS - An object with the specified name could not be
        created because an Alias account with that name or RID already exists.

--*/
{

    SAMTRACE("SampCollisionError");

    //
    // Name collision.  Return offending RID and appropriate
    // error code.
    //

    switch ( ObjectType ) {

        case SampAliasObjectType: {

            return STATUS_ALIAS_EXISTS;
        }

        case SampGroupObjectType: {

            return STATUS_GROUP_EXISTS;
        }

        case SampUserObjectType: {

            return STATUS_USER_EXISTS;
        }
    }
    return STATUS_USER_EXISTS;
}



NTSTATUS
SamICreateAccountByRid(
    IN SAMPR_HANDLE DomainHandle,
    IN SAM_ACCOUNT_TYPE AccountType,
    IN ULONG RelativeId,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT ULONG *ConflictingAccountRid
    )

/*++

Routine Description:

    This service creates a user, group or alias account with a specific
    RID value.


Arguments:

    DomainHandle - A handle to an open domain.

    AccountType - Specifies which type of account is being created.

    RelativeId - The relative ID to be assigned to the account.  If an
        account of the specified type and specified RID value and
        specified name already exists, then it will be opened.  If an
        account exists with any of this information in conflict, then an
        error will be returned indicating what the problem is.

    AccountName - The name to assign to the account.  If an account of
        the specified type and specified RID value and specified name
        already exists, then it will be opened.  If an account exists with
        any of this information in conflict, then an error will be returned
        indicating what the problem is.

    DesiredAccess - Specifies the accesses desired to the account object.

    AccountHandle - Recieves a handle to the account object.

    ConflictingAccountRid - If another account with the same name or RID
        prevents this account from being created, then this will receive
        the RID of the conflicting account (in the case of conflicting
        RIDs, this means that we return the RID that was passed in).
        The error value indicates the type of the account.


Return Value:

    STATUS_SUCCESS - The object has been successfully opened or created.

    STATUS_OBJECT_TYPE_MISMATCH - The specified object type did not match
        the type of the object found with the specified RID.

    STATUS_USER_EXISTS - An object with the specified name could not be
        created because a User account with that name already exists.

    STATUS_GROUP_EXISTS - An object with the specified name could not be
        created because a Group account with that name already exists.

    STATUS_ALIAS_EXISTS - An object with the specified name could not be
        created because an Alias account with that name already exists.


--*/
{
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING          KeyName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    SAM_ACCOUNT_TYPE        ObjectType, SecondObjectType, ThirdObjectType;
    SID_NAME_USE            SidNameUse;
    HANDLE                  KeyHandle;
    NTSTATUS                NtStatus, IgnoreStatus,
                            NotFoundStatus, FoundButWrongStatus;
    ACCESS_MASK             GrantedAccess;
    ULONG                   LocalGroupType =  GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_RESOURCE_GROUP;
    ULONG                   GlobalGroupType =  GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_ACCOUNT_GROUP;

    SAMTRACE("SamICreateAccountByRid");

    ASSERT( RelativeId != 0 );

    switch ( AccountType ) {

        case SamObjectUser: {

            ObjectType = SampUserObjectType;
            SecondObjectType = SampAliasObjectType;
            ThirdObjectType = SampGroupObjectType;
            NotFoundStatus = STATUS_NO_SUCH_USER;
            FoundButWrongStatus = STATUS_USER_EXISTS;
            break;
        }

        case SamObjectGroup: {

            ObjectType = SampGroupObjectType;
            SecondObjectType = SampAliasObjectType;
            ThirdObjectType = SampUserObjectType;
            NotFoundStatus = STATUS_NO_SUCH_GROUP;
            FoundButWrongStatus = STATUS_GROUP_EXISTS;
            break;
        }

        case SamObjectAlias: {

            ObjectType = SampAliasObjectType;
            SecondObjectType = SampGroupObjectType;
            ThirdObjectType = SampUserObjectType;
            NotFoundStatus = STATUS_NO_SUCH_ALIAS;
            FoundButWrongStatus = STATUS_ALIAS_EXISTS;
            break;
        }

        default: {

            return( STATUS_INVALID_PARAMETER );
        }
    }

    //
    // See if the account specified already exists.
    //

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   0,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampLookupAccountRid(
                       DomainContext,
                       ObjectType,
                       (PUNICODE_STRING)AccountName,
                       NotFoundStatus,
                       ConflictingAccountRid,
                       &SidNameUse
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // The NAME exists; now we have to check the RID.
            //

            if ( (*ConflictingAccountRid) == RelativeId ) {

                //
                // The correct account already exists, so just open it.
                //

                SampSetTransactionWithinDomain(FALSE);

                NtStatus = SampOpenAccount(
                               ObjectType,
                               DomainHandle,
                               DesiredAccess,
                               RelativeId,
                               TRUE,    //we already have the lock
                               AccountHandle
                               );

                 goto Done;

            } else {

                //
                // An account with the given name, but a different RID, exists.
                // Return error.
                //

                NtStatus = FoundButWrongStatus;
            }

        } else {

            if ( NtStatus == NotFoundStatus ) {

                //
                // Account doesn't exist, that's good
                //

                NtStatus = STATUS_SUCCESS;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Check for name collision with 2nd object type
            //

            NtStatus = SampLookupAccountRid(
                           DomainContext,
                           SecondObjectType,
                           (PUNICODE_STRING)AccountName,
                           STATUS_UNSUCCESSFUL,
                           ConflictingAccountRid,
                           &SidNameUse
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // The name was found; return an error.
                //

                NtStatus = SampCollisionError( SecondObjectType );

            } else {

                if ( NtStatus == STATUS_UNSUCCESSFUL ) {

                    //
                    // Account doesn't exist, that's good
                    //

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }


        if (NT_SUCCESS(NtStatus)) {

            //
            // Check for name collision with 3rd object type
            //

            NtStatus = SampLookupAccountRid(
                           DomainContext,
                           ThirdObjectType,
                           (PUNICODE_STRING)AccountName,
                           STATUS_UNSUCCESSFUL,
                           ConflictingAccountRid,
                           &SidNameUse
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampCollisionError( ThirdObjectType );

            } else {

                if ( NtStatus == STATUS_UNSUCCESSFUL ) {

                    //
                    // Account doesn't exist, that's good
                    //

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }


        if (NT_SUCCESS(NtStatus))
        {
            SAMP_OBJECT_TYPE FoundObjectType;


            //
            // We didn't find the name as an alias, group or user.
            // Now, check to see if the RID is already in use.
            //

            NtStatus = SampLookupAccountName(
                                DomainContext->DomainIndex,
                                RelativeId,
                                NULL,
                                &FoundObjectType
                                );
            if (NT_SUCCESS(NtStatus))
            {
                if (SampUnknownObjectType!=FoundObjectType)
                {
                    NtStatus = SampCollisionError(FoundObjectType);
                    *ConflictingAccountRid = RelativeId;
                }
            }

        }


        if (NT_SUCCESS(NtStatus)) {

            //
            // We haven't found a conflicting account, so go ahead
            // and create this one with the name and RID specified.
            //

            switch ( AccountType ) {

                case SamObjectUser: {

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampCreateUserInDomain(
                                   DomainHandle,
                                   AccountName,
                                   USER_NORMAL_ACCOUNT,
                                   DesiredAccess,
                                   TRUE,
                                   FALSE,       // not loopback client
                                   AccountHandle,
                                   &GrantedAccess,
                                   &RelativeId
                                   );

                    break;
                }

                case SamObjectGroup: {

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampCreateGroupInDomain(
                                   DomainHandle,
                                   AccountName,
                                   DesiredAccess,
                                   TRUE,
                                   FALSE, // not loopback client
                                   GlobalGroupType,
                                   AccountHandle,
                                   &RelativeId
                                   );
                    break;
                }

                case SamObjectAlias: {

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampCreateAliasInDomain(
                                   DomainHandle,
                                   AccountName,
                                   DesiredAccess,
                                   TRUE,
                                   FALSE, // not loopback client
                                   LocalGroupType,
                                   AccountHandle,
                                   &RelativeId
                                   );
                    break;
                }
            }


            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // We may have created a new account.  Set the domain's RID
                // marker, if necessary, to make sure we don't re-use the
                // RID we just created.
                //

                PSAMP_DEFINED_DOMAINS Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

                if ( RelativeId >= Domain->CurrentFixed.NextRid ) {
                    Domain->CurrentFixed.NextRid = RelativeId + 1;
                }
            }
        }


Done:
        //
        // De-reference the domain object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    if ( NT_SUCCESS( NtStatus ) ) {

        SampSetTransactionWithinDomain(FALSE);
        NtStatus = SampReleaseWriteLock( TRUE );

    } else {

        IgnoreStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return( NtStatus );
}




NTSTATUS
SamIGetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    )

/*++

Routine Description:

    This routine retrieves the creation time and modified count of the
    domain.  This information is used as a serial number for the domain.

Arguments:

    DomainHandle - Handle to the domain being replicated.

    ModifiedCount - Retrieves the current count of modifications to the
        domain.

    CreationTime - Receives the date/time the domain was created.

Return Value:

    STATUS_SUCCESS - The service has completed successfully.

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;

    SAMTRACE("SamIGetSerialNumberDomain");

    SampAcquireReadLock();

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    NtStatus = SampLookupContext(
                   DomainContext,
                   0L,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        (*ModifiedCount) = Domain->NetLogonChangeLogSerialNumber;
        (*CreationTime) = Domain->UnmodifiedFixed.CreationTime;

        //
        // De-reference the domain object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    SampReleaseReadLock();

    return( NtStatus );
}



NTSTATUS
SamISetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    )

/*++

Routine Description:

    This routine causes the creation time and modified count of the
    domain to be replaced.  This information is used as a serial number
    for the domain.

Arguments:

    DomainHandle - Handle to the domain being replicated.

    ModifiedCount - Provides the current count of modifications to the
        domain.

    CreationTime - Provides the date/time the domain was created.

    StartOfFullSync - This boolean indicates whether a full sync is being
        initiated.  If this is TRUE, then a full sync is to follow and
        all existing domain information may be discarded.  If this is
        FALSE, then only specific domain information is to follow and all
        changes must not violate statndard SAM operation behaviour.

Return Value:

    STATUS_SUCCESS - The service has completed successfully.

    Other failures may be returned from SampReleaseWriteLock().

--*/
{
    LARGE_INTEGER           LargeOne, AdjustedModifiedCount;
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_DEFINED_DOMAINS   Domain;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;

    UNREFERENCED_PARAMETER( StartOfFullSync );

    SAMTRACE("SamISetSerialNumberDomain");

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        return(NtStatus);
    }

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    NtStatus = SampLookupContext(
                   DomainContext,
                   0L,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        //
        // Now set the Domain's ModifiedCount and CreationTime to the values
        // specified.
        //

        Domain->CurrentFixed.CreationTime = (*CreationTime);

        if ( SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole
            == DomainServerRoleBackup ) {

            //
            // Go ahead and use the ModifiedCount that was passed in.
            // Since this is a BDC, the commit code will not increment
            // the ModifiedCount.
            //

            Domain->NetLogonChangeLogSerialNumber = (*ModifiedCount);

        } else {

            //
            // This is a PDC, so the commit code will increment the
            // ModifiedCount before using it.  So decrement
            // it here so that it ends up at the right value.
            //


            AdjustedModifiedCount.QuadPart = ModifiedCount->QuadPart - 1 ;

            Domain->NetLogonChangeLogSerialNumber = AdjustedModifiedCount;
        }

        //
        // Update the "disk mirror" copy of the Modified Count. This ensures
        // that this will be written immediately rather than be lazy flushed.
        //

        Domain->CurrentFixed.ModifiedCount =(*ModifiedCount);

        if ( !( ModifiedCount->QuadPart == 0) ||
             !StartOfFullSync ) {

            //
            // If ModifiedCount is non-zero, we must be ending a full
            // or partial replication of the database...or perhaps we've
            // just finished a 128k chunk over a WAN or somesuch.  Let's
            // ask to flush this stuff out to disk right away, rather
            // than waiting for the flush thread to get around to it.
            //

            FlushImmediately = TRUE;
        }




        SampDiagPrint( DISPLAY_ROLE_CHANGES,
                       ("SAM: SamISetSerialNumberDomain\n"
                        "                  Old ModifiedId: [0x%lx, 0x%lx]\n"
                        "                  New ModifiedId: [0x%lx, 0x%lx]\n",
                        Domain->UnmodifiedFixed.ModifiedCount.HighPart,
                        Domain->UnmodifiedFixed.ModifiedCount.LowPart,
                        Domain->CurrentFixed.ModifiedCount.HighPart,
                        Domain->CurrentFixed.ModifiedCount.LowPart )
                      );


        //
        // De-reference the domain object
        // Don't save changes - the domain fixed info will be written
        // out when the write lock is released.
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));


        NtStatus = SampReleaseWriteLock( TRUE );

    } else {

        TmpStatus = SampReleaseWriteLock( FALSE );
    }

    return( NtStatus );
}

NTSTATUS
SampGetPrivateUserData(
    PSAMP_OBJECT UserContext,
    OUT PULONG DataLength,
    OUT PVOID *Data
    )

/*++

Routine Description:

    This service is used during replication of private user
    type-specific information.  It reads the private user information from
    the registry, and adjusts it if necessary (ie if the password history
    value is smaller than it used to be).

Arguments:

    UserContext - A handle to a User.

    DataLength - The length of the data returned.

    Data - Receives a pointer to a buffer of length DataLength allocated
        and returned by SAM.  The buffer must be freed to the process
        heap when it is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{
    NTSTATUS                NtStatus;
    UNICODE_STRING          TempString;
    UNICODE_STRING          StoredBuffer;
    PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PasswordData;
    PSAMP_DEFINED_DOMAINS   Domain;
    PVOID BufferPointer;
    ULONG PasswordHistoryLength;

    Domain = &SampDefinedDomains[ UserContext->DomainIndex ];
    PasswordHistoryLength = Domain->UnmodifiedFixed.PasswordHistoryLength;

    //
    // Keep a history of at least 2 for krbtgt account
    //

    if ((UserContext->TypeBody.User.Rid == DOMAIN_USER_RID_KRBTGT) &&
        ( PasswordHistoryLength<SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH))
    {
        PasswordHistoryLength = SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH;
    }

    *Data = NULL;
    //
    // Return data length as the maximum possible for this domain
    // - the size of the structure, plus the maximum size of the
    // NT and LM password histories.
    //

    *DataLength = ( ( PasswordHistoryLength )
        * ENCRYPTED_NT_OWF_PASSWORD_LENGTH ) +
        ( ( PasswordHistoryLength ) *
        ENCRYPTED_LM_OWF_PASSWORD_LENGTH ) +
        sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE );

    *Data = MIDL_user_allocate( *DataLength );

    if ( *Data == NULL ) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        PasswordData = (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE)*Data;
        PasswordData->DataType = 0;  // set correctly when we're done

        NtStatus = SampGetUnicodeStringAttribute(
                       UserContext,
                       SAMP_USER_DBCS_PWD,
                       FALSE,
                       &StoredBuffer
                       );

        if ( NT_SUCCESS( NtStatus ) ) {
            if (SampIsDataEncrypted(&StoredBuffer)) {
                NtStatus = SampDecryptSecretData(
                                &TempString,
                                LmPassword,
                                &StoredBuffer,
                                UserContext->TypeBody.User.Rid
                                );
            } else {
                TempString = StoredBuffer;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            PasswordData->CaseInsensitiveDbcs.Length = TempString.Length;
            PasswordData->CaseInsensitiveDbcs.MaximumLength = TempString.MaximumLength;
            PasswordData->CaseInsensitiveDbcs.Buffer = 0;

            RtlCopyMemory(
                &(PasswordData->CaseInsensitiveDbcsBuffer),
                TempString.Buffer,
                TempString.Length );

            if (TempString.Buffer != StoredBuffer.Buffer) {
                SampFreeUnicodeString(&TempString);
            }

            NtStatus = SampGetUnicodeStringAttribute(
                           UserContext,
                           SAMP_USER_UNICODE_PWD,
                           FALSE,
                           &StoredBuffer
                           );
            if ( NT_SUCCESS( NtStatus ) ) {
                if (SampIsDataEncrypted(&StoredBuffer)) {
                    NtStatus = SampDecryptSecretData(
                                    &TempString,
                                    NtPassword,
                                    &StoredBuffer,
                                    UserContext->TypeBody.User.Rid
                                    );
                } else {
                    TempString = StoredBuffer;
                }
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                PasswordData->CaseSensitiveUnicode.Length = TempString.Length;
                PasswordData->CaseSensitiveUnicode.MaximumLength = TempString.MaximumLength;
                PasswordData->CaseSensitiveUnicode.Buffer = 0;

                RtlCopyMemory(
                    &(PasswordData->CaseSensitiveUnicodeBuffer),
                    TempString.Buffer,
                    TempString.Length );

                if (TempString.Buffer != StoredBuffer.Buffer) {
                    SampFreeUnicodeString(&TempString);
                }

                NtStatus = SampGetUnicodeStringAttribute(
                               UserContext,
                               SAMP_USER_NT_PWD_HISTORY,
                               FALSE,
                               &StoredBuffer
                               );

                if ( NT_SUCCESS( NtStatus ) ) {
                    if (SampIsDataEncrypted(&StoredBuffer)) {
                        NtStatus = SampDecryptSecretData(
                                        &TempString,
                                        NtPasswordHistory,
                                        &StoredBuffer,
                                        UserContext->TypeBody.User.Rid
                                        );
                    } else {
                        TempString = StoredBuffer;
                    }
                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // If history is too long, must shorten here
                    //

                    PasswordData->NtPasswordHistory.Length = TempString.Length;
                    PasswordData->NtPasswordHistory.MaximumLength = TempString.MaximumLength;
                    PasswordData->NtPasswordHistory.Buffer = 0;

                    if ( PasswordData->NtPasswordHistory.Length > (USHORT)
                        ( PasswordHistoryLength
                        * ENCRYPTED_NT_OWF_PASSWORD_LENGTH ) ) {

                        PasswordData->NtPasswordHistory.Length = (USHORT)
                            ( PasswordHistoryLength
                            * ENCRYPTED_NT_OWF_PASSWORD_LENGTH );
                    }

                    //
                    // Put the body of the Nt password history
                    // immediately following the structure.
                    //

                    BufferPointer = (PVOID)(((PCHAR)PasswordData) +
                        sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE ) );

                    RtlCopyMemory(
                        BufferPointer,
                        TempString.Buffer,
                        PasswordData->NtPasswordHistory.Length );

                    if (TempString.Buffer != StoredBuffer.Buffer) {
                        SampFreeUnicodeString(&TempString);
                    }


                    NtStatus = SampGetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_LM_PWD_HISTORY,
                                   FALSE,
                                   &StoredBuffer
                                   );

                    if ( NT_SUCCESS( NtStatus ) ) {
                        if (SampIsDataEncrypted(&StoredBuffer)) {
                            NtStatus = SampDecryptSecretData(
                                            &TempString,
                                            LmPasswordHistory,
                                            &StoredBuffer,
                                            UserContext->TypeBody.User.Rid
                                            );
                        } else {
                            TempString = StoredBuffer;
                        }
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        PasswordData->LmPasswordHistory.Length = TempString.Length;
                        PasswordData->LmPasswordHistory.MaximumLength = TempString.MaximumLength;
                        PasswordData->LmPasswordHistory.Buffer = 0;

                        if ( PasswordData->LmPasswordHistory.Length > (USHORT)
                            ( PasswordHistoryLength
                            * ENCRYPTED_LM_OWF_PASSWORD_LENGTH ) ) {

                            PasswordData->LmPasswordHistory.Length = (USHORT)
                                ( PasswordHistoryLength
                                * ENCRYPTED_LM_OWF_PASSWORD_LENGTH );
                        }

                        //
                        // Put the body of the Lm password history
                        // immediately following the Nt password
                        // history.
                        //

                        BufferPointer = (PVOID)(((PCHAR)(BufferPointer)) +
                            PasswordData->NtPasswordHistory.Length );

                        RtlCopyMemory(
                            BufferPointer,
                            TempString.Buffer,
                            PasswordData->LmPasswordHistory.Length );

                        PasswordData->DataType = SamPrivateDataPassword;

                        if (TempString.Buffer != StoredBuffer.Buffer) {
                            SampFreeUnicodeString(&TempString);
                        }

                    }
                }
            }
        }
    }

    if  ((!NT_SUCCESS(NtStatus)) && (NULL!=*Data))
    {
        MIDL_user_free(*Data);
        *Data = NULL;
    }

    return( NtStatus );
}

VOID
SampGetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    )
/*++

    This routine retreives the modified count of the domain. This is used
    by ntdsa.dll. This routine does no database access, and does not acquire
    SAM lock. It returns the information from the in - memory structures


    Parameters

        DomainSid -- Sid specifying the domain
        SamSerialNumber -- The account database serial number is returned in here
        BuiltinSerialNumber -- The builtin database serial number is returned in here

    Return Values

        Void Function
--*/
{
    ULONG DomainIndex,
          BuiltinDomainIndex;

    for (DomainIndex=SampDsGetPrimaryDomainStart();
                DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid))
        {
            break;
        }
    }

    ASSERT(DomainIndex<SampDefinedDomainsCount);

    BuiltinDomainIndex = DomainIndex-1;

    *SamSerialNumber = SampDefinedDomains[DomainIndex].NetLogonChangeLogSerialNumber;
    *SamCreationTime = SampDefinedDomains[DomainIndex].UnmodifiedFixed.CreationTime;
    *BuiltinSerialNumber =
        SampDefinedDomains[BuiltinDomainIndex].NetLogonChangeLogSerialNumber;
    *BuiltinCreationTime =
        SampDefinedDomains[BuiltinDomainIndex].UnmodifiedFixed.CreationTime;
}


NTSTATUS
SampSetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    )
/*++

    This routine sets the modified count of the domain. This is used
    by ntdsa.dll.


    Parameters

        DomainSid -- Sid specifying the domain
        SamSerialNumber -- The account database serial number is returned in here
        BuiltinSerialNumber -- The builtin database serial number is returned in here

    Return Values

        Void Function
--*/
{
    ULONG DomainIndex,
          BuiltinDomainIndex;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // This routine can be called from within SAM/ntdsa, with
    // the sam lock held.
    //

    ASSERT(SampCurrentThreadOwnsLock());


    for (DomainIndex=SampDsGetPrimaryDomainStart();
            DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid))
        {
            break;
        }
    }

    ASSERT(DomainIndex<SampDefinedDomainsCount);

    BuiltinDomainIndex = DomainIndex-1;

    NtStatus = SampValidateDomainCache();
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    SampSetTransactionDomain(DomainIndex);

    SampDefinedDomains[DomainIndex].NetLogonChangeLogSerialNumber
            = *SamSerialNumber;
    SampDefinedDomains[DomainIndex].CurrentFixed.CreationTime
            = *SamCreationTime;

    SampDefinedDomains[DomainIndex].CurrentFixed.ModifiedCount
            = *SamSerialNumber;

    NtStatus = SampCommitChanges();
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    SampSetTransactionWithinDomain(FALSE);

    //
    // Validate the domain cache again, as commit changes can affect
    // it's status
    //

    NtStatus = SampValidateDomainCache();
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    SampSetTransactionDomain(BuiltinDomainIndex);

    SampDefinedDomains[BuiltinDomainIndex].NetLogonChangeLogSerialNumber
            = *BuiltinSerialNumber;
    SampDefinedDomains[BuiltinDomainIndex].CurrentFixed.CreationTime
            = *BuiltinCreationTime;

    SampDefinedDomains[BuiltinDomainIndex].CurrentFixed.ModifiedCount
            = *BuiltinSerialNumber;

    NtStatus = SampCommitChanges();
    if (!NT_SUCCESS(NtStatus))
        goto Error;



Error:

    SampSetTransactionWithinDomain(FALSE);

    return NtStatus;
}



NTSTATUS
SamIGetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN PSAMI_PRIVATE_DATA_TYPE PrivateDataType,
    OUT PBOOLEAN SensitiveData,
    OUT PULONG DataLength,
    OUT PVOID *Data
    )

/*++

Routine Description:

    This service is used to replicate private object type-specific
    information.  This information must be replicated for each instance
    of the object type that is replicated.

Arguments:

    SamHandle - A handle to a Domain, User, Group or Alias.

    PrivateDataType - Indicates which private data is being retrieved.
        The data type must correspond to the type of object that the
        handle is to.

    SensitiveData - Indicates that the data returned must be encrypted
        before being sent anywhere.

    DataLength - The length of the data returned.

    Data - Receives a pointer to a buffer of length DataLength allocated
        and returned by SAM.  The buffer must be freed to the process
        heap when it is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain;

    SAMTRACE("SamIGetPrivateData");

    SampAcquireReadLock();

    switch ( *PrivateDataType ) {

    case SamPrivateDataNextRid: {

        PSAMP_OBJECT            DomainContext;

        //
        // Validate type of, and access to object.
        //

        DomainContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       DomainContext,
                       0L,
                       SampDomainObjectType,           // ExpectedType
                       &FoundType
                       );

        if (NT_SUCCESS(NtStatus)) {

            PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData;

            //
            // Return the domain's NextRid.
            //

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

            *Data = MIDL_user_allocate( sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ) );

            if ( *Data == NULL ) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                NextRidData = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)*Data;
                NextRidData->NextRid = Domain->CurrentFixed.NextRid;
                NextRidData->DataType = SamPrivateDataNextRid;
            }

            *DataLength = sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE );

            *SensitiveData = FALSE;

            //
            // De-reference the object
            //

            IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        break;
    }

    case SamPrivateDataPassword: {

        PSAMP_OBJECT            UserContext;

        //
        // Validate type of, and access to object.
        //

        UserContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       UserContext,
                       0L,
                       SampUserObjectType,           //ExpectedType
                       &FoundType
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetPrivateUserData(
                           UserContext,
                           DataLength,
                           Data
                           );

            *SensitiveData = TRUE;

            //
            // De-reference the object
            //

            IgnoreStatus = SampDeReferenceContext( UserContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        break;
    }

    default: {

        //
        // Since caller is trusted, assume we've got a version mismatch
        // or somesuch.
        //

        NtStatus = STATUS_NOT_IMPLEMENTED;

        break;
    }
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    return( NtStatus );
}



NTSTATUS
SampSetPrivateUserData(
    PSAMP_OBJECT UserContext,
    IN ULONG DataLength,
    IN PVOID Data
    )

/*++

Routine Description:

    This service is used to replicate private user type-specific
    information.  It writes the private data (passwords and password
    histories) to the registry.


Arguments:

    UserContext - Handle to a User object.

    DataLength - The length of the data being set.

    Data - A pointer to a buffer of length DataLength containing the
        private data.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{
    NTSTATUS                NtStatus;
    UNICODE_STRING          StoredBuffer;
    SAMI_PRIVATE_DATA_PASSWORD_TYPE Buffer;
    PSAMI_PRIVATE_DATA_PASSWORD_TYPE PasswordData = &Buffer;
    PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PasswordDataRelative;
    BOOLEAN                 ReplicateImmediately = FALSE;

    ASSERT( Data != NULL );

    if ( ( Data != NULL ) &&
        ( DataLength >= sizeof(SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE) ) ) {

        PasswordDataRelative = (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE)Data;

        PasswordData->CaseInsensitiveDbcs.Length = PasswordDataRelative->CaseInsensitiveDbcs.Length;
        PasswordData->CaseInsensitiveDbcs.MaximumLength = PasswordDataRelative->CaseInsensitiveDbcs.MaximumLength;
        PasswordData->CaseInsensitiveDbcs.Buffer = (PWSTR)
            (&(PasswordDataRelative->CaseInsensitiveDbcsBuffer));

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        LmPassword,
                        &(PasswordData->CaseInsensitiveDbcs),
                        UserContext->TypeBody.User.Rid
                        );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                            UserContext,
                            SAMP_USER_DBCS_PWD,
                            &StoredBuffer
                            );

            SampFreeUnicodeString(&StoredBuffer);
        }

        if ( NT_SUCCESS( NtStatus ) ) {

            PasswordData->CaseSensitiveUnicode.Length = PasswordDataRelative->CaseSensitiveUnicode.Length;
            PasswordData->CaseSensitiveUnicode.MaximumLength = PasswordDataRelative->CaseSensitiveUnicode.MaximumLength;
            PasswordData->CaseSensitiveUnicode.Buffer = (PWSTR)
                (&(PasswordDataRelative->CaseSensitiveUnicodeBuffer));

            NtStatus = SampEncryptSecretData(
                            &StoredBuffer,
                            SampGetEncryptionKeyType(),
                            NtPassword,
                            &(PasswordData->CaseSensitiveUnicode),
                            UserContext->TypeBody.User.Rid
                            );

            if (NT_SUCCESS(NtStatus)) {

                 NtStatus = SampSetUnicodeStringAttribute(
                            UserContext,
                            SAMP_USER_UNICODE_PWD,
                            &StoredBuffer
                            );

                SampFreeUnicodeString(&StoredBuffer);
            }


            if ( NT_SUCCESS( NtStatus ) ) {

                PasswordData->NtPasswordHistory.Length = PasswordDataRelative->NtPasswordHistory.Length;
                PasswordData->NtPasswordHistory.MaximumLength = PasswordDataRelative->NtPasswordHistory.MaximumLength;
                PasswordData->NtPasswordHistory.Buffer =
                    (PWSTR)(((PCHAR)PasswordDataRelative) +
                    sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE ) );

                NtStatus = SampEncryptSecretData(
                                &StoredBuffer,
                                SampGetEncryptionKeyType(),
                                NtPasswordHistory,
                                &(PasswordData->NtPasswordHistory),
                                UserContext->TypeBody.User.Rid
                                );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_NT_PWD_HISTORY,
                                    &StoredBuffer
                                    );

                    SampFreeUnicodeString(&StoredBuffer);
                }



                if ( NT_SUCCESS( NtStatus ) ) {

                    PasswordData->LmPasswordHistory.Length = PasswordDataRelative->LmPasswordHistory.Length;
                    PasswordData->LmPasswordHistory.MaximumLength = PasswordDataRelative->LmPasswordHistory.MaximumLength;
                    PasswordData->LmPasswordHistory.Buffer =
                        (PWSTR)(((PCHAR)PasswordDataRelative) +
                        sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE )
                     +  PasswordDataRelative->NtPasswordHistory.Length  );

                    NtStatus = SampEncryptSecretData(
                                    &StoredBuffer,
                                    SampGetEncryptionKeyType(),
                                    LmPasswordHistory,
                                    &(PasswordData->LmPasswordHistory),
                                    UserContext->TypeBody.User.Rid
                                    );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampSetUnicodeStringAttribute(
                                        UserContext,
                                        SAMP_USER_LM_PWD_HISTORY,
                                        &StoredBuffer
                                        );

                        SampFreeUnicodeString(&StoredBuffer);
                    }


                }
            }
        }

    } else {

        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}


NTSTATUS
SamISetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN ULONG DataLength,
    IN PVOID Data
    )

/*++

Routine Description:

    This service is used to replicate private object type-specific
    information.  This information must be replicated for each instance
    of the object type that is replicated.


Arguments:

    SamHandle - Handle to a Domain, User, Group or Alias object.  See
        SamIGetPrivateInformation() for a list of supported object
        types.

    DataLength - The length of the data being set.

    Data - A pointer to a buffer of length DataLength containing the
        private data.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE        FoundType;
    BOOLEAN                 ReplicateImmediately = FALSE;

    SAMTRACE("SamISetPrivateData");

    ASSERT( Data != NULL );

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    switch ( *((PSAMI_PRIVATE_DATA_TYPE)(Data)) ) {

    case SamPrivateDataNextRid: {

        PSAMP_OBJECT            DomainContext;
        PSAMP_DEFINED_DOMAINS   Domain;

        //
        // Validate type of, and access to object.
        //

        DomainContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       DomainContext,
                       0L,
                       SampDomainObjectType,           // ExpectedType
                       &FoundType
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Set the domain's NextRid.
            //

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

            if ( ( Data != NULL ) &&
                ( DataLength == sizeof(SAMI_PRIVATE_DATA_NEXTRID_TYPE) ) ) {

                PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData;

                //
                // We can trust Data to be a valid pointer; since our
                // caller is trusted.
                //

                NextRidData = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)Data;

                //
                // We used to set the domain's NextRid here.  But we've
                // decided that, rather than trying to replicate an exact
                // copy of the database, we're going to try to patch any
                // problems as we replicate.  To ensure that we don't
                // create any problems on the way, we want to make sure
                // that the NextRid value on a BDC is NEVER decreased.
                // Not that it matters; nobody calls this anyway.  So the
                // Get/SetPrivateData code for domains could be removed.
                //

                // Domain->CurrentFixed.NextRid = NextRidData->NextRid;

            } else {

                NtStatus = STATUS_INVALID_PARAMETER;
            }

            //
            // De-reference the object
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampDeReferenceContext(
                               DomainContext,
                               TRUE
                               );
            } else {

                IgnoreStatus = SampDeReferenceContext(
                                   DomainContext,
                                   FALSE
                                   );
            }
        }

        break;
    }

    case SamPrivateDataPassword: {

        PSAMP_OBJECT            UserContext;

        //
        // Validate type of, and access to object.
        //

        UserContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       UserContext,
                       0L,
                       SampUserObjectType,           // ExpectedType
                       &FoundType
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampSetPrivateUserData(
                           UserContext,
                           DataLength,
                           Data
                           );
            //
            // De-reference the object, adding attribute changes to the
            // RXACT if everything went OK.
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampDeReferenceContext(
                           UserContext,
                           TRUE
                           );

            } else {

                IgnoreStatus = SampDeReferenceContext(
                               UserContext,
                               FALSE
                               );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }

        break;
    }

    default: {

        //
        // We've either got a version mismatch, or the caller passed us
        // bad data, or SamIGetPrivateData() never finished getting the
        // data into the buffer.
        //

        NtStatus = STATUS_INVALID_PARAMETER;

        break;
    }
    }


    //
    // Release the write lock - commit only if successful.
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampReleaseWriteLock( TRUE );

        //
        // No need to call SampNotifyNetlogonOfDelta, since the replicator
        // is the one that made this call.
        //

    } else {

        IgnoreStatus = SampReleaseWriteLock( FALSE );
    }

    return(NtStatus);
}

NTSTATUS
SampConvertToUniversalGroup(
    IN PSAMP_OBJECT DomainContext,
    IN ULONG        GroupRid
    )
/*++

    This routine converts the specified group, specified by GroupRid
    to be a universal group. This is used by SamISetMixedDomainFlag
    below.

    Arguments

    DomainContext -- Identifies the domain
    GroupRid      -- Identifies the group


    Return Values

    STATUS_SUCCESS
    Other error codes to indicate various failures

--*/
{
     SAMPR_HANDLE        GroupHandle=NULL;
     NTSTATUS            NtStatus = STATUS_SUCCESS;


     NtStatus = SamrOpenGroup(
                    DomainContext,
                    GROUP_ALL_ACCESS,
                    GroupRid,
                    &GroupHandle
                    );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // O.K we opened the account
        //

        NtStatus = SampWriteGroupType(
                        GroupHandle,
                        GROUP_TYPE_UNIVERSAL_GROUP|GROUP_TYPE_SECURITY_ENABLED,
                        TRUE // mixed domain bit is not set as yet
                        );

        //
        // Close the Handle
        //

        SamrCloseHandle(&GroupHandle);


    }


    return(NtStatus);
}



NTSTATUS
SamISetMixedDomainFlag(
    IN SAMPR_HANDLE DomainHandle
    )

/*++

Routine Description:


    This routine modify the group type of enterprise admins 
    and schema admins groups to be a universal group.

    It will NOT modify the in memory MixedDomain Flag, because

    1. we don't hold SAM lock
    2. the transaction is not committed yet.
    
    Finally, when the loopback transaction committed, 
    SampNotifyReplicatedInChange() will do the job for us.
   

    This Routine does not yet still handle multiple hosted domains

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Currently always returned from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG DomainIndex = DOMAIN_START_DS;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT) DomainHandle;


    //
    // Modify the group type of the enterprise admins group
    // to be a universal group.
    //

    NtStatus = SampConvertToUniversalGroup(
                     DomainContext,
                     DOMAIN_GROUP_RID_ENTERPRISE_ADMINS
                     );

    if (STATUS_NO_SUCH_GROUP==NtStatus)
    {
        //
        // Quite O.K to not have the group, we need not be root domain
        //

        NtStatus = STATUS_SUCCESS;
    }


    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Modify the group type of the schema admins group
    // to be a universal group.
    //

    NtStatus = SampConvertToUniversalGroup(
                     DomainContext,
                     DOMAIN_GROUP_RID_SCHEMA_ADMINS
                     );

    if (STATUS_NO_SUCH_GROUP==NtStatus)
    {
        //
        // Quite O.K to not have the group, we need not be root domain
        //

        NtStatus = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(NtStatus))
       goto Error;


Error:

    return(NtStatus);
}



NTSTATUS
SamrTestPrivateFunctionsDomain(
    IN SAMPR_HANDLE DomainHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    DomainHandle - Handle to the domain being tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{
#if SAM_SERVER_TESTS

    LARGE_INTEGER ModifiedCount1;
    LARGE_INTEGER CreationTime1;
    PSAMP_DEFINED_DOMAINS   Domain;
    NTSTATUS NtStatus, TmpStatus;
    SAMI_PRIVATE_DATA_TYPE DataType = SamPrivateDataNextRid;
    SAMI_PRIVATE_DATA_NEXTRID_TYPE LocalNextRidData;
    PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData1 = NULL;
    PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData2 = NULL;
    PVOID   NextRidDataPointer = NULL;
    ULONG   DataLength = 0;
    BOOLEAN SensitiveData = TRUE;

    SAMTRACE("SamrTestPrivateFunctionsDomain");

    Domain = &SampDefinedDomains[ ((PSAMP_OBJECT)DomainHandle)->DomainIndex ];

    //
    // Test SamIGetSerialNumberDomain().  Just do a GET to make sure we
    // don't blow up.
    //

    NtStatus = SamIGetSerialNumberDomain(
                   DomainHandle,
                   &ModifiedCount1,
                   &CreationTime1 );

    //
    // Test SamISetSerialNumberDomain().
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        LARGE_INTEGER ModifiedCount2;
        LARGE_INTEGER ModifiedCount3;
        LARGE_INTEGER CreationTime2;
        LARGE_INTEGER CreationTime3;

        //
        // Try a simple SET to make sure we don't blow up.
        //

        ModifiedCount2.HighPart = 7;
        ModifiedCount2.LowPart = 4;
        CreationTime2.HighPart = 6;
        CreationTime2.LowPart = 9;

        NtStatus = SamISetSerialNumberDomain(
                       DomainHandle,
                       &ModifiedCount2,
                       &CreationTime2,
                       FALSE );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Now do a GET to see if our SET worked.
            //

            NtStatus = SamIGetSerialNumberDomain(
                           DomainHandle,
                           &ModifiedCount3,
                           &CreationTime3 );

            if ( ( CreationTime2.HighPart != CreationTime3.HighPart ) ||
                ( CreationTime2.LowPart != CreationTime3.LowPart ) ) {

                NtStatus = STATUS_DATA_ERROR;
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Do another SET to put CreationTime back where it should
                // be.  ModifiedCount will be 1 too big, so what.
                //

                NtStatus = SamISetSerialNumberDomain(
                               DomainHandle,
                               &ModifiedCount1,
                               &CreationTime1,
                               FALSE );
            }
        }
    }

    //
    // Test SamIGetPrivateData().
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SamIGetPrivateData(
                       DomainHandle,
                       &DataType,
                       &SensitiveData,
                       &DataLength,
                       &NextRidDataPointer );

        if ( NT_SUCCESS( NtStatus ) ) {

            NextRidData1 = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)NextRidDataPointer;

            if ( ( DataLength != sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ) ) ||
                ( SensitiveData != FALSE ) ||
                ( NextRidData1->DataType != SamPrivateDataNextRid ) ||
                ( NextRidData1->NextRid != Domain->CurrentFixed.NextRid ) ) {

                NtStatus = STATUS_DATA_ERROR;
            }
        }
    }

//    //
//    // Test SamISetPrivateData().
//    //
//    // NO, don't test it, since it no longer does anything.  We don't
//    // ever want NextRid to get set, because we never want it to get
//    // smaller.
//
//    if ( NT_SUCCESS( NtStatus ) ) {
//
//        //
//        // First do a random domain set to make sure we don't blow up.
//        //
//
//        LocalNextRidData.DataType = SamPrivateDataNextRid;
//        LocalNextRidData.NextRid = 34567;
//
//        NtStatus = SamISetPrivateData(
//                       DomainHandle,
//                       sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ),
//                       &LocalNextRidData
//                       );
//
//        if ( NT_SUCCESS( NtStatus ) ) {
//
//            //
//            // Now do a domain get to make sure our set worked.
//            //
//
//            NtStatus = SamIGetPrivateData(
//                           DomainHandle,
//                           &DataType,
//                           &SensitiveData,
//                           &DataLength,
//                           &NextRidDataPointer );
//
//            if ( NT_SUCCESS( NtStatus ) ) {
//
//                //
//                // Verify the data is as we set it.
//                //
//
//                NextRidData2 = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)NextRidDataPointer;
//
//                if ( NextRidData2->NextRid != LocalNextRidData.NextRid ) {
//
//                    NtStatus = STATUS_DATA_ERROR;
//                }
//
//                //
//                // Now do a domain set to restore things to their original state.
//                //
//
//                TmpStatus = SamISetPrivateData(
//                               DomainHandle,
//                               sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ),
//                               NextRidData1
//                               );
//
//                if ( NT_SUCCESS( NtStatus ) ) {
//
//                    NtStatus = TmpStatus;
//                }
//            }
//        }
//
//        if ( NextRidData1 != NULL ) {
//
//            MIDL_user_free( NextRidData1 );
//        }
//
//        if ( NextRidData2 != NULL ) {
//
//            MIDL_user_free( NextRidData2 );
//        }
//    }

    //
    // Test SamICreateAccountByRid().
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        RPC_UNICODE_STRING  AccountNameU;
        RPC_UNICODE_STRING  AccountName2U;
        SAMPR_HANDLE UserAccountHandle;
        SAMPR_HANDLE BadAccountHandle;
        SAMPR_HANDLE GroupAccountHandle;
        NTSTATUS TmpStatus;
        ULONG RelativeId = 1111;
        ULONG ConflictingAccountRid;
        BOOLEAN AllTestsCompleted = FALSE;

        //
        // Create a unique account - a user with a known name and RID.
        //

        RtlInitUnicodeString( &AccountNameU, L"USER1SRV" );
        RtlInitUnicodeString( &AccountName2U, L"USER2SRV" );

        NtStatus = SamICreateAccountByRid(
                       DomainHandle,
                       SamObjectUser,
                       RelativeId,
                       &AccountNameU,
                       USER_ALL_ACCESS,
                       &UserAccountHandle,
                       &ConflictingAccountRid );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // User is open.  Close it, and make the same call as above to
            // make sure that the user gets opened.  We'll need it open
            // later to delete it anyway.
            //

            TmpStatus = SamrCloseHandle( &UserAccountHandle );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            NtStatus = SamICreateAccountByRid(
                           DomainHandle,
                           SamObjectUser,
                           RelativeId,
                           &AccountName,
                           USER_ALL_ACCESS,
                           &UserAccountHandle,
                           &ConflictingAccountRid );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Make same call as above, but with a different RID.
                // Should get an error because of the name collision.
                //

                NtStatus = SamICreateAccountByRid(
                               DomainHandle,
                               SamObjectUser,
                               RelativeId + 1,
                               &AccountName,
                               0L,
                               &BadAccountHandle,
                               &ConflictingAccountRid );

                if ( NtStatus == STATUS_USER_EXISTS ) {

                    //
                    // Make same call as above, but with a different name.  Should
                    // get an error because of the RID collision.
                    //

                    NtStatus = SamICreateAccountByRid(
                                   DomainHandle,
                                   SamObjectUser,
                                   RelativeId,
                                   &AccountName2,
                                   0L,
                                   &BadAccountHandle,
                                   &ConflictingAccountRid );

                    if ( NtStatus == STATUS_USER_EXISTS ) {

                        //
                        // Create a different type - a group - with the
                        // user's RID.  Should get an error because of
                        // the RID collision.
                        //

                        NtStatus = SamICreateAccountByRid(
                                       DomainHandle,
                                       SamObjectGroup,
                                       RelativeId,
                                       &AccountName,
                                       0L,
                                       &BadAccountHandle,
                                       &ConflictingAccountRid );

                        if ( NtStatus == STATUS_USER_EXISTS ) {

                            //
                            // Try a different type - a group - with a
                            // different name, but still the same RID.
                            // This should still fail due to the RID
                            // collision.
                            //

                            NtStatus = SamICreateAccountByRid(
                                           DomainHandle,
                                           SamObjectGroup,
                                           RelativeId,
                                           &AccountName2,
                                           0L,
                                           &BadAccountHandle,
                                           &ConflictingAccountRid );

                            if ( NtStatus == STATUS_USER_EXISTS ) {

                                //
                                // Create a group with the user's name, but
                                // a different RID.  This should fail
                                // because of the name collision.
                                //

                                NtStatus = SamICreateAccountByRid(
                                               DomainHandle,
                                               SamObjectGroup,
                                               RelativeId + 1,
                                               &AccountName,
                                               GROUP_ALL_ACCESS,
                                               &GroupAccountHandle,
                                               &ConflictingAccountRid );

                                if ( NT_SUCCESS( NtStatus ) ) {

                                    //
                                    // Ack!  This shouldn't have happened.
                                    // Close and delete the group we just created.
                                    //

                                    TmpStatus = SamrDeleteGroup( &GroupAccountHandle );
                                    ASSERT( NT_SUCCESS( TmpStatus ) );
                                    NtStatus = STATUS_UNSUCCESSFUL;

                                }  else {

                                    if ( NtStatus == STATUS_USER_EXISTS ) {

                                        NtStatus = STATUS_SUCCESS;
                                        AllTestsCompleted = TRUE;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            //
            // Now delete the user.
            //

            TmpStatus = SamrDeleteUser( &UserAccountHandle );
            ASSERT( NT_SUCCESS( TmpStatus ) );
        }

        if ( ( !AllTestsCompleted ) && ( NtStatus == STATUS_SUCCESS ) ) {

            //
            // STATUS_SUCCESS means everything succeeded (it was set after
            // the last one succeeded) or a test that was supposed to fail
            // didn't.  If the former, set an error.
            //

            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }

    return( NtStatus );

#else

    return( STATUS_NOT_IMPLEMENTED );

#endif  // SAM_SERVER_TESTS

}



NTSTATUS
SamrTestPrivateFunctionsUser(
    IN SAMPR_HANDLE UserHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    UserHandle - Handle to the user being tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{

#if SAM_SERVER_TESTS

    UNICODE_STRING WorkstationsU, LogonWorkstationU;
    LOGON_HOURS LogonHours;
    PVOID LogonHoursPointer, WorkstationsPointer;
    LARGE_INTEGER LogoffTime, KickoffTime;
    NTSTATUS NtStatus, TmpStatus;
    SAMI_PRIVATE_DATA_TYPE DataType = SamPrivateDataPassword;
    PVOID   PasswordDataPointer = NULL;
    PCHAR   BufferPointer;
    ULONG   OriginalDataLength = 0;
    ULONG   DataLength = 0;
    USHORT  i;
    BOOLEAN SensitiveData = FALSE;
    SAMI_PRIVATE_DATA_PASSWORD_TYPE LocalPasswordData;
    PSAMI_PRIVATE_DATA_PASSWORD_TYPE PasswordData1;
    PSAMI_PRIVATE_DATA_PASSWORD_TYPE PasswordData2;
    PUSER_ALL_INFORMATION All = NULL;
    PUSER_ALL_INFORMATION All2 = NULL;

    SAMTRACE("SamrTestPrivateFunctionsUser");

    // --------------------------------------------------------------
    // Test Query and SetInformationUser for UserAllInformation level
    //
    // The handle is passed to us from user space.  Make it look like
    // a trusted handle so we can test the trusted stuff.
    //

    ((PSAMP_OBJECT)(UserHandle))->TrustedClient = TRUE;

    NtStatus = SamrQueryInformationUser(
                   UserHandle,
                   UserAllInformation,
                   (PSAMPR_USER_INFO_BUFFER *)&All
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // Now change some of the data, and set it
        //

        RtlInitUnicodeString( (PUNICODE_STRING)(&All->FullName), L"FullName" );

        RtlInitUnicodeString( (PUNICODE_STRING)(&All->HomeDirectory), L"HomeDirectory" );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->HomeDirectoryDrive),
            L"HomeDirectoryDrive"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->ScriptPath),
            L"ScriptPath"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->ProfilePath),
            L"ProfilePath"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->AdminComment),
            L"AdminComment"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->WorkStations),
            L"WorkStations"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->UserComment),
            L"UserComment"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->Parameters),
            L"Parameters"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->NtPassword),
            L"12345678"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->LmPassword),
            L"87654321"
            );

        All->BadPasswordCount = 5;
        All->LogonCount = 6;
        All->CountryCode = 7;
        All->CodePage = 8;

        All->PasswordExpired = TRUE;
        All->NtPasswordPresent = TRUE;
        All->LmPasswordPresent = TRUE;

        All->LogonHours.UnitsPerWeek = 7;

        All->WhichFields =
                            USER_ALL_FULLNAME |
                            USER_ALL_HOMEDIRECTORY |
                            USER_ALL_HOMEDIRECTORYDRIVE |
                            USER_ALL_SCRIPTPATH |
                            USER_ALL_PROFILEPATH |
                            USER_ALL_ADMINCOMMENT |
                            USER_ALL_WORKSTATIONS |
                            USER_ALL_USERCOMMENT |
                            USER_ALL_PARAMETERS |
                            USER_ALL_BADPASSWORDCOUNT |
                            USER_ALL_LOGONCOUNT |
                            USER_ALL_COUNTRYCODE |
                            USER_ALL_CODEPAGE |
                            USER_ALL_PASSWORDEXPIRED |
                            USER_ALL_LMPASSWORDPRESENT |
                            USER_ALL_NTPASSWORDPRESENT |
                            USER_ALL_LOGONHOURS;

        NtStatus = SamrSetInformationUser(
                       UserHandle,
                       UserAllInformation,
                       (PSAMPR_USER_INFO_BUFFER)All
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SamrQueryInformationUser(
                           UserHandle,
                           UserAllInformation,
                           (PSAMPR_USER_INFO_BUFFER *)&All2
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Verify that queried info is as we set it
                //

                if (

                    //
                    // Fields that we didn't touch.  Note that private
                    // data and PasswordMustChange will change anyway
                    // due to password changes.
                    //

                    ( All2->WhichFields != (USER_ALL_READ_GENERAL_MASK    |
                                           USER_ALL_READ_LOGON_MASK       |
                                           USER_ALL_READ_ACCOUNT_MASK     |
                                           USER_ALL_READ_PREFERENCES_MASK |
                                           USER_ALL_READ_TRUSTED_MASK) ) ||
                    ( !(All->LastLogon.QuadPart == All2->LastLogon.QuadPart) ) ||
                    ( !(All->LastLogoff.QuadPart == All2->LastLogoff.QuadPart) ) ||
                    ( !(All->PasswordLastSet.QuadPart == All2->PasswordLastSet.QuadPart) ) ||
                    ( !(All->AccountExpires.QuadPart == All2->AccountExpires.QuadPart) ) ||
                    ( !(All->PasswordCanChange.QuadPart == All2->PasswordCanChange.QuadPart) ) ||
                    (  (All->PasswordMustChange.QuadPart == All2->PasswordMustChange.QuadPart) ) ||
                    (RtlCompareUnicodeString(
                        &(All->UserName),
                        &(All2->UserName),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->PrivateData),
                        &(All2->PrivateData),
                        FALSE) == 0) ||
                    ( All->SecurityDescriptor.Length !=
                        All2->SecurityDescriptor.Length ) ||
                    ( All->UserId != All2->UserId ) ||
                    ( All->PrimaryGroupId != All2->PrimaryGroupId ) ||
                    ( All->UserAccountControl != All2->UserAccountControl ) ||
                    ( All->PrivateDataSensitive !=
                        All2->PrivateDataSensitive ) ||

                    // Fields that we changed

                    (RtlCompareUnicodeString(
                        &(All->FullName),
                        &(All2->FullName),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->HomeDirectory),
                        &(All2->HomeDirectory),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->HomeDirectoryDrive),
                        &(All2->HomeDirectoryDrive),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->ScriptPath),
                        &(All2->ScriptPath),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->ProfilePath),
                        &(All2->ProfilePath),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->AdminComment),
                        &(All2->AdminComment),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->WorkStations),
                        &(All2->WorkStations),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->UserComment),
                        &(All2->UserComment),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->Parameters),
                        &(All2->Parameters),
                        FALSE) != 0) ||
                    ( All->BadPasswordCount != All2->BadPasswordCount ) ||
                    ( All->LogonCount != All2->LogonCount ) ||
                    ( All->CountryCode != All2->CountryCode ) ||
                    ( All->CodePage != All2->CodePage ) ||
                    ( All->PasswordExpired != All2->PasswordExpired ) ||
                    ( All->LmPasswordPresent != All2->LmPasswordPresent ) ||
                    ( All->NtPasswordPresent != All2->NtPasswordPresent ) ||
                    ( All->LogonHours.UnitsPerWeek !=
                        All2->LogonHours.UnitsPerWeek )
                    ) {

                    NtStatus = STATUS_DATA_ERROR;
                }

                MIDL_user_free( All2 );
            }
        }

        MIDL_user_free( All );
    }

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    // --------------------------------------------------------------
    // Test SamIAccountRestrictions
    // NOTE: We really should have more tests for this
    //

    RtlInitUnicodeString( &WorkstationsU, L"machine1,CHADS2   chads1" );

    NtStatus = SamrSetInformationUser(
                   UserHandle,
                   UserWorkStationsInformation,
                   (PSAMPR_USER_INFO_BUFFER) &WorkstationsU
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    LogonHours.UnitsPerWeek = 168;
    LogonHours.LogonHours = MIDL_user_allocate( 21 );
    ASSERT( LogonHours.LogonHours != NULL );

    for ( i = 0; i < 21; i++ ) {

        LogonHours.LogonHours[i] = 0xa1;
    }

    NtStatus = SamrSetInformationUser(
                   UserHandle,
                   UserLogonHoursInformation,
                   (PSAMPR_USER_INFO_BUFFER)&LogonHours
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    LogonHoursPointer = NULL;

    NtStatus = SamrQueryInformationUser(
                   UserHandle,
                   UserLogonHoursInformation,
                   (PSAMPR_USER_INFO_BUFFER *)&LogonHoursPointer
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    WorkstationsPointer = NULL;

    NtStatus = SamrQueryInformationUser(
                   UserHandle,
                   UserWorkStationsInformation,
                   (PSAMPR_USER_INFO_BUFFER *)&WorkstationsPointer
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    RtlInitUnicodeString( &WorkstationsU, L"ChadS2" );

    NtStatus = SamIAccountRestrictions(
                   UserHandle,
                   &LogonWorkstation,
                   WorkstationsPointer,
                   LogonHoursPointer,
                   &LogoffTime,
                   &KickoffTime
                   );

    if ( NtStatus == STATUS_INVALID_LOGON_HOURS ) {

        //
        // We hate to use 0xff all the time as a test value, but using
        // 0xA1 as a test value means that this test may fail depending
        // on when it runs.  So only IF we get this error, will we try
        // again with 0xff as the logon hours.
        //

        LogonHours.UnitsPerWeek = 168;

        for ( i = 0; i < 21; i++ ) {

            LogonHours.LogonHours[i] = 0xff;
        }

        NtStatus = SamrSetInformationUser(
                       UserHandle,
                       UserLogonHoursInformation,
                       (PSAMPR_USER_INFO_BUFFER)&LogonHours
                       );
        ASSERT( NT_SUCCESS( NtStatus ) ) ;

        MIDL_user_free( LogonHoursPointer );
        LogonHoursPointer = NULL;

        NtStatus = SamrQueryInformationUser(
                       UserHandle,
                       UserLogonHoursInformation,
                       (PSAMPR_USER_INFO_BUFFER *)&LogonHoursPointer
                       );
        ASSERT( NT_SUCCESS( NtStatus ) ) ;

        NtStatus = SamIAccountRestrictions(
                       UserHandle,
                       &LogonWorkstationU,
                       WorkstationsPointer,
                       LogonHoursPointer,
                       &LogoffTime,
                       &KickoffTime
                       );
    }

    MIDL_user_free( LogonHours.LogonHours );

    MIDL_user_free( LogonHoursPointer );
    MIDL_user_free( WorkstationsPointer );

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

#if 0

    //
    // SamISetPrivateData/SamTGetPrivateData is broken in that the structure it
    // expects is not marshalled with respect to different platforms
    //

    // --------------------------------------------------------------
    // Test SamIGetPrivateData
    //

    NtStatus = SamIGetPrivateData(
                   UserHandle,
                   &DataType,
                   &SensitiveData,
                   &OriginalDataLength,
                   &PasswordDataPointer );

    if ( NT_SUCCESS( NtStatus ) ) {

        PasswordData1 = (PSAMI_PRIVATE_DATA_PASSWORD_TYPE)PasswordDataPointer;

        if ( ( !( OriginalDataLength >= sizeof( SAMI_PRIVATE_DATA_PASSWORD_TYPE ) ) ) ||
            ( SensitiveData != TRUE ) ||
            ( PasswordData1->DataType != SamPrivateDataPassword ) ) {

            NtStatus = STATUS_DATA_ERROR;
        }
    }



    // --------------------------------------------------------------
    // Now test SamISetPrivateData() for user objects.
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // First do a random user set to make sure we don't blow up.
        //

        LocalPasswordData.DataType = SamPrivateDataPassword;

        LocalPasswordData.CaseInsensitiveDbcs.Length = ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseInsensitiveDbcs.MaximumLength = ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseInsensitiveDbcs.Buffer = (PWSTR)&(LocalPasswordData.CaseInsensitiveDbcsBuffer);

        BufferPointer = (PCHAR)&(LocalPasswordData.CaseInsensitiveDbcsBuffer);

        for ( i = 0; i < ENCRYPTED_LM_OWF_PASSWORD_LENGTH; i++ ) {

            *BufferPointer++ = (CHAR)(i + 12);
        }

        LocalPasswordData.CaseSensitiveUnicode.Length = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseSensitiveUnicode.MaximumLength = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseSensitiveUnicode.Buffer = (PWSTR)&(LocalPasswordData.CaseSensitiveUnicodeBuffer);

        BufferPointer = (PCHAR)(&LocalPasswordData.CaseSensitiveUnicodeBuffer);

        for ( i = 0; i < ENCRYPTED_NT_OWF_PASSWORD_LENGTH; i++ ) {

            *BufferPointer++ = (CHAR)(i + 47);
        }

        LocalPasswordData.LmPasswordHistory.Length = 0;
        LocalPasswordData.LmPasswordHistory.MaximumLength = 0;
        LocalPasswordData.LmPasswordHistory.Buffer = (PWSTR)
            ( &LocalPasswordData + sizeof( SAMI_PRIVATE_DATA_PASSWORD_TYPE ) );

        LocalPasswordData.NtPasswordHistory.Length = 0;
        LocalPasswordData.NtPasswordHistory.MaximumLength = 0;
        LocalPasswordData.NtPasswordHistory.Buffer = (PWSTR)
            ( &LocalPasswordData + sizeof( SAMI_PRIVATE_DATA_PASSWORD_TYPE ) );

        NtStatus = SamISetPrivateData(
                       UserHandle,
                       sizeof( LocalPasswordData ),
                       &LocalPasswordData
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Now do a user get to make sure our set worked.
            //

            NtStatus = SamIGetPrivateData(
                           UserHandle,
                           &DataType,
                           &SensitiveData,
                           &DataLength,
                           &PasswordDataPointer );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Verify the data is as we set it.
                //

                PasswordData2 = (PSAMI_PRIVATE_DATA_PASSWORD_TYPE)PasswordDataPointer;

                if ( ( PasswordData2->DataType != LocalPasswordData.DataType ) ||

                    ( PasswordData2->CaseInsensitiveDbcs.Length != LocalPasswordData.CaseInsensitiveDbcs.Length ) ||

                    ( PasswordData2->CaseSensitiveUnicode.Length != LocalPasswordData.CaseSensitiveUnicode.Length ) ||

                    ( PasswordData2->LmPasswordHistory.Length != LocalPasswordData.LmPasswordHistory.Length ) ||

                    ( PasswordData2->NtPasswordHistory.Length != LocalPasswordData.NtPasswordHistory.Length ) ||

                    ( RtlCompareMemory(
                          &LocalPasswordData.CaseInsensitiveDbcsBuffer,
                          &(PasswordData2->CaseInsensitiveDbcsBuffer),
                          ENCRYPTED_LM_OWF_PASSWORD_LENGTH) != ENCRYPTED_LM_OWF_PASSWORD_LENGTH ) ||

                    ( RtlCompareMemory(
                          &LocalPasswordData.CaseSensitiveUnicodeBuffer,
                          &(PasswordData2->CaseSensitiveUnicodeBuffer),
                          ENCRYPTED_NT_OWF_PASSWORD_LENGTH) != ENCRYPTED_NT_OWF_PASSWORD_LENGTH )

                    ) {

                    NtStatus = STATUS_DATA_ERROR;
                }

                //
                // Now do a user set to restore things to their original state.
                //

                TmpStatus = SamISetPrivateData(
                               UserHandle,
                               OriginalDataLength,
                               PasswordData1
                               );

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = TmpStatus;
                }
            }
        }

        if ( PasswordData1 != NULL ) {

            MIDL_user_free( PasswordData1 );
        }

        if ( PasswordData2 != NULL ) {

            MIDL_user_free( PasswordData2 );
        }
    }

    return( NtStatus );

#endif

#else

    return( STATUS_NOT_IMPLEMENTED );

#endif  // SAM_SERVER_TESTS

}



NTSTATUS
SampBuildDomainKeyName(
    OUT PUNICODE_STRING DomainKeyName,
    IN PUNICODE_STRING DomainName OPTIONAL
    )

/*++

Routine Description:

    This routine builds the name of a domain registry key.
    The name produced is relative to the SAM root and will be the name of
    key whose name is the name of the domain.

    The name built up is comprized of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the domain.


    For example, given a DomainName of "ABC_DOMAIN" this would
    yield a resultant DomainKeyName of "DOMAINS\ABC_DOMAIN"



    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    DomainKeyName - The address of a unicode string whose buffer is to be
        filled in with the full name of the registry key.  If successfully
        created, this string must be released with SampFreeUnicodeString()
        when no longer needed.


    DomainName - The name of the domain.  This string is not modified.


Return Value:

    STATUS_SUCCESS - DomainKeyName points at the full key name.

--*/
{
    NTSTATUS NtStatus;
    USHORT TotalLength, DomainNameLength;

    SAMTRACE("SampBuildDomainKeyName");

    //
    // Allocate a buffer large enough to hold the entire name.
    // Only count the domain name if it is passed.
    //

    DomainNameLength = 0;
    if (ARGUMENT_PRESENT(DomainName)) {
        DomainNameLength = DomainName->Length + SampBackSlash.Length;
    }

    TotalLength =   SampNameDomains.Length          +
                    DomainNameLength               +
                    (USHORT)(sizeof(UNICODE_NULL)); // for null terminator

    NtStatus = SampInitUnicodeString( DomainKeyName, TotalLength );
    if (NT_SUCCESS(NtStatus)) {

        //
        // "DOMAINS"
        //

        NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomains);
        if (NT_SUCCESS(NtStatus)) {

            if (ARGUMENT_PRESENT(DomainName)) {

                //
                // "DOMAINS\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // "DOMAINS\(domain name)"
                    //

                    NtStatus = SampAppendUnicodeString(
                                   DomainKeyName,
                                   DomainName
                                   );
                }
            }
        }
    }


    //
    // Clean-up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampFreeUnicodeString( DomainKeyName );
    }

    return(NtStatus);

}

//
// SampDsGetPrimaryDomainStart is used to correctly set the starting index in the
// SampDefinedDomains array whenever it is accessed in the SAM code. In the
// case of an NT workstation or member server, the first two entries of the
// array correspond to registry data, hence the index is started at zero. In
// the case of a domain controller, the DS-based data is not stored in the
// first two elements (those may be used for crash-recovery data, still ob-
// tained from the registry), but rather in subsequent array elements, hence
// is start at index DOMAIN_START_DS.
//

ULONG
SampDsGetPrimaryDomainStart(VOID)
{
    ULONG   DomainStart = DOMAIN_START_REGISTRY;

    if (TRUE == SampUseDsData)
    {
        // Domain Controller
        DomainStart = DOMAIN_START_DS;
    }

    return DomainStart;
}


NTSTATUS
SampSetMachineAccountOwnerDuringDCPromo(
    IN PDSNAME pDsName,
    IN PSID    NewOwner
    )
/*++
Routine Description:

    This routine does

    1. Set the Owner of the Machine Account to Domain Administrators Group
    2. Add ms-ds-CreatorSid attribute to this machine account. The creator
       SID indicates the real creator of this machine.

    Should Only been called for machine account created by privilege.

Parameters:

    pDsName -- Object DS Name

    NewOwner -- New Owner in the Security descriptor

Return Values:

    STATUS_SUCCESS
    STATUS_INTERNAL_ERROR
    or other DS returned error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ATTRTYP  AttrTypToRead[] = {SAMP_USER_SECURITY_DESCRIPTOR};
    ATTRVAL  AttrValsToRead[] = {0, NULL};
    DEFINE_ATTRBLOCK1(AttrsToRead, AttrTypToRead, AttrValsToRead);
    ATTRBLOCK   ReadAttrs;

    ATTRTYP  AttrTypToSet[] = {SAMP_USER_SECURITY_DESCRIPTOR, SAMP_USER_CREATOR_SID};
    ATTRVAL  AttrValsToSet[] = { {0, NULL}, {0, NULL} };
    DEFINE_ATTRBLOCK2(AttrsToSet, AttrTypToSet, AttrValsToSet);

    PSID    CreatorOwner = NULL;
    PSID    Group = NULL;
    PACL    Dacl = NULL;
    PACL    Sacl = NULL;
    PSECURITY_DESCRIPTOR OldDescriptor = NULL;
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    ULONG   NewDescriptorLength = 0;


    //
    // Retrieve the old security descriptor
    //
    NtStatus = SampDsRead(pDsName,
                          0,
                          SampUserObjectType,
                          &AttrsToRead,
                          &ReadAttrs
                          );

    if (NT_SUCCESS(NtStatus))
    {
        if ((1==ReadAttrs.attrCount) &&
            (NULL != ReadAttrs.pAttr) &&
            (1==ReadAttrs.pAttr[0].AttrVal.valCount) &&
            (NULL!=ReadAttrs.pAttr[0].AttrVal.pAVal) )
        {
            OldDescriptor = (PSECURITY_DESCRIPTOR)ReadAttrs.pAttr[0].AttrVal.pAVal[0].pVal;

            CreatorOwner = GetOwner(OldDescriptor);
            Group = GetGroup(OldDescriptor);
            Sacl = GetSacl(OldDescriptor);
            Dacl = GetDacl(OldDescriptor);

            if (CreatorOwner && Group && Sacl && Dacl)
            {
                //
                // Construct new security descriptor with the desired Owner
                //
                NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                                    NewOwner,
                                    Group,
                                    Dacl,
                                    Sacl,
                                    &NewDescriptorLength,
                                    &NewDescriptor
                                    );

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Set the New Security Descriptor
                    //
                    AttrsToSet.pAttr[0].AttrVal.pAVal[0].pVal = (PUCHAR) NewDescriptor;
                    AttrsToSet.pAttr[0].AttrVal.pAVal[0].valLen = NewDescriptorLength;

                    //
                    // Add ms-ds-CreatorSid attribute
                    //
                    AttrsToSet.pAttr[1].AttrVal.pAVal[0].pVal = (PUCHAR) CreatorOwner;
                    AttrsToSet.pAttr[1].AttrVal.pAVal[0].valLen = RtlLengthSid(CreatorOwner);

                    //
                    // Call into DS api with SAM_LAZY_COMMIT flag
                    //
                    NtStatus = SampDsSetAttributes(
                                        pDsName,
                                        SAM_LAZY_COMMIT,    // during DCPromo,
                                        REPLACE_ATT,
                                        SampUserObjectType,
                                        &AttrsToSet
                                        );
                }
            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
    }

    //
    // Free memory if necessary
    //
    if (NULL != NewDescriptor)
    {
        MIDL_user_free(NewDescriptor);
    }

    return NtStatus;
}


VOID
SampDenyDeletion(
    IN PSID OldOwner,
    IN OUT PACL DAcl
    )
/*++
Routine Description:

    Users can create machine account in domain if they have the
    privilege. The default security descriptor will grant deletion
    right to the creator owner. Since deleted machine accounts
    (tombstone) are no longer counted during MachineAccountQuota
    calculation, we need to make sure the privileged machine
    account creator owner can not delete the machine account.

    This routine scans the DACL on the machine object, remove
    the deletion access from any GRANT aces in the DACL that
    have the OldOwner SID in the ACE.


Arguments:

    OldOwner - Indicator the SID the ACE should be applied to.

    DAcl - pointer to DACL

Return Value:

    None.

--*/
{
    ACE     *pAce = NULL;
    PSID    pSid = NULL;
    ULONG   i;

    for (i = 0; i < DAcl->AceCount; i++)
    {
        // get the i'st ACE
        pAce = GetAcePrivate(DAcl, i);

        if (NULL == pAce)
        {
            continue;
        }

        //
        // we did not check ACCESS_ALLOWED_OBJECT_ACE because
        //
        // 1. change the default schema is a rare operation
        //    we don't expect to happen so often.
        //
        // 2. Even we check ACCESS_ALLOWED_OBJECT_ACE, administrators
        //    can still grant other access to the trustee (SID inside
        //    the ACE), such as create child access right, which will
        //    introduce the similar deny service attack
        //

        if (IsAccessAllowedAce(pAce) &&
            !(INHERIT_ONLY_ACE & ((PACE_HEADER)pAce)->AceFlags))
        {
            pSid = SidFromAce(pAce);

            if ((NULL!=pSid) && 
                (RtlEqualSid(OldOwner, pSid)))
            {
                ACCESS_MASK * AccessMask;

                AccessMask = &(((ACCESS_ALLOWED_ACE*)pAce)->Mask);
                (*AccessMask) &= (~(ACTRL_DS_DELETE_TREE|DELETE));

                continue;
            }
        }
    }

    return;
}




NTSTATUS
SampSetMachineAccountOwner(
    IN PSAMP_OBJECT UserContext,
    IN PSID NewOwner
    )
/*++
Routine Description:

    This routine sets the Owner in the passed in User's Security
    Descriptor.

Parameters:

    UserContext -- User Context

    NewOwner -- Pointer to a SID (new owner)

Return Values:

    NTSTATUS Code - STATUS_SUCCESS or other if error

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR OldDescriptor = NULL;
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    ULONG   NewDescriptorLength = 0;
    PSID    OldOwner = NULL;
    PSID    Group = NULL;
    PACL    Dacl = NULL;
    PACL    Sacl = NULL;
    ULONG   Revision;

    //
    // Get the current security descriptor so we can
    // change the owner field.
    //

    NtStatus = SampGetAccessAttribute(
                            UserContext,
                            SAMP_USER_SECURITY_DESCRIPTOR,
                            FALSE,   // don't make copy
                            &Revision,
                            &OldDescriptor
                            );

    if (NT_SUCCESS(NtStatus))
    {
        OldOwner = GetOwner(OldDescriptor);
        Group = GetGroup(OldDescriptor);
        Sacl = GetSacl(OldDescriptor);
        Dacl = GetDacl(OldDescriptor);


        if (OldOwner && Dacl)
        {
            SampDenyDeletion(OldOwner, Dacl);
        }

        if (Group && Sacl && Dacl)
        {
            //
            // Construct the new Security Descriptor using
            // the Administrators Alias SID as the owner
            //
            NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                                    NewOwner,
                                    Group,
                                    Dacl,
                                    Sacl,
                                    &NewDescriptorLength,
                                    &NewDescriptor
                                    );

        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // Write the new security descriptor into the object
        //
        NtStatus = SampSetAccessAttribute(
                            UserContext,
                            SAMP_USER_SECURITY_DESCRIPTOR,
                            NewDescriptor,
                            NewDescriptorLength
                            );
    }

    if (NULL != NewDescriptor)
    {
        MIDL_user_free(NewDescriptor);
    }

    return NtStatus;
}



NTSTATUS
SampCheckQuotaForPrivilegeMachineAccountCreation(
    VOID
    )
/*++
Routine Description

    First, this routine reads value of attribute (ms-ds-MachineAccountQuota)
    from Domain Object.

    Second, search how many machine accounts have been created by the current
    logged on user.

    Based on per-Domain Quota and used quota, figure out whether there is quota
    left or not.

Parameter

    None

Return Value

    STATUS_SUCCESS -- There is quota left.

    error

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       MachineAccountQuota = 0;
    ULONG       UsedQuota = 0;
    PTOKEN_OWNER    Owner = NULL;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup = NULL;
    ATTRTYP     AttrTypToRead[] = {SAMP_DOMAIN_MACHINE_ACCOUNT_QUOTA};
    ATTRVAL     AttrValsToRead[] = {0, NULL};
    DEFINE_ATTRBLOCK1(AttrsToRead, AttrTypToRead, AttrValsToRead);
    ATTRBLOCK   ReadAttrs;
    PULONG  FilterValue = NULL;


    ASSERT(SampUseDsData);
    if (!SampUseDsData)
    {
        return NtStatus;
    }

    //
    // set fDSA, otherwise, the client might be denied for reading
    // the Domain Object or searching deleted object.
    //
    SampSetDsa(TRUE);

    //
    // Read the highest Quota from the Domain Object.
    // This value could be changed by Administrator etc.
    //

    NtStatus = SampDsRead(ROOT_OBJECT,          // object
                          0,                    // Flags
                          SampDomainObjectType, // SAM object type
                          &AttrsToRead,         // attribute to read
                          &ReadAttrs            // result
                          );

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        //
        // per-domain Quota is not set yet.
        // Maybe administrator does not want to enforce the quota.
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Read Machine Account Quota Failed. Machine Quota may not be set yet.\n"));

        return STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(NtStatus))
    {
        //
        // Machine Account Quota has been set. retrieve the value
        //
        ASSERT(1 == ReadAttrs.attrCount);
        ASSERT(NULL != ReadAttrs.pAttr);
        ASSERT(1 == ReadAttrs.pAttr[0].AttrVal.valCount);
        ASSERT(NULL != ReadAttrs.pAttr[0].AttrVal.pAVal);


        if ((1 == ReadAttrs.attrCount) &&
            (NULL != ReadAttrs.pAttr) &&
            (1 == ReadAttrs.pAttr[0].AttrVal.valCount) &&
            (NULL != ReadAttrs.pAttr[0].AttrVal.pAVal) )
        {
            // retrieve the machineAccoutQuota
            MachineAccountQuota = * ((ULONG *)ReadAttrs.pAttr[0].AttrVal.pAVal[0].pVal);
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Machine Account Quota is %d\n", MachineAccountQuota));
        }
    }

    //
    // Figure out the quota consumed.
    //
    if (NT_SUCCESS(NtStatus))
    {
        FILTER  DsFilter;
        ULONG   SamAccountTypeLo, SamAccountTypeHi;
        ULONG   MaximumNumberOfEntries;
        SEARCHRES   *SearchRes = NULL;
        ATTRTYP AttrTypesToSrch[] = { SAMP_FIXED_USER_ACCOUNT_CONTROL };
        ATTRVAL AttrValsToSrch[] = {0, NULL};
        DEFINE_ATTRBLOCK1(AttrsToSrch, AttrTypesToSrch, AttrValsToSrch);

        //
        // Get the current client's Self SID from client token
        //
        NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                                 &Owner,
                                 &PrimaryGroup
                                 );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // build DS Filter
        //
        RtlZeroMemory(&DsFilter, sizeof(FILTER));

        DsFilter.choice = FILTER_CHOICE_ITEM;
        DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        DsFilter.FilterTypes.
            Item.FilTypes.ava.type = ATT_MS_DS_CREATOR_SID;
        DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = RtlLengthSid(Owner->Owner);


        //
        // Copy Self SID
        //
        FilterValue = MIDL_user_allocate(RtlLengthSid(Owner->Owner));
        if (NULL == FilterValue)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlZeroMemory(FilterValue, RtlLengthSid(Owner->Owner));
        RtlCopyMemory(FilterValue, Owner->Owner, RtlLengthSid(Owner->Owner));

        DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)FilterValue;


        //
        // Call SampDsDoSearch(); do NOT include deleted objects
        //
        NtStatus = SampDsDoSearch2(0,
                                   NULL,
                                   ROOT_OBJECT,
                                   &DsFilter,
                                   0,
                                   SampUserObjectType,
                                   &AttrsToSrch,
                                   (0 == MachineAccountQuota) ? 2: MachineAccountQuota + 1,
                                   0,
                                   &SearchRes
                                   );

        //
        // Get Used Quota
        //
        if ( !NT_SUCCESS(NtStatus) || (NULL == SearchRes) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SampDsDoSearch2 Failed NtStatus ==> %x\n",
                       NtStatus));

            goto Error;
        }

        ASSERT(NULL != SearchRes);
        UsedQuota = SearchRes->count;
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Used Quota is %d\n",
                   UsedQuota));
    }

    //
    // Check whether the creator still have quota or not
    //
    if (NT_SUCCESS(NtStatus))
    {
        if (UsedQuota >= MachineAccountQuota)
        {
            NtStatus = STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED;
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Machine Account Quota Exceeded\n"));
        }
    }

Error:

    if (FilterValue)
    {
        MIDL_user_free(FilterValue);
    }

    if (Owner)
    {
        MIDL_user_free(Owner);
    }

    if (PrimaryGroup)
    {
        MIDL_user_free(PrimaryGroup);
    }

    return NtStatus;
}



NTSTATUS
SampDoUserCreationChecks(
    IN PSAMP_OBJECT DomainContext,
    IN  ULONG   AccountType,
    OUT BOOLEAN *CreateByPrivilege,
    OUT ULONG   *pAccessRestriction
    )
/*++

    This Routine Does the Appropriate Sam Access Checks for creating Users.
    Access checks done are different for DS and Registry Mode. In DS mode
    fDSA is typically reset, so that the DS does the appropriate access check,
    except for the case where a machine account is created through privileges.


    DomainContext -- Pointer to the Domain Object Context
    AccountType   -- Specifies the account type field
    fCreateByPrivilege -- Indicates that a machine account creation is proceeding by
                          privilege

    Return Values:

        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        STATUS_INVALID_DOMAIN_ROLE

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;

    *CreateByPrivilege = FALSE;


    if (IsDsObject(DomainContext))
    {
        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext as needed
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        0, // No Accesses are required, Core DS will check access
                        SampDomainObjectType,
                        &FoundType
                        );

        //
        // In the DS case do the following
        //
        // 1. Trusted Clients always have access provided they opened the domain handle
        //    with the required access
        //
        // 2. Check if a machine account is being created, and if so then
        //    wether you have the privilege. If you have the privilege, then
        //    you create using the privilege. fDSA is set to true in this case
        //
        // 3. If you do not have the privilege then you may try your luck with the
        //    core DS. fDSA is set to false,the DS will do the access check and may
        //    return an access denied.
        //
        //    The way the access ck works is tat DOMIN_CREATE* access is always granted
        //    Here we test the mask to ensure that DOMAIN_CREATE was asked for while
        //    opening the handle. If the caller is not trusted we would set fDSA to false
        //    in order to delegate the ck to the core DS.
        //
        // 4. We do not apply the Privilege Test during Loopback cases. This is because
        //    we always want the DS access check to happen, as non SAM properties may be
        //    passed in and we do not know how to check these. Also note that the privilege
        //    definition is join workstations to domain, which technically speaking is
        //    different from creating a machine account through LDAP
        //
        // 5. InterDomain trust accounts are created only by trusted callers. Therefore enforce
        //    that the context is a trusted client if the account type is an intedomain trust
        //    account.
        //


        if (NT_SUCCESS(NtStatus))
        {
            //
            // Check the granted access field in the context
            //

            NtStatus = (DomainContext->GrantedAccess & DOMAIN_CREATE_USER)
                            ?STATUS_SUCCESS:STATUS_ACCESS_DENIED;

            //
            // Interdomain trust accounts can be created only by trusted callers
            //

            if ((NT_SUCCESS(NtStatus))
                && (AccountType==USER_INTERDOMAIN_TRUST_ACCOUNT)
                && (!DomainContext->TrustedClient))
            {
                NtStatus = STATUS_ACCESS_DENIED;
            }

            //
            // check whether the client has the right to create a Domain Controller
            // account.
            //

            //
            // the right required on the domain NC head to replicate is tested
            // at here
            //

            if ((NT_SUCCESS(NtStatus)) &&
                (!DomainContext->TrustedClient) &&
                (USER_SERVER_TRUST_ACCOUNT == AccountType))
            {
                NtStatus = SampValidateDomainControllerCreation(DomainContext);
            }

            if (NT_SUCCESS(NtStatus))
            {
                DSNAME  * LoopbackObject;




                if (!SampExistsDsLoopback(&LoopbackObject))
                {
                    //
                    // Apply the access and Privilege Checks as described above.
                    //

                    if (USER_WORKSTATION_TRUST_ACCOUNT==AccountType)
                    {
                        //
                        // Case of a Machine Account, Check to see if we have
                        // privileges to do so
                        //

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                    TRUE,       // ImpersonateClient
                                    SE_MACHINE_ACCOUNT_PRIVILEGE,
                                    NULL        // ClientId - optional
                                    );

                        if (STATUS_PRIVILEGE_NOT_HELD==NtStatus)
                        {
                            //
                            // We do not have the privilege; Reset the status code
                            // to STATUS_SUCCESS. The DS may allow the creation if
                            // the caller had the right access
                            //

                            NtStatus = STATUS_SUCCESS;



                        }
                        else
                        {
                            //
                            // We are creating accounts, with the privilege. Turn off DS access
                            // checks. Note Access Restrictions do not apply in DS mode. We always
                            // obtain the security descriptor from the schema, and set owner and
                            // group appropriately
                            //

                            *CreateByPrivilege = TRUE;
                        }
                    }
                }
            }

            //
            // Dereference domain context when failure
            //
            if (!NT_SUCCESS(NtStatus))
            {
                IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);

                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }
    }
    else
    {
        //
        // Registry Case. In this case first do the access check
        //

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_CREATE_USER,             // DesiredAccess
                        SampDomainObjectType,           // ExpectedType
                        &FoundType
                        );

        //
        // if we don't have DOMAIN_CREATE_USER access, then see
        // if we are creating a machine account and try for DOMAIN_LOOKUP.
        // If this works, then we can see if the client has
        // SE_CREATE_MACHINE_ACCOUNT_PRIVILEGE.
        //

        if ( (NtStatus == STATUS_ACCESS_DENIED) &&
             (AccountType == USER_WORKSTATION_TRUST_ACCOUNT) )
        {

            SampSetTransactionWithinDomain(FALSE);

            NtStatus = SampLookupContext(
                           DomainContext,
                           DOMAIN_LOOKUP,                   // DesiredAccess
                           SampDomainObjectType,            // ExpectedType
                           &FoundType
                           );

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampRtlWellKnownPrivilegeCheck(
                                    TRUE,       // ImpersonateClient
                                    SE_MACHINE_ACCOUNT_PRIVILEGE,
                                    NULL       // ClientId - optional
                                    );
                if (NtStatus == STATUS_PRIVILEGE_NOT_HELD)
                {
                    NtStatus = STATUS_ACCESS_DENIED;
                }

                if (NT_SUCCESS(NtStatus))
                {

                    //
                    // Tell our caller that we are creating by Privilege
                    //

                    *CreateByPrivilege = TRUE;
                    *pAccessRestriction = DELETE |
                                          USER_WRITE |
                                          USER_FORCE_PASSWORD_CHANGE;
                }
            }
        }
    }

    return NtStatus;
}

NTSTATUS
SampDoGroupCreationChecks(
    IN PSAMP_OBJECT DomainContext
    )
/*++

    This Routine Does the Appropriate Sam Access Checks for creating Groups
    Access checks done are different for DS and Registry Mode. In DS mode
    fDSA is typically reset, so that the DS does the appropriate access check,
    except for the case where a machine account is created through privileges.


    DomainContext -- Pointer to the Domain Object Context

        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        STATUS_INVALID_DOMAIN_ROLE

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;


    if (IsDsObject(DomainContext))
    {

        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext as needed
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        0, // No Accesses are required, Core DS will check access
                        SampDomainObjectType,
                        &FoundType
                        );

        //
        // In the DS case do the following
        //
        // 1. Trusted Clients always have access. Check the domain handle and if
        //    its opened with the right access, they can sail through. The creation
        //    will then proceed with fDSA set.
        //
        // 2. Else fDSA will be set to false,the DS will do the access check and may
        //    return an access denied.
        //    The way the access ck works is tat DOMIN_CREATE* access is always granted
        //    Here we test the mask to ensure that DOMAIN_CREATE was asked for while
        //    opening the handle. If the caller is not trusted we would set fDSA to false
        //    in order to delegate the ck to the core DS.
        //



        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = (DomainContext->GrantedAccess & DOMAIN_CREATE_GROUP)
                        ?STATUS_SUCCESS:STATUS_ACCESS_DENIED;
        }

    }
    else
    {
        //
        // Registry Case. In this case first do the access check
        //

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_CREATE_GROUP,             // DesiredAccess
                        SampDomainObjectType,           // ExpectedType
                        &FoundType
                        );

    }

    return NtStatus;
}

NTSTATUS
SampDoAliasCreationChecks(
    IN PSAMP_OBJECT DomainContext
    )
/*++

    This Routine Does the Appropriate Sam Access Checks for creating Groups
    Access checks done are different for DS and Registry Mode. In DS mode
    fDSA is typically reset, so that the DS does the appropriate access check,
    except for the case where a machine account is created through privileges.


    DomainContext -- Pointer to the Domain Object Context

        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        STATUS_INVALID_DOMAIN_ROLE

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;




    if (IsDsObject(DomainContext))
    {

        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext as needed
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        0, // No Accesses are required, Core DS will check access
                        SampDomainObjectType,
                        &FoundType
                        );

        //
        // In the DS case do the following
        //
        // 1. Trusted Clients always have access. Check the domain handle and if
        //    its opened with the right access, they can sail through. The creation
        //    will then proceed with fDSA set.
        //
        // 2. Else fDSA will be set to false,the DS will do the access check and may
        //    return an access denied.
        //    The way the access ck works is tat DOMIN_CREATE* access is always granted
        //    Here we test the mask to ensure that DOMAIN_CREATE was asked for while
        //    opening the handle. If the caller is not trusted we would set fDSA to false
        //    in order to delegate the ck to the core DS.


        if (NT_SUCCESS(NtStatus))
        {
             NtStatus = (DomainContext->GrantedAccess & DOMAIN_CREATE_ALIAS)
                            ?STATUS_SUCCESS:STATUS_ACCESS_DENIED;

        }

    }
    else
    {
        //
        // Registry Case. In this case first do the access check
        //

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_CREATE_ALIAS,             // DesiredAccess
                        SampDomainObjectType,           // ExpectedType
                        &FoundType
                        );


    }

    return NtStatus;
}



NTSTATUS
SampCheckForDuplicateSids(
    PSAMP_OBJECT DomainContext,
    ULONG   NewAccountRid
    )
/*++

    Routine Description
        This routine checks for the existance of an object with a RID that is
        about to be issued, in a seperate newly begun transaction. The purpose
        of the routine is for error checking only.

    Parameter:

        DomainContext -- The domain context in which to locate the RID

        NewAccountRid --- Rid of the new account

    Return Values

        STATUS_SUCCESS
        STATUS_INTERNAL_ERROR

  --*/
{
    PVOID   ExistingThreadState = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME  * ConflictingObject = NULL;

#if DBG
    #define ENABLE_DUPLICATE_SID_CHECKS 1
#endif
#ifdef ENABLE_DUPLICATE_SID_CHECKS

    if (TRUE==SampUseDsData)
    {
        //
        // In DS mode check for duplicates
        //
        //
        // Save the thread state.
        //

        ExistingThreadState = THSave();


        NtStatus = SampDsLookupObjectByRid(
                    SampDefinedDomains[DomainContext->DomainIndex].Context->ObjectNameInDs,
                    NewAccountRid,
                    &ConflictingObject
                    );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // We Found an Object, Too Bad, we are about to issue a duplicate Sid
            //

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "About to Issue a Duplicate Sid. This condition should never "
                       "Legally occur and points to either a timing or transactioning "
                       "Problem \n"));

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "NewRid = %x\n",
                       NewAccountRid));

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Conflicting Object = %x\n",ConflictingObject));

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Existing Thread State = %x\n",
                       ExistingThreadState));

            if ( IsDebuggerPresent())
               DebugBreak();
            NtStatus = STATUS_INTERNAL_ERROR;

            MIDL_user_free(ConflictingObject);
        }
        else
        {
            // We don't expect duplicate Sids

            NtStatus = STATUS_SUCCESS;
        }

        SampMaybeEndDsTransaction(TransactionCommit);

        THRestore(ExistingThreadState);
    }
    else
    {
        //
        // No Duplicate Sid detection in Registry Mode
        //
        NtStatus = STATUS_SUCCESS;
    }

#endif

    return NtStatus;
}

ULONG
SampDefaultPrimaryGroup(
    PSAMP_OBJECT    UserContext,
    ULONG           AccountType
    )
/*++

    Routine Description

        Returns the Default Primary Group given the User account
        control and the context

    Parameters

          UserContext -- The Context of the User
          AccountType -- The User account Control

    Return Values

          The Rid of the Primary Group
--*/
{

    //
    // Support for domain Computers and Domain Controllers is not yet
    // enabled. When this support is enabled the code in the #if 0 will
    // activated
    //


    if ((IsDsObject(UserContext))
                      && (AccountType & USER_WORKSTATION_TRUST_ACCOUNT))
    {
        return DOMAIN_GROUP_RID_COMPUTERS;
    }
    else if ((IsDsObject(UserContext))
          && (AccountType & USER_SERVER_TRUST_ACCOUNT))
    {
        return DOMAIN_GROUP_RID_CONTROLLERS;
    }
    else
    {
        return DOMAIN_GROUP_RID_USERS;
    }

    return (DOMAIN_GROUP_RID_USERS);

}



NTSTATUS
SamIDsCreateObjectInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PRPC_UNICODE_STRING  AccountName,
    IN ULONG UserAccountType, 
    IN ULONG GroupType,
    IN ACCESS_MASK  DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT PULONG  GrantedAccess,
    IN OUT PULONG RelativeId
    )
/*++
Routine Description:

    This routine is used by DS (Loopback client) to create account in domain 

Parameters:

Return Values:

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE("SamIDsCreateObjectInDomain");

    //
    // verify the object type, should be the one we know
    // 
    ASSERT((SampUserObjectType == ObjectType) ||
           (SampGroupObjectType == ObjectType) ||
           (SampAliasObjectType == ObjectType));


    switch (ObjectType)
    {
    case SampUserObjectType:

        ASSERT(0 != UserAccountType);

        NtStatus = SampCreateUserInDomain(
                                DomainHandle,       // DomainHandle
                                AccountName,        // AccountName
                                UserAccountType,    // User account type
                                DesiredAccess,      // Desired Access
                                FALSE,              // Write Lock Held
                                TRUE,               // Loopback Client
                                AccountHandle,      // Account Handle
                                GrantedAccess,      // GrantedAccess
                                RelativeId          // Object Rid
                                );
        break;

    case SampGroupObjectType:

        NtStatus = SampCreateGroupInDomain(
                                DomainHandle,       // DomainHandle
                                AccountName,        // Account Name
                                DesiredAccess,      // Desired Access
                                FALSE,              // Write Lock Held
                                TRUE,               // Loopback Client
                                GroupType,          // GroupType
                                AccountHandle,      // AccountHandle
                                RelativeId          // Object Rid
                                );

        break;

    case SampAliasObjectType:

        NtStatus = SampCreateAliasInDomain(
                                DomainHandle,       // DomainHandle
                                AccountName,        // AccountName
                                DesiredAccess,      // DesiredAccess
                                FALSE,              // WriteLockHeld
                                TRUE,               // Loopback Client
                                GroupType,          // Group Type
                                AccountHandle,      // AccountHandle
                                RelativeId          // Object Rid
                                );

        break;

    default:

        ASSERT(FALSE && "Wrong Object Type!");
        NtStatus = STATUS_INVALID_PARAMETER;
        break;
    }


    return( NtStatus );

}

WCHAR AccountNameEncodingTable[32] = {
L'0',L'1',L'2',L'3',L'4',L'5',L'6',L'7',
L'8',L'9',L'A',L'B',L'C',L'D',L'E',L'F',
L'G',L'H',L'I',L'J',L'K',L'L',L'M',L'N',
L'O',L'P',L'Q',L'R',L'S',L'T',L'U',L'V' };

NTSTATUS
SampGetAccountNameFromRid(
    OUT PRPC_UNICODE_STRING AccountName,
    IN ULONG Rid
    )
{
    ULONG i;
    LARGE_INTEGER Random;

    //
    // Generate a 64 bit random quantity
    //

    if (!CDGenerateRandomBits((PUCHAR) &Random.QuadPart, sizeof(Random.QuadPart)))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
     

    //
    // The account name that we generate will be 20 Chars long
    //

    AccountName->Length = 20 * sizeof(WCHAR);
    AccountName->MaximumLength = AccountName->Length;

    AccountName->Buffer = MIDL_user_allocate(AccountName->Length);
    if (NULL==AccountName->Buffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // The first character in the account name is a $ sign 
    //

    AccountName->Buffer[0] = L'$';

    //
    // The next 6 chars are the least 30 bits of the RID that are base 32 encoded
    //

    for (i=1;i<=6;i++)
    {

         //
         // Lookup the char corresponding to the last 5 bits of the RID
         //

         AccountName->Buffer[i] = AccountNameEncodingTable[(Rid & 0x1F)];

         //
         // Shift the RID right by 5 places
         //

         Rid = Rid >> 5;
    }

    //
    // The next char is a "-" to make the name more readable
    //
 
    AccountName->Buffer[7] = L'-';

    //
    // The next 12 chars are formed by base 32 encoding the last 60
    // bits of random bits. 
    //

    for (i=8;i<=19;i++)
    {
         //
         // Lookup the char corresponding to the last 5 bits 
         //

         AccountName->Buffer[i] = AccountNameEncodingTable[(Random.QuadPart & 0x1F)];

         //
         // Shift  right by 5 places
         //
         Random.QuadPart = Random.QuadPart >> 5;
    }



    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsdsply.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsdsply.c

Abstract:

    This file contains services for  implementing the Display Information
    API from the DS.

    

Author:

    Murli Satagopan   (Murlis)  17 December 1996

Environment:

    User Mode - Win32

Revision History:
    


--*/


#include <samsrvp.h>
#include <dslayer.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <lmaccess.h>


#define MAX_ENTRIES_TO_QUERY_FROM_DS    100
#define MAX_ENTRIES_TO_RETURN_TO_CLIENT 100
#define MAX_ENTRIES_TO_RETURN_TO_TRUSTED_CLIENTS 131072
#define MAX_RID 0x7FFFFFFF


//
// Prototypes of functions used in this file only
//

NTSTATUS
SampDsBuildAccountRidFilter(
    PSID    StartingSid,
    PSID    EndingSid,
    ULONG   AccountType,
    FILTER  * Filter                
    );

NTSTATUS
SampDsBuildQDIFilter(
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    FILTER  *QDIFilter                
    );

VOID
SampDsFreeAccountRidFilter(
    FILTER * Filter
    );

VOID
SampDsFreeQDIFilter(
    FILTER * QDIFilter
    );

NTSTATUS
SampDsCleanQDIBuffer(
  DOMAIN_DISPLAY_INFORMATION    DisplayInformation,
  PSAMPR_DISPLAY_INFO_BUFFER     Buffer
  );

VOID
SampDsGetLastEntryIndex(
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    PSAMPR_DISPLAY_INFO_BUFFER  Buffer,
    PULONG                      LastEntryIndex,
    PULONG                      EntriesRead 
    );

NTSTATUS
SampDsPackQDI(
    SEARCHRES   * SearchRes,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer,
    PRESTART * RestartToUse,
    PULONG     EntriesReturned
    );

NTSTATUS
SampPackUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackMachineDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    DOMAIN_DISPLAY_INFORMATION DisplayType,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackOemUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackOemGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampDsCheckDisplayAttributes(
     ATTRBLOCK * DsAttrs,
     DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
     PULONG     ObjectNameOffset,
     PULONG     UserAccountControlOffset,
     PULONG     UserAcctCtrlComputedOffset,
     PULONG     FullNameOffset,
     PULONG     AdminCommentOffset,
     BOOLEAN    * FullNamePresent,
     BOOLEAN    * AdminCommentPresent
     );

NTSTATUS
DsValToUnicodeString(
    PUNICODE_STRING UnicodeString,
    ULONG   Length,
    PVOID   pVal
    );

NTSTATUS
SampGetQDIAvailable(
    PSAMP_OBJECT    DomainContext,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG   *TotalAvailable
    );

NTSTATUS
SampDsEnumerateAccountRidsWorker(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountType,
    IN  ULONG StartingRid,
    IN  ULONG EndingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    );

NTSTATUS
SampDsEnumerateAccountRidsWorker(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountType,
    IN  ULONG StartingRid,
    IN  ULONG EndingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )
/*++

    This is the DS version of Enumerate Account Rid API for Net logon

    Parameters:

        Domain Handle - Handle to the domain object
        AccountType   - Specifies the type of account to use
        StartingRid   - The starting Rid
        EndingRid     - The ending Rid
        PreferedMaximumLength - The maximum length supplied by the client
        ReturnCount   - The Count of accounts returned
        AccountRids   - Array of account Rids

    Return Values

        STATUS_SUCCESS for successful completion
        Other Error codes under error conditions

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    // Declare the attributes that we want the search to return. Note that we obtain
    // the Rid by parsing the SID in the returned DSName. We therefore need only the
    // SAM account Type
    //
    ATTRTYP         AttrTypes[]=
                    {
                        SAMP_UNKNOWN_ACCOUNT_TYPE
                    };
    
    ATTRVAL         AttrVals[]=
                    {
                        {0,NULL}
                    };
                  
    DEFINE_ATTRBLOCK1(
                      AttrsToRead,
                      AttrTypes,
                      AttrVals
                      );

    BOOLEAN         MoreEntriesPresent = FALSE;
    FILTER          DsFilter;
    SEARCHRES       *SearchRes;
    PSAMP_OBJECT    DomainContext = (PSAMP_OBJECT)DomainHandle;
    PSID            StartingSid = NULL;
    PSID            EndingSid = NULL;
    PSID            DomainSid = SampDefinedDomains[DomainContext->DomainIndex].Sid;
    ULONG           MaximumEntriesToReturn = PreferedMaximumLength/ sizeof(ULONG);
    ULONG           AccountTypeLo = 0;
    ULONG           AccountTypeHi = 0;
    ENTINFLIST      *CurrentEntInf;
  
    //
    // Compute the starting and ending Sid Ranges
    //
    *AccountRids = NULL;
    NtStatus = SampCreateFullSid(
                    DomainSid,
                    StartingRid,
                    &StartingSid
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampCreateFullSid(
                    DomainSid,
                    EndingRid,
                    &EndingSid
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    
    //
    // Allocate memory for the Rids to be returned
    // allocate one more and so that the very last entry ( not included in the
    // count has a 0x7FFFFFFF ( MAX_RID ). This will be valuable when we merge
    // sorted lists in SampDsEnumerateAccountRids

    *AccountRids = MIDL_user_allocate(sizeof(ULONG)* (MaximumEntriesToReturn+1));
   
    if (NULL==*AccountRids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }


    //
    // Build a filter structure for searching
    //
    //

    NtStatus = SampDsBuildAccountRidFilter(
                    StartingSid,
                    EndingSid,
                    AccountType,
                    &DsFilter
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Now keep querying from DS till we hit either preferred Maximum length
    // entries or have completed the query. We prefer to query the DS by doing small
    // transactions and retrieving small number of objects every time. This is because
    // the DS never frees any memory, till the transaction is terminated and our memory
    // usage becomes pegged at abnormally high levels by doing long transactions. 
    //

    *ReturnCount = 0;
       
    NtStatus = SampDoImplicitTransactionStart(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Set the index ranges from the starting Sid to the Ending Sid. We filter on
    // on just Sid >= Starting Sid in the DS. Setting the index range ensures that
    // we will not need to look at object with a Sid greater than our ending Sid.
    //
    NtStatus = SampSetIndexRanges(
                    SAM_SEARCH_NC_ACCTYPE_SID , // Use NC ACCTYPE SID Index
                    sizeof(ULONG),
                    &AccountType,
                    RtlLengthSid(StartingSid),
                    StartingSid,
                    sizeof(ULONG),
                    &AccountType,
                    RtlLengthSid(EndingSid),
                    EndingSid,
                    FALSE
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    //  Perform the DS search.
    //

    NtStatus = SampDsDoSearch(
                    NULL,
                    DomainContext->ObjectNameInDs,
                    &DsFilter,
                    0,          // Starting Index
                    SampUnknownObjectType,
                    &AttrsToRead,
                    MaximumEntriesToReturn,
                    &SearchRes
                    );

    SampDiagPrint(DISPLAY_CACHE,("[SAMSS]SamIEnumerateAccountRids"));
    SampDiagPrint(DISPLAY_CACHE,("Returned From DS, Count=%d,Restart=%x\n",
                                        SearchRes->count, SearchRes->PagedResult.pRestart));
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Pack the results
    //

    for (CurrentEntInf = &(SearchRes->FirstEntInf);
            ((CurrentEntInf!=NULL)&&(SearchRes->count>0));
            CurrentEntInf=CurrentEntInf->pNextEntInf)

    {
        ULONG   Rid;
        PSID    ReturnedSid = NULL;
        PSID    DomainSidOfCurrentEntry = NULL;
        PULONG  SamAccountType;

        //
        // Assert that the Attrblock returned is what we expected
        //
        ASSERT(CurrentEntInf->Entinf.AttrBlock.attrCount==1);
        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr);

        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount==1);
        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal);
        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen);

        //
        // skip return entry that doesn't have desired attribute
        //
        if ( (CurrentEntInf->Entinf.AttrBlock.attrCount != 1) ||
             (CurrentEntInf->Entinf.AttrBlock.pAttr == NULL) ||
             (CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount != 1) ||
             (CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal == NULL) ||
             (CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].valLen == 0)
            )
        {
            continue;
        }

        
        
        //
        // Get the Sid and subsequently the Rid of the entry
        //

        ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
        
        NtStatus = SampSplitSid(
                    ReturnedSid,
                    &DomainSidOfCurrentEntry,
                    &Rid
                    );

        if (!NT_SUCCESS(NtStatus))
            goto Error;

#if DBG

        //
        // For debug builds print out the last Rid that was returned
        //

        if (NULL==CurrentEntInf->pNextEntInf)
        {
            SampDiagPrint(DISPLAY_CACHE,("[SAMSS]\t Last Rid=%d\n",Rid));
        }
#endif


        
        //
        // Check wether the returned Sid belongs to the Domain
        //

        if (!RtlEqualSid(DomainSid,DomainSidOfCurrentEntry))
        {
           //
           // Skip this entry as this does not belong to the domain
           //

            MIDL_user_free(DomainSidOfCurrentEntry);
            DomainSidOfCurrentEntry = NULL;
            continue;
        }

        MIDL_user_free(DomainSidOfCurrentEntry);
        DomainSidOfCurrentEntry = NULL;

        //
        // Check the Account type. If user object are asked and account type is user object,
        // or if group objects are asked for and account type is group object then  Fill in
        // the Rid. Else skip this object and continue to the next object
        //

        (*AccountRids)[(*ReturnCount)++] = Rid;

        SamAccountType = (PULONG) CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
        ASSERT(*SamAccountType==AccountType);


    }

   ASSERT((*ReturnCount)<=MaximumEntriesToReturn);

   //
   // Mark the end ( not included in the count, with MAX RID. This will prove
   // valuable later when merging the sorted lists
   //

   (*AccountRids)[(*ReturnCount)] = MAX_RID;

    //
    // Process search continuation
    //

    if ((SearchRes->PagedResult.pRestart) && (SearchRes->count>0))
    {            
        //
        // Restart structure was returned. More entries are still present
        //

        MoreEntriesPresent = TRUE;
    }

Error:

    if (StartingSid)
        MIDL_user_free(StartingSid);

    if (EndingSid)
        MIDL_user_free(EndingSid);

    if (NT_SUCCESS(NtStatus) && (MoreEntriesPresent))
    {
        NtStatus = STATUS_MORE_ENTRIES;
    }

    if (!NT_SUCCESS(NtStatus))
    {
       if (*AccountRids)
           MIDL_user_free(*AccountRids);
    }
       
    SampDsFreeAccountRidFilter(&DsFilter);


    SampDiagPrint(DISPLAY_CACHE,("[SAMSS]SamIEnumerateAccountRids, StartingRid=%d, AccountTypesMask= %d,ReturnCount=%d, ReturnCode=%x\n",
        StartingRid, AccountType, *ReturnCount, NtStatus));

    return NtStatus;
}


NTSTATUS
SampDsEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )
{

    ULONG   EndingRid = MAX_RID; // set to max rid
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PULONG UserList, MachineList, TrustList;

    UserList = MachineList = TrustList = NULL;

    //
    // Look at the account types mask and get the correct
    // account type to set.
    //

    if (AccountTypesMask & SAM_GLOBAL_GROUP_ACCOUNT)
    {
      NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_GROUP_OBJECT,
                    StartingRid,
                    EndingRid,
                    PreferedMaximumLength,
                    ReturnCount,
                    AccountRids
                    );
    }
    else if (AccountTypesMask & SAM_LOCAL_GROUP_ACCOUNT)
    {
        NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_ALIAS_OBJECT,
                    StartingRid,
                    EndingRid,
                    PreferedMaximumLength,
                    ReturnCount,
                    AccountRids
                    );
    }
    else if (AccountTypesMask & SAM_USER_ACCOUNT)
    {
        ULONG EndingRidUser,EndingRidMachine,EndingRidTrust;
        ULONG  UserCount, MachineCount, TrustCount,LastRidToReturn;
        NTSTATUS StatusUser,StatusMachine,StatusTrust;
        ULONG u,m,t;

        EndingRidUser = EndingRidMachine = EndingRidTrust = EndingRid;
    
        UserCount = MachineCount = TrustCount = 0;
        LastRidToReturn = MAX_RID-1;

        //
        // Start with normal users, and then enumerate
        // machines and trusts and then merge the sorted
        // list of RIDs into a single sorted list
        //

        NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_NORMAL_USER_ACCOUNT,
                    StartingRid,
                    EndingRidUser,
                    PreferedMaximumLength,
                    &UserCount,
                    &UserList
                    );

        // Bail on error
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        StatusUser = NtStatus;

        if (STATUS_MORE_ENTRIES == NtStatus)
        {
            //
            // There are more users in the database than we
            // can return. Constrain  the searches for machines
            // and trusts to within the last RID returned by the
            // user enumeration
            //

            ASSERT(NULL!=UserList);
            ASSERT(UserCount>0);

            EndingRidMachine = EndingRidTrust = UserList[UserCount-1]-1;
        }

        //
        // Enumerate the machines in the domain. This time we will walk a
        // different part of the index range and generate a list of RIDs
        // corresponding to the machines
        //

        NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_MACHINE_ACCOUNT,
                    StartingRid,
                    EndingRidMachine,
                    PreferedMaximumLength,
                    &MachineCount,
                    &MachineList
                    );

        // Bail on error
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        StatusMachine = NtStatus;

        if (STATUS_MORE_ENTRIES == NtStatus)
        {
            //
            // Even within the constrained Rid range that we
            // specified for machines, we have more machines than
            // we can return. The RID of the last machine returned
            // must be less than the RID of the last user returned,
            // as the index range for machines has been further constrained.
            // Therefore for trusts, further constrain the index range
            // to be within the last Machine RID returned
            //

            ASSERT(NULL!=MachineList);
            ASSERT(MachineCount>0);
            if (UserCount>0 && (STATUS_MORE_ENTRIES == StatusUser))
            {
                ASSERT(UserList[UserCount-1]>MachineList[MachineCount-1]);

            }

            EndingRidTrust = MachineList[MachineCount-1]-1;

        }

        //
        // Enumerate the trust accounts in the domain
        //

       NtStatus = SampDsEnumerateAccountRidsWorker(
                        DomainHandle,
                        SAM_TRUST_ACCOUNT,
                        StartingRid,
                        EndingRidTrust,
                        PreferedMaximumLength,
                        &TrustCount,
                        &TrustList
                        );

       if (!NT_SUCCESS(NtStatus))
            goto Error;

       StatusTrust = NtStatus;

       if (StatusTrust==STATUS_MORE_ENTRIES)
       {
           //
           // We found more trust accounts, inspite of the index
           // range limitation. In this case return all the trust
           // accounts found plus all the machine accounts with rids
           // less than the last trust account and all user accounts with
           // rids less than the last trust account
           //

           ASSERT(TrustCount>0);
           LastRidToReturn = TrustList[TrustCount-1];
           NtStatus = STATUS_MORE_ENTRIES;
       }
       else if (StatusMachine == STATUS_MORE_ENTRIES)
       {
           //
           // We found more machines than users inspite of the index range
           // limitation on machines. In this case return all the machine
           // accounts found plus all the user and trust accounts with rids
           // less than the last machine account.
           //

           LastRidToReturn = MachineList[MachineCount-1];
           NtStatus = STATUS_MORE_ENTRIES;
       }
       else if (StatusUser == STATUS_MORE_ENTRIES)
       {
           //
           // We found more users than anything else. In this case return all
           // the machine and trust accounts found plus all the users
           //

           LastRidToReturn = UserList[UserCount-1];
           NtStatus = STATUS_MORE_ENTRIES;
       }
       else
       {
           //
           // We did not get StatusMore entries from users enumeration, or from
           // machine enumeration. Return all the rids found so far, and return
           // a status success
           //

           LastRidToReturn = MAX_RID-1;
           NtStatus = STATUS_SUCCESS;
       }

       //
       // Now you have an 3 sorted arrays of Rids. Create a single sorted array
       // containing all the 3 rids upto and including the LastRidToReturn.
       //
        
       *AccountRids = MIDL_user_allocate(sizeof(ULONG) * (UserCount+MachineCount+TrustCount));
       if (NULL==*AccountRids)
           goto Error;

       u=m=t=0;

       for ((*ReturnCount)=0;
                (*ReturnCount)<UserCount+MachineCount+TrustCount;
                        (*ReturnCount)++)
       {
           ULONG NextRid;

           if ((UserList[u]<MachineList[m]) && (UserList[u]<TrustList[t]) 
               && (UserList[u]<=LastRidToReturn))
           {
               ASSERT(u<UserCount); 
               (*AccountRids)[(*ReturnCount)] = UserList[u];
               u++;
              
           }
           else if  ((MachineList[m]<UserList[u]) && (MachineList[m]<TrustList[t]) 
               && (MachineList[m]<=LastRidToReturn))
           {
               ASSERT(m<MachineCount);
               (*AccountRids)[(*ReturnCount)] = MachineList[m];
               m++;
           }
           else if ((TrustList[t]<UserList[u]) && (TrustList[t]<MachineList[m]) 
               && (TrustList[t]<=LastRidToReturn))
           {
               ASSERT(t<TrustCount);
               (*AccountRids)[(*ReturnCount)] = TrustList[t];
               t++;
           }
           else
           {
               //
               // We have reached the point where we can return no more Rids
               // break out of the loop
               //

               break;
           }
       }
    }


Error:

    if (NULL!=UserList)
        MIDL_user_free(UserList);

    if (NULL!=MachineList)
        MIDL_user_free(MachineList);

    if (NULL!=TrustList)
        MIDL_user_free(TrustList);

    //
    // End the current transaction. 
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    return(NtStatus);
}


NTSTATUS
SampDsBuildAccountRidFilter(
    PSID    StartingSid,
    PSID    EndingSid,
    ULONG   AccountType,
    FILTER  * Filter                
    )
/*++

    Builds a Filter for use by SampDsEnumerateAccountRids.

    Parameters:

        StartingSid        -- The starting Sid that we are interseted in
        EndingSid          -- The ending Sid that we are interested in
        AccountTypesMask   -- The account types that were requested

    Return Values:

        STATUS_SUCCESS
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;


    //
    // In building DS filters a tradeoff exists between the complextity of the filter
    // and the number of objects that the filter limits the search too. After some 
    // empirical studies it was found that it is more beneficial to use a fairly simple
    // filter alongwith some manual filtering, than supply a complex filter to the DS.
    // Hence this filter is just set simply to TRUE.
    //
    //

    RtlZeroMemory(Filter,sizeof(FILTER));
    Filter->pNextFilter = NULL;
    Filter->choice = FILTER_CHOICE_ITEM;
    Filter->FilterTypes.Item.choice = FI_CHOICE_TRUE;
    
    return Status;
}

VOID
SampDsFreeAccountRidFilter(FILTER * Filter)
/*++

  Routine Description

    This frees any memory allocated in the filter structure 
    built by SampDsBuildAccountRidFilter

  Paramters:

    Filter -- The Filter structure
--*/
{
    //
    // This is a place holder routine, to free any memory allocated in the Filter.
    // this must be kept in sync with the SampDsBuildAccountRidFilter
    //
}





NTSTATUS
SampDsQueryDisplayInformation (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      StartingOffset,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

  This routine implements the Query of Display information from the DS. The
  SAM global lock is assumed to be held at this time.


  Since user manager behavior is to download everything upon startup, this routine
  is heavily optimized for that case. It relies upon the new compund indices to sort
  the results in the order of account Name. 

  Paramters:

        Same as SamrQueryDisplayInformation3
  Return Values

        Same as SamrQueryDisplayInformation3

++*/
{
    ULONG               SamAccountTypeLo;
    ULONG               SamAccountTypeHi;
    ULONG               IndexToUse = SAM_SEARCH_NC_ACCTYPE_NAME;
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    FILTER              QDIFilter;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT)DomainHandle;
    SAMP_OBJECT_TYPE    ObjectTypeForConversion;
    ULONG               NumEntriesToReturn = 0;
    ULONG               NumEntriesAlreadyReturned = 0;
    ULONG               NumEntriesToQueryFromDs = 0;
    ULONG               LastEntryIndex = 0;
    ULONG               EntriesRead = 0;
    BOOLEAN             fReadLockReleased = FALSE;
    BOOLEAN             fThreadCountIncremented = FALSE;

    //
    // Declare the attrTypes that we need. Again note that we will obtain the Rid by
    // using the Sid in the object name field.
    //

    ATTRTYP         UserAttrTypes[]=
                    {
                        SAMP_FIXED_USER_ACCOUNT_CONTROL,
                        SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED,
                        SAMP_USER_ACCOUNT_NAME,
                        SAMP_USER_ADMIN_COMMENT,
                        SAMP_USER_FULL_NAME
                    };
    
    ATTRVAL         UserAttrVals[]=
                    {
                        {0,NULL},
                        {0,NULL},
                        {0,NULL},
                        {0,NULL},
                        {0,NULL}
                    };
                  
    DEFINE_ATTRBLOCK5(
                      UserAttrs,
                      UserAttrTypes,
                      UserAttrVals
                      );

    ATTRTYP         GroupAttrTypes[]=
                    {
                        SAMP_GROUP_NAME,
                        SAMP_GROUP_ADMIN_COMMENT
                    };
    
    ATTRVAL         GroupAttrVals[]=
                    {
                        {0,NULL},
                        {0,NULL}
                    };
                  
    DEFINE_ATTRBLOCK2(
                      GroupAttrs,
                      GroupAttrTypes,
                      GroupAttrVals
                      );
    ATTRBLOCK       * QDIAttrs;

    PRESTART        RestartToUse = NULL; 
    SEARCHRES       *SearchRes;
    BOOLEAN         CanQueryEntireDomain = TRUE;
    BOOLEAN         MoreEntries = TRUE; 
    BOOLEAN         NewSearch = FALSE;
    int             DeltaToUse = 0;

    #define LIMIT_ENTRIES(X,Limit) ((X>Limit)?Limit:X)
    #define DISPLAY_ENTRY_SIZE  32

    RtlZeroMemory(&QDIFilter,sizeof(FILTER));
                                        
    //
    // Do the number of entries returned arithmetic
    //
    //  Many NT4 Clients download the entire database
    //  upon startup, rather than go to the server for queries.
    //  This can potentially require very long transactions. Additionally
    //  due to the nature of the core DS memory allocation scheme, this will
    //  result in a huge memory consumption on the part of the server. Solution
    //  approaches are
    // 
    //  1. We can artificially limit the number of objects that we will 
    //  return in a single query display. This will result in a lot of network traffic
    //  when the NT4 client comes up as they will make many small queries
    //
    //  2. We can conduct many small searches, stuff the results in for NT4 clients
    //  and return a fairly large number of results.  
    //
    //  Current implementation implements solution approach 2.
    //
    //      
    //
    //

    NumEntriesToReturn = EntriesRequested;
    NumEntriesToReturn = LIMIT_ENTRIES(NumEntriesToReturn,PreferredMaximumLength/DISPLAY_ENTRY_SIZE);
    NumEntriesToReturn = LIMIT_ENTRIES(NumEntriesToReturn,MAX_ENTRIES_TO_RETURN_TO_CLIENT);
    if (NumEntriesToReturn < 1)
    {
        NumEntriesToReturn = 1;
    }


    //
    // Get index ranges to set based on the search type
    // and allocate space for array of elements
    //

    switch (DisplayInformation)
    {
    case DomainDisplayUser:
        
        SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
        SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
        QDIAttrs = &UserAttrs;
        ObjectTypeForConversion = SampUserObjectType;

        if (NULL==Buffer->UserInformation.Buffer)
        {

            Buffer->UserInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_USER));

            if (NULL==Buffer->UserInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->UserInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_USER));
            Buffer->UserInformation.EntriesRead=0;
        }

        break;

    case DomainDisplayOemUser:
        
        SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
        SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
        QDIAttrs = &UserAttrs;
        ObjectTypeForConversion = SampUserObjectType;

        if (NULL==Buffer->OemUserInformation.Buffer)
        {

            Buffer->OemUserInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_USER));

            if (NULL==Buffer->OemUserInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->OemUserInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_USER));
            Buffer->OemUserInformation.EntriesRead=0;
        }

        break;
        
    case DomainDisplayMachine:
        
        SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
        SamAccountTypeHi = SAM_MACHINE_ACCOUNT;
        ObjectTypeForConversion = SampUserObjectType;
        QDIAttrs = &UserAttrs;

        if (NULL==Buffer->MachineInformation.Buffer)
        {

            Buffer->MachineInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));

            if (NULL==Buffer->MachineInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->MachineInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));
            Buffer->MachineInformation.EntriesRead=0;
        }

        break;

    case DomainDisplayServer:

        //
        // Since all domain controllers have DOMAIN_GROUP_RID_CONTROLLERS as 
        // their primary group ID. So using PRIMARY_GROUP_ID as Index will 
        // result much faster query.
        // 
        IndexToUse = SAM_SEARCH_PRIMARY_GROUP_ID;
        SamAccountTypeLo = DOMAIN_GROUP_RID_CONTROLLERS; 
        SamAccountTypeHi = DOMAIN_GROUP_RID_CONTROLLERS;
        ObjectTypeForConversion = SampUserObjectType;
        QDIAttrs = &UserAttrs;

        if (NULL==Buffer->MachineInformation.Buffer)
        {

            Buffer->MachineInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));

            if (NULL==Buffer->MachineInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->MachineInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));
            Buffer->MachineInformation.EntriesRead=0;
        }

        break;

    case DomainDisplayGroup:

        SamAccountTypeLo = SAM_GROUP_OBJECT;
        SamAccountTypeHi = SAM_GROUP_OBJECT;
        ObjectTypeForConversion = SampGroupObjectType;
        QDIAttrs = &GroupAttrs;

        if (NULL==Buffer->GroupInformation.Buffer)
        {

            Buffer->GroupInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_GROUP));

            if (NULL==Buffer->GroupInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            Buffer->GroupInformation.EntriesRead=0;
            RtlZeroMemory(Buffer->GroupInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_GROUP));
        }

        break;

    case DomainDisplayOemGroup:

        SamAccountTypeLo = SAM_GROUP_OBJECT;
        SamAccountTypeHi = SAM_GROUP_OBJECT;
        ObjectTypeForConversion = SampGroupObjectType;
        QDIAttrs = &GroupAttrs;

        if (NULL==Buffer->OemGroupInformation.Buffer)
        {

            Buffer->OemGroupInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_GROUP));

            if (NULL==Buffer->OemGroupInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->OemGroupInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_GROUP));
            Buffer->OemGroupInformation.EntriesRead=0;
        }

        break;

    default:
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Check if the query can be restarted by state stored in domain context
    //

    //
    // As mentioned before User manager and various net API try to download the entire
    // display information in one stroke. In case of a large number of accounts user manager
    // will call the query display information API many times. Each time the starting offset
    // will be set to indicate the next object that is needed. A straigforward implementation,
    // just specifying the starting offset to the DS search routine will result in manual skipping
    // of that many objects by using JetMove's. To speed this up, therefore we maintain state,
    // telling us the offset of the last object that we returned, the type of display information,
    // and a restart structure, allowing for easy positioning on the object.
    //
    // Currently, there are two APIs using this rouinte. 
    // 1. SAM API, the client using the same Domain Handle in different calls, thus 
    //    we can use the restart search which is cached in the Domain Context.
    //    The extra benefit is that the caller of SAM API can even manipulate the returned 
    //    index, do certain kind of arithmetic.
    //
    // 2. NET API. that poorly designed API create/use a new Domain Handle when calling
    //    SamrQueryDisplayInformation(). Thus they lose all cached restart infomation.
    //    To handle this case correctly, SAM actully return Object's DNT as index to caller.
    //    When our client sends back the last object's DNT, we can position on the last 
    //    entry quickly by using the DNT, then start from it.
    //

    if (0 == StartingOffset)
    {
        //
        // StartingOffset is 0 means caller wants to begin a new query. 
        // Clean up the cached restart info if any
        // 
        if (DomainContext->TypeBody.Domain.DsDisplayState.Restart)
        {
            MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
        }

        DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = 0;
        DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
        DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation = DisplayInformation;

        //
        // Set local variables accordingly 
        // 
        DeltaToUse = 0;
        RestartToUse = NULL;
        NewSearch = TRUE;
    }
    else if (NULL != DomainContext->TypeBody.Domain.DsDisplayState.Restart)
    {
        // we have the restart info. This client must call SAM API
        if (DisplayInformation == 
            DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation)
        {
            //
            // StartingOffset is not Zero. 
            // If the Domain Context caches the restart info and the DisplayInformation matched.
            // Then we can do a restart search. 
            // 
            ULONG   NextStartingOffset;

            NextStartingOffset = DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset;

            if (StartingOffset == NextStartingOffset)
            {
                //
                // Starting Offset matches the restartable state
                // and client is using the Index we returned to them. (correct usage) 
                //

                RestartToUse = DomainContext->TypeBody.Domain.DsDisplayState.Restart;
                DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                DeltaToUse = 0;
            }
            else if (StartingOffset == DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned)
            {
                //
                // client assumes the value of total returned entries is the index. 
                // (this is a wrong usage of the index). but since this kind of client
                // exists since NT4, so we have to patch this special case.
                // here is what we do for them:
                // 1. TotalEntriesReturned is used in the Domain Context to track how many entries returned already
                // 2. Once we detect that the client is using the wrong index. 
                //    (whether StartingOffset equal to TotalEntriesReturned or not).
                //    we need to pick the restart structure and with 0 delta
                //
                RestartToUse = DomainContext->TypeBody.Domain.DsDisplayState.Restart;
                DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                DeltaToUse = 0;
            }
            else if ((ABSOLUTE_VALUE((int)(StartingOffset - NextStartingOffset)))
                        < ((int)StartingOffset))
            {
                //
                // We will need to walk much less number of object's by using the restart
                //

                RestartToUse = DomainContext->TypeBody.Domain.DsDisplayState.Restart;
                DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                DeltaToUse = (int)(StartingOffset - NextStartingOffset);

            }
            else
            {
                //
                // We are better off walking from the top of the Table
                //
                MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
                DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;

                RestartToUse = NULL;
                DeltaToUse = (int)StartingOffset;
            }

        }
        else
        {
            //
            // Restart is not NULL, StartingOffset is not 0, but another
            // Information Class. Try our best
            // 
            PRESTART Restart = NULL;

            MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
            DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
            DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = StartingOffset;
            DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
            DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation = DisplayInformation;

            NtStatus = SampGetQDIRestart(DomainContext->ObjectNameInDs,
                                         DisplayInformation,
                                         StartingOffset,        // Last returned entry DNT
                                         &Restart
                                         );
            
            if (STATUS_NO_MORE_ENTRIES == NtStatus)
            {
                MoreEntries = FALSE;
                NtStatus = STATUS_SUCCESS;
                goto Error;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }


            if (NULL != Restart)
            {
                NtStatus = SampCopyRestart(Restart, &RestartToUse);

                if (!NT_SUCCESS(NtStatus))
                    goto Error;
            }

            DeltaToUse = 0;

        }
    }
    else
    {
        // StartingOffest is not ZERO. But restart is NULL. 
        // there are two of cases will lead us falling into this situation: 
        // 
        // 1. NET API using a brand new Domain Handle each every time they call 
        //    this routine. So no cached info available. In this case,  
        //    the StartingOffset should be the last returned entry's DNT. 
        //    And since this is a new Domain Context, so the cached
        //    DisplayInformation should be 0.
        // 
        // 2. Client is using SAM API. We can tell it if the DomainContext->
        //    DisplayInformation is not 0. In this case, Restart == NULL means
        //    there is no more entry available, we have already returned all
        //    entried in previous calls. StartingOffset could be anything.
        //    Return success immediately with 0 entry.
        //
        // For case 1, SAM will re-position in the table based on the passed in Index - which is
        // the last entry's DNT (we returned to caller previously), then restart from there.
        // Because no previous restart cached, so no Index arithmetic allowed.
        // 

        if (DisplayInformation == DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation)
        {
            // Case 2. I don't care about the StartingOffset anymore.
            MoreEntries = FALSE;
            NtStatus = STATUS_SUCCESS;
            goto Error;
        }                                    
        else
        {
            // Case 1.
            //
            // Query Server Info should NOT fall into this case. Because:
            // 1. NET API is not allowed to query server info. ONLY SAM API can do that.
            //    Thus, we should always have restart cached in the domain handle.
            // 2. In this case, we will re-create the new restart using NcAccTypeName index,
            //    but for server info, we do really want to use PRIMARY_GROUP_ID index.
            // 
            PRESTART Restart = NULL;

            ASSERT(DomainDisplayServer != DisplayInformation);

            // start a ds transaction
            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            //  Get a Restart Structure from the passed in Index.
            //  the Index is actually the DNT of the last returned object
            // 
            NtStatus = SampGetQDIRestart(DomainContext->ObjectNameInDs,
                                         DisplayInformation,
                                         StartingOffset,        // Last returned entry DNT
                                         &Restart
                                         );
            
            if (STATUS_NO_MORE_ENTRIES == NtStatus)
            {
                MoreEntries = FALSE;
                NtStatus = STATUS_SUCCESS;
                goto Error;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }


            if (NULL != Restart)
            {
                NtStatus = SampCopyRestart(Restart, &RestartToUse);

                if (!NT_SUCCESS(NtStatus))
                    goto Error;
            }

            DeltaToUse = 0;
        }
    }
    

    //
    // Get the approximate total number available in the specified info class
    //

    *TotalAvailable = 0;
    if (DomainContext->TypeBody.Domain.DsDisplayState.TotalAvailable)
    {
        //
        // use the cached information if we have
        //

        *TotalAvailable = DomainContext->TypeBody.Domain.DsDisplayState.TotalAvailable;
    }
     
    //
    // Loop through and query entries in the DS.
    //

    NumEntriesAlreadyReturned = 0;
    NumEntriesToQueryFromDs = LIMIT_ENTRIES((NumEntriesToReturn - NumEntriesAlreadyReturned),
                                        MAX_ENTRIES_TO_QUERY_FROM_DS);

    //
    // we will search the Ds directly. Release the Read Lock
    // as we no longer need access to any variable in Domain Context.
    // Since this Domain Context can be shared by multiple threads, 
    // we have to hold the read lock until now.
    //

    ASSERT(SampCurrentThreadOwnsLock());
    SampReleaseReadLock();
    fReadLockReleased = TRUE;

    //
    // Since we do not hold SAM lock, increment the active thread count
    // while doing ds operations.
    // 
    NtStatus = SampIncrementActiveThreads();

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    else
    {
        fThreadCountIncremented = TRUE;
    }
    //
    // If we did not get the cached total available information from the
    // handle, initiate a count of indices to get an estimate of the total
    // number of available items
    //

    if (0 == *TotalAvailable)
    {
        NtStatus = SampGetQDIAvailable(
                    DomainContext,
                    DisplayInformation,
                    TotalAvailable
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // End the transaction
        //

        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Run special check (introduced for Windows 2000 SP2).
    // 
    // The goal is to stop enumerate everyone behaviour. This hotfix
    // allows an administrator to shut down this API's alone to everyone
    // except a subset of people. 
    // 
    NtStatus = SampExtendedEnumerationAccessCheck( DomainContext->TrustedClient, &CanQueryEntireDomain );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    while (NumEntriesToQueryFromDs && MoreEntries)
    {
        ULONG   EntriesReturned = 0;
        BOOLEAN DidSearch = FALSE;

        //
        // Begin a transaction
        //

        NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Build the appropriate Filter
        //

        NtStatus = SampDsBuildQDIFilter(
                    DisplayInformation,
                    &QDIFilter
                    );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }


        //
        //  Set Index Type and Ranges
        //

        NtStatus =  SampSetIndexRanges(
                        IndexToUse,
                        sizeof(SamAccountTypeLo),
                        &SamAccountTypeLo,
                        0,NULL,
                        sizeof(SamAccountTypeHi),
                        &SamAccountTypeHi,
                        0,NULL,
                        TRUE
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Turn off the DSA flag for a non trusted client
        //

        if (!DomainContext->TrustedClient)
        {
             SampSetDsa(FALSE);
        }

        //
        // Call the Ds Search. Don't allow restarted searches if
        // if client cannot enumerate entire domain.
        //

        if (( NewSearch || CanQueryEntireDomain))
        {

            NtStatus = SampDsDoSearch2(
                          0,
                          RestartToUse, 
                          DomainContext->ObjectNameInDs, 
                          &QDIFilter,
                          DeltaToUse,
                          ObjectTypeForConversion,
                          QDIAttrs,
                          NumEntriesToQueryFromDs,
                          (DomainContext->TrustedClient)?0:1*60*1000,
                          &SearchRes
                          );

            DidSearch = TRUE;
        }

        SampSetDsa(TRUE);


        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        SampDsFreeQDIFilter(&QDIFilter);

        //
        // Check if any objects are returned
        //

        if ((DidSearch ) && (SearchRes->count>0))
        {
            //
            // Yep, Pack the results into the buffer. Also obtain any restart structure
            // that was returned. SampDsPackQDI copies the restart structure in thread
            // local memory returned by the DS into MIDL memory.
            //

            NtStatus = SampDsPackQDI(
                          SearchRes,
                          DisplayInformation,
                          DomainContext->DomainIndex,
                          StartingOffset+NumEntriesAlreadyReturned,
                          Buffer,
                          &RestartToUse,
                          &EntriesReturned
                          );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

        }

        //
        // Try to determine if there are more entries. If some objects were returned
        // in this search, and a restart structure was also returned then there are 
        // more entries present.  
        //
        // if SearchRes->Count == 0 && SearchRes->PagedResult->pStart != NULL 
        // due to timeout, we will still set MoreEntries to FALSE. because most
        // likely this client won't have access to enumeration all accounts.
        // 

        if ((DidSearch) && (SearchRes->count > 0)&&(RestartToUse!=NULL)&&(CanQueryEntireDomain))
        {
            MoreEntries = TRUE;
        }
        else
        {
            MoreEntries = FALSE;
        }


        //
        // End the transaction
        //

        NtStatus = SampMaybeEndDsTransaction(TransactionCommit);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Compute entries returned so far, and number of more entries to 
        // query from DS.
        //

        NumEntriesAlreadyReturned+=EntriesReturned;
        NumEntriesToQueryFromDs = LIMIT_ENTRIES((NumEntriesToReturn - NumEntriesAlreadyReturned),
                                            MAX_ENTRIES_TO_QUERY_FROM_DS);

    }

    if (fThreadCountIncremented)
    {
        SampDecrementActiveThreads();
        fThreadCountIncremented = FALSE;
    }

    if (fReadLockReleased)
    {
        SampAcquireReadLock();
        fReadLockReleased = FALSE;
    }

    //
    // Set the state in the domain context such as the the restart mechanism may be used
    // to speed up clients which want to download the display information in one stroke
    //
    SampDsGetLastEntryIndex(DisplayInformation, 
                            Buffer, 
                            &LastEntryIndex, 
                            &EntriesRead
                            );

    DomainContext->TypeBody.Domain.DsDisplayState.Restart = RestartToUse;
    RestartToUse = NULL;
    DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation = DisplayInformation;
    DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned += EntriesRead;
    if (0 == EntriesRead)
    {
        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = StartingOffset; 
    }
    else
    {
        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = LastEntryIndex; 
    }


Error:

    //
    // Cleanup before returning
    //

    if (!NT_SUCCESS(NtStatus))
    {
        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        if (Buffer)
        {

            //
            // We could have errored out in the middle of a query, where we have
            // some objects already allocated, and are now going to return an error
            // to the client. We need to walk through the buffer freeing all the
            // information.
            //

            IgnoreStatus = SampDsCleanQDIBuffer(DisplayInformation,Buffer);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }
    else
    {
        // Make sure any transactions are commited        
        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        *TotalReturned = NumEntriesAlreadyReturned * DISPLAY_ENTRY_SIZE;
        if (MoreEntries)
        {
            NtStatus = STATUS_MORE_ENTRIES;
        }
     
    }

    SampDsFreeQDIFilter(&QDIFilter);

    if (fThreadCountIncremented)
    {
        SampDecrementActiveThreads();
        fThreadCountIncremented = FALSE;
    }

    if (fReadLockReleased)
    {
        SampAcquireReadLock();
        fReadLockReleased = FALSE;
    }

    if (RestartToUse) {
        MIDL_user_free(RestartToUse);
    }

    return(NtStatus);
}



VOID
SampDsGetLastEntryIndex(
    DOMAIN_DISPLAY_INFORMATION    DisplayInformation,
    PSAMPR_DISPLAY_INFO_BUFFER    Buffer,
    PULONG                        LastEntryIndex,
    PULONG                        EntriesRead 
    )
{
    *LastEntryIndex = 0;
    *EntriesRead = 0;

    switch (DisplayInformation) {
    case DomainDisplayUser:
        *EntriesRead = Buffer->UserInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->UserInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayMachine:
    case DomainDisplayServer: 
        *EntriesRead = Buffer->MachineInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->MachineInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayGroup: 
        *EntriesRead = Buffer->GroupInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->GroupInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayOemUser: 
        *EntriesRead = Buffer->OemUserInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->OemUserInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayOemGroup: 
        *EntriesRead = Buffer->OemGroupInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->OemGroupInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    default:
        break; 
    }

    return;
}



NTSTATUS
SampDsCleanQDIBuffer(
  DOMAIN_DISPLAY_INFORMATION    DisplayInformation,
  PSAMPR_DISPLAY_INFO_BUFFER     Buffer
  )
/*++

  Routine Description:

    This routine cleans out the Query Display information buffer.

  Parameters:

    DisplayInformation -- Specifies the type of display information
    Buffer             -- The Buffer to clean out

--*/
{
    ULONG ReturnedItems;
    
    switch(DisplayInformation)
    {
    case DomainDisplayUser:
    
         ReturnedItems = Buffer->UserInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeUserInfo((PDOMAIN_DISPLAY_USER)
                &(Buffer->UserInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->UserInformation.Buffer);
        Buffer->UserInformation.Buffer = NULL;
        break;

    case DomainDisplayGroup:
         ReturnedItems = Buffer->GroupInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeGroupInfo((PDOMAIN_DISPLAY_GROUP)
                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->GroupInformation.Buffer);
        Buffer->GroupInformation.Buffer = NULL;
        break;

    case DomainDisplayMachine:
    case DomainDisplayServer:
          
         ReturnedItems = Buffer->MachineInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeMachineInfo((PDOMAIN_DISPLAY_MACHINE)
                &(Buffer->MachineInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->MachineInformation.Buffer);
        Buffer->MachineInformation.Buffer = NULL;
        break;

    case DomainDisplayOemUser:
         ReturnedItems = Buffer->UserInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeOemUserInfo((PDOMAIN_DISPLAY_OEM_USER)
                &(Buffer->UserInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->UserInformation.Buffer);
        Buffer->UserInformation.Buffer = NULL;
        break;

    case DomainDisplayOemGroup:
         ReturnedItems = Buffer->GroupInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeOemGroupInfo((PDOMAIN_DISPLAY_OEM_GROUP)
                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->GroupInformation.Buffer);
        Buffer->GroupInformation.Buffer = NULL;
        break;

    default:

        ASSERT(FALSE && "Unknown Object Type");
        break;
    }
        
    return STATUS_SUCCESS;
}

NTSTATUS
SampDsBuildQDIFilter(
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    FILTER  *QDIFilter                
    )
/*++

    Builds a Filter for query of Display Information

    Parameters:

        DisplayInformation -- Display information type
        QDIFilter          -- Pointer to a filter structure
                              where the filter is builtin

    Return Values:

        STATUS_SUCCESS  - upon successfully building the filter
        STATUS_INSUFFICIENT_RESOURCES - upon memory alloc failures
        STATUS_INVALID_PARAMETER - Upon a junk Display Information type

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       SamAccountType;

    RtlZeroMemory(QDIFilter, sizeof(FILTER));

    if (DomainDisplayServer==DisplayInformation)
    {
        //
        // If backup domain controllers were required then
        // then request only user account control bit
        //

        QDIFilter->choice = FILTER_CHOICE_ITEM;
        QDIFilter->FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
        QDIFilter->FilterTypes.Item.FilTypes.ava.type = 
                SampDsAttrFromSamAttr(
                    SampUserObjectType,
                    SAMP_FIXED_USER_ACCOUNT_CONTROL
                    );

        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = 
                MIDL_user_allocate(sizeof(ULONG));
    
        if (NULL==QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        *((ULONG *)(QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal))=
                               UF_SERVER_TRUST_ACCOUNT;
    }
    else
    {

        switch(DisplayInformation)
        {
        case DomainDisplayUser:
        case DomainDisplayOemUser:
            SamAccountType = SAM_NORMAL_USER_ACCOUNT;
            break;
    
        case DomainDisplayMachine:
            SamAccountType = SAM_MACHINE_ACCOUNT;
            break;

        case DomainDisplayGroup:
        case DomainDisplayOemGroup:
            SamAccountType = SAM_GROUP_OBJECT;
            break;

        default:
            return (STATUS_INVALID_PARAMETER);
        }

        QDIFilter->choice = FILTER_CHOICE_ITEM;
        QDIFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        QDIFilter->FilterTypes.Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                           SampUnknownObjectType,
                                                           SAMP_UNKNOWN_ACCOUNT_TYPE
                                                           );

        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = 
                    MIDL_user_allocate(sizeof(ULONG));
    
        if (NULL==QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        *((ULONG *)(QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal))=
                                   SamAccountType;
    }

Error:

    return Status;
}

VOID
SampDsFreeQDIFilter(
    FILTER  * QDIFilter
    )
/*++
    
      Routine Description
        
            This routine frees the filter built in the SampDSbuildQDIFilter
            routine. This routine must be kept in sync with the SampDSbuildQDIFilter
            rotuine
      Parameters:

        QDIFilter -- Filter that needs to be freed.

      Return Values -- None
--*/
{
    if (QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal)
    {
        MIDL_user_free(
            QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal);
    }

    QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal=NULL;
}




NTSTATUS
SampDsPackQDI(
    SEARCHRES   *SearchRes,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG       DomainIndex,
    ULONG       StartingIndex,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer,
    PRESTART    *RestartToUse,
    PULONG      EntriesReturned
    )
/*++

    This routine Takes a DS search result and then packs it into a SAM display
    information structure. It uses the routines in display.c, originally developed
    to support NT4 style display cache structures to pack the results

    Parameters:
        
         SearchRes -- Search Results as returned by the DS.

         DisplayInformation   -- The type of Display Information
         Buffer               --  Buffer that stores the display information
         RestartToUse         --  If the DS returned a restart , then the restart structure
                                  is returned in here

    Return Values

        STATUS_SUCCESS for successful return
        Other Error codes upon Failure
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


  
    //
    // Free the old restart structure
    //

    if (NULL!=*RestartToUse)
    {
        MIDL_user_free(*RestartToUse);
        *RestartToUse = NULL;
    }

    //
    // Copy in the newly returned restart structure
    //

    if (SearchRes->PagedResult.pRestart!=NULL)
    {

        NtStatus = SampCopyRestart(
                        SearchRes->PagedResult.pRestart,
                        RestartToUse
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;
    }

    //
    // Pack in the results in the buffer provided
    //

    switch (DisplayInformation) {
    case DomainDisplayUser:
        NtStatus = SampPackUserDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayMachine:
    case DomainDisplayServer:
        NtStatus = SampPackMachineDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        DisplayInformation,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayGroup:
        NtStatus = SampPackGroupDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayOemUser:
        NtStatus = SampPackOemUserDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayOemGroup:
        NtStatus = SampPackOemGroupDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }

    
Error:

    //
    // Cleanup on Error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*RestartToUse)
        {
            MIDL_user_free(*RestartToUse);
            *RestartToUse = NULL;
        }
    }

    return NtStatus;
}

  
    
NTSTATUS
SampPackUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if User Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->UserInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                  DomainSid = NULL;
          PSID                  ReturnedSid;
          ULONG                 AccountControlValue;
          DOMAIN_DISPLAY_USER   DisplayElement;
          BOOLEAN               FullNamePresent = FALSE;
          BOOLEAN               AdminCommentPresent=FALSE;
          ULONG                 NameOffset, AccCntrlOffset,
                                AccCntrlComputedOffset,
                                FullNameOffset, AdminCommentOffset;
          ULONG                 Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayUser,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AdminCommentOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          //
          // Get the RID, Remember DS returns us a SID, so get the Rid Part out.
          // Also check that the object belongs to the requested domain
          //

          
          ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
          NtStatus = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &Rid
                        );
          if (NT_SUCCESS(NtStatus))
          {
              if (!RtlEqualSid(
                     DomainSid,SampDefinedDomains[DomainIndex].Sid))
              {                 
                 MIDL_user_free(DomainSid);
                 DomainSid = NULL;
                 continue;
              }
              MIDL_user_free(DomainSid);
              DomainSid = NULL;
          }
          else
              goto Error;

          DisplayElement.Rid = Rid;
          DisplayElement.AccountControl = * ((ULONG *)
                CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlOffset].AttrVal.pAVal->pVal);

          DisplayElement.AccountControl |= * ((ULONG *)
                CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlComputedOffset].AttrVal.pAVal->pVal);



          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.LogonName),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          //
          // Copy the Admin Comment
          //

          if (AdminCommentPresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.AdminComment),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.AdminComment.Length=0;
              DisplayElement.AdminComment.MaximumLength = 0;
              DisplayElement.AdminComment.Buffer = NULL;
          }


          //
          // Copy the Full Name portion
          //

          if (FullNamePresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.FullName),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[FullNameOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[FullNameOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.FullName.Length=0;
              DisplayElement.FullName.MaximumLength = 0;
              DisplayElement.FullName.Buffer = NULL;
          }


          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateUserInfo(
                        (PDOMAIN_DISPLAY_USER) 
                                &(Buffer->UserInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_USER) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
   
        Buffer->UserInformation.EntriesRead = ReturnedItems;
        

    return NtStatus;

 }


NTSTATUS
SampPackMachineDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    DOMAIN_DISPLAY_INFORMATION DisplayType,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if Machine Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        DisplayType    -- If DomainDisplayServer was specified then this discards
                          any entries not having a user account control of
                          USER_SERVER_TRUST_ACCOUNT

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/

{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->MachineInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                  DomainSid = NULL;
          PSID                  ReturnedSid;
          ULONG                 AccountControlValue;
          DOMAIN_DISPLAY_MACHINE DisplayElement;
          BOOLEAN               FullNamePresent;
          BOOLEAN               AdminCommentPresent;
          ULONG                 NameOffset, AccCntrlOffset,
                                AccCntrlComputedOffset,
                                FullNameOffset, AdminCommentOffset;
          ULONG                 Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayMachine,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AdminCommentOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          //
          // Get the account control
          //

           DisplayElement.AccountControl = * ((ULONG *)
                CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlOffset].AttrVal.pAVal->pVal);

           DisplayElement.AccountControl |= * ((ULONG *)
                 CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlComputedOffset].AttrVal.pAVal->pVal);


          //
          // Manually Filter on User account control if server's were specified as
          // the display type
          //

          if (DomainDisplayServer==DisplayType)
          {
              if (!(DisplayElement.AccountControl & USER_SERVER_TRUST_ACCOUNT))
              {
                  continue;
              }
          }

          //
          // Get the RID, Remember DS returns us a SID, so get the Rid Part out.
          // Also check that the object belongs to the requested domain
          //

          
          ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
          NtStatus = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &Rid
                        );
          if (NT_SUCCESS(NtStatus))
          {
              if (!RtlEqualSid(
                     DomainSid,SampDefinedDomains[DomainIndex].Sid))
              {                 
                 MIDL_user_free(DomainSid);
                 DomainSid = NULL;
                 continue;
              }
              MIDL_user_free(DomainSid);
              DomainSid = NULL;
          }
          else
              goto Error;

          DisplayElement.Rid = Rid;
         

          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.Machine),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          //
          // Copy the Admin Comment
          //

          if (AdminCommentPresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.Comment),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.Comment.Length=0;
              DisplayElement.Comment.MaximumLength = 0;
              DisplayElement.Comment.Buffer = NULL;
          }


          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateMachineInfo(
                        (PDOMAIN_DISPLAY_MACHINE) 
                                &(Buffer->MachineInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_MACHINE) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
        
    Buffer->MachineInformation.EntriesRead = ReturnedItems;
        

    return NtStatus;

 }

NTSTATUS
SampPackGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if Group Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/

{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->GroupInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                  DomainSid = NULL;
          PSID                  ReturnedSid;
          ULONG                 AccountControlValue;
          DOMAIN_DISPLAY_GROUP  DisplayElement;
          BOOLEAN               FullNamePresent;
          BOOLEAN               AdminCommentPresent;
          ULONG                 NameOffset, AccCntrlOffset,
                                AccCntrlComputedOffset,
                                FullNameOffset, AdminCommentOffset;
          ULONG                 Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayGroup,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AdminCommentOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          //
          // Get the RID, Remember DS returns us a SID, so get the Rid Part out.
          // Also check that the object belongs to the requested domain
          //

          
          ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
          NtStatus = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &Rid
                        );

          if (NT_SUCCESS(NtStatus))
          {
              if (!RtlEqualSid(
                     DomainSid,SampDefinedDomains[DomainIndex].Sid))
              {                 
                 MIDL_user_free(DomainSid);
                 DomainSid = NULL;
                 continue;
              }
              MIDL_user_free(DomainSid);
              DomainSid = NULL;
          }
          else
              goto Error;

          DisplayElement.Rid = Rid;
          
          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.Group),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          //
          // Copy the Admin Comment
          //

          if (AdminCommentPresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.Comment),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.Comment.Length=0;
              DisplayElement.Comment.MaximumLength = 0;
              DisplayElement.Comment.Buffer = NULL;
          }

          //
          // Add the Element to the Buffer
          //
          
          NtStatus = SampDuplicateGroupInfo(
                        (PDOMAIN_DISPLAY_GROUP) 
                                &(Buffer->GroupInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_GROUP) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:

        Buffer->GroupInformation.EntriesRead = ReturnedItems;
   

    return NtStatus;

 }

NTSTATUS
SampPackOemGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if OemGroup Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->OemGroupInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                      DomainSid = NULL;
          PSID                      ReturnedSid;
          ULONG                     AccountControlValue;
          DOMAIN_DISPLAY_GROUP      DisplayElement;
          BOOLEAN                   FullNamePresent;
          BOOLEAN                   AdminCommentPresent;
          ULONG                     NameOffset, AccCntrlOffset,
                                    AccCntrlComputedOffset,
                                    FullNameOffset, AdminCommentOffset;
          ULONG                     Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayOemGroup,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AccCntrlOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          
          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.Group),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          
          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateOemGroupInfo(
                        (PDOMAIN_DISPLAY_OEM_GROUP) 
                                &(Buffer->OemGroupInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_GROUP) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
        
        Buffer->OemGroupInformation.EntriesRead = ReturnedItems;
        

    return NtStatus;

 }

NTSTATUS
SampPackOemUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if Oem User Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->OemUserInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                      DomainSid = NULL;
          PSID                      ReturnedSid;
          ULONG                     AccountControlValue;
          DOMAIN_DISPLAY_USER       DisplayElement;
          BOOLEAN                   FullNamePresent;
          BOOLEAN                   AdminCommentPresent;
          ULONG                     NameOffset, AccCntrlOffset,
                                    AccCntrlComputedOffset,
                                    FullNameOffset, AdminCommentOffset;
          ULONG                     Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayOemUser,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AccCntrlOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          
          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.LogonName),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          
          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateOemUserInfo(
                        (PDOMAIN_DISPLAY_OEM_USER) 
                                &(Buffer->OemUserInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_USER) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
           
        Buffer->OemUserInformation.EntriesRead = ReturnedItems;
        
    return NtStatus;

 }


 NTSTATUS
 SampDsCheckDisplayAttributes(
     ATTRBLOCK * DsAttrs,
     DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
     PULONG     ObjectNameOffset,
     PULONG     UserAccountControlOffset,
     PULONG     UserAcctCtrlComputedOffset,
     PULONG     FullNameOffset,
     PULONG     AdminCommentOffset,
     BOOLEAN    * FullNamePresent,
     BOOLEAN    * AdminCommentPresent
     )
/*++
  
    Routine Description:

      This routine Validates the attribute block returned by the DS for each 
      entry in the search results. For the attribute block to be valid required
      entries such as account name must be present. Further this routine will also
      compute the offset of both required and optional attributes returned by the DS
      in the attribute block. It will also indicate if the optional attributes are
      present or absent. Further This routine will translate from the Flags values 
      stored in the DS to user account control values used by SAM

    Parameters:

       DsAttrs   -- Attribute block returned by the DS
       DisplayInformation -- The type of display information the caller is interested in
       ObjectNameOffset -- The offset of the SAM account name property in the attribute
                            block
       UserAccountControlOffset -- The offset of the user account control field if present 
       FullNameOffset   --  The offset of the full name field if present
       AdminCommentOffset -- The offset of the admin comment attribute if present

       FullNamePresent   -- Indicates that the full name attribute is present
       AdminCommentPresent -- Indicates the at the admin comment attribute is present

    Return Values


        STATUS_SUCCESS -- If the attribute block was correctly validated
        STATUS_INTERNAL_ERROR - Otherwise
--*/
 {
     ULONG  i;
     BOOLEAN    NameFound = FALSE;
     BOOLEAN    AccountControlFound = FALSE;
     BOOLEAN    AccountControlComputedFound = FALSE;
     NTSTATUS   NtStatus = STATUS_INTERNAL_ERROR;

     //
     // Every Attrblock must have a SID, and an account Name
     //

     *FullNamePresent = FALSE;
     *AdminCommentPresent = FALSE;

     for (i=0;i<DsAttrs->attrCount;i++)
     {
         
         if (DsAttrs->pAttr[i].attrTyp 
                == SampDsAttrFromSamAttr(SampUnknownObjectType,SAMP_UNKNOWN_OBJECTNAME))
         {
             *ObjectNameOffset = i;
             NameFound = TRUE;
         }

         if (DsAttrs->pAttr[i].attrTyp 
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_FIXED_USER_ACCOUNT_CONTROL))
         {
             NTSTATUS IgnoreStatus;

             *UserAccountControlOffset = i;
             AccountControlFound = TRUE;

             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal);
             ASSERT(1==DsAttrs->pAttr[i].AttrVal.valCount);
             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal);

             // Transalte this from Flags to account Control 
             IgnoreStatus = SampFlagsToAccountControl(
                                *((ULONG*)(DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal)),
                                (ULONG *)DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal
                                );

             // Flags better be right
             ASSERT(NT_SUCCESS(IgnoreStatus));
                                
         }

         if (DsAttrs->pAttr[i].attrTyp 
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED))
         {
             NTSTATUS IgnoreStatus;

             *UserAcctCtrlComputedOffset = i;
             AccountControlComputedFound = TRUE;

             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal);
             ASSERT(1==DsAttrs->pAttr[i].AttrVal.valCount);
             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal);

             // Transalte this from Flags to account Control 
             IgnoreStatus = SampFlagsToAccountControl(
                                *((ULONG*)(DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal)),
                                (ULONG *)DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal
                                );

             // Flags better be right
             ASSERT(NT_SUCCESS(IgnoreStatus));
                                
         }


         if (DsAttrs->pAttr[i].attrTyp
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_USER_ADMIN_COMMENT))
         {
             *AdminCommentOffset = i;
             *AdminCommentPresent= TRUE;
         }

         if (DsAttrs->pAttr[i].attrTyp
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_USER_FULL_NAME))
         {
             *FullNameOffset = i;
             *FullNamePresent= TRUE;
         }
     }

     //
     // Check for presence of attributes
     //

     switch(DisplayInformation)
     {
     case DomainDisplayUser:
     case DomainDisplayMachine:
     case DomainDisplayOemUser:
     case DomainDisplayServer:

         if ((NameFound) && (AccountControlFound) && (AccountControlComputedFound))
             NtStatus = STATUS_SUCCESS;
         break;

     case DomainDisplayGroup:
     case DomainDisplayOemGroup:
         if (NameFound)
             NtStatus = STATUS_SUCCESS;
         break;
     default:
         break;
     }

         
     return NtStatus;
         
 }


NTSTATUS
SampGetQDIAvailable(
    PSAMP_OBJECT    DomainContext,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG   *TotalAvailable
    )
/*++

    Routine Description:

        NT4 Display API allows the client to query the number of display 
        information bytes that are available in the server. Apparently this
        is only supported for DisplayInformation type of user. Unfortunately
        this short sighted API is impossible to implement correctly in the DS
        case. Doing so requires that we walk through every user object in the DS,
        evaluate the sum total of display attribute data in them and return this
        value to the client. Therefore this routine aims at returning only a very
        approximate total count.

    Parameters:

        DomainContext -- SAM handle to the domain object.
        DisplayInformation -- The type of display information
        TotalAvailable -- Bytes available are returned here

    Return values

        STATUS_SUCCESS
        Other Errors upon failure
--*/
{
    NTSTATUS NtStatus;
    ULONG    UserCount;
    ULONG    GroupCount;
    ULONG    AliasCount;

    *TotalAvailable = 0;

    NtStatus = SampRetrieveAccountCountsDs(
                    DomainContext,
                    TRUE,           // get approximate value
                    &UserCount,
                    &GroupCount,
                    &AliasCount
                    );
    if (NT_SUCCESS(NtStatus))
    {
        switch(DisplayInformation)
        {
        case DomainDisplayUser:

                //
                // Compute a very approximate total. User count includes
                // count of machines also, but who cares ?
                //

                *TotalAvailable = UserCount * DISPLAY_ENTRY_SIZE;
                DomainContext->TypeBody.Domain.DsDisplayState.TotalAvailable
                        = *TotalAvailable;
                break;
        default:
            //
            // Not supported for other information types. In these
            // cases an acceptable return value is 0
            //
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
DsValToUnicodeString(
    PUNICODE_STRING UnicodeString,
    ULONG   Length,
    PVOID   pVal
    )
/*++
    Routine Description

        Small helper routine to convert a DS val to unicode string

--*/
{
    UnicodeString->Length = (USHORT) Length;
    UnicodeString->MaximumLength = (USHORT) Length;
    UnicodeString->Buffer = pVal;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Abstract:

    This file contains services for maintaining the cached display
    information.

    The information is stored in multiple tables because there are
    multiple formats it must be returned in.  The tables maintained
    include:

            AccountsByRid - includes all user and global group accounts
                by RID.  Aliases may be added to this list at some time
                in the future.

            NormalUsersByName - Normal user accounts, sorted by name.

            MachinesByName - Machine user accounts, sorted by name.

            InterDomainByName - Interdomain trust accounts, sorted by
                name.

            GroupsByName - Global group accounts, sorted by name.


    Any time an entry is placed in or removed from one of "ByName"
    tables, it is also placed in or removed from the "ByRid" table.

    User and machine accounts are added to the display cache in one
    operation.  So, there is a single boolean flag indicating whether
    or not these tables are valid.  The groups are maintained in a
    separate table, and so there is another flag indicating whether
    or not that table is valid.

    The Rid table is only valid if both the group table and the
    user/machine tables are valid.



Author:

    Dave Chalmers   (Davidc)  1-April-1992

Environment:

    User Mode - Win32

Revision History:

    Murlis 12/17/96 - Modified to not use display cache for DS.


--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dbgutilp.h>
#include <dsdsply.h>
#include <samtrace.h>
#include "validate.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampCreateDisplayInformation (
    DOMAIN_DISPLAY_INFORMATION DisplayType
    );


VOID
SampDeleteDisplayInformation (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampRetrieveDisplayInfoFromDisk(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampAddDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    );

NTSTATUS
SampDeleteDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    );

NTSTATUS
SampUpdateDisplayAccount(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO  AccountInfo
    );

NTSTATUS
SampTallyTableStatistics (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampEmptyGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    BOOLEAN FreeElements,
    SAMP_OBJECT_TYPE ObjectType OPTIONAL
    );

PVOID
SampGenericTable2Allocate (
    CLONG BufferSize
    );

VOID
SampGenericTable2Free (
    PVOID Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareUserNodeByName (
    PVOID Node1,
    PVOID Node2
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareMachineNodeByName (      // Also used for Interdomain trust accounts
    PVOID Node1,
    PVOID Node2
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareGroupNodeByName (
    PVOID Node1,
    PVOID Node2
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareNodeByRid (
    PVOID Node1,
    PVOID Node2
    );


VOID
SampSwapUserInfo(
    PDOMAIN_DISPLAY_USER Info1,
    PDOMAIN_DISPLAY_USER Info2
    );

VOID
SampSwapMachineInfo(            // Also used for Interdomain trust accounts
    PDOMAIN_DISPLAY_MACHINE Info1,
    PDOMAIN_DISPLAY_MACHINE Info2
    );

VOID
SampSwapGroupInfo(
    PDOMAIN_DISPLAY_GROUP Info1,
    PDOMAIN_DISPLAY_GROUP Info2
    );

ULONG
SampBytesRequiredUserNode (
    PDOMAIN_DISPLAY_USER Node
    );

ULONG
SampBytesRequiredMachineNode (  // Also used for Interdomain trust accounts
    PDOMAIN_DISPLAY_MACHINE Node
    );

ULONG
SampBytesRequiredGroupNode (
    PDOMAIN_DISPLAY_GROUP Node
    );

ULONG
SampBytesRequiredOemUserNode (
    PDOMAIN_DISPLAY_OEM_USER Node
    );

ULONG
SampBytesRequiredOemGroupNode (
    PDOMAIN_DISPLAY_OEM_GROUP Node
    );


VOID
SampDisplayDiagnostic( VOID );

VOID
SampDisplayDiagEnumRids( VOID );





//
// Macros for deciding whether an account is:
//
//      A normal user account
//
//      A machine account
//
//      An Interdomain trust account
//
//      Included in the display cache
//
//

#define USER_ACCOUNT(AccountControl) ((AccountControl & \
                                       (USER_NORMAL_ACCOUNT | \
                                       USER_TEMP_DUPLICATE_ACCOUNT)) != 0)

#define MACHINE_ACCOUNT(AccountControl) ((AccountControl & \
                                         (USER_WORKSTATION_TRUST_ACCOUNT | \
                                          USER_SERVER_TRUST_ACCOUNT)) != 0)


#define INTERDOMAIN_ACCOUNT(AccountControl) (((AccountControl) & \
                                   (USER_INTERDOMAIN_TRUST_ACCOUNT)) != 0)


#define DISPLAY_ACCOUNT(AccountControl) (USER_ACCOUNT(AccountControl)    || \
                                         MACHINE_ACCOUNT(AccountControl) || \
                                         INTERDOMAIN_ACCOUNT(AccountControl))



//
// Test to see if Rid table is valid
//
//  BOOLEAN
//  SampRidTableValid( IN ULONG DomainIndex )
//

#define SampRidTableValid(DI)  (  \
    (SampDefinedDomains[DI].DisplayInformation.UserAndMachineTablesValid) &&   \
    (SampDefinedDomains[DI].DisplayInformation.GroupTableValid)                \
    )



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private data types                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// All entries in the display cache are expected to start with this
// data structure.
//

typedef struct _SAMP_DISPLAY_ENTRY_HEADER {

    //
    // The index field plays two roles.  Within the generic table,
    // it is used to indicate which type of account this is.  The
    // valid types are: SAM_USER_ACCOUNT, SAM_GLOBAL_GROUP_ACCOUNT,
    // or SAM_LOCAL_GROUP_ACCOUNT.
    //
    // Otherwise, this field is filled in just before being returned
    // to query and other client calls.
    //


    ULONG           Index;


    //
    // The RID of the account
    //

    ULONG           Rid;

} SAMP_DISPLAY_ENTRY_HEADER, *PSAMP_DISPLAY_ENTRY_HEADER;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module-wide variables                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LCID  SampSystemDefaultLCID;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RPC exported routines                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamrQueryDisplayInformation (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    Thin wrapper around SamrQueryDisplayInformation3().

    Provided for compatibility with down-level clients.

--*/
{
    return( SamrQueryDisplayInformation3(
                    DomainHandle,
                    DisplayInformation,
                    Index,
                    EntriesRequested,
                    PreferredMaximumLength,
                    TotalAvailable,
                    TotalReturned,
                    Buffer
                    ) );
}

NTSTATUS
SamrQueryDisplayInformation2 (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    Thin wrapper around SamrQueryDisplayInformation3().

    Provided for compatibility with down-level clients.

--*/
{
    return( SamrQueryDisplayInformation3(
                    DomainHandle,
                    DisplayInformation,
                    Index,
                    EntriesRequested,
                    PreferredMaximumLength,
                    TotalAvailable,
                    TotalReturned,
                    Buffer
                    ) );
}

NTSTATUS
SamrQueryDisplayInformation3 (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)

    The netui listboxes all contain similar information.  e.g:

      o  AccountControl, the bits that identify the account type,
         eg, HOME, REMOTE, SERVER, WORKSTATION, etc.

      o  Logon name (machine name for computers)

      o  Full name (not used for computers)

      o  Comment (admin comment for users)

    SAM maintains this data locally in two sorted indexed cached
    lists identified by infolevels.

      o DomainDisplayUser:       HOME and REMOTE user accounts only

      o  DomainDisplayMachine:   SERVER and WORKSTATION accounts only

    Note that trust accounts, groups, and aliases are not in either of
    these lists.


    Added for NT1.0A -

        o Group enumeration has been added in NT1.0A
          with the following characteristic:

               We did not change the RPC interface ID.  This allows
               callers to continue to call down-level servers.  However,
               down-level servers will return an error if they passed
               this information level.

        o OEM string info levels were added for jimh (Chicago).  These
          info levels dramatically reduce the memory needed to query
          the limited information that Chicago is interested in.


Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.

    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    Buffer - Receives a pointer to a buffer containing a (possibly)
        sorted list of the requested information.  This buffer is
        allocated by this routine and contains the following
        structure:


            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

            DomainDisplayGroup   --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_GROUP.    This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_GROUP structures.

            DomainDisplayOemUser  --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_user structures.

            DomainDisplayOemGroup --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_GROUP.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_GROUP structures.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.





--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain;

    PSAMPR_DOMAIN_DISPLAY_USER
        UserElement;

    PSAMPR_DOMAIN_DISPLAY_MACHINE
        MachineElement;

    PSAMPR_DOMAIN_DISPLAY_GROUP
        GroupElement;


    ULONG
        ReturnedBytes = 0,
        ReturnedItems = 0;

    PVOID
        RestartKey;

    BOOLEAN ReadLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(DomainHandle);


    SAMTRACE_EX("SamrQueryDisplayInformation3");


    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryDisplayInformation
                   );

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_QUERYDISPLAYS,
        FLAG_COUNTER_INCREMENT,
        0
        );


    //
    // Prepare for failure
    //

    *TotalAvailable = 0;
    *TotalReturned = 0;

    switch (DisplayInformation) {
    case DomainDisplayUser:
        Buffer->UserInformation.EntriesRead = 0;
        Buffer->UserInformation.Buffer = NULL;
        break;

    case DomainDisplayMachine:
        Buffer->MachineInformation.EntriesRead = 0;
        Buffer->MachineInformation.Buffer = NULL;
        break;

    case DomainDisplayServer:
        if ( SampUseDsData ) {
            Buffer->MachineInformation.EntriesRead = 0;
            Buffer->MachineInformation.Buffer = NULL;
            break;
        } else {
            NtStatus = STATUS_INVALID_INFO_CLASS;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto ErrorReturn;
        }

    case DomainDisplayGroup:
        Buffer->GroupInformation.EntriesRead = 0;
        Buffer->GroupInformation.Buffer = NULL;
        break;

    case DomainDisplayOemUser:
        Buffer->OemUserInformation.EntriesRead = 0;
        Buffer->OemUserInformation.Buffer = NULL;
        break;

    case DomainDisplayOemGroup:
        Buffer->OemGroupInformation.EntriesRead = 0;
        Buffer->OemGroupInformation.Buffer = NULL;
        break;

    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto ErrorReturn;
    }

    //
    // If they don't want anything, that's what they'll get
    //

    if (EntriesRequested == 0) {
        NtStatus = STATUS_SUCCESS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto ErrorReturn;
    }

    //
    // Make sure we don't try to allocate too much memory on
    // the user's behalf
    //

    if (EntriesRequested > 5000) {
        EntriesRequested = 5000;
    }

    //
    // Grab the read lock
    //

    SampAcquireReadLock();
    ReadLockAcquired = TRUE;

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LIST_ACCOUNTS,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            //
            // I am the only caller of SampDsQueryDisplayInformation()
            // We need to hold SAM lock before calling into the following
            // routing and release lock when we done.
            //

            NtStatus = SampDsQueryDisplayInformation(
                            DomainHandle,
                            DisplayInformation,
                            Index,
                            EntriesRequested,
                            PreferredMaximumLength,
                            TotalAvailable,
                            TotalReturned,
                            Buffer
                            );
        }
        else
        {

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];



            //
            // Set up the common loop statistics
            //

            ReturnedBytes = 0;
            ReturnedItems = 0;


            switch (DisplayInformation) {

            case DomainDisplayUser:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayUser);

                //
                // Set the Restart Key from the passed in index
                //

                UserElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.UserTable,
                                  Index,
                                  &RestartKey
                                  );

                if (UserElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }


                //
                // Allocate space for array of elements
                //

                Buffer->UserInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_USER));

                if (Buffer->UserInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateUserInfo(
                                (PDOMAIN_DISPLAY_USER)
                                &(Buffer->UserInformation.Buffer[ReturnedItems]),
                                (PDOMAIN_DISPLAY_USER)UserElement,
                                Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems --;
                            SampFreeUserInfo((PDOMAIN_DISPLAY_USER)
                                &(Buffer->UserInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->UserInformation.Buffer);
                        Buffer->UserInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes += SampBytesRequiredUserNode(
                                        (PDOMAIN_DISPLAY_USER)UserElement);
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    UserElement = RtlEnumerateGenericTable2(
                                      &Domain->DisplayInformation.UserTable,
                                      &RestartKey
                                      );

                    if (UserElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->UserInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = Domain->DisplayInformation.TotalBytesInUserTable;
                }

                break; // out of switch


            case DomainDisplayMachine:

                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayMachine);

                //
                // Set the Restart Key from the passed in index
                //

                MachineElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.MachineTable,
                                  Index,
                                  &RestartKey
                                  );

                if (MachineElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }

                //
                // Allocate space for array of elements
                //

                Buffer->MachineInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));

                if (Buffer->MachineInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateMachineInfo(
                                     (PDOMAIN_DISPLAY_MACHINE)
                                     &(Buffer->MachineInformation.Buffer[ReturnedItems]),
                                     (PDOMAIN_DISPLAY_MACHINE)MachineElement,
                                     Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems--;
                            SampFreeMachineInfo((PDOMAIN_DISPLAY_MACHINE)
                                &(Buffer->MachineInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->MachineInformation.Buffer);
                        Buffer->MachineInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes += SampBytesRequiredMachineNode(
                                        (PDOMAIN_DISPLAY_MACHINE)MachineElement);
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    MachineElement = RtlEnumerateGenericTable2(
                                         &Domain->DisplayInformation.MachineTable,
                                         &RestartKey
                                         );

                    if (MachineElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->MachineInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = Domain->DisplayInformation.TotalBytesInMachineTable;
                }

                break; // out of switch


            case DomainDisplayGroup:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayGroup);

                //
                // Set the Restart Key from the passed in index
                //

                GroupElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.GroupTable,
                                  Index,
                                  &RestartKey
                                  );

                if (GroupElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }

                //
                // Allocate space for array of elements
                //

                Buffer->GroupInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_GROUP));

                if (Buffer->GroupInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateGroupInfo(
                                     (PDOMAIN_DISPLAY_GROUP)
                                     &(Buffer->GroupInformation.Buffer[ReturnedItems]),
                                     (PDOMAIN_DISPLAY_GROUP)GroupElement,
                                     Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems--;
                            SampFreeGroupInfo((PDOMAIN_DISPLAY_GROUP)
                                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->GroupInformation.Buffer);
                        Buffer->GroupInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes += SampBytesRequiredGroupNode(
                                        (PDOMAIN_DISPLAY_GROUP)GroupElement);
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    GroupElement = RtlEnumerateGenericTable2(
                                         &Domain->DisplayInformation.GroupTable,
                                         &RestartKey
                                         );

                    if (GroupElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->GroupInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = Domain->DisplayInformation.TotalBytesInGroupTable;
                }

                break; // out of switch

            case DomainDisplayOemUser:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayUser);

                //
                // Set the Restart Key from the passed in index
                //

                UserElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.UserTable,
                                  Index,
                                  &RestartKey
                                  );

                if (UserElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }


                //
                // Allocate space for array of elements
                //

                Buffer->UserInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_USER));

                if (Buffer->OemUserInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateOemUserInfo(
                                (PDOMAIN_DISPLAY_OEM_USER)
                                &(Buffer->OemUserInformation.Buffer[ReturnedItems]),
                                (PDOMAIN_DISPLAY_USER)UserElement,
                                Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems --;
                            SampFreeOemUserInfo((PDOMAIN_DISPLAY_OEM_USER)
                                &(Buffer->UserInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->OemUserInformation.Buffer);
                        Buffer->OemUserInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes +=
                        SampBytesRequiredOemUserNode(
                            (PDOMAIN_DISPLAY_OEM_USER)
                            &(Buffer->OemUserInformation.Buffer[ReturnedItems]));
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    UserElement = RtlEnumerateGenericTable2(
                                      &Domain->DisplayInformation.UserTable,
                                      &RestartKey
                                      );

                    if (UserElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->UserInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = 0; // Not supported for this info level
                }

                break; // out of switch


            case DomainDisplayOemGroup:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayGroup);

                //
                // Set the Restart Key from the passed in index
                //

                GroupElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.GroupTable,
                                  Index,
                                  &RestartKey
                                  );

                if (GroupElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }


                //
                // Allocate space for array of elements
                //

                Buffer->GroupInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_GROUP));

                if (Buffer->OemGroupInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateOemGroupInfo(
                                (PDOMAIN_DISPLAY_OEM_GROUP)
                                &(Buffer->OemGroupInformation.Buffer[ReturnedItems]),
                                (PDOMAIN_DISPLAY_GROUP)GroupElement,
                                Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems --;
                            SampFreeOemGroupInfo((PDOMAIN_DISPLAY_OEM_GROUP)
                                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->OemGroupInformation.Buffer);
                        Buffer->OemGroupInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes +=
                        SampBytesRequiredOemGroupNode(
                            (PDOMAIN_DISPLAY_OEM_GROUP)
                            &(Buffer->OemGroupInformation.Buffer[ReturnedItems]));
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    GroupElement = RtlEnumerateGenericTable2(
                                      &Domain->DisplayInformation.GroupTable,
                                      &RestartKey
                                      );

                    if (GroupElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->GroupInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = 0; // Not supported for this info level
                }

                break; // out of switch

            }
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    if (ReadLockAcquired)
        SampReleaseReadLock();

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

ErrorReturn:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryDisplayInformation
                   );

    return(NtStatus);
}



NTSTATUS
SamrGetDisplayEnumerationIndex (
      IN    SAMPR_HANDLE      DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This wrapper around SamrGetDisplayEnumerationIndex2().

    Provided for compatibility with down-level clients.


--*/
{

    return(SamrGetDisplayEnumerationIndex2( DomainHandle,
                                            DisplayInformation,
                                            Prefix,
                                            Index
                                            ) );
}

NTSTATUS
SamrGetDisplayEnumerationIndex2 (
      IN    SAMPR_HANDLE      DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_NO_MORE_ENTRIES - There are no entries for this information class.


--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain;

    PRTL_GENERIC_TABLE2
        Table = NULL;

    DOMAIN_DISPLAY_USER
        UserElement;

    DOMAIN_DISPLAY_MACHINE
        MachineElement;

    DOMAIN_DISPLAY_GROUP
        GroupElement;

    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PRTL_GENERIC_2_COMPARE_ROUTINE
        CompareRoutine = NULL;

    PVOID
        Element = NULL,
        NextElement = NULL,
        RestartKey = NULL;

    ULONG
        CurrentIndex;

    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrGetDisplayEnumerationIndex2");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetDisplayEnumerationIndex
                   );


    //
    // Check the information class
    //

    if ((DisplayInformation != DomainDisplayUser)    &&
        (DisplayInformation != DomainDisplayMachine) &&
        (DisplayInformation != DomainDisplayGroup)
       ) {

        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    if( !SampValidateRpcUnicodeString( Prefix ) ) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    }


    //
    // Grab the read lock
    //

    SampAcquireReadLock();



    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LIST_ACCOUNTS,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            //
            // Begin a Ds transaction
            //

            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            if (NT_SUCCESS(NtStatus))
            {
                RESTART * pRestart;

                //
                // Call into the DS to get the Index , value and also a restart
                // structure such the QueryDisplayInformation can restart this
                // search at the object just found, if the returned index was
                // specified in the starting offset.
                //
                NtStatus = SampGetDisplayEnumerationIndex(
                                DomainContext->ObjectNameInDs,
                                DisplayInformation,
                                Prefix,
                                Index,
                                &pRestart
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    if (NULL!=DomainContext->TypeBody.Domain.DsDisplayState.Restart)
                    {
                        MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
                        DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                    }

                    NtStatus = SampCopyRestart(
                                    pRestart,
                                    &(DomainContext->TypeBody.Domain.DsDisplayState.Restart)
                                    );
                    if (NT_SUCCESS(NtStatus))
                    {
                        DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
                        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset
                                = *Index;

                        DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation
                                = DisplayInformation;
                    }
                    else
                    {
                        *Index = 0;
                        DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                    }
                }

                //
                // End the DS transaction
                //

                IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }


        }
        else
        {


            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

            //
            // Set default return value
            //

            (*Index) = 0;

            //
            // Recreate our cached data if necessary
            //

            NtStatus = SampCreateDisplayInformation(DisplayInformation);

            if (NT_SUCCESS(NtStatus)) {

                //
                // Set up
                //          The table to search,
                //          The comparison routine to use,
                //          An appropriate element for the search.
                //

                switch (DisplayInformation) {

                case DomainDisplayUser:

                    Table = &Domain->DisplayInformation.UserTable;
                    CompareRoutine = SampCompareUserNodeByName;

                    Element = (PVOID)&UserElement;
                    UserElement.LogonName = *(PUNICODE_STRING)Prefix;

                    break;  // out of switch

                case DomainDisplayMachine:

                    Table = &Domain->DisplayInformation.MachineTable;
                    CompareRoutine = SampCompareMachineNodeByName;

                    Element = (PVOID)&MachineElement;
                    MachineElement.Machine = *(PUNICODE_STRING)Prefix;

                    break;  // out of switch


                case DomainDisplayGroup:

                    Table = &Domain->DisplayInformation.GroupTable;
                    CompareRoutine = SampCompareGroupNodeByName;

                    Element = (PVOID)&GroupElement;
                    GroupElement.Group = *(PUNICODE_STRING)Prefix;

                    break;  // out of switch
                }


                if (RtlIsGenericTable2Empty(Table)) {

                    NtStatus = STATUS_NO_MORE_ENTRIES;

                } else {

                    //
                    // Now compare each entry until we find the one asked
                    // for.
                    //

                    CurrentIndex = 0;

                    RestartKey = NULL;
                    for (NextElement = RtlEnumerateGenericTable2(Table, &RestartKey);
                        NextElement != NULL;
                        NextElement = RtlEnumerateGenericTable2(Table, &RestartKey)) {

                        //
                        // Compare with passed in element
                        //

                        CompareResult = (*CompareRoutine)( NextElement, Element );
                        if (CompareResult != GenericLessThan) {
                            break;  // break out of for loop
                        }

                        CurrentIndex++;
                    }

                    //
                    // CurrentIndex has the return value in it.
                    //

                    ASSERT( CurrentIndex <= RtlNumberElementsGenericTable2(Table) );

                    (*Index) = CurrentIndex;
                    if (NULL == NextElement)
                    {
                        NtStatus = STATUS_NO_MORE_ENTRIES;
                    }
                    else
                    {
                        NtStatus = STATUS_SUCCESS;
                    }
                }
            }
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetDisplayEnumerationIndex
                   );

    return(NtStatus);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available to trusted clients in SAM's process                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )

/*++

Routine Description:

    Provide a list of account RIDs.  The caller may ask for one or
    more types of account rids in a single call.

    The returned rids are in ascending value order.

        WARNING - This routine is only callable by trusted clients.
                  Therefore, parameter checking is only performed
                  in checked-build systems.

Parameters:

    DomainHandle - handle to the domain whose accounts are to be
        enumerated.

    AccountTypesMask - Mask indicating which types of accounts
        the caller wants enumerated.  These included:

                SAM_USER_ACCOUNT
                SAM_GLOBAL_GROUP_ACCOUNT
                SAM_LOCAL_GROUP_ACCOUNT     (not yet supported)

    StartingRid - A rid that is less than the lowest value rid to be
        included in the enumeration.


    PreferedMaximumLength - Provides a restriction on how much memory
        may be returned in this call.  This is not a hard upper limit,
        but serves as a guideline.

    ReturnCount - Receives a count of the number of rids returned.

    AccountRids - Receives a pointer to an array of rids.  If
        ReturnCount is zero, then this will be returned as NULL.
        Otherwise, it will point to an array containing ReturnCount
        rids.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_INVALID_INFO_CLASS - The specified AccountTypesMask contained
        unknown or unsupported account types.

    STATUS_NO_MEMORY - Could not allocate pool to complete the call.

--*/
{

    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    BOOLEAN
        fSamLockHeld = FALSE;


    SAMTRACE_EX("SamIEnumerateAccountRids");

    //
    // Prepare for failure
    //

    (*ReturnCount) = 0;
    (*AccountRids) = NULL;

#if DBG

    if ( (AccountTypesMask & ~( SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT))
         != 0 ) {
        return(STATUS_INVALID_INFO_CLASS);
    }


#endif //DBG


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    //
    // Acquire the SAM read lock if necessary
    //

    SampMaybeAcquireReadLock(DomainContext,
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fSamLockHeld);


    NtStatus = SampLookupContext(
                   DomainContext,
                   0,                              // Trusted clients only
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            NtStatus = SampDsEnumerateAccountRids(
                            DomainHandle,
                            AccountTypesMask,
                            StartingRid,
                            PreferedMaximumLength,
                            ReturnCount,
                            AccountRids
                            );
        }
        else
        {
            //
            // Just In case
            //
            ASSERT(FALSE && "No One should call me in Registry Mode\n");
            NtStatus = STATUS_NOT_SUPPORTED;
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fSamLockHeld);

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);

}


#if 0

//
// The following routine will not been called in Registry Mode.
// We are using the above routine instead.
// Preserving the old routine just for safe keeping ONLY.
//


NTSTATUS
SamIEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )

/*++

Routine Description:

    Provide a list of account RIDs.  The caller may ask for one or
    more types of account rids in a single call.

    The returned rids are in ascending value order.

        WARNING - This routine is only callable by trusted clients.
                  Therefore, parameter checking is only performed
                  in checked-build systems.

Parameters:

    DomainHandle - handle to the domain whose accounts are to be
        enumerated.

    AccountTypesMask - Mask indicating which types of accounts
        the caller wants enumerated.  These included:

                SAM_USER_ACCOUNT
                SAM_GLOBAL_GROUP_ACCOUNT
                SAM_LOCAL_GROUP_ACCOUNT     (not yet supported)

    StartingRid - A rid that is less than the lowest value rid to be
        included in the enumeration.


    PreferedMaximumLength - Provides a restriction on how much memory
        may be returned in this call.  This is not a hard upper limit,
        but serves as a guideline.

    ReturnCount - Receives a count of the number of rids returned.

    AccountRids - Receives a pointer to an array of rids.  If
        ReturnCount is zero, then this will be returned as NULL.
        Otherwise, it will point to an array containing ReturnCount
        rids.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_INVALID_INFO_CLASS - The specified AccountTypesMask contained
        unknown or unsupported account types.

    STATUS_NO_MEMORY - Could not allocate pool to complete the call.

--*/
{

    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain;

    PRTL_GENERIC_TABLE2
        Table;

    ULONG
        MaxEntries,
        Count,
        AccountType;

    PVOID
        RestartKey;

    PSAMP_DISPLAY_ENTRY_HEADER
        Element;
    BOOLEAN
        fSamLockHeld = FALSE;

    SAMP_DISPLAY_ENTRY_HEADER
        RestartValue;

    SAMTRACE_EX("SamIEnumerateAccountRids");

    //
    // Prepare for failure
    //

    (*ReturnCount) = 0;
    (*AccountRids) = NULL;

#if DBG

    if ( (AccountTypesMask & ~( SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT))
         != 0 ) {
        return(STATUS_INVALID_INFO_CLASS);
    }


#endif //DBG

    //
    // Grab the read lock
    //

    SampAcquireReadLock();
    fSamLockHeld = TRUE;

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   0,                              // Trusted clients only
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            //
            // We can release the read lock after validating
            // the context as netlogon guarentees us that it
            // will not call a close on the context as long
            // as an active call is being made using it. Since
            // netlogon is the only caller of this API and it
            // is a trusted client we can optimize the lock usage
            // by releasing the read lock
            //

            SampReleaseReadLock();
            fSamLockHeld = FALSE;

            //
            // Since we no longer hold the lock while doing
            // ds operations we should increment the active
            // thread count so that the DS is not shut down
            // while we are still running
            //

            NtStatus = SampIncrementActiveThreads();
            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampDsEnumerateAccountRids(
                            DomainHandle,
                            AccountTypesMask,
                            StartingRid,
                            PreferedMaximumLength,
                            ReturnCount,
                            AccountRids
                            );

                SampDecrementActiveThreads();
            }

        }
        else
        {

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];
            Table =  &Domain->DisplayInformation.RidTable;

            //
            // If the RID table isn't valid, force it to be made valid.
            //

            if (!SampRidTableValid(DomainContext->DomainIndex)) {
                NtStatus = SampCreateDisplayInformation ( DomainDisplayUser );  //User and machine
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampCreateDisplayInformation ( DomainDisplayGroup );
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Allocate a return buffer.
                // Only allocate as much as we can use.
                // This is limited either by PreferedMaximumLength
                // or the number of entries in the table.
                //

                MaxEntries =
                    ( PreferedMaximumLength / sizeof(ULONG) );

                if (MaxEntries == 0) {
                    MaxEntries = 1;  // Always return at least one
                }

                if (MaxEntries > RtlNumberElementsGenericTable2(Table) ) {
                    MaxEntries = RtlNumberElementsGenericTable2(Table);
                }

                PreferedMaximumLength = MaxEntries *
                                        sizeof(SAMP_DISPLAY_ENTRY_HEADER);

                (*AccountRids) = MIDL_user_allocate( PreferedMaximumLength );
                if ((*AccountRids) == NULL) {
                    STATUS_NO_MEMORY;
                }

                //
                // Get the restart key based upon the passed in RID.
                //

                Table = &Domain->DisplayInformation.RidTable;
                RestartValue.Rid = StartingRid;

                Element = RtlRestartKeyByValueGenericTable2(
                              Table,
                              &RestartValue,
                              &RestartKey
                              );

                //
                // Now we may loop obtaining entries until we reach
                // either MaxEntries or the end of the table.
                //
                // WARNING - there is one special case that we have to
                // take care of.  If the returned Element is not null,
                // but the RestartKey is null, then the caller has
                // asked for an enumeration and passed in the last rid
                // defined.  If we aren't careful, this will cause an
                // enumeration to be started from the beginning of the
                // list again.  Instead, return status indicating we have
                // no more entries.
                //

                Count = 0;
                if (((Element != NULL) && (RestartKey == NULL))) {

                    Element = NULL;  // Used to signify no more entries found

                } else {

                    for (Element  = RtlEnumerateGenericTable2(Table, &RestartKey);
                         ( (Element != NULL)  && (Count < MaxEntries) );
                         Element = RtlEnumerateGenericTable2(Table, &RestartKey)) {

                        //
                        // Make sure this is an account that was asked for
                        //

                        AccountType = Element->Index;
                        if ((AccountType & AccountTypesMask) != 0) {
                            (*AccountRids)[Count] = Element->Rid;
                            Count++;
                        }
                    }
                }

                //
                // Now figure out what we have done:
                //
                //      Returned all entries in table => STATUS_SUCCESS
                //      More entries to return => STATUS_MORE_ENTRIES
                //
                //      Count == 0 => free AccountRid array.
                //

                if (Element == NULL) {
                    NtStatus = STATUS_SUCCESS;
                } else {
                    NtStatus = STATUS_MORE_ENTRIES;
                }

                if (Count == 0) {
                    MIDL_user_free( (*AccountRids) );
                    (*AccountRids) = NULL;
                }

                (*ReturnCount) = Count;

            }
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //
    if (fSamLockHeld)
    {
        SampReleaseReadLock();
        fSamLockHeld = FALSE;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);


}

#endif // 0



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available to other SAM modules                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampInitializeDisplayInformation (
    ULONG DomainIndex
    )

/*++

Routine Description:

    This routines initializes the display information structure.
    This involves initializing the User, Machine and Group trees (empty),
    and setting the Valid flag to FALSE.

    If this is the account domain, we also create the display information.

Parameters:

    DomainIndex - An index into the DefinedDomains array.  This array
        contains information about the domain being openned,
        including its name.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;

    //
    // This must be initialized before we use SampCompareDisplayStrings().
    //

    SampSystemDefaultLCID = GetSystemDefaultLCID();

    DisplayInformation = &SampDefinedDomains[DomainIndex].DisplayInformation;

    RtlInitializeGenericTable2(
                &DisplayInformation->UserTable,
                SampCompareUserNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->MachineTable,
                SampCompareMachineNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->InterdomainTable,
                SampCompareMachineNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->GroupTable,
                SampCompareGroupNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->RidTable,
                SampCompareNodeByRid,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    DisplayInformation->UserAndMachineTablesValid = FALSE;
    DisplayInformation->GroupTableValid = FALSE;

    if ( ( SampProductType == NtProductLanManNt) &&
         ( FALSE == SampUseDsData) &&
         (DomainIndex == SampDefinedDomainsCount - 1 )) {

        //
        // Grab the read lock and indicate which domain the transaction is in
        //

        SampAcquireReadLock();
        SampSetTransactionDomain( DomainIndex );

        //
        // Populate the Display Cache
        //

        SAMTRACE("SAMSS: Attempting to create display information\n");

        (VOID) SampCreateDisplayInformation(DomainDisplayUser);
        (VOID) SampCreateDisplayInformation(DomainDisplayGroup);

        SAMTRACE("SAMSS: Finished creating display information\n");

        //
        // Free the read lock
        //

        SampReleaseReadLock();
    }

    return(STATUS_SUCCESS);

}



VOID
SampDeleteDisplayInformation (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routines frees up any resources used by the display information.


    Note:  It use to be that we could selectively invalidate
            portions of the display cache (e.g., users, or groups).
            With the addition of the RID table, this becomes
            problematic.  So, now the approach is to flush all tables
            for a domain if any the tables in that domain are flushed.


Parameters:

    DisplayInformation - The display information structure to delete.

    ObjectType - Indicates which table to delete the information from.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    NTSTATUS    NtStatus;


    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {
        //
        // Empty the Rid table and check it really is empty.
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->RidTable,
                                          FALSE,
                                          0);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->RidTable));

        DisplayInformation->TotalBytesInRidTable = 0;


        //
        // Remember that we keep the same account information in two
        // places. One is in the individual table (would be User, Group,
        // Machine, InterDomainTrust), the other is in the Rid Table.
        // So we cannot really delete the actual generic table DATA until
        // this point in this function, otherwise we'll have dangling pointer.
        //

        //
        // But we shouldn't even bother here.
        //

        //
        // Empty the user table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->UserTable,
                                          TRUE,
                                          SampUserObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->UserTable));

        DisplayInformation->TotalBytesInUserTable = 0;



        //
        // Empty the machine table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->MachineTable,
                                          TRUE,
                                          SampUserObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->MachineTable));

        DisplayInformation->TotalBytesInMachineTable = 0;



        //
        // Empty the Interdomain table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->InterdomainTable,
                                          TRUE,
                                          SampUserObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->InterdomainTable));

        DisplayInformation->TotalBytesInInterdomainTable = 0;



        //
        // Empty the Group table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->GroupTable,
                                          TRUE,
                                          SampGroupObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->GroupTable));

        DisplayInformation->TotalBytesInGroupTable = 0;


        //
        // Mark Both UserTable and GroupTable Invalid
        //
        DisplayInformation->UserAndMachineTablesValid = FALSE;
        DisplayInformation->GroupTableValid = FALSE;

    }


}



NTSTATUS
SampMarkDisplayInformationInvalid (
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine invalidates any cached display information. This
    causes it to be recreated the next time a client queries it.
    Later we will probably start/restart a thread here and have it
    re-create the display information in the background.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

    Another Note:  It use to be that we could selectively invalidate
            portions of the display cache (e.g., users, or groups).
            With the addition of the RID table, this becomes
            problematic.  So, now the approach is to flush all tables
            for a domain if any the tables in that domain are flushed.


Parameters:

    ObjectType - SampUserObjectType or SampGroupObjectType.  Only the
        appropriate tables will be marked Invalid.  For User type, the
        user and machine tables will be marked Invalid.  For Group type,
        the group table will be marked Invalid.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    PSAMP_DEFINED_DOMAINS Domain;

    ASSERT(SampTransactionWithinDomain == TRUE);

    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {

        SampDiagPrint(DISPLAY_CACHE,
                     ("SAM: MarkDisplayInformationInvalid : Emptying cache\n"));

        //
        // Get pointer to the current domain structure
        //

        Domain = &SampDefinedDomains[SampTransactionDomainIndex];

        //
        // Delete any cached data
        //

        SampDeleteDisplayInformation(&Domain->DisplayInformation, ObjectType);

        //
        // Set the Valid flag to FALSE
        //

        Domain->DisplayInformation.UserAndMachineTablesValid = FALSE;
        Domain->DisplayInformation.GroupTableValid = FALSE;
    }


    return(STATUS_SUCCESS);

}



NTSTATUS
SampCreateDisplayInformation (
    DOMAIN_DISPLAY_INFORMATION DisplayType
    )

/*++

Routine Description:

    This routine builds the cached display information for the current
    domain.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().

Parameters:

    DisplayType - Indicates which type of display information is
        being created.  This leads us to the appropriate table(s).

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain;
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;

    SAMTRACE("SampCreateDisplayInformation");


    ASSERT(SampTransactionWithinDomain == TRUE);

    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {
        //
        // We will build display information only if we boot from registry
        //

        Domain = &SampDefinedDomains[SampTransactionDomainIndex];


        DisplayInformation = &Domain->DisplayInformation;

        switch (DisplayType) {
        case DomainDisplayUser:
        case DomainDisplayMachine:

            //
            // If the cache is valid, nothing to do
            //

            if (DisplayInformation->UserAndMachineTablesValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation : User/Machine Cache is valid, nothing to do\n"));
                return(STATUS_SUCCESS);
            };


            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: CreateDisplayInformation : Creating user/machine cache...\n"));

            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->UserTable));
            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->MachineTable));
            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->InterdomainTable));


            NtStatus = SampRetrieveDisplayInfoFromDisk( DisplayInformation, SampUserObjectType );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampTallyTableStatistics(DisplayInformation, SampUserObjectType);
            }

            //
            // Clean up on error

            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation FAILED: 0x%lx\n", NtStatus));

                SampDeleteDisplayInformation(&Domain->DisplayInformation, SampUserObjectType);
            } else {
                Domain->DisplayInformation.UserAndMachineTablesValid = TRUE;
            }

            break;   // out of switch


        case DomainDisplayGroup:

            //
            // If the cache is valid, nothing to do
            //

            if (DisplayInformation->GroupTableValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation : Group Cache is valid, nothing to do\n"));

                return(STATUS_SUCCESS);
            };


            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: CreateDisplayInformation : Creating group cache...\n"));

            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->GroupTable));


            NtStatus = SampRetrieveDisplayInfoFromDisk( DisplayInformation, SampGroupObjectType );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampTallyTableStatistics(DisplayInformation, SampGroupObjectType);
            }

            //
            // Clean up on error

            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation FAILED: 0x%lx\n", NtStatus));
                SampDeleteDisplayInformation(&Domain->DisplayInformation, SampGroupObjectType);
            } else {
                Domain->DisplayInformation.GroupTableValid = TRUE;
            }

            break;   // out of switch
        }
    }

    return(NtStatus);
}

ULONG MaxEnumSize = 10000;


NTSTATUS
SampRetrieveDisplayInfoFromDisk(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    )

{
    NTSTATUS NtStatus;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    PSAMPR_ENUMERATION_BUFFER EnumerationBuffer;
    ULONG i;
    ULONG CountReturned;
    BOOLEAN MoreEntries;


    SAMTRACE("SampRetrieveDisplayInfoFromDisk");

    //
    // Enumerate the accounts.
    // For each account, get the relevant information on it,
    // and add to either the UserTable, MachineTable, or GroupTable.
    //

    EnumerationContext = 0;

    do {

        NtStatus = SampEnumerateAccountNames(
                       ObjectType,
                       &EnumerationContext,
                       &EnumerationBuffer,
                       MaxEnumSize,               // PreferedMaximumLength
                       0L,                         // no filter
                       &CountReturned,
                       FALSE                       // trusted client
                       );
        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint( DISPLAY_CACHE_ERRORS,
                           ("SAM: Retrieve Info From Disk - "
                            "Error enumerating account names (0x%lx)\n",
                            NtStatus) );
            break;
        }



        //
        // Print Dignostic Message Regarding what is available
        //

        SampDiagPrint(DISPLAY_CACHE,("SAMSS: SampEnumerateAccounNames"
                                        "Enumeration Context = %x"
                                        "Enumeration Buffer  = %p"
                                        "Count Returned = %d"
                                        "Return Value = %x\n",
                                        (ULONG) EnumerationContext,
                                        EnumerationBuffer,
                                        (ULONG) CountReturned,
                                        NtStatus));
        //
        // Make a note if there are more entries
        //

        MoreEntries = (NtStatus == STATUS_MORE_ENTRIES);


        //
        // For each account, get the necessary information for it
        // and add to the appropriate display information table
        //

        for (i = 0; i < EnumerationBuffer->EntriesRead; i++) {

            ULONG                   AccountRid =
                                    EnumerationBuffer->Buffer[i].RelativeId;
            PUNICODE_STRING         AccountName =
                                    (PUNICODE_STRING)&(EnumerationBuffer->Buffer[i].Name);
            SAMP_V1_0A_FIXED_LENGTH_USER UserV1aFixed; // Contains account control
            SAMP_V1_0A_FIXED_LENGTH_GROUP GroupV1Fixed; // Contains attributes
            SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;
            PSAMP_OBJECT            AccountContext;


            //
            // Open a context to the account
            //

            NtStatus = SampCreateAccountContext(
                            ObjectType,
                            AccountRid,
                            TRUE, // Trusted client
                            FALSE,// Loopback client
                            TRUE, // Account exists
                            &AccountContext
                            );

            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint( DISPLAY_CACHE_ERRORS,
                               ("SAM: Retrieve Info From Disk - "
                                "Error Creating account context (0x%lx)\n",
                                NtStatus) );
                break; // out of for loop
            }


            //
            // Get the account control information
            //

            switch (ObjectType) {
                case SampUserObjectType:

                    NtStatus = SampRetrieveUserV1aFixed(AccountContext, &UserV1aFixed);
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve USER From Disk - "
                                    "Error getting V1a Fixed (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }


                    //
                    // If this is not an account we're interested in skip it
                    //

                    if (!DISPLAY_ACCOUNT(UserV1aFixed.UserAccountControl)) {
                        SampDeleteContext( AccountContext );
                        continue; // next account
                    }



                    //
                    // Get the admin comment
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   FALSE, // Don't make copy
                                   &AccountInfo.Comment
                                   );

                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve USER From Disk - "
                                    "Error getting admin comment (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }


                    //
                    // Get the full name
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   FALSE, // Don't make copy
                                   &AccountInfo.FullName
                                   );

                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve USER From Disk - "
                                    "Error getting full name (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }

                    //
                    // Set the  account control
                    //

                    AccountInfo.AccountControl = UserV1aFixed.UserAccountControl;

                    break;  // out of switch

                case SampGroupObjectType:

                    NtStatus = SampRetrieveGroupV1Fixed(AccountContext, &GroupV1Fixed);
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve GROUP From Disk - "
                                    "Error getting V1 fixed (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }

                    //
                    // Get the admin comment
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_GROUP_ADMIN_COMMENT,
                                   FALSE, // Don't make copy
                                   &AccountInfo.Comment
                                   );
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve GROUP From Disk - "
                                    "Error getting admin comment (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }

                    //
                    // Set the  attributes
                    //

                    AccountInfo.AccountControl = GroupV1Fixed.Attributes;

                    break;  // out of switch
            }


            //
            // Now add this account to the cached data
            //

            AccountInfo.Rid = AccountRid;
            AccountInfo.Name = *((PUNICODE_STRING)(&EnumerationBuffer->Buffer[i].Name));

            NtStatus = SampAddDisplayAccount(DisplayInformation,
                                             ObjectType,
                                             &AccountInfo);

            //
            // We're finished with the account context
            //

            SampDeleteContext( AccountContext );

            //
            // Check the result of adding the account to the cache
            //

            if (!NT_SUCCESS(NtStatus)) {
                break; // out of for loop
            }


        } // end_for


        //
        // Free up the enumeration buffer returned
        //

        SamIFree_SAMPR_ENUMERATION_BUFFER(EnumerationBuffer);

    } while ( MoreEntries );

    return(NtStatus);

}


NTSTATUS
SampUpdateDisplayInformation (
    PSAMP_ACCOUNT_DISPLAY_INFO  OldAccountInfo OPTIONAL,
    PSAMP_ACCOUNT_DISPLAY_INFO  NewAccountInfo OPTIONAL,
    SAMP_OBJECT_TYPE            ObjectType
    )

/*++

Routine Description:

    This routines updates the cached display information to reflect
    changes to a single account.

    If any error occurs, this routine marks the cached information
    Invalid so it will get fixed during re-creation.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Parameters:

    OldAccountInfo - The old information for this account. If this is NULL
                     then the account is being added.
                     The only fields required in the OldAccountInfo are
                        Name
                        AccountControl
                        Rid

    NewAccountInfo - The new information for this account. If this is NULL
                     then the account is being deleted.


    ObjectType - Indicates whether the account is a user account or
        group account.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain;
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;
    BOOLEAN DoUpdate;

    ASSERT( ARGUMENT_PRESENT(OldAccountInfo) ||
            ARGUMENT_PRESENT(NewAccountInfo)
            );

    ASSERT( !SampUseDsData );

    ASSERT(SampTransactionWithinDomain == TRUE);


    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {

        Domain = &SampDefinedDomains[SampTransactionDomainIndex];
        DisplayInformation = &Domain->DisplayInformation;


        IF_SAMP_GLOBAL( DISPLAY_CACHE ) {

            if (ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Updating cache for old account <%wZ>, new <%wZ>\n",
                                &OldAccountInfo->Name, &NewAccountInfo->Name));
            }
            if (!ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Adding account <%wZ> to cache\n",
                                &NewAccountInfo->Name));
            }
            if (ARGUMENT_PRESENT(OldAccountInfo) && !ARGUMENT_PRESENT(NewAccountInfo)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Deleting account <%wZ> from cache\n",
                                &OldAccountInfo->Name));
            }
        } //end_IF_SAMP_GLOBAL


        switch (ObjectType) {

        case SampUserObjectType:

            //
            // If the cache is Invalid there's nothing to do
            //

            if (!DisplayInformation->UserAndMachineTablesValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : User Cache is Invalid, nothing to do\n"));

                return(STATUS_SUCCESS);
            };


            //
            // If this is an update to an existing account then try
            // to do an inplace update of the cache.
            // If this fails because it's too complex etc, then revert to
            // the less efficient method of deleting the old, then adding the new.
            //

            DoUpdate = FALSE;
            if (ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {

                //
                // We can only do an update if both old and new accounts
                // are types that we keep in the display cache.
                //

                if ( DISPLAY_ACCOUNT(OldAccountInfo->AccountControl) &&
                     DISPLAY_ACCOUNT(NewAccountInfo->AccountControl) ) {

                    //
                    // We can only do an update if the account is still of
                    // the same type. i.e. it hasn't jumped cache table.
                    //

                    if ( (USER_ACCOUNT(OldAccountInfo->AccountControl) ==
                          USER_ACCOUNT(NewAccountInfo->AccountControl)) &&
                         (MACHINE_ACCOUNT(OldAccountInfo->AccountControl) ==
                          MACHINE_ACCOUNT(NewAccountInfo->AccountControl)) ) {

                        //
                        // We can only do an update if the account name hasn't changed
                        //

                        if (RtlEqualUnicodeString( &OldAccountInfo->Name,
                                                   &NewAccountInfo->Name,
                                                   FALSE // Case sensitive
                                                   )) {
                            //
                            // Everything has been checked out - we can do an update
                            //

                            DoUpdate = TRUE;
                        }
                    }
                }
            }

            break;  // out of switch

        case SampGroupObjectType:

            //
            // If the cache is already Invalid there's nothing to do
            //

            if (!DisplayInformation->GroupTableValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Group Cache is Invalid, nothing to do\n"));

                return(STATUS_SUCCESS);
            };


            //
            // If this is an update to an existing account then try
            // and do an inplace update of the cache.
            // If this fails because it's too complex etc, then revert to
            // the less efficient method of deleting the old, then adding the new.
            //

            DoUpdate = FALSE;
            if (ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {

                //
                // We can only do an update if the account name hasn't changed
                //

                if (RtlEqualUnicodeString( &OldAccountInfo->Name,
                                          &NewAccountInfo->Name,
                                          FALSE // Case sensitive
                                          )) {
                    DoUpdate = TRUE;
                }
            }

            break;  // out of switch

        default:

            ASSERT(FALSE && "Invalide SAM ObjectType for DisplayInfo\n");
            return(STATUS_INTERNAL_ERROR);

        }


        //
        // Do an update if possible, otherwise do delete then insert
        //

        if (DoUpdate) {

            NtStatus = SampUpdateDisplayAccount(DisplayInformation,
                                                ObjectType,
                                                NewAccountInfo);

        } else {

            NtStatus = STATUS_SUCCESS;

            //
            // Delete the old account
            //

            if (ARGUMENT_PRESENT(OldAccountInfo)) {
                NtStatus = SampDeleteDisplayAccount(DisplayInformation,
                                                    ObjectType,
                                                    OldAccountInfo);
            }

            //
            // Add the new account
            //

            if (NT_SUCCESS(NtStatus) && ARGUMENT_PRESENT(NewAccountInfo)) {
                NtStatus = SampAddDisplayAccount(DisplayInformation,
                                                 ObjectType,
                                                 NewAccountInfo);
            }

            //
            // Re-tally the cache
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampTallyTableStatistics(DisplayInformation, ObjectType);
            }
        }



        if (!NT_SUCCESS(NtStatus)) {

            //
            // Something is messed up.
            // Mark the cache Invalid - it will get rebuilt from scratch
            // at the next query.
            //

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: The display cache is inconsistent, forcing rebuild\n"));

            NtStatus = SampMarkDisplayInformationInvalid(ObjectType);
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_SUCCESS;
        }
    }


    return(NtStatus);
}





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available within this module only                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampDeleteDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    )

/*++

Routine Description:

    This routines deletes the specified account from the cached display
    information. It is asummed that if this account is a cached type it
    will appear in the appropriate cache table.

Parameters:

    DisplayInformation - Pointer to cached display information

    ObjectType - Indicates which table(s) to look for the account in.

    AccountInfo - The account to be deleted.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_INTERNAL_ERROR - the account is a cached type yet could not be
                            found in the cached data.
--*/
{
    NTSTATUS NtStatus;
    ULONG Control = AccountInfo->AccountControl;
    BOOLEAN Success;

    //
    // We expect the cache to be valid
    //
#if DBG
    switch (ObjectType) {
    case SampUserObjectType:
        ASSERT(DisplayInformation->UserAndMachineTablesValid);
        break;  //out of switch

    case SampGroupObjectType:
        ASSERT(DisplayInformation->GroupTableValid);
        break;  //out of switch
    }
#endif //DBG


    SampDiagPrint(DISPLAY_CACHE,
        ("SAM: DeleteDisplayAccount : Deleting account <%wZ>\n", &AccountInfo->Name));



    switch (ObjectType) {
    case SampUserObjectType:

        if (USER_ACCOUNT(Control)) {

            DOMAIN_DISPLAY_USER LocalUserInfo;
            PDOMAIN_DISPLAY_USER UserInfo;
            PDOMAIN_DISPLAY_USER TempUserInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from user table\n"));

            UserInfo = &LocalUserInfo;
            NtStatus = SampInitializeUserInfo(AccountInfo, &UserInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {
                //
                //     First, lookup the account from the cached table,
                //     get the reference to the data. If the lookup failed,
                //     that means the account is a cached type, but can not
                //     been found in the table, return STATUS_INTERNAL_wERROR.
                //
                //     If the lookup succeeded, then delete the reference
                //     to the account data from both the user table and Rid
                //     table.
                //
                //     At the end, free the memory of the account data.
                //
                //     (We should do the same thing for other Cached
                //      Display Types.)
                //
                //
                TempUserInfo = RtlLookupElementGenericTable2(
                                &DisplayInformation->UserTable,
                                (PVOID)UserInfo);

                //
                // Delete the account reference from the user table
                //
                Success = RtlDeleteElementGenericTable2(
                                        &DisplayInformation->UserTable,
                                        (PVOID)UserInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                       ("SAM: DeleteDisplayAccount : Failed to delete element from user table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // Now remove reference from the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)UserInfo);

                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                           ASSERT(Success);
                       } else
                    {
                        //
                        // Successfully remove references from both
                        // user table and Rid table, safe to free the
                        // memory.
                        //
                        if (TempUserInfo != NULL)
                        {
                            SampFreeUserInfo(TempUserInfo);
                            MIDL_user_free(TempUserInfo);
                            TempUserInfo = NULL;
                        }
                    }
                }

            }


        } else if (MACHINE_ACCOUNT(Control)) {

            DOMAIN_DISPLAY_MACHINE LocalMachineInfo;
            PDOMAIN_DISPLAY_MACHINE MachineInfo;
            PDOMAIN_DISPLAY_MACHINE TempMachineInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from machine table\n"));

            MachineInfo = &LocalMachineInfo;
            NtStatus = SampInitializeMachineInfo(AccountInfo, &MachineInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {

                TempMachineInfo = RtlLookupElementGenericTable2(
                                    &DisplayInformation->MachineTable,
                                    (PVOID)MachineInfo);

                //
                // Delete the account from the machine table
                //

                Success = RtlDeleteElementGenericTable2(
                                            &DisplayInformation->MachineTable,
                                            (PVOID)MachineInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: DeleteDisplayAccount : Failed to delete element from machine table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now remove it to the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)MachineInfo);
                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                        ASSERT(Success);
                    } else
                    {
                        if (TempMachineInfo != NULL)
                        {
                            SampFreeMachineInfo( TempMachineInfo );
                            MIDL_user_free( TempMachineInfo );
                            TempMachineInfo = NULL;
                        }
                    }
                }
            }

        } else if (INTERDOMAIN_ACCOUNT(Control)) {

            //
            // Interdomain account
            //

            DOMAIN_DISPLAY_MACHINE LocalInterdomainInfo;
            PDOMAIN_DISPLAY_MACHINE InterdomainInfo;
            PDOMAIN_DISPLAY_MACHINE TempInterdomainInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from Interdomain table\n"));

            InterdomainInfo = &LocalInterdomainInfo;
            NtStatus = SampInitializeMachineInfo(AccountInfo, &InterdomainInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {

                TempInterdomainInfo = RtlLookupElementGenericTable2(
                                        &DisplayInformation->InterdomainTable,
                                        (PVOID)InterdomainInfo);

                //
                // Delete the account from the Interdomain table
                //

                Success = RtlDeleteElementGenericTable2(
                                            &DisplayInformation->InterdomainTable,
                                            (PVOID)InterdomainInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: DeleteDisplayAccount : Failed to delete element from Interdomain table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now remove it to the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)InterdomainInfo);
                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                        ASSERT(Success);
                    } else
                    {
                        if (TempInterdomainInfo != NULL)
                        {
                            SampFreeMachineInfo( TempInterdomainInfo );
                            MIDL_user_free( TempInterdomainInfo );
                            TempInterdomainInfo = NULL;
                        }
                    }
                }
            }

        } else {

            //
            // This account is not one that we cache - nothing to do
            //

            NtStatus = STATUS_SUCCESS;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Account is not one that we cache, account control = 0x%lx\n", Control));
        }


        break;  //out of switch





    case SampGroupObjectType:

        {

            DOMAIN_DISPLAY_GROUP LocalGroupInfo;
            PDOMAIN_DISPLAY_GROUP GroupInfo;
            PDOMAIN_DISPLAY_GROUP TempGroupInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from Group table\n"));

            GroupInfo = &LocalGroupInfo;
            NtStatus = SampInitializeGroupInfo(AccountInfo, &GroupInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {

                TempGroupInfo = RtlLookupElementGenericTable2(
                                        &DisplayInformation->GroupTable,
                                        (PVOID)GroupInfo);

                //
                // Delete the account from the Group table
                //

                Success = RtlDeleteElementGenericTable2(
                                            &DisplayInformation->GroupTable,
                                            (PVOID)GroupInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: DeleteDisplayAccount : Failed to delete element from Group table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now remove it to the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)GroupInfo);
                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                        ASSERT(Success);
                    }else
                    {
                        if (TempGroupInfo != NULL)
                        {
                            SampFreeGroupInfo( TempGroupInfo );
                            MIDL_user_free( TempGroupInfo );
                            TempGroupInfo = NULL;
                        }
                    }

                }
            }

            break;  //out of switch
        }

    }


    return(STATUS_SUCCESS);
}



NTSTATUS
SampAddDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    )

/*++

Routine Description:

    This routines adds the specified account to the cached display
    information as appropriate to its type.

Parameters:

    DisplayInformation - Pointer to cached display information

    ObjectType - SampUserObjectType or SampGroupObjectType.  Helps
        determine which table it goes into.

    AccountInfo - The account to be added.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_INTERNAL_ERROR - the account already existed in the cache
--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Control = AccountInfo->AccountControl;

    BOOLEAN
        NewElement;


    if (ObjectType == SampGroupObjectType) {

        PDOMAIN_DISPLAY_GROUP GroupInfo;

        SampDiagPrint(DISPLAY_CACHE,
            ("SAM: AddDisplayAccount : Adding account to group table\n"));

        NtStatus = SampInitializeGroupInfo(AccountInfo, &GroupInfo, TRUE);
        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the account to the Group table
            //

            (VOID)RtlInsertElementGenericTable2(
                            &DisplayInformation->GroupTable,
                            GroupInfo,
                            &NewElement);
            if (!NewElement) {
                SampDiagPrint(DISPLAY_CACHE_ERRORS,
                    ("SAM: AddDisplayAccount : Account already exists in GROUP table\n"));
                ASSERT(FALSE);
                SampFreeGroupInfo(GroupInfo);
                MIDL_user_free(GroupInfo);
                GroupInfo = NULL;
                NtStatus = STATUS_INTERNAL_ERROR;
            } else {

                //
                // Now add it to the RID table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->RidTable,
                                GroupInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE_ERRORS,
                        ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                    NtStatus = STATUS_INTERNAL_ERROR;
                    ASSERT(NewElement);
                }

            }
        }

    } else {

        ASSERT(ObjectType == SampUserObjectType);

        if (USER_ACCOUNT(Control)) {

            PDOMAIN_DISPLAY_USER UserInfo;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Adding account to user table\n"));

            NtStatus = SampInitializeUserInfo(AccountInfo, &UserInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the account to the normal user table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->UserTable,
                                UserInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE_ERRORS,
                        ("SAM: AddDisplayAccount : Account already exists in USER table\n"));
                    ASSERT(FALSE);
                    SampFreeUserInfo(UserInfo);
                    MIDL_user_free(UserInfo);
                    UserInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now add it to the RID table
                    //

                    (VOID)RtlInsertElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    UserInfo,
                                    &NewElement);

                    if (!NewElement) {
                        SampDiagPrint(DISPLAY_CACHE_ERRORS,
                            ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                }
            }

        } else if (MACHINE_ACCOUNT(Control)) {

            PDOMAIN_DISPLAY_MACHINE MachineInfo;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Adding account to machine table\n"));

            NtStatus = SampInitializeMachineInfo(AccountInfo, &MachineInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the account to the machine table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->MachineTable,
                                MachineInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: AddDisplayAccount : Account already exists in MACHINE table\n"));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(MachineInfo);
                    MIDL_user_free(MachineInfo);
                    MachineInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now add it to the RID table
                    //

                    (VOID)RtlInsertElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    MachineInfo,
                                    &NewElement);

                    if (!NewElement) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                        ASSERT(NewElement);
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                }
            }
        } else if (INTERDOMAIN_ACCOUNT(Control)) {

            PDOMAIN_DISPLAY_MACHINE InterdomainInfo;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Adding account to Interdomain table\n"));

            NtStatus = SampInitializeMachineInfo(AccountInfo, &InterdomainInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the account to the Interdomain table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->InterdomainTable,
                                InterdomainInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: AddDisplayAccount : Account already exists in Interdomain table\n"));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(InterdomainInfo);
                    MIDL_user_free(InterdomainInfo);
                    InterdomainInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now add it to the RID table
                    //

                    (VOID)RtlInsertElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    InterdomainInfo,
                                    &NewElement);

                    if (!NewElement) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                        ASSERT(NewElement);
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                }
            }

        } else {

            //
            // This account is not one that we cache - nothing to do
            //

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Account is not one that we cache, account control = 0x%lx\n", Control));

            NtStatus = STATUS_SUCCESS;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampUpdateDisplayAccount(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO  AccountInfo
    )

/*++

Routine Description:

    This routines attempts to update an account in the display cache.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Parameters:

    DisplayInformation - Pointer to cached display information

    ObjectType - Indicates whether the account is a user account or
        group account.

    AccountInfo - The new information for this account.

Return Values:

    STATUS_SUCCESS - normal, successful completion.


Notes:

    The account must be a cached type (MACHINE/USER/GROUP)

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SampDiagPrint(DISPLAY_CACHE,
        ("SAM: UpdateDisplayAccount : Updating cached account <%wZ>\n",
        &AccountInfo->Name));

#if SAMP_DIAGNOSTICS
    {
        UNICODE_STRING
            SampDiagAccountName;

        RtlInitUnicodeString( &SampDiagAccountName, L"SAMP_DIAG" );

        if (RtlEqualUnicodeString(&AccountInfo->Name, &SampDiagAccountName, FALSE)) {
            SampDisplayDiagnostic();
        }

    }
#endif //SAMP_DIAGNOSTICS


    //
    // We should only be called when the cache is valid.
    //

    switch (ObjectType) {
    case SampUserObjectType:

        ASSERT(DisplayInformation->UserAndMachineTablesValid);

        //
        // The account must be one that we cache
        //

        ASSERT( DISPLAY_ACCOUNT(AccountInfo->AccountControl) );

        //
        // Go find the account in the appropriate table and update it's fields.
        //

        if (USER_ACCOUNT(AccountInfo->AccountControl)) {

            PDOMAIN_DISPLAY_USER UserInfo;

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeUserInfo(AccountInfo, &UserInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_USER FoundElement;

                //
                // Search for the account in the user table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->UserTable,
                                UserInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in user table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeUserInfo(UserInfo);
                    MIDL_user_free(UserInfo);
                    UserInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the logon name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->LogonName, &UserInfo->LogonName, FALSE));
                    ASSERT(FoundElement->Rid == UserInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapUserInfo(FoundElement, UserInfo);
                    SampFreeUserInfo(UserInfo);
                    MIDL_user_free(UserInfo);
                    UserInfo = NULL;
                }
            }

        } else if (MACHINE_ACCOUNT(AccountInfo->AccountControl)) {

            PDOMAIN_DISPLAY_MACHINE MachineInfo;

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeMachineInfo(AccountInfo, &MachineInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_MACHINE FoundElement;

                //
                // Search for the account in the user table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->MachineTable,
                                MachineInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in machine table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(MachineInfo);
                    MIDL_user_free(MachineInfo);
                    MachineInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the account name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->Machine, &MachineInfo->Machine, FALSE));
                    ASSERT(FoundElement->Rid == MachineInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapMachineInfo(FoundElement, MachineInfo);
                    SampFreeMachineInfo(MachineInfo);
                    MIDL_user_free(MachineInfo);
                    MachineInfo = NULL;
                }
            }

        } else if (INTERDOMAIN_ACCOUNT(AccountInfo->AccountControl)) {

            PDOMAIN_DISPLAY_MACHINE InterdomainInfo;

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeMachineInfo(AccountInfo, &InterdomainInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_MACHINE FoundElement;

                //
                // Search for the account in the user table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->InterdomainTable,
                                InterdomainInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in Interdomain table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(InterdomainInfo);
                    MIDL_user_free(InterdomainInfo);
                    InterdomainInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the account name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->Machine, &InterdomainInfo->Machine, FALSE));
                    ASSERT(FoundElement->Rid == InterdomainInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapMachineInfo(FoundElement, InterdomainInfo);
                    SampFreeMachineInfo(InterdomainInfo);
                    MIDL_user_free(InterdomainInfo);
                    InterdomainInfo = NULL;
                }
            }
        }


        break;  // out of switch

    case SampGroupObjectType:
        {
            PDOMAIN_DISPLAY_GROUP GroupInfo;

            ASSERT(DisplayInformation->GroupTableValid);

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeGroupInfo(AccountInfo, &GroupInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_GROUP FoundElement;

                //
                // Search for the account in the group table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->GroupTable,
                                GroupInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in group table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeGroupInfo(GroupInfo);
                    MIDL_user_free(GroupInfo);
                    GroupInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the account name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->Group, &GroupInfo->Group, FALSE));
                    ASSERT(FoundElement->Rid == GroupInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapGroupInfo(FoundElement, GroupInfo);
                    SampFreeGroupInfo(GroupInfo);
                    MIDL_user_free(GroupInfo);
                    GroupInfo = NULL;
                }
            }
        }

        break;  // out of switch

    }  // end_switch



    return(NtStatus);
}



NTSTATUS
SampTallyTableStatistics (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routines runs through the cached data tables and totals
    up the number of bytes in all elements of each table and stores
    in the displayinfo.

Parameters:

    DisplayInformation - The display information structure to tally.

    ObjectType - Indicates which table(s) to tally.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    PVOID Node;
    PVOID RestartKey;


    switch (ObjectType) {
    case SampUserObjectType:

        DisplayInformation->TotalBytesInUserTable = 0;
        RestartKey = NULL;

        for (Node = RtlEnumerateGenericTable2(  &DisplayInformation->UserTable,
                                                &RestartKey);
             Node != NULL;
             Node = RtlEnumerateGenericTable2(  &DisplayInformation->UserTable,
                                                &RestartKey)
            ) {

            DisplayInformation->TotalBytesInUserTable +=
                SampBytesRequiredUserNode((PDOMAIN_DISPLAY_USER)Node);
        }

        DisplayInformation->TotalBytesInMachineTable = 0;
        RestartKey = NULL;

        for (Node = RtlEnumerateGenericTable2(  &DisplayInformation->MachineTable,
                                                &RestartKey);
             Node != NULL;
             Node = RtlEnumerateGenericTable2(  &DisplayInformation->MachineTable,
                                                &RestartKey)
            ) {


            DisplayInformation->TotalBytesInMachineTable +=
                SampBytesRequiredMachineNode((PDOMAIN_DISPLAY_MACHINE)Node);
        }

        break;  // out of switch


    case SampGroupObjectType:

        DisplayInformation->TotalBytesInGroupTable = 0;
        RestartKey = NULL;

        for (Node = RtlEnumerateGenericTable2(  &DisplayInformation->GroupTable,
                                                &RestartKey);
             Node != NULL;
             Node = RtlEnumerateGenericTable2(  &DisplayInformation->GroupTable,
                                                &RestartKey)
            ) {


            DisplayInformation->TotalBytesInGroupTable +=
                SampBytesRequiredGroupNode((PDOMAIN_DISPLAY_GROUP)Node);
        }

        break;  // out of switch

    } // end_switch
    return(STATUS_SUCCESS);
}



NTSTATUS
SampEmptyGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    BOOLEAN FreeElements,
    SAMP_OBJECT_TYPE ObjectType OPTIONAL
    )

/*++

Routine Description:

    This routines deletes all elements in the specified table.

Parameters:

    Table - The table whose elements are to be deleted.

    FreeElements - Indicates whether or not the element bodies
        should also be freed.

    ObjectType -- Indicates the account type. Only used when FreeElements is TRUE

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    BOOLEAN     Deleted;
    PVOID       Element;
    PVOID       RestartKey;

    RestartKey = NULL;  // Always get the first element
    while ((Element = RtlEnumerateGenericTable2( Table, (PVOID *)&RestartKey)) != NULL) {

        Deleted = RtlDeleteElementGenericTable2(Table, Element);
        ASSERT(Deleted);

        if (FreeElements) {

            //
            // If caller asks us to free the Data, we should
            // first free account specified infomation,
            // then free the element structure.
            //

            switch (ObjectType)
            {
            case SampUserObjectType:

                if (USER_ACCOUNT(((PDOMAIN_DISPLAY_USER) Element)->AccountControl) )
                {
                    SampFreeUserInfo(Element);
                }
                else
                {
                    ASSERT( (MACHINE_ACCOUNT(((PDOMAIN_DISPLAY_MACHINE)Element)->AccountControl) ||
                             INTERDOMAIN_ACCOUNT(((PDOMAIN_DISPLAY_MACHINE)Element)->AccountControl)
                            )
                            && "We should not cache this account"
                          );

                    SampFreeMachineInfo(Element);
                }

                break;

            case SampGroupObjectType:

                SampFreeGroupInfo(Element);

                break;

            default:

                ASSERT( FALSE && "We should not cache this account");
            }

            MIDL_user_free(Element);
        }

        RestartKey = NULL;
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampInitializeUserInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_USER *UserInfo,
    BOOLEAN CopyData
    )

/*++

Routine Description:

    This routines initializes the passed user info structure from the
    AccountInfo parameter.

Parameters:

    AccountInfo - The account information

    UserInfo - Pointer to the pointer to the user structure to initialize.
        If CopyData is TRUE, then a pointer to the user structure will be
        returned to this argument.

    CopyData - FALSE - the UserInfo structure points to the same data as
                       the AccountInfo structure
               TRUE  - space for the data is allocated and all data copied
                       out of the AccountInfo structure into it.

Return Values:

    STATUS_SUCCESS - UserInfo initialized successfully.

    STATUS_NO_MEMORY - Heap could not be allocated to copy the data.

--*/
{
    NTSTATUS
        NtStatus;

    PDOMAIN_DISPLAY_USER
        UI;

    if (CopyData) {
        (*UserInfo) = MIDL_user_allocate( sizeof(DOMAIN_DISPLAY_USER) );
        if ((*UserInfo) == NULL) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: Init User Info: failed to allocate %d bytes\n",
                 sizeof(DOMAIN_DISPLAY_USER)) );
            return(STATUS_NO_MEMORY);
        }
    }

    UI = (*UserInfo);


    UI->Rid = AccountInfo->Rid;
    UI->AccountControl = AccountInfo->AccountControl;

    if (CopyData) {

        //
        // Set all strings to NULL initially
        //

        RtlInitUnicodeString(&UI->LogonName, NULL);
        RtlInitUnicodeString(&UI->AdminComment, NULL);
        RtlInitUnicodeString(&UI->FullName, NULL);

        //
        // Copy source data into destination
        //

        NtStatus = SampDuplicateUnicodeString(&UI->LogonName,
                                              &AccountInfo->Name);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&UI->AdminComment,
                                                  &AccountInfo->Comment);
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampDuplicateUnicodeString(&UI->FullName,
                                                      &AccountInfo->FullName);
            }
        }

        //
        // Clean up on failure
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: SampInitializeUserInfo failed, status = 0x%lx\n", NtStatus));
            SampFreeUserInfo(UI);
            MIDL_user_free(UI);
            UI = NULL;
        }

    } else {

        //
        // Refer to source data directly
        //

        UI->LogonName = AccountInfo->Name;
        UI->AdminComment = AccountInfo->Comment;
        UI->FullName = AccountInfo->FullName;

        NtStatus = STATUS_SUCCESS;
    }


    //
    // In the Generic Table, the Index field is used to tag the type
    // of account so we can filter enumerations.
    //

    if (NT_SUCCESS(NtStatus))
    {
        UI->Index = SAM_USER_ACCOUNT;
    }

    return(NtStatus);
}



NTSTATUS
SampInitializeMachineInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_MACHINE *MachineInfo,
    BOOLEAN CopyData
    )

/*++

Routine Description:

    This routines initializes the passed machine info structure from the
    AccountInfo parameter.

Parameters:

    AccountInfo - The account information

    MachineInfo - Pointer to the pointer to the Machine structure to initialize.
        If CopyData is TRUE, then a pointer to the structure will be
        returned to this argument.

    CopyData - FALSE - the MachineInfo structure points to the same data as
                       the AccountInfo structure
               TRUE  - space for the data is allocated and all data copied
                       out of the AccountInfo structure into it.

Return Values:

    STATUS_SUCCESS - UserInfo initialized successfully.

--*/
{
    NTSTATUS
        NtStatus;

    PDOMAIN_DISPLAY_MACHINE
        MI;

    if (CopyData) {
        (*MachineInfo) = MIDL_user_allocate( sizeof(DOMAIN_DISPLAY_MACHINE) );
        if ((*MachineInfo) == NULL) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: Init Mach Info: failed to allocate %d bytes\n",
                 sizeof(DOMAIN_DISPLAY_MACHINE)) );
            return(STATUS_NO_MEMORY);
        }
    }

    MI = (*MachineInfo);

    MI->Rid = AccountInfo->Rid;
    MI->AccountControl = AccountInfo->AccountControl;

    if (CopyData) {

        //
        // Set all strings to NULL initially
        //

        RtlInitUnicodeString(&MI->Machine, NULL);
        RtlInitUnicodeString(&MI->Comment, NULL);

        //
        // Copy source data into destination
        //

        NtStatus = SampDuplicateUnicodeString(&MI->Machine,
                                              &AccountInfo->Name);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&MI->Comment,
                                                  &AccountInfo->Comment);
        }

        //
        // Clean up on failure
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: SampInitializeMachineInfo failed, status = 0x%lx\n", NtStatus));
            SampFreeMachineInfo(MI);
            MIDL_user_free(MI);
            MI = NULL;
        }

    } else {

        //
        // Refer to source data directly
        //

        MI->Machine = AccountInfo->Name;
        MI->Comment = AccountInfo->Comment;

        NtStatus = STATUS_SUCCESS;
    }

    //
    // In the Generic Table, the Index field is used to tag the type
    // of account so we can filter enumerations.
    //

    if (NT_SUCCESS(NtStatus))
    {
        MI->Index = SAM_USER_ACCOUNT;
    }

    return(NtStatus);
}


NTSTATUS
SampInitializeGroupInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_GROUP *GroupInfo,
    BOOLEAN CopyData
    )

/*++

Routine Description:

    This routines initializes the passed Group info structure from the
    AccountInfo parameter.

Parameters:

    AccountInfo - The account information

    GroupInfo - Pointer to the pointer to the Group structure to initialize.
        If CopyData is TRUE, then a pointer to the structure will be
        returned to this argument.

    CopyData - FALSE - the GroupInfo structure points to the same data as
                       the AccountInfo structure
               TRUE  - space for the data is allocated and all data copied
                       out of the AccountInfo structure into it.

Return Values:

    STATUS_SUCCESS - GroupInfo initialized successfully.

--*/
{
    NTSTATUS
        NtStatus;

    PDOMAIN_DISPLAY_GROUP
        GI;

    if (CopyData) {
        (*GroupInfo) = MIDL_user_allocate( sizeof(DOMAIN_DISPLAY_GROUP) );
        if ((*GroupInfo) == NULL) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: Init Group Info: failed to allocate %d bytes\n",
                 sizeof(DOMAIN_DISPLAY_GROUP)) );
            return(STATUS_NO_MEMORY);
        }
    }

    GI = (*GroupInfo);


    GI->Rid = AccountInfo->Rid;
    GI->Attributes = AccountInfo->AccountControl;

    if (CopyData) {

        //
        // Set all strings to NULL initially
        //

        RtlInitUnicodeString(&GI->Group, NULL);
        RtlInitUnicodeString(&GI->Comment, NULL);

        //
        // Copy source data into destination
        //

        NtStatus = SampDuplicateUnicodeString(&GI->Group,
                                              &AccountInfo->Name);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&GI->Comment,
                                                  &AccountInfo->Comment);
        }

        //
        // Clean up on failure
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: SampInitializeGroupInfo failed, status = 0x%lx\n", NtStatus));
            SampFreeGroupInfo(GI);
            MIDL_user_free(GI);
            GI = NULL;
        }

    } else {

        //
        // Refer to source data directly
        //

        GI->Group = AccountInfo->Name;
        GI->Comment = AccountInfo->Comment;

        NtStatus = STATUS_SUCCESS;
    }

    //
    // In the Generic Table, the Index field is used to tag the type
    // of account so we can filter enumerations.
    //

    if (NT_SUCCESS(NtStatus))
    {
        GI->Index = SAM_GLOBAL_GROUP_ACCOUNT;
    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateUserInfo(
    PDOMAIN_DISPLAY_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;
    Destination->Rid = Source->Rid;
    Destination->AccountControl = Source->AccountControl;

    //
    // Set all strings to NULL initially
    //

    RtlInitUnicodeString(&Destination->LogonName, NULL);
    RtlInitUnicodeString(&Destination->AdminComment, NULL);
    RtlInitUnicodeString(&Destination->FullName, NULL);

    //
    // Copy source data into destination
    //

    NtStatus = SampDuplicateUnicodeString(&Destination->LogonName,
                                          &Source->LogonName);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampDuplicateUnicodeString(&Destination->AdminComment,
                                              &Source->AdminComment);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&Destination->FullName,
                                                  &Source->FullName);
        }
    }

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateUserInfo failed, status = 0x%lx\n", NtStatus));
        SampFreeUserInfo(Destination);

    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateMachineInfo(
    PDOMAIN_DISPLAY_MACHINE Destination,
    PDOMAIN_DISPLAY_MACHINE Source,
    ULONG                   Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;
    Destination->Rid = Source->Rid;
    Destination->AccountControl = Source->AccountControl;

    //
    // Set all strings to NULL initially
    //

    RtlInitUnicodeString(&Destination->Machine, NULL);
    RtlInitUnicodeString(&Destination->Comment, NULL);

    //
    // Copy source data into destination
    //

    NtStatus = SampDuplicateUnicodeString(&Destination->Machine,
                                          &Source->Machine);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampDuplicateUnicodeString(&Destination->Comment,
                                              &Source->Comment);
    }

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateMachineInfo failed, status = 0x%lx\n", NtStatus));
        SampFreeMachineInfo(Destination);
    }

    return(NtStatus);
}


NTSTATUS
SampDuplicateGroupInfo(
    PDOMAIN_DISPLAY_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                 Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;
    Destination->Rid = Source->Rid;
    Destination->Attributes = Source->Attributes;

    //
    // Set all strings to NULL initially
    //

    RtlInitUnicodeString(&Destination->Group, NULL);
    RtlInitUnicodeString(&Destination->Comment, NULL);

    //
    // Copy source data into destination
    //

    NtStatus = SampDuplicateUnicodeString(&Destination->Group,
                                          &Source->Group);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampDuplicateUnicodeString(&Destination->Comment,
                                              &Source->Comment);
    }

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateGroupInfo failed, status = 0x%lx\n", NtStatus));
        SampFreeGroupInfo(Destination);
    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of a subset of
        the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;

    //
    // Set all strings to NULL initially
    //

    RtlInitString(&Destination->User, NULL);


    //
    // Copy source data into destination
    //

    NtStatus = SampUnicodeToOemString(&Destination->User,
                                      &Source->LogonName);

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateOemUser failed, status = 0x%lx\n", NtStatus));
        RtlInitString(&Destination->User, NULL);
    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of a subset of
        the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;

    //
    // Set all strings to NULL initially
    //

    RtlInitString(&Destination->Group, NULL);


    //
    // Copy source data into destination
    //

    NtStatus = SampUnicodeToOemString(&Destination->Group,
                                      &Source->Group);

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateOemGroup failed, status = 0x%lx\n", NtStatus));
        RtlInitString(&Destination->Group, NULL);
    }

    return(NtStatus);
}



VOID
SampSwapUserInfo(
    PDOMAIN_DISPLAY_USER Info1,
    PDOMAIN_DISPLAY_USER Info2
    )

/*++

Routine Description:

    Swap the field contents of Info1 and Info2.

Parameters:

    Info1 & Info2 - The structures whose contents are to be swapped.


Return Values:

    None

--*/
{

    DOMAIN_DISPLAY_USER
        Tmp;

    Tmp.LogonName      = Info1->LogonName;
    Tmp.AdminComment   = Info1->AdminComment;
    Tmp.FullName       = Info1->FullName;
    Tmp.AccountControl = Info1->AccountControl;

    Info1->LogonName      = Info2->LogonName;
    Info1->AdminComment   = Info2->AdminComment;
    Info1->FullName       = Info2->FullName;
    Info1->AccountControl = Info2->AccountControl;

    Info2->LogonName      = Tmp.LogonName;
    Info2->AdminComment   = Tmp.AdminComment;
    Info2->FullName       = Tmp.FullName;
    Info2->AccountControl = Tmp.AccountControl;

    return;
}


VOID
SampSwapMachineInfo(
    PDOMAIN_DISPLAY_MACHINE Info1,
    PDOMAIN_DISPLAY_MACHINE Info2
    )

/*++

Routine Description:

    Swap the field contents of Info1 and Info2.

Parameters:

    Info1 & Info2 - The structures whose contents are to be swapped.


Return Values:

    None

--*/
{

    DOMAIN_DISPLAY_MACHINE
        Tmp;

    Tmp.Machine        = Info1->Machine;
    Tmp.Comment        = Info1->Comment;
    Tmp.AccountControl = Info1->AccountControl;

    Info1->Machine        = Info2->Machine;
    Info1->Comment        = Info2->Comment;
    Info1->AccountControl = Info2->AccountControl;

    Info2->Machine        = Tmp.Machine;
    Info2->Comment        = Tmp.Comment;
    Info2->AccountControl = Tmp.AccountControl;

    return;
}


VOID
SampSwapGroupInfo(
    PDOMAIN_DISPLAY_GROUP Info1,
    PDOMAIN_DISPLAY_GROUP Info2
    )

/*++

Routine Description:

    Swap the field contents of Info1 and Info2.

Parameters:

    Info1 & Info2 - The structures whose contents are to be swapped.


Return Values:

    None

--*/
{

    DOMAIN_DISPLAY_GROUP
        Tmp;

    Tmp.Group      = Info1->Group;
    Tmp.Comment    = Info1->Comment;
    Tmp.Attributes = Info1->Attributes;

    Info1->Group      = Info2->Group;
    Info1->Comment    = Info2->Comment;
    Info1->Attributes = Info2->Attributes;

    Info2->Group      = Tmp.Group;
    Info2->Comment    = Tmp.Comment;
    Info2->Attributes = Tmp.Attributes;

    return;
}


VOID
SampFreeUserInfo(
    PDOMAIN_DISPLAY_USER UserInfo
    )

/*++

Routine Description:

    Frees data associated with a userinfo structure.

Parameters:

    UserInfo - User structure to free


Return Values:

    None

--*/
{
    SampFreeUnicodeString(&UserInfo->LogonName);
    SampFreeUnicodeString(&UserInfo->AdminComment);
    SampFreeUnicodeString(&UserInfo->FullName);

    return;
}



VOID
SampFreeMachineInfo(
    PDOMAIN_DISPLAY_MACHINE MachineInfo
    )

/*++

Routine Description:

    Frees data associated with a machineinfo structure.

Parameters:

    UserInfo - User structure to free

Return Values:

    None

--*/
{
    SampFreeUnicodeString(&MachineInfo->Machine);
    SampFreeUnicodeString(&MachineInfo->Comment);

    return;
}


VOID
SampFreeGroupInfo(
    PDOMAIN_DISPLAY_GROUP GroupInfo
    )

/*++

Routine Description:

    Frees data associated with a Groupinfo structure.

Parameters:

    UserInfo - User structure to free

Return Values:

    None

--*/
{
    SampFreeUnicodeString(&GroupInfo->Group);
    SampFreeUnicodeString(&GroupInfo->Comment);

    return;
}



VOID
SampFreeOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER UserInfo
    )

/*++

Routine Description:

    Frees data associated with a UserInfo structure.

Parameters:

    UserInfo - User structure to free


Return Values:

    None

--*/
{
    SampFreeOemString(&UserInfo->User);

    return;
}



VOID
SampFreeOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP GroupInfo
    )

/*++

Routine Description:

    Frees data associated with a GroupInfo structure.

Parameters:

    GroupInfo - Group structure to free


Return Values:

    None

--*/
{
    SampFreeOemString(&GroupInfo->Group);

    return;
}



ULONG
SampBytesRequiredUserNode (
    PDOMAIN_DISPLAY_USER Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) +
            Node->LogonName.Length +
            Node->AdminComment.Length +
            Node->FullName.Length
            );
}



ULONG
SampBytesRequiredMachineNode (
    PDOMAIN_DISPLAY_MACHINE Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) +
            Node->Machine.Length +
            Node->Comment.Length
            );
}


ULONG
SampBytesRequiredGroupNode (
    PDOMAIN_DISPLAY_GROUP Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) + Node->Group.Length + Node->Comment.Length );
}


ULONG
SampBytesRequiredOemUserNode (
    PDOMAIN_DISPLAY_OEM_USER Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) + Node->User.Length );
}


ULONG
SampBytesRequiredOemGroupNode (
    PDOMAIN_DISPLAY_OEM_GROUP Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) + Node->Group.Length );
}



PVOID
SampGenericTable2Allocate (
    CLONG BufferSize
    )

/*++

Routine Description:

    This routine is used by the generic table2 package to allocate
    memory.

Parameters:

    BufferSize - the number of bytes needed.

Return Values:

    Pointer to the allocated memory

--*/
{
    PVOID
        Buffer;

    Buffer = MIDL_user_allocate(BufferSize);
#if DBG
    if (Buffer == NULL) {
        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                       ("SAM: GenTab alloc of %d bytes failed.\n",
                        BufferSize) );
    }
#endif //DBG
    return(Buffer);
}



VOID
SampGenericTable2Free (
    PVOID Buffer
    )

/*++

Routine Description:

    This routines frees memory previously allocated using
    SampGenericTable2Allocate().

Parameters:

    Node - the memory to free.

Return Values:

    None.

--*/
{
    //
    // Free up the base structure
    //

    MIDL_user_free(Buffer);

    return;
}



RTL_GENERIC_COMPARE_RESULTS
SampCompareUserNodeByName (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares account name fields of two user nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{
    PUNICODE_STRING
        NodeName1,
        NodeName2;

    LONG
        NameComparison;

    NodeName1 = &((PDOMAIN_DISPLAY_USER)Node1)->LogonName;
    NodeName2 = &((PDOMAIN_DISPLAY_USER)Node2)->LogonName;

    //
    // Do a case-insensitive comparison of the node names
    //

    NameComparison = SampCompareDisplayStrings(NodeName1, NodeName2, TRUE);

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
SampCompareMachineNodeByName (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares account name fields of two machine nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{
    PUNICODE_STRING
        NodeName1,
        NodeName2;

    LONG
        NameComparison;



    NodeName1 = &((PDOMAIN_DISPLAY_MACHINE)Node1)->Machine;
    NodeName2 = &((PDOMAIN_DISPLAY_MACHINE)Node2)->Machine;


    //
    // Do a case-insensitive comparison of the node names
    //

    NameComparison = SampCompareDisplayStrings(NodeName1, NodeName2, TRUE);

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
SampCompareGroupNodeByName (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares account name fields of two group nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{
    PUNICODE_STRING
        NodeName1,
        NodeName2;

    LONG
        NameComparison;



    NodeName1 = &((PDOMAIN_DISPLAY_GROUP)Node1)->Group;
    NodeName2 = &((PDOMAIN_DISPLAY_GROUP)Node2)->Group;

    //
    // Do a case-insensitive comparison of the node names
    //


    NameComparison = SampCompareDisplayStrings(NodeName1, NodeName2, TRUE);

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
SampCompareNodeByRid (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares the RID of two nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{

    PDOMAIN_DISPLAY_USER
        N1,
        N2;

    //
    // This routine assumes that all nodes have RIDs in the same
    // place, regardless of node type.
    //

    ASSERT(FIELD_OFFSET(DOMAIN_DISPLAY_USER,    Rid) ==
           FIELD_OFFSET(DOMAIN_DISPLAY_MACHINE, Rid));
    ASSERT(FIELD_OFFSET(DOMAIN_DISPLAY_USER,    Rid) ==
           FIELD_OFFSET(DOMAIN_DISPLAY_GROUP,   Rid));

    N1 = Node1;
    N2 = Node2;


    if (N1->Rid < N2->Rid) {
        return(GenericLessThan);
    }

    if (N1->Rid > N2->Rid) {
        return(GenericGreaterThan);
    }

    return(GenericEqual);
}


LONG
SampCompareDisplayStrings(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN IgnoreCase
    )
/*++

Routine Description:

    This routine is a replacement for RtlCompareUnicodeString().
    The difference between RtlCompareUnicodeString() and this routine
    is that this routine takes into account various customer selected
    sort criteria (like, how is "A-MarilF" sorted in comparison to
    "Alfred").  This routine uses CompareStringW() for its comparison
    function.


Parameters:

    String1 - Points to a unicode string to compare.

    String2 - Points to a unicode string to compare.

    IgnoreCase - indicates whether the comparison is to be case
        sensitive (FALSE) or case insensitive (TRUE).

Return Values:


    -1 - String1 is lexically less than string 2.  That is, String1
         preceeds String2 in an ordered list.

     0 - String1 and String2 are lexically equivalent.

    -1 - String1 is lexically greater than string 2.  That is, String1
         follows String2 in an ordered list.


--*/


{

    INT
        CompareResult;

    DWORD
        Options = 0;

    if (IgnoreCase) {
        Options = NORM_IGNORECASE;
    }

    CompareResult = CompareStringW( SampSystemDefaultLCID,
                                     Options,
                                     String1->Buffer,
                                     (String1->Length / sizeof(WCHAR)),
                                     String2->Buffer,
                                     (String2->Length / sizeof(WCHAR))
                                     );

    //
    // Note that CompareStringW() returns values 1, 2, and 3 for
    // string1 less than, equal, or greater than string2 (respectively)
    // So, to obtain the RtlCompareUnicodeString() return values of
    // -1, 0, and 1 for the same meaning, we simply have to subtract 2.
    //

    CompareResult -= 2;

    //
    // CompareStringW has the property that alternate spellings may
    // produce strings that compare identically while the rest of SAM
    // treats the strings as different.  To get around this, if the
    // strings are the same we call RtlCompareUnicodeString to make
    // sure the strings really are the same.
    //

    if (CompareResult == 0) {
        CompareResult = RtlCompareUnicodeString(
                            String1,
                            String2,
                            IgnoreCase
                            );

    }
    return(CompareResult);
}


#if SAMP_DIAGNOSTICS


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal diagnostics                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SAMP_DISPLAY_DIAG_ENUM_RIDS         (0x00000001)

VOID
SampDisplayDiagnosticSuccess(
    IN  NTSTATUS s,
    IN  BOOLEAN Eol
    )

/*++

Routine Description:

    This routine prints "Success" or "Failure" depending upon the
    the passed in status value.

    If failure, it also prints the status code.


Parameters:

    s - the status value.

    Eol - if TRUE, causes an end of line to also be printed.


Return Values:


--*/
{
    if (NT_SUCCESS(s)) {
        SampDiagPrint(DISPLAY_CACHE, ("Success"));
    } else {
        SampDiagPrint(DISPLAY_CACHE, ("Failure - Status: 0x%lx", s));
    }

    if (Eol) {
        SampDiagPrint(DISPLAY_CACHE, ("\n"));
    }
    return;
}


VOID
SampDisplayDiagnostic(
    VOID
    )

/*++

Routine Description:

    This routine provides internal diagnostics and test capabilities.

    This routine is called whenever an account called SAMP_DIAG is
    modified such that the display cache requires updating.

    This routine breakpoints, allowing diagnostic parameters to be set.


Parameters:

    None.

Return Values:


--*/
{

    ULONG
        DiagnosticRunCount = 0,
        DiagnosticsToRun = 0;

    SampDiagPrint(DISPLAY_CACHE,
                  ("SAM: SampDisplayDiagnostic() called.\n"
                   "     Breakpointing to allow diagnostic parameters to be set.\n"
                   "     Diagnostic Flag Word: 0x%lx\n"
                   "     Diagnostic values: \n"
                   "          SamIEnumerateAccountRids:      0x%lx\n"
                   "\n",
                   &DiagnosticsToRun,
                   SAMP_DISPLAY_DIAG_ENUM_RIDS
                   ) );
    DbgBreakPoint();

    if ((DiagnosticsToRun & SAMP_DISPLAY_DIAG_ENUM_RIDS) != 0) {
        SampDisplayDiagEnumRids();
        DiagnosticRunCount++;
    }


    SampDiagPrint(DISPLAY_CACHE,
                  ("SAM: SampDisplayDiagnostic()  - %d diagnostics run.\n",
                   DiagnosticRunCount) );


    return;
}


VOID
SampDisplayDiagEnumRids(
    VOID
    )

/*++

Routine Description:

    This routine tests the RID table enumeration api
    (SamIEnumerateAccountRids()).


Parameters:

    None.

Return Values:


--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        i,
        ReturnCount,
        LastRid = 0;

    PULONG
        AccountRids;

    SAMPR_HANDLE
        Server,
        Domain;

    SampDiagPrint(DISPLAY_CACHE,
                  ("SAM: Testing SamIEnumerateAccountRids...\n"));


    NtStatus = SamIConnect( L"",        //ServerName
                            &Server,    //ServerHandle
                            0,          //DesiredAccess
                            TRUE        //TrustedClient
                            );
    ASSERT(NT_SUCCESS(NtStatus));

    NtStatus = SamrOpenDomain( Server,
                               0,                           //DesiredAccess
                               SampDefinedDomains[1].Sid,   //DomainId
                               &Domain
                               );
    ASSERT(NT_SUCCESS(NtStatus));



    
    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Enumerate both USERs and GLOBAL GROUPs                        //
    //                                                               //
    ///////////////////////////////////////////////////////////////////


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating first three users and global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT,
                                         0,                 //StartingRid
                                         3*sizeof(ULONG),   //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 100 accounts
    //


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 100 users and global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT,
                                         LastRid,           //StartingRid
                                         100*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 4000 accounts
    //


    if (NtStatus == STATUS_MORE_ENTRIES) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     Enumerating next 4000 users and global groups...") );
        NtStatus = SamIEnumerateAccountRids( Domain,
                                             SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT,
                                             LastRid,           //StartingRid
                                             400*sizeof(ULONG), //PreferedMaximumLength
                                             &ReturnCount,
                                             &AccountRids
                                             );

        SampDisplayDiagnosticSuccess( NtStatus, TRUE );
        if (NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE,
                          ("     %d entries returned.\n", ReturnCount));
            if (ReturnCount > 0) {
                ASSERT(AccountRids != NULL);
                i=0;
                if (ReturnCount > 8) {
                    for (i=0; i<ReturnCount-8; i=i+8) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                             AccountRids[i+0], AccountRids[i+1],
                             AccountRids[i+2], AccountRids[i+3],
                             AccountRids[i+4], AccountRids[i+5],
                             AccountRids[i+6], AccountRids[i+7] ));
                    }
                }
                for (i=i; i<ReturnCount; i++) {
                    SampDiagPrint(DISPLAY_CACHE,
                                  ("     0x%lx  ", AccountRids[i]));
                }
                SampDiagPrint(DISPLAY_CACHE, ("\n"));
                LastRid = AccountRids[i];
                MIDL_user_free(AccountRids);
            } else {
                ASSERT(AccountRids == NULL);
            }
        }
    }


    
    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Now try just USER accounts                                    //
    //                                                               //
    ///////////////////////////////////////////////////////////////////

    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating first three users ...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT,
                                         0,                 //StartingRid
                                         3*sizeof(ULONG),   //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 100 accounts
    //


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 100 users...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT,
                                         LastRid,           //StartingRid
                                         100*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 4000 accounts
    //


    if (NtStatus == STATUS_MORE_ENTRIES) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     Enumerating next 4000 users...") );
        NtStatus = SamIEnumerateAccountRids( Domain,
                                             SAM_USER_ACCOUNT,
                                             LastRid,           //StartingRid
                                             400*sizeof(ULONG), //PreferedMaximumLength
                                             &ReturnCount,
                                             &AccountRids
                                             );

        SampDisplayDiagnosticSuccess( NtStatus, TRUE );
        if (NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE,
                          ("     %d entries returned.\n", ReturnCount));
            if (ReturnCount > 0) {
                ASSERT(AccountRids != NULL);
                i=0;
                if (ReturnCount > 8) {
                    for (i=0; i<ReturnCount-8; i=i+8) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                             AccountRids[i+0], AccountRids[i+1],
                             AccountRids[i+2], AccountRids[i+3],
                             AccountRids[i+4], AccountRids[i+5],
                             AccountRids[i+6], AccountRids[i+7] ));
                    }
                }
                for (i=i; i<ReturnCount; i++) {
                    SampDiagPrint(DISPLAY_CACHE,
                                  ("     0x%lx  ", AccountRids[i]));
                }
                SampDiagPrint(DISPLAY_CACHE, ("\n"));
                LastRid = AccountRids[i];
                MIDL_user_free(AccountRids);
            } else {
                ASSERT(AccountRids == NULL);
            }
        }
    }

    
    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Now just try GLOBAL GROUPs                                    //
    //                                                               //
    ///////////////////////////////////////////////////////////////////


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating first three global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_GLOBAL_GROUP_ACCOUNT,
                                         0,                 //StartingRid
                                         3*sizeof(ULONG),   //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 100 accounts
    //


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 100 global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_GLOBAL_GROUP_ACCOUNT,
                                         LastRid,           //StartingRid
                                         100*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 4000 accounts
    //


    if (NtStatus == STATUS_MORE_ENTRIES) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     Enumerating next 4000 global groups...") );
        NtStatus = SamIEnumerateAccountRids( Domain,
                                             SAM_GLOBAL_GROUP_ACCOUNT,
                                             LastRid,           //StartingRid
                                             4000*sizeof(ULONG), //PreferedMaximumLength
                                             &ReturnCount,
                                             &AccountRids
                                             );

        SampDisplayDiagnosticSuccess( NtStatus, TRUE );
        if (NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE,
                          ("     %d entries returned.\n", ReturnCount));
            if (ReturnCount > 0) {
                ASSERT(AccountRids != NULL);
                i=0;
                if (ReturnCount > 8) {
                    for (i=0; i<ReturnCount-8; i=i+8) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                             AccountRids[i+0], AccountRids[i+1],
                             AccountRids[i+2], AccountRids[i+3],
                             AccountRids[i+4], AccountRids[i+5],
                             AccountRids[i+6], AccountRids[i+7] ));
                    }
                }
                for (i=i; i<ReturnCount; i++) {
                    SampDiagPrint(DISPLAY_CACHE,
                                  ("     0x%lx  ", AccountRids[i]));
                }
                SampDiagPrint(DISPLAY_CACHE, ("\n"));
                LastRid = AccountRids[i];
                MIDL_user_free(AccountRids);
            } else {
                ASSERT(AccountRids == NULL);
            }
        }
    }



    //
    // Now try to continue an enumeration from the very last RID.
    // At one point in time, this use to restart the enumeration
    // (which was not correct behaviour).  It should indicate that
    // there are no more entries.
    //

    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 5 global groups.."
                   "     (should be none to enumerate)   ...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_GLOBAL_GROUP_ACCOUNT,
                                         LastRid,           //StartingRid
                                         5*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            SampDiagPrint(DISPLAY_CACHE,
                      ("    ERROR - there should be no RIDs returned ! !\n"));
            ASSERT(AccountRids != NULL);
            i=0;
            if (ReturnCount > 8) {
                for (i=0; i<ReturnCount-8; i=i+8) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                         AccountRids[i+0], AccountRids[i+1],
                         AccountRids[i+2], AccountRids[i+3],
                         AccountRids[i+4], AccountRids[i+5],
                         AccountRids[i+6], AccountRids[i+7] ));
                }
            }
            for (i=i; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx  ", AccountRids[i]));
            }
            SampDiagPrint(DISPLAY_CACHE, ("\n"));
            LastRid = AccountRids[i];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }





    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Hmmm, can't close handles because it will conflict            //
    // with the rxact state we already have going.  Bummer.          //
    //                                                               //
    ///////////////////////////////////////////////////////////////////

    //NtStatus = SamrCloseHandle( &Domain ); ASSERT(NT_SUCCESS(NtStatus));
    //NtStatus = SamrCloseHandle( &Server ); ASSERT(NT_SUCCESS(NtStatus));

    return;
}

#endif //SAMP_DIAGNOSTICS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dbgutilp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbgutilp.h

Abstract:

    This file contains private debugging routines, macros, etc. for the SAM
    server. All debugging utilities should be added to this file, or to the
    dbgutil.c file.

    See below comments for more information on how to use these routines,
    how to add new routines, and how to add or remove them from the build.

    IF DEBUGGING CODE IS NEEDED THAT IS DEPENDENT ON BUILD TYPE, THEN THIS
    CODE SHOULD STRICTLY RELY ON THE DEFINITION OF THE PROJECT-WIDE NT DE-
    BUGGING MACRO "DBG". THIS IS AUTOMATICALLY DEFINED FOR CHECKED BUILDS,
    AND WILL ENABLE THE SamKdPrint or SampDiagPrint MACROS (via NT KdPrint),
    FOR INSTANCE.

    EXAMPLE USAGE:

    if (DBG == 1)
    {
        CHAR DebugBuffer[64] = "Some Debug Message...";
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: %s\n",
                   DebugBuffer));

        SampDiagPrint(INFORM, ("SAMSS: Another Debug Message...\n));
    }

    or

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAMSS: Some status message\n"));

    or

    SampDiagPrint(INFORM, ("SAMSS: Another Debug Message...\n));

    Note that output verbosity from SampDiagPrint can be set in the debugger
    by setting the value of SampGlobalFlag to the SAMP_DIAG_ flags defined
    below.

    IF A DEBUGGING MESSAGE IS NEEEDED REGARDLESS OF THE BUILD TYPE, THEN USE
    THE SamOutputDebugString MACRO.

    EXAMPLE USAGE:

    SamOutputDebugString("SAMSS: Mandatory Debug Message...\n");

    Note that all SAM server debug output begins with "SAMSS:" or "[SAMSS]"
    so that the SAM server debug output can be distinguished from the other
    components in the system.

Author:

    Chris Mayhall (ChrisMay)  04-Apr-1996

Environment:

    User Mode - Win32

Revision History:

    04-Apr-1996 ChrisMay
        Created.
    02-Dec-1996 ChrisMay
        Clean up, re-organized, removed obsolete routines, documented how
        to use all this stuff, added filtered KdPrint output.
    05-Dec-1996 ChrisMay
        Moved the SAM diagnostic routines from samsrvp.h to this file.
    07-Feb-1997 ChrisMay
        Added RID manager debug flag.

--*/

#ifndef _DBGUTILP_
#define _DBGUTILP_

// SAM server debugging facility consists of the following macros and compile-
// time flags:
//
// -SampDiagPrint: This macro is enabled in checked builds of the system, and
//  relies on the global variable "SampGlobalFlag" to filter the diagnostic
//  output. In non-checked builds, this code is not included in the server.
//  This macro is intended to be used for informational output that would
//  normally be too verbose by default. Be default, SampGlobalFlag is set
//  to zero, disabling any output to the debugger. See the SAMP_DIAG_ flags
//  defined below for enabling output.
//
// -SAMP_TRACE: Per-routine tracing output to the debugger when this flag is
//  set to 1. This displays the SAM server routine name on the debugger when
//  it is called. This can be enabled in checked or free builds of the ser-
//  ver.
//
// -SAMP_DUMP: A set of routines that will dump registry blobs, security
//  descriptors, ACL's, etc. when this flag is set to 1. This can be enabled
//  in checked or free builds of the server.
//
// These flags are compile-time flags, that when set to 1 include the debug
// code in the build, or when set to 0 do not include the code in the build.
//
// By default, SAMP_DUMP is set to 0 to reduce debugger output, particularly
// on a domain controller.
//
// SAMP_TRACE is set to 1 so that the routines are compiled into the code
// (during development), but note that this debug mechanism also refers to
// runtime variables (set via the debugger) to control how much output is
// sent to the debugger (see below). This allows the developer to dynamically
// filter trace output, while the server is running. No trace output will
// be generated by default, the runtime variables must be set first.
//
// The runtime variables that allow the developer to control how much infor-
// mation is sent to the debugger are "SampTraceTag" and "SampTraceFileTag",
// as defined in dbgutil.c. They can be set from a debugger, as documented
// in dbgutil.c.
//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// as mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_SAMSS_Mask and may be set via the registry or the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\SAMSS
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//
// A typical debug output request is:
//
//    KdPrintEx((DPFLTR_SAMSS_ID,
//               DPFLTR_INFO_LEVEL,
//               "SAMSS: Some status message\n"));
//

#define SAMP_TRACE      0
#define SAMP_DUMP       0

// These flags are used by the tracing routines to determine what is traced.
// If SampTraceTags is set to 1, then trace SAM server exported routines. If
// SampTraceTags is set to 2, then trace the routines within a specified src
// code file. if trace is 4 then trace all DS calls and their return values
// if trace is 8 output ticks

#define SAM_TRACE_EXPORTS       0x00000001
#define SAM_TRACE_FILE_BASIS    0x00000002
#define SAM_TRACE_DS            0x00000004
#define SAM_TRACE_TICKS         0x00000008


// The src code file is specified via the SampTraceFileTags variable.  The
// value of this variable is based on the TraceTable (refer to dbgutil.c for
// the entries), or if set to 0xffffffff, will trace all SAM server routines.
// As new src code files are added to the project, the list of files in the
// TraceTable should be updated as well.

#define SAM_TRACE_ALL           0xffffffff

//======================SAM SERVER DIAGNOSTIC ROUTINES========================

// The following define controls the diagnostic capabilities that are built
// into SAM. The SampDiagPrint routine should be used whenever informational
// or verbose output is required. This output is only available in checked
// builds, and is settable from the debugger (set SampGlobalFlag).

#if DBG

#define SAMP_DIAGNOSTICS 1

#endif // DBG


#if (SAMP_DIAGNOSTICS == 1)

// Test for diagnostics enabled.

#define IF_SAMP_GLOBAL( FlagName ) \
    if (SampGlobalFlag & (SAMP_DIAG_##FlagName))

#define IF_NOT_SAMP_GLOBAL( FlagName ) \
    if ( !(SampGlobalFlag & (SAMP_DIAG_##FlagName)) )

// Diagnostics print statement

#define SampDiagPrint( FlagName, _Text_ )\
    IF_SAMP_GLOBAL( FlagName )\
        DbgPrint _Text_

#else

#define IF_SAMP_GLOBAL( FlagName ) if (FALSE)
#define IF_NOT_SAMP_GLOBAL ( FlagName ) if (TRUE)
#define SampDiagPrint( FlagName, Text ) ;

#endif // SAMP_DIAGNOSTICS


// The following flags enable or disable various diagnostic capabilities
// within SAM.  The value of SampGlobalFlag can be set to one or more of
// these flags from the debugger.
//
//      DISPLAY_CACHE - print diagnostic messages related
//          to the display cache (additions, deletions,
//          modifications, etc).
//
//      DISPLAY_LOCKOUT - print diagnostic messages related
//          to account lockout.
//
//      DISPLAY_ROLE_CHANGES - print diagnostic messages related
//          to primary/backup role changes.
//
//      DISPLAY_CACHE_ERRORS - print diagnostic messages related to
//          errors when manipulating the display cache.
//
//      DISPLAY_STORAGE_FAIL - print diagnostic messages related to
//          backing store failures.
//
//      BREAK_ON_STORAGE_FAIL - breakpoint if an attempt to write
//          to backing store fails.
//
//      CONTEXT_TRACKING - print diagnostic messages related to
//          object context usage (creation / deletion, etc.).
//
//      ACTIVATE_DEBUG_PROC - activate a process for use as a diagnostic
//          aid.  This is expected to be used only during SETUP testing.
//
//      DISPLAY_ADMIN_CHANGES - print diagnostic messages related to
//          changing user account protection to allow or dissallow
//          Account Operator access to admin or normal user accounts.
//
//      LOGON - Traces some of the important activiites that pertain
//          to the logon sequence.
//
//      NT5_ACCESS_CHECKS - Traces and prints some information regarding NT5
//          Access checks.
//
//      SD_DUMP - Dumps out the security descriptor during the check.
//
//      SD_CONVERT - Prints diagnostic messages about security coonversions.
//
//      FORCE_FULL_SD_CONVERSION - Is used to disable the standard ACL recognition
//         mecahnism for NT4 to NT5 security descriptor conversions. This can test
//         the enhanced ACL mechanism efficiently
//
//      SAMP_DIAG_BREAK_ON_CHECK -- Forces a Debug Break, Just before we call access
//         check by type result list. Useful in verifying what the function returned
//
//      PROMOTE -- prints out infomation relating to the promotion or
//                 demotion of a SAM server
//
//      RID_TRACE -- Traces information regarding Rid Allocations.
//
//
//      OBJECT_CONFLICT -- Prints information regarding SAM account Name and
//                         Sid Conflicts
//
//      INFORM - Generic informational flag, used to display verbose or
//          frequently occurring status messages that are not tied to a
//          specific sub-system or component. This is not intended to be
//          used for error reporting, rather for informational status.
//

#define SAMP_DIAG_DISPLAY_CACHE             ((ULONG) 0x00000001L)
#define SAMP_DIAG_DISPLAY_LOCKOUT           ((ULONG) 0x00000002L)
#define SAMP_DIAG_DISPLAY_ROLE_CHANGES      ((ULONG) 0x00000004L)
#define SAMP_DIAG_DISPLAY_CACHE_ERRORS      ((ULONG) 0x00000008L)
#define SAMP_DIAG_DISPLAY_STORAGE_FAIL      ((ULONG) 0x00000010L)
#define SAMP_DIAG_BREAK_ON_STORAGE_FAIL     ((ULONG) 0x00000020L)
#define SAMP_DIAG_CONTEXT_TRACKING          ((ULONG) 0x00000040L)
#define SAMP_DIAG_ACTIVATE_DEBUG_PROC       ((ULONG) 0x00000080L)
#define SAMP_DIAG_DISPLAY_ADMIN_CHANGES     ((ULONG) 0x00000100L)
#define SAMP_DIAG_LOGON                     ((ULONG) 0x00000200L)
#define SAMP_DIAG_NT5_ACCESS_CHECKS         ((ULONG) 0x00000400L)
#define SAMP_DIAG_SD_DUMP                   ((ULONG) 0x00000800L)
#define SAMP_DIAG_SD_CONVERSION             ((ULONG) 0x00001000L)
#define SAMP_DIAG_RID_MANAGER               ((ULONG) 0x00002000L)
#define SAMP_DIAG_FORCE_FULL_SD_CONVERSION  ((ULONG) 0x00004000L)
#define SAMP_DIAG_BREAK_ON_CHECK            ((ULONG) 0x00008000L)
#define SAMP_DIAG_PROMOTE                   ((ULONG) 0x00010000L)
#define SAMP_DIAG_RID_TRACE                 ((ULONG) 0x00020000L)
#define SAMP_DIAG_OBJECT_CONFLICT           ((ULONG) 0x00040000L)

#define SAMP_DIAG_INFORM                    ((ULONG) 0x80000000L)


// Choose a print type appropriate to how we are building.

#ifdef SAMP_BUILD_CONSOLE_PROGRAM

#define BldPrint printf

#else

#define BldPrint DbgPrint

#endif // SAMP_BUILD_CONSOLE_PROGRAM


#if (SAMP_DIAGNOSTICS == 1)

extern ULONG SampGlobalFlag;

#endif // SAMP_DIAGNOSTICS


// Define this symbol to get context tracking messages printed (otherwise,
// comment it out).

//#define SAMP_DBG_CONTEXT_TRACKING

#ifdef SAMP_DBG_CONTEXT_TRACKING

VOID
SampDumpContexts(
    VOID
    );

#endif

//======================SAM SERVER TRACING ROUTINES===========================

#if (SAMP_TRACE == 1)

#define SAMTRACE(a)                    SamIDebugOutput(__FILE__,a,SAM_TRACE_FILE_BASIS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, SAM_TRACE_FILE_BASIS);

#define SAMTRACE_EX(a)                 SamIDebugOutput(__FILE__,a,(SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS));\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, (SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS));

#define SAMTRACE_DS(a)                 SamIDebugOutput(__FILE__,a,SAM_TRACE_DS);\
                                            SamIDebugFileLineOutput(__FILE__,__LINE__,(SAM_TRACE_DS));

#define SAMTRACE_RETURN_CODE(rc)       SamIDebugOutputReturnCode(__FILE__,rc,SAM_TRACE_FILE_BASIS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__|SAM_TRACE_FILE_BASIS);

#define SAMTRACE_RETURN_CODE_EX(rc)    SamIDebugOutputReturnCode(__FILE__,rc,SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, (SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS));

#define SAMTRACE_RETURN_CODE_DS(rc)    SamIDebugOutputReturnCode(__FILE__,rc,SAM_TRACE_DS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, (SAM_TRACE_DS));

#else

#define SAMTRACE(a)
#define SAMTRACE_EX(a)
#define SAMTRACE_RETURN_CODE(rc)
#define SAMTRACE_RETURN_CODE_EX(rc)
#define SAMTRACE_DS(a)
#define SAMTRACE_RETURN_CODE_DS(rc)

#endif

// Define the Trace Table structure for tracing on a file by file basis.

typedef struct {
    LPSTR FileName;
    ULONGLONG TraceBit;
} TRACE_TABLE_ENTRY;

//======================SAM SERVER DUMPING ROUTINES===========================

#if (SAMP_DUMP == 1)

#define SampDumpNtSetValueKey(a, b, c, d, e)        SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtSetValueKey(a, b, c, d, e)
#define SampDumpRtlpNtSetValueKey(a, b, c)          SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRtlpNtSetValueKey(a, b, c)
#define SampDumpNtEnumerateKey(a, b, c, d, e)       SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtEnumerateKey(a, b, c, d, e)
#define SampDumpRtlpNtEnumerateSubKey(a, b, c)      SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRtlpNtEnumerateSubKey(a, b, c)
#define SampDumpNtOpenKey(a, b, c)                  SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtOpenKey(a, b, c);
#define SampDumpNtQueryKey(a, b, c, d)              SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtQueryKey(a, b, c, d)
#define SampDumpNtQueryValueKey(a, b, c, d, e)      SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtQueryValueKey(a, b, c, d, e)
#define SampDumpRtlpNtQueryValueKey(a, b, c, d)     SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRtlpNtQueryValueKey(a, b, c, d)
#define SampDumpRXact(a, b, c, d, e, f, g, h, i)    SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRXact(a, b, c, d, e, f, g, h, i)

#else

#define SampDumpNtSetValueKey(a, b, c, d, e)
#define SampDumpRtlpNtSetValueKey(a, b, c)
#define SampDumpNtEnumerateKey(a, b, c, d, e)
#define SampDumpRtlpNtEnumerateSubKey(a, b, c)
#define SampDumpNtOpenKey(a, b, c)
#define SampDumpNtQueryKey(a, b, c, d)
#define SampDumpNtQueryValueKey(a, b, c, d, e)
#define SampDumpRtlpNtQueryValueKey(a, b, c, d)
#define SampDumpRXact(a, b, c, d, e, f, g, h, i)

#endif

// These debugging flags are used in the dumping routines to help identify
// what kind of SAM object is being dumped.

#define FIXED_LENGTH_SERVER_FLAG                 0
#define FIXED_LENGTH_DOMAIN_FLAG                 1
#define FIXED_LENGTH_ALIAS_FLAG                  2
#define FIXED_LENGTH_GROUP_FLAG                  3
#define FIXED_LENGTH_USER_FLAG                   4
#define VARIABLE_LENGTH_ATTRIBUTE_FLAG           5
#define FixedBufferAddressFlag                   6

//===============SAM SERVER PRIVATE DEBUG ROUTINE DECLARATIONS================

VOID
SamIDebugOutput(
    IN LPSTR FileName,
    IN LPSTR DebugMessage,
    IN ULONG TraceLevel
    );

VOID
SamIDebugFileLineOutput(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN ULONG TraceLevel
    );

VOID
SamIDebugOutputReturnCode(
    IN  LPSTR   FileName,
    IN  ULONG   ReturnCode,
    IN  ULONG   TraceLevel
    );

VOID
SamIDumpNtSetValueKey(
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

VOID
SamIDumpRtlpNtSetValueKey(
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

VOID
SamIDumpNtEnumerateKey(
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

VOID
SamIDumpRtlpNtEnumerateSubKey(
    IN PUNICODE_STRING SubKeyName,
    IN PSAM_ENUMERATE_HANDLE Index,
    IN LARGE_INTEGER LastWriteTime
    );

VOID
SamIDumpNtOpenKey(
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Options
    );

VOID
SamIDumpNtQueryKey(
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

VOID
SamIDumpNtQueryValueKey(
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

VOID
SamIDumpRtlpNtQueryValueKey(
    IN PULONG KeyValueType,
    IN PVOID KeyValue,
    IN PULONG KeyValueLength,
    IN PLARGE_INTEGER LastWriteTime
    );

VOID
SamIDumpRXact(
    IN PRTL_RXACT_CONTEXT TransactionContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG RegistryKeyType,
    IN PVOID NewValue,
    IN ULONG NewValueLength,
    IN ULONG NewValueType
    );
VOID
SampDumpBinaryData(
    PBYTE   pData,
    DWORD   cbData
    );

#endif  //_DBGUTILP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsdomain.h ===
typedef struct _SAMP_DOMAIN_INFO
{
    // BUG: work in progress - what else should be stored here?

    UNICODE_STRING DomainName;                  // Domain display name
    PDSNAME DomainDsName;                       // Domain DS name
} SAMP_DOMAIN_INFO, *PSAMP_DOMAIN_INFO;

typedef struct _SAMP_DOMAIN_INIT_INFO
{
    ULONG DomainCount;                          // Count of returned domains
    PSAMP_DOMAIN_INFO DomainInfo;               // Array of domain information
} SAMP_DOMAIN_INIT_INFO, *PSAMP_DOMAIN_INIT_INFO;

NTSTATUS
SampExtendDefinedDomains(
    ULONG DomainCount
    );

NTSTATUS
SampDsInitializeDomainObject(
    PSAMP_DOMAIN_INFO DomainInfo,
    ULONG Index,
	BOOLEAN MixedDomain,
    ULONG   BehaviorVersion,
    DOMAIN_SERVER_ROLE ServerRole, 
    ULONG   LastLogonTimeStampSyncInterval
    );

NTSTATUS
SampDsInitializeDomainObjects(
    VOID
    );

NTSTATUS
SampDsGetDomainInitInfo(
    PSAMP_DOMAIN_INIT_INFO DomainInitInfo
    );

NTSTATUS
SamrCreateDomain(
    IN PWCHAR DomainName,
    IN ULONG DomainNameLength,
    IN BOOLEAN WriteLockHeld,
    OUT SAMPR_HANDLE *DomainHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsbackup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsbackup.c

Abstract:

    This file contains the thread fn to host the DS backup/restore
    interface.


Author:

    R.S. Raghavan    (rsraghav)  04/21/97

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dslayer.h>
#include <ntdsbsrv.h>

#define RPC_SERVICE "rpcss"

ULONG
SampDSBackupRestoreInit(
    PVOID Ignored
    )
/*++

Routine Description:

    This routine waits for the RPCS service to start and then registers
    DS backup and restore RPC interfaces.

Arguments:

    Ignored - required parameter for starting a thread.

Return Value:

    None.

--*/
{

    HMODULE hModule;
    DWORD dwErr;

    FARPROC BackupRegister = NULL;
    FARPROC BackupUnregister = NULL;
    FARPROC RestoreRegister = NULL;
    FARPROC RestoreUnregister = NULL;
    FARPROC SetNTDSOnlineStatus = NULL;

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAM:DSBACKUP: Entered SampDSBackupRestoreInit() thread function\n"));

    if (!DsaWaitUntilServiceIsRunning(RPC_SERVICE))
    {
        dwErr = GetLastError();
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM:DSBACKUP: DsaWaitUntilServerIsRunning(RPC_SERVICE) returned FALSE\n"));

        return dwErr;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAM: DSBACKUP: RPCS service is running\n"));

    if (!(hModule = (HMODULE) LoadLibrary(NTDSBACKUPDLL)))
    {
        dwErr = GetLastError();
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM:DSBACKUP: LoadLibrary() of %s failed with error code %u\n",
                   NTDSBACKUPDLL,
                   dwErr));

        return dwErr;
    }


    BackupRegister = GetProcAddress(hModule, BACKUP_REGISTER_FN);
    BackupUnregister = GetProcAddress(hModule, BACKUP_UNREGISTER_FN);
    RestoreRegister = GetProcAddress(hModule, RESTORE_REGISTER_FN);
    RestoreUnregister = GetProcAddress(hModule, RESTORE_UNREGISTER_FN);
    SetNTDSOnlineStatus = GetProcAddress(hModule, SET_NTDS_ONLINE_STATUS_FN);

    if (!BackupRegister         ||
        !BackupUnregister       ||
        !RestoreRegister        ||
        !RestoreUnregister      ||
        !SetNTDSOnlineStatus)
    {
        dwErr = GetLastError();
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM:DSBACKUP: GetProcAddress() failed with error code %u\n",
                   dwErr));

        return dwErr;
    }

    // set online status to distinguish between registry booting and DS booting
    SetNTDSOnlineStatus((BOOL) SampUsingDsData());

    // Register the backup and restore interfaces
    BackupRegister();
    RestoreRegister();

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAM: DSBACKUP: DS Backup and restore interface registration successful!\n"));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsmember.h ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsmember.h

Abstract:

    Header File for SAM private API Routines that manipulate
    membership related things in the DS.

Author:
    MURLIS

Revision History

    7-2-96 Murlis Created

--*/

VOID
SampInvalidateGroupCacheElement(
    IN ULONG Rid
    );

VOID
SampDsFreeCachedMembershipOperationsList(
    IN PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY *MembershipOperationsList,
    IN ULONG *MaxLength,
    IN ULONG *Count
    );


NTSTATUS                        
SampDsFlushCachedMembershipOperationsList(
    IN DSNAME *Object,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG  MembershipAttrType,
    IN OUT PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY *MembershipOperationsList,
    IN OUT ULONG *MaxLength,
    IN OUT ULONG *Count
    );


NTSTATUS
SampDsAddMembershipOperationToCache(
    IN PSAMP_OBJECT Context, 
    IN ULONG        Attribute,
    IN ULONG        OperationType,
    IN DSNAME       * MemberDsName
    );


NTSTATUS
SampDsGetAliasMembershipOfAccount(
    IN DSNAME*   DomainDn,
    IN DSNAME   *AccountDn,
    OUT PULONG MemberCount OPTIONAL,
    IN OUT PULONG BufferSize OPTIONAL,
    OUT PULONG Buffer OPTIONAL
    );

NTSTATUS
SampDsGetGroupMembershipOfAccount(
    IN DSNAME * DomainDn,
    IN DSNAME * AccountObject,
    OUT  PULONG MemberCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    );


NTSTATUS
SampDsAddMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN ULONG    Flags,
    IN ULONG    Attribute,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    );

NTSTATUS
SampDsAddMultipleMembershipAttribute(
    IN DSNAME*          GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DWORD            Flags,
    IN DWORD            MemberCount,
    IN DSNAME*          MemberName[]
    );

NTSTATUS
SampDsRemoveMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN ULONG    Attribute,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    );

NTSTATUS
SampDsGetGroupMembershipList(
    IN DSNAME * DomainObject,
    IN DSNAME * GroupName,
    IN ULONG  GroupRid,
    IN PULONG *Members OPTIONAL,
    IN PULONG MemberCount
    );

NTSTATUS
SampDsGetAliasMembershipList(
    IN DSNAME *AliasName,
    IN ULONG  AliasRid,
    IN PULONG MemberCount,
    IN PSID   **Members OPTIONAL
    );


NTSTATUS
SampDsGetReverseMemberships(
   DSNAME * pObjName,
   ULONG    Flags,
   ULONG    *pcSid,
   PSID     **prpSids
   );

NTSTATUS
SampDsGetPrimaryGroupMembers(
    DSNAME * DomainObject,
    ULONG   GroupRid,
    PULONG  PrimaryMemberCount,
    PULONG  *PrimaryMembers
    );


NTSTATUS
SampDsResolveSidsWorker(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgEnterpriseSids,
    IN  ULONG   cEnterpriseSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    );

NTSTATUS
SampDsResolveSidsForDsUpgrade(
    IN  PSID    DomainSid,
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    );


//
// Flags for Resolve Sids
//

#define RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL 0x1 
                  // -- Automatically Adds the foreign 
                  //    domain security principal to the DS.

#define RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS            0x2
                  // -- Fails the call if well known Sids 
                  //    are present in the array
        
#define RESOLVE_SIDS_VALIDATE_AGAINST_GC            0x4 
                  // -- Goes to the G.C if required

#define RESOLVE_SIDS_SID_ONLY_NAMES_OK              0x8
                 // Constructs a Sid Only Name, 
                 // Useful where it is appropriate to use SID based positioning
                 // in the DS. 

#define RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK       0x10
                 // Constructs a Sid only name, if the SID is from the hosted
                 // domain. This is used by upgrader logic to speed up SID
                 // lookups upon a upgrade. 

#define RESOLVE_SIDS_FAIL_BUILTIN_DOMAIN_SIDS      0x20
                 // Fails call if SIDs like "Administrators" are present
                 // in the array


NTSTATUS
SampDsGetSensitiveSidList(
    IN DSNAME *DomainObjectName,
    IN PULONG pcSensSids,
    IN PSID   **pSensSids
    );

NTSTATUS
SampDsExamineSid(
    IN PSID Sid,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    );


VOID
SampAcquireGroupLock();

VOID
SampReleaseGroupLock();

VOID
SampInvalidateGroupCacheElement(
    IN ULONG Rid
    );

NTSTATUS
SampInitializeGroupCache();

VOID
SampInvalidateGroupCache();

VOID
SampInvalidateGroupCacheByMemberRid(IN ULONG Rid);

VOID
SampProcessChangesToGroupCache(
    IN ULONG ChangedObjectRid,
    IN SAMP_OBJECT_TYPE ChangedObjectType,
    IN BOOL UserAccountControlChange,
    IN ULONG   UserAccountControl,
    IN SECURITY_DB_DELTA_TYPE DeltaType
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dslayer.h ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dslayer.h

Abstract:

    Header file for SAM Private API Routines to access the DS
    These API provide a simplified API, and hide most of the
    underlying complexity to set up the parameters to a DS call
    and parse the resulting result. They also provide an abstraction
    by which we can create a simple layer, to unit test SAM without
    actually running the DS.

Author:
    MURLIS

Revision History

    5-14-96 Murlis Created
    11-Jul-1996 ChrisMay
        Added DEFINE_ATTRBLOCK5, 6.

--*/

#ifndef __DSLAYER_H__
#define __DSLAYER_H__

#include <samsrvp.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <dsatools.h>
#include <dsutil.h>
#include <wxlpc.h>

// Size Limit for DS operations
#define SAMP_DS_SIZE_LIMIT 100000


//
// Some defines for Error codes returned by Ds Layer calls.
//



///////////////////////////////////////////////////////////////////
//                                                               //
// Macros for defining Local arrays of Attributes                //
//                                                               //
///////////////////////////////////////////////////////////////////

//Need some preprocessor support to do this a variable number of times


//*****     ATTRBLOCK1
#define DEFINE_ATTRBLOCK1(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}


//*****     ATTRBLOCK2
#define DEFINE_ATTRBLOCK2(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}


//*****    ATTRBLOCK3
#define DEFINE_ATTRBLOCK3(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}


//*****    ATTRBLOCK4
#define DEFINE_ATTRBLOCK4(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

//*****    ATTRBLOCK5
#define DEFINE_ATTRBLOCK5(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}},\
    {_AttrTypes_[4], {1,&_AttrValues_[4]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

//*****    ATTRBLOCK6
#define DEFINE_ATTRBLOCK6(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}},\
    {_AttrTypes_[4], {1,&_AttrValues_[4]}},\
    {_AttrTypes_[5], {1,&_AttrValues_[5]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

//*****    ATTRBLOCK7
#define DEFINE_ATTRBLOCK7(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}},\
    {_AttrTypes_[4], {1,&_AttrValues_[4]}},\
    {_AttrTypes_[5], {1,&_AttrValues_[5]}},\
    {_AttrTypes_[6], {1,&_AttrValues_[6]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// private structure used by Duplicate SAM Account Name Routine            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


//
// used to pass the dupliate objects DSNAME to the asynchronous routine to rename
// those duplicate accounts.
// 

typedef struct _SAMP_RENAME_DUP_ACCOUNT_PARM   {
    ULONG           Count;
    PDSNAME         * DuplicateAccountDsNames; 
} SAMP_RENAME_DUP_ACCOUNT_PARM, *PSAMP_RENAME_DUP_ACCOUNT_PARM;




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// DS DLL initialize exports. This is here only temporarily. Should remove //
// this and create a header file that has all the exports together         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////



WX_AUTH_TYPE
DsGetBootOptions(VOID);

NTSTATUS
DsChangeBootOptions(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    );


///////////////////////////////////////////////////////////////////////
//                                                                   //
// DS Operation Routines and macros implemented in dslayer.c         //
//                                                                   //
///////////////////////////////////////////////////////////////////////


//
// Flag Values for All DS Layer Calls.
// The Flags use the Upper 16 bits of the DWORD. The lower 16 bit half is
// used by the mapping flags.
//

#define SAM_MAKE_DEL_AVAILABLE                  0x010000
#define SAM_UNICODE_STRING_MANUAL_COMPARISON    0x020000
#define SAM_LAZY_COMMIT                         0x040000
#define SAM_RESET_DSA_FLAG                      0x080000
#define SAM_NO_LOOPBACK_NAME                    0x100000
#define SAM_URGENT_REPLICATION                  0x200000
#define SAM_USE_OU_FOR_CN                       0x400000
#define SAM_ALLOW_REORDER                       0x800000
#define SAM_DELETE_TREE                        0x1000000
#define SAM_UPGRADE_FROM_REGISTRY              0x2000000
#define SAM_ALLOW_INTRAFOREST_FPO              0x4000000

NTSTATUS
SampDsInitialize(
    BOOL fSamLoopback);

NTSTATUS
SampDsUninitialize();

NTSTATUS
SampDsRead(
            IN DSNAME * Object,
            IN ULONG    Flags,
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK * AttributesToRead,
            OUT ATTRBLOCK * AttributeValues
          );


//
// Operatin Values for Set Attributes
//

#define REPLACE_ATT ((ULONG) 0)
#define ADD_ATT     ((ULONG) 1)
#define REMOVE_ATT  ((ULONG) 2)
#define ADD_VALUE   ((ULONG) 3)
#define REMOVE_VALUE ((ULONG) 4)



NTSTATUS
SampDsSetAttributes(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  Operation,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
    );

NTSTATUS
SampDsSetAttributesEx(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  *Operation,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
    );

NTSTATUS
SampDsCreateObjectActual(
    IN   DSNAME         *Object,
    IN   ULONG          Flags,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    );



NTSTATUS
SampDsCreateObject(
    IN DSNAME * Object,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributesToSet,
    IN PSID DomainSid
    );

NTSTATUS
SampDsCreateInitialAccountObject(
    IN   PSAMP_OBJECT    Object,
    IN   ULONG           Flags,
    IN   ULONG           AccountRid,
    IN   PUNICODE_STRING AccountName,
    IN   PSID            CreatorSid OPTIONAL,
    IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN   PULONG          UserAccountControl OPTIONAL,
    IN   PULONG          GroupType
    );


NTSTATUS
SampDsCreateBuiltinDomainObject(
    IN   DSNAME         *Object,
    IN   ATTRBLOCK      *AttributesToSet
    );

NTSTATUS
SampDsDeleteObject(
            IN DSNAME * Object,
            IN ULONG    Flags
            );

NTSTATUS
SampDsChangeAccountRDN(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName
    );

///////////////////////////////////////////////////////////////////
//                                                               //
//                                                               //
//    DS Search Routines                                         //
//                                                               //
//                                                               //
//                                                               //
///////////////////////////////////////////////////////////////////


#define SampDsDoSearch(r, dom, df, delta, otype, attr, max, search) \
        SampDsDoSearch2(0, r, dom, df, delta, otype, attr, max, 0, search) 


NTSTATUS
SampDsDoSearch2(
                ULONG    Flags,
                RESTART *Restart,
                DSNAME  *DomainObject,
                FILTER  *DsFilter,
                int      Delta,
                SAMP_OBJECT_TYPE ObjectTypeForConversion,
                ATTRBLOCK * AttrsToRead,
                ULONG   MaxMemoryToUse,
                ULONG   TimeLimit,
                SEARCHRES **SearchRes
                );



NTSTATUS
SampDsDoUniqueSearch(
             ULONG  Flags,
             IN DSNAME * ContainerObject,
             IN ATTR * AttributeToMatch,
             OUT DSNAME **Object
             );


NTSTATUS
SampDsLookupObjectByName(
            IN DSNAME * DomainObject,
            IN SAMP_OBJECT_TYPE ObjectType,
            IN PUNICODE_STRING ObjectName,
            OUT DSNAME ** Object
            );

NTSTATUS
SampDsLookupObjectByRid(
            IN DSNAME * DomainObject,
            ULONG ObjectRid,
            DSNAME **Object
            );

////////////////////////////////////////////////////////////////////
//                                                                //
//                                                                //
//     Object To Sid Mappings                                     //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

NTSTATUS
SampDsObjectFromSid(
    IN PSID Sid,
    OUT DSNAME ** DsName
    );

PSID
SampDsGetObjectSid(
    IN  DSNAME * Object
    );



/////////////////////////////////////////////////////////////////////
//                                                                 //
//   Some Utility Routines in Dslayer.c                            //
//                                                                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////

#define SampDsCreateDsName(d,a,n) SampDsCreateDsName2(d,a,0,n)

NTSTATUS
SampDsCreateDsName2(
            IN DSNAME * DomainObject,
            IN PUNICODE_STRING AccountName,
            IN ULONG           Flags,
            IN OUT DSNAME ** NewObject
            );


VOID
SampInitializeDsName(
            DSNAME * pDsName,
            WCHAR * NamePrefix,
            ULONG   NamePrefixLen,
            WCHAR * ObjectName,
            ULONG NameLen
            );



NTSTATUS
SampDsCreateAccountObjectDsName(
    IN  DSNAME *DomainObject,
    IN  PSID    DomainSid OPTIONAL,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  PUNICODE_STRING AccountName,
    IN  PULONG  AccountRid OPTIONAL,
    IN  PULONG  UserAccountControl OPTIONAL,
    IN  BOOLEAN BuiltinDomain,
    OUT DSNAME **AccountObject
    );

NTSTATUS
SampDsBuildRootObjectName(
    VOID
    );
    
NTSTATUS
SampDsGetWellKnownContainerDsName(
    IN  DSNAME  *DomainObject,
    IN  GUID    *WellKnownGuid,
    OUT DSNAME  **ContainerObject
    );

NTSTATUS
SampInitWellKnownContainersDsName(
    IN DSNAME *DomainObject 
    );    

NTSTATUS
SampInitWellKnownContainersDsNameAsync(
    IN DSNAME *DomainObject
    );

NTSTATUS
SampCopyRestart(
    IN  PRESTART OldRestart,
    OUT PRESTART *NewRestart
    );

NTSTATUS
SampDsReadSingleAttribute(
    IN PDSNAME pObjectDsName,
    IN ATTRTYP AttrTyp,
    OUT PVOID *ppValue,
    OUT ULONG *Size
    );


// Miscellaneous routines accessed from other SAM source files.

PVOID
DSAlloc(
    IN ULONG Length
    );

NTSTATUS
SampMapDsErrorToNTStatus(
    ULONG RetValue,
    COMMRES *ComRes
    );


void
BuildStdCommArg(
    IN OUT COMMARG * pCommArg
    );

VOID
BuildDsNameFromSid(
    PSID Sid,
    DSNAME * DsName
    );

NTSTATUS
SampDoImplicitTransactionStart(
    SAMP_DS_TRANSACTION_CONTROL LocalTransactionType
    );


/////////////////////////////////////////////////////////////////////
//                                                                 //
//  ATTRBLOCK conversion routines. These Routines convert back     //
//  and forth between SAM and DS ATTRBLOCKS. The type of conversion//
//  depends upon the Flags Conversion Flags that are passed in.    //
//                                                                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////


//
// Conversion Flag Definitions  for SampSamToDsAttrBlock. These
// Flags always occupy the lower 16 bits of the DWORD. The upper
// 16 bit of the DWORD is reserved for generic dslayer flags.
//

#define ALREADY_MAPPED_ATTRIBUTE_TYPES    ((ULONG)0x1)
#define REALLOC_IN_DSMEMORY               ((ULONG)0x2)
#define ADD_OBJECT_CLASS_ATTRIBUTE        ((ULONG)0x4)
#define MAP_RID_TO_SID                    ((ULONG)0x8)
#define DOMAIN_TYPE_DOMAIN                ((ULONG)0x10)
#define DOMAIN_TYPE_BUILTIN               ((ULONG)0x20)
#define IGNORE_GROUP_UNUSED_ATTR          ((ULONG)0x40)
#define ADVANCED_VIEW_ONLY                ((ULONG)0x80)
#define FORCE_NO_ADVANCED_VIEW_ONLY       ((ULONG)0x100)

//
// Function Declaration
//

NTSTATUS
SampSamToDsAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK  *AttrBlockToConvert,
            IN ULONG      ConversionFlags,
            IN PSID       DomainSid,
            OUT ATTRBLOCK * ConvertedAttrBlock
            );

//
// Conversion Flag Definitions For SampDsToSamAttrBlock
//

// #define MAP_ATTRIBUTE_TYPES        0x1
#define MAP_SID_TO_RID             0x2

NTSTATUS
SampDsToSamAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK * AttrBlockToConvert,
            IN ULONG     ConversionFlags,
            OUT ATTRBLOCK * ConvertedAttrBlock
            );

ATTR *
SampDsGetSingleValuedAttrFromAttrBlock(
    IN ATTRTYP attrTyp,
    IN ATTRBLOCK * AttrBlock
    );


VOID
SampMapSamAttrIdToDsAttrId(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT ATTRBLOCK * AttributeBlock
    );

NTSTATUS
SampAppendCommonName(
    IN PDSNAME DsName,
    IN PWSTR CN,
    OUT PDSNAME *NewDsName
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsrmpwd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsrmpwd.c

Abstract:

    Routines in the file are used to set Directory Service Restore Mode
    Administrator Account Password.

Author:

    Shaohua Yin  (ShaoYin) 08-01-2000

Environment:

    User Mode - Win32

Revision History:

    08-01-2000 ShaoYin Create Init File
--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>
#include <msaudite.h>

NTSTATUS
SampGetClientIpAddr(
    OUT LPSTR *NetworkAddr
);

NTSTATUS
SampEncryptDSRMPassword(
    OUT PUNICODE_STRING EncryptedData,
    IN  USHORT          KeyId,
    IN  SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN  PUNICODE_STRING ClearData,
    IN  ULONG Rid
    );


NTSTATUS
SampValidateDSRMPwdSet(
    VOID
    )
/*++
Routine Description:

    This routine checks whether this client can set DSRM (Directory Service
    Restore Mode) Administrator's password or not by checking whether the
    caller is a member of Builtin Administrators Group or not.

Parameter:

    None.

Return Value:

    STATUS_SUCCESS iff the caller is a member of Builtin Administrators Alias GROUP

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     fImpersonating = FALSE;
    HANDLE      ClientToken = INVALID_HANDLE_VALUE;
    ULONG       RequiredLength = 0, i;
    PTOKEN_GROUPS   Groups = NULL;
    BOOLEAN     ImpersonatingNullSession = FALSE;

    //
    // Impersonate client
    //

    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }
    fImpersonating = TRUE;

    //
    // Get Client Token
    //

    NtStatus = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_QUERY,
                        TRUE,           // OpenAsSelf
                        &ClientToken
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Query ClienToken for User's Groups

    NtStatus = NtQueryInformationToken(
                        ClientToken,
                        TokenGroups,
                        NULL,
                        0,
                        &RequiredLength
                        );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && (RequiredLength > 0))
    {
        //
        // Allocate memory
        //

        Groups = MIDL_user_allocate(RequiredLength);
        if (NULL == Groups)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(Groups, RequiredLength);

        //
        // Query Groups again
        //

        NtStatus = NtQueryInformationToken(
                            ClientToken,
                            TokenGroups,
                            Groups,
                            RequiredLength,
                            &RequiredLength
                            );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Check whether this client is member of Builtin Administrators Group
        //

        ASSERT(NT_SUCCESS(NtStatus));
        NtStatus = STATUS_ACCESS_DENIED;
        for (i = 0; i < Groups->GroupCount; i++)
        {
            PSID    pSid = NULL;

            pSid = Groups->Groups[i].Sid;

            ASSERT(pSid);
            ASSERT(RtlValidSid(pSid));

            // SID matches
            if ( RtlEqualSid(pSid, SampAdministratorsAliasSid) )
            {
                NtStatus = STATUS_SUCCESS;
                break;
            }
        } // for loop

    }


Error:

    if (fImpersonating)
        SampRevertToSelf(ImpersonatingNullSession);

    if (Groups)
        MIDL_user_free(Groups);

    if (INVALID_HANDLE_VALUE != ClientToken)
        NtClose(ClientToken);

    return( NtStatus );
}

VOID
SampAuditSetDSRMPassword(
    IN NTSTATUS AuditStatus
    )
/*++
Routine Description:

    This routine audits a call to SamrSetDSRMPassword.

Parameters:

    AuditStatus - this status will be in the audit, also used to determine if
        the audit must be done

Return Values:

    NTSTATUS Code

--*/
{
    if( SampDoSuccessOrFailureAccountAuditing( SampDsGetPrimaryDomainStart(), AuditStatus ) ) {

        UNICODE_STRING WorkstationName;
        PSTR NetAddr = NULL;

        RtlInitUnicodeString( &WorkstationName, NULL );

        //
        // Extract workstation name
        //

        if( NT_SUCCESS( SampGetClientIpAddr( &NetAddr ) ) ) {

            RtlCreateUnicodeStringFromAsciiz( &WorkstationName, NetAddr );
            RpcStringFreeA( &NetAddr );
        }


        ( VOID ) LsaIAuditSamEvent(
                AuditStatus,
                SE_AUDITID_DSRM_PASSWORD_SET,
                NULL,   // No information is passed explicitly
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                &WorkstationName
                );

        RtlFreeUnicodeString( &WorkstationName );
    }
}

NTSTATUS
SamrSetDSRMPassword(
    IN handle_t BindingHandle,
    IN PRPC_UNICODE_STRING ServerName,
    IN ULONG UserId,
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++
Routine Description:

    This routine sets Directory Service Restore Mode Administrator Account
    Password.

Parameters:

    BindingHandle   - RPC binding handle

    ServerName - Name of the machine this SAM resides on. Ignored by this
        routine, may be UNICODE or OEM string depending on Unicode parameter.

    UserId - Relative ID of the account, only Administrator ID is valid so far.

    EncryptedNtOwfPassword - Encrypted NT OWF Password

Return Values:

    NTSTATUS Code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS,
                    IgnoreStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    UserContext = NULL;
    ULONG           DomainIndex = SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX;
    UNICODE_STRING  StoredBuffer, StringBuffer;
    NTSTATUS        AuditStatus;
    BOOLEAN         TransactionStarted = FALSE;
    BOOLEAN         WriteLockAcquired = FALSE;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    SAMTRACE("SamrSetDSRMPassword");

    RtlInitUnicodeString( &StoredBuffer, NULL );

    //
    // This RPC only supported in DS Mode
    //
    if( !SampUseDsData )
    {
        NtStatus = STATUS_NOT_SUPPORTED;
        goto Error;
    }

    //
    // Only Administrator's password can be reset
    //
    if( DOMAIN_USER_RID_ADMIN != UserId )
    {
        NtStatus = STATUS_NOT_SUPPORTED;
        goto Error;
    }

    if( EncryptedNtOwfPassword == NULL )
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Drop calls over invalid / uninstalled protocol sequences
    //

    NtStatus = SampValidateRpcProtSeq( ( RPC_BINDING_HANDLE ) BindingHandle );

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }


    //
    // check client permission
    //
    NtStatus = SampValidateDSRMPwdSet();

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }


    //
    // Encrypt NtOwfPassword with password encryption Key
    //
    StringBuffer.Buffer = (PWCHAR)EncryptedNtOwfPassword;
    StringBuffer.Length = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
    StringBuffer.MaximumLength = StringBuffer.Length;

    NtStatus = SampEncryptDSRMPassword(
                        &StoredBuffer,
                        SAMP_DEFAULT_SESSION_KEY_ID,
                        NtPassword,
                        &StringBuffer,
                        UserId
                        );

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }

    //
    // Acquire SAM Write Lock in order to access SAM backing store
    //

    NtStatus = SampAcquireWriteLock();

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }

    WriteLockAcquired = TRUE;

    //
    // Begin a Registry transaction by, ( acquire lock will not
    // do so because we are in DS mode ). We will use this registry
    // transaction to update the restore mode account password
    // information in the safe boot hive
    //

    IgnoreStatus = RtlStartRXact( SampRXactContext );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    TransactionStarted = TRUE;

    SampSetTransactionWithinDomain(FALSE);
    SampSetTransactionDomain(DomainIndex);

    //
    // Create a Context for the User Account
    //
    UserContext = SampCreateContextEx(SampUserObjectType,
                                      TRUE,     // TrustedClient
                                      FALSE,    // DsMode
                                      TRUE,     // ThreadSafe
                                      FALSE,    // LoopbackClient
                                      TRUE,     // LazyCommit
                                      TRUE,     // PersistAcrossCalss
                                      FALSE,    // BufferWrite
                                      FALSE,    // Opened By DcPromo
                                      DomainIndex
                                      );

    if( NULL == UserContext )
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Turn the object flag to Registry Account, so that SAM will switch to
    // registry routines to get/set attributes
    //
    SetRegistryObject(UserContext);
    UserContext->ObjectNameInDs = NULL;
    UserContext->DomainIndex = DomainIndex;
    UserContext->GrantedAccess = USER_ALL_ACCESS;
    UserContext->TypeBody.User.Rid = UserId;

    NtStatus = SampBuildAccountSubKeyName(
                   SampUserObjectType,
                   &UserContext->RootName,
                   UserId,
                   NULL             // Don't give a sub-key name
                   );

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }



    //
    // If the account should exist, try and open the root key
    // to the object - fail if it doesn't exist.
    //
    InitializeObjectAttributes(
            &ObjectAttributes,
            &UserContext->RootName,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(&UserContext->RootKey,
                             (KEY_READ | KEY_WRITE),
                             &ObjectAttributes,
                             0
                             );

    if( !NT_SUCCESS( NtStatus ) )
    {
        UserContext->RootKey = INVALID_HANDLE_VALUE;
        NtStatus = STATUS_NO_SUCH_USER;
        goto Error;
    }

    NtStatus = SampSetUnicodeStringAttribute(UserContext,
                                             SAMP_USER_UNICODE_PWD,
                                             &StoredBuffer
                                             );

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }

    //
    // Update the change to registry backing store
    //
    NtStatus = SampStoreObjectAttributes(UserContext,
                                         TRUE
                                         );

    if( !NT_SUCCESS( NtStatus ) )
    {
        goto Error;
    }

Exit:

    //
    // Save NtStatus before applying/aborting transaction
    //
    AuditStatus = NtStatus;

    //
    // Commit or Abort the registry transaction by hand
    //
    if( TransactionStarted )
    {
        if( NT_SUCCESS( NtStatus ) )
        {
            NtStatus = RtlApplyRXact(SampRXactContext);
        }
        else
        {
            NtStatus = RtlAbortRXact(SampRXactContext);
        }
    }

    //
    // If AuditStatus has an unsuccessful value then the operation was
    //  unsucessful, therefore audit so. If not, then we need to get the
    //  return code of transaction apply call.
    //

    if( NT_SUCCESS( AuditStatus ) && !NT_SUCCESS( NtStatus ) )
    {
        AuditStatus = NtStatus;
    }

    SampAuditSetDSRMPassword( AuditStatus );

    if( NULL != UserContext )
    {
        SampDeleteContext( UserContext );
    }

    //
    // Release Write Lock
    //
    if( WriteLockAcquired )
    {
        IgnoreStatus = SampReleaseWriteLock(FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if (NULL != StoredBuffer.Buffer)
    {
        RtlZeroMemory(StoredBuffer.Buffer, StoredBuffer.Length);
        MIDL_user_free(StoredBuffer.Buffer);
    }

    return( NtStatus );

Error:

    ASSERT( !NT_SUCCESS( NtStatus ) );
    goto Exit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsutilp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsutilp.h

Abstract:

    This file contains definitions private to the SAM server program.

Author:

    Chris Mayhall (ChrisMay) 09-May-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    09-May-1996
        Created initial file.

--*/

#ifndef _DSUTILP_H_
#define _DSUTILP_H_

// Include DSA header files to resolve READARG, READRES, etc.

#include <ntdsa.h>      // public DS data types 

// Wrap the DS typedefs with private typedefs to insulate the SAM code from
// onging changes to the DS structure names.

typedef READRES         DSDATA, *PDSDATA;
typedef ATTR            DSATTR, *PDSATTR;
typedef ATTRVAL         DSATTRVAL, *PDSATTRVAL;
typedef ATTRBLOCK       DSATTRBLOCK, *PDSATTRBLOCK;
typedef ATTRVALBLOCK    DSATTRVALBLOCK, *PDSATTRVALBLOCK;
typedef ATTRMODLIST     DSATTRMODLIST, *PDSATTRMODLIST;

//
// The following type is used to identify which grouping of attribute
// (fixed or variable-length) are being refered to in a number of api.
//

#define SAMP_FIXED_ATTRIBUTES       (0L)
#define SAMP_VARIABLE_ATTRIBUTES    (1L)

// BUG: Defining BOGUS_TYPE. This type is used to indicate a missing or
// erroneous data type in the various AttributeMappingTables, found in
// mappings.c.

#define BOGUS_TYPE      0

// SAM does not explicity store type or length information for its fixed-
// length attributes, but the DS storage routines require this information.
// This structure is intended to store any "patch" information needed for
// the DS backing store, as regards fixed attributes.

typedef struct _SAMP_FIXED_ATTRIBUTE_TYPE_INFO
{
    // Type of the fixed-length attribute.

    ULONG Type;

    // Byte count of the fixed length attribute when stored in SAM
    ULONG SamLength;

    // Byte count of the fixed-length attribute when stored in the DS

    ULONG Length;

} SAMP_FIXED_ATTRIBUTE_TYPE_INFO, PSAMP_FIXED_ATTRIBUTE_TYPE_INFO;

// These constants are used to allocate a table of fixed-attribute informa-
// tion structures. If elements are added or removed from SAMP_OBJECT_TYPE,
// or if structure members in any of the SAM fixed-attribute strucutes are
// added or removed, then these constants must be updated to reflect the new
// members. SAMP_ATTRIBUTE_TYPES_MAX is the maximum number of attributes in
// any single SAM object.

#define SAMP_OBJECT_TYPES_MAX               5
#define SAMP_FIXED_ATTRIBUTES_MAX           18
#define SAMP_VAR_ATTRIBUTES_MAX             18

// These values of these constants are equal to the number of data members in
// the SAM fixed-length attribute structures for each object type. These con-
// stants must be updated whenever data members are added or removed from the
// fixed-length attributes structures.

#define SAMP_SERVER_FIXED_ATTR_COUNT        1
#define SAMP_DOMAIN_FIXED_ATTR_COUNT        15
#define SAMP_GROUP_FIXED_ATTR_COUNT         1
#define SAMP_ALIAS_FIXED_ATTR_COUNT         1
#define SAMP_USER_FIXED_ATTR_COUNT          12

// These type-information arrays are used by the routines in this file. They
// contain data type/size information that is needed by the DS routines for
// reading/writing data. Changes to the fixed-length attribute structures re-
// quire corresponding updates to these arrays.

extern SAMP_FIXED_ATTRIBUTE_TYPE_INFO
    SampFixedAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_FIXED_ATTRIBUTES_MAX];

// SAM variable-length attributes explicitly store length and the number
// of attributes for each object is defined in samsrvp.h. No type information,
// however is stored with these attributes, so define this table.

typedef struct _SAMP_VAR_ATTRIBUTE_TYPE_INFO
{
    // Type of the variable-length attribute.

    ULONG Type;

    // The field identifier identifies the attribute as being associated
    // with a field of the WhichFields parameter for user all information.
    // The passed in whichfields parameter in userallinformation can be used
    // to control what is being prefetched.

    ULONG FieldIdentifier;
    BOOLEAN IsGroupMembershipAttr;

} SAMP_VAR_ATTRIBUTE_TYPE_INFO, PSAMP_VAR_ATTRIBUTE_TYPE_INFO;

extern SAMP_VAR_ATTRIBUTE_TYPE_INFO
    SampVarAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_VAR_ATTRIBUTES_MAX];

// Routine forward declarations.

NTSTATUS
SampConvertAttrBlockToVarLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes,
    OUT PULONG TotalLength
    );

NTSTATUS
SampConvertVarLengthAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    );

NTSTATUS
SampConvertAttrBlockToFixedLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PVOID *SamAttributes,
    OUT PULONG TotalLength
    );

NTSTATUS
SampConvertFixedLengthAttributesToAttrBlock(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    );

NTSTATUS
SampConvertAttrBlockToCombinedAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PVOID *SamAttributes,
    OUT PULONG FixedLength,
    OUT PULONG VariableLength
    );

NTSTATUS
SampConvertCombinedAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN ULONG FixedLength,
    IN ULONG VariableLength,
    OUT PDSATTRBLOCK *DsAttributes
    );

VOID
SampFreeAttributeBlock(
   IN PDSATTRBLOCK AttrBlock
   );

BOOLEAN
IsGroupMembershipAttr(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AttrIndex
    );

NTSTATUS
SampAppendAttrToAttrBlock(
    IN ATTR CredentialAttr,
    IN OUT PDSATTRBLOCK * DsAttrBlock
    );

VOID
SampMarkPerAttributeInvalidFromWhichFields(
    IN PSAMP_OBJECT Context,
    IN ULONG        WhichFields
    );

#endif // _DSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\sam\server\dsmember.c ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsmember.c

Abstract:

    This file contains SAM private API Routines that manipulate
    membership related things in the DS.

Author:
    MURLIS

Revision History

    7-2-96 Murlis Created

--*/

#include <samsrvp.h>
#include <attids.h>
#include <dslayer.h>
#include <filtypes.h>
#include <dsmember.h>
#include <dsdsply.h>
#include <sdconvrt.h>
#include <malloc.h>

//
// Theory of Operation for Membership Attributes for Group and Alias Types
//
//
// Alias and Group objects have multiple "membership-related" attributes: 
// members and non members (ATT_MEMBER, ATT_MSDS_NON_MEMBERS). In terms
// of manipulating the memberships of each attribute, they are identical -- 
// thier only difference is an application or component's interpretation of the 
// values.  As such, most membership support routines in this file are
// parameterized to take the membership attribute requested. Only when
// the change is committed to the DS is the actually type of membership
// looked at.
// 
// Some W.NET implementation notes:
//
// 1. Only Application Basic and Ldap Query groups can have non-members
// 2. The scoping rules for non-members is identical to members.
// 3. While the members attribute affects group expansion, non-members
//    does not.
// 
// A corollary of 1. is that non-members doesn't exist in registry mode.
//

VOID
SampDsFreeCachedMembershipOperationsList(
    IN PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY *MembershipOperationsList,
    IN ULONG *MaxLength,
    IN ULONG *Count
    )
/*++

Routine Description:

    This routine will release the memory used to buffer membership operations for 
    group or alias. 

Parameters:

    MembershipOperationsList -- the list to free
    
    MaxLength, Count -- associated state set to zero

Return Values:

    None.

--*/

{
    ULONG  Index = 0;
    
    SAMTRACE("SampDsFreeCachedMembershipOperationsList");
    
    if (NULL != *MembershipOperationsList)
    {
        for (Index = 0; Index < *MaxLength; Index++)
        {
            if (NULL != (*MembershipOperationsList)[Index].MemberDsName)
            {
                MIDL_user_free( (*MembershipOperationsList)[Index].MemberDsName );
            }
        }
        
        MIDL_user_free(*MembershipOperationsList);
        
        *MembershipOperationsList = NULL;
    }
    
    (*Count) = 0;
    (*MaxLength) = 0;

    return;    
}



NTSTATUS                        
SampDsFlushCachedMembershipOperationsList(
    IN DSNAME *Object,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG  SamAttrType,
    IN OUT PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY *MembershipOperationsList,
    IN OUT ULONG *MaxLength,
    IN OUT ULONG *Count
)
/*++

Routine Description:

    This routine will write all buffered group / alias membership operations to DS
    After everything is done, this routine will zero the memory. 

Parameters:

    Object -- the group or alias object in the DS
    
    ObjectType -- group or alias
    
    SamAttrType -- membership to modify (members, or non members)
    
    MemberOperationsList, MaxLength, Count -- attributes of the cached 
                                              operations
    
Return Values:

    NTSTATUS -- STATUS_NO_MEMORY   
                ..

--*/

{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    ULONG     Index;
    ATTRMODLIST * AttrModList = NULL;
    MODIFYARG   ModifyArg;
    MODIFYRES   *pModifyRes = NULL;
    ATTRMODLIST * CurrentMod = NULL, * NextMod = NULL, * LastMod = NULL;
    COMMARG     * pCommArg = NULL;
    ULONG       MembershipAttrType;
    ULONG       RetValue;
    
    SAMTRACE("SampDsFlushCachedMembershipOperationsList");


    ASSERT(*Count);
    
    NtStatus = SampDoImplicitTransactionStart(TransactionWrite);
    
    if (STATUS_SUCCESS != NtStatus)
    {
        goto Error;
    }

    //
    // Get the DS attribute name
    //
    MembershipAttrType = SampDsAttrFromSamAttr(ObjectType,
                                               SamAttrType);
    
    // 
    // allocate memory to hold all membership operations (add / remove) 
    // "*Count - 1" is because of FirstMod in ModifyArg can host one operation
    //
    // Using thread memory, because DirModifyEntry will merge the link-list
    // in DirModifyEntry. 
    // 
    if (*Count > 1)
    {
        AttrModList = (ATTRMODLIST *) DSAlloc( (*Count - 1) * sizeof(ATTRMODLIST) );
    
        if (NULL == AttrModList)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        memset(AttrModList, 0, (*Count - 1) * sizeof(ATTRMODLIST));
    }
    
    memset( &ModifyArg, 0, sizeof(ModifyArg) );
    CurrentMod = &(ModifyArg.FirstMod);
    NextMod = AttrModList;
    LastMod = NULL;
    
    for (Index = 0; Index < (*Count); Index++)
    {
        if ( ADD_VALUE == (*MembershipOperationsList)[Index].OpType)
        {
            CurrentMod->choice = AT_CHOICE_ADD_VALUES;
        }
        else 
        {
            ASSERT( REMOVE_VALUE == (*MembershipOperationsList)[Index].OpType);
            CurrentMod->choice = AT_CHOICE_REMOVE_VALUES;
        }
        
        CurrentMod->AttrInf.attrTyp = MembershipAttrType;
        
        CurrentMod->AttrInf.AttrVal.valCount = 1;
        CurrentMod->AttrInf.AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
        
        if (NULL == CurrentMod->AttrInf.AttrVal.pAVal)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error; 
        }
        
        memset(CurrentMod->AttrInf.AttrVal.pAVal, 0, sizeof(ATTRVAL));
        
        CurrentMod->AttrInf.AttrVal.pAVal[0].valLen = 
                (*MembershipOperationsList)[Index].MemberDsName->structLen;
        
        CurrentMod->AttrInf.AttrVal.pAVal[0].pVal = 
                (PUCHAR) (*MembershipOperationsList)[Index].MemberDsName;
                
        LastMod = CurrentMod;
        CurrentMod->pNextMod = NextMod;
        CurrentMod = CurrentMod->pNextMod;
        NextMod = NextMod + 1;
        
    }
    
    if (LastMod)
    {
        LastMod->pNextMod = NULL;
    }
    else
    {
        // this should not happen
        ASSERT(FALSE && "NULL == LastMod");
    }
    
    pCommArg = &(ModifyArg.CommArg);
    BuildStdCommArg(pCommArg);
    
    ModifyArg.pObject = Object;
    ModifyArg.count = (USHORT) *Count;
    
    SAMTRACE_DS("DirModifyEntry\n");
    
    RetValue = DirModifyEntry(&ModifyArg, &pModifyRes);
    
    SAMTRACE_RETURN_CODE_DS(RetValue);
    
    if (NULL == pModifyRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue, &pModifyRes->CommRes);
    }
    
    if (STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS==NtStatus)
    {
        NtStatus = STATUS_MEMBER_IN_ALIAS;
    }
    else 
    {
        if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
        {
            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
        }
    }
    
Error:    

    // 
    // Clear any error
    //
    SampClearErrors();
    
    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //
    SampSetDsa(TRUE);
    
    // 
    // release memory occupied by MemberDsName
    // 
    for (Index = 0; Index < (*Count); Index++)
    {
        if (NULL != (*MembershipOperationsList)[Index].MemberDsName)
        {
            MIDL_user_free( (*MembershipOperationsList)[Index].MemberDsName );
        }
        
    }
    
    RtlZeroMemory(*MembershipOperationsList,
                  (*MaxLength) * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                  );
    
    *Count = 0;
    
    return NtStatus;
}



NTSTATUS
SampDsAddMembershipOperationToCache(
    IN PSAMP_OBJECT Context, 
    IN ULONG        Attribute,
    IN ULONG        OperationType,
    IN DSNAME       * MemberDsName
)
/*++

Routine Description:

    This routine adds one membership operation (add/remove) to the context's buffer. 
    At the very beginning, it will allocate INIT_MEMBERSHIP_OPERATION_NUMBER slots for 
    membership operations. If more membership operations need to be buffered, this 
    routine will extend the buffer to MAX_MEMBERSHIP_OPERATION_NUMBER. 
    
    When buffered operations fill the buffer, we will flush all these operaions to DS.
    
    If any error occurs, this routine will discard already buffered membership operations.       
    
Parameters:

    Context -- Pointer to Object's Context
    
    Attribute -- the member attribute to update
    
    OperationType -- ADD_VALUE or REMOVE_VALUE, specify the membership operation.
    
    MemberDsName -- Pointer to the DSNAME, which should be added to or removed from the 
                    group/alias Member Attribute.

Return Values:

    NTSTATUS - STATUS_NO_MEMORY, 
               or return value from SampDsFlushCachedMembershipOperationsList().

--*/ 

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index;
    ULONG       *MaxLength = NULL;
    ULONG       *Count = NULL;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY ** MembershipOperationsList = NULL;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY * TmpMembershipOperationsList = NULL; 
    
    SAMTRACE("SampDsAddMembershipOperationToCache");
    
    ASSERT(NULL != Context);
    ASSERT(ADD_VALUE == OperationType || REMOVE_VALUE == OperationType);
    ASSERT(NULL != MemberDsName);
    
    if (SampGroupObjectType == Context->ObjectType)
    {
        MembershipOperationsList = & (Context->TypeBody.Group.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Group.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Group.CachedMembershipOperationsListMaxLength);
    }
    else
    {
        ASSERT(SampAliasObjectType == Context->ObjectType);
        
        if (Attribute == SAMP_ALIAS_MEMBERS) {
            MembershipOperationsList = & (Context->TypeBody.Alias.CachedMembershipOperationsList);
            Count = & (Context->TypeBody.Alias.CachedMembershipOperationsListLength);
            MaxLength = & (Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength);
        } else {
            ASSERT(Attribute == SAMP_ALIAS_NON_MEMBERS);

            MembershipOperationsList = & (Context->TypeBody.Alias.CachedNonMembershipOperationsList);
            Count = & (Context->TypeBody.Alias.CachedNonMembershipOperationsListLength);
            MaxLength = & (Context->TypeBody.Alias.CachedNonMembershipOperationsListMaxLength);
        }
    }
    
    // 
    // Allocate small amount of memory at beginning.
    //     
    
    if (NULL == *MembershipOperationsList)
    {
        *MembershipOperationsList =  
            MIDL_user_allocate(INIT_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY));
        
        if (NULL == *MembershipOperationsList)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        RtlZeroMemory(*MembershipOperationsList, 
                      INIT_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY));
        
        (*Count) = 0;
        
        (*MaxLength) = INIT_MEMBERSHIP_OPERATION_NUMBER;
    }
    
    //
    // Extend memory if necessary
    //    
    
    if ((INIT_MEMBERSHIP_OPERATION_NUMBER <= *Count) &&
        (INIT_MEMBERSHIP_OPERATION_NUMBER == *MaxLength) )
    {
        
        TmpMembershipOperationsList = 
            MIDL_user_allocate(MAX_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY));
        
        if (NULL == TmpMembershipOperationsList)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        RtlZeroMemory(TmpMembershipOperationsList, 
                      MAX_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                      );
        
        RtlCopyMemory(TmpMembershipOperationsList, 
                      *MembershipOperationsList, 
                      INIT_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                      );
        
        MIDL_user_free(*MembershipOperationsList);
        
        *MembershipOperationsList = TmpMembershipOperationsList;
        TmpMembershipOperationsList = NULL;
        
        (*MaxLength) = MAX_MEMBERSHIP_OPERATION_NUMBER;
    }
    
    //
    // Fill one membership operation slot
    //     
    
    (*MembershipOperationsList)[*Count].OpType = OperationType;
    (*MembershipOperationsList)[*Count].MemberDsName = MIDL_user_allocate(MemberDsName->structLen); 
                                            
    if (NULL == (*MembershipOperationsList)[*Count].MemberDsName)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }
    
    RtlZeroMemory((*MembershipOperationsList)[*Count].MemberDsName, 
                  MemberDsName->structLen
                  );
                  
    RtlCopyMemory((*MembershipOperationsList)[*Count].MemberDsName, 
                  MemberDsName, 
                  MemberDsName->structLen
                  );
    
    (*Count) ++;
    
    // 
    // Flush the buffered membership operations if we reach upper limit. 
    // and SampDsFlushCachedMembershipOperaionsList will do the cleanup work and reset Count
    // 
    
    if (MAX_MEMBERSHIP_OPERATION_NUMBER <= *Count)
    {
        NtStatus = SampDsFlushCachedMembershipOperationsList(Context->ObjectNameInDs,
                                                             Context->ObjectType,
                                                             Attribute,
                                                             MembershipOperationsList,
                                                             MaxLength,
                                                             Count);
    }
    
    return NtStatus;
    
Error: 

    // 
    // If any error occured, cleanup everything. 
    // Discard all buffered operations.
    // Reset Count 
    // 

    if (NULL != *MembershipOperationsList)
    {
        for (Index = 0; Index < *Count; Index++)
        {
            if (NULL != (*MembershipOperationsList)[Index].MemberDsName)
            {
                MIDL_user_free( (*MembershipOperationsList)[Index].MemberDsName );
            }
        }
        
        RtlZeroMemory(*MembershipOperationsList, 
                      (*MaxLength) * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                      );
    }
    
    (*Count) = 0;

    return NtStatus;
}


NTSTATUS
SampDsGetAliasMembershipOfAccount(
    IN DSNAME       *DomainDn,
    IN DSNAME       *AccountDn,
    OUT PULONG      MemberCount OPTIONAL,
    IN OUT PULONG   BufferSize  OPTIONAL,
    OUT PULONG      Buffer      OPTIONAL
    )
/*++

  Routine Description:

        This routine gives the alias membership list of a given
        account SID, in the domain speicified by DomainObjectName,
        in the DS. This list is used in computing the given user's
        Token.

  Arguments:

        DomainDn         -- DSNAME of the Domain, in which evaluation is done.
        AccountDn        -- DSNAME of the Account
        MemberCount      -- List of Aliases this is a member of
        BufferSize       -- Passed in by caller if he has already allocated a Buffer
        Buffer           -- Buffer to hold things in, Pointer can hold
                            NULL, if caller wants us to allocate

  Return Values

        STATUS_SUCCESS
        Other Error codes From DS Layer.
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       cSid;
    PDSNAME     * rpDsNames = NULL;
    ULONG       BufferReqd;
    BOOLEAN     BufferAllocated = FALSE;
    ULONG       Index;





    ASSERT(ARGUMENT_PRESENT(MemberCount));

    *MemberCount = 0;

    //
    // Look at the DS object
    //

    if (NULL==AccountDn)
    {
        //
        // Do not fail the call. Return 0 member count
        //

        if (ARGUMENT_PRESENT(BufferSize))
            *BufferSize = 0;
        Status = STATUS_SUCCESS;
        return(Status);
    }


    // Perform lazy thread and transaction initialization.
    Status = SampMaybeBeginDsTransaction(SampDsTransactionType);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Get the reverse membership list
    //

    Status = SampGetMemberships(
                &AccountDn,
                1,
                DomainDn,
                RevMembGetAliasMembership,
                &cSid,
                &rpDsNames,
                NULL,
                NULL,
                NULL
                );

    if (!NT_SUCCESS(Status))
        goto Error;


    BufferReqd = cSid * sizeof(ULONG);
    *MemberCount = cSid;

    if (ARGUMENT_PRESENT(Buffer)&&(*MemberCount>0))
    {

        //
        // Buffer size must be provided.
        //

        if (!ARGUMENT_PRESENT(BufferSize))
        {
           Status = STATUS_INVALID_PARAMETER;
           goto Error;
        }

        if (NULL == Buffer)
        {
            //
            // Buffer size must be provided and equal to 0
            //

            if (0!=*BufferSize)
            {

                Status = STATUS_INVALID_PARAMETER;
                goto Error;
            }
            else
            {
                //
                // Allocate buffer
                //

                Buffer = MIDL_user_allocate(BufferReqd);
                if (NULL== Buffer)
                {
                    Status = STATUS_NO_MEMORY;
                    goto Error;
                }

                *BufferSize = BufferReqd;
                BufferAllocated = TRUE;
            }
        }
        else
        {
            if (*BufferSize < BufferReqd)
            {
                //
                // Less buffer than what is required
                //

                Status = STATUS_BUFFER_OVERFLOW;
                goto Error;
            }

            *BufferSize = BufferReqd;
        }

        //
        // Copy in the memberships
        //

        for (Index=0;Index<cSid;Index++)
        {
          ASSERT(rpDsNames[Index]->SidLen>0);

          Status = SampSplitSid(
                        &((rpDsNames[Index])->Sid),
                        NULL,
                        & (Buffer[Index])
                        );

          if (!NT_SUCCESS(Status))
                goto Error;
        }
    }
    else if (ARGUMENT_PRESENT(BufferSize))
    {
        *BufferSize = BufferReqd;
    }


Error:

    //
    // Cleanup on errors
    //


    if (!NT_SUCCESS(Status))
    {
        if (BufferAllocated)
        {
             MIDL_user_free(Buffer);
             Buffer = NULL;
        }
    }

    return Status;
}



NTSTATUS
SampDsGetGroupMembershipOfAccount(
    IN DSNAME * DomainDn,
    IN DSNAME * AccountObject,
    OUT  PULONG MemberCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    )
/*

  Routine Description:

        This routine gets the reverse group membership list of the given Account,
        in the domain, specified by DomainObjectName. The Account is specified
        by the account Rid.

            DomainDn         -- DSNAME of Domain, where search needs to be limited to.
            AccountObject    -- DSName of the Account whose reverse membership needs
                                to be computed.
            MemberCount      -- Count of Members.
            Membership       -- Returned group membership list
*/
{
    NTSTATUS    Status;
    ULONG       cSid;
    PDSNAME     * rpDsNames=NULL;
    ULONG       Index;


    // Perform lazy thread and transaction initialization.
    Status = SampMaybeBeginDsTransaction(SampDsTransactionType);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    Status = SampGetMemberships(
                &AccountObject,
                1,
                DomainDn,
                RevMembGetGroupsForUser,
                &cSid,
                &rpDsNames,
                NULL,
                NULL,
                NULL
                );

    if (NT_SUCCESS(Status))
    {
        *MemberCount = cSid;

        if (ARGUMENT_PRESENT(Membership))
        {
            //
            // Alloc one more for the user's primary group
            //

            *Membership = MIDL_user_allocate((cSid+1) * sizeof(GROUP_MEMBERSHIP));
            if (NULL==*Membership)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            for (Index=0;Index<cSid;Index++)
            {
                ASSERT(rpDsNames[Index]->SidLen>0);

                Status = SampSplitSid(
                            &(rpDsNames[Index]->Sid),
                            NULL,
                            &(((*Membership)[Index]).RelativeId)
                            );
                if (!NT_SUCCESS(Status))
                    goto Error;

                ((*Membership)[Index]).Attributes = SE_GROUP_MANDATORY |
                            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;

            }
        }
    }

Error:

    //
    // Cleanup on return
    //

    if (!NT_SUCCESS(Status))
    {
        if (ARGUMENT_PRESENT(Membership) && (NULL!=*Membership))
        {
            MIDL_user_free(*Membership);
            *Membership= NULL;
        }
    }

    return Status;
}


NTSTATUS
SampDsAddMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN ULONG    Flags,
    IN ULONG    MembershipAttrType,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    )
/*++
 Routine Description:

        This routine adds a Member To a Group or Alias Object

 Arguments:
        GroupObjectName -- DS Name of the Group or Alias
        Flags           -- flags to be passed to dslayer
        Attribute       -- the membership attribute to adjust
        SamObjectType   -- the SAM object
        MemberName      -- DS Name of the Member to be added

 Return Values:
        STATUS_SUCCESS
        Other Error codes from DS Layer
--*/
{
    ATTRVAL MemberVal;
    ATTR    MemberAttr;
    ATTRBLOCK AttrsToAdd;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Build the Attr Val adding the membership attr
    //

    MemberVal.valLen = MemberName->structLen;
    MemberVal.pVal = (UCHAR *) MemberName;
    MemberAttr.attrTyp = MembershipAttrType;
    MemberAttr.AttrVal.valCount = 1;
    MemberAttr.AttrVal.pAVal = & MemberVal;


    //
    // Build the AttrBlock
    //

    AttrsToAdd.attrCount = 1;
    AttrsToAdd.pAttr = & MemberAttr;

    //
    // Add the Value
    //

    NtStatus = SampDsSetAttributes(
                    GroupObjectName, // Object
                    Flags,           // Flags
                    ADD_VALUE,       // Operation
                    SamObjectType,   // ObjectType
                    &AttrsToAdd      // AttrBlock
                    );

    return NtStatus;
}

NTSTATUS
SampDsAddMultipleMembershipAttribute(
    IN DSNAME*          GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DWORD            Flags,
    IN DWORD            MemberCount,
    IN DSNAME*          MemberName[]
    )
/*++

 Routine Description:

        This routine adds a multiple members to a group or alias object

 Arguments:

        GroupObjectName -- DS Name of the Group or Alias
        SamObjectType   -- group or alias
        Flags           -- SAM_LAZY_COMMIT, etc.
        MemberCount     -- number of elements in MemberName
        MemberName      -- array of dsnames

 Return Values:

        STATUS_SUCCESS

        Other Error codes from DS Layer
--*/
{
    NTSTATUS  NtStatus;


    ULONG     MembershipAttrType;
    ATTRVAL  *MemberVal = NULL;
    ATTR     *MemberAttr = NULL;
    ATTRBLOCK AttrsToAdd;

    ULONG     i;


    if ( MemberCount < 1 )
    {
        return STATUS_SUCCESS;
    }

    //
    // Get the membership attribute for the SAM object in question
    //
    switch( SamObjectType )
    {
        case SampGroupObjectType:

            MembershipAttrType = SAMP_GROUP_MEMBERS;
            break;

        case SampAliasObjectType:

            MembershipAttrType = SAMP_ALIAS_MEMBERS;
            break;

        default:

            ASSERT( !"Unknown ObjectType" );
            return STATUS_UNSUCCESSFUL;

    }

    //
    // Build the Attr Val adding the membership attr
    //
    MemberVal = ( ATTRVAL* ) RtlAllocateHeap( RtlProcessHeap(),
                                              0,
                                              MemberCount * sizeof( ATTRVAL ) );
    if ( !MemberVal )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    MemberAttr = ( ATTR* ) RtlAllocateHeap( RtlProcessHeap(),
                                            0,
                                            MemberCount * sizeof(ATTR) );
    if ( !MemberAttr )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    for ( i = 0; i < MemberCount; i++ )
    {
        MemberVal[i].valLen            = MemberName[i]->structLen;
        MemberVal[i].pVal              = (UCHAR*) MemberName[i];
        MemberAttr[i].attrTyp          = MembershipAttrType;
        MemberAttr[i].AttrVal.valCount = 1;
        MemberAttr[i].AttrVal.pAVal    = &MemberVal[i];
    }

    //
    // Build the AttrBlock
    //
    AttrsToAdd.attrCount = MemberCount;
    AttrsToAdd.pAttr = &MemberAttr[0];

    //
    // Add the Value
    //
    NtStatus = SampDsSetAttributes( GroupObjectName,
                                    Flags,
                                    ADD_VALUE,
                                    SamObjectType,
                                    &AttrsToAdd  );

Cleanup:

    if ( MemberVal )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, MemberVal );
    }

    if ( MemberAttr )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, MemberAttr );
    }

    return NtStatus;

}

NTSTATUS
SampDsRemoveMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN ULONG    MembershipAttrType,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    )
/*++
Routine Description:

        This Routine Removes a Member from a Group or Alias Object

Arguments:

        GroupObjectName -- DS Name of the Group or Alias
        Attribute       -- The membership attribute to modify
        MemberName      -- DS Name of the Member to be added

 Return Values:
        STATUS_SUCCESS
        Other Error codes from DS Layer
--*/
{
    ATTRVAL MemberVal;
    ATTR    MemberAttr;
    ATTRBLOCK AttrsToRemove;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Build the Attr Val adding the membership attr
    //

    MemberVal.valLen = MemberName->structLen;
    MemberVal.pVal = (UCHAR *) MemberName;
    MemberAttr.attrTyp = MembershipAttrType;
    MemberAttr.AttrVal.valCount = 1;
    MemberAttr.AttrVal.pAVal = & MemberVal;

    //
    // Build the AttrBlock
    //

    AttrsToRemove.attrCount = 1;
    AttrsToRemove.pAttr = & MemberAttr;

    //
    // Remove the Value
    //

    NtStatus = SampDsSetAttributes(
                    GroupObjectName, // Object
                    0,               // Flags
                    REMOVE_VALUE,    // Operation
                    SamObjectType,   // ObjectType
                    &AttrsToRemove   // AttrBlock
                    );

    return NtStatus;

}

/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  GROUP CACHE -- Theory of operation


  SAM caches upto 10 groups with large member counts for purposes
  of speeding up BDC replication.

  1. Simple description -- in simple terms the group cache caches
  the membership of the 10 largest groups. Cached groups can be 
  local , global or universal. The general mechansim is that on
  a query, the cache is first checked, if the group is in the cache
  the request is satisfied out of the cache, else the membership 
  is evaluated from the database. If the member count is large
  enough the ( ie greater than SAMP_DS_LARGE_GROUP_LIMIT ) then the
  group is cached.

  2. Serializing access to the group cache -- access to the group
  cache is serialized by using the SampDsGroupLock critical section

  3. Keeping the cache upto date -- The cache maintains an aggressive
  invalidate algorithm. That means that most changes invalidate the
  cache today ( ie when in doubt invalidate ). The invalidate algorithm
  can be improved by gathering more data and making it more sophisticated
  such that cached groups are invalidated more selectively. It is debatable
  if such sophistication is required as the primary purpose of the cache
  was to speed up BDC replication and given the high temporal locality
  of queries in that scenario, followed by relative infrequency of changes
  the cache should still be pretty effective for what it was designed for

  4. Transactional consistency -- Since the cache was designed for BDC
  replication, it is important to build a transactionally consistent cache.
  Transactional consitency in the group cache is achieved by using a 
  sequence number as follows

         i) Invalidates increase the sequence numbers with the group 
         cache lock held.

         ii) On a group membership query that needs to be evaluated
         from the database, we grab the current sequence number first.
         Then begin a fresh transaction ( the transaction must be 
         started after the sequence number was grabbed ) and evaluate
         the membership list from the database. Before caching it we
         check the sequence number ( with the lock held ). If sequence #
         match then it means that no invalidates were processed since
         the time we evaluated the membership and we are good to cache.
         If sequence numbers do not match, then we discard the results as
         far as caching is concerned.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
//
// Declare structures for the group cache. The cache can be
// in terms of RID as we host exactly one domain today and
// the groups in the builtin domain won't clash in terms of
// RID with any other group RID.
//


//
// We don't want to cache membership of small groups.
// SAMP_DS_LARGE_GROUP_LIMIT defines the member count of groups
// above which we want to cache.
//

#if DBG
#define SAMP_DS_LARGE_GROUP_LIMIT 10
#else
#define SAMP_DS_LARGE_GROUP_LIMIT 1000
#endif


//
// The group cache is an array of cache elements declared
// as follows
//

typedef struct _GroupMembershipCacheElement {
    ULONG  Rid;
    SAMP_OBJECT_TYPE ObjectType;
    PVOID Members;
    ULONG  MemberCount;
    ULARGE_INTEGER TimeStamp;
    BOOLEAN Valid;
} GROUP_MEMBERSHIP_CACHE_ELEMENT;


GROUP_MEMBERSHIP_CACHE_ELEMENT GroupCache[10];

//
// Critical section used to serialize access to the group 
// cache
//

CRITICAL_SECTION SampDsGroupLock;

//
// Sequence No, used to detect if any changes were made to the
// database since we evaluated the group info
//

ULONG GroupCacheSequenceNum=0;


//
// Critical section used to serialize computation of membership
// of expensive groups such as domain users and domain computers
//

CRITICAL_SECTION SampDsExpensiveGroupLock;


NTSTATUS
SampInitializeGroupCache()
/*++

   Initialize Routine for the group cache, clears the group
   cache, and initializes the critical sections and sequence #

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory(GroupCache,sizeof(GroupCache));
    GroupCacheSequenceNum = 0;


    Status = RtlInitializeCriticalSection(&SampDsGroupLock);
    if (NT_SUCCESS(Status))
    {
        Status = RtlInitializeCriticalSection(&SampDsExpensiveGroupLock);
    }

    return(Status);

}

//
// Primitives to aquire and release the group cache lock and test if
// the current thread owns the group cache lock
//

VOID 
SampAcquireGroupLock()
{
    NTSTATUS Status;

    Status = RtlEnterCriticalSection(&SampDsGroupLock);

    // Nothing more to do other than assert, failure
    // to aquire lock will result in very difficult situations
    // as we'll find ourselves in situations where changes are
    // commited, can't update change log etc. Fundamentally these
    // primitives need to be fixed such that they do appropriate
    // resource reservation at initialize time.

    ASSERT(NT_SUCCESS(Status));
}

VOID
SampReleaseGroupLock()
{
    RtlLeaveCriticalSection(&SampDsGroupLock);
}

BOOLEAN
SampIsGroupLockAcquired()
{
    ULONG_PTR OwningThread = (ULONG_PTR) SampDsGroupLock.OwningThread;
    ULONG_PTR CurrentThread = (ULONG_PTR) (NtCurrentTeb())->ClientId.UniqueThread;

    if (CurrentThread==OwningThread)
    {
        return(TRUE);
    }

    return(FALSE);
}

//
// Primitives to invalidate the group cache
//
  
VOID
SampInvalidateGroupCacheEntry(
    IN ULONG Slot
    )
/*++

  Invalidates the group cache entry described by slot.
  Invalidation simply invalidates the membership  list,
  the RID and Membercount are left in there for reference
  as a hint to indicate that the given group is a big
  group. This information is used to control the 
  transactional semantics of retrieiving the group membership,
  a group that potentially should be cached is retrieved,
  with the group cache lock held and the transaction started
  with the group cache held

  Parameters:

  Slot -- specifies the entry slot

--*/
{
    ASSERT(SampIsGroupLockAcquired());

    if (NULL!=GroupCache[Slot].Members)
    {
        MIDL_user_free(GroupCache[Slot].Members);
    }

    GroupCache[Slot].Valid = FALSE;

    GroupCache[Slot].Members = NULL;
   
}

VOID
SampInvalidateGroupCache()
/*++

  Invalidates the complete group cache

--*/
{
    ULONG i=0;

    for (i=0;i<ARRAY_COUNT(GroupCache);i++)
    {
        SampInvalidateGroupCacheEntry(i);
    }
}

VOID
SampInvalidateGroupCacheByMemberRid(
    IN ULONG Rid
    )
/*++

  Given the RID of a member, this routine searches the cache
  for groups and invalidates all the groups that this 
  security principal is a member of
--*/
{
    //
    // There are 2 ways by which we can determine if the user
    // or a group is a member of any cached groups. 
    // 1. We can search for the group in the membership list
    // 2. We can get the reverse membership of the object and then
    //    check to see if any groups that this is object is a member of
    //    is cached. 
    // Both changes require some more complicated infrastructural changes
    // 1. above requires we maintain the membership in a sorted fashion
    //    so that we can do a binary search
    // 2. above requires that we supply the member of attribute's value 
    //    as it was before deletion as part of the notification callout.
    //
    // For the purpose of speeding up NT 4 BDC replication by one magnitude    
    // neither of these changes is required. Following an aggressive invalidate
    // strategy of invalidating the entire cache, still delivers the goods as
    // there is a lot of temporal locality with multiple BDC's wanting to query
    // the same group within a very short window that can be exploited.
    //
    // Considering the factors above, for now we will simply invalidate the 
    // entire cache.
    //

    SampInvalidateGroupCache();
}



VOID
SampInvalidateGroupCacheElement(
    IN ULONG Rid
    )
/*++

   Invalidates the membership information for the group
   identified by RID. 

  Invalidation simply invalidates the membership  list,
  the RID and Membercount are left in there for reference
  as a hint to indicate that the given group is a big
  group. This information is used to control the 
  transactional semantics of retrieiving the group membership,
  a group that potentially should be cached is retrieved,
  with the group cache lock held and the transaction started
  with the group cache held.

   
   Parameters:

        Rid : Specifies the RID of the group

   Return Values:

      None

--*/
{
    ULONG i =0;

    ASSERT(SampIsGroupLockAcquired());

    for (i=0;i<ARRAY_COUNT(GroupCache);i++)
    {
        if (Rid == GroupCache[i].Rid)
        {
           SampInvalidateGroupCacheEntry(i);
        }
    }
}

VOID
SampProcessChangesToGroupCache(
    IN ULONG ChangedObjectRid,
    IN SAMP_OBJECT_TYPE ChangedObjectType,
    IN BOOL UserAccountControlChange,
    IN ULONG   UserAccountControl,
    IN SECURITY_DB_DELTA_TYPE DeltaType
    )
{

    BOOLEAN CacheInvalidated = FALSE;

    //
    // Acquire the group cache's lock
    //

    SampAcquireGroupLock();

     //
    // Invalidate the group cache for groups
    //

    if (((SampGroupObjectType==ChangedObjectType) ||
         (SampAliasObjectType==ChangedObjectType)))
    {
        SampInvalidateGroupCacheElement(
                ChangedObjectRid
                );

       CacheInvalidated = TRUE;
    }
   

    //
    // if  a new user or computer is being created then invalidate the 
    // membership of the appropriate default group
    //

    if ((SampUserObjectType==ChangedObjectType) && (SecurityDbNew==DeltaType)) 
    {
       
        if (UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
        {
            SampInvalidateGroupCacheElement(DOMAIN_GROUP_RID_COMPUTERS);
        }
        else if (UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
        {
            SampInvalidateGroupCacheElement(DOMAIN_GROUP_RID_CONTROLLERS);
        }
        else
        {
            SampInvalidateGroupCacheElement(DOMAIN_GROUP_RID_USERS);
        }

        CacheInvalidated = TRUE;
    }

    //
    // If the user account control is changed then membership of the user
    // or computer in the domain user's, domain computer's , or domain 
    // controllers group will be affected.
    //

    if ((SampUserObjectType==ChangedObjectType) && 
        (SecurityDbChange==DeltaType) && 
        (UserAccountControlChange))
    {
        //
        // Note we cannot tell of the groups we need to invalidate
        // based on the new value of user account control alone. We needed to 
        // have access to the old value of user account control, in addition
        // to the new value. Following our principle of an aggressive
        // invalidate strategy we will validate all 3 groups.
        //
     
        SampInvalidateGroupCacheElement(DOMAIN_GROUP_RID_COMPUTERS);
        SampInvalidateGroupCacheElement(DOMAIN_GROUP_RID_CONTROLLERS);
        SampInvalidateGroupCacheElement(DOMAIN_GROUP_RID_USERS);
       

        CacheInvalidated = TRUE;
    }

    //
    // On a user/computer/group deletion, invalidate the groups that the user/ 
    // computer/group were a member of
    //

    if (SecurityDbDelete==DeltaType)
    {
        SampInvalidateGroupCacheByMemberRid(ChangedObjectRid);
        CacheInvalidated = TRUE;
    }

    if (CacheInvalidated)
    {
        InterlockedIncrement(&GroupCacheSequenceNum);
    }

    SampReleaseGroupLock();
}



NTSTATUS
SampAllocateAndCopyGroupMembershipList(
    IN PVOID Original,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG MemberCount,
    OUT PVOID *New
    )
/*++

  Copies a membership list from one buffer to another, considering
  the type of membership -- global group membership is an array of RIDs
  Local group membership is an array of SIDs

  Parameters:

    Original -- The original membership list
    ObjectType -- The type of object
    MemberCount -- The count of members in the list
    New     -- The new membership list

  Return Values:

     STATUS_SUCCESS
     STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG i;

    if (SampGroupObjectType==ObjectType)
    {
        //
        // For global groups, the array is an array of RIDs
        //

        *New = MIDL_user_allocate(MemberCount*sizeof(ULONG));

        if (NULL==*New)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(
            *New,
            Original,
            MemberCount*sizeof(ULONG)
            );
    }
    else
    {
        ULONG  MembershipSize = MemberCount*sizeof(PSID)
                                + MemberCount * sizeof(NT4SID);
        NT4SID * OldSidArray = NULL;
        NT4SID * NewSidArray = NULL;

        ASSERT(SampAliasObjectType == ObjectType);

        //
        // For local groups, the array is an array of SIDs
        //

        *New = MIDL_user_allocate(MembershipSize);
        if (NULL==*New)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Copy the SID data
        //

        //
        // Get the correct address of actural SidArray
        // Fix for RAID: 689833
        // Note: because non security principal can be 
        //       a member of (local / global) group, a gap 
        //       between the pointers array (PSIDs) and the 
        //       memory to store the member SIDs can be created
        //       when we skip those non security principals. 
        // 
        // Illustrate as this:
        //       if DsRead returns N members, but one of them 
        //       is a non security principal, then PSID (Nth) 
        //       will point to NULL, thus create a gap between 
        //       PSID (N-1th) and SID (1st).  If there is not 
        //       gap, we should have a contiguous space. 
        // 
        // -------------
        // |  PSID 1   |-----------------
        // -------------                |
        // |  PSID 2   |-------------   |
        // ------------             |   |
        //      .                   |   |
        //      .                   |   |
        // ------------             |   |
        // |  PSID N-1|-----------| |   |
        // ------------           | |   |
        // |  PSID N  |-> NULL    | |   |
        // ------------           | |   |
        // |  SID 1   |<----------+-+---|
        // ------------           | |
        // |  SID 2   |<----------+--
        // ------------           |
        //      .                 |
        //      .                 |
        // ------------           |
        // |  SID N-1 |<-----------
        // ------------
        //    

    
        OldSidArray = (NT4SID *) ((PSID *)Original)[0];
        NewSidArray = (NT4SID *) (((PSID *)(*New)) + MemberCount);

       
        RtlCopyMemory(
            NewSidArray, 
            OldSidArray, 
            MemberCount * sizeof(NT4SID)
           );

        //
        // Fixup the pointers
        //

        for (i=0;i<MemberCount;i++)
        {
            ((PSID *)(*New))[i] = NewSidArray + i;
        }
    }

Error:

    return(NtStatus);
}





NTSTATUS
SampUpdateGroupCacheElement(
    IN ULONG Rid,
    IN ULONG Slot,
    IN PVOID Members OPTIONAL,
    IN ULONG MemberCount,
    IN SAMP_OBJECT_TYPE ObjectType
    )
/*++

  Updates the group cache element described by slot with the group membership
  of the group specified by Rid

  Parameters:

  Rid -- Rid of the group that whose membership is being updated
  Slot -- The entry of the group cache, where the membership is being updated
  Members -- the membership list, has different forms for global and local groups
  MemberCount -- Count of members
  ObjectType -- Describes the type of group -- local/global

  Return Values

    STATUS_SUCCESS
    Other error codes to denote resource failures
  
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
 

    //
    // This routine requires that the group cache lock be held
    //

    ASSERT(SampIsGroupLockAcquired());


    //
    // if the group already exists and its membership is
    // valid then simply update the timestamp
    //

    if ((GroupCache[Slot].Rid == Rid) && 
        (GroupCache[Slot].Valid) &&
        (GroupCache[Slot].ObjectType == ObjectType))
    {
         GetSystemTimeAsFileTime((FILETIME *)&GroupCache[Slot].TimeStamp);
    }
    else
    {
        //
        // invalidate the current entry if necessary
        //

        SampInvalidateGroupCacheElement(Slot);

        GroupCache[Slot].Rid = 0;
    
        //
        // Allocate and copy the supplied membership list
        // into the cached slot , provided the membership
        // was provided. If not simply cache the member count
        // information and that the cache was large.
        //

        if (ARGUMENT_PRESENT(Members))
        {
            NtStatus = SampAllocateAndCopyGroupMembershipList(
                            Members,
                            ObjectType,
                            MemberCount,
                            &GroupCache[Slot].Members
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

            GroupCache[Slot].Valid = TRUE;
        }

        GroupCache[Slot].Rid = Rid;
        GroupCache[Slot].MemberCount = MemberCount;
        GroupCache[Slot].ObjectType = ObjectType;
        GroupCache[Slot].TimeStamp.QuadPart = 0;
        GetSystemTimeAsFileTime((FILETIME *)&GroupCache[Slot].TimeStamp);
    }
 
Error:

    return(NtStatus);
}


NTSTATUS
SampCacheGroupMembership(
    IN ULONG Rid,
    IN PVOID Members,
    IN ULONG SequenceNumber,
    IN ULONG MemberCount,
    IN SAMP_OBJECT_TYPE ObjectType
    )
/*++

   Caches the membership of a group described by Rid

   Paramters

   Rid 

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN fLockAcquired = FALSE;
    ULONG i =0;
    ULARGE_INTEGER  OldestGroupTimeStamp = {0x7FFFFFFF,0xFFFFFFFF};
    ULONG OldestGroup = 0x7FFFFFFF; // set to a large value to start with
    

    //
    // No need to cache small groups, make an exception for domain users and
    // computers
    //

    if ((MemberCount<SAMP_DS_LARGE_GROUP_LIMIT) &&
       (Rid != DOMAIN_GROUP_RID_USERS) &&
       (Rid != DOMAIN_GROUP_RID_COMPUTERS))
    {
        //
        // No need to cache memberships of small groups
        // This is the case where the group is small and the
        // group did'nt previously exist in cache
        // 
        goto Exit;
    }

    //
    // Acquire the group cache lock
    //
   
    SampAcquireGroupLock();
    fLockAcquired = TRUE;

    //
    // if sequence # did not match then bail ... cannot cache the 
    // membership as a change was processed after we started the
    // membership evaluation
    //
  
    if (SequenceNumber != GroupCacheSequenceNum)
    {
        goto Exit;
    }

    //
    // First check to see if group is already
    // cached.
    //

    for (i=0;i<ARRAY_COUNT(GroupCache);i++)
    {
        if (Rid==GroupCache[i].Rid)
        {
            //
            // Group is already cached; need to update its
            // membership and timestamp
            //
            
             
            NtStatus = SampUpdateGroupCacheElement(
                            Rid,
                            i,
                            Members,
                            MemberCount,
                            ObjectType
                            );

            goto Exit;
        }
    }

    //
    // Search for a slot
    //

    for (i=0;i<ARRAY_COUNT(GroupCache);i++)
    {
       
        //
        // If there is a free available slot then use it
        //

        if (0==GroupCache[i].Rid) 
        {
            
            //
            // Free slot is available, using it ...
            //
       
            NtStatus = SampUpdateGroupCacheElement(
                            Rid,
                            i,
                            Members,
                            MemberCount,
                            ObjectType
                            );
     

            goto Exit;
        }

        //
        // Compute the least recently used group
        // Domain Users and Domain Computers are always cached
        //

        if (( GroupCache[i].TimeStamp.QuadPart < OldestGroupTimeStamp.QuadPart) &&
            ( GroupCache[i].Rid != DOMAIN_GROUP_RID_USERS) &&
            ( GroupCache[i].Rid != DOMAIN_GROUP_RID_COMPUTERS))
        {
            OldestGroupTimeStamp = GroupCache[i].TimeStamp;
            OldestGroup = i;
        }
    }

    //
    // Cache by replacing the least recently used group
    //

  
    NtStatus = SampUpdateGroupCacheElement(
                    Rid,
                    OldestGroup,
                    Members,
                    MemberCount,
                    ObjectType
                    );
   

Exit:

    if (fLockAcquired)
    {
        SampReleaseGroupLock();
    }
    
    return(NtStatus);
}


NTSTATUS
SampGetGroupFromCache(
    IN ULONG Rid,
    IN SAMP_OBJECT_TYPE ObjectType,
    OUT BOOLEAN *fFound,
    OUT ULONG   *SequenceNum,
    OUT PVOID * Members,
    OUT PULONG  MemberCount
    )
/*+++

   Checks to see if a given group is cached and if so retrieves its 
   membership list from the cache

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN fLockAcquired = FALSE;
    ULONG i =0;

    *fFound = FALSE;
   


    //
    // Acquire Group lock
    //

    SampAcquireGroupLock();
    fLockAcquired = TRUE;

    *SequenceNum = GroupCacheSequenceNum;
            

    for (i=0;i<ARRAY_COUNT(GroupCache);i++)
    {
        //
        // Test if group is in the cache in valid state
        //

        if ((Rid==GroupCache[i].Rid) &&
            (GroupCache[i].ObjectType==ObjectType) &&
            (GroupCache[i].Valid))
        {
            *MemberCount = GroupCache[i].MemberCount;
            if (ARGUMENT_PRESENT(Members))
            {

                //
                // Copy membership
                //

                NtStatus = SampAllocateAndCopyGroupMembershipList(
                                GroupCache[i].Members,
                                ObjectType,
                                *MemberCount,
                                Members
                                );

                if (!NT_SUCCESS(NtStatus))
                {
                    goto Error;
                }

                //
                // Update timestamp; so that we know that we recently
                // referenced the group
                //

                GetSystemTimeAsFileTime((FILETIME *)&GroupCache[i].TimeStamp);

            }

            *fFound = TRUE;
            break;
        }
    }
     
Error:
   
    if (fLockAcquired)
    {
        SampReleaseGroupLock();
    }

    return(NtStatus);
}


NTSTATUS
SampDsGetGroupMembershipList(
    IN DSNAME * DomainObject,
    IN DSNAME * GroupName,
    IN ULONG    GroupRid,
    IN PULONG  *Members OPTIONAL,
    IN PULONG MemberCount
    )
/*++

  Routine Description:

    This Routine Gets a Group Membership as an array of Rid's as required
    by SAM.
    
    NOTE (by ShaoYin): I modified this routine to query Group Members 
        in increments rather that as a whole. The reason is: when the
        Group hosts tons of thousands members, SAM will consume large
        amounts of memory to query members by using single DirRead. 
        After the change, this routine queried Group Memmbers in a 
        incremental fashion through everything is still in the same 
        transaction. By segmenting read member operation to several 
        DirRead(s), SAM will do better job. 
        
        But because all the DirRead(s) are still in one transaction, 
        actually we do not have much memory gain. 
        
        Probably, the right thing we need to do to relieve memory usage
        is segment the transaction. 
        
        The original code is commented at the end of this routine.
        Same for SampDsGetAliasMembershipsList()

  Arguments

    GroupName -- DSNAME of the concerned group object
    Members   -- Array of Rids will be passed in here
    MemberCount -- Count of Rids

  Return Values:
        STATUS_SUCCESS
        STATUS_NO_MEMORY
        Return Codes from DS Layer
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       PrimaryMemberCount;
    PULONG      PrimaryMembers = NULL;
    PULONG      TmpMembers = NULL; 
    
    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    COMMARG     * pCommArg = NULL;
    ATTR        MemberAttr;
    ENTINFSEL   EntInf;
    RANGEINFOITEM RangeInfoItem;
    RANGEINFSEL RangeInf;
    DWORD       LowerLimit = 0;
    ULONG       RetValue = 0;
    BOOLEAN     fFoundInCache = FALSE;
    ULONG       SequenceNum=0;
    BOOLEAN     fLockHeld = FALSE;
    LONG        Upper = 0;

    //
    //  Asserts
    //

    ASSERT(MemberCount);

    //
    // Initialize Members field
    //

    *MemberCount = 0;

    if (ARGUMENT_PRESENT(Members))
        *Members = NULL;

    // End existing transaction; as need to evaluate members in 
    // fresh transaction ... the transaction has to be started after
    // the sequence # has been obtained.
    
    SampMaybeEndDsTransaction(TransactionCommit);

    //
    // Serialize the evaluation of the domain users and domain computers group.
    // There are a couple of reasons for this
    // 1. This serialization acts as a throttle preventing the consumption of
    //    more than one CPU when evaluating these groups .. most servers are 
    //    multi cpu and this helps in not consuming all the cpu resources on 
    //    the server
    //
    // 2. In mixed domains when a change is detected to the domain users or 
    //    domain computers group, multiple bdc's may rush at the same time to
    //    grab the change. The serialization results in exactly one thread 
    //    performing the expensive evaluation
    //

    if ((GroupRid==DOMAIN_GROUP_RID_USERS)||(GroupRid == DOMAIN_GROUP_RID_COMPUTERS))
    {
        NTSTATUS IgnoreStatus;
        
        IgnoreStatus = RtlEnterCriticalSection(&SampDsExpensiveGroupLock);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        if (NT_SUCCESS(IgnoreStatus))
        {
            fLockHeld = TRUE;
        }
    }

    //
    // Check the cache
    //

    Status = SampGetGroupFromCache(
                GroupRid,
                SampGroupObjectType,
                &fFoundInCache,
                &SequenceNum,
                Members,
                MemberCount
                );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }

    if (fFoundInCache)
    {
        // we are done nothing more to do
        Status = STATUS_SUCCESS;
        goto Exit;
    }

    //
    // First check for any members that are present by virtue of the fact
    // that their primary group Id property indicates this group
    //

    Status = SampDsGetPrimaryGroupMembers(
                    DomainObject,
                    GroupRid,
                    &PrimaryMemberCount,
                    &PrimaryMembers
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }
    
    *MemberCount = PrimaryMemberCount;
    if (ARGUMENT_PRESENT(Members))
    {
        *Members = PrimaryMembers;
        PrimaryMembers = NULL;
    }
    
    //
    // init arguments 
    //
    memset(&EntInf,   0, sizeof(ENTINFSEL));
    memset(&RangeInf, 0, sizeof(RANGEINFSEL)); 
    memset(&ReadArg,  0, sizeof(READARG));
        
    MemberAttr.AttrVal.valCount = 0;
    MemberAttr.AttrVal.pAVal = NULL;
    MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                   SampGroupObjectType, 
                                   SAMP_GROUP_MEMBERS
                                   );
        
    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &MemberAttr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
        
    RangeInfoItem.AttId = MemberAttr.attrTyp;
    RangeInfoItem.lower = LowerLimit;           // 0 is the begin of index.
    RangeInfoItem.upper = -1;                   // means the end of values
        
    RangeInf.valueLimit = SAMP_READ_GROUP_MEMBERS_INCREMENT;
    RangeInf.count = 1;
    RangeInf.pRanges = &RangeInfoItem;
        
    ReadArg.pObject = GroupName;
    ReadArg.pSel = &EntInf;
    ReadArg.pSelRange = &RangeInf;
        
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);
    
    do
    {
        ATTRBLOCK   AttrsRead;
        
        RangeInfoItem.lower = LowerLimit;
        
        Status = SampDoImplicitTransactionStart(TransactionRead);
        
        if (STATUS_SUCCESS != Status)
        {
            goto Error;
        }
        
        SAMTRACE_DS("DirRead");
        
        RetValue = DirRead(&ReadArg, &pReadRes);
        
        SAMTRACE_RETURN_CODE_DS(RetValue);
        
        if (NULL==pReadRes)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = SampMapDsErrorToNTStatus(RetValue, &pReadRes->CommRes);
        }
        
        SampClearErrors();
        
        SampSetDsa(TRUE);
        
        if (NT_SUCCESS(Status))
        {
            AttrsRead = pReadRes->entry.AttrBlock;
            ASSERT(AttrsRead.pAttr);
            
            //
            // Set the value for Lower index, used by next dirread
            //
            LowerLimit = RangeInfoItem.lower + AttrsRead.pAttr->AttrVal.valCount;
            
            if (AttrsRead.pAttr)
            {
                ULONG   Count = 0;
                ULONG   Index;
                ULONG   Rid;
                PSID    MemberSid = NULL;
                DSNAME  * MemberName = NULL;
                
                Count = AttrsRead.pAttr->AttrVal.valCount;
                
                if (ARGUMENT_PRESENT(Members))
                {
                    // 
                    // extend memory to hold more member's RID
                    //
                    TmpMembers = MIDL_user_allocate((*MemberCount + Count) * sizeof(ULONG));
                    
                    if (NULL == TmpMembers)
                    {
                        Status = STATUS_NO_MEMORY;
                        goto Error;
                    }

                    RtlZeroMemory(TmpMembers, (*MemberCount + Count)*sizeof(ULONG));
                    RtlCopyMemory(TmpMembers, (*Members), (*MemberCount)*sizeof(ULONG));
                    
                    if (*Members)
                    {
                        MIDL_user_free(*Members);
                    }
                    
                    *Members = TmpMembers;
                    
                    TmpMembers = NULL; 
                }
                    
                for (Index = 0; Index < Count; Index ++)
                {
                    //
                    // retrieve each member's RID
                    //
                    MemberName = (DSNAME *)AttrsRead.pAttr->AttrVal.pAVal[Index].pVal;
                       
                    if (MemberName->SidLen > 0)
                        MemberSid = &(MemberName->Sid);
                    else
                        MemberSid = SampDsGetObjectSid(MemberName);
                       
                    if (NULL == MemberSid)
                    {
                        // 
                        // Not a Secrutiy Principal, SKip.
                        //
                        continue;
                    }
                        
                    Status = SampSplitSid(MemberSid, NULL, &Rid);
                        
                    if (!NT_SUCCESS(Status))
                        goto Error;
                            
                    if (ARGUMENT_PRESENT(Members))
                    {
                        (*Members)[*MemberCount] = Rid;
                    }
                    
                    (*MemberCount)++;
                }
            }
        }

        //
        // pReadRes->range.pRanges[0].upper == -1 means the last value has been reached.
        //
        if (NT_SUCCESS(Status)) {
            Upper = pReadRes->range.pRanges[0].upper;
        }

        //
        // End the transaction (and thread state) to limit server side resources
        //
        SampMaybeEndDsTransaction(TransactionCommit);
        

    } while (NT_SUCCESS(Status) && (-1 != Upper));
    
    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == Status)
    {
        Status = STATUS_SUCCESS;
    }

    //
    // On success cache the membership of large groups
    //

    if ((NT_SUCCESS(Status)) && (ARGUMENT_PRESENT(Members)))
    {
        NTSTATUS IgnoreStatus;

        IgnoreStatus = SampCacheGroupMembership(
                            GroupRid,
                            *Members,
                            SequenceNum,
                            *MemberCount,
                            SampGroupObjectType
                            );
    }
    
Error:
Exit:

    if (fLockHeld)
    {
        RtlLeaveCriticalSection(&SampDsExpensiveGroupLock);
        fLockHeld = FALSE;
    }
   
    if (!NT_SUCCESS(Status))
    {
        //
        // Set Error Return
        //

        if ((ARGUMENT_PRESENT(Members) ) && (*Members))
        {
            MIDL_user_free(*Members);
            *Members = NULL;
        }
        
        *MemberCount = 0;
    }


    if (NULL!=PrimaryMembers)
    {
        MIDL_user_free(PrimaryMembers);
        PrimaryMembers = NULL;
    }

    return Status;
    
}



NTSTATUS
SampDsGetAliasMembershipList(
    IN DSNAME *AliasName,
    IN ULONG   AliasRid,
    OUT PULONG MemberCount,
    OUT PSID   **Members OPTIONAL
    )
/*++

  Routine Description:

    This Routine Gets a Alias Membership as an array of Sid's as required
    by SAM.
    
    NOTE (by ShaoYin): I modified this routine to query Alias Members 
        in increments rather that as a whole. The reason is: when the
        Alias hosts tons of thousands members, SAM will consume large
        amounts of memory to query members by using single DirRead. 
        After the change, this routine queried Alias Memmbers in a 
        incremental fashion through everything is still in the same 
        transaction. By segmenting read member operation to several 
        DirRead(s), SAM will do better job. 
        
        But because all the DirRead(s) are still in one transaction, 
        actually we do not have much memory gain. 
        
        Probably, the right thing we need to do to relieve memory usage
        is segment the transaction. 
        
        The original code is commented at the end of this routine.

  Arguments

    AliasName -- DSNAME of the concerned Alias object
    Members   -- Array of Rids will be passed in here
    MemberCount -- Count of Sids

  Return Values:
        STATUS_SUCCESS
        STATUS_NO_MEMORY
        Return Codes from DS Layer
--*/

{

    NTSTATUS    Status = STATUS_SUCCESS;
    PSID        * TmpMembers = NULL;
    
    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    COMMARG     * pCommArg = NULL;
    ATTR        MemberAttr;
    ENTINFSEL   EntInf;
    RANGEINFOITEM RangeInfoItem;
    RANGEINFSEL RangeInf;
    DWORD       LowerLimit = 0;
    ULONG       RetValue = 0;
    BOOLEAN     fFoundInCache = FALSE;
    ULONG       SequenceNum = 0;
    LONG        Upper = 0;
    
    //
    // Asserts
    //
    
    ASSERT(MemberCount);
    
    //
    // Initialize Members field
    //
    
    *MemberCount = 0;
    if (ARGUMENT_PRESENT(Members))
        *Members = NULL;

    
    // End existing transaction; as need to evaluate members in 
    // fresh transaction ... the transaction has to be started after
    // the sequence # has been obtained.

    SampMaybeEndDsTransaction(TransactionCommit);

    //
    // Check the cache
    //

    Status = SampGetGroupFromCache(
                AliasRid,
                SampAliasObjectType,
                &fFoundInCache,
                &SequenceNum,
                (PVOID *)Members,
                MemberCount
                );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }

    if (fFoundInCache)
    {
        // we are done nothing more to do
        return(STATUS_SUCCESS);
    }


    //
    // Initialize all arguments
    //
    
    memset(&EntInf,   0, sizeof(ENTINFSEL));
    memset(&RangeInf, 0, sizeof(RANGEINFSEL));
    memset(&ReadArg,  0, sizeof(READARG));
    
    MemberAttr.AttrVal.valCount = 0;
    MemberAttr.AttrVal.pAVal = NULL;
    MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                   SampAliasObjectType, 
                                   SAMP_ALIAS_MEMBERS
                                   );
                                   
    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &MemberAttr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
    
    RangeInfoItem.AttId = MemberAttr.attrTyp;
    RangeInfoItem.lower = LowerLimit;             // 0 is the beginning of values
    RangeInfoItem.upper = -1;                     // -1 means the enf of values;
    
    RangeInf.valueLimit = SAMP_READ_ALIAS_MEMBERS_INCREMENT;
    RangeInf.count = 1;
    RangeInf.pRanges = &RangeInfoItem;             
    
    ReadArg.pObject = AliasName; 
    ReadArg.pSel = &EntInf;
    ReadArg.pSelRange = &RangeInf;
    
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);
    
    do
    {
        ATTRBLOCK   AttrsRead;
        
        RangeInfoItem.lower = LowerLimit;
        
        Status = SampDoImplicitTransactionStart(TransactionRead);
        
        if (STATUS_SUCCESS != Status)
        {
            goto Error;
        }
        
        SAMTRACE_DS("DirRead");
        
        RetValue = DirRead(&ReadArg, &pReadRes);
        
        SAMTRACE_RETURN_CODE_DS(RetValue);
        
        if (NULL == pReadRes)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = SampMapDsErrorToNTStatus(RetValue, &pReadRes->CommRes);
        }
        
        SampClearErrors();
        
        SampSetDsa(TRUE);
        
        if (NT_SUCCESS(Status))
        {
            AttrsRead = pReadRes->entry.AttrBlock;
            ASSERT(AttrsRead.pAttr);
            
            //
            // Re-Set the Lower Index, used by next dirread
            //
            LowerLimit = RangeInfoItem.lower + AttrsRead.pAttr->AttrVal.valCount;
            
            if (AttrsRead.pAttr)
            {
                ULONG   Count;
                ULONG   Index;
                ULONG   TmpIndex;
                ULONG   BufferSize; 
                DSNAME  * MemberName = NULL;
                PSID    MemberSid = NULL;
                NT4SID  * SidArray = NULL;
                
                //
                // Get the Member Count from the nearest DirRead call
                //
                
                Count = AttrsRead.pAttr->AttrVal.valCount;
                
                if (ARGUMENT_P