                m_strName;      // Name of the chord
    TListItem<DMExtendedChord*>*        m_pSubChords;   // List of pointers to subchords of the chord
};

struct DMChordEntry;
struct SearchInfo; 

struct DMChordLink
{
    BOOL                        Walk(SearchInfo *pSearch);

    TListItem<DMChordEntry>*    m_pChord;   // pointer to an entry in the Chord Map list
    DWORD                       m_dwFlags;  // (?) 
    short                       m_nID;  // ID for matching up pointers
    WORD                        m_wWeight;      
    WORD                        m_wMinBeats;
    WORD                        m_wMaxBeats;
};

struct DMChordEntry
{
    TListItem<DMChordLink>* ChooseNextChord();
    BOOL                Walk(SearchInfo *pSearch);

    DWORD               m_dwFlags;      // Flags (first chord in path, last chord in path, etc.)
    short               m_nID;          // ID for matching up pointers
    DMChordData         m_ChordData;    // Chord body
    TList<DMChordLink>  m_Links;        // List of links from this chord
};

struct DMSignPost
{
    DWORD               m_dwChords; // Which kinds of signposts are supported.
    DWORD               m_dwFlags;
    DWORD               m_dwTempFlags;
    DMChordData         m_ChordData;
    DMChordData         m_aCadence[2];
};

struct PlayChord
{
    HRESULT Save(IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig);
    char GetRoot();
    void SetRoot(char chNewRoot);

    DMChordData*                m_pChord;       // Chord to perform.
    TListItem<DMChordLink>*     m_pNext;        // Next chord
    DWORD                       m_dwFlags;
    short                       m_nMeasure;
    short                       m_nBeat;
    short                       m_nMinbeats;
    short                       m_nMaxbeats;
    bool                        m_fSilent;
};

struct FailSearch
{
    FailSearch() : 
        m_nTooManybeats(0), m_nTooFewbeats(0), m_nTooManychords(0), m_nTooFewchords(0)
    {}

    short   m_nTooManybeats;
    short   m_nTooFewbeats;
    short   m_nTooManychords;
    short   m_nTooFewchords;
};

struct SearchInfo 
{
    SearchInfo() : m_pFirstChord(NULL), m_pPlayChord(NULL) {}

    //DMChordEntry              m_Start;
    //DMChordEntry              m_End;
    DMChordData                 m_Start;
    DMChordData                 m_End;
    TListItem<PlayChord>*       m_pPlayChord;
    TListItem<DMChordEntry>*    m_pFirstChord;
    short                       m_nBeats;
    short                       m_nMinBeats;
    short                       m_nMaxBeats;
    short                       m_nChords;
    short                       m_nMinChords;
    short                       m_nMaxChords;
    short                       m_nActivity;
    FailSearch                  m_Fail;
};

struct TemplateCommand
{
    TemplateCommand() : m_nMeasure(0), m_dwChord(0)
    { 
        m_Command.bCommand = m_Command.bGrooveLevel = m_Command.bGrooveRange = 0;
        m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    short           m_nMeasure;    // Which measure
    DMUS_COMMAND_PARAM m_Command;    // Command type
    DWORD           m_dwChord;     // Signpost flags
};

struct CompositionCommand : TemplateCommand
{
    TListItem<DMSignPost>*      m_pSignPost;
    TListItem<DMChordEntry>*    m_pFirstChord;
    TList<PlayChord>            m_PlayList;
    SearchInfo                  m_SearchInfo;
};

/*
@interface IDirectMusicComposer | 
The <i IDirectMusicComposer> interface permits access to the Direct Music composition 
engine which 
composes chord progression to generate section segments. In addition to building new 
section segments from templates and personalities, it can generate transition segments to 
transition between different section segments. And, it can apply a ChordMap to an 
existing section segment to convert the chord progression to match the harmonic behavior 
of the ChordMap, a great way to alter the mood of a section while it plays.

The composition engine uses template segments or predefined shapes to determine the 
structure of the composed section segment and personalities to determine the content of 
the segment.


@base public | IUnknown

@meth HRESULT | ComposeSegmentFromTemplate | Creates an original section segment from a 
style, ChordMap and template.
@meth HRESULT | ComposeSegmentFromShape | Creates an original section segment from a 
style and ChordMap based on a predefined shape. 
@meth HRESULT | ComposeTransition |  Composes a transition from a measure inside one 
Section Segment to another.
@meth HRESULT | AutoTransition | Composes and performs a transition from one
Section Segment to another.
@meth HRESULT | ComposeTemplateFromShape | Allocates and composes a new template segment 
based on a predefined shape.
@meth HRESULT | ChangeChordMap | Modifies the chords and scale pattern of an existing 
section segment to reflect the new ChordMap.

*/

/////////////////////////////////////////////////////////////////////////////
// CDMCompos
class CDMCompos : 
    public IDirectMusicComposer8,
    public IDirectMusicComposer8P
{
friend class CSPstTrk;
public:
    CDMCompos();
    ~CDMCompos();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicComposer
    HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplate(
                    IDirectMusicStyle*          pStyle, 
                    IDirectMusicSegment*        pTempSeg,   
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**       ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeSegmentFromShape(
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wNumMeasures,
                    WORD                        wShape,
                    WORD                        wActivity,
                    BOOL                        fComposeIntro,
                    BOOL                        fComposeEnding,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**       ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeTransition(
                    IDirectMusicSegment*    pFromSeg, 
                    IDirectMusicSegment*    pToSeg,     
                    MUSIC_TIME              mtTime,
                    WORD                    wCommand,
                    DWORD                   dwFlags,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE AutoTransition(
                    IDirectMusicPerformance*    pPerformance,
                    IDirectMusicSegment*    pToSeg,     
                    WORD                    wCommand,
                    DWORD                   dwFlags,
                    IDirectMusicChordMap*   pChordMap,
                    IDirectMusicSegment**   ppTransSeg,
                    IDirectMusicSegmentState**  ppToSegState,
                    IDirectMusicSegmentState**  ppTransSegState
            );

    HRESULT STDMETHODCALLTYPE ComposeTemplateFromShape(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    WORD                    wEndLength,
                    IDirectMusicSegment**   ppTempSeg   
            );

    HRESULT STDMETHODCALLTYPE ChangeChordMap(
                    IDirectMusicSegment*        pSectionSeg,
                    BOOL                        fTrackScale,
                    IDirectMusicChordMap*   pChordMap
            );

    // IDirectMusicComposer8
    HRESULT STDMETHODCALLTYPE ComposeSegmentFromTemplateEx(
                    IDirectMusicStyle*      pStyle, 
                    IDirectMusicSegment*    pTempSeg, 
                    DWORD                   dwFlags, // are we using activity levels?  
                                                     // Are we creating a new seg. or composing into the current one?
                    DWORD                   dwActivity,
                    IDirectMusicChordMap*   pChordMap, 
                    IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT STDMETHODCALLTYPE ComposeTemplateFromShapeEx(
                WORD wNumMeasures,                  // Number of measures in template
                WORD wShape,                        // Shape for composition
                BOOL fIntro,                        // Compose an intro?
                BOOL fEnd,                          // Compose an ending?
                IDirectMusicStyle* pStyle,          // Style used for embellishment lengths
                IDirectMusicSegment** ppTemplate    // Template containing chord and command tracks
            );

protected: // member functions
    void CleanUp();
    void AddChord(DMChordData* pChord);
    TListItem<PlayChord> *AddChord(TList<PlayChord>& rList, DMChordData *pChord, int nMeasure,int nBeat);
    TListItem<PlayChord> *AddCadence(TList<PlayChord>& rList, DMChordData *pChord, int nMax);
    void ChordConnections(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2);
    void ChordConnections2(TList<DMChordEntry>& ChordMap, 
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2);
    void ComposePlayList(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList,
                            WORD wActivity);
    void ComposePlayList2(TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,  
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList);
    HRESULT ComposePlayListFromShape(
                    long                    lNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicStyle*          pStyle, 
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pPersonality,
                    TList<TemplateCommand>& CommandList,
                    TList<PlayChord>&       PlayList
                );
    BOOL Compose(TList<DMChordEntry>& ChordMap, 
                SearchInfo *pSearch, 
                CompositionCommand& rCommand);

    void JostleBack(TList<PlayChord>& rList, TListItem<PlayChord> *pChord, int nBeats);

    BOOL AlignChords(TListItem<PlayChord> *pChord,int nLastbeat,int nRes);

    void ChooseSignPosts(TListItem<DMSignPost> *pSignPostHead,
                            TListItem<CompositionCommand> *pTempCommand, DWORD dwType,
                            bool fSecondPass);

    TListItem<CompositionCommand> *GetNextChord(TListItem<CompositionCommand> *pCommand);

    void FindEarlierSignpost(TListItem<CompositionCommand> *pCommand, 
                         TListItem<CompositionCommand> *pThis,
                         SearchInfo *pSearch);

    void CleanUpBreaks(TList<PlayChord>& PlayList, TListItem<CompositionCommand> *pCommand);

    HRESULT GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern);

    HRESULT GetPersonality(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicChordMap*& rpPers);

    HRESULT ExtractCommandList(TList<TemplateCommand>& CommandList,
                               IDirectMusicTrack*   pSignPostTrack,
                               IDirectMusicTrack*   pCommandTrack,
                               DWORD dwGroupBits);

    HRESULT AddToSegment(IDirectMusicSegment* pTempSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale);

    HRESULT CopySegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicSegment** ppSectionSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           IDirectMusicChordMap* pChordMap,
                           BOOL fStyleFromTrack,
                           BOOL fChordMapFromTrack,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale);

    HRESULT BuildSegment(TList<TemplateCommand>& CommandList,
                            TList<PlayChord>& PlayList, 
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pChordMap,
                            long lMeasures,
                            IDirectMusicSegment** ppSectionSeg,
                            BYTE bRoot, DWORD dwScale, 
                            double* pdblTempo = NULL,
                            IDirectMusicBand* pCurrentBand = NULL,
                            bool fAlign = false,
                            IDirectMusicGraph* pGraph = NULL,
                            IUnknown* pPath = NULL);

    HRESULT SaveChordList( IAARIFFStream* pRIFF,  TList<PlayChord>& rPlayList,
                             BYTE bRoot, DWORD dwScale, DMUS_TIMESIGNATURE& rTimeSig);
    HRESULT TransitionCommon(
                IDirectMusicStyle*      pFromStyle,
                IDirectMusicBand*       pCurrentBand,
                double*                 pdblFromTempo,
                DMUS_COMMAND_PARAM_2&   rFromCommand,
                DMUS_CHORD_PARAM&       rLastChord,
                DMUS_CHORD_PARAM&       rNextChord,

                IDirectMusicSegment*    pToSeg,
                WORD                    wCommand,
                DWORD                   dwFlags,
                IDirectMusicChordMap*   pChordMap,
                IDirectMusicGraph*      pFromGraph,
                IDirectMusicGraph*      pToGraph,
                IUnknown*               pFromPath,
                IUnknown*               pToPath,
                IDirectMusicSegment**   ppSectionSeg
            );

    HRESULT ComposeTemplateFromShapeInternal(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nBreakLength,
                    int                     nFillLength,
                    int                     nEndLength,
                    IDirectMusicSegment**   ppTempSeg
            );

    bool HasDX8Content(IDirectMusicStyle* pFromStyle, 
                    IDirectMusicChordMap* pFromChordMap = NULL, 
                    IDirectMusicSegment* pFromSegment = NULL,
                    DMUS_COMMAND_PARAM_2* pCommand = NULL,
                    DMUS_CHORD_PARAM* pLastChord = NULL)
    {
        // Currently this will return true if the Style is DX8.  Should be sufficient (when called from
        // AutoTransition, at least), since the style is primarily responsible for the way the transition 
        // will sound.
        bool fResult = false;
        IDMStyle* pDMStyle = NULL;
        if (pFromStyle && SUCCEEDED(pFromStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle)))
        {
            if (pDMStyle->IsDX8() == S_OK) fResult = true;
            pDMStyle->Release();
        }
        return fResult;
    }

    bool UsingDX8(IDirectMusicStyle* pFromStyle = NULL, 
                    IDirectMusicChordMap* pFromChordMap = NULL, 
                    IDirectMusicSegment* pFromSegment = NULL,
                    DMUS_COMMAND_PARAM_2* pCommand = NULL,
                    DMUS_CHORD_PARAM* pLastChord = NULL)
    {
        return 
            (m_dwFlags & COMPOSEF_USING_DX8) || 
            HasDX8Content(pFromStyle, pFromChordMap, pFromSegment, pCommand, pLastChord);
    }

    TListItem<DMSignPost>* ChooseSignPost(
            IDirectMusicChordMap* pChordMap,
            DMChordData* pNextChord,
            bool fEnding,
            DWORD dwScale,
            BYTE bRoot);

    HRESULT ComposePlayListFromTemplate(IDirectMusicStyle* pStyle,
                                        IDirectMusicChordMap* pChordMap,
                                        IDirectMusicTrack* pChordMapTrack,
                                        IDirectMusicTrack* pSignPostTrack,
                                        IDirectMusicTrack* pCommandTrack,
                                        DWORD dwGroupBits,
                                        MUSIC_TIME mtLength,
                                        bool fUseActivity,
                                        DWORD dwActivity,
                                        TList<PlayChord>& rPlayList,
                                        BYTE& rbRoot,
                                        DWORD& rdwScale);

    IDirectMusicGraph* CloneSegmentGraph(IDirectMusicSegment* pSegment);
    IUnknown* GetSegmentAudioPath(IDirectMusicSegment* pSegment, DWORD dwFlags, DWORD* pdwAudioPath = NULL);


protected: // attributes
    long m_cRef;
    TListItem<DMChordData*>* m_pChords;
    DWORD                   m_dwFlags;              // variaous flags
    CRITICAL_SECTION        m_CriticalSection;      // for i/o
    BOOL                    m_fCSInitialized;
};

void ChangeCommand(DMUS_COMMAND_PARAM& rResult, DMUS_COMMAND_PARAM& rCommand, int nDirection);

#endif //__DMCOMPOS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmcompp.h ===
//
// DMCompP.H
//
// Private include for DMCompos.DLL
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
//

#ifndef _DMCOMPP_
#define _DMCOMPP_

#define ALL_TRACK_GROUPS 0xffffffff

extern long g_cComponent;

// Class factory
//
class CDirectMusicPersonalityFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicComposerFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicComposerFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicComposerFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicTemplateFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicTemplateFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicTemplateFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicSignPostTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicSignPostTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicSignPostTrackFactory() {} 

private:
    long m_cRef;
};

class CDirectMusicPersonalityTrackFactory : public IClassFactory
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // Interface IClassFactory
    //
    virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
    virtual STDMETHODIMP LockServer(BOOL bLock); 

    // Constructor
    //
    CDirectMusicPersonalityTrackFactory() : m_cRef(1) {}

    // Destructor
    // ~CDirectMusicPersonalityTrackFactory() {} 

private:
    long m_cRef;
};

// private interfaces
interface IDMPers : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality)=0; 
};

interface IDMTempl : IUnknown
{
	virtual HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment)=0;
	virtual HRESULT STDMETHODCALLTYPE Init(void* pTemplate)=0;
};


// private CLSIDs and IIDs (some IIDs should no longer be needed...)
const CLSID CLSID_DMTempl = {0xD30BCC65,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

const IID IID_IDMPers = {0x93BE9414,0x5C4E,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_IDMCompos = {0x6724A8C0,0x60C3,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
const IID IID_IDMTempl = {0xD30BCC64,0x60E8,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};
//const IID IID_ISPstTrk = {0xB65019E0,0x61B6,0x11D1,{0xA7,0xCE,0x00,0xA0,0xC9,0x13,0xF7,0x3C}};

/*
// stuff that will move to dmusici.h

DEFINE_GUID(CLSID_DirectMusicPersonalityTrack, 
	0xf1edefe1, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);

DEFINE_GUID(GUID_PersonalityTrack, 
	0xf1edefe2, 0xae0f, 0x11d1, 0xa7, 0xce, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x3c);
	*/

/*
// stuff that will move to dmusicf.h

// personalities

// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

///*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

///

// Signpost tracks

#define DMUS_FOURCC_SIGNPOST_TRACK_CHUNK	 mmioFOURCC( 's', 'g', 'n', 'p' )


struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

///*

	// <sgnp-list>
	'sgnp'
	(
		//sizeof ioDMSignPost, followed by a number of <ioDMSignPost>
	)

///

// Personality tracks

#define DMUS_FOURCC_PERF_TRACK_LIST mmioFOURCC('p', 'f', 't', 'r')
#define DMUS_FOURCC_PERF_REF_LIST mmioFOURCC('p', 'f', 'r', 'f')
#define DMUS_FOURCC_TIME_STAMP_CHUNK mmioFOURCC('s', 't', 'm', 'p')

///*

	// <pftr-list>
	LIST('pftr'
	(
		// some number of <pfrf-list>
	)

	// <pfrf-list>
	LIST('pfrf'
	(
		<stmp-ck>
		<DMRF>
	)

  // <stmp-ck>
  'stmp'
  (
	// time:DWORD
  )



///

*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmtempl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       dmtempl.h
//
//--------------------------------------------------------------------------

// DMTempl.h : Declaration of the CDMTempl

#ifndef __DMTEMPL_H_
#define __DMTEMPL_H_

#include "DMCompos.h"

struct TemplateStruct
{
	void AddIntro(bool f1Bar, int nLength);
	void AddIntro(TList<PlayChord>& PlayList, int nIntroLength);
	void AddEnd(int nLength);
	void InsertCommand(TListItem<TemplateCommand> *pCommand, BOOL fIsCommand);
	void AddChord(int nMeasure, DWORD dwChord);
	void AddCommand(int nMeasure, DWORD dwCommand);
	void CreateSignPosts();
    void CreateEmbellishments(WORD shape, int nFillLength, int nBreakLength);
	void IncorporateTemplate(short nMeasure, TemplateStruct* pTemplate, short nDirection);
	void FillInGrooveLevels();

	String					m_strName;
	String					m_strType;
	short					m_nMeasures;
	TList<TemplateCommand>	m_CommandList;
};

/////////////////////////////////////////////////////////////////////////////
// CDMTempl
class CDMTempl : 
	public IDMTempl,
	public IPersistStream
{
public:
	CDMTempl();
	~CDMTempl();
	void CleanUp();
	HRESULT SaveCommandList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&	TimeSig );
	HRESULT SaveSignPostList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&	TimeSig );
	HRESULT LoadTemplate( LPSTREAM pStream, DWORD dwSize );
	HRESULT Init(TemplateStruct* pTemplate);

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDMTempl
public:
	HRESULT STDMETHODCALLTYPE CreateSegment(IDirectMusicSegment* pSegment);
	HRESULT STDMETHODCALLTYPE Init(void* pTemplate);

// IPersist
public:
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

// IPersistStream
public:
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

public: // attributes
    long m_cRef;
	BOOL					m_fDirty;				// has this been modified?
    CRITICAL_SECTION		m_CriticalSection;		// for i/o
    BOOL                    m_fCSInitialized;
	TemplateStruct*			m_pTemplateInfo;
};

#endif //__DMTEMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmpers.h ===
// DMPers.h : Declaration of the CDMPers
//
// Copyright (c) 1997-1999 Microsoft Corporation
//
// @doc EXTERNAL
//

#ifndef __DMPERS_H_
#define __DMPERS_H_

#include "dmusici.h"
#include "DMCompos.h"

const short MAX_PALETTE = 24;

struct DMPersonalityStruct
{
	//void ResolveConnections( LPPERSONALITY personality, short nCount );
	bool					m_fLoaded;			// is the personality loaded in memory?
	GUID					m_guid;
	//DWORD					m_dwVersionMS;
	//DWORD					m_dwVersionLS;
	String					m_strName;			// Name of the personality
	//String					m_strCategory;			// Category of the personality
	DWORD					m_dwScalePattern;	// Scale for the personality
	DWORD					m_dwChordMapFlags;			// Flags (?)
	TList<DMChordData>		m_aChordPalette[MAX_PALETTE];	// chord palette
	TList<DMChordEntry>		m_ChordMap;			// Chord map DAG (adjacency list)
	TList<DMSignPost>		m_SignPostList;		// List of sign posts
};

/*
@interface IDirectMusicPersonality | 
The <i IDirectMusicPersonality> interface provides methods for manipulating personalities.
Personalities provide the Composer (<i IDirectMusicComposer>) with the information it 
needs to compose chord progressions, which it uses to build section segments and automatic 
transitions, as wells as to change the chords in an existing segment as it plays.

It also supports the <i IPersistStream> and <i IDirectMusicObject> interfaces for loading 
its data.

@base public | IUnknown

@meth HRESULT | GetScale | Returns the scale of the personality.

*/

/////////////////////////////////////////////////////////////////////////////
// CDMPers
class CDMPers : 
	public IDMPers,
	public IDirectMusicChordMap,
	public IDirectMusicObject,
	public IPersistStream
{
public:
	CDMPers();
	~CDMPers();

    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDMPers
public:
	void CleanUp();
	//HRESULT LoadPersonality( LPSTREAM pStream, DWORD dwSize );
	HRESULT DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  );
	HRESULT DM_LoadPersonality( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain );
	HRESULT DM_LoadSignPost( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB );
	HRESULT DM_LoadChordEntry( 
		IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB, short& nMax );
	HRESULT STDMETHODCALLTYPE GetPersonalityStruct(void** ppPersonality);

// IDirectMusicPersonality
public:
HRESULT STDMETHODCALLTYPE GetScale(DWORD* pdwScale);

//HRESULT STDMETHODCALLTYPE GetName(BSTR* pdwName);

// IDirectMusicObject methods
	HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc) ;
	HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) ;

// IPersist
public:
    STDMETHOD(GetClassID)(THIS_ LPCLSID pclsid);

// IPersistStream
public:
    // Determines if the Style has been modified by simply checking the Style's m_fDirty flag.  This flag is cleared
    // when a Style is saved or has just been created.
    STDMETHOD(IsDirty)(THIS);
    // Loads a Style from a stream.
    STDMETHOD(Load)(THIS_ LPSTREAM pStream);
    // Saves a Style to a stream in RIFF format.
    STDMETHOD(Save)(THIS_ LPSTREAM pStream, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(THIS_ ULARGE_INTEGER FAR* pcbSize);

protected: // attributes
    long m_cRef;
	BOOL					m_fDirty;				// has the style been modified?
    CRITICAL_SECTION		m_CriticalSection;		// for i/o
    BOOL                    m_fCSInitialized;
	DMPersonalityStruct		m_PersonalityInfo;		// The details of the personality
};

#endif //__DMPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmpers.cpp ===
// 
// DMPers.cpp : Implementation of CDMPers
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "DMPers.h"
#include "dmusici.h"

#include "..\shared\validate.h"
#include "..\shared\dmscriptautguids.h"

#include "debug.h"

V_INAME(DMCompose)

/////////////////////////////////////////////////////////////////////////////
// ReadMBSfromWCS

void ReadMBSfromWCS( IStream* pIStream, DWORD dwSize, String& pstrText )
{
    HRESULT     hr = S_OK;
    wchar_t*    wstrText = NULL;
    DWORD       dwBytesRead;
    
    pstrText = "";
    
    wstrText = new wchar_t[dwSize];
    if( wstrText == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERR;
    }

    hr = pIStream->Read( wstrText, dwSize, &dwBytesRead );
    if( FAILED( hr )
    ||  dwBytesRead != dwSize )
    {
        goto ON_ERR;
    }

    pstrText = wstrText;
    
ON_ERR:
    if( wstrText )
        delete [] wstrText;
}

/////////// Utility functions for chords //////////////////

static BYTE setchordbits( long lPattern )
{
LONG    i;
short   count = 0;
BYTE bBits = 0;

    for( i=0L ;  i<32L ;  i++ )
    {
        if( lPattern & (1L << i) )
            count++;
    }
    bBits |= CHORD_INVERT;
    if( count > 3 )
        bBits |= CHORD_FOUR;
    if( lPattern & (15L << 18L) )
        bBits |= CHORD_UPPER;
    bBits &= ~CHORD_COUNT;
    bBits |= count;
    return bBits;
}

// returns TRUE if the chord pattern represents a multichord, FALSE otherwise
inline BOOL MultiChord(DWORD dwPattern)
{
    BYTE bBits = setchordbits( dwPattern );
    short nChordCount = bBits & CHORD_COUNT;
    return !((bBits & CHORD_FOUR && nChordCount <= 4) || 
             (!(bBits & CHORD_FOUR) && nChordCount <= 3));
}

/*
TListItem<DMExtendedChord*>* ConvertChord(
    DWORD dwChordPattern, BYTE bChordRoot, DWORD dwScalePattern, BYTE bScaleRoot)
{ 
    BYTE bBits = setchordbits( dwChordPattern );
    short nChordCount = bBits & CHORD_COUNT;
    // The root of the lower chord is the input chord's root, 
    // relative to the scale root.
    bChordRoot -= bScaleRoot;
    if (bChordRoot < 0) bChordRoot += 12;
    if ((bBits & CHORD_FOUR && nChordCount <= 4) || 
        (!(bBits & CHORD_FOUR) && nChordCount <= 3))
    {
        // single subchord with all info from input chord
        TListItem<DMExtendedChord*>* pSubChord = new TListItem<DMExtendedChord*>;
        if ( pSubChord == NULL ) return NULL;
        DMExtendedChord* pNew = new DMExtendedChord;
        if (!pNew)
        {
            delete pSubChord;
            return NULL;
        }
        DMExtendedChord*& rSubChord = pSubChord->GetItemValue();
        rSubChord = pNew;
        rSubChord->m_dwChordPattern = dwChordPattern;
        rSubChord->m_dwScalePattern = dwScalePattern;
        rSubChord->m_dwInvertPattern = 0xffffff;    // default: inversions everywhere
        rSubChord->m_bRoot = bChordRoot;
        rSubChord->m_bScaleRoot = bScaleRoot;
        rSubChord->m_wCFlags = 0;
        // A single subchord can be used as either a bass or standard chord
        rSubChord->m_dwParts = (1 << SUBCHORD_BASS) | (1 << SUBCHORD_STANDARD_CHORD);
        rSubChord->AddRef();
        return pSubChord;
    }
    else
    {
        // two subchords both with scale and roots from input chord, and:
        // 1st chord: chord pattern from lower n notes of input chord
        // 2nd chord: chord pattern from upper n notes of input chord
        DWORD dwLowerSubChord = 0L;
        DWORD dwUpperSubChord = 0L;
        BYTE bUpperRoot = bChordRoot;
        DWORD dwPattern = dwChordPattern;
        short nIgnoreHigh = (bBits & CHORD_FOUR) ? 4 : 3;
        short nIgnoreLow = (bBits & CHORD_FOUR) ? nChordCount - 4 : nChordCount - 3;
        short nLowestUpper = 0;
        for (short nPos = 0, nCount = 0; nPos < 24; nPos++)
        {
            if (dwPattern & 1)
            {
                if (nCount < nIgnoreHigh)
                {
                    dwLowerSubChord |= 1L << nPos;
                }
                if (nCount >= nIgnoreLow)
                {
                    if (!nLowestUpper)
                    {
                        nLowestUpper = nPos;
                        bUpperRoot = (bUpperRoot + (BYTE) nLowestUpper);
                    }
                    dwUpperSubChord |= 1L << (nPos - nLowestUpper);
                }
                nCount++;
                if (nCount >= nChordCount)
                    break;
            }
            dwPattern >>= 1L;
        }
        // now, create the two subchords.
        TListItem<DMExtendedChord*>* pLowerSubChord = new TListItem<DMExtendedChord*>;
        if ( pLowerSubChord == NULL ) return NULL;
        DMExtendedChord* pLower = new DMExtendedChord;
        if (!pLower)
        {
            delete pLowerSubChord;
            return NULL;
        }
        DMExtendedChord*& rLowerSubChord = pLowerSubChord->GetItemValue();
        rLowerSubChord = pLower;
        rLowerSubChord->m_dwChordPattern = dwLowerSubChord;
        rLowerSubChord->m_dwScalePattern = dwScalePattern;
        rLowerSubChord->m_dwInvertPattern = 0xffffff;   // default: inversions everywhere
        rLowerSubChord->m_bRoot = bChordRoot;
        rLowerSubChord->m_bScaleRoot = bScaleRoot;
        rLowerSubChord->m_wCFlags = 0;
        rLowerSubChord->m_dwParts = (1 << SUBCHORD_BASS); // the lower chord is the bass chord
        TListItem<DMExtendedChord*>* pUpperSubChord = new TListItem<DMExtendedChord*>;
        if ( pUpperSubChord == NULL ) return NULL;
        DMExtendedChord* pUpper = new DMExtendedChord;
        if (!pUpper) 
        {
            delete pUpperSubChord;
            return NULL;
        }
        DMExtendedChord*& rUpperSubChord = pUpperSubChord->GetItemValue();
        rUpperSubChord = pUpper;
        rUpperSubChord->m_dwChordPattern = dwUpperSubChord;
        rUpperSubChord->m_dwScalePattern = dwScalePattern;
        rUpperSubChord->m_dwInvertPattern = 0xffffff;   // default: inversions everywhere
        rUpperSubChord->m_bRoot = bUpperRoot % 24;
        while (rUpperSubChord->m_bRoot < rLowerSubChord->m_bRoot)
            rUpperSubChord->m_bRoot += 12;
        rUpperSubChord->m_bScaleRoot = bScaleRoot;  
        rUpperSubChord->m_wCFlags = 0;
        rUpperSubChord->m_dwParts = (1 << SUBCHORD_STANDARD_CHORD); // the upper chord is the standard chord
        rLowerSubChord->AddRef();
        rUpperSubChord->AddRef();
        return pLowerSubChord->Cat(pUpperSubChord);
    }
}
*/

/////////////////////////////////////////////////////////////////////////////
// CDMPers

CDMPers::CDMPers( ) : m_cRef(1), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;

    m_PersonalityInfo.m_fLoaded = false;
    ZeroMemory(&m_PersonalityInfo.m_guid, sizeof(GUID));
}

CDMPers::~CDMPers()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        ::DeleteCriticalSection( &m_CriticalSection );
    }

    InterlockedDecrement(&g_cComponent);
}

void CDMPers::CleanUp()
{
    m_PersonalityInfo.m_fLoaded = false;
    ZeroMemory(&m_PersonalityInfo.m_guid, sizeof(GUID));
    TListItem<DMChordEntry>* pEntry = m_PersonalityInfo.m_ChordMap.GetHead(); 
    for(; pEntry; pEntry=pEntry->GetNext())
    {
        pEntry->GetItemValue().m_ChordData.Release();
    }
    m_PersonalityInfo.m_ChordMap.CleanUp();
    for (short i = 0; i < 24; i++)
    {
        TListItem<DMChordData>* pData = m_PersonalityInfo.m_aChordPalette[i].GetHead(); 
        for(; pData; pData=pData->GetNext())
        {
            pData->GetItemValue().Release();
        }
        m_PersonalityInfo.m_aChordPalette[i].CleanUp();
    }
    TListItem<DMSignPost>* pSignPost = m_PersonalityInfo.m_SignPostList.GetHead();
    for (; pSignPost != NULL; pSignPost = pSignPost->GetNext())
    {
        DMSignPost& rSignPost = pSignPost->GetItemValue();
        rSignPost.m_ChordData.Release();
        rSignPost.m_aCadence[0].Release();
        rSignPost.m_aCadence[1].Release();
    }
    m_PersonalityInfo.m_SignPostList.CleanUp();
}

STDMETHODIMP CDMPers::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMPers::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicChordMap)
    {
        *ppv = static_cast<IDirectMusicChordMap*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDMPers)
    {
        *ppv = static_cast<IDMPers*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMPers::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMPers::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMPers::GetPersonalityStruct(void** ppPersonality)
{
    if (ppPersonality)
        *ppPersonality = &m_PersonalityInfo;
    return S_OK;
}

HRESULT CDMPers::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    EnterCriticalSection( &m_CriticalSection );
    ZeroMemory(pDesc, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicChordMap;
    if (m_PersonalityInfo.m_fLoaded)
    {
        pDesc->dwValidData |= DMUS_OBJ_LOADED;
    }
    if (m_PersonalityInfo.m_guid.Data1 || m_PersonalityInfo.m_guid.Data2)
    {
        pDesc->dwValidData |= DMUS_OBJ_OBJECT;
        pDesc->guidObject = m_PersonalityInfo.m_guid;
    }
    if (m_PersonalityInfo.m_strName)
    {
        pDesc->dwValidData |= DMUS_OBJ_NAME;
        wcscpy(pDesc->wszName, m_PersonalityInfo.m_strName);
        //MultiByteToWideChar( CP_ACP, 0, m_PersonalityInfo.m_strName, -1, pDesc->wszName, DMUS_MAX_NAME);
    }
    LeaveCriticalSection( &m_CriticalSection );
    return S_OK;
}

HRESULT CDMPers::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::SetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    EnterCriticalSection( &m_CriticalSection );
    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_PersonalityInfo.m_guid = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            m_PersonalityInfo.m_strName = pDesc->wszName;
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2, "WARNING: SetDescriptor (chord map): Descriptor contains fields that were not set.\n");
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CDMPers::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CDMPers::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
//    Prsonality  personality;
//    DWORD       dwSize;
//    FOURCC      id;
    DWORD dwPos;
    HRESULT hr = S_OK;

    dwPos = StreamTell( pStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    hr = AllocRIFFStream( pStream, &pIRiffStream );
    if( SUCCEEDED( hr ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDMAP_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_ParseDescriptor( pIRiffStream, &ckMain, pDesc );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
    }
    else
    {
        return hr;
    }

    if( !fFoundFormat )
    {
        /* Don't try to parse IMA 2.5 format
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
        */
            Trace(1, "ERROR: ParseDescriptor (chord map): File does not contain a valid chord map.\n");
            return DMUS_E_CHUNKNOTFOUND;
        /*
        }
        if( id != mmioFOURCC( 'R', 'E', 'P', 's' ) )
        {
            Trace(1, "ERROR: ParseDescriptor (chord map): File does not contain a valid chord map.\n");
            return DMUS_E_CHUNKNOTFOUND;
        }

        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicChordMap;

        GetMLong( pStream, dwSize );
        if( SUCCEEDED( pStream->Read( &personality, min( sizeof(Prsonality), dwSize ), NULL ) ) )
        {
            MultiByteToWideChar( CP_ACP, 0, personality.name, -1, pDesc->wszName, DMUS_MAX_NAME);
            if (pDesc->wszName[0])
            {
                pDesc->dwValidData |= DMUS_OBJ_NAME;
            }
        }
        */
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPersonality

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicPersonality | GetScale | Retrieves the scale
associated with the personality.

@rdesc Returns:

@flag S_OK | Success.
@flag E_POINTER | <p pdwScale> is not a valid pointer.

@comm The scale is defined by the bits in a DWORD, split into a scale pattern (lower 24 bits)
and a root (upper 8 bits) For the scale pattern, the low bit (0x0001) is the lowest note in the
scale, the next higher (0x0002) is a semitone higher, etc. for two octaves.  The root is
represented as a number between 0 and 23, where 0 represents a low C, 1 represents the
C# above that, etc. for two octaves.

*/
 
HRESULT CDMPers::GetScale(
                    DWORD *pdwScale // @parm The scale value to be returned.
                )
{
    V_PTR_WRITE(pdwScale, sizeof(DWORD) );
    *pdwScale = m_PersonalityInfo.m_dwScalePattern;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CDMPers::GetClassID( LPCLSID pclsid )
{
    if ( pclsid == NULL ) return E_INVALIDARG;
    *pclsid = CLSID_DirectMusicChordMap;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IPersistStream

HRESULT CDMPers::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

HRESULT CDMPers::Save( LPSTREAM /*pStream*/, BOOL /*fClearDirty*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMPers::GetSizeMax( ULARGE_INTEGER FAR* /*pcbSize*/ )
{
    return E_NOTIMPL;
}

HRESULT CDMPers::Load( LPSTREAM pStream )
{
    //FOURCC id;
    //DWORD dwSize;
    DWORD dwPos;
    IAARIFFStream*  pIRiffStream;
    MMCKINFO        ckMain;
    HRESULT hr = E_FAIL;

    if ( pStream == NULL ) return E_INVALIDARG;
    EnterCriticalSection( &m_CriticalSection );
    CleanUp();

    dwPos = StreamTell( pStream );

    BOOL fFoundFormat = FALSE;

    // Check for Direct Music format
    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDMAP_FORM;

        if( pIRiffStream->Descend( &ckMain, NULL, MMIO_FINDRIFF ) == 0 )
        {
            hr = DM_LoadPersonality( pIRiffStream, &ckMain );
            fFoundFormat = TRUE;
        }
        pIRiffStream->Release();
    }

    if( !fFoundFormat )
    {
        /* Don't try to load IMA 2.5 format
        StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
        if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
        */
            Trace(1, "ERROR: Load (chord map): File does not contain a valid chord map.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto end;
        /*
        }
        if( id != mmioFOURCC( 'R', 'E', 'P', 's' ) )
        {
            Trace(1, "ERROR: Load (chord map): File does not contain a valid chord map.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto end;
        }
        hr = LoadPersonality( pStream, dwSize );
        */
    }
end:
    if (SUCCEEDED(hr)) m_PersonalityInfo.m_fLoaded = true;
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

/*
static LPSINEPOST loadasignpost( LPSTREAM pStream, DWORD dwSize )
{
    LPSINEPOST signpost;

    signpost = new SinePost;
    if( signpost == NULL )
    {
        StreamSeek( pStream, dwSize, STREAM_SEEK_CUR );
        return NULL;
    }

    if( dwSize > sizeof(SinePost) )
    {
        pStream->Read( signpost, sizeof(SinePost), NULL );
        FixBytes( FBT_SINEPOST, signpost );
        StreamSeek( pStream, dwSize - sizeof(SinePost), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( signpost, dwSize, NULL );
        FixBytes( FBT_SINEPOST, signpost );
    }
    signpost->pNext = 0;
    signpost->chord.pNext      = 0;
    signpost->cadence[0].pNext = 0;
    signpost->cadence[1].pNext = 0;

    return signpost;
}


static LPNEXTCHRD loadnextchords( LPSTREAM pStream, DWORD dwSiz )
{
    HRESULT hr = S_OK;
    LPNEXTCHRD nextchordlist = NULL;
    LPNEXTCHRD nextchord;
    DWORD      nodesize = 0;
    long lSize = dwSiz;

    if (!GetMLong( pStream, nodesize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return NULL;
    }

    lSize -= 4;

    while( lSize > 0 )
    {
        nextchord = new NextChrd;
        if( nextchord == NULL )
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        if( nodesize > NEXTCHORD_SIZE )
        {
            hr = pStream->Read( &nextchord->dwflags, NEXTCHORD_SIZE, NULL );
            FixBytes( FBT_NEXTCHRD, nextchord );
            StreamSeek( pStream, nodesize - NEXTCHORD_SIZE, STREAM_SEEK_CUR );
        }
        else
        {
            pStream->Read( &nextchord->dwflags, nodesize, NULL );
            FixBytes( FBT_NEXTCHRD, nextchord );
        }
        lSize -= nodesize;

        if (SUCCEEDED(hr))
        {
            nextchord->pNext = 0;
            nextchordlist = List_Cat( nextchordlist, nextchord );
        }
        else 
        {
            delete nextchord;
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }
    }

    return nextchordlist;
}

static LPCHRDENTRY loadachordentry( LPSTREAM pStream, DWORD dwSiz )
{
    LPCHRDENTRY chordentry;
    DWORD       csize = 0;
    DWORD       segsize = 0;
    DWORD       id;
    long lSize = dwSiz;

    chordentry = new ChrdEntry;
    if( chordentry == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return NULL;
    }

    if (!GetMLong( pStream, csize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete chordentry;
        return NULL;
    }
    
    lSize -= 4;
    if( csize > CHORDENTRY_SIZE )
    {
        pStream->Read( &chordentry->chord.time, CHORDENTRY_SIZE, NULL );
        FixBytes( FBT_CHRDENTRY, chordentry );
        StreamSeek( pStream, csize - CHORDENTRY_SIZE, STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( &chordentry->chord.time, csize, NULL );
        FixBytes( FBT_CHRDENTRY, chordentry );
    }
    lSize -= csize;
    chordentry->pNext = 0;
    chordentry->nextchordlist = 0;
    chordentry->chord.pNext    = 0;

    while( lSize > 0 )
    {
        pStream->Read( &id, sizeof(id), NULL );
        if (!GetMLong( pStream, segsize ))
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        lSize   -= 8;

        switch( id )
        {
        case mmioFOURCC( 'L', 'X', 'N', 's' ):
            chordentry->nextchordlist = loadnextchords( pStream, segsize );
            break;
        default:
            StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
            break;
        }

        lSize -= segsize;
    }

    return chordentry;
}

void DMPersonalityStruct::ResolveConnections( LPPERSONALITY personality, short nCount )
{
    LPCHRDENTRY entry;
    LPNEXTCHRD  nextchord;

    if (nCount == 0)
    {
        return;
    }
    // nCount is the largest index, so the array needs to be one more than that
    TListItem<DMChordEntry> **ChordMap = new TListItem<DMChordEntry> *[nCount + 1]; 
    if (!ChordMap) return;

    for( entry=personality->chordlist ;  entry ;  entry=entry->pNext )
    {
        TListItem<DMChordEntry>* pEntry = new TListItem<DMChordEntry>;
        if (!pEntry)
        {
            delete [] ChordMap;
            return;
        }
        DMChordEntry& rEntry = pEntry->GetItemValue();
        rEntry.m_dwFlags = entry->dwflags;
        rEntry.m_ChordData.m_strName = entry->chord.name;
        rEntry.m_ChordData.m_pSubChords = ConvertChord(
            entry->chord.pattern, entry->chord.root, entry->chord.scalepattern, 0);
        m_ChordMap.AddHead(pEntry);
        ChordMap[entry->nid] = pEntry;
        nextchord = entry->nextchordlist;
        for( ;  nextchord ;  nextchord=nextchord->pNext )
        {
            if( nextchord->nid )
            {
                TListItem<DMChordLink>* pLink = new TListItem<DMChordLink>;
                if (!pLink)
                {
                    delete [] ChordMap;
                    return;
                }
                DMChordLink& rLink = pLink->GetItemValue();
                rLink.m_wWeight = nextchord->nweight;       
                rLink.m_wMinBeats = nextchord->nminbeats;
                rLink.m_wMaxBeats = nextchord->nmaxbeats;
                rLink.m_dwFlags = nextchord->dwflags;
                rLink.m_nID = nextchord->nid;
                rEntry.m_Links.AddHead(pLink);
            }
        }
    }

    for(TListItem<DMChordEntry>* pEntry=m_ChordMap.GetHead(); pEntry; pEntry=pEntry->GetNext())
    {
        TListItem<DMChordLink>* pLink = pEntry->GetItemValue().m_Links.GetHead();
        for( ;  pLink ;  pLink = pLink->GetNext() )
        {
            DMChordLink& rLink = pLink->GetItemValue();
            if( rLink.m_nID )
            {
                rLink.m_pChord = ChordMap[rLink.m_nID];
            }
        }
    }
    delete [] ChordMap;
}

HRESULT CDMPers::LoadPersonality( LPSTREAM pStream, DWORD dwSiz )
{
    short         i;
    LPPERSONALITY personality;
    LPCHRDENTRY   chordentry;
    LPSINEPOST    signpost;
    DWORD         csize = 0;
    DWORD         segsize = 0;
    FOURCC        id;
    short         nCount = 0;
    long lSize = dwSiz;
    HRESULT hr = S_OK;

    if ( pStream == NULL ) return E_INVALIDARG;
    personality = new Prsonality;
    if( personality == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }
    if (!GetMLong( pStream, csize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete personality;
        return E_FAIL;
    }

    lSize -= 4;
    if( csize > sizeof(Prsonality) )
    {
        pStream->Read( personality, sizeof(Prsonality), NULL );
        FixBytes( FBT_PRSONALITY, personality );
        StreamSeek( pStream, csize - sizeof(Prsonality), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( personality, csize, NULL );
        FixBytes( FBT_PRSONALITY, personality );
    }
    lSize -= csize;
    m_PersonalityInfo.m_strName = personality->name;
    m_PersonalityInfo.m_dwScalePattern = personality->scalepattern;
    personality->pNext         = NULL;
    personality->dwAA         = 0;
    personality->chordlist    = NULL;
    personality->signpostlist = NULL;
    personality->playlist     = 0;
    personality->firstchord   = NULL;
    for( i=0 ;  i<24 ;  i++ )
    {
        TListItem<DMChordData>* pPaletteEntry = new TListItem<DMChordData>;
        if (!pPaletteEntry)
        {
            hr = E_OUTOFMEMORY;
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }
        DMChordData& rChordData = pPaletteEntry->GetItemValue();
        rChordData.m_strName = personality->chord[i].achName;
        rChordData.m_pSubChords = ConvertChord(
            personality->chord[i].lPattern, personality->chord[i].chRoot, 
            personality->chord[i].lScalePattern, 0);
        m_PersonalityInfo.m_aChordPalette[i].AddTail(pPaletteEntry);
        personality->chord[i].pNext = 0;
    }

    if (SUCCEEDED(hr))
    {
        while( lSize > 0 )
        {
            pStream->Read( &id, sizeof(id), NULL );
            if (!GetMLong( pStream, segsize ))
            {
                StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
                break;
            }

            lSize   -= 8;

            switch( id )
            {
            case mmioFOURCC( 'N', 'E', 'C', 's' ):
                chordentry = loadachordentry( pStream, segsize );
                if( chordentry )
                {
                    personality->chordlist = List_Cat( personality->chordlist, chordentry );
                    if (chordentry->nid > nCount)
                        nCount = chordentry->nid;
                }
                break;

            case mmioFOURCC( 'P', 'N', 'S', 's' ):
                signpost = loadasignpost( pStream, segsize );
                if( signpost )
                {
                    personality->signpostlist = List_Cat( personality->signpostlist, signpost );
                    TListItem<DMSignPost>* pSignPost = new TListItem<DMSignPost>;
                    if (!pSignPost)
                    {
                        hr = E_OUTOFMEMORY;
                        StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
                        break;
                    }
                    DMSignPost& rSignPost = pSignPost->GetItemValue();
                    rSignPost.m_dwChords = signpost->chords;
                    rSignPost.m_dwFlags = signpost->flags;
                    rSignPost.m_dwTempFlags = signpost->tempflags;
                    rSignPost.m_ChordData.m_strName = signpost->chord.name;
                    rSignPost.m_ChordData.m_pSubChords = ConvertChord(
                        signpost->chord.pattern, signpost->chord.root, 
                        signpost->chord.scalepattern, 0);
                    rSignPost.m_aCadence[0].m_strName = signpost->cadence[0].name;
                    rSignPost.m_aCadence[0].m_pSubChords = ConvertChord(
                        signpost->cadence[0].pattern, signpost->cadence[0].root, 
                        signpost->cadence[0].scalepattern, 0);
                    rSignPost.m_aCadence[1].m_strName = signpost->cadence[1].name;
                    rSignPost.m_aCadence[1].m_pSubChords = ConvertChord(
                        signpost->cadence[1].pattern, signpost->cadence[1].root, 
                        signpost->cadence[1].scalepattern, 0);
                    m_PersonalityInfo.m_SignPostList.AddTail(pSignPost);
               }
                break;

            default:
                StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
                break;
            }

            lSize   -= segsize;
        }
    }

    if (SUCCEEDED(hr))
    {
        m_PersonalityInfo.ResolveConnections( personality, nCount );
    }

    // free up all the old format data structures
    LPCHRDENTRY pChord;
    LPNEXTCHRD  pNextChord;
    LPNEXTCHRD  pNextNextChord;
    for( pChord = personality->chordlist ; pChord != NULL ; pChord = pChord->pNext )
    {
        for( pNextChord = pChord->nextchordlist ; pNextChord != NULL ;  pNextChord = pNextNextChord )
        {
            pNextNextChord = pNextChord->pNext;
            delete pNextChord;
        }
    }
    List_Free( personality->chordlist );
    List_Free( personality->signpostlist );
    delete personality;

    return hr;
}
*/

HRESULT CDMPers::DM_ParseDescriptor( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain, LPDMUS_OBJECTDESC pDesc  )
{
    IStream*            pIStream;
    MMCKINFO            ck;
    DWORD               dwByteCount;
    DWORD               dwSize;
    DWORD               dwPos;
    HRESULT             hr = S_OK;
    short nCount = 0;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicChordMap;

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_IOCHORDMAP_CHUNK:
            {
                DMUS_IO_CHORDMAP iPersonality;
                dwSize = min( ck.cksize, sizeof( DMUS_IO_CHORDMAP ) );
                hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: ParseDescriptor (chord map): DMUS_FOURCC_IOCHORDMAP_CHUNK chunk does not contain a valid DMUS_IO_CHORDMAP.\n");
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_END;
                }
                wcscpy(pDesc->wszName, iPersonality.wszLoadName);
                if(pDesc->wszName[0])
                {
                    pDesc->dwValidData |= DMUS_OBJ_NAME;
                    pDesc->wszName[16] = 0;
                }
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &pDesc->guidObject, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: ParseDescriptor (chord map): DMUS_FOURCC_GUID_CHUNK chunk does not contain a valid GUID.\n");
                    hr = DMUS_E_CHUNKNOTFOUND;
                    goto ON_END;

                }
                pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_END:
    pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadPersonality( IAARIFFStream* pIRiffStream, MMCKINFO* pckMain )
{
    IStream*            pIStream;
    MMCKINFO            ck;
    MMCKINFO            ck1;
    MMCKINFO            ckList;
    DWORD               dwByteCount;
    DWORD               dwSize;
    DWORD               dwPos;
    HRESULT             hr = S_OK;
    DMExtendedChord**   apChordDB = NULL;
    short nCount = 0;
    short n;

    pIStream = pIRiffStream->GetStream();
    if ( pIStream == NULL ) return E_FAIL;

    dwPos = StreamTell( pIStream );

    while( pIRiffStream->Descend( &ck, pckMain, 0 ) == 0 )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_IOCHORDMAP_CHUNK:
            {
                DMUS_IO_CHORDMAP iPersonality;
                ZeroMemory(&iPersonality, sizeof(DMUS_IO_CHORDMAP));
                iPersonality.dwScalePattern = 0xffffffff;
                dwSize = min( ck.cksize, sizeof( DMUS_IO_CHORDMAP ) );
                hr = pIStream->Read( &iPersonality, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_IOCHORDMAP_CHUNK chunk does not contain a valid DMUS_IO_CHORDMAP.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_END;
                }
                if( iPersonality.dwFlags & 0xffff0000 )
                {
                    // the scale was not properly initialized
                    Trace(2, "WARNING: Load (chord map): The chord map's flags are not properly initialized; clearing flags.\n");
                    iPersonality.dwFlags = 0;
                }
                if( !(iPersonality.dwFlags & DMUS_CHORDMAPF_VERSION8) && 
                    iPersonality.dwScalePattern >> 24 )
                {
                    // the scale was not properly initialized
                    Trace(1, "ERROR: Load (chord map): The chord map's scale is not properly initialized.\n");
                    hr = DMUS_E_NOT_INIT;
                    goto ON_END;
                }
                m_PersonalityInfo.m_strName = iPersonality.wszLoadName;
                m_PersonalityInfo.m_dwScalePattern = iPersonality.dwScalePattern;
                m_PersonalityInfo.m_dwChordMapFlags = iPersonality.dwFlags;
                break;
            }

            case DMUS_FOURCC_GUID_CHUNK:
                dwSize = min( ck.cksize, sizeof( GUID ) );
                hr = pIStream->Read( &m_PersonalityInfo.m_guid, dwSize, &dwByteCount );
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_GUID_CHUNK chunk does not contain a valid GUID.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_END;
                }
                break;

            case DMUS_FOURCC_SUBCHORD_CHUNK:
            {
                long lFileSize = ck.cksize;
                WORD wSize;
                DWORD cb;
                hr = pIStream->Read( &wSize, sizeof( wSize ), &cb );
                if (FAILED(hr) || cb != sizeof( wSize ) ) 
                {
                    Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_SUBCHORD_CHUNK chunk does not contain a valid size DWORD.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                lFileSize -= cb;
                TList<DMExtendedChord*> ChordList;
                while (lFileSize > 0)
                {
                    DMUS_IO_PERS_SUBCHORD iSubChord;
                    hr = pIStream->Read( &iSubChord, wSize, &cb );
                    if (FAILED(hr) || cb !=  wSize ) 
                    {
                        Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_SUBCHORD_CHUNK chunk does not contain a valid DMUS_IO_PERS_SUBCHORD.\n");
                        if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    // stuff the data into a subchord struct and add it to the chord list
                    // (in reverse order)
                    TListItem<DMExtendedChord*>* pChordItem = new TListItem<DMExtendedChord*>;
                    if (pChordItem)
                    {
                        DMExtendedChord*& rpChord = pChordItem->GetItemValue();
                        rpChord = new DMExtendedChord;
                        if (rpChord)
                        {
                            rpChord->m_dwChordPattern = iSubChord.dwChordPattern;
                            rpChord->m_dwScalePattern = iSubChord.dwScalePattern;
                            rpChord->m_dwInvertPattern = iSubChord.dwInvertPattern;
                            rpChord->m_bRoot = iSubChord.bChordRoot;
                            rpChord->m_bScaleRoot = iSubChord.bScaleRoot;
                            rpChord->m_wCFlags = iSubChord.wCFlags;
                            rpChord->m_dwParts = iSubChord.dwLevels;
                            nCount++;
                            ChordList.AddHead(pChordItem);
                        }
                        else
                        {
                            delete pChordItem;
                            pChordItem = NULL;
                        }
                    }
                    if (!pChordItem)
                    {
                        hr = E_OUTOFMEMORY;
                        goto ON_END;
                    }
                    lFileSize -= wSize;
                }
                if (lFileSize != 0 )
                {
                    hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                // now that the chord list is complete, transfer the pointers into the
                // chord db (back to front to reinstate original order)
                apChordDB = new DMExtendedChord*[nCount];
                if (apChordDB)
                {
                    TListItem<DMExtendedChord*>* pScan = ChordList.GetHead();
                    for (n = nCount - 1; n >= 0; n--)
                    {
                        apChordDB[n] = pScan->GetItemValue();
                        pScan = pScan->GetNext();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                break;
            }
            case FOURCC_LIST:
                ck1 = ck;
                ckList = ck;
                switch( ck1.fccType )
                {
                case DMUS_FOURCC_CHORDPALETTE_LIST:
                    for( n = 0; pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 && n < 24; n++ )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_CHORD_LIST )
                        {
                            TListItem<DMChordData>* pChordData = new TListItem<DMChordData>;
                            if (pChordData)
                            {
                                m_PersonalityInfo.m_aChordPalette[n].AddHead(pChordData);
                                hr = pChordData->GetItemValue().Read(pIRiffStream, &ck1, apChordDB);
                            }
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                        dwPos = StreamTell( pIStream );
                    }
                    break;
                case DMUS_FOURCC_CHORDMAP_LIST:
                {
                    short nMapMax = 0;
                    while ( pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_CHORDENTRY_LIST )
                        {
                            DM_LoadChordEntry(pIRiffStream, &ck1, apChordDB, nMapMax);
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                        dwPos = StreamTell( pIStream );
                    }
                    TListItem<DMChordEntry>** aChordArray = new TListItem<DMChordEntry>*[nMapMax + 1];
                    if (!aChordArray)
                    {
                        hr = E_OUTOFMEMORY;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    TListItem<DMChordEntry>* pScan = m_PersonalityInfo.m_ChordMap.GetHead();
                    for(; pScan; pScan = pScan->GetNext())
                    {
                        if (pScan->GetItemValue().m_nID < 0 || pScan->GetItemValue().m_nID > nMapMax)
                        {
                            // the connection id was not properly initialized
                            Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_CHORDMAP_LIST chunk contains an improperly initialized connection ID.\n");
                            hr = DMUS_E_NOT_INIT;
                            pIRiffStream->Ascend( &ck, 0 );
                            delete [] aChordArray;
                            goto ON_END;
                        }
                        aChordArray[pScan->GetItemValue().m_nID] = pScan;
                    }
                    pScan = m_PersonalityInfo.m_ChordMap.GetHead();
                    for (; pScan; pScan = pScan->GetNext())
                    {
                        TListItem<DMChordLink>* pLink = pScan->GetItemValue().m_Links.GetHead();
                        for (; pLink; pLink = pLink->GetNext())
                        {
                            DMChordLink& rLink = pLink->GetItemValue();
                            if (rLink.m_nID < 0 || rLink.m_nID > nMapMax)
                            {
                                // the connection id was not properly initialized
                                Trace(1, "ERROR: Load (chord map): DMUS_FOURCC_CHORDMAP_LIST chunk contains an improperly initialized connection ID.\n");
                                hr = DMUS_E_NOT_INIT;
                                pIRiffStream->Ascend( &ck, 0 );
                                delete [] aChordArray;
                                goto ON_END;
                            }
                            rLink.m_pChord = aChordArray[rLink.m_nID];
                        }
                    }
                    delete [] aChordArray;
                    break;
                }
                    
                case DMUS_FOURCC_SIGNPOST_LIST:
                    while ( pIRiffStream->Descend( &ck1, &ckList, 0 ) == 0 )
                    {
                        if ( ck1.ckid == FOURCC_LIST && ck1.fccType == DMUS_FOURCC_SIGNPOSTITEM_LIST )
                        {
                            DM_LoadSignPost(pIRiffStream, &ck1, apChordDB);
                        }
                        pIRiffStream->Ascend( &ck1, 0 );
                        dwPos = StreamTell( pIStream );
                    }
                    break;

                }
                break;
        }

        pIRiffStream->Ascend( &ck, 0 );
        dwPos = StreamTell( pIStream );
    }

ON_END:
    if (apChordDB) delete [] apChordDB;
    pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadChordEntry( 
    IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB, short& nMax )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    WORD wConnectionID = 0;

    TListItem<DMChordEntry>* pChordEntry = new TListItem<DMChordEntry>;
    if (!pChordEntry) return E_OUTOFMEMORY;
    DMChordEntry& rChordEntry = pChordEntry->GetItemValue();
    rChordEntry.m_ChordData.m_strName = "";
    m_PersonalityInfo.m_ChordMap.AddHead(pChordEntry);
    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
    {
        switch(ck.ckid)
        {
        case DMUS_FOURCC_CHORDENTRY_CHUNK:
            {
                DMUS_IO_CHORDENTRY iChordEntry;
                DWORD cb;
                hr = pIStream->Read( &iChordEntry, sizeof(iChordEntry), &cb );
                if (FAILED(hr) || cb !=  sizeof(iChordEntry) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rChordEntry.m_dwFlags = iChordEntry.dwFlags;
                rChordEntry.m_nID = iChordEntry.wConnectionID;
                if (rChordEntry.m_nID > nMax) nMax = rChordEntry.m_nID;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_CHORD_LIST)
            {
                hr = rChordEntry.m_ChordData.Read(pIRiffStream, &ck, apChordDB);
            }
            break;
        case DMUS_FOURCC_NEXTCHORDSEQ_CHUNK:
            {
                long lFileSize = ck.cksize;
                WORD wSize;
                DWORD cb;
                hr = pIStream->Read( &wSize, sizeof( wSize ), &cb );
                if (FAILED(hr) || cb != sizeof( wSize ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                lFileSize -= cb;
                while (lFileSize > 0)
                {
                    DMUS_IO_NEXTCHORD iNextChord;
                    hr = pIStream->Read( &iNextChord, wSize, &cb );
                    if (FAILED(hr) || cb !=  wSize ) 
                    {
                        if (SUCCEEDED(hr)) hr = E_FAIL;
                        pIRiffStream->Ascend( &ck, 0 );
                        goto ON_END;
                    }
                    if (iNextChord.wConnectionID)
                    {
                        TListItem<DMChordLink>* pItem = new TListItem<DMChordLink>;
                        if (!pItem ) 
                        {
                            hr = E_OUTOFMEMORY;
                            pIRiffStream->Ascend( &ck, 0 );
                            goto ON_END;
                        }
                        DMChordLink& rLink = pItem->GetItemValue();
                        rLink.m_dwFlags = iNextChord.dwFlags;
                        rLink.m_nID = iNextChord.wConnectionID;
                        rLink.m_wWeight = iNextChord.nWeight;
                        rLink.m_wMinBeats = iNextChord.wMinBeats;
                        rLink.m_wMaxBeats = iNextChord.wMaxBeats;
                        rChordEntry.m_Links.AddHead(pItem);
                    }
                    lFileSize -= wSize;
                }
                if (lFileSize != 0 )
                {
                    hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
            }
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
ON_END:
    if (pIStream) pIStream->Release();
    return hr;
}

HRESULT CDMPers::DM_LoadSignPost( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    TListItem<DMSignPost>* pSignPost = new TListItem<DMSignPost>;
    if (!pSignPost) return E_OUTOFMEMORY;
    DMSignPost& rSignPost = pSignPost->GetItemValue();
    m_PersonalityInfo.m_SignPostList.AddTail(pSignPost);
    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0 && hr == S_OK)
    {
        switch(ck.ckid)
        {
        case DMUS_FOURCC_IOSIGNPOST_CHUNK:
            {
                DMUS_IO_PERS_SIGNPOST iSignPost;
                DWORD cb;
                hr = pIStream->Read( &iSignPost, sizeof(iSignPost), &cb );
                if (FAILED(hr) || cb !=  sizeof(iSignPost) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rSignPost.m_dwChords = iSignPost.dwChords;
                rSignPost.m_dwFlags = iSignPost.dwFlags;
            }
            break;
        case FOURCC_LIST:
            switch(ck.fccType)
            {
            case DMUS_FOURCC_CHORD_LIST:
                hr = rSignPost.m_ChordData.Read(pIRiffStream, &ck, apChordDB);
                break;
            case DMUS_FOURCC_CADENCE_LIST:
                {
                    MMCKINFO ckCadence = ck;
                    MMCKINFO ck1 = ck;
                    for (short n = 0;
                         pIRiffStream->Descend(&ck1, &ckCadence, 0) == 0 && hr == S_OK && n < 2;
                        n++)
                    {
                        if (ck1.fccType == DMUS_FOURCC_CHORD_LIST)
                        {
                            short n2 = n;
                            if ( !(rSignPost.m_dwFlags & DMUS_SPOSTCADENCEF_1) &&
                                 (rSignPost.m_dwFlags & DMUS_SPOSTCADENCEF_2) )
                            {
                                // if all we have is cadence 2, put it in location 1
                                n2 = 1;
                            }
                            hr = rSignPost.m_aCadence[n2].Read(pIRiffStream, &ck1, apChordDB);
                        }
                        pIRiffStream->Ascend(&ck1, 0);
                    }
                }
                break;
            }
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
ON_END:
    if (pIStream) pIStream->Release();
    return hr;
}

HRESULT DMChordData::Read(
    IAARIFFStream* pIRiffStream, MMCKINFO* pckParent, DMExtendedChord** apChordDB)
{
    HRESULT hr1 = E_FAIL, hr2 = E_FAIL;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    if (!apChordDB) return E_POINTER;
    MMCKINFO ck;
    wchar_t wzName[12];
    WORD awSubIds[4];

    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;

    while(pIRiffStream->Descend(&ck, pckParent, 0) == 0)
    {
        TListItem<DMExtendedChord*>* pChord = NULL;
        switch(ck.ckid)
        {
        case DMUS_FOURCC_CHORDNAME_CHUNK:
            hr1 = pIStream->Read(wzName, sizeof(wzName), 0);
            if (SUCCEEDED(hr1)) m_strName = wzName;
            break;
        case DMUS_FOURCC_SUBCHORDID_CHUNK:
            hr2 = pIStream->Read(awSubIds, sizeof(awSubIds), 0);
            // now use the ids to set up pointers to subchords
            if (m_pSubChords) Release();
            pChord = new TListItem<DMExtendedChord*>(apChordDB[awSubIds[3]]);
            if (pChord)
            {
                pChord->GetItemValue()->AddRef();
                for (short n = 2; n >= 0; n--)
                {
                    TListItem<DMExtendedChord*>* pNew = new TListItem<DMExtendedChord*>(apChordDB[awSubIds[n]]);
                    if (pNew)
                    {
                        pNew->GetItemValue()->AddRef();
                        pNew->SetNext(pChord);
                        pChord = pNew;
                    }
                }
            }
            m_pSubChords = pChord;
            break;
        }
        pIRiffStream->Ascend(&ck, 0);
    }
    pIStream->Release();
    return (hr1 == S_OK && hr2 == S_OK) ? S_OK : E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmcompos.cpp ===
//
// DMCompos.cpp : Implementation of CDMCompos
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include <time.h>   // to seed random number generator
#include "DMCompos.h"
#include "debug.h"
#include "DMPers.h"
#include "DMTempl.h"

#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\iostru.h"
#include "..\dmime\dmgraph.h"

#include "..\shared\Validate.h"
#include "debug.h"

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;
// default chord is major 7
const DWORD DEFAULT_CHORD_PATTERN = 0x891;

BOOL Less(TemplateCommand& TC1, TemplateCommand& TC2)
{
    return TC1.m_nMeasure < TC2.m_nMeasure;
}

BOOL Less(PlayChord& PC1, PlayChord& PC2)
{
    return PC1.m_nMeasure < PC2.m_nMeasure ||
           (PC1.m_nMeasure == PC2.m_nMeasure && PC1.m_nBeat < PC2.m_nBeat);
}

static void Free(TListItem<DMExtendedChord*>*& pSubChord)
{
    TListItem<DMExtendedChord*> *pScan = pSubChord;
    for (; pScan; pScan = pScan->GetNext())
    {
        pScan->GetItemValue()->Release();
        pScan->GetItemValue() = NULL;
    }
    TListItem<DMExtendedChord*>::Delete(pSubChord);
    pSubChord = NULL;
}

TListItem<DMExtendedChord*>* Copy(TListItem<DMExtendedChord*>* pChord)
{
    if (!pChord) return NULL;
    TListItem<DMExtendedChord*>* pNext = new TListItem<DMExtendedChord*>;
    if (pNext)
    {
        DMExtendedChord* pNew = new DMExtendedChord;
        if (pNew)
        {
            DMExtendedChord*& rChord = pChord->GetItemValue();
            DMExtendedChord*& rNext = pNext->GetItemValue();
            rNext = pNew;
            rNext->m_dwChordPattern = rChord->m_dwChordPattern;
            rNext->m_dwScalePattern = rChord->m_dwScalePattern;
            rNext->m_dwInvertPattern = rChord->m_dwInvertPattern;
            rNext->m_bRoot = rChord->m_bRoot;
            rNext->m_bScaleRoot = rChord->m_bScaleRoot;
            rNext->m_wCFlags = rChord->m_wCFlags;
            rNext->m_dwParts = rChord->m_dwParts;
            rNext->m_nRefCount = 1;
            pNext->SetNext(Copy(pChord->GetNext()));
        }
        else
        {
            delete pNext;
            pNext = NULL;
        }
    }
    return pNext;
}

DMChordData::DMChordData(DMChordData& rChordData)
{
    m_strName = rChordData.m_strName;
    m_pSubChords = Copy(rChordData.m_pSubChords);
}

DMChordData::DMChordData(DMUS_CHORD_PARAM& DMC)
{
    m_strName = DMC.wszName;
    m_pSubChords = NULL;
    for (BYTE n = 0; n < DMC.bSubChordCount; n++)
    {
        TListItem<DMExtendedChord*>* pSub = new TListItem<DMExtendedChord*>;
        if( pSub )
        {
            DMExtendedChord* pNew = new DMExtendedChord;
            if (pNew)
            {
                memset( pNew, 0, sizeof( *pNew) );
                DMExtendedChord*& rSubChord = pSub->GetItemValue();
                rSubChord = pNew;
                rSubChord->AddRef();
                rSubChord->m_dwChordPattern = DMC.SubChordList[n].dwChordPattern;
                rSubChord->m_dwScalePattern = DMC.SubChordList[n].dwScalePattern;
                rSubChord->m_dwInvertPattern = DMC.SubChordList[n].dwInversionPoints;
                rSubChord->m_dwParts = DMC.SubChordList[n].dwLevels;
                rSubChord->m_bRoot = DMC.SubChordList[n].bChordRoot;
                rSubChord->m_bScaleRoot = DMC.SubChordList[n].bScaleRoot;
                m_pSubChords = m_pSubChords->Cat(pSub);
            }
            else
            {
                delete pSub;
                // no need continuing in the loop if we ran out of memory
                break;
            }
        }
    }
}

// At the moment, this assumes that the pattern of the chord is the pattern of the
// first subchord in the chord's subchord list.
DWORD DMChordData::GetChordPattern()
{
    if (m_pSubChords)
    {
        return m_pSubChords->GetItemValue()->m_dwChordPattern;
    }
    else return 0;
}

// At the moment, this assumes that the root of the chord is the root of the
// first subchord in the chord's subchord list.
char DMChordData::GetRoot()
{
    if (m_pSubChords)
    {
        return m_pSubChords->GetItemValue()->m_bRoot;
    }
    else return 0;
}

// At the moment, this assumes that the root of the chord is the root of the
// first subchord in the chord's subchord list.
void DMChordData::SetRoot(char chNewRoot)
{
    if (m_pSubChords)
    {
        m_pSubChords->GetItemValue()->m_bRoot = chNewRoot;
    }
}


void DMChordData::Release()
{
    Free(m_pSubChords);
}

// Two chords are equal if they have the same number of subchords and each
// corresponding subchord is equal
BOOL DMChordData::Equals(DMChordData& rhsChord)
{
    TListItem<DMExtendedChord*> *pLeft = m_pSubChords;
    TListItem<DMExtendedChord*> *pRight = rhsChord.m_pSubChords;
    for(; pLeft; pLeft = pLeft->GetNext(), pRight = pRight->GetNext())
    {
        if (pRight == NULL || !pLeft->GetItemValue()->Equals(*pRight->GetItemValue()))
            return FALSE;
    }
    return pRight == NULL;
}


BOOL DMExtendedChord::Equals(DMExtendedChord& rhsChord)
{
    char a = m_bRoot;
    char b = rhsChord.m_bRoot;
    while (a > 11) a -= 12;
    while (b > 11) b -= 12;
    return ((m_dwChordPattern == rhsChord.m_dwChordPattern) && (a == b));
}

BOOL DMChordLink::Walk(SearchInfo *pSearch)
{
    BOOL fResult = FALSE;
    if (m_pChord)
    {
        pSearch->m_nMinBeats = (short)( pSearch->m_nMinBeats + m_wMinBeats );
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + m_wMaxBeats );
        pSearch->m_nChords++;
        fResult = m_pChord->GetItemValue().Walk(pSearch);
        pSearch->m_nChords--;
        pSearch->m_nMinBeats = (short)( pSearch->m_nMinBeats - m_wMinBeats );
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats - m_wMaxBeats );
    }
    return(fResult);
}

TListItem<DMChordLink> *DMChordEntry::ChooseNextChord()

{
    int total = 0;
    int choice;
    TListItem<DMChordLink> *pNext = m_Links.GetHead();
    for (; pNext; pNext = pNext->GetNext())
    {
        if (!(pNext->GetItemValue().m_dwFlags & NC_NOPATH))
        {
            if (pNext->GetItemValue().m_pChord) total += pNext->GetItemValue().m_wWeight;
        }
    }
    if (!total) return(NULL);
    choice = rand() % total;
    pNext = m_Links.GetHead();
    for (; pNext; pNext = pNext->GetNext())
    {
        if (!(pNext->GetItemValue().m_dwFlags & NC_NOPATH))
        {
            if (pNext->GetItemValue().m_pChord) choice -= pNext->GetItemValue().m_wWeight;
            if (choice < 0) return(pNext);
        }
    }
    return(NULL);
}

BOOL DMChordEntry::Walk(SearchInfo *pSearch)
{
    TListItem<DMChordLink> *pNext = m_Links.GetHead();
    if (pSearch->m_nChords > pSearch->m_nMaxChords)
    {
        pSearch->m_Fail.m_nTooManychords++;
        return (FALSE);
    }
    for (; pNext; pNext = pNext->GetNext())
    {
        pNext->GetItemValue().m_dwFlags &= ~(NC_PATH | NC_NOPATH);
    }
    if ((m_dwFlags & CE_END) && (m_ChordData.Equals(pSearch->m_End)))
    {
        if (pSearch->m_nChords >= pSearch->m_nMinChords)
        {
            if (pSearch->m_nBeats <= pSearch->m_nMaxBeats)
            {
                if (pSearch->m_nBeats >= pSearch->m_nMinBeats)
                {
                    m_dwFlags |= CE_PATH;
                    return(TRUE);
                }
                else pSearch->m_Fail.m_nTooManybeats++;
            }
            else pSearch->m_Fail.m_nTooFewbeats++;
        }
        else
        {
            pSearch->m_Fail.m_nTooFewchords++;
        }
    }
    m_dwFlags &= ~CE_PATH;
    if (pSearch->m_pPlayChord)
    {
        pSearch->m_pPlayChord = pSearch->m_pPlayChord->GetNext();
    }
    if (pSearch->m_pPlayChord)
    {
        TListItem<PlayChord> *pPlay = pSearch->m_pPlayChord;
        if (pPlay->GetItemValue().m_pChord)
        {
            pNext = pPlay->GetItemValue().m_pNext;
            if (pNext)
            {
                if (pNext->GetItemValue().Walk(pSearch))
                {
                    pNext->GetItemValue().m_dwFlags |= NC_PATH;
                    m_dwFlags |= CE_PATH;
                    return(TRUE);
                }
                else
                {
                    pNext->GetItemValue().m_dwFlags |= NC_NOPATH;
                    pSearch->m_pPlayChord = NULL;
                }
            }
        }
    }
    while( ( pNext = ChooseNextChord() ) != NULL )
    {
        if (pNext->GetItemValue().Walk(pSearch))
        {
            pNext->GetItemValue().m_dwFlags |= NC_PATH;
            m_dwFlags |= CE_PATH;
            return(TRUE);
        }
        else
        {
            pNext->GetItemValue().m_dwFlags |= NC_NOPATH;
        }
    }
    return (FALSE);
}

#define MAX_CHORD_NAME 16

HRESULT PlayChord::Save( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig )
{
    IStream*    pStream;
    MMCKINFO    ck;
    DWORD       cb;
    DMUS_IO_CHORD   iChord;
    DMUS_IO_SUBCHORD    iSubChord;
    DWORD        dwSize;
    HRESULT hr = E_FAIL;

    if ( !m_pChord || !m_pChord->m_pSubChords )
    {
        Trace(1, "ERROR: Attempt to save an empty chord list.\n");
        return E_FAIL;
    }
    pStream = pRIFF->GetStream();
    ck.ckid = mmioFOURCC('c','r','d','b');
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        memset( &iChord, 0, sizeof( iChord ) );
        if (m_pChord->m_strName)
        {
            wcsncpy( iChord.wszName, m_pChord->m_strName, MAX_CHORD_NAME );
            iChord.wszName[MAX_CHORD_NAME - 1] = 0;
        }
        iChord.mtTime = ClocksPerBeat(rTimeSig) * m_nBeat + ClocksPerMeasure(rTimeSig) * m_nMeasure;
        iChord.wMeasure = m_nMeasure;
        iChord.bBeat = (BYTE)m_nBeat;
        iChord.bFlags = 0;
        if (m_fSilent) iChord.bFlags |= DMUS_CHORDKEYF_SILENT;
        dwSize = sizeof( iChord );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( SUCCEEDED(hr) &&
            SUCCEEDED( pStream->Write( &iChord, sizeof( iChord), &cb ) ) &&
            cb == sizeof( iChord) )
        {
            {
                DWORD dwCount = (WORD) m_pChord->m_pSubChords->GetCount();
                hr = pStream->Write( &dwCount, sizeof( dwCount ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                dwSize = sizeof( iSubChord );
                hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
                if( FAILED( hr ) || cb != sizeof( dwSize ) )
                {
                    pStream->Release();
                    return E_FAIL;
                }
                for (TListItem<DMExtendedChord*>* pSub = m_pChord->m_pSubChords; pSub != NULL; pSub = pSub->GetNext())
                {
                    DMExtendedChord*& rSubChord = pSub->GetItemValue();
                    memset( &iSubChord, 0, sizeof( iSubChord ) );
                    iSubChord.dwChordPattern = rSubChord->m_dwChordPattern;
                    iSubChord.dwScalePattern = rSubChord->m_dwScalePattern;
                    iSubChord.dwInversionPoints = rSubChord->m_dwInvertPattern;
                    iSubChord.dwLevels = rSubChord->m_dwParts;
                    iSubChord.bChordRoot = rSubChord->m_bRoot;
                    iSubChord.bScaleRoot = rSubChord->m_bScaleRoot;
                    if( FAILED( pStream->Write( &iSubChord, sizeof( iSubChord ), &cb ) ) ||
                        cb != sizeof( iSubChord ) )
                    {
                        break;
                    }
                }
                // ascend from chord body chunk
                if( pSub == NULL &&
                    pRIFF->Ascend( &ck, 0 ) != 0 )
                {
                    hr = S_OK;
                }
            }
        }
    }
    pStream->Release();
    return hr;
}

char PlayChord::GetRoot()
{
    if (m_pChord)
    {
        return m_pChord->GetRoot();
    }
    else return 0;
}

void PlayChord::SetRoot(char chNewRoot)
{
    if (m_pChord)
    {
        m_pChord->SetRoot(chNewRoot);
    }
}



HRESULT LoadChordChunk(LPSTREAM pStream, PlayChord& rChord)
{
    DWORD           dwChordSize;
    DWORD           dwSubChordSize;
    DWORD           dwSubChordCount;
    DWORD           cb;
    HRESULT         hr;
    DMUS_IO_CHORD       iChord;
    DMUS_IO_SUBCHORD    iSubChord;

    memset(&iChord , 0, sizeof(iChord));
    memset(&iSubChord , 0, sizeof(iSubChord));

    hr = pStream->Read( &dwChordSize, sizeof( dwChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwChordSize ) )
    {
        return E_FAIL;
    }
    if( dwChordSize <= sizeof( DMUS_IO_CHORD ) )
    {
        pStream->Read( &iChord, dwChordSize, NULL );
    }
    else
    {
        pStream->Read( &iChord, sizeof( DMUS_IO_CHORD ), NULL );
        StreamSeek( pStream, dwChordSize - sizeof( DMUS_IO_CHORD ), STREAM_SEEK_CUR );
    }
    memset( &rChord, 0, sizeof( rChord) );
    rChord.m_nMeasure = iChord.wMeasure;
    rChord.m_nBeat = iChord.bBeat;
    rChord.m_fSilent = (iChord.bFlags & DMUS_CHORDKEYF_SILENT) ? true : false;
    rChord.m_pChord = new DMChordData;
    if (!rChord.m_pChord) return E_OUTOFMEMORY;
    rChord.m_pChord->m_strName = iChord.wszName;
    rChord.m_pChord->m_pSubChords = NULL;
    hr = pStream->Read( &dwSubChordCount, sizeof( dwSubChordCount ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordCount ) )
    {
        return E_FAIL;
    }
    hr = pStream->Read( &dwSubChordSize, sizeof( dwSubChordSize ), &cb );
    if (FAILED(hr) || cb != sizeof( dwSubChordSize ) )
    {
        return E_FAIL;
    }
    for (; dwSubChordCount > 0; dwSubChordCount--)
    {
        if( dwSubChordSize <= sizeof( DMUS_IO_SUBCHORD ) )
        {
            pStream->Read( &iSubChord, dwSubChordSize, NULL );
        }
        else
        {
            pStream->Read( &iSubChord, sizeof( DMUS_IO_SUBCHORD ), NULL );
            StreamSeek( pStream, dwSubChordSize - sizeof( DMUS_IO_SUBCHORD ), STREAM_SEEK_CUR );
        }
        TListItem<DMExtendedChord*>* pSub = new TListItem<DMExtendedChord*>;
        if( pSub )
        {
            DMExtendedChord* pNew = new DMExtendedChord;
            if (pNew)
            {
                memset( pNew, 0, sizeof( *pNew) );
                DMExtendedChord*& rSubChord = pSub->GetItemValue();
                rSubChord = pNew;
                rSubChord->AddRef();
                rSubChord->m_dwChordPattern = iSubChord.dwChordPattern;
                rSubChord->m_dwScalePattern = iSubChord.dwScalePattern;
                rSubChord->m_dwInvertPattern = iSubChord.dwInversionPoints;
                rSubChord->m_dwParts = iSubChord.dwLevels;
                rSubChord->m_bRoot = iSubChord.bChordRoot;
                rSubChord->m_bScaleRoot = iSubChord.bScaleRoot;
                rChord.m_pChord->m_pSubChords = rChord.m_pChord->m_pSubChords->Cat(pSub);
            }
            else
            {
                delete pSub;
                pSub = NULL;
            }
        }
        if (!pSub)
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

HRESULT LoadChordList(TList<PlayChord>& ChordList, LPSTREAM pStream,
                      BYTE &bRoot, DWORD &dwScalePattern)
{
    long lFileSize = 0;
    DWORD dwChunkSize;
    MMCKINFO        ckMain;
    MMCKINFO        ck;
    MMCKINFO        ckHeader;
    IAARIFFStream*  pRIFF;
    FOURCC id = 0;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;

    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );


    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) )
    {
        ckMain.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
        if( pRIFF->Descend( &ckMain, NULL, MMIO_FINDLIST ) == 0)
        {
            lFileSize = ckMain.cksize - 4; // subtract off the list type
            DWORD dwScale;
            DWORD cb;
            if (pRIFF->Descend(&ckHeader, &ckMain, 0) == 0 &&
                ckHeader.ckid == DMUS_FOURCC_CHORDTRACKHEADER_CHUNK )
            {
                lFileSize -= 8;  // chunk id + chunk size: double words
                lFileSize -= ckHeader.cksize;
                hr = pStream->Read( &dwScale, sizeof( dwScale ), &cb );
                if (FAILED(hr) || cb != sizeof( dwScale ) )
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pRIFF->Ascend( &ckHeader, 0 );
                    pRIFF->Release();
                    return hr;
                }
                hr = pRIFF->Ascend( &ckHeader, 0 );
                if (FAILED(hr))
                {
                    return hr;
                }
            }
            bRoot = (BYTE) (dwScale >> 24);
            dwScalePattern = dwScale & 0xffffff;
            while (lFileSize > 0)
            {
                if (pRIFF->Descend(&ck, &ckMain, 0) == 0 &&
                    ck.ckid == mmioFOURCC('c','r','d','b') )
                {
                    dwChunkSize = ck.cksize;
                    TListItem<PlayChord>* pChord = new TListItem<PlayChord>;
                    if (!pChord) break;
                    PlayChord& rChord = pChord->GetItemValue();
                    if (FAILED(LoadChordChunk(pStream, rChord))) break;
                    ChordList.AddTail(pChord);
                    if (pRIFF->Ascend( &ck, 0 ) != 0) break;
                    lFileSize -= 8;  // chunk id + chunk size: double words
                    lFileSize -= dwChunkSize;
                }
                else break;
            }
            if (lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0)
            {
                hr = S_OK;
            }
        }
    }
    ChordList.MergeSort(Less);
    pRIFF->Release();
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CDMCompos

CDMCompos::CDMCompos( )
  : m_cRef(1),
    m_dwFlags(0)
{
    InterlockedIncrement(&g_cComponent);
    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;

    srand((unsigned int)time(NULL));
    m_pChords = NULL;
}

CDMCompos::~CDMCompos()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

void CDMCompos::CleanUp()
{
    TListItem<DMChordData*>* pScan = m_pChords;
    for(; pScan; pScan = pScan->GetNext())
    {
        pScan->GetItemValue()->Release();
        delete pScan->GetItemValue();
    }
    if (m_pChords)
    {
        TListItem<DMChordData*>::Delete(m_pChords);
        m_pChords = NULL;
    }
}

void CDMCompos::AddChord(DMChordData* pChord)
{
    TListItem<DMChordData*>* pNew = new TListItem<DMChordData*>(pChord);
    if (pNew)
    {
        pNew->SetNext(m_pChords);
        m_pChords = pNew;
    }
}


void CDMCompos::ChooseSignPosts(TListItem<DMSignPost> *pSignPostHead,
                            TListItem<CompositionCommand> *pTempCommand, DWORD dwType,
                            bool fSecondPass)

{
    //TempCommand *ptcom = tclist->GetHead();
    TListItem<DMSignPost> *pSignPost;
    for (;pTempCommand; pTempCommand = pTempCommand->GetNext())
    {
        CompositionCommand& rTempCommand = pTempCommand->GetItemValue();
        short nTotal = 0;
        if ((rTempCommand.m_dwChord & dwType) == 0)
        {
            continue;   // Only command, no chord.
        }
        pSignPost = pSignPostHead;
        for (; pSignPost; pSignPost = pSignPost->GetNext())
        {
            DMSignPost& rSignPost = pSignPost->GetItemValue();
            if (rSignPost.m_dwTempFlags & rTempCommand.m_dwChord & dwType)
            {
                break;
            }
            else
            {
                if (rSignPost.m_dwChords & rTempCommand.m_dwChord & dwType)
                {
                    if (!rSignPost.m_dwTempFlags || fSecondPass) nTotal++;
                }
            }
        }
        if (!pSignPost)
        {
            if (nTotal) nTotal = rand() % nTotal;
            else nTotal = 0;
            nTotal++;
            pSignPost = pSignPostHead;
            for (; pSignPost; pSignPost = pSignPost->GetNext())
            {
                DMSignPost& rSignPost = pSignPost->GetItemValue();
                if (rSignPost.m_dwChords & rTempCommand.m_dwChord & dwType)
                {
                    if (!rSignPost.m_dwTempFlags || fSecondPass)
                    {
                        nTotal--;
                        if (!nTotal)
                        {
                            break;
                        }
                    }
                }
            }
        }
        if (pSignPost && !rTempCommand.m_pSignPost)
        {
            pSignPost->GetItemValue().m_dwTempFlags |= rTempCommand.m_dwChord;
            rTempCommand.m_pSignPost = pSignPost;
        }
    }
}

TListItem<CompositionCommand> *CDMCompos::GetNextChord(TListItem<CompositionCommand> *pCommand)

{
    if (pCommand) pCommand = pCommand->GetNext();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        if (pCommand->GetItemValue().m_dwChord == 0) continue;   // Only command, no chord.
        if (pCommand->GetItemValue().m_pSignPost) break;
    }
    return(pCommand);
}

void CDMCompos::FindEarlierSignpost(TListItem<CompositionCommand> *pCommand,
                         TListItem<CompositionCommand> *pThis,
                         SearchInfo *pSearch)

{
    CompositionCommand& rThis = pThis->GetItemValue();
    TListItem<CompositionCommand> *pBest = NULL;
    pSearch->m_pPlayChord = NULL;
    pSearch->m_pFirstChord = NULL;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (pCommand == pThis) break;
        if (!UsingDX8() || rCommand.m_dwChord == rThis.m_dwChord)
        {
            if (rCommand.m_pSignPost == rThis.m_pSignPost)
            {
                if (rCommand.m_SearchInfo.m_End.Equals(
                    rThis.m_SearchInfo.m_End))
                {
                        pSearch->m_pPlayChord = rCommand.m_PlayList.GetHead();
                        pSearch->m_pFirstChord = rCommand.m_pFirstChord;
                        return;
                }
                pBest = pCommand;
            }
        }
    }
    if (pBest)
    {
        pSearch->m_pPlayChord = pBest->GetItemValue().m_PlayList.GetHead();
        pSearch->m_pFirstChord = pBest->GetItemValue().m_pFirstChord;
    }
}


static void ClearChordFlags(TList<DMChordEntry>& ChordMap, DWORD dwFlag)
{
    TListItem<DMChordEntry> *pChord = ChordMap.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        pChord->GetItemValue().m_dwFlags &= ~dwFlag;
    }
}

static void ClearNextFlags(TList<DMChordEntry>& ChordMap, DWORD dwFlag)

{
    TListItem<DMChordEntry> *pChord = ChordMap.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        TListItem<DMChordLink> *pScan = pChord->GetItemValue().m_Links.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            pScan->GetItemValue().m_dwFlags &= ~dwFlag;
        }
    }
}

// rCommand will hold the first chord and playlist
BOOL CDMCompos::Compose(TList<DMChordEntry>& ChordMap, SearchInfo *pSearch, CompositionCommand& rCommand)

{
    TListItem<PlayChord> *pDupe;
    TListItem<DMChordEntry> *pChord = NULL;
    SearchInfo tempSearch;
    FailSearch tempFail;
    tempSearch = *pSearch;
    int i = 0;
    // First, if we have a previous instance with the same starting point,
    // try to come up with a solution using its path.
    if (pSearch->m_pPlayChord && pSearch->m_pFirstChord)
    {
        pChord = pSearch->m_pFirstChord;
        ClearNextFlags(ChordMap, NC_PATH);
        ClearChordFlags(ChordMap, CE_PATH);
        if (pChord->GetItemValue().Walk(pSearch))
        {
        }
        else
        {
            pChord = NULL;
        }
    }
    if (!pChord)
    {
        pChord = ChordMap.GetHead();
        for (; pChord; pChord = pChord->GetNext())
        {
            DMChordEntry& rChord = pChord->GetItemValue();
            if (rChord.m_dwFlags & CE_START)
            {
                if (rChord.m_ChordData.Equals(pSearch->m_Start))
                {
                    ClearNextFlags(ChordMap, NC_PATH);
                    ClearChordFlags(ChordMap, CE_PATH);
                    tempFail = pSearch->m_Fail;
                    *pSearch = tempSearch;
                    pSearch->m_Fail = tempFail;
                    if (rChord.Walk(pSearch)) break;
                }
            }
        }
    }
    if (!pChord)
    {
        return(FALSE);
    }
    pDupe = new TListItem<PlayChord>;
    if (pDupe)
    {
        PlayChord& rDupe = pDupe->GetItemValue();
        rDupe.m_fSilent = false;
        rDupe.m_pChord = &pChord->GetItemValue().m_ChordData;
        rDupe.m_nMeasure = (short)i++;
        rDupe.m_nMinbeats = rDupe.m_nMaxbeats = 0;
        rDupe.m_pNext = NULL;
        pDupe->SetNext(NULL);
        rCommand.m_pFirstChord = pChord;
        rCommand.m_PlayList.AddTail(pDupe);
    }
    for (; pChord; )
    {
        TListItem<DMChordLink> *pNext = pChord->GetItemValue().m_Links.GetHead();
        for (; pNext; )
        {
            DMChordLink& rNext = pNext->GetItemValue();
            if (rNext.m_dwFlags & NC_PATH)
            {
                pDupe = new TListItem<PlayChord>;
                if (pDupe)
                {
                    PlayChord& rDupe = pDupe->GetItemValue();
                    rDupe.m_fSilent = false;
                    rDupe.m_pChord = &rNext.m_pChord->GetItemValue().m_ChordData;
                    rDupe.m_nMeasure = (short)i++;
                    rDupe.m_nMinbeats = (short)rNext.m_wMinBeats;
                    rDupe.m_nMaxbeats = (short)rNext.m_wMaxBeats;
                    rDupe.m_pNext = pNext;
                    pDupe->SetNext(NULL);
                    rCommand.m_PlayList.AddTail(pDupe);
                }
                break;
            }
            else
            {
                pNext = pNext->GetNext();
            }
        }
        if (pNext)
        {
            pChord = pNext->GetItemValue().m_pChord;
        }
        else pChord = NULL;
    }
    return(TRUE);
}

TListItem<PlayChord> *CDMCompos::AddChord(TList<PlayChord>& rList, DMChordData *pChord,
                    int nMeasure,int nBeat)

{
    if (pChord->m_pSubChords)
    {
        TListItem<PlayChord> *pNext = new TListItem<PlayChord>;
        if (pNext)
        {
            pNext->GetItemValue().m_pChord = new DMChordData(*pChord);
            if (pNext->GetItemValue().m_pChord)
            {
                AddChord(pNext->GetItemValue().m_pChord);
                pNext->GetItemValue().m_fSilent = false;
                pNext->GetItemValue().m_nMeasure = (short)nMeasure;
                pNext->GetItemValue().m_nBeat = (short)nBeat;
                pNext->GetItemValue().m_nMinbeats = 1;
                pNext->GetItemValue().m_pNext = NULL;
                rList.AddTail(pNext);
            }
            else
            {
                delete pNext;
                pNext = NULL;
            }
        }
        return (pNext);
    }
    else return NULL;
}

TListItem<PlayChord> *CDMCompos::AddCadence(TList<PlayChord>& rList, DMChordData *pChord, int nMax)

{
    TListItem<PlayChord> *pNext = AddChord(rList, pChord, 0, 0);
    if (pNext)
    {
        pNext->GetItemValue().m_nMaxbeats = (short)nMax;
    }
    return (pNext);
}

void CDMCompos::JostleBack(TList<PlayChord>& rList, TListItem<PlayChord> *pChord, int nBeats)

{
    PlayChord& rChord = pChord->GetItemValue();
    TListItem<PlayChord> *pLast = rList.GetPrev(pChord);
    if (nBeats && pLast)
    {
        int distance;
        rChord.m_nBeat = (short)( rChord.m_nBeat + nBeats );
        distance = rChord.m_nBeat - pLast->GetItemValue().m_nBeat;
        if (distance > rChord.m_nMaxbeats)
        {
            JostleBack(rList, pLast, distance - rChord.m_nMaxbeats);
        }
        else if (distance < rChord.m_nMinbeats)
        {
            JostleBack(rList, pLast, distance - rChord.m_nMinbeats);
        }
    }
}

static BOOL inline InRange(TListItem<PlayChord> *pChord,int nLastbeat)

{
    PlayChord& rChord = pChord->GetItemValue();
    int time = rChord.m_nBeat - nLastbeat;
    return ((time >= rChord.m_nMinbeats) && (time <= rChord.m_nMaxbeats));
}

BOOL CDMCompos::AlignChords(TListItem<PlayChord> *pChord,int nLastbeat,int nRes)

{
    if (pChord)
    {
        PlayChord& rChord = pChord->GetItemValue();
        if (!(pChord->GetNext()))
        {
            return (InRange(pChord, nLastbeat));
        }
        if ((rChord.m_nBeat % nRes) == 0)
        {
            if (InRange(pChord, nLastbeat))
            {
                return(AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes));
            }
            return(FALSE);
        }
        BOOL tryright = rand() % 2;
        int old = rChord.m_nBeat;
        rChord.m_nBeat = (short)( ( rChord.m_nBeat / nRes ) * nRes );
        if (tryright) rChord.m_nBeat = (short)( rChord.m_nBeat + nRes );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        if (tryright) rChord.m_nBeat = (short)( rChord.m_nBeat - nRes );
        else rChord.m_nBeat = (short)( rChord.m_nBeat + nRes );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        if (!tryright) rChord.m_nBeat = (short)( rChord.m_nBeat - nRes );
        rChord.m_nBeat = (short)( rChord.m_nBeat + ( ( nRes + 1 ) >> 1 ) );
        if (InRange(pChord, nLastbeat))
        {
            if (AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes))
                return(TRUE);
        }
        rChord.m_nBeat = (short)old;
        if (InRange(pChord, nLastbeat))
        {
            return(AlignChords(pChord->GetNext(), rChord.m_nBeat, nRes));
        }
    }
    return (FALSE);
}

void CDMCompos::ChordConnections(TList<DMChordEntry>& ChordMap,
                             CompositionCommand& rCommand,
                             SearchInfo *pSearch,
                             short nBPM,
                             DMChordData *pCadence1,
                             DMChordData *pCadence2)

{
    int mint, maxt, top, bottom, total;
    short oldbeats = pSearch->m_nBeats;
    //, error;
    TListItem<PlayChord> *pChord;
    SearchInfo tempSearch;
    // Compose a chord list.
    pSearch->m_nMinBeats = 0;
    pSearch->m_nMaxBeats = 0;
    pSearch->m_nChords = 0;
    pSearch->m_Fail.m_nTooManybeats = 0;
    pSearch->m_Fail.m_nTooFewbeats = 0;
    pSearch->m_Fail.m_nTooManychords = 0;
    pSearch->m_Fail.m_nTooFewchords = 0;
    if (pCadence1)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + ((nBPM + 1) >> 1) );
        pSearch->m_nChords++;
    }
    if (pCadence2)
    {
        pSearch->m_nMinBeats++;
        pSearch->m_nMaxBeats = (short)( pSearch->m_nMaxBeats + ((nBPM + 1) >> 1) );
        pSearch->m_nChords++;
    }
    tempSearch = *pSearch;
    for (total = 0;total < 4;total++)
    {
        rCommand.m_PlayList.RemoveAll();
        Compose(ChordMap, pSearch, rCommand);
        pChord = rCommand.m_PlayList.GetHead();
        if (pChord) break;
        if (pSearch->m_Fail.m_nTooManybeats > pSearch->m_Fail.m_nTooFewbeats)
        {
            tempSearch.m_nBeats = (short)( tempSearch.m_nBeats >> 1 );
        }
        else if (pSearch->m_Fail.m_nTooManybeats < pSearch->m_Fail.m_nTooFewbeats)
        {
            tempSearch.m_nBeats = (short)( tempSearch.m_nBeats << 1 );
        }
        else if (pSearch->m_Fail.m_nTooManychords > pSearch->m_Fail.m_nTooFewchords)
        {
            break;      // Can't possibly get better.  Use Cadence.
        }
        else if (pSearch->m_Fail.m_nTooManychords < pSearch->m_Fail.m_nTooFewchords)
        {
            tempSearch.m_nMinChords = (short)( tempSearch.m_nMinChords >> 1 );
        }
        else break;
        *pSearch = tempSearch;
    }
    pSearch->m_nBeats = oldbeats;
    // Tally the min and max beats.
    mint = 0;
    maxt = 0;
    for (; pChord; pChord = pChord->GetNext())
    {
        mint += pChord->GetItemValue().m_nMinbeats;
        maxt += pChord->GetItemValue().m_nMaxbeats;
    }
    pChord = rCommand.m_PlayList.GetHead();
    // If no chord connection was found, create one.
    if (!pChord)
    {
        int nextDuration = oldbeats;
        pChord = AddCadence(rCommand.m_PlayList, &pSearch->m_Start, 0);
        if (pChord)
        {
            pChord->GetItemValue().m_nMinbeats = 0;
        }
        if (pCadence1)
        {
            AddCadence(rCommand.m_PlayList, pCadence1, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, pCadence2, nextDuration);
            mint++;
            maxt += nextDuration;
            nextDuration = nBPM + 1;
        }
        AddCadence(rCommand.m_PlayList, &pSearch->m_Start, nextDuration);
        mint++;
        maxt += nextDuration;
    }
    else
    {
        int chordCount = (int) rCommand.m_PlayList.GetCount();
        int avMax;
        if (chordCount > 1) chordCount--;
        avMax = maxt / chordCount;
        if (avMax < 1) avMax = 1;
        if (pCadence1)
        {
            if (pCadence2)
            {
                AddCadence(rCommand.m_PlayList, pCadence2, avMax);
                maxt += avMax;
                mint++;
            }
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
        else if (pCadence2)
        {
            AddCadence(rCommand.m_PlayList, &pSearch->m_End, avMax);
            maxt += avMax;
            mint++;
        }
    }
    // Prepare a ratio to apply to each connection.
    top = pSearch->m_nBeats - mint;
    bottom = maxt - mint;
    if (bottom <= 0) bottom = 1;
    // Assign each connection a time based on the ratio.
    total = 0;
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int beat = rChord.m_nMaxbeats - rChord.m_nMinbeats;
        beat *= top;
        beat += (bottom >> 1);
        beat /= bottom;
        if (beat < rChord.m_nMinbeats) beat = rChord.m_nMinbeats;
        if (beat > rChord.m_nMaxbeats) beat = rChord.m_nMaxbeats;
        total += beat;
        rChord.m_nBeat = (short)total;
    }
    // It should not be the case that total is 0 after this loop, but it is possible.
    // (particularly if the playlist contains a single chord).  If this happens, give
    // total a value of 1 to make the computations in the following loop work correctly.
    if (!total) total = 1;
    // We should now have a close approximation of the correct time.
    // Stretch or shrink the range to fit exactly.  Err on the side
    // of too long, since jostleback will scrunch them back in place.
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        int newbeat = (rChord.m_nBeat * pSearch->m_nBeats) + total - 1;
        newbeat /= total;
        rChord.m_nBeat = (short)newbeat;
        if (!pChord->GetNext()) total = rChord.m_nBeat;
    }
    // Now we should have times close to the real thing.
    pChord = rCommand.m_PlayList.GetItem(rCommand.m_PlayList.GetCount() - 1);
    if (pChord && (int)pSearch->m_nBeats >= total)
    {
        JostleBack(rCommand.m_PlayList, pChord, pSearch->m_nBeats - total);
    }
    // Now, add the starting time offset to each chord.
    // And, remove the straggler last chord.
    AlignChords(rCommand.m_PlayList.GetHead(), 0, nBPM);
    pChord = rCommand.m_PlayList.GetHead();
    for (; pChord; )
    {
        pChord->GetItemValue().m_nMeasure =
            (short)( ( pChord->GetItemValue().m_nBeat / nBPM ) + rCommand.m_nMeasure );
        pChord->GetItemValue().m_nBeat %= nBPM;
        if (pChord->GetNext())
        {
            pChord = pChord->GetNext();
        }
        else
        {
            rCommand.m_PlayList.Remove(pChord);
            delete pChord;
            break;
        }
    }
}

static TListItem<PlayChord> *FindChordInMeasure(TList<PlayChord>& PlayList,int nMeasure)

{
    TListItem<PlayChord> *pChord = PlayList.GetHead();
    for (; pChord; pChord = pChord->GetNext())
    {
        PlayChord& rChord = pChord->GetItemValue();
        if (rChord.m_nMeasure > nMeasure) break;
        if (rChord.m_nMeasure == nMeasure)
        {
            if (rChord.m_nBeat) return(pChord);
        }
    }
    return(NULL);
}

void CDMCompos::CleanUpBreaks(TList<PlayChord>& PlayList, TListItem<CompositionCommand> *pCommand)
{
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if ((rCommand.m_Command.bCommand == DMUS_COMMANDT_BREAK) ||
            (rCommand.m_Command.bCommand == DMUS_COMMANDT_END) ||
            (rCommand.m_Command.bCommand == DMUS_COMMANDT_INTRO) )
        {
            TListItem<PlayChord> *pChord;

            while( ( pChord = FindChordInMeasure( PlayList, rCommand.m_nMeasure ) ) != NULL )
            {
                PlayList.Remove(pChord);
                delete pChord;
            }
        }
    }
}

static void LoadCommandList(TList<TemplateCommand>& CommandList, LPSTREAM pCStream)
{
    HRESULT         hr = E_FAIL;
    IAARIFFStream*  pRIFF;
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;

    StreamSeek(pCStream, 0, STREAM_SEEK_SET);

    if( SUCCEEDED( AllocRIFFStream( pCStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
        ck.ckid == FOURCC_COMMAND)
    {
        DMUS_IO_COMMAND iCommand;
        lFileSize = ck.cksize;
        hr = pCStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<TemplateCommand>* pCommand;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pCommand = new TListItem<TemplateCommand>;
                    if( pCommand )
                    {
                        TemplateCommand& rCommand = pCommand->GetItemValue();
                        if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                        {
                            pCStream->Read( &iCommand, dwNodeSize, NULL );
                        }
                        else
                        {
                            pCStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                            StreamSeek( pCStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                        }
                        memset( &rCommand, 0, sizeof( rCommand ) );
                        rCommand.m_nMeasure = iCommand.wMeasure;
                        rCommand.m_Command.bCommand = iCommand.bCommand;
                        rCommand.m_Command.bGrooveLevel = iCommand.bGrooveLevel;
                        rCommand.m_Command.bGrooveRange = iCommand.bGrooveRange;
                        rCommand.m_Command.bRepeatMode = iCommand.bRepeatMode;
                        rCommand.m_dwChord = 0;
                        CommandList.AddTail(pCommand);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    pRIFF->Release();
}

static void LoadCommandList(TList<TemplateCommand>& CommandList, LPSTREAM pSPStream, LPSTREAM pCStream)
{
    TList<DMSignPostStruct> SignPostList;
    HRESULT         hr = E_FAIL;
    DWORD dwPos;
    IAARIFFStream*  pRIFF = NULL;

    dwPos = StreamTell( pSPStream );
    StreamSeek( pSPStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    DMUS_IO_SIGNPOST        iSignPost;

    if( SUCCEEDED( AllocRIFFStream( pSPStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
        ck.ckid == DMUS_FOURCC_SIGNPOST_TRACK_CHUNK)
    {
        lFileSize = ck.cksize;
        hr = pSPStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMSignPostStruct>* pSignPost;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    pSignPost = new TListItem<DMSignPostStruct>;
                    if( pSignPost )
                    {
                        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
                        if( dwNodeSize <= sizeof( iSignPost ) )
                        {
                            pSPStream->Read( &iSignPost, dwNodeSize, NULL );
                        }
                        else
                        {
                            pSPStream->Read( &iSignPost, sizeof( iSignPost ), NULL );
                            StreamSeek( pSPStream, lFileSize - sizeof( iSignPost ), STREAM_SEEK_CUR );
                        }
                        memset( &rSignPost, 0, sizeof( rSignPost ) );
                        rSignPost.m_mtTime = iSignPost.mtTime;
                        rSignPost.m_wMeasure = iSignPost.wMeasure;
                        rSignPost.m_dwChords = iSignPost.dwChords;
                        SignPostList.AddTail(pSignPost);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    if (pRIFF)
    {
        pRIFF->Release();
        pRIFF = NULL;
    }

    // If a command stream exists, load the commands into the command list.
    if (pCStream)
    {
        StreamSeek(pCStream, 0, STREAM_SEEK_SET);

        if( SUCCEEDED( AllocRIFFStream( pCStream, &pRIFF ) ) &&
            pRIFF->Descend( &ck, NULL, 0 ) == 0 &&
            ck.ckid == FOURCC_COMMAND)
        {
            DMUS_IO_COMMAND iCommand;
            lFileSize = ck.cksize;
            hr = pCStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
            if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
            {
                lFileSize -= 4; // for the size dword
                TListItem<TemplateCommand>* pCommand;
                if (lFileSize % dwNodeSize)
                {
                    hr = E_FAIL;
                }
                else
                {
                    while( lFileSize > 0 )
                    {
                        pCommand = new TListItem<TemplateCommand>;
                        if( pCommand )
                        {
                            TemplateCommand& rCommand = pCommand->GetItemValue();
                            if( dwNodeSize <= sizeof( DMUS_IO_COMMAND ) )
                            {
                                pCStream->Read( &iCommand, dwNodeSize, NULL );
                            }
                            else
                            {
                                pCStream->Read( &iCommand, sizeof( DMUS_IO_COMMAND ), NULL );
                                StreamSeek( pCStream, lFileSize - sizeof( DMUS_IO_COMMAND ), STREAM_SEEK_CUR );
                            }
                            memset( &rCommand, 0, sizeof( rCommand ) );
                            rCommand.m_nMeasure = iCommand.wMeasure;
                            rCommand.m_Command.bCommand = iCommand.bCommand;
                            rCommand.m_Command.bGrooveLevel = iCommand.bGrooveLevel;
                            rCommand.m_Command.bGrooveRange = iCommand.bGrooveRange;
                            rCommand.m_Command.bRepeatMode = iCommand.bRepeatMode;
                            CommandList.AddTail(pCommand);
                            lFileSize -= dwNodeSize;
                        }
                        else break;
                    }
                }
            }
            if( lFileSize == 0 &&
                pRIFF->Ascend( &ck, 0 ) == 0 )
            {
                hr = S_OK;
            }
        }
        if (pRIFF) pRIFF->Release();
    }

    // Now, go through the signpost list, making sure that every signpost has a corresponding
    // command.  If this is not the case for some signpost, insert a groove with the last
    // current groove level into the list (default this to 67).  Give each command's m_dwChord
    // the m_dwChords value from the corresponding signpost.
    BYTE bGrooveLevel = 62;
    TListItem<DMSignPostStruct>* pSignPost = SignPostList.GetHead();
    for( ; pSignPost; pSignPost = pSignPost->GetNext())
    {
        bool fFoundInList = false;
        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
        TListItem<TemplateCommand>* pPrevious = NULL;
        TListItem<TemplateCommand>* pCommand = CommandList.GetHead();
        for ( ; pCommand; pCommand = pCommand->GetNext())
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            if (rSignPost.m_wMeasure == rCommand.m_nMeasure)
            {
                rCommand.m_dwChord = rSignPost.m_dwChords;
                fFoundInList = true;
                break;
            }
            else if (rSignPost.m_wMeasure < rCommand.m_nMeasure)
            {
                // We went too far in the command list, so break out
                break;
            }
            if (rCommand.m_Command.bGrooveLevel)
            {
                bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            }
            pPrevious = pCommand;
        }
        if ( !fFoundInList )
        {
            // We need to create a new command and stick it between pPrevious and pCommand
            TListItem<TemplateCommand>* pNew = new TListItem<TemplateCommand>;
            if( pNew )
            {
                TemplateCommand& rNew = pNew->GetItemValue();
                memset( &rNew, 0, sizeof( rNew ) );
                rNew.m_nMeasure = rSignPost.m_wMeasure;
                rNew.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                rNew.m_Command.bGrooveLevel = bGrooveLevel;
                rNew.m_Command.bGrooveRange = 0;
                rNew.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                rNew.m_dwChord = rSignPost.m_dwChords;
                if (pPrevious)
                {
                    pPrevious->SetNext(pNew);
                    pNew->SetNext(pCommand);
                }
                else
                {
                    CommandList.AddHead(pNew);
                }
            }
        }
    }
}

HRESULT CDMCompos::SaveChordList( IAARIFFStream* pRIFF,  TList<PlayChord>& rPlayList,
                             BYTE bRoot, DWORD dwScale, DMUS_TIMESIGNATURE& rTimeSig)
{
    IStream*    pStream;
    MMCKINFO    ck;
    MMCKINFO    ckHeader;
    HRESULT     hr;
    TListItem<PlayChord>*   pChord;
    DWORD cb;


    pStream = pRIFF->GetStream();

    ck.fccType = DMUS_FOURCC_CHORDTRACK_LIST;
    hr = pRIFF->CreateChunk(&ck,MMIO_CREATELIST);
    if (SUCCEEDED(hr))
    {

        DWORD dwRoot = bRoot;
        dwScale |= (dwRoot << 24);

        ckHeader.ckid = DMUS_FOURCC_CHORDTRACKHEADER_CHUNK;
        hr = pRIFF->CreateChunk(&ckHeader, 0);
        if (SUCCEEDED(hr))
        {
            hr = pStream->Write( &dwScale, sizeof( dwScale ), &cb );
            if (SUCCEEDED(hr))
            {
                hr = pRIFF->Ascend( &ckHeader, 0 );
                if (hr == S_OK)
                {
                    pChord = rPlayList.GetHead();
                    for( ; pChord != NULL ; pChord = pChord->GetNext() )
                    {
                        hr = pChord->GetItemValue().Save(pRIFF, rTimeSig);
                        if (FAILED(hr))
                        {
                            pStream->Release();
                            return hr;
                        }
                    }
                    if( pChord == NULL &&
                        pRIFF->Ascend( &ck, 0 ) == 0 )
                    {
                        hr = S_OK;
                    }
                }

            }
        }
    }

    pStream->Release();
    return hr;
}

static HRESULT SaveCommandList( IAARIFFStream* pRIFF,  TList<TemplateCommand>& rCommandList,
                               DMUS_TIMESIGNATURE& rTimeSig)
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<TemplateCommand>* pCommand;

    pStream = pRIFF->GetStream();
    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release( );
            return E_FAIL;
        }
        for( pCommand = rCommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            memset( &iCommand, 0, sizeof( iCommand ) );
            iCommand.mtTime = ClocksPerMeasure(rTimeSig) * rCommand.m_nMeasure;
            iCommand.wMeasure = rCommand.m_nMeasure;
            iCommand.bBeat = 0;
            iCommand.bCommand = rCommand.m_Command.bCommand;
            iCommand.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            iCommand.bGrooveRange = rCommand.m_Command.bGrooveRange;
            iCommand.bRepeatMode = rCommand.m_Command.bRepeatMode;
            if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                cb != sizeof( iCommand ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release( );
    return hr;
}

static HRESULT SaveStartMarkers( IAARIFFStream* pRIFF,  TemplateCommand& rCommand,
                               IDMStyle* pStyle)
{
    IStream*    pStream;
    MMCKINFO    ckMain;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_VALID_START oValidStart;
    bool fWroteOne = false;

    pStream = pRIFF->GetStream();
    hr = E_FAIL;
    ckMain.ckid = FOURCC_LIST;
    ckMain.fccType = DMUS_FOURCC_MARKERTRACK_LIST;
    if( pRIFF->CreateChunk( &ckMain, MMIO_CREATELIST ) == 0 )
    {
        ck.ckid = DMUS_FOURCC_VALIDSTART_CHUNK;
        if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
        {
            dwSize = sizeof( DMUS_IO_VALID_START );
            hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
            if( FAILED( hr ) || cb != sizeof( dwSize ) )
            {
                pStream->Release( );
                return E_FAIL;
            }
            DWORD dwIndex = 0;
            MUSIC_TIME mtTime = 0;
            while(S_OK == (hr = pStyle->EnumStartTime(dwIndex, &rCommand.m_Command, &mtTime)))
            {
                memset( &oValidStart, 0, sizeof( oValidStart ) );
                oValidStart.mtTime = mtTime;
                if( FAILED( hr = pStream->Write( &oValidStart, sizeof( oValidStart ), &cb ) ) ||
                    cb != sizeof( oValidStart ) )
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    break;
                }
                fWroteOne = true;
                dwIndex++;
            }
            if( SUCCEEDED(hr) && pRIFF->Ascend( &ck, 0 ) == 0 )
            {
                hr = S_OK;
            }
        }
        if( SUCCEEDED(hr) && pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    if (!fWroteOne) hr = E_FAIL;

    pStream->Release( );
    return hr;
}

void CDMCompos::ComposePlayList(TList<PlayChord>& PlayList,
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pPersonality,
                            TList<TemplateCommand>& rCommandList,
                            WORD wActivity)
{
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    if (wActivity < 0) wActivity = 0;
    if (wActivity > 3) wActivity = 3;
    short nBPM = TimeSig.bBeatsPerMeasure;
    IDMPers* pDMP;
    pPersonality->QueryInterface(IID_IDMPers, (void**)&pDMP);
    DMPersonalityStruct* pPers;
    pDMP->GetPersonalityStruct((void**)&pPers);
    TList<DMChordEntry> &ChordMap = pPers->m_ChordMap;
    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    for (; pSign; pSign = pSign->GetNext())
    {
        pSign->GetItemValue().m_dwTempFlags = 0;
    }
    // Assign specific root sign posts, then letter based sign posts.
    TList<CompositionCommand> CommandList;
    TListItem<TemplateCommand>* pTC = rCommandList.GetHead();
    for(; pTC; pTC = pTC->GetNext())
    {
        TemplateCommand& rTC = pTC->GetItemValue();
        TListItem<CompositionCommand>* pNew = new TListItem<CompositionCommand>;
        if (pNew)
        {
            CompositionCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rTC.m_nMeasure;
            rNew.m_Command = rTC.m_Command;
            rNew.m_dwChord = rTC.m_dwChord;
            rNew.m_pSignPost = NULL;
            rNew.m_pFirstChord = NULL;
            CommandList.AddTail(pNew);
        }
    }
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, false);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_ROOT, true);
    ChooseSignPosts(SignPostList.GetHead(), CommandList.GetHead(),DMUS_SIGNPOSTF_LETTER, true);
   // Now, we should have a chord assigned for each node in the template.
    TListItem<CompositionCommand>* pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        CompositionCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_dwChord == 0) continue;   // Only command, no chord.
        if (rCommand.m_pSignPost)
        {
            TListItem<CompositionCommand>* pNext = GetNextChord(pCommand);
            if (pNext)
            {
                CompositionCommand& rNext = pNext->GetItemValue();
                SearchInfo *pSearch = &rCommand.m_SearchInfo;
                DMChordData *pCadence1 = NULL;
                DMChordData *pCadence2 = NULL;
                pSearch->m_Start = rCommand.m_pSignPost->GetItemValue().m_ChordData;
                if (rNext.m_dwChord & DMUS_SIGNPOSTF_CADENCE)
                {
                    TListItem<DMSignPost> *pLocalSign = rNext.m_pSignPost;
                    DMSignPost& rSign = pLocalSign->GetItemValue();
                    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
                    {
                        pSearch->m_End = rSign.m_aCadence[0];
                        pCadence1 = &rSign.m_aCadence[0];
                        if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                        {
                            pCadence2 = &rSign.m_aCadence[1];
                        }
                    }
                    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
                    {
                        pSearch->m_End = rSign.m_aCadence[1];
                        pCadence2 = &rSign.m_aCadence[1];
                    }
                    else
                    {
                        pSearch->m_End = rSign.m_ChordData;
                    }
                }
                else
                {
                    pSearch->m_End = rNext.m_pSignPost->GetItemValue().m_ChordData;
                }
                pSearch->m_nActivity = (short) wActivity;
                pSearch->m_nBeats = (short)( (rNext.m_nMeasure - rCommand.m_nMeasure) * nBPM );
                pSearch->m_nMaxChords = (short)( pSearch->m_nBeats >> wActivity );
                pSearch->m_nMinChords = (short)( pSearch->m_nBeats >> (wActivity + 1) );
                FindEarlierSignpost(CommandList.GetHead(), pCommand, pSearch);
                // rCommand holds the playlist and the measure used by ChordConnections
                // (it should be passed by reference since the playlist changes)
                ChordConnections(ChordMap, rCommand, pSearch, nBPM, pCadence1, pCadence2);
            }
            else
            {
                AddChord(rCommand.m_PlayList, &rCommand.m_pSignPost->GetItemValue().m_ChordData,
                    rCommand.m_nMeasure,0);
            }
        }
    }
    // Take all the Chord references and fold 'em into one list.
    pCommand = CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        PlayList.Cat(pCommand->GetItemValue().m_PlayList.GetHead());
        pCommand->GetItemValue().m_PlayList.RemoveAll();
    }
    CleanUpBreaks(PlayList, CommandList.GetHead());
    pDMP->Release();
}

HRESULT CDMCompos::ExtractCommandList(TList<TemplateCommand>& CommandList,
                                      IDirectMusicTrack*    pSignPostTrack,
                                      IDirectMusicTrack*    pCommandTrack,
                                      DWORD dwGroupBits)
{
    HRESULT             hr              = S_OK;
    IPersistStream*     pPS1            = NULL;
    IPersistStream*     pPS2            = NULL;
    IStream*            pStream1        = NULL;
    IStream*            pStream2        = NULL;

    // First, get the signpost track from the template segment and persist it to a stream
    if (!pSignPostTrack)
    {
        Trace(1, "ERROR: No signpost track to use for chord composition.\n");
        hr = E_POINTER;
        goto ON_END;
    }
    hr = pSignPostTrack->QueryInterface(IID_IPersistStream, (void**)&pPS1);
    if (hr != S_OK) goto ON_END;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream1);
    if (hr != S_OK) goto ON_END;
    hr = pPS1->Save(pStream1, FALSE);
    if (hr != S_OK) goto ON_END;
    StreamSeek(pStream1, 0, STREAM_SEEK_SET);


    // Next, get the command track from the template segment and persist it to a stream.
    // If there is no command track, we'll just use a NULL stream.
    if (pCommandTrack)
    {
        hr = pCommandTrack->QueryInterface(IID_IPersistStream, (void**)&pPS2);
        if (hr != S_OK) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream2);
        if (hr != S_OK) goto ON_END;
        hr = pPS2->Save(pStream2, FALSE);
        if (hr != S_OK) goto ON_END;
        StreamSeek(pStream2, 0, STREAM_SEEK_SET);
    }

    // Finally, call LoadCommandList, passing in the two streams.
    LoadCommandList(CommandList, pStream1, pStream2);

ON_END:
    if (pPS1) pPS1->Release();
    if (pPS2) pPS2->Release();
    if (pStream1) pStream1->Release();
    if (pStream2) pStream2->Release();
    return hr;
}

// This will modify an existing segment by adding *only* a chord track to it.
// Any existing chord tracks with conflicting group bits will be removed.
HRESULT CDMCompos::AddToSegment(IDirectMusicSegment* pTempSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale)
{
    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;

    /////////////////////////////////////////////////////////////
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        // if there exists a chord track with these group bits, reload these chords into that
        // track (use the first track that's found).  Otherwise, create a new chord track
        // to load these chords into.
        hr = pTempSeg->GetTrack(CLSID_DirectMusicChordTrack, dwGroupBits, 0, &pIChordTrack);
        if (S_OK != hr)
        {
            // create a new chord track
            hr = ::CoCreateInstance(
                CLSID_DirectMusicChordTrack,
                NULL,
                CLSCTX_INPROC,
                IID_IDirectMusicTrack,
                (void**)&pIChordTrack
                );
            if (!SUCCEEDED(hr)) goto ON_END;
            // insert the new chord track.
            pTempSeg->InsertTrack(pIChordTrack, dwGroupBits);
        }
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    return hr;
}

HRESULT CDMCompos::CopySegment(IDirectMusicSegment* pTempSeg,
                           IDirectMusicSegment** ppSectionSeg,
                           TList<PlayChord>& PlayList,
                           IDirectMusicStyle* pStyle,
                           IDirectMusicChordMap* pChordMap,
                           BOOL fStyleFromTrack,
                           BOOL fChordMapFromTrack,
                           DWORD dwGroupBits,
                           BYTE bRoot, DWORD dwScale)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pIChordMapTrack         = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;
    long                    nClocks                 = 0;
    DMUS_BAND_PARAM         DMBandParam;

    DWORD dwStyleGroupBits = 1;
    if (UsingDX8(pStyle, pChordMap))
    {
        for (int i = 0; i < 32; i++)
        {
            if (dwGroupBits & (1 << i))
            {
                dwStyleGroupBits = 1 << i;
                break;
            }
        }
    }
    else
    {
        dwGroupBits = 1;
    }

    pTempSeg->GetLength(&nClocks);
    /////////////////////////////////////////////////////////////
    // clone the template segment to get a section segment
    hr = pTempSeg->Clone(0, nClocks, ppSectionSeg);
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIChordTrack
            );
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        (*ppSectionSeg)->InsertTrack(pIChordTrack, dwGroupBits);
    }

    // If the passed-in Style is not from the template segment,
    // remove all style tracks from the new segment and add a new Style track.
    if (!fStyleFromTrack)
    {
        do
        {
            hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, ALL_TRACK_GROUPS, 0, &pIStyleTrack);
            if (S_OK == hr)
            {
                (*ppSectionSeg)->RemoveTrack(pIStyleTrack);
                pIStyleTrack->Release();
            }
        } while (S_OK == hr);
        hr = ::CoCreateInstance(
            CLSID_DirectMusicStyleTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIStyleTrack
        );
        if (FAILED(hr)) goto ON_END;
        pIStyleTrack->SetParam(GUID_IDirectMusicStyle, 0, (void*)pStyle);
        (*ppSectionSeg)->InsertTrack(pIStyleTrack, dwStyleGroupBits);
    }

    // If the passed-in ChordMap is not from the template segment,
    // remove all ChordMap tracks from the new segment and add a new ChordMap track.
    if (!fChordMapFromTrack)
    {
        do
        {
            hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicChordMapTrack, ALL_TRACK_GROUPS, 0, &pIChordMapTrack);
            if (S_OK == hr)
            {
                (*ppSectionSeg)->RemoveTrack(pIChordMapTrack);
                pIChordMapTrack->Release();
            }
        } while (S_OK == hr);
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordMapTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIChordMapTrack
        );
        if (FAILED(hr)) goto ON_END;
        pIChordMapTrack->SetParam(GUID_IDirectMusicChordMap, 0, (void*)pChordMap);
        (*ppSectionSeg)->InsertTrack(pIChordMapTrack, dwGroupBits);
    }

    // if there's no tempo track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pDMTrack)))
    {
        // Create a Tempo Track in which to store the tempo events
        DMUS_TEMPO_PARAM tempo;
        tempo.mtTime = 0; //ConvertTime( dwTime );

        pStyle->GetTempo(&tempo.dblTempo);
        if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
            NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
            (void**)&pDMTrack )))
        {
            if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
            {
                (*ppSectionSeg)->InsertTrack( pDMTrack, dwGroupBits );
            }
        }
    }
    // if there's no band track in the template segment, create one and add it
    if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicBandTrack, ALL_TRACK_GROUPS, 0, &pBandTrack)))
    {
        // Create band track
        hr = ::CoCreateInstance(
            CLSID_DirectMusicBandTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pBandTrack
            );

        if(!SUCCEEDED(hr)) goto ON_END;

        // Load default band from style into track
        // If for some reason the style doesn't have a default band (could happend
        // if the style came from a pattern track), don't make a band track.
        if (pStyle->GetDefaultBand(&pBand) == S_OK)
        {
            DMBandParam.mtTimePhysical = -64;
            DMBandParam.pBand = pBand;
            hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
            if (!SUCCEEDED(hr)) goto ON_END;
            (*ppSectionSeg)->InsertTrack(pBandTrack, dwGroupBits);
        }
    }

    // Initialize the segment
    (*ppSectionSeg)->SetRepeats(0); // still needed for dx7
    TraceI(4, "Segment Length: %d\n", nClocks);
    (*ppSectionSeg)->SetLength(nClocks);
    if (UsingDX8(pStyle, pChordMap))
    {
        DWORD dwLoopRepeats = 0;
        pTempSeg->GetRepeats( &dwLoopRepeats );
        (*ppSectionSeg)->SetRepeats( dwLoopRepeats );
        MUSIC_TIME mtLoopStart = 0, mtLoopEnd = 0;
        pTempSeg->GetLoopPoints( &mtLoopStart, &mtLoopEnd );
        (*ppSectionSeg)->SetLoopPoints( mtLoopStart, mtLoopEnd );
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pDMTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CoCreateInstance
        pDMTrack->Release();
    }
    if (pBandTrack)
    {
        // This releases the Addref made either by GetTrack or (if GetTrack failed)
        // by CoCreateInstance
        pBandTrack->Release();
    }
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pIChordMapTrack) pIChordMapTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

HRESULT CDMCompos::BuildSegment(TList<TemplateCommand>& CommandList,
                            TList<PlayChord>& PlayList,
                            IDirectMusicStyle* pStyle,
                            IDirectMusicChordMap* pChordMap,
                            long lMeasures,
                            IDirectMusicSegment** ppSectionSeg,
                            BYTE bRoot, DWORD dwScale,
                            double* pdblTempo,
                            IDirectMusicBand* pCurrentBand,
                            bool fAlign,
                            IDirectMusicGraph* pGraph,
                            IUnknown* pPath)
{
    if (!ppSectionSeg) return E_INVALIDARG;

    HRESULT                 hr                      = S_OK;
    IDirectMusicTrack*      pIChordTrack            = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    IDirectMusicTrack*      pICommandTrack          = NULL;
    IAARIFFStream*          pCommandRIFF            = NULL;
    IStream*                pICommandStream         = NULL;
    IPersistStream*         pICommandTrackStream    = NULL;
    IDirectMusicTrack*      pIMarkerTrack           = NULL;
    IAARIFFStream*          pMarkerRIFF             = NULL;
    IStream*                pIMarkerStream          = NULL;
    IPersistStream*         pIMarkerTrackStream     = NULL;
    IDirectMusicTrack*      pIStyleTrack            = NULL;
    IDirectMusicTrack*      pIChordMapTrack         = NULL;
    IDirectMusicTrack*      pDMTrack                = NULL;
    IDirectMusicTrack*      pBandTrack              = NULL;
    IDirectMusicBand*       pBand                   = NULL;
    long                    nClocks                 = 0;
    DMUS_BAND_PARAM         DMBandParam;

    // create a section segment
    hr = ::CoCreateInstance(
        CLSID_DirectMusicSegment,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicSegment,
        (void**)ppSectionSeg
    );
    if (!SUCCEEDED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    nClocks = (lMeasures) * TimeSig.bBeatsPerMeasure * (DMUS_PPQ * 4 / TimeSig.bBeat);
    // Convert PlayList into a Chord Track
    if (PlayList.GetHead())
    {
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordTrack,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicTrack,
            (void**)&pIChordTrack
            );
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pIChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
    }
    // Convert CommandList into a Command Track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicCommandTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pICommandTrack
        );
    if (!SUCCEEDED(hr)) goto ON_END;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (S_OK != hr) goto ON_END;
    SaveCommandList(pCommandRIFF, CommandList, TimeSig);
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if (!SUCCEEDED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if (!SUCCEEDED(hr)) goto ON_END;

    // If the align flag's been set, create a marker track
    if (fAlign)
    {
        TListItem<TemplateCommand>* pCommandItem = CommandList.GetHead();
        IDMStyle* pDMStyle = NULL;
        if (pCommandItem &&
            pStyle &&
            SUCCEEDED(pStyle->QueryInterface(IID_IDMStyle, (void**) &pDMStyle)))
        {
            hr = ::CoCreateInstance(
                CLSID_DirectMusicMarkerTrack,
                NULL,
                CLSCTX_INPROC,
                IID_IDirectMusicTrack,
                (void**)&pIMarkerTrack
                );

            if (!SUCCEEDED(hr))
            {
                pDMStyle->Release();
                goto ON_END;
            }

            hr = CreateStreamOnHGlobal(NULL, TRUE, &pIMarkerStream);
            if (S_OK != hr)
            {
                pDMStyle->Release();
                goto ON_END;
            }

            hr = AllocRIFFStream( pIMarkerStream, &pMarkerRIFF);
            if (S_OK != hr)
            {
                pDMStyle->Release();
                goto ON_END;
            }

            hr = SaveStartMarkers(pMarkerRIFF, pCommandItem->GetItemValue(), pDMStyle);
            // If the above fails, it means the style doesn't have any markers, so just
            // continue without creating a marker track.
            if (SUCCEEDED(hr))
            {
                hr = pIMarkerTrack->QueryInterface(IID_IPersistStream, (void**)&pIMarkerTrackStream);
                if (!SUCCEEDED(hr))
                {
                    pDMStyle->Release();
                    goto ON_END;
                }

                StreamSeek(pIMarkerStream, 0, STREAM_SEEK_SET);
                hr = pIMarkerTrackStream->Load(pIMarkerStream);
                if (!SUCCEEDED(hr))
                {
                    pDMStyle->Release();
                    goto ON_END;
                }

            }

            pDMStyle->Release();
        }
    }

    // Use the passed-in Style to create a Style Track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicStyleTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIStyleTrack
    );
    if (FAILED(hr)) goto ON_END;
    pIStyleTrack->SetParam(GUID_IDirectMusicStyle, 0, (void*)pStyle);

    // Use the passed-in ChordMap to create a ChordMap Track
    hr = ::CoCreateInstance(
        CLSID_DirectMusicChordMapTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pIChordMapTrack
    );
    if (FAILED(hr)) goto ON_END;
    pIChordMapTrack->SetParam(GUID_IDirectMusicChordMap, 0, (void*)pChordMap);

    // Create a Tempo Track in which to store the tempo events
    ////////////////////////////////////////////////////////////
    DMUS_TEMPO_PARAM tempo;
    tempo.mtTime = 0; //ConvertTime( dwTime );

    if (!pdblTempo)
    {
        pStyle->GetTempo(&tempo.dblTempo);
    }
    else
    {
        tempo.dblTempo = *pdblTempo;
    }
    ////////////////////////////////////////////////////////////
    if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
        NULL, CLSCTX_INPROC, IID_IDirectMusicTrack,
        (void**)&pDMTrack )))
    {
        if ( SUCCEEDED(pDMTrack->SetParam(GUID_TempoParam, 0, &tempo)) )
        {
            (*ppSectionSeg)->InsertTrack( pDMTrack, 1 );
        }
    }
    // Create a new band track.
    hr = ::CoCreateInstance(
        CLSID_DirectMusicBandTrack,
        NULL,
        CLSCTX_INPROC,
        IID_IDirectMusicTrack,
        (void**)&pBandTrack
        );

    if(!SUCCEEDED(hr)) goto ON_END;

    // Add either the band passed in, or the style's default band.
    if (pCurrentBand)
    {
        pBand = pCurrentBand;
        pBand->AddRef(); // Needed because we release the band before returning
    }
    else
    {
        hr = pStyle->GetDefaultBand(&pBand);
    }
    DMBandParam.mtTimePhysical = -64;
    DMBandParam.pBand = pBand;
    hr = pBandTrack->SetParam(GUID_BandParam, 0, (void*)&DMBandParam);
    if (!SUCCEEDED(hr)) goto ON_END;

    // Initialize the segment and insert the above tracks
    (*ppSectionSeg)->SetRepeats(0);
    (*ppSectionSeg)->SetLength(nClocks);
    (*ppSectionSeg)->InsertTrack(pBandTrack, 1);
    (*ppSectionSeg)->InsertTrack(pIStyleTrack, 1);
    (*ppSectionSeg)->InsertTrack(pIChordMapTrack, 1);
    (*ppSectionSeg)->InsertTrack(pICommandTrack, 1);
    if (pIMarkerTrack)
    {
        (*ppSectionSeg)->InsertTrack(pIMarkerTrack, 1);
    }
    if (pIChordTrack)
    {
        (*ppSectionSeg)->InsertTrack(pIChordTrack, 1);
    }
    // Add the graph
    if (pGraph)
    {
        (*ppSectionSeg)->SetGraph(pGraph);
    }
    // Add the Audio Path
    if (pPath)
    {
        IDirectMusicSegment8P* pSegP = NULL;
        if (SUCCEEDED((*ppSectionSeg)->QueryInterface(IID_IDirectMusicSegment8P, (void**)&pSegP)))
        {
            pSegP->SetAudioPathConfig(pPath);
            pSegP->Release();
        }
    }

ON_END:
    if (pIChordTrack) pIChordTrack->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pICommandTrack) pICommandTrack->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pDMTrack) pDMTrack->Release();
    if (pBandTrack) pBandTrack->Release();
    if (pIStyleTrack) pIStyleTrack->Release();
    if (pIMarkerTrack) pIMarkerTrack->Release();
    if (pMarkerRIFF) pMarkerRIFF->Release();
    if (pIMarkerStream) pIMarkerStream->Release();
    if (pIMarkerTrackStream) pIMarkerTrackStream->Release();
    if (pIChordMapTrack) pIChordMapTrack->Release();
    if (pBand) pBand->Release();
    return hr;
}

void ChangeCommand(DMUS_COMMAND_PARAM& rResult, DMUS_COMMAND_PARAM& rCommand, int nDirection)

{
    BYTE bGrooveLevel = 0;
    BYTE bRiff = 0;

    if (nDirection > 0)
    {
        while (nDirection > 0)
        {
            switch (rCommand.bGrooveLevel)
            {
                case 12 : bGrooveLevel = 37; break;
                case 37 : bGrooveLevel = 62; break;
                case 62 : bGrooveLevel = 87; break;
                case 87 : bGrooveLevel = 87; break;
                default: bGrooveLevel = rCommand.bGrooveLevel;
            }
            switch (rCommand.bCommand)
            {
                case DMUS_COMMANDT_FILL : bRiff = DMUS_COMMANDT_FILL; break;
                case DMUS_COMMANDT_BREAK : bRiff = DMUS_COMMANDT_FILL; break;
                default: bRiff = rCommand.bCommand;
            }
            rResult.bGrooveLevel = bGrooveLevel;
            rResult.bCommand = bRiff;
            nDirection--;
        }
    }
    else if (nDirection == 0)
    {
        rResult.bGrooveLevel = rCommand.bGrooveLevel;
        rResult.bCommand = rCommand.bCommand;
    }
    else if (nDirection < 0)
    {
        while (nDirection < 0)
        {
            switch (rCommand.bGrooveLevel)
            {
                case 12 : bGrooveLevel = 12; break;
                case 37 : bGrooveLevel = 12; break;
                case 62 : bGrooveLevel = 37; break;
                case 87 : bGrooveLevel = 62; break;
                default: bGrooveLevel = rCommand.bGrooveLevel;
            }
            switch (rCommand.bCommand)
            {
                case DMUS_COMMANDT_FILL : bRiff = DMUS_COMMANDT_BREAK; break;
                case DMUS_COMMANDT_BREAK : bRiff = DMUS_COMMANDT_BREAK; break;
                default: bRiff = rCommand.bCommand;
           }
            rResult.bGrooveLevel = bGrooveLevel;
            rResult.bCommand = bRiff;
            nDirection++;
        }
    }
}

static void InsertStuff(int nMeasure,
        TListItem<TemplateCommand> *pCommands,
        TListItem<PlayChord> *pPlayChord,
        TList<TemplateCommand> &rCommandList,
        TList<PlayChord> &rChordList,
        int nDirection)

{
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        TListItem<TemplateCommand> *pNew = new TListItem<TemplateCommand>;
        if (pNew)
        {
            TemplateCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rCommand.m_nMeasure + (short)nMeasure;
            ChangeCommand(rNew.m_Command, rCommand.m_Command, nDirection);
            rNew.m_dwChord = rCommand.m_dwChord;
            rCommandList.AddHead(pNew);
        }
    }
    for (; pPlayChord; pPlayChord = pPlayChord->GetNext())
    {
        PlayChord& rChord = pPlayChord->GetItemValue();
        TListItem<PlayChord>* pNew = new TListItem<PlayChord>;
        if (pNew)
        {
            PlayChord& rNew = pNew->GetItemValue();
            rNew.m_fSilent = rChord.m_fSilent;
            rNew.m_pChord = rChord.m_pChord;
            rNew.m_pNext = rChord.m_pNext;
            rNew.m_dwFlags = rChord.m_dwFlags;
            rNew.m_nMeasure = rChord.m_nMeasure + (short)nMeasure;
            rNew.m_nBeat = rChord.m_nBeat;
            rNew.m_nMinbeats = rChord.m_nMinbeats;
            rNew.m_nMaxbeats = rChord.m_nMaxbeats;
            rChordList.AddHead(pNew);
        }
    }
}

void InsertCommand(int nMeasure, int nLength, TList<TemplateCommand> &rCommandList, BYTE bCommand)

{
    // insert nLength bars before nMeasure
    nMeasure -= nLength;
    TListItem<TemplateCommand> *pTarget = NULL;
    TListItem<TemplateCommand> *pCommand = rCommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_nMeasure == nMeasure)
        {
            pTarget = pCommand;
        }
        // return if another command would interupt this one
        else if ( (rCommand.m_Command.bCommand || rCommand.m_Command.bGrooveLevel) &&
                  (rCommand.m_nMeasure > nMeasure) &&
                  (rCommand.m_nMeasure < nMeasure + nLength) )
        {
            return;
        }
    }
    if (pTarget)
    {
        pTarget->GetItemValue().m_Command.bCommand = bCommand;
    }
    else
    {
        pCommand = new TListItem<TemplateCommand>;
        if (pCommand)
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            rCommand.m_nMeasure = (short)nMeasure;
            rCommand.m_Command.bCommand = bCommand;
            rCommandList.AddHead(pCommand);
        }
    }
}

int WeightedRand(int nRange);

HRESULT CDMCompos::ComposePlayListFromShape(
                    long                    lNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicStyle*          pStyle,
                    WORD                        wActivity,
                    IDirectMusicChordMap*   pPersonality,
                    TList<TemplateCommand>& CommandList,
                    TList<PlayChord>&       PlayList
                )
{
    HRESULT hr = S_OK;
    TListItem<TemplateCommand>* pCommand = NULL;

    int nOriginalMeasures = 0;
    if (fComposeIntro)
    {
        lNumMeasures -= nIntroLength;
        if (lNumMeasures < 1)
        {
            lNumMeasures = 1;
        }
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        nOriginalMeasures = (int)lNumMeasures;
        lNumMeasures -= (nLength - 1);
        if (lNumMeasures < 1)
        {
            lNumMeasures = 1;
        }
    }
    TemplateStruct Template;
    TemplateStruct* apTempl[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    if ((wShape != DMUS_SHAPET_SONG) || (lNumMeasures <= 24))
    {
        if (wShape == DMUS_SHAPET_LOOPABLE) lNumMeasures++;
        Template.m_nMeasures = (short)lNumMeasures;
        Template.CreateSignPosts();
        Template.CreateEmbellishments(wShape, nFillLength, nBreakLength);
        if (wShape == DMUS_SHAPET_LOOPABLE)
        {
            lNumMeasures--;
            Template.m_nMeasures = (short)lNumMeasures;
        }
        ComposePlayList(PlayList, pStyle, pPersonality, Template.m_CommandList, wActivity);
    }
    else
    {
        short nShortestLength = 12; // initialized to longest value in sanLengths
        TListItem<TemplateCommand> *apCommands[8];
        TList<PlayChord> aPlayList[8];
        TListItem<PlayChord>* apChords[8];
        int anLengths[8];
        int anGrooveLevel[8];
        int anPlayCount[8];
        BYTE abLeadins[8];
        int nTypeCount = 2;
        unsigned int nSize = (unsigned int) lNumMeasures >> 5;
        int nTypeIndex;
        int nMeasure;
        int nChoice, nLastChoice;
        while (nSize)
        {
            nTypeCount++;
            nSize = nSize >> 1;
            if (nTypeCount >= 8) break;
        }
        for (nTypeIndex = 1; nTypeIndex < nTypeCount; nTypeIndex++)
        {
            static WORD awShapes[8] = {
                DMUS_SHAPET_FALLING, DMUS_SHAPET_LEVEL, DMUS_SHAPET_LOUD, DMUS_SHAPET_QUIET,
                DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM };
            static int anInitGroovels[8] = { 0,-1,0,0,1,-1,2,-2 };
            static BYTE abRiffs[8] = {
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK,
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL };
            static short sanLengths[10] = { 8,8,8,8,6,12,8,8,10,6 };
            short nLength = sanLengths[rand() % 10];

            apTempl[nTypeIndex] = new TemplateStruct;
            if (!apTempl[nTypeIndex])
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }

            apTempl[nTypeIndex]->m_nMeasures = nLength;
            anLengths[nTypeIndex] = nLength;
            if (nLength)
            {
                if (nShortestLength > nLength) nShortestLength = nLength;
                apTempl[nTypeIndex]->CreateSignPosts();
                apTempl[nTypeIndex]->CreateEmbellishments(awShapes[nTypeIndex], nFillLength, nBreakLength);
                ComposePlayList(
                    aPlayList[nTypeIndex], pStyle, pPersonality, apTempl[nTypeIndex]->m_CommandList, wActivity);
                apCommands[nTypeIndex] = apTempl[nTypeIndex]->m_CommandList.GetHead();
                apChords[nTypeIndex] = aPlayList[nTypeIndex].GetHead();
                anPlayCount[nTypeIndex] = 0;
                anGrooveLevel[nTypeIndex] = anInitGroovels[nTypeIndex];
                if (rand() % 4) abLeadins[nTypeIndex] = abRiffs[nTypeIndex];
                else abLeadins[nTypeIndex] = 0;
            }
            else
            {
                apCommands[nTypeIndex] = NULL;
            }
        }
        anPlayCount[0] = 1;
        anGrooveLevel[0] = 0;
        Template.m_nMeasures = (short)lNumMeasures;
        nMeasure = 0;
        nChoice = 1;
        nLastChoice = 0;
        for (; nMeasure < lNumMeasures; )
        {
            int nGroove;
            int nNewChoice;

            if ((lNumMeasures - nMeasure) <= nShortestLength)
            {
                nChoice = 0;
                short nLength = (short) (lNumMeasures - nMeasure);
                apTempl[0] = new TemplateStruct;
                if (!apTempl[0])
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_END;
                }
                apTempl[0]->m_nMeasures = nLength;
                anLengths[0] = nLength;
                apTempl[0]->CreateSignPosts();
                apTempl[0]->CreateEmbellishments(DMUS_SHAPET_FALLING, nFillLength, nBreakLength);
                ComposePlayList(
                    aPlayList[0], pStyle, pPersonality, apTempl[0]->m_CommandList, wActivity);
                apCommands[0] = apTempl[0]->m_CommandList.GetHead();
                apChords[0] = aPlayList[0].GetHead();
                anPlayCount[0] = 0;
                anGrooveLevel[0] = 0;
                if (rand() % 4) abLeadins[0] = DMUS_COMMANDT_FILL;
                else abLeadins[0] = 0;
            }
            nGroove = anGrooveLevel[nChoice];
            InsertStuff(nMeasure, apCommands[nChoice], apChords[nChoice],
                Template.m_CommandList, PlayList, nGroove);
            if ( (abLeadins[nChoice] == DMUS_COMMANDT_FILL && nMeasure >= nFillLength) )
            {
                InsertCommand(nMeasure, nFillLength, Template.m_CommandList, abLeadins[nChoice]);
            }
            else if ( (abLeadins[nChoice] == DMUS_COMMANDT_BREAK && nMeasure >= nBreakLength) )
            {
                InsertCommand(nMeasure, nBreakLength, Template.m_CommandList, abLeadins[nChoice]);
            }
            if (anGrooveLevel[nChoice] < 0) anGrooveLevel[nChoice]++;
            else
            {
                if (rand() % 3)
                {
                    if (rand() % 2)
                    {
                        anGrooveLevel[nChoice]++;
                    }
                    else
                    {
                        anGrooveLevel[nChoice]--;
                    }
                }
            }
            anPlayCount[nChoice]++;
            nMeasure += anLengths[nChoice];
            nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            if ((nNewChoice == nChoice) && (nNewChoice == nLastChoice))
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            if (nNewChoice == nChoice)
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            // If there are enough measures for some but not all of the
            // patterns, find a pattern that fits
            if ((lNumMeasures - nMeasure) > nShortestLength)
            {
                while ((lNumMeasures - nMeasure) < anLengths[nNewChoice])
                {
                    nNewChoice = WeightedRand(nTypeCount - 1) + 1;
                }
            }
            nLastChoice = nChoice;
            nChoice = nNewChoice;
        }
        Template.m_CommandList.MergeSort(Less);
        PlayList.MergeSort(Less);
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        if (lNumMeasures != nOriginalMeasures)
        {
            Template.m_nMeasures = (short)nOriginalMeasures;
        }
        if (nLength > nOriginalMeasures)
        {
            nLength = nOriginalMeasures;
        }
        Template.AddEnd(nLength);
    }
    if (fComposeIntro)
    {
        Template.AddIntro(PlayList, nIntroLength);
    }
    pCommand = Template.m_CommandList.GetHead();
    for(; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand || rCommand.m_Command.bGrooveLevel)
        {
            TListItem<TemplateCommand>* pNew = new TListItem<TemplateCommand>;
            if (!pNew)
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }
            pNew->GetItemValue().m_nMeasure = rCommand.m_nMeasure;
            pNew->GetItemValue().m_Command = rCommand.m_Command;
            pNew->GetItemValue().m_dwChord = rCommand.m_dwChord;
            CommandList.AddTail(pNew);
        }
    }

ON_END:
    for (short n = 0; n < 8; n++)
    {
        if (apTempl[n])
        {
            delete apTempl[n];
        }
    }
    return hr;
}


static short ChordMisses(DWORD dwScalePattern, DWORD dwChordPattern, char chRoot)

{
    short nErrors = 0;
    dwScalePattern &= 0xFFF;
    dwScalePattern |= (dwScalePattern << 12);
    while (chRoot < 0) chRoot += 12;
    while (chRoot > 11) chRoot -= 12;
    dwChordPattern = dwChordPattern << chRoot;
    for (short index = 0;index < 24;index++)
    {
        DWORD dwScaleBit = dwScalePattern & 1;
        DWORD dwChordBit = dwChordPattern & 1;
        dwScalePattern = dwScalePattern >> 1;
        dwChordPattern = dwChordPattern >> 1;
        if (dwChordBit && !dwScaleBit) nErrors++;
    }
    return(nErrors);
}

static short CompareSPToChord(DMSignPost& rSign,
                                DWORD dwLastScale,
                                DMChordData& rNextChord,
                                char chLastRoot)

{
    BYTE bLastRoot = chLastRoot % 12;
    short nResult = 50;
    if (rNextChord.Equals(rSign.m_ChordData))
    {
        nResult = 0;
    }
    else if (rSign.m_dwChords & DMUS_SIGNPOSTF_1)
    {
        nResult = 25;
    }

    if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_1)
    {
        DMChordData& rChord = rSign.m_aCadence[0];
        BYTE bOffset = rChord.GetRoot();
        if (bOffset < bLastRoot) bOffset += 12;
        nResult += ChordMisses(dwLastScale, rChord.GetChordPattern(), (bOffset - bLastRoot) % 12);
    }
    else if (rSign.m_dwFlags & DMUS_SPOSTCADENCEF_2)
    {
        DMChordData& rChord = rSign.m_aCadence[1];
        BYTE bOffset = rChord.GetRoot();
        if (bOffset < bLastRoot) bOffset += 12;
        nResult += ChordMisses(dwLastScale, rChord.GetChordPattern(), (bOffset - bLastRoot) % 12);
    }
    else nResult += 30;

    return (nResult);
}

static HRESULT ChordListFromSegment(TList<PlayChord>& ChordList, IDirectMusicSegment* pSeg,
                                 BYTE &bRoot, DWORD &dwScale)
{
    HRESULT             hr          = S_OK;
    IDirectMusicTrack*  pChordTrack = NULL;
    IPersistStream*     pPS         = NULL;
    IStream*            pStream     = NULL;

    // Get the segment's chord track.
    hr = pSeg->GetTrack(CLSID_DirectMusicChordTrack, ALL_TRACK_GROUPS, 0, &pChordTrack);
    if (S_OK != hr) goto ON_END;

    // Write the track to a stream, and read from the stream into a chord list.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (S_OK != hr) goto ON_END;
    hr = pPS->Save(pStream, FALSE);
    if (S_OK != hr) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    LoadChordList(ChordList, pStream, bRoot, dwScale);

ON_END:
    if (pStream) pStream->Release();
    if (pChordTrack) pChordTrack->Release();
    if (pPS) pPS->Release();
    return hr;
}

static void Clear(TList<PlayChord>& ChordList)
{
    for (TListItem<PlayChord>* pChord = ChordList.GetHead(); pChord; pChord = pChord->GetNext())
    {
        pChord->GetItemValue().m_pChord->Release();
        delete pChord->GetItemValue().m_pChord;
    }
}

static char TwelveToScale(DWORD dwPattern, char chRoot, char *pchOffset)

{
    char i;
    *pchOffset = 0;
    char chResult = -1;
    while (chRoot < 0) chRoot += 12;
    while (chRoot >= 24) chRoot -= 12;
    for (i=0;i<24;i++)
    {
        if ((dwPattern >> i) & 1)
        {
            chResult++;
            *pchOffset = 0;
        }
        else
        {
            *pchOffset = (char)( *pchOffset + 1 );
        }
        if (i == chRoot)
        {
            return(chResult);
        }
    }
    return(0);
}

static char ScaleToTwelve(DWORD dwPattern, char chRoot, char chOffset)

{
    char i;
    char chResult = 0;
    while (chRoot < 0) chRoot += 7;
    while (chRoot >= 14) chRoot -= 7;
    for (i=0;i<24;i++)
    {
        if ((dwPattern >> i) & 1)
        {
            if (chResult == chRoot) break;
            chResult++;
        }
    }
    i = (char)( i + chOffset );
    while (i >= 24) i -= 12;    // RSW: fix for bug 173304
    return(i);
}

/*HRESULT CDMCompos::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern)
{
    HRESULT hr = S_OK;
    // Get the segment's style track.
    IDirectMusicTrack* pStyleTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicStyleTrack, dwGroupBits, 0, &pStyleTrack);
    if (S_OK != hr && fTryPattern)
    {
        hr = pFromSeg->GetTrack(CLSID_DirectMusicPatternTrack, dwGroupBits, 0, &pStyleTrack);
    }
    if (S_OK != hr) return hr;
    // Get the style from the style track
    hr = pStyleTrack->GetParam(GUID_IDirectMusicStyle, mt, NULL, (void*) &rpStyle);
    pStyleTrack->Release();
    return hr;
}*/

HRESULT CDMCompos::GetStyle(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicStyle*& rpStyle, bool fTryPattern)
{
    HRESULT hr = pFromSeg->GetParam(GUID_IDirectMusicStyle, dwGroupBits, 0, mt, NULL, &rpStyle);
    if (S_OK != hr && fTryPattern)
    {
        hr = pFromSeg->GetParam(GUID_IDirectMusicPatternStyle, dwGroupBits, 0, mt, NULL, &rpStyle);
    }
    return hr;
}

HRESULT CDMCompos::GetPersonality(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, DWORD dwGroupBits, IDirectMusicChordMap*& rpPers)
{
    HRESULT hr = S_OK;
    // Get the segment's personality track.
    IDirectMusicTrack* pPersTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwGroupBits, 0, &pPersTrack);
    if (S_OK != hr) return hr;
    // Get the personality from the personality track
    hr = pPersTrack->GetParam(GUID_IDirectMusicChordMap, mt, NULL, (void*) &rpPers);
    pPersTrack->Release();
    return hr;
}

HRESULT GetTempo(IDirectMusicSegment* pFromSeg, MUSIC_TIME mt, double* pdblTempo)
{
    HRESULT hr = S_OK;
    // Get the segment's tempo track.
    IDirectMusicTrack* pTempoTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pTempoTrack);
    if (S_OK != hr) return hr;
    // Get the tempo from the tempo track
    DMUS_TEMPO_PARAM Tempo;
    hr = pTempoTrack->GetParam(GUID_TempoParam, mt, NULL, (void*) &Tempo);
    pTempoTrack->Release();
    if (SUCCEEDED(hr))
    {
        *pdblTempo = Tempo.dblTempo;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicComposer

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromTemplate | Creates an
original section segment from a style, ChordMap, and template.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and
<p ppSectionSeg> is an invalid pointer.
@flag E_INVALIDARG | Either <p pStyle> is NULL and there is no Style track, or <p pChordMap>
is NULL and there is no ChordMap track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL,
a Style is retrieved from <p pTempSeg>'s Style track.
Similarly, if <p pChordMap> is non-NULL, it is used in composing the segment; if it is
NULL, a ChordMap is retrieved from <p pTempSeg>'s ChordMap track.
The length of the section segment is equal to the length of the template section
passed in.
*/

/*
DX8 changes in track group bits, etc. (activated by dx8 content)
0. The signpost track is used to determine dwCompositionGroupBits.
1. Composed chords are placed in track groups dwCompositionGroupBits.
2. If a style is passed in, all style ref tracks in the composed segment are removed (as before).
   The new style is placed in the track group with the lowest value matching dwCompositionGroupBits.
   If a chord map is passed in, all chord map ref tracks in the composed segment are removed (as
   before).  The new chord map is placed in track groups dwCompositionGroupBits.
3. If the Style is pulled from a StyleRef track, the StyleRef tracks are copied from the template
   segment.  Ditto for chord maps.  The StyleRef track used is the first one that matches
   dwCompositionGroupBits.  Ditto for chord maps.
4. The groove track used is the first one that matches dwCompositionGroupBits.
5. The time signature of the style chosen to compose with is the one used to determine chord
   placement.
6. If there are no tempo tracks in the template segment, one is created in track groups
   dwCompositionGroupBits and the style's tempo is set to play at time 0.
7. If there are no band tracks in the template segment, one is created in track groups
   dwCompositionGroupBits and the style's default band is set to play at physical time -64,
   logical time 0.
8. Loops are handled correctly.
NOTE: Leaving other Composition methods as they are (they put everything in track group 1).  It's
easy enough to change things programmatically, and since these segments are all created from scratch,
they don't rely on existing behavior in segments.
*/

HRESULT CDMCompos::ComposeSegmentFromTemplate(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to create the section segment.
                    IDirectMusicSegment*        pTempSeg, // @parm The template from which to create the section segment.
                    WORD                        wActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**       ppSectionSeg // @parm Returns the created section segment.
            )
{
    return ComposeSegmentFromTemplateEx(
                pStyle,
                pTempSeg,
                (DMUS_COMPOSE_TEMPLATEF_ACTIVITY | DMUS_COMPOSE_TEMPLATEF_CLONE),
                wActivity,
                pChordMap,
                ppSectionSeg
        );

}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicComposer

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromTemplate | Creates an
original section segment from a style, ChordMap, and template.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or both of <p pTempSeg> and
<p ppSectionSeg> is an invalid pointer.
@flag E_INVALIDARG | Either <p pStyle> is NULL and there is no Style track, or <p pChordMap>
is NULL and there is no ChordMap track.

@comm If <p pStyle> is non-NULL, it is used in composing the segment; if it is NULL,
a Style is retrieved from <p pTempSeg>'s Style track.
Similarly, if <p pChordMap> is non-NULL, it is used in composing the segment; if it is
NULL, a ChordMap is retrieved from <p pTempSeg>'s ChordMap track.
The length of the section segment is equal to the length of the template section
passed in.
*/

HRESULT CDMCompos::ComposeSegmentFromTemplateEx(
                    IDirectMusicStyle*      pStyle, // @parm The style from which to create the section segment.
                    IDirectMusicSegment*    pTempSeg, // @parm The template from which to create the section segment.
                    DWORD                   dwFlags, // @parm Various composition options.
                    DWORD                   dwActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**   ppSectionSeg // @parm Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeSegmentFromTemplateEx)
    V_PTR_WRITE_OPT(pStyle, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTR_WRITE(pTempSeg, 1);
    V_PTRPTR_WRITE_OPT(ppSectionSeg);
    if ((dwFlags & DMUS_COMPOSE_TEMPLATEF_CLONE) && !ppSectionSeg)
    {
        Trace(1, "ERROR (ComposeSegmentFromTemplateEx): CLONE flag set but ppSectionSeg is NULL\n");
        return E_POINTER;
    }

    bool fUseActivity = (dwFlags & DMUS_COMPOSE_TEMPLATEF_ACTIVITY) ? true : false;
    bool fCloneSegment = (dwFlags & DMUS_COMPOSE_TEMPLATEF_CLONE) ? true : false;

    HRESULT hr = S_OK;
    DWORD dwGroupBitsRead = ALL_TRACK_GROUPS; // fallback to dx7 behavior
    DWORD dwGroupBitsWrite = 1; // fallback to dx7 behavior
    IDirectMusicTrack* pSignPostTrack = NULL;
    IDirectMusicTrack* pCommandTrack = NULL;
    IDirectMusicTrack* pChordMapTrack = NULL;

    EnterCriticalSection( &m_CriticalSection );

    // Look for a style and chord map, just to determine DX8 content
    BOOL fStyleFromTrack = FALSE;
    BOOL fPersFromTrack = FALSE;
    if (!pStyle)
    {
        if (FAILED(GetStyle(pTempSeg, 0, ALL_TRACK_GROUPS, pStyle, true)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a style.\n");
            hr = E_INVALIDARG;
        }
        else fStyleFromTrack = TRUE;
    }
    if (SUCCEEDED(hr) && !pChordMap)
    {
        if (FAILED(GetPersonality(pTempSeg, 0, ALL_TRACK_GROUPS, pChordMap)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a chord map.\n");
            hr = E_INVALIDARG;
        }
        else fPersFromTrack = TRUE;
    }

    // Get track group bits from the signpost track
    if (SUCCEEDED(hr))
    {
        HRESULT hrTemp = pTempSeg->GetTrack(CLSID_DirectMusicSignPostTrack, ALL_TRACK_GROUPS, 0, &pSignPostTrack);
        if (hrTemp == S_OK && UsingDX8(pStyle, pChordMap))
        {
            hrTemp = pTempSeg->GetTrackGroup(pSignPostTrack, &dwGroupBitsWrite);
            if (hrTemp != S_OK) dwGroupBitsWrite = ALL_TRACK_GROUPS; // now read, write are both ALL
            else dwGroupBitsRead = dwGroupBitsWrite;
        }
        else if (UsingDX8(pStyle, pChordMap)) // no signpost track, DX8 content
        {
            dwGroupBitsWrite = ALL_TRACK_GROUPS; // now read, write are both ALL
        }
    }

    // Now that we know the group bits, get a style and chord map that match them.
    if (SUCCEEDED(hr) && fStyleFromTrack)
    {
        pStyle->Release();
        pStyle = NULL;
        if (FAILED(GetStyle(pTempSeg, 0, dwGroupBitsRead, pStyle, true)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a style.\n");
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr) && fPersFromTrack)
    {
        pChordMap->Release();
        pChordMap = NULL;
        if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwGroupBitsRead, 0, &pChordMapTrack)))
        {
            Trace(1, "ERROR (ComposeSegmentFromTemplateEx): Failed to get a chordmap.\n");
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (FAILED(pTempSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwGroupBitsRead, 0, &pCommandTrack)))
        {
            // If there is no command track, use a NULL command track for ExtractCommandList
            pCommandTrack = NULL;
        }
    }

    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtLength = 0;
        pTempSeg->GetLength(&mtLength);
        TList<PlayChord> PlayList;
        BYTE bRoot = 0;
        DWORD dwScale = 0;
        hr = ComposePlayListFromTemplate(
            pStyle, pChordMap, pChordMapTrack, pSignPostTrack, pCommandTrack, dwGroupBitsRead,
            mtLength, fUseActivity, dwActivity, PlayList, bRoot, dwScale);

        if (SUCCEEDED(hr))
        {
            // Build a section segment from the playlist and command list.
            if (fCloneSegment)
            {
                hr = CopySegment(pTempSeg, ppSectionSeg, PlayList, pStyle, pChordMap, fStyleFromTrack, fPersFromTrack, dwGroupBitsWrite, bRoot, dwScale);
            }
            else
            {
                hr = AddToSegment(pTempSeg, PlayList, pStyle, dwGroupBitsWrite, bRoot, dwScale);
            }
            if (!PlayList.GetHead() && UsingDX8(pStyle, pChordMap))
            {
                hr = S_FALSE;
            }
        }
    }
    CleanUp();
    if (pSignPostTrack) pSignPostTrack->Release();
    if (pCommandTrack) pCommandTrack->Release();
    if (pChordMapTrack) pChordMapTrack->Release();
    if (fStyleFromTrack && pStyle) pStyle->Release();
    if (fPersFromTrack && pChordMap) pChordMap->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CDMCompos::ComposePlayListFromTemplate(IDirectMusicStyle* pStyle,
                                               IDirectMusicChordMap* pChordMap,
                                               IDirectMusicTrack* pChordMapTrack,
                                               IDirectMusicTrack* pSignPostTrack,
                                               IDirectMusicTrack* pCommandTrack,
                                               DWORD dwGroupBits,
                                               MUSIC_TIME mtLength,
                                               bool fUseActivity,
                                               DWORD dwActivity,
                                               TList<PlayChord>& rPlayList,
                                               BYTE& rbRoot,
                                               DWORD& rdwScale)
{
    HRESULT hr = S_OK;
    // Note: assumes time signature doesn't change.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    if (!TimeSig.bBeatsPerMeasure) TimeSig.bBeatsPerMeasure = 4;
    if (!TimeSig.bBeat) TimeSig.bBeat = 4;
    // tics  per bar
    MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
    // To find the beat to place a second chord in a measure, divide by 2 and round up
    int nSecondBeat = TimeSig.bBeatsPerMeasure / 2;
    if (nSecondBeat * 2 != TimeSig.bBeatsPerMeasure) nSecondBeat++;
    // Get the command list from the template segment.
    TList<TemplateCommand> CommandList;
    ExtractCommandList(CommandList, pSignPostTrack, pCommandTrack, dwGroupBits);
    // For each chordmap in the chordmap track, compose a playlist from only the commands
    // in the range of the chordmap
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    HRESULT hrChordMap = S_OK;
    IDirectMusicChordMap* pLastChordMap = NULL;
    while (SUCCEEDED(hrChordMap) && SUCCEEDED(hr) && mtNext < mtLength)
    {
        bool fChordMapPassedIn = false;
        if (!pChordMap)
        {
            if (pChordMapTrack)
            {
                hrChordMap = pChordMapTrack->GetParam(GUID_IDirectMusicChordMap, mtNow, &mtNext, (void*) &pChordMap);
                if (!mtNext) mtNext = mtLength;
                else mtNext += mtNow;
            }
            else
            {
                Trace(1, "ERROR: No chord map track to use for chord composition.\n");
                hr = hrChordMap = E_POINTER;
            }
        }
        else // a chordmap got passed in; make sure it's the only one we use
        {
            mtNext = mtLength;
            fChordMapPassedIn = true;
        }
        if (SUCCEEDED(hrChordMap))
        {
            if (!mtNow)
            {
                pChordMap->GetScale(&rdwScale);
                rbRoot = (BYTE) (rdwScale >> 24);
                rdwScale &= 0xffffff;
            }
            // get the commands in the range of this chordmap.
            TList<TemplateCommand> CurrentCommandList;
            TListItem<TemplateCommand>* pScan = CommandList.GetHead();
            for (; pScan; pScan = pScan->GetNext())
            {
                TemplateCommand& rScan = pScan->GetItemValue();
                MUSIC_TIME mtScanBar = rScan.m_nMeasure * mtBar;
                if ( mtScanBar >= mtNow && mtScanBar < mtNext )
                {
                    TListItem<TemplateCommand>* pNew = new  TListItem<TemplateCommand>;
                    if (pNew)
                    {
                        pNew->GetItemValue() = rScan;
                        CurrentCommandList.AddTail(pNew);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                // Compose a playlist for this chordmap.
                TList<PlayChord> CurrentPlayList; // playlist for this chordmap.
                if (fUseActivity)
                {
                    ComposePlayList(CurrentPlayList, pStyle, pChordMap, CurrentCommandList, (WORD)dwActivity);
                }
                else
                {
                    ComposePlayList2(CurrentPlayList, pStyle, pChordMap, CurrentCommandList);
                }
                // if we're past the first bar, compose a cadence to the first chord
                // of the current playlist via a call to ChooseSignPost (using the last
                // chordmap) and add it to the current playlist.
                int nCurrentBar = mtNow / mtBar;
                if (rPlayList.GetHead() && nCurrentBar &&  pLastChordMap)
                {
                    DWORD dwScale = 0;
                    pLastChordMap->GetScale(&dwScale);
                    BYTE bRoot = (BYTE) (dwScale >> 24);
                    dwScale &= 0xffffff;
                    int nBar = nCurrentBar - 1;
                    bool fCadence1 = false;
                    bool fCadence2 = false;
                    TListItem<DMSignPost> *pSignChoice = NULL;
                    if (CurrentPlayList.GetHead())
                    {
                        DMChordData* pFirstChord = CurrentPlayList.GetHead()->GetItemValue().m_pChord;
                        pSignChoice = ChooseSignPost(pChordMap, pFirstChord, false, dwScale, bRoot);
                    }
                    else
                    {
                        pSignChoice = ChooseSignPost(pChordMap, NULL, true, dwScale, bRoot);
                    }
                    if (pSignChoice)
                    {
                        DMSignPost& rSignChoice = pSignChoice->GetItemValue();
                        fCadence1 = (rSignChoice.m_dwFlags & DMUS_SPOSTCADENCEF_1) ? true : false;
                        fCadence2 = (rSignChoice.m_dwFlags & DMUS_SPOSTCADENCEF_2) ? true : false;
                        if (fCadence1)
                        {
                            AddChord( CurrentPlayList, &rSignChoice.m_aCadence[0], nBar, 0 );
                        }
                        if (fCadence2)
                        {
                            int nBeat = fCadence1 ? nSecondBeat : 0;
                            AddChord( CurrentPlayList, &rSignChoice.m_aCadence[1], nBar, nBeat );
                        }
                    }
                }
                // Add the current playlist to the end of the master playlist.
                rPlayList.AddTail(CurrentPlayList.GetHead());
                CurrentPlayList.RemoveAll();
            }
            // clear out the chord map for the next iteration
            if (pLastChordMap) pLastChordMap->Release();
            pLastChordMap = pChordMap;
            if (pLastChordMap) pLastChordMap->AddRef();
            if (!fChordMapPassedIn) pChordMap->Release();
            pChordMap = NULL;
        }
        mtNow = mtNext;
    }
    if (pLastChordMap) pLastChordMap->Release();
    return hr;
}


/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeSegmentFromShape |  Creates
an original section segment from a style and ChordMap based on a predefined shape.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pStyle>, <p pChordMap>, and <p ppSectionSeg>
is an invalid pointer.

@comm Creates an original section segment from a style and a ChordMap based on a
predefined shape.  Shapes (passed in <p wShape>) represent the way chords and embellishments
occur over time across the section.  There are nine shapes:

  @flag DMUS_SHAPET_FALLING | The section gets quieter over time.
  @flag DMUS_SHAPET_LEVEL   | The section remains at the same level.
  @flag DMUS_SHAPET_LOOPABLE | The section is arranged to loop back to its beginning.
  @flag DMUS_SHAPET_LOUD    | The section remains loud.
  @flag DMUS_SHAPET_QUIET   | The section remains quiet.
  @flag DMUS_SHAPET_PEAKING | The section peaks.
  @flag DMUS_SHAPET_RANDOM | The section is random.
  @flag DMUS_SHAPET_RISING | The section builds over time.
  @flag DMUS_SHAPET_SONG | The section is in a song form.

*/

HRESULT CDMCompos::ComposeSegmentFromShape(
                    IDirectMusicStyle*          pStyle, // @parm The style from which to compose the section segment.
                    WORD                        wNumMeasures, // @parm The length, in measures, to compose the section segment.
                    WORD                        wShape, // @parm The shape to compose the section segment.
                    WORD                        wActivity, // @parm Specifies the rate of harmonic motion; valid values are 0 through 3.
                    BOOL                        fComposeIntro, // @parm TRUE if an intro is to be composed for the section segment.
                    BOOL                        fComposeEnding, // @parm TRUE if an ending is to be composed for the section segment.
                    IDirectMusicChordMap*   pChordMap, // @parm The ChordMap from which to create the section segment.
                    IDirectMusicSegment**       ppSectionSeg // @parm Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeSegmentFromShape)
    V_PTR_WRITE(pStyle, 1);
    V_PTR_WRITE(pChordMap, 1);
    V_PTRPTR_WRITE(ppSectionSeg);

    EnterCriticalSection( &m_CriticalSection );

    int nIntroLength = 1;
    int nFillLength = 1;
    int nBreakLength = 1;
    int nEndLength = 1;

    // Get the maximum ending length from the style.
    DWORD dwMin, dwMax;
    HRESULT hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_END, 0, &dwMin, &dwMax);
    if (FAILED(hr)) // remain consistent with old behavior and fail.
    {
        LeaveCriticalSection( &m_CriticalSection );
        return hr;
    }
    if (hr == S_OK) nEndLength = (int) dwMax;
    if ( UsingDX8(pStyle) )
    {
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, 0, &dwMin, &dwMax);
        if (hr == S_OK) nIntroLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_FILL, 0, &dwMin, &dwMax);
        if (hr == S_OK) nFillLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_BREAK, 0, &dwMin, &dwMax);
        if (hr == S_OK) nBreakLength = (int) dwMax;
    }

    if (wNumMeasures & 0x8000 || wNumMeasures == 0)  wNumMeasures = 1;
    int nNumMeasures = wNumMeasures;
    if (wShape != DMUS_SHAPET_FALLING &&
        wShape != DMUS_SHAPET_LEVEL &&
        wShape != DMUS_SHAPET_LOOPABLE &&
        wShape != DMUS_SHAPET_LOUD &&
        wShape != DMUS_SHAPET_QUIET &&
        wShape != DMUS_SHAPET_PEAKING &&
        wShape != DMUS_SHAPET_RANDOM &&
        wShape != DMUS_SHAPET_RISING &&
        wShape != DMUS_SHAPET_SONG)
    {
        wShape = DMUS_SHAPET_RANDOM;
    }

    if (fComposeIntro)
    {
        if (nIntroLength <= 0) nIntroLength = 1;
        if ( nIntroLength >= nNumMeasures )
        {
            nNumMeasures = nIntroLength;
        }
    }
    if (fComposeEnding)
    {
        if (nEndLength <= 0) nEndLength = 1;
        if ( nEndLength >= nNumMeasures )
        {
            nNumMeasures = nEndLength;
            if (fComposeIntro) nNumMeasures += nIntroLength;
        }
    }

    // Compose playlists for sections of the segment.
    TList<TemplateCommand> CommandList;
    TList<PlayChord> PlayList;
    hr = ComposePlayListFromShape(
        nNumMeasures, wShape, fComposeIntro, fComposeEnding,
        nIntroLength, nFillLength, nBreakLength, nEndLength, pStyle, wActivity,
        pChordMap, CommandList, PlayList);
    if (SUCCEEDED(hr))
    {
        // Build a segment from the resulting command lists and playlists.
        BYTE bRoot = 0;
        DWORD dwScale;
        pChordMap->GetScale(&dwScale);
        bRoot = (BYTE) (dwScale >> 24);
        dwScale &= 0xffffff;
        hr = BuildSegment(CommandList, PlayList, pStyle, pChordMap, nNumMeasures, ppSectionSeg, bRoot, dwScale);
        CleanUp();
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT GetCommandList(IDirectMusicSegment* pFromSeg, TList<TemplateCommand>& CommandList)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack* pCommandTrack;
    hr = pFromSeg->GetTrack(CLSID_DirectMusicCommandTrack, ALL_TRACK_GROUPS, 0, &pCommandTrack);
    if (S_OK != hr) return hr;
    // Write the track to a stream, and read from the stream into a command list.
    IPersistStream* pPS;
    IStream *pStream;
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK == hr)
    {
        hr = pCommandTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
        if (S_OK == hr)
        {
            hr = pPS->Save(pStream, FALSE);
            if (S_OK == hr)
            {
                StreamSeek(pStream, 0, STREAM_SEEK_SET);
                LoadCommandList(CommandList, pStream);
            }
            pPS->Release();
        }
        pStream->Release();
    }
    pCommandTrack->Release();
    return hr;
}

// New flags:
// DMUS_COMPOSEF_ENTIRE_TRANSITION: play the transition pattern in its entirety.
// DMUS_COMPOSEF_1BAR_TRANSITION: play one bar of the the transition pattern.
// the following two are ignored unless DMUS_COMPOSEF_LONG is set:
// DMUS_COMPOSEF_ENTIRE_ADDITION: play the additional pattern in its entirety.
// DMUS_COMPOSEF_1BAR_ADDITION: play one bar of the additional pattern.
// Default behavior will be the same as dx7:
// DMUS_COMPOSEF_1BAR_TRANSITION unless pattern is an ending
// DMUS_COMPOSEF_1BAR_ADDITION always

// Used by both ComposeTransition and AutoTransition
HRESULT CDMCompos::TransitionCommon(
    IDirectMusicStyle*      pFromStyle,
    IDirectMusicBand*       pCurrentBand,
    double*                 pdblFromTempo,
    DMUS_COMMAND_PARAM_2&   rFromCommand,
    DMUS_CHORD_PARAM&       rLastChord,
    DMUS_CHORD_PARAM&       rNextChord,

    IDirectMusicSegment*    pToSeg,
    WORD                    wCommand,
    DWORD                   dwFlags,
    IDirectMusicChordMap*   pChordMap,
    IDirectMusicGraph*      pFromGraph,
    IDirectMusicGraph*      pToGraph,
    IUnknown*               pFromPath,
    IUnknown*               pToPath,
    IDirectMusicSegment**   ppSectionSeg
            )
{
    IDirectMusicGraph* pGraph = NULL;
    IUnknown* pPath = NULL;
    BYTE bRoot = rLastChord.bKey;
    DWORD dwScale = rLastChord.dwScale;
    DMChordData LastChord = rLastChord;
    DMChordData NextChord = rNextChord;
    HRESULT hr = S_OK;

    bool fLong = (dwFlags & DMUS_COMPOSEF_LONG) ? true : false;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fEntireTransition = false;
    if ((dwFlags & DMUS_COMPOSEF_ENTIRE_TRANSITION) ||
        (fEnding && !(dwFlags & DMUS_COMPOSEF_1BAR_TRANSITION)))
    {
        fEntireTransition = true;
    }
    bool fEntireAddition = (dwFlags & DMUS_COMPOSEF_ENTIRE_ADDITION) ? true : false;
    bool fAlign = (dwFlags & DMUS_COMPOSEF_ALIGN) ? true : false;

    // Get the ending segment's style
    IDirectMusicStyle* pToStyle = NULL;
    if (pToSeg)
    {
        hr = GetStyle(pToSeg, 0, ALL_TRACK_GROUPS, pToStyle, false);
        if (FAILED(hr)) pToStyle = NULL;
    }
    if (!pToStyle && !pFromStyle) // Not much to do...
    {
        *ppSectionSeg = NULL;
        return S_OK;
    }

    // Get tempo from the end segment.  This will be passed into BuildSegment.
    double dblFromTempo = 120.0;
    double dblToTempo = 120.0;
    double* pdblToTempo = &dblToTempo;
    if (pdblFromTempo)
    {
        dblFromTempo = *pdblFromTempo;
    }
    // If there is no To tempo, set it to the From tempo (or keep it at the fallback).
    if (!pToSeg || FAILED(GetTempo(pToSeg, 0, &dblToTempo)))
    {
        if (pdblFromTempo) dblToTempo = dblFromTempo; // otherwise use fallback of 120
    }
    // If there is no From tempo, set it to the To tempo.
    if (!pdblFromTempo)
    {
        dblFromTempo = dblToTempo;
        pdblFromTempo = &dblFromTempo;
    }

    EnterCriticalSection( &m_CriticalSection );

    // Extract the starting style's time signature.
    DMUS_TIMESIGNATURE FromTimeSig;
    if (pFromStyle)
    {
        pFromStyle->GetTimeSignature(&FromTimeSig);
    }
    else
    {
        FromTimeSig.bBeat = 4;
        FromTimeSig.bBeatsPerMeasure = 4;
        FromTimeSig.wGridsPerBeat = 4;
        FromTimeSig.mtTime = 0;
    }
    // Extract the ending style's time signature.
    DMUS_TIMESIGNATURE ToTimeSig;
    if (pToStyle)
    {
        pToStyle->GetTimeSignature(&ToTimeSig);
    }
    else
    {
        ToTimeSig.bBeat = 4;
        ToTimeSig.bBeatsPerMeasure = 4;
        ToTimeSig.wGridsPerBeat = 4;
        ToTimeSig.mtTime = 0;
    }
    if (!ToTimeSig.bBeatsPerMeasure) ToTimeSig.bBeatsPerMeasure = 4;
    // To find the beat to place a second chord in a measure, divide by 2 and round up
    int nSecondBeat = ToTimeSig.bBeatsPerMeasure / 2;
    if (nSecondBeat * 2 != ToTimeSig.bBeatsPerMeasure) nSecondBeat++;
    MUSIC_TIME mtIntro = 0;
    TList<PlayChord> PlayList;
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (!pCommand)
    {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }
    TListItem<TemplateCommand> *pLast = pCommand;
    // Intros get their chords when adding commands
    if (wCommand != DMUS_COMMANDT_INTRO)
    {
        if ( fModulate )
        {
            bool fCadence1 = false;
            bool fCadence2 = false;
            TListItem<DMSignPost> *pSignChoice = ChooseSignPost(pChordMap, &NextChord, fEnding, dwScale, bRoot);
            if (pSignChoice)
            {
                fCadence1 = (pSignChoice->GetItemValue().m_dwFlags & DMUS_SPOSTCADENCEF_1) ? true : false;
                fCadence2 = (pSignChoice->GetItemValue().m_dwFlags & DMUS_SPOSTCADENCEF_2) ? true : false;
            }
            if (fCadence1 || fCadence2)
            {
                if ( fCadence1 && (fLong || !fEnding || !fCadence2) )
                {
                    AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[0], 0, 0 );
                }
                else
                {
                    AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 0, 0 );
                }
                if (fCadence1 && fCadence2)
                {
                    if (fLong == fEnding)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 0, nSecondBeat );
                    }
                    if (fLong && !fEnding)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_aCadence[1], 1, 0 );
                    }
                }
                if ( fEnding )
                {
                    if (fLong)
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_ChordData, 1, 0 );
                    }
                    else
                    {
                        AddChord( PlayList, &pSignChoice->GetItemValue().m_ChordData, 0, nSecondBeat );
                    }
                }
            }
            else
            {
                AddChord( PlayList, &LastChord, 0 , 0 );
            }
        }
        else
        {
            AddChord( PlayList, &LastChord, 0 , 0 );
        }
    }
    int nLength = 0;
    int nPreIntro = 0;
    if (pCommand)
    {
        DWORD dwMax = 1;
        DWORD dwMin;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_Command.bCommand = rFromCommand.bCommand;
        rCommand.m_Command.bGrooveLevel = rFromCommand.bGrooveLevel;
        rCommand.m_Command.bGrooveRange = rFromCommand.bGrooveRange;
        rCommand.m_Command.bRepeatMode = rFromCommand.bRepeatMode;
        rCommand.m_nMeasure = 0;
        if (pFromStyle)
        {
            if (wCommand != DMUS_COMMANDT_INTRO)
            {
                WORD wTempCommand = wCommand;
                if ( wCommand == DMUS_COMMANDT_END || wCommand == DMUS_COMMANDT_ENDANDINTRO )
                {
                    wTempCommand = DMUS_COMMANDT_END;
                }
                if (fEntireTransition)
                {
                    HRESULT hrTemp = pFromStyle->GetEmbellishmentLength(wTempCommand, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                    if (hrTemp != S_OK) dwMax = 1;
                    nLength = dwMax;
                }
                else
                {
                    nLength = 1;
                }
            }
            if ( fLong )
            {
                if (fEntireAddition)
                {
                    HRESULT hrTemp = pFromStyle->GetEmbellishmentLength(DMUS_COMMANDT_GROOVE, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                    if (hrTemp != S_OK) dwMax = 1;
                }
                else
                {
                    dwMax = 1;
                }
                nLength += dwMax;
                if (wCommand == DMUS_COMMANDT_GROOVE && UsingDX8(pFromStyle)) // Just have one long groove.
                {
                    rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                }
                else if (wCommand != DMUS_COMMANDT_INTRO)
                {
                    TListItem<TemplateCommand> *pSecond = new TListItem<TemplateCommand>;
                    if (pSecond)
                    {
                        TemplateCommand& rSecond = pSecond->GetItemValue();
                        rSecond.m_nMeasure = (short) dwMax;
                        if (wCommand == DMUS_COMMANDT_ENDANDINTRO)
                        {
                            rSecond.m_Command.bCommand = DMUS_COMMANDT_END;
                        }
                        else
                        {
                            rSecond.m_Command.bCommand = (BYTE)wCommand;
                        }
                        rSecond.m_Command.bGrooveLevel = 0;
                        rSecond.m_Command.bGrooveRange = 0;
                        rSecond.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                        pLast->SetNext(pSecond);
                        pLast = pSecond;
                    }
                }
            }
            else if (wCommand != DMUS_COMMANDT_INTRO)
            {
                if (wCommand == DMUS_COMMANDT_ENDANDINTRO)
                {
                    rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
                }
                else
                {
                    rCommand.m_Command.bCommand = (BYTE)wCommand;
                }
            }
        }
        if ( pToStyle && fHasIntro)
        {
            nPreIntro = nLength;
            if (fEntireTransition)
            {
                // Check that this is the correct thing to do if pFromStyle is NULL.
                HRESULT hrTemp = pToStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, rFromCommand.bGrooveLevel, &dwMin, &dwMax);
                if (hrTemp != S_OK) dwMax = 1;
                nLength += dwMax;
            }
            else
            {
                nLength++;
            }
            AddChord( PlayList, &NextChord, nPreIntro , 0 );
            if ( nPreIntro > 0 )
            {
                if (wCommand == DMUS_COMMANDT_INTRO) AddChord( PlayList, &LastChord, 0 , 0 );
                TListItem<TemplateCommand> *pSecond = new TListItem<TemplateCommand>;
                if (pSecond)
                {
                    TemplateCommand& rSecond = pSecond->GetItemValue();
                    rSecond.m_nMeasure = (short)nPreIntro;
                    rSecond.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                    rSecond.m_Command.bGrooveLevel = 0;
                    rSecond.m_Command.bGrooveRange = 0;
                    rSecond.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                    pLast->SetNext(pSecond);
                }
            }
            else
            {
                rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
            }
        }
    }
    TList<TemplateCommand> CommandList2;
    CommandList2.Cat(pCommand);
    *ppSectionSeg = NULL;
    if (fHasIntro && !fEnding && UsingDX8(pToStyle))
    {
        pGraph = pToGraph;
        pPath = pToPath;
    }
    else if (UsingDX8(pFromStyle))
    {
        pGraph = pFromGraph;
        pPath = pFromPath;
    }
    if (fHasIntro)
    {
        if (pFromStyle)
        {
            hr = BuildSegment(CommandList2, PlayList, pFromStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblFromTempo, pCurrentBand, fAlign, pGraph, pPath);
            if (SUCCEEDED(hr) && pToStyle)
            {
                mtIntro = ClocksPerMeasure(FromTimeSig) * nPreIntro;
                IDirectMusicTrack* pStyleTrack;
                hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicStyleTrack, ALL_TRACK_GROUPS, 0, &pStyleTrack);
                if (SUCCEEDED(hr))
                {
                    pStyleTrack->SetParam(GUID_IDirectMusicStyle, mtIntro, (void*) pToStyle);
                    pStyleTrack->Release();
                }
                IDirectMusicTrack* pTempoTrack;
                hr = (*ppSectionSeg)->GetTrack(CLSID_DirectMusicTempoTrack, ALL_TRACK_GROUPS, 0, &pTempoTrack);
                if (SUCCEEDED(hr))
                {
                    DMUS_TEMPO_PARAM tempo;
                    tempo.mtTime = mtIntro;
                    tempo.dblTempo = dblToTempo;
                    pTempoTrack->SetParam(GUID_TempoParam, mtIntro, (void*) &tempo);
                    pTempoTrack->Release();
                }
                // I also need to add a band (from the To segment) to the band track at the appropriate time...
                if ( UsingDX8(pToStyle) )
                {
                    if (mtIntro == 0) // Intro is the first thing to play; don't need any other bands
                    {
                        (*ppSectionSeg)->SetParam(GUID_Clear_All_Bands, ALL_TRACK_GROUPS, 0, 0, NULL);
                    }
                    DMUS_BAND_PARAM DMBand;
                    if (pToSeg && SUCCEEDED(pToSeg->GetParam(GUID_BandParam, ALL_TRACK_GROUPS, DMUS_SEG_ANYTRACK, 0, NULL, (void*)&DMBand)))
                    {
                        DMBand.mtTimePhysical = mtIntro;
                        (*ppSectionSeg)->SetParam(GUID_BandParam, ALL_TRACK_GROUPS, 0, mtIntro, (void*)&DMBand);
                        DMBand.pBand->Release();
                    }
                }
                // readjust the length to account for differences in the two styles's time signatures
                if ( nLength > nPreIntro && (UsingDX8(pFromStyle) || UsingDX8(pToStyle)) )
                {
                    MUSIC_TIME mtNewLength = mtIntro + ((nLength - nPreIntro) * ClocksPerMeasure(ToTimeSig));
                    (*ppSectionSeg)->SetLength(mtNewLength);
                }
            }
        }
        else if (pToStyle)
        {
            hr = BuildSegment(CommandList2, PlayList, pToStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblToTempo, pCurrentBand, fAlign, pGraph, pPath);
        }
    }
    else if (pFromStyle)
    {
        hr = BuildSegment(CommandList2, PlayList, pFromStyle, pChordMap, nLength, ppSectionSeg, bRoot, dwScale, pdblFromTempo, pCurrentBand, fAlign, pGraph, pPath);
    }
    else
    {
        hr = S_OK; // don't build anything, but return OK
    }
    CommandList2.RemoveAll();
    TListItem<TemplateCommand>::Delete(pCommand);
    if (pToStyle) pToStyle->Release();
    CleanUp();
    NextChord.Release();
    LastChord.Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

TListItem<DMSignPost>* CDMCompos::ChooseSignPost(
            IDirectMusicChordMap* pChordMap,
            DMChordData* pNextChord,
            bool fEnding,
            DWORD dwScale,
            BYTE bRoot)
{
    if (!fEnding && !pNextChord) return NULL;
    DMPersonalityStruct* pPers = NULL;
    if (pChordMap)
    {
        IDMPers* pDMP;
        if (FAILED(pChordMap->QueryInterface(IID_IDMPers, (void**)&pDMP))) return NULL;
        pDMP->GetPersonalityStruct((void**)&pPers);
        pDMP->Release();
    }
    if (!pPers) return NULL;

    TList<DMSignPost> &SignPostList = pPers->m_SignPostList;
    TListItem<DMSignPost> *pSign = SignPostList.GetHead();
    TListItem<DMSignPost> *pSignChoice = pSign;
    int nMin = 100;
    int nHit = 100;
    int nMatches = 0;
    if (fEnding)
    {
        for (;pSign; pSign = pSign->GetNext())
        {
            if ( (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1) )
            {
                pSignChoice = pSign;
                nMatches = 0;
                for (; pSign; pSign = pSign->GetNext())
                {
                    if (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1) nMatches++;
                }
                break;
            }
        }
    }
    else
    {
        DMChordData& rNextChord = *pNextChord;
        for (;pSign; pSign = pSign->GetNext())
        {
            nHit = CompareSPToChord(pSign->GetItemValue(), dwScale, rNextChord, (char) bRoot);
            if (nHit == nMin) nMatches++;
            else if (nHit < nMin)
            {
                nMin = nHit;
                pSignChoice = pSign;
                nMatches = 1;
            }
        }
    }
    // Pick a winning signpost at random
    pSign = pSignChoice;
    if (nMatches) nMatches = rand() % nMatches;
    for (int i = 0; i <= nMatches && pSign; pSign = pSign->GetNext())
    {
        if (fEnding)
        {
            if (pSign->GetItemValue().m_dwChords & DMUS_SIGNPOSTF_1)
            {
                i++;
                pSignChoice = pSign;
            }
        }
        else
        {
            DMChordData& rNextChord = *pNextChord;
            nHit = CompareSPToChord(pSign->GetItemValue(), dwScale, rNextChord, (char) bRoot);
            if (nHit == nMin)
            {
                i++;
                pSignChoice = pSign;
            }
        }
    }
    // If the signpost that was found doesn't match the chord we're going to, discard it
    if (!fEnding &&
        pSignChoice &&
        (!(*pNextChord).Equals(pSignChoice->GetItemValue().m_ChordData)))
    {
        pSignChoice = NULL;
    }
    return pSignChoice;
}

IDirectMusicGraph* CDMCompos::CloneSegmentGraph(IDirectMusicSegment* pSegment)
{
    if (!pSegment)
    {
        return NULL;
    }
    IDirectMusicGraph* pGraph = NULL;
    HRESULT hr = pSegment->GetGraph(&pGraph);
    if (FAILED(hr) || !pGraph)
    {
        return NULL;
    }
    IGraphClone *pGraph8 = NULL;
    hr = pGraph->QueryInterface(IID_IGraphClone, (void**)&pGraph8);
    pGraph->Release();
    if (FAILED(hr) || !pGraph8)
    {
        return NULL;
    }
    hr = pGraph8->Clone(&pGraph);
    pGraph8->Release();
    if (SUCCEEDED(hr))
    {
        return pGraph;
    }
    else
    {
        return NULL;
    }
}

IUnknown* CDMCompos::GetSegmentAudioPath(IDirectMusicSegment* pSegment, DWORD dwFlags, DWORD* pdwAudioPath)
{
    if (!pSegment)
    {
        return NULL;
    }
    if (!(dwFlags & DMUS_COMPOSEF_USE_AUDIOPATH))
    {
        DWORD dwDefault = 0;
        pSegment->GetDefaultResolution(&dwDefault);
        if ( pdwAudioPath && (dwDefault & DMUS_SEGF_USE_AUDIOPATH) )
        {
            *pdwAudioPath = DMUS_SEGF_USE_AUDIOPATH;
        }
        return NULL;
    }
    IUnknown* pPath = NULL;
    IDirectMusicSegment8* pSeg8 = NULL;
    HRESULT hr = pSegment->QueryInterface(IID_IDirectMusicSegment8, (void**)&pSeg8);
    if (FAILED(hr)) return NULL;
    hr = pSeg8->GetAudioPathConfig(&pPath);
    pSeg8->Release();
    if (FAILED(hr) || !pPath)
    {
        return NULL;
    }
    else
    {
        return pPath;
    }
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeTransition |  Composes a
transition from inside one section segment to another segment.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pFromSeg>, <p pToSeg> and <p ppSectionSeg>
is not a valid pointer.
@flag E_INVALIDARG | <p pToSeg> is NULL and
  DMUS_COMPOSEF_MODULATE is set in <p dwFlags>.
@flag E_OUTOFMEMORY | An attempt to allocate memory failed.

@comm Allowable values for <p dwFlags> are:

  @flag DMUS_COMPOSEF_LONG | Composes a long transition.  If the flag is not included, the length
  of the transition is the combined lengths of valid embellishments specified by <p wCommand>.
  If the flag is included and <p pFromSeg> is non-null, the length of the transition
  increases by 1.
  @flag DMUS_COMPOSEF_MODULATE | Composes a transition that modulates smoothly from
  <p pFromSeg> to <p pToSeg>.
  @flag DMUS_COMPOSEF_ALIGN | Align transition to the time signature of the currently playing
    segment.
  @flag DMUS_COMPOSEF_OVERLAP | Overlap the transition into <p pToSeg>.


  <p pToSeg> may be NULL, as long as
  <p dwFlags> does not include DMUS_COMPOSEF_MODULATE.
  If <p pToSeg> is NULL or doesn't contain a style track, intro embellishments are not valid.
  If <p pFromSeg> is NULL or doesn't contain a style track,
  fill, break, end, and groove embellishments are not valid.
  Note that the above implies that it is possible for both <p pFromSeg> and <p pToSeg> to be
  NULL or to be
  segments that don't contain style tracks.  If so, all embellishments are invalid.  When all
  embellishments are invalid, a NULL transition segment is returned.

  <p pChordMap> may be NULL.  If so, an attempt is made to obtain a ChordMap from a
  ChordMap track, first from <p pToSeg>, and then from <p pFromSeg>.  If neither of these
  segments contains a ChordMap track, the chord occuring at <p mtTime> in <p pFromSeg> is
  used as the chord in the transition.
*/

HRESULT CDMCompos::ComposeTransition(
    IDirectMusicSegment*    pFromSeg, // @parm
                            // The section from which to compose the transition.
    IDirectMusicSegment*    pToSeg,  // @parm
                            // The section to which the transition should smoothly flow.
    MUSIC_TIME              mtTime, // @parm
                            // The time in <p pFromSeg> from which to compose the transition.
    WORD                    wCommand, // @parm
                            // The embellishment to use when composing the transition.
                            // DMUS_COMMANDT_ENDANDINTRO means compose a segment containing
                            // an end to <p pFromSeg> and an intro to <p pToSeg>.
    DWORD                   dwFlags, // @parm
                            // Various composition options.
    IDirectMusicChordMap* pChordMap, // @parm
                             // The ChordMap to be used when composing the transition.
    IDirectMusicSegment**   ppSectionSeg // @parm
                            // Returns the created section segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeTransition)
    V_PTR_WRITE_OPT(pToSeg, 1);
    V_PTR_WRITE_OPT(pFromSeg, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTRPTR_WRITE(ppSectionSeg);
    HRESULT hr = S_OK;
    bool fHaveChordMap = pChordMap ? true : false;

    DWORD dwGroupBits = ALL_TRACK_GROUPS;
    DWORD dwIndex = DMUS_SEG_ANYTRACK;

    bool fLong = (dwFlags & DMUS_COMPOSEF_LONG) ? true : false;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    if (!pToSeg && !fEnding && fModulate)
    {
        Trace(1, "ERROR (ComposeTransition): Invalid modulation.\n");
        return E_INVALIDARG;
    }

    // Get Tool graphs from the To and From segments
    IDirectMusicGraph* pFromGraph = CloneSegmentGraph(pFromSeg);
    IDirectMusicGraph* pToGraph = CloneSegmentGraph(pToSeg);

    // Get Audiopaths from the To and From segments
    IUnknown* pFromPath = GetSegmentAudioPath(pFromSeg, dwFlags);
    IUnknown* pToPath = GetSegmentAudioPath(pToSeg, dwFlags);

    // Get the starting segment's style
    IDirectMusicStyle* pFromStyle = NULL;
    if (pFromSeg)
    {
        hr = GetStyle(pFromSeg, mtTime, ALL_TRACK_GROUPS, pFromStyle, false);
        if (FAILED(hr)) pFromStyle = NULL;
    }

    // if no ChordMap is passed in, try to get one from the segments (first the
    // TO segment, then the FROM segment).  If these both fail, use the current chord
    // as the chord for the transition.  (if we're composing an ending, skip the TO segment)
    hr = S_OK;
    if (!pChordMap)
    {
        if (fEnding || !pToSeg || FAILED(GetPersonality(pToSeg, 0, ALL_TRACK_GROUPS, pChordMap)))
        {
            if (!pFromSeg || FAILED(GetPersonality(pFromSeg, mtTime, ALL_TRACK_GROUPS, pChordMap)))
                pChordMap = NULL;
        }
    }

    // Get a tempo from the From segment.
    double dblFromTempo = 120.0;
    double* pdblFromTempo = NULL;
    if (pFromSeg && SUCCEEDED(GetTempo(pFromSeg, mtTime, &dblFromTempo)))
    {
        pdblFromTempo = &dblFromTempo;
    }

    DMUS_COMMAND_PARAM_2 Command;
    if (!pFromSeg || FAILED(pFromSeg->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, mtTime, NULL, (void*) &Command)))
    {
        Command.mtTime = 0;
        Command.bCommand = DMUS_COMMANDT_GROOVE;
        Command.bGrooveLevel = 62;
        Command.bGrooveRange = 0;
        Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    DMUS_CHORD_PARAM NextChord;
    DMUS_CHORD_PARAM LastChord;
    if (!pFromSeg || FAILED(pFromSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, mtTime, NULL, (void*) &LastChord)))
    {
        wcscpy(LastChord.wszName, L"M7");
        LastChord.wMeasure = 0;
        LastChord.bBeat = 0;
        LastChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        LastChord.dwScale = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        LastChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwInversionPoints = 0xffffff;
        LastChord.SubChordList[0].dwLevels = 0xffffffff;
        LastChord.SubChordList[0].bChordRoot = 12; // 2C
        LastChord.SubChordList[0].bScaleRoot = 0;
    }
    if ((fModulate || fHasIntro) && pToSeg)
    {
        hr = pToSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else if (pFromSeg)
    {
        hr = pFromSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else
    {
        hr = E_FAIL;
    }
    if (FAILED(hr))
    {
        wcscpy(NextChord.wszName, L"M7");
        NextChord.wMeasure = 0;
        NextChord.bBeat = 0;
        NextChord.bSubChordCount = 1;
        NextChord.bKey = 12;
        NextChord.dwScale = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        NextChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwInversionPoints = 0xffffff;
        NextChord.SubChordList[0].dwLevels = 0xffffffff;
        NextChord.SubChordList[0].bChordRoot = 12; // 2C
        NextChord.SubChordList[0].bScaleRoot = 0;
    }

    hr = TransitionCommon(pFromStyle, NULL, pdblFromTempo, Command, LastChord, NextChord,
                pToSeg, wCommand, dwFlags, pChordMap, pFromGraph, pToGraph, pFromPath, pToPath, ppSectionSeg);

    if (pFromStyle) pFromStyle->Release();
    if (!fHaveChordMap && pChordMap) pChordMap->Release();
    if (pFromGraph) pFromGraph->Release();
    if (pToGraph) pToGraph->Release();
    if (pFromPath) pFromPath->Release();
    if (pToPath) pToPath->Release();

    return hr;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | AutoTransition |  Composes a
transition from inside a performance's primary segment to another segment, and then
queues the transition and the second segment to play.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | One or more of <p pPerformance>, <p pToSeg>, <p pChordMap>,
<p ppTransSeg>, <p ppToSegState>, and <p ppTransSegState> is not a valid pointer.

@comm Allowable values for <p dwFlags> include all values allowed for
<om IDirectMusicComposer::ComposeTransition>.  Additionally, the following values are
allowed:

  @flag DMUS_COMPOSEF_IMMEDIATE | Start transition on music or reference time boundary.
  @flag DMUS_COMPOSEF_GRID | Start transition on grid boundary.
  @flag DMUS_COMPOSEF_BEAT | Start transition on beat boundary.
  @flag DMUS_COMPOSEF_MEASURE | Start transition on measure boundary.
  @flag DMUS_COMPOSEF_AFTERPREPARETIME | Use the DMUS_SEGF_AFTERPREPARETIME flag when
     queueing the transition.


  <p ppTransSeg may be NULL.  In this case, the transition segment is not returned.
  <p pToSeg> may be NULL as long as <p dwFlags> does not include DMUS_COMPOSEF_MODULATE.
  If <p pToSeg> is NULL or doesn't contain a style track, intro embellishments are not valid.
  If the currently playing segment is NULL or doesn't contain a style track,
  fill, break, end, and groove embellishments are not valid.
  Note that the above implies that it is possible for both the currently playing segment and
  <p pToSeg> to be NULL or to be
  segments that don't contain style tracks.  If so, all embellishments are invalid.  When all
  embellishments are invalid, no transition occurs between the currently playing segment
  and <p pToSeg>.
  <p pChordMap> may be NULL.  If so, an attempt is made to obtain a ChordMap from a
  ChordMap track, first from <p pToSeg>, and then from the performance's primary segment.
  If neither of these
  segments contains a ChordMap track, the chord occuring at <p mtTime> in the primary
  segment is
  used as the chord in the transition.
*/

HRESULT CDMCompos::AutoTransition(
    IDirectMusicPerformance*    pPerformance,   // @parm
                                // The performance in which to do the transition.
    IDirectMusicSegment*        pToSeg,         // @parm
                                // The section to which the transition should smoothly flow.
    WORD                        wCommand,       // @parm
                                // The embellishment to use when composing the transition.
    DWORD                       dwFlags,        // @parm
                                // Various composition options.
    IDirectMusicChordMap*       pChordMap,  // @parm
                                // The ChordMap to be used when composing the transition.
    IDirectMusicSegment**       ppTransSeg,     // @parm
                                // Returns the created section segment.
    IDirectMusicSegmentState**  ppToSegState,   // @parm
                                // Returns the segment state for the transition segment.
    IDirectMusicSegmentState**  ppTransSegState // @parm
                                // Returns the segment state for the segment following the transition.
            )
{
    // ppToSegState and ppTransSegState are checked in Performance::PlaySegment,
    // BUT I need to check them here as well.
    V_INAME(IDirectMusicComposer::AutoTransition)
    V_PTR_WRITE_OPT(pToSeg, 1);
    V_PTR_WRITE_OPT(pChordMap, 1);
    V_PTR_WRITE(pPerformance, 1);
    V_PTR_WRITE_OPT(ppTransSeg, 1);
    V_PTR_WRITE_OPT(ppToSegState, 1);
    V_PTR_WRITE_OPT(ppTransSegState, 1);

    DWORD dwGroupBits = 0xffffffff;
    DWORD dwIndex = DMUS_SEG_ANYTRACK;

    DWORD dwResolution;
    if (dwFlags & DMUS_COMPOSEF_MEASURE) dwResolution = DMUS_SEGF_MEASURE;
    else if (dwFlags & DMUS_COMPOSEF_BEAT) dwResolution = DMUS_SEGF_BEAT;
    else if (dwFlags & DMUS_COMPOSEF_GRID) dwResolution = DMUS_SEGF_GRID;
    else if (dwFlags & DMUS_COMPOSEF_DEFAULT) dwResolution = DMUS_SEGF_DEFAULT;
    else if (dwFlags & DMUS_COMPOSEF_IMMEDIATE) dwResolution = 0;
    else dwResolution = DMUS_SEGF_MEASURE;

    if (dwFlags & DMUS_COMPOSEF_ALIGN) dwResolution |= DMUS_SEGF_ALIGN;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_MEASURE) dwResolution |= DMUS_SEGF_VALID_START_MEASURE;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_BEAT) dwResolution |= DMUS_SEGF_VALID_START_BEAT;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_GRID) dwResolution |= DMUS_SEGF_VALID_START_GRID;
    if (dwFlags & DMUS_COMPOSEF_VALID_START_TICK) dwResolution |= DMUS_SEGF_VALID_START_TICK;

    if (dwFlags & DMUS_COMPOSEF_AFTERPREPARETIME) dwResolution |= DMUS_SEGF_AFTERPREPARETIME;
    if (dwFlags & DMUS_COMPOSEF_NOINVALIDATE) dwResolution |= DMUS_SEGF_NOINVALIDATE;
    if (dwFlags & DMUS_COMPOSEF_INVALIDATE_PRI) dwResolution |= DMUS_SEGF_INVALIDATE_PRI;
    if (dwFlags & DMUS_COMPOSEF_USE_AUDIOPATH) dwResolution |= DMUS_SEGF_USE_AUDIOPATH;

    DWORD dwUseAudioPath = dwResolution & DMUS_SEGF_USE_AUDIOPATH;

    IDirectMusicSegment* pTransSeg = NULL;
    if (!ppTransSeg)
    {
        ppTransSeg = &pTransSeg;
    }

    IDirectMusicChordMap* pFromChordMap = NULL;
    bool bReleaseFromChordMap = false;
    double dblFromTempo = 120.0;
    double* pdblFromTempo = NULL;
    IDirectMusicStyle* pFromStyle = NULL;
    IDirectMusicBand* pBand = NULL;
    IDirectMusicSegmentState* pSegState = NULL;
    IDirectMusicSegment* pFromSegment = NULL;
    bool fModulate = (dwFlags & DMUS_COMPOSEF_MODULATE) ? true : false;
    bool fEnding = wCommand == DMUS_COMMANDT_END  || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    bool fHasIntro = wCommand == DMUS_COMMANDT_INTRO || wCommand == DMUS_COMMANDT_ENDANDINTRO;
    if (!pToSeg && !fEnding && fModulate)
    {
        Trace(1, "ERROR (AutoTransition): Invalid modulation.\n");
        return E_INVALIDARG;
    }
    MUSIC_TIME mtTime, mt;
    MUSIC_TIME mtStart;
    REFERENCE_TIME rt, rtResolved;
    HRESULT hr = pPerformance->GetQueueTime(&rt);
    if (SUCCEEDED(hr)) hr = pPerformance->GetResolvedTime(rt, &rtResolved, dwResolution);
    if (SUCCEEDED(hr)) hr = pPerformance->ReferenceToMusicTime(rtResolved, &mtTime);
    if (SUCCEEDED(hr)) hr = pPerformance->ReferenceToMusicTime(rt, &mt);

    if (!SUCCEEDED(hr)) return hr;
    if (rtResolved > rt) mtTime--;
    hr = pPerformance->GetSegmentState(&pSegState, mtTime);
    if (SUCCEEDED(hr))
    {
        hr = pSegState->GetStartTime(&mtStart);
        TraceI(3, "Time: %d Resolved Time: %d\n", mt - mtStart, mtTime - mtStart);
        if (!SUCCEEDED(hr))
        {
            goto ON_END;
        }
        hr = pSegState->GetSegment(&pFromSegment);
        if (!SUCCEEDED(hr))
        {
            goto ON_END;
        }
        if (dwFlags & DMUS_COMPOSEF_SEGMENTEND)
        {
            MUSIC_TIME mtLength;
            if( SUCCEEDED( pFromSegment->GetLength( &mtLength ) ) )
            {
                mtTime = mtLength - 1;
                mtStart = 0;
            }
        }
    }
    else pSegState = NULL;

    // Get the starting segment's style
    if (pPerformance)
    {
        hr = pPerformance->GetParam(GUID_IDirectMusicStyle, dwGroupBits, dwIndex, mtTime, NULL, (void*)&pFromStyle);
        if (FAILED(hr)) pFromStyle = NULL;
    }

    // if no ChordMap is passed in, try to get one (first from the TO segment,
    // then the FROM segment).  If these both fail, use the current chord
    // as the chord for the transition.  (if we're composing an ending, skip the TO segment)
    hr = S_OK;
    if (!pChordMap)
    {
        if (fEnding || !pToSeg || FAILED(GetPersonality(pToSeg, 0, dwGroupBits, pFromChordMap)))
        {
            if (!pFromSegment || FAILED(GetPersonality(pFromSegment, 0, dwGroupBits, pFromChordMap)))
            {
                pFromChordMap = NULL;
            }
        }

        if(pFromChordMap)
        {
            bReleaseFromChordMap = true;
        }
    }
    else
    {
        pFromChordMap = pChordMap;
    }

    DMUS_COMMAND_PARAM_2 Command;
    if (FAILED(pPerformance->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, mtTime, NULL, (void*) &Command)))
    {
        Command.mtTime = 0;
        Command.bCommand = DMUS_COMMANDT_GROOVE;
        Command.bGrooveLevel = 62;
        Command.bGrooveRange = 0;
        Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
    }
    DMUS_CHORD_PARAM NextChord;
    DMUS_CHORD_PARAM LastChord;
    if (FAILED(pPerformance->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, mtTime, NULL, (void*) &LastChord)))
    {
        wcscpy(LastChord.wszName, L"M7");
        LastChord.wMeasure = 0;
        LastChord.bBeat = 0;
        LastChord.bSubChordCount = 1;
        LastChord.bKey = 12;
        LastChord.dwScale = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        LastChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        LastChord.SubChordList[0].dwInversionPoints = 0xffffff;
        LastChord.SubChordList[0].dwLevels = 0xffffffff;
        LastChord.SubChordList[0].bChordRoot = 12; // 2C
        LastChord.SubChordList[0].bScaleRoot = 0;
    }
    if ((fModulate || fHasIntro) && pToSeg)
    {
        hr = pToSeg->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord);
    }
    else
    {
        // Check that this is the correct thing to do if pFromSegment is NULL.
        hr = pFromSegment ? pFromSegment->GetParam(GUID_ChordParam, dwGroupBits, dwIndex, 0, NULL, (void*) &NextChord) : E_FAIL;
    }
    if (FAILED(hr))
    {
        wcscpy(NextChord.wszName, L"M7");
        NextChord.wMeasure = 0;
        NextChord.bBeat = 0;
        NextChord.bSubChordCount = 1;
        NextChord.bKey = 12;
        NextChord.dwScale = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwChordPattern = DEFAULT_CHORD_PATTERN;
        NextChord.SubChordList[0].dwScalePattern = DEFAULT_SCALE_PATTERN;
        NextChord.SubChordList[0].dwInversionPoints = 0xffffff;
        NextChord.SubChordList[0].dwLevels = 0xffffffff;
        NextChord.SubChordList[0].bChordRoot = 12; // 2C
        NextChord.SubChordList[0].bScaleRoot = 0;
    }
    // If < DX8 content for From segment (or playing transition from segment end),
    // call ComposeTransition; otherwise, call TransitionCommon
    if (!UsingDX8(pFromStyle, pFromChordMap, pFromSegment, &Command, &LastChord) ||
        (dwFlags & DMUS_COMPOSEF_SEGMENTEND) )
    {
        if (pSegState)
        {
            hr = ComposeTransition(pFromSegment, pToSeg, mtTime - mtStart, wCommand, dwFlags, pChordMap, ppTransSeg);
        }
        else
        {
            hr = ComposeTransition(NULL, pToSeg, 0, wCommand, dwFlags, pChordMap, ppTransSeg);
        }
    }
    else
    {
        // Get Tool graphs from the To and From segments
        IDirectMusicGraph* pFromGraph = CloneSegmentGraph(pFromSegment);
        IDirectMusicGraph* pToGraph = CloneSegmentGraph(pToSeg);

        // Get Audiopaths from the To and From segments
        IUnknown* pFromPath = GetSegmentAudioPath(pFromSegment, dwFlags);
        IUnknown* pToPath = GetSegmentAudioPath(pToSeg, dwFlags, &dwUseAudioPath);

        // Get a tempo from the performance.
        DMUS_TEMPO_PARAM Tempo;
        if (SUCCEEDED(pPerformance->GetParam(GUID_TempoParam, dwGroupBits, dwIndex, mtTime, NULL, (void*)&Tempo)))
        {
            dblFromTempo = Tempo.dblTempo;
            pdblFromTempo = &dblFromTempo;
        }

        // Get the currently playing band
        DMUS_BAND_PARAM DMBand;
        if (SUCCEEDED(pPerformance->GetParam(GUID_BandParam, dwGroupBits, dwIndex, mtTime, NULL, (void*)&DMBand)))
        {
            pBand = DMBand.pBand;
        }

        hr = TransitionCommon(pFromStyle, pBand, pdblFromTempo, Command, LastChord, NextChord,
                    pToSeg, wCommand, dwFlags, pFromChordMap, pFromGraph, pToGraph,  pFromPath, pToPath, ppTransSeg);
        if (pFromGraph) pFromGraph->Release();
        if (pToGraph) pToGraph->Release();
        if (pFromPath) pFromPath->Release();
        if (pToPath) pToPath->Release();
    }

    if (SUCCEEDED(hr))
    {
        if (*ppTransSeg && pToSeg)
        {
            DMUS_COMMAND_PARAM_2 CommandParam;
            if (SUCCEEDED(pToSeg->GetParam(GUID_CommandParam2, dwGroupBits, dwIndex, 0, NULL, (void*) &CommandParam)))
            {
                (*ppTransSeg)->SetParam(GUID_CommandParamNext, dwGroupBits, 0, 0, (void*) &CommandParam);
            }
        }

        if (dwFlags & DMUS_COMPOSEF_SEGMENTEND) dwResolution |= DMUS_SEGF_SEGMENTEND;
        if (dwFlags & DMUS_COMPOSEF_MARKER) dwResolution |= DMUS_SEGF_MARKER;
        DWORD dwQueueResolution = DMUS_SEGF_QUEUE | dwUseAudioPath;

        hr = S_OK;
        if (*ppTransSeg)
        {
            hr = pPerformance->PlaySegment(*ppTransSeg, dwResolution, 0, ppTransSegState);
            if (SUCCEEDED(hr) && pToSeg)
            {
                hr = pPerformance->PlaySegment(pToSeg, dwQueueResolution, 0, ppToSegState);
            }
        }
        else
        {
            if (!pToSeg)
            {
                if (!(dwFlags & DMUS_COMPOSEF_SEGMENTEND))
                {
                    hr = pPerformance->Stop(pFromSegment, NULL, 0, dwResolution);
                }
            }
            else
            {
                hr = pPerformance->PlaySegment(pToSeg, dwResolution, 0, ppToSegState);
            }
        }
    }

ON_END:
    if (pFromStyle) pFromStyle->Release();
    if (pBand) pBand->Release();
    if (pTransSeg) pTransSeg->Release();
    if (pSegState) pSegState->Release();
    if (pFromSegment) pFromSegment->Release();
    if (bReleaseFromChordMap) pFromChordMap->Release();
    return hr;
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ComposeTemplateFromShape |  Creates
a new template segment based on a predefined shape.

@rdesc Returns:

@flag S_OK | Success
@flag E_POINTER | <p ppTempSeg> is not a valid pointer.
@flag E_OUTOFMEMORY | An attempt to allocate memory failed.
@flag E_INVALIDARG | <p wNumMeasures> is 0, or <p fComposeEnding> is TRUE and either
  <p wEndLength> is 0 or <p wEndLength> is greater than the number of non-intro measures.

@comm Shapes (passed in <p wShape>) represent the way chords and embellishments
occur over time across the section.  There are nine shapes:

  @flag DMUS_SHAPET_FALLING | The section gets quieter over time.
  @flag DMUS_SHAPET_LEVEL   | The section remains at the same level.
  @flag DMUS_SHAPET_LOOPABLE | The section is arranged to loop back to its beginning.
  @flag DMUS_SHAPET_LOUD    | The section remains loud.
  @flag DMUS_SHAPET_QUIET   | The section remains quiet.
  @flag DMUS_SHAPET_PEAKING | The section peaks.
  @flag DMUS_SHAPET_RANDOM | The section is random.
  @flag DMUS_SHAPET_RISING | The section builds over time.
  @flag DMUS_SHAPET_SONG | The section is in a song form.

*/
HRESULT CDMCompos::ComposeTemplateFromShape(
                    WORD                    wNumMeasures, // @parm The length, in measures, to compose the section segment
                    WORD                    wShape,// @parm The shape to compose the section segment.
                    BOOL                    fComposeIntro,// @parm TRUE if an intro is to be composed for the section segment.
                    BOOL                    fComposeEnding,// @parm TRUE if an ending is to be composed for the section segment.
                    WORD                    wEndLength, // @parm Length in measures of the ending, if one is to be composed.
                    IDirectMusicSegment**   ppTempSeg   // @parm Returns the created template segment.
            )
{
    V_INAME(IDirectMusicComposer::ComposeTemplateFromShape)
    V_PTRPTR_WRITE(ppTempSeg);
    return ComposeTemplateFromShapeInternal(wNumMeasures, wShape, fComposeIntro, fComposeEnding,
        1, 1, 1, (int)wEndLength, ppTempSeg);
}

HRESULT CDMCompos::ComposeTemplateFromShapeEx(
                WORD wNumMeasures,                  // Number of measures in template
                WORD wShape,                        // Shape for composition
                BOOL fIntro,                        // Compose an intro?
                BOOL fEnd,                          // Compose an ending?
                IDirectMusicStyle* pStyle,          // Style used for embellishment lengths
                IDirectMusicSegment** ppTemplate    // Template containing chord and command tracks
            )
{
    V_INAME(IDirectMusicComposer::ComposeTemplateFromShapeEx)
    V_PTRPTR_WRITE(ppTemplate);
    V_PTR_WRITE_OPT(pStyle, 1);
    HRESULT hr = S_OK;

    int nIntroLength = 1;
    int nFillLength = 1;
    int nBreakLength = 1;
    int nEndLength = 1;
    if (pStyle)
    {
        DWORD dwMin, dwMax;

        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_INTRO, 0, &dwMin, &dwMax);
        if (hr == S_OK) nIntroLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_FILL, 0, &dwMin, &dwMax);
        if (hr == S_OK) nFillLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_BREAK, 0, &dwMin, &dwMax);
        if (hr == S_OK) nBreakLength = (int) dwMax;
        hr = pStyle->GetEmbellishmentLength(DMUS_COMMANDT_END, 0, &dwMin, &dwMax);
        if (hr == S_OK) nEndLength = (int) dwMax;
    }
    return ComposeTemplateFromShapeInternal(wNumMeasures, wShape, fIntro, fEnd,
        nIntroLength, nFillLength, nBreakLength, nEndLength, ppTemplate);
}

HRESULT CDMCompos::ComposeTemplateFromShapeInternal(
                    WORD                    wNumMeasures,
                    WORD                    wShape,
                    BOOL                    fComposeIntro,
                    BOOL                    fComposeEnding,
                    int                     nIntroLength,
                    int                     nFillLength,
                    int                     nBreakLength,
                    int                     nEndLength,
                    IDirectMusicSegment**   ppTempSeg
            )
{
    HRESULT hr;
    if ( !wNumMeasures ||
         (fComposeEnding && !nEndLength) ||
         (fComposeIntro && !nIntroLength) ||
         (fComposeEnding && fComposeIntro && (nEndLength + nIntroLength) > wNumMeasures) ||
         (fComposeEnding && (nEndLength > wNumMeasures)) ||
         (fComposeIntro && (nIntroLength > wNumMeasures)) )
    {
        Trace(1, "ERROR (ComposeTemplateFromShape): Invalid template length.\n");
        return E_INVALIDARG;
    }

    if (wNumMeasures & 0x8000 || wNumMeasures == 0) wNumMeasures = 1;
    int nNumMeasures = (int)wNumMeasures;
    if (fComposeEnding)
    {
        if (nEndLength <= 0) nEndLength = 1;
    }
    if (wShape != DMUS_SHAPET_FALLING &&
        wShape != DMUS_SHAPET_LEVEL &&
        wShape != DMUS_SHAPET_LOOPABLE &&
        wShape != DMUS_SHAPET_LOUD &&
        wShape != DMUS_SHAPET_QUIET &&
        wShape != DMUS_SHAPET_PEAKING &&
        wShape != DMUS_SHAPET_RANDOM &&
        wShape != DMUS_SHAPET_RISING &&
        wShape != DMUS_SHAPET_SONG)
    {
        wShape = DMUS_SHAPET_RANDOM;
    }


    int nOriginalMeasures = 0;
    bool f1Bar = false;
    if (fComposeIntro)
    {
        nNumMeasures -= nIntroLength;
        if (nNumMeasures < nIntroLength)
        {
            f1Bar = true;
            nNumMeasures = nIntroLength;
        }
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        nOriginalMeasures = nNumMeasures;
        nNumMeasures -= (nLength - 1);
        if (nNumMeasures < 1)
        {
            nNumMeasures = 1;
        }
    }
    TemplateStruct* pTemplate = new TemplateStruct;
    if (!pTemplate) return E_OUTOFMEMORY;
    TemplateStruct* apTempl[8] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };
    if ((wShape != DMUS_SHAPET_SONG) || (nNumMeasures <= 24))
    {
        if (wShape == DMUS_SHAPET_LOOPABLE) nNumMeasures++;
        pTemplate->m_nMeasures = (short)nNumMeasures;
        pTemplate->CreateSignPosts();
        pTemplate->CreateEmbellishments(wShape, nFillLength, nBreakLength);
        if (wShape == DMUS_SHAPET_LOOPABLE)
        {
            nNumMeasures--;
            pTemplate->m_nMeasures = (short)nNumMeasures;
        }
    }
    else
    {
        short nShortestLength = 12; // initialized to longest value in sanLengths
        int anLengths[8];
        int anGrooveLevel[8];
        BYTE abLeadins[8];
        int nTypeCount = 2;
        unsigned int nSize = (unsigned int) nNumMeasures >> 5;
        int nTypeIndex;
        int nMeasure;
        int nChoice, nLastChoice;
        while (nSize)
        {
            nTypeCount++;
            nSize = nSize >> 1;
            if (nTypeCount >= 8) break;
        }
        for (nTypeIndex = 1; nTypeIndex < nTypeCount; nTypeIndex++)
        {
            apTempl[nTypeIndex] = new TemplateStruct;
            if (!apTempl[nTypeIndex])
            {
                hr = E_OUTOFMEMORY;
                goto ON_END;
            }
            static WORD awShapes[8] = {
                DMUS_SHAPET_FALLING, DMUS_SHAPET_LEVEL, DMUS_SHAPET_LOUD, DMUS_SHAPET_QUIET,
                DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM, DMUS_SHAPET_RANDOM };
            static int anInitGroovels[8] = { 0,-1,0,0,1,-1,2,-2 };
            static BYTE abRiffs[8] = {
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK,
                DMUS_COMMANDT_FILL, DMUS_COMMANDT_FILL, DMUS_COMMANDT_BREAK, DMUS_COMMANDT_FILL };
            static short sanLengths[10] = { 8,8,8,8,6,12,8,8,10,6 };
            short nLength = sanLengths[rand() % 10];

            apTempl[nTypeIndex]->m_nMeasures = nLength;
            anLengths[nTypeIndex] = nLength;
            if (nLength)
            {
                if (nShortestLength > nLength) nShortestLength = nLength;
                apTempl[nTypeIndex]->CreateSignPosts();
                apTempl[nTypeIndex]->CreateEmbellishments(awShapes[nTypeIndex], nFillLength, nBreakLength);
                anGrooveLevel[nTypeIndex] = anInitGroovels[nTypeIndex];
                if (rand() % 4) abLeadins[nTypeIndex] = abRiffs[nTypeIndex];
                else abLeadins[nTypeIndex] = 0;
            }
        }
        anGrooveLevel[0] = 0;
        pTemplate->m_nMeasures = (short)nNumMeasures;
        nMeasure = 0;
        nChoice = 1;
        nLastChoice = 0;
        for (; nMeasure < nNumMeasures; )
        {
            int nGroove;
            int nNewChoice;

            if ((nNumMeasures - nMeasure) <= nShortestLength)
            {
                nChoice = 0;
                short nLength = nNumMeasures - nMeasure;
                apTempl[0] = new TemplateStruct;
                if (!apTempl[0])
                {
                    hr = E_OUTOFMEMORY;
                    goto ON_END;
                }
                apTempl[0]->m_nMeasures = nLength;
                anLengths[0] = nLength;
                apTempl[0]->CreateSignPosts();
                apTempl[0]->CreateEmbellishments(DMUS_SHAPET_FALLING, nFillLength, nBreakLength);
                anGrooveLevel[0] = 0;
                if (rand() % 4) abLeadins[0] = DMUS_COMMANDT_FILL;
                else abLeadins[0] = 0;
            }
            nGroove = anGrooveLevel[nChoice];
            pTemplate->IncorporateTemplate((short)nMeasure, apTempl[nChoice], (short)nGroove);
            if ( (abLeadins[nChoice] == DMUS_COMMANDT_FILL && nMeasure >= nFillLength) )
            {
                InsertCommand(nMeasure, nFillLength, pTemplate->m_CommandList, abLeadins[nChoice]);
            }
            else if ( (abLeadins[nChoice] == DMUS_COMMANDT_BREAK && nMeasure >= nBreakLength) )
            {
                InsertCommand(nMeasure, nBreakLength, pTemplate->m_CommandList, abLeadins[nChoice]);
            }
            if (anGrooveLevel[nChoice] < 0) anGrooveLevel[nChoice]++;
            else
            {
                if (rand() % 3)
                {
                    if (rand() % 2)
                    {
                        anGrooveLevel[nChoice]++;
                    }
                    else
                    {
                        anGrooveLevel[nChoice]--;
                    }
                }
            }
            nMeasure += anLengths[nChoice];
            nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            if ((nNewChoice == nChoice) && (nNewChoice == nLastChoice))
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            if (nNewChoice == nChoice)
            {
                nNewChoice = WeightedRand(nTypeCount - 1) + 1;
            }
            // If there are enough measures for some but not all of the
            // patterns, find a pattern that fits
            if ((nNumMeasures - nMeasure) > nShortestLength)
            {
                while ((nNumMeasures - nMeasure) < anLengths[nNewChoice])
                {
                    nNewChoice = WeightedRand(nTypeCount - 1) + 1;
                }
            }
            nLastChoice = nChoice;
            nChoice = nNewChoice;
        }
        pTemplate->m_CommandList.MergeSort(Less);
    }
    if (fComposeEnding)
    {
        int nLength = nEndLength;
        if (nNumMeasures != nOriginalMeasures)
        {
            pTemplate->m_nMeasures = (short)nOriginalMeasures;
        }
        if (nLength > nOriginalMeasures)
        {
            nLength = nOriginalMeasures;
        }
        pTemplate->AddEnd(nLength);
    }
    if (fComposeIntro)
    {
        pTemplate->AddIntro(f1Bar, nIntroLength);
    }
    // build the template segment...
    IDMTempl* pITemplate;
    hr = S_OK;
    hr = CoCreateInstance(
        CLSID_DMTempl,
        NULL,
        CLSCTX_INPROC,
        IID_IDMTempl,
        (void**)&pITemplate);
    if (SUCCEEDED(hr))
    {
        pITemplate->Init(pTemplate);
        hr = CoCreateInstance(
            CLSID_DirectMusicSegment,
            NULL,
            CLSCTX_INPROC,
            IID_IDirectMusicSegment,
            (void**)ppTempSeg);
        if (SUCCEEDED(hr))
        {
            pITemplate->CreateSegment(*ppTempSeg);
        }
        pITemplate->Release();
    }
ON_END:
    for (short n = 0; n < 8; n++)
    {
        if (apTempl[n])
        {
            delete apTempl[n];
        }
    }
    return hr;
}

inline char ShiftRoot(DWORD dwScale, BYTE bRoot)
{
    switch (dwScale & 0xfff)
    {
    case 0x56b: bRoot += 1; break;  // C#
    case 0xad6: bRoot += 2; break;  // D
    case 0x5ad: bRoot += 3; break;  // D#

    case 0xb5a: bRoot += 4; break;  // E
    case 0x6b5: bRoot += 5; break;  // F
    case 0xd6a: bRoot += 6; break;  // F#
    case 0xad5: bRoot += 7; break;  // G

    case 0x5ab: bRoot += 8; break;  // G#
    case 0xb56: bRoot += 9; break;  // A
    case 0x6ad: bRoot += 10; break; // A#
    case 0xd5a: bRoot += 11; break; // B
    }

    return (char) (bRoot %= 12);
}

/*
@method:(EXTERNAL) HRESULT | IDirectMusicComposer | ChangeChordMap |  Modifies the chords
and scale pattern of an existing section segment to reflect the new ChordMap.

@rdesc Returns:

@flag S_OK | Success.
@flag E_POINTER | Either <p pSectionSeg> or <p pChordMap> is not a valid pointer.

@comm
*/
HRESULT CDMCompos::ChangeChordMap(
                    IDirectMusicSegment*        pSectionSeg, // @parm The section to change the ChordMap upon.
                    BOOL                        fTrackScale, // @parm If TRUE, does scale tracking.
                    IDirectMusicChordMap*   pChordMap // @parm The ChordMap to change the section.
            )
{
    V_INAME(IDirectMusicComposer::ChangeChordMap)
    V_PTR_WRITE(pSectionSeg, 1);
    V_PTR_WRITE(pChordMap, 1);

    HRESULT                 hr              = S_OK;
    IDMPers*                pDMP            = NULL;
    IDirectMusicTrack*      pChordTrack     = NULL;
    IDirectMusicStyle*      pStyle          = NULL;
    IPersistStream*         pPS             = NULL;
    IStream*                pStream         = NULL;
    IAARIFFStream*          pChordRIFF      = NULL;
    TList<PlayChord>        ChordList;
    BYTE                    bSectionRoot    = 0;
    DWORD                   dwSectionScale  = 0;
    TListItem<PlayChord>*   pChords         = NULL;
    DMPersonalityStruct*    pPers           = NULL;
    BYTE                    bNewRoot        = 0;
    DWORD                   dwNewScale      = 0;
    char                    chOffset        = 0;

    EnterCriticalSection( &m_CriticalSection );
    pChordMap->QueryInterface(IID_IDMPers, (void**)&pDMP);
    pDMP->GetPersonalityStruct((void**)&pPers);
    if (!pPers)
    {
        Trace(1, "ERROR (ChangeChordMap): Chord map not properly initialized.\n");
        hr = DMUS_E_NOT_INIT;
        goto ON_END;
    }
    // Get the segment's chord track.
    hr = pSectionSeg->GetTrack(CLSID_DirectMusicChordTrack, ALL_TRACK_GROUPS, 0, &pChordTrack);
    if (S_OK != hr) goto ON_END;
    // Write the track to a stream, and read from the stream into a chord list.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (S_OK != hr) goto ON_END;
    hr = pPS->Save(pStream, FALSE);
    if (S_OK != hr) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    LoadChordList(ChordList, pStream, bSectionRoot, dwSectionScale);
    bSectionRoot %= 24;

    pChordMap->GetScale(&dwNewScale);
    bNewRoot = (BYTE) (dwNewScale >> 24);
    dwNewScale &= 0xffffff;
    if (pPers->m_dwChordMapFlags & DMUS_CHORDMAPF_VERSION8)
    {
        BYTE bTempRoot = bSectionRoot % 12;
        if (bNewRoot < bTempRoot) bNewRoot += 12;
        chOffset = (bNewRoot - bTempRoot) % 12;
    }
    else
    {
        chOffset = ShiftRoot(dwNewScale, bNewRoot) - ShiftRoot(dwSectionScale, bSectionRoot);
    }
    // Modify the chords in the chord list to match the new personality's chord palette.
    for (pChords = ChordList.GetHead(); pChords; pChords = pChords->GetNext())
    {
        PlayChord& rChord = pChords->GetItemValue();
        char chRoot = rChord.GetRoot();
        if (fTrackScale)
        {
            chRoot += chOffset;
        }
        TListItem<DMChordData> *pPalette;
        char chNewRoot = chRoot - bSectionRoot;
        while (chNewRoot < 0) chNewRoot += 12;
        while (chNewRoot > 23) chNewRoot -= 12;
        pPalette = pPers->m_aChordPalette[chNewRoot].GetHead();
        if (!pPalette)
        {
            Trace(1, "ERROR (ChangeChordMap): No Chord Pallette for root %d.\n", chNewRoot);
            hr = E_POINTER;
            goto ON_END;
        }
        if (rChord.m_pChord)
        {
            rChord.m_pChord->Release();
            delete rChord.m_pChord;
        }
        rChord.m_pChord = new DMChordData(pPalette->GetItemValue());
        if (!rChord.m_pChord)
        {
            hr = E_OUTOFMEMORY;
            goto ON_END;
        }
    }
    pStream->Release();
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStream);
    if (S_OK != hr) goto ON_END;
    hr = AllocRIFFStream( pStream, &pChordRIFF);
    if (S_OK != hr) goto ON_END;
    // Get the segment's first style
    hr = GetStyle(pSectionSeg, 0, ALL_TRACK_GROUPS, pStyle, true);
    if (FAILED(hr)) goto ON_END;
    // Extract the style's time signature.
    DMUS_TIMESIGNATURE TimeSig;
    pStyle->GetTimeSignature(&TimeSig);
    SaveChordList(pChordRIFF, ChordList, bNewRoot, dwNewScale, TimeSig);
    pPS->Release();
    pPS = NULL;
    // Load the modified chord list into the chord track
    hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pPS);
    if (!SUCCEEDED(hr)) goto ON_END;
    StreamSeek(pStream, 0, STREAM_SEEK_SET);
    hr = pPS->Load(pStream);
ON_END:
    //ChordList.RemoveAll();
    Clear(ChordList);
    if (pPS)
    {
        pPS->Release();
    }
    if (pChordTrack)
    {
        pChordTrack->Release();
    }
    if (pChordRIFF)
    {
        pChordRIFF->Release();
    }
    if (pStyle)
    {
        pStyle->Release();
    }
    if (pStream)
    {
        pStream->Release();
    }
    if (pDMP)
    {
        pDMP->Release();
    }
    CleanUp();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

STDMETHODIMP CDMCompos::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CDMCompos::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicComposer)
    {
        *ppv = static_cast<IDirectMusicComposer*>(this);
    }
    else if (iid == IID_IDirectMusicComposer8)
    {
        *ppv = static_cast<IDirectMusicComposer8*>(this);
        m_dwFlags |= COMPOSEF_USING_DX8;
    }
    else if (iid == IID_IDirectMusicComposer8P)
    {
        *ppv = static_cast<IDirectMusicComposer8P*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMCompos::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMCompos::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\dmtempl.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) 1998-2001 Microsoft Corporation
//
//  File:       dmtempl.cpp
//
//--------------------------------------------------------------------------

// DMTempl.cpp : Implementation of CDMTempl

#include "DMTempl.h"
#include <comdef.h>
#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\iostru.h"
#include "debug.h"
#include "..\shared\Validate.h"

void TemplateStruct::AddIntro(TList<PlayChord>& PlayList, int nIntroLength)
{
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        BOOL fMerge = FALSE;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = 0;
        rCommand.m_dwChord = 0;
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<PlayChord> *pChord = PlayList.GetHead();
        for (; pChord; pChord = pChord->GetNext())
        {
            pChord->GetItemValue().m_nMeasure += (short)nIntroLength;
        }
        TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure >= nIntroLength || !rScan.m_dwChord)
                rScan.m_nMeasure += (short)nIntroLength;
            else if (rScan.m_Command.bGrooveLevel != 0 || rScan.m_Command.bCommand == DMUS_COMMANDT_END)
            {
                rCommand.m_dwChord = rScan.m_dwChord;
                rScan.m_dwChord = 0;
                rScan.m_nMeasure += (short)nIntroLength;
            }
            else // merge with existing command
            {
                rScan.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                rScan.m_Command.bGrooveLevel = 0;
                rScan.m_Command.bGrooveRange = 0;
                rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                fMerge = TRUE;
            }
        }
        m_nMeasures += (short)nIntroLength;
        if (fMerge)
            delete pCommand;
        else
            m_CommandList.AddHead(pCommand);
    }
}

void TemplateStruct::AddIntro(bool f1Bar, int nLength)
{
    TListItem<TemplateCommand> *pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        BOOL fMerge = FALSE;
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = 0;
        rCommand.m_dwChord = 0;
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure > 0 || !rScan.m_dwChord)
                rScan.m_nMeasure += (short)nLength;
            else if ( !f1Bar &&
                        (rScan.m_Command.bGrooveLevel != 0 ||
                         rScan.m_Command.bCommand != DMUS_COMMANDT_GROOVE) )
            {
                rCommand.m_dwChord = rScan.m_dwChord;
                rScan.m_dwChord = 0;
                rScan.m_nMeasure += (short)nLength;
            }
            else // merge with existing command
            {
                rScan.m_Command.bCommand = DMUS_COMMANDT_INTRO;
                rScan.m_Command.bGrooveLevel = 0;
                rScan.m_Command.bGrooveRange = 0;
                rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                fMerge = TRUE;
            }
        }
        if (!f1Bar) m_nMeasures += (short)nLength;
        if (fMerge)
            delete pCommand;
        else
            m_CommandList.AddHead(pCommand);
    }
}

void TemplateStruct::AddEnd(int nLength)
{
    TListItem<TemplateCommand> *pCommand;
    TListItem<TemplateCommand> *pScan = m_CommandList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (m_nMeasures - nLength == pScan->GetItemValue().m_nMeasure) break;
    }
    pCommand = (pScan) ? pScan : new TListItem<TemplateCommand>;
    if (pCommand)
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = m_nMeasures - nLength;
        if (!pScan || pScan->GetItemValue().m_nMeasure > 1) // otherwise keep the existing signpost
        {
            rCommand.m_dwChord = 0;
        }
        rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
        rCommand.m_Command.bGrooveLevel = 0;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        if (!pScan) m_CommandList.AddTail(pCommand);
    }
}

void TemplateStruct::FillInGrooveLevels()
{
    BYTE bLastGrooveLevel = 62;
    TListItem<TemplateCommand>* pCommands = m_CommandList.GetHead();
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        if (rCommand.m_Command.bGrooveLevel == 0)
        {
            rCommand.m_Command.bGrooveLevel = bLastGrooveLevel;
        }
        else
        {
            bLastGrooveLevel = rCommand.m_Command.bGrooveLevel;
        }
    }
}


void TemplateStruct::IncorporateTemplate(
            short nMeasure, TemplateStruct* pTemplate, short nDirection)
{
    if (!pTemplate) return;
    TListItem<TemplateCommand>* pCommands = pTemplate->m_CommandList.GetHead();
    for(; pCommands; pCommands = pCommands->GetNext())
    {
        TemplateCommand& rCommand = pCommands->GetItemValue();
        TListItem<TemplateCommand> *pNew = new TListItem<TemplateCommand>;
        if (pNew)
        {
            TemplateCommand& rNew = pNew->GetItemValue();
            rNew.m_nMeasure = rCommand.m_nMeasure + (short)nMeasure;
            ChangeCommand(rNew.m_Command, rCommand.m_Command, nDirection);
            rNew.m_dwChord = rCommand.m_dwChord;
            m_CommandList.AddHead(pNew);
        }
    }
}

void TemplateStruct::InsertCommand(TListItem<TemplateCommand> *pCommand, BOOL fIsCommand)
{
    TListItem<TemplateCommand> *pScan;

    if( !pCommand )
    {
        return;
    }
    pCommand->SetNext(NULL);
    TemplateCommand& rCommand = pCommand->GetItemValue();
    pScan = m_CommandList.GetHead();
    if (pScan)
    {
        for (; pScan; pScan = pScan->GetNext())
        {
            TemplateCommand& rScan = pScan->GetItemValue();
            if (rScan.m_nMeasure == rCommand.m_nMeasure)
            {
                if (fIsCommand)
                {
                    rScan.m_dwChord = 0;
                    rScan.m_Command.bCommand = rCommand.m_Command.bCommand;
                    rScan.m_Command.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
                    rScan.m_Command.bGrooveRange = rCommand.m_Command.bGrooveRange;
                    rScan.m_Command.bRepeatMode = rCommand.m_Command.bRepeatMode;
                }
                else
                {
                    rScan.m_dwChord = rCommand.m_dwChord;
                    rScan.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
                    rScan.m_Command.bGrooveLevel = 0;
                    rScan.m_Command.bGrooveRange = 0;
                    rScan.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
                }
                delete pCommand;
                return;
            }
            if (rScan.m_nMeasure > rCommand.m_nMeasure)
            {
                m_CommandList.InsertBefore(pScan, pCommand);
                break;
            }
        }
    }
    if (!pScan)
    {
        m_CommandList.AddTail(pCommand);
    }
}

void TemplateStruct::AddCommand(int nMeasure, DWORD dwCommand)

{
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        rCommand.m_nMeasure = (short)nMeasure;
        rCommand.m_Command.bGrooveRange = 0;
        rCommand.m_Command.bRepeatMode = DMUS_PATTERNT_RANDOM;
        switch (dwCommand)
        {
        case PF_FILL:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_FILL;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_INTRO:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_BREAK:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_BREAK;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_END:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
            rCommand.m_Command.bGrooveLevel = 0;
            break;
        case PF_A:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 12;
            break;
        case PF_B:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 37;
            break;
        case PF_C:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 62;
            break;
        case PF_D:
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 87;
            break;
        default:  // default to a Groove C
            rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
            rCommand.m_Command.bGrooveLevel = 62;
        }
        InsertCommand( pCommand, TRUE );
    }
}

void TemplateStruct::AddChord(int nMeasure, DWORD dwChord)

{
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if (pCommand)
    {
        pCommand->GetItemValue().m_nMeasure = (short)nMeasure;
        pCommand->GetItemValue().m_dwChord = dwChord;
        InsertCommand( pCommand, FALSE );
    }
}

int WeightedRand(int nRange)

/*  This randomly chooses a number within nrange.  However, it heavily
    weights in favor of the first index, which has twice the chance
    of the second index, which has twice the chance of the third...
*/

{
    int nTotal = 0;
    int index;
    unsigned int nGuess;
    if (nRange <= 0 || nRange > 15) return(0);     // out of range.
    for (index = 0;index < nRange; index++)
    {
        nTotal += (1 << index);
    }
    nGuess = rand() % nTotal;
    nGuess++;
    for (;nGuess;index--)
    {
        nGuess = nGuess >> 1;
    }
    return(index);
}

void TemplateStruct::CreateSignPosts()
{
    // First, figure out how many different sign posts we should use.
    // Should be the number of bits in measures minus two. Min is one.
    // For example, 8 measures gets us 2 sign posts.

    int nSPCount = -2;
    int nCopy = m_nMeasures;
    m_CommandList.RemoveAll();
    while (nCopy)
    {
        nSPCount++;
        nCopy = nCopy >> 1;
    }
    if (nSPCount < 1) nSPCount = 1;
    if (nSPCount > 7) nSPCount = 7;

    // Now, choose some signposts.  We choose from the following set:
    // 1, A, C, E, B, D, F. Randomly, but heavily weighted towards the start
    // of the set.

    static DWORD adwSource[7] = { DMUS_SIGNPOSTF_1, DMUS_SIGNPOSTF_A, DMUS_SIGNPOSTF_C, DMUS_SIGNPOSTF_E, DMUS_SIGNPOSTF_B, DMUS_SIGNPOSTF_D, DMUS_SIGNPOSTF_F };
    DWORD adwChoice[7];
    DWORD adwSign[7];
    int anLength[7];
    DWORD dwLastChord;

    int index;
    for (index = 0;index < 7;index++)
    {
        adwChoice[index] = adwSource[index];
        adwSign[index] = 0;
        if (rand() % 3) anLength[index] = 4;
        else anLength[index] = 2;
    }
    if (rand() % 2) anLength[0] = 4;
    for (index = 0;index < nSPCount;index++)
    {
        int nPosition;
        int nScan = 0;
        if (index) nPosition = WeightedRand(7 - index);
        else nPosition = WeightedRand(3);
        for (;nScan < 7;nScan++)
        {
            if (adwChoice[nScan])
            {
                if (!nPosition)
                {
                    adwSign[index] = adwChoice[nScan];
                    if (rand() % 2) adwSign[index] |= DMUS_SIGNPOSTF_CADENCE;
                    adwChoice[nScan] = 0;
                    break;
                }
                nPosition--;
            }
        }
    }
    AddChord(0,dwLastChord = adwSign[0]);
    int nLast = 0;
    for (index = 0;index < m_nMeasures;)
    {
        DWORD dwCadence = 0;
        DWORD dwChord;
        index += anLength[nLast];
        if (index >= (m_nMeasures - 1))
        {
            if (rand() % 3) AddChord(m_nMeasures - 1,DMUS_SIGNPOSTF_1 | dwCadence);
            else AddChord(m_nMeasures - 1,adwSign[0] | dwCadence);
            break;
        }
        dwChord = adwSign[nLast = WeightedRand(nSPCount)];
        if (dwChord == dwLastChord)
        {
            dwChord = adwSign[nLast = WeightedRand(nSPCount)];
        }
        AddChord(index,dwChord | dwCadence);
        dwLastChord = dwChord;
    }
}

static void GrooveRange(TemplateStruct *pTemplate,int nStartm,int nEndm,
            int nStartg,int nEndg,BOOL fRandom)

{
    static BYTE abGrooveLevels[4] = { 12, 37, 62, 87 };
    TListItem<TemplateCommand> *pCommand = pTemplate->m_CommandList.GetHead();
    TListItem<TemplateCommand> *pLast = NULL;
    int nRangem = nEndm - nStartm;
    int nRangeg = nEndg - nStartg;
    BYTE bLastGrooveLevel = 0;
    int nLastGroove = -1;
    int nLastMeasure = 0;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE &&
            rCommand.m_Command.bGrooveLevel > 0)
        {
            bLastGrooveLevel = rCommand.m_Command.bGrooveLevel;
            nLastMeasure = rCommand.m_nMeasure;
        }
        if (rCommand.m_nMeasure >= nStartm)
        {
            if (rCommand.m_nMeasure >= nEndm) break;
            int nGroove;
            TListItem<TemplateCommand> *pNext = pCommand->GetNext();
            if (pNext)
            {
                nGroove = 
                    ((pNext->GetItemValue().m_nMeasure + rCommand.m_nMeasure ) >> 1) - nStartm;
            }
            else
            {
                nGroove = rCommand.m_nMeasure - nStartm;
            }
            if (fRandom)
            {
                nGroove = rand() % 3;
                nGroove += nLastGroove - 1;
                if (nGroove > 3) nGroove = 2;
                if (nGroove < 0) nGroove = 1;
            }
            else
            {
                nGroove *= nRangeg;
                nGroove += (nRangem >> 1);
                nGroove /= nRangem;
                nGroove += nStartg;
            }
            if ((nGroove >= 0) && (nGroove < 4))
            {
                if (abGrooveLevels[nGroove] != bLastGrooveLevel)
                {
                    if (nLastGroove >= 0)
                    {
                        if (nLastGroove > nGroove) nGroove = nLastGroove - 1;
                        else if (nLastGroove < nGroove) nGroove = nLastGroove + 1;
                    }
                    rCommand.m_Command.bGrooveLevel = abGrooveLevels[nGroove];
                    rCommand.m_Command.bGrooveRange = 0;
                    bLastGrooveLevel = abGrooveLevels[nGroove];
                    nLastMeasure = rCommand.m_nMeasure;
                    nLastGroove = nGroove;
                }
                else if (rCommand.m_nMeasure > (nLastMeasure + 6))
                {
                    nGroove += ((rand() % 3) - 1);
                    if (nGroove < 0) nGroove += 2;
                    if (nGroove > 3) nGroove -= 2;
                    if (!nRangeg)
                    {
                        if ((nGroove < nLastGroove) && (nGroove <= nStartg))
                        {
                            if (rand() % 2) nGroove++;
                        }
                    }
                    if (abGrooveLevels[nGroove] != bLastGrooveLevel)
                    {
                        rCommand.m_Command.bGrooveLevel = abGrooveLevels[nGroove];
                        rCommand.m_Command.bGrooveRange = 0;
                        bLastGrooveLevel = abGrooveLevels[nGroove];
                        nLastMeasure = rCommand.m_nMeasure;
                        nLastGroove = nGroove;
                    }
                }
            }
        }
    }
}

void TemplateStruct::CreateEmbellishments(WORD shape, int nFillLength, int nBreakLength)
{
    // Put fills in. Scan forward through the list, placing fills
    // just prior to sign post changes.  Each time, move forward a
    // random count.
    TListItem<TemplateCommand> *pCommand;
    BYTE bLastGroove = 0;
    BOOL fAddMore = FALSE;
    int nStartg, nEndg;
    switch (shape)
    {
    case DMUS_SHAPET_FALLING:
        nStartg = 3;
        nEndg = 0;
        break;
    case DMUS_SHAPET_LEVEL:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_LOOPABLE:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_LOUD:
        nStartg = 3;
        nEndg = 3;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_QUIET:
        nStartg = 0;
        nEndg = 1;
        fAddMore = TRUE;
        break;
    case DMUS_SHAPET_PEAKING:
        nStartg = 0;
        nEndg = 3;
        GrooveRange(this, 0, m_nMeasures >> 1, nStartg, nEndg, FALSE);
        nStartg = 3;
        nEndg = 0;
        GrooveRange(this, m_nMeasures >> 1, m_nMeasures - 1, nStartg, nEndg, FALSE);
        nStartg = 0;
        nEndg = 0;
        break;
    case DMUS_SHAPET_RANDOM:
        nStartg = 0;
        nEndg = 0;
        GrooveRange(this, 0, m_nMeasures - 1, nStartg, nEndg, TRUE);
        break;
    case DMUS_SHAPET_RISING:
        nStartg = 0;
        nEndg = 3;
        break;
    case DMUS_SHAPET_SONG:
    default:
        nStartg = 2;
        nEndg = 2;
        fAddMore = TRUE;
        break;
    }
    if (nStartg || nEndg) GrooveRange(this, 0, m_nMeasures - 1, nStartg, nEndg, FALSE);
    pCommand = m_CommandList.GetHead();
    int nLastGrooveBar = 0;
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE)
        {
            BYTE bGrooveLevel = rCommand.m_Command.bGrooveLevel;
            if (bGrooveLevel && (bGrooveLevel != bLastGroove))
            {
               if (rand() % 2)
                {
                    if ( (rCommand.m_nMeasure >= nFillLength) && 
                         (rCommand.m_nMeasure - nFillLength > nLastGrooveBar) && 
                         (bGrooveLevel > 50 || bLastGroove > 75) )
                    {
                        AddCommand(rCommand.m_nMeasure - nFillLength, PF_FILL);
                    }
                    else
                    {
                        if ((rCommand.m_nMeasure >= nBreakLength) && 
                            (rCommand.m_nMeasure - nBreakLength > nLastGrooveBar) &&
                            (rand() % 3) )
                        {
                            AddCommand(rCommand.m_nMeasure - nBreakLength, PF_BREAK);
                        }
                    }
                }
            }
            bLastGroove = bGrooveLevel;
            if (rCommand.m_Command.bGrooveLevel) nLastGrooveBar = rCommand.m_nMeasure;
        }
    }
    if (fAddMore)
    {
        int nLastMeasure = 0;
        nLastGrooveBar = 0;
        bLastGroove = 0;
        pCommand = m_CommandList.GetHead();
        for (; pCommand; pCommand = pCommand->GetNext())
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            TListItem<TemplateCommand> *pNext = pCommand->GetNext();
            int nMeasure = rCommand.m_nMeasure;
            if (rCommand.m_Command.bCommand != DMUS_COMMANDT_GROOVE)
            {
                nLastMeasure = nMeasure;
                continue;
            }
            if (rCommand.m_Command.bCommand == DMUS_COMMANDT_GROOVE)
            {
                bLastGroove = rCommand.m_Command.bGrooveLevel;
            }
            if ( (nLastMeasure + nFillLength + nBreakLength + 4) < nMeasure )
            {
                if ((rand() % 3) == 0)  // do something?
                {                // perhaps a fill?
                    nLastMeasure = nMeasure;
                    if ((bLastGroove > 50) && 
                        (nMeasure >= nFillLength) && 
                        (nMeasure - nFillLength > nLastGrooveBar) && 
                        (rand() % 2))
                    {
                        AddCommand(nMeasure - nFillLength, PF_FILL);
                    }
                    else
                    {
                        if (pNext)
                        {
                            while (nMeasure + nBreakLength <= pNext->GetItemValue().m_nMeasure )
                            {
                                AddCommand(nMeasure, PF_BREAK);
                                nMeasure += nBreakLength;
                                if (rand() % 2) break;
                            }
                        }
                    }
                }
            }
            if (bLastGroove) nLastGrooveBar = rCommand.m_nMeasure;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDMTempl

CDMTempl::CDMTempl(  ) : m_cRef(1), m_pTemplateInfo(NULL), m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CDMTempl::~CDMTempl()
{
    if (m_fCSInitialized)
    {
        CleanUp();
        ::DeleteCriticalSection( &m_CriticalSection );
    }

    InterlockedDecrement(&g_cComponent);
}

void CDMTempl::CleanUp()
{
    if( m_pTemplateInfo != NULL )
    {
        delete m_pTemplateInfo;
        m_pTemplateInfo = NULL;
    }
}

STDMETHODIMP CDMTempl::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CDMTempl::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDMTempl)
    {
        *ppv = static_cast<IDMTempl*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDMTempl::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CDMTempl::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CDMTempl::SaveCommandList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE& rTimeSig )
{
    IStream*    pStream;
    MMCKINFO    ck;
    HRESULT     hr;
    DWORD       cb;
    DWORD        dwSize;
    DMUS_IO_COMMAND   iCommand;
    TListItem<TemplateCommand>* pCommand;

    if (!m_pTemplateInfo) return E_FAIL;
    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = FOURCC_COMMAND;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( DMUS_IO_COMMAND );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_pTemplateInfo->m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            if (rCommand.m_Command.bGrooveLevel || rCommand.m_Command.bCommand)
            {
                memset( &iCommand, 0, sizeof( iCommand ) );
                iCommand.mtTime = ClocksPerMeasure(rTimeSig) * rCommand.m_nMeasure;
                iCommand.wMeasure = rCommand.m_nMeasure;
                iCommand.bBeat = 0;
                iCommand.bCommand = rCommand.m_Command.bCommand;
                iCommand.bGrooveLevel = rCommand.m_Command.bGrooveLevel;
                iCommand.bGrooveRange = rCommand.m_Command.bGrooveRange;
                iCommand.bRepeatMode = rCommand.m_Command.bRepeatMode;
                if( FAILED( pStream->Write( &iCommand, sizeof( iCommand ), &cb ) ) ||
                    cb != sizeof( iCommand ) )
                {
                    break;
                }
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }

    pStream->Release();
    return hr;
}

HRESULT CDMTempl::SaveSignPostList( IAARIFFStream* pRIFF, DMUS_TIMESIGNATURE&   TimeSig )
{
    IStream*        pStream;
    MMCKINFO        ck;
    HRESULT         hr;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_SIGNPOST    oSignPost;
    TListItem<TemplateCommand>* pCommand;
    ;

    if (!m_pTemplateInfo) return E_FAIL;
    pStream = pRIFF->GetStream();
    if (!pStream) return E_FAIL;

    hr = E_FAIL;
    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( oSignPost );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            pStream->Release();
            return E_FAIL;
        }
        for( pCommand = m_pTemplateInfo->m_CommandList.GetHead(); pCommand != NULL ; pCommand = pCommand->GetNext() )
        {
            TemplateCommand& rCommand = pCommand->GetItemValue();
            memset( &oSignPost, 0, sizeof( oSignPost ) );
            oSignPost.mtTime = ClocksPerMeasure(TimeSig) * rCommand.m_nMeasure;
            oSignPost.wMeasure = rCommand.m_nMeasure;
            oSignPost.dwChords = rCommand.m_dwChord;
            if( FAILED( pStream->Write( &oSignPost, sizeof( oSignPost ), &cb ) ) ||
                cb != sizeof( oSignPost ) )
            {
                break;
            }
        }
        if( pCommand == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
    pStream->Release();
    return hr;
}

HRESULT CDMTempl::Init(void* pTemplate)
{
    CleanUp();
    m_pTemplateInfo = (TemplateStruct*)pTemplate;
    // fix groove levels in the command list
//  m_pTemplateInfo->FillInGrooveLevels();
    return S_OK;
}

HRESULT CDMTempl::CreateSegment(IDirectMusicSegment* pISegment)
{
    if (!pISegment) return E_INVALIDARG;
    if (!m_pTemplateInfo) return E_FAIL;

    IDirectMusicTrack*  pICommandTrack          = NULL;
    IDirectMusicTrack*  pISignPostTrack         = NULL;
    IAARIFFStream*      pCommandRIFF            = NULL;
    IStream*            pICommandStream         = NULL;
    IPersistStream*     pICommandTrackStream    = NULL;
    IPersistStream*     pISignPostTrackStream   = NULL;
    IAARIFFStream*      pSignPostRIFF           = NULL;
    IStream*            pISignPostStream        = NULL;
    HRESULT             hr                      = S_OK;
    DMUS_TIMESIGNATURE  TimeSig;

    // Fill in the time sig event with default values (4/4, 16th note resolution)
    TimeSig.mtTime = 0;
    TimeSig.bBeatsPerMeasure = 4;
    TimeSig.bBeat = 4;
    TimeSig.wGridsPerBeat = 4;

    // 1. Create Command and Sign Post Tracks.
    hr = ::CoCreateInstance(
        CLSID_DirectMusicCommandTrack,
        NULL,
        CLSCTX_INPROC, 
        IID_IDirectMusicTrack,
        (void**)&pICommandTrack
        );
    if (FAILED(hr)) goto ON_END;
    hr = ::CoCreateInstance(
        CLSID_DirectMusicSignPostTrack,
        NULL,
        CLSCTX_INPROC, 
        IID_IDirectMusicTrack,
        (void**)&pISignPostTrack
        );
    if (FAILED(hr)) goto ON_END;

    // 2. Write the template's command list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pICommandStream);
    if (S_OK != hr) goto ON_END;
    AllocRIFFStream( pICommandStream, &pCommandRIFF);
    if (!pCommandRIFF)
    {
        hr = E_FAIL;
        goto ON_END;
    }
    SaveCommandList(pCommandRIFF, TimeSig);

    // 3. Use the command list stream as input to the Command Track's Load method.
    hr = pICommandTrack->QueryInterface(IID_IPersistStream, (void**)&pICommandTrackStream);
    if(FAILED(hr)) goto ON_END;
    StreamSeek(pICommandStream, 0, STREAM_SEEK_SET);
    hr = pICommandTrackStream->Load(pICommandStream);
    if(FAILED(hr)) goto ON_END;

    // 4. Write the template's sign post list out to a stream.
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pISignPostStream);
    if(S_OK != hr) goto ON_END;
    AllocRIFFStream( pISignPostStream, &pSignPostRIFF);
    if (!pSignPostRIFF)
    {
        hr = E_FAIL;
        goto ON_END;
    }
    SaveSignPostList(pSignPostRIFF, TimeSig);

    // 5. Use the chord list stream as input to the Sign Post Track's Load method.
    hr = pISignPostTrack->QueryInterface(IID_IPersistStream, (void**)&pISignPostTrackStream);
    if(FAILED(hr)) goto ON_END;
    StreamSeek(pISignPostStream, 0, STREAM_SEEK_SET);
    hr = pISignPostTrackStream->Load(pISignPostStream);
    if (FAILED(hr)) goto ON_END;

    // 6. Create a Segment has been removed it is now passed in

    // 7. Initialize the segment appropriately.
    //pISegment->SetUserData(m_pTemplateInfo->m_nMeasures);
    pISegment->SetLength(ClocksPerMeasure(TimeSig) * m_pTemplateInfo->m_nMeasures);

    // 8. Insert the two Tracks into the Segment's Track list.
    pISegment->InsertTrack(pICommandTrack, 1);
    pISegment->InsertTrack(pISignPostTrack, 1);
    // Note: the segment must release the track objects...

ON_END:
    if (pICommandTrack) pICommandTrack->Release();
    if (pISignPostTrack) pISignPostTrack->Release();
    if (pCommandRIFF) pCommandRIFF->Release();
    if (pICommandStream) pICommandStream->Release();
    if (pICommandTrackStream) pICommandTrackStream->Release();
    if (pISignPostTrackStream) pISignPostTrackStream->Release();
    if (pSignPostRIFF) pSignPostRIFF->Release();
    if (pISignPostStream) pISignPostStream->Release();

    return hr;
}

HRESULT CDMTempl::GetClassID( LPCLSID pclsid )
{
    if ( pclsid == NULL ) return E_INVALIDARG;
    *pclsid = CLSID_DMTempl;
    return S_OK;
}

HRESULT CDMTempl::IsDirty()
{
    return ( m_fDirty ) ? S_OK : S_FALSE;
}

static TListItem<TemplateCommand>* loadacommand( LPSTREAM pStream, DWORD dwSize )
{
    CommandExt command;
    TListItem<TemplateCommand>* pCommand = new TListItem<TemplateCommand>;
    if( pCommand == NULL )
    {
        StreamSeek( pStream, dwSize, STREAM_SEEK_CUR );
        return NULL;
    }
    TemplateCommand& rCommand = pCommand->GetItemValue();

    if( dwSize > sizeof(CommandExt) )
    {
        pStream->Read( &command, sizeof(CommandExt), NULL );
        FixBytes( FBT_COMMANDEXT, &command );
        StreamSeek( pStream, dwSize - sizeof(CommandExt), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( &command, dwSize, NULL );
        FixBytes( FBT_COMMANDEXT, &command );
    }
    //rCommand.m_lTime = command->time;
    rCommand.m_nMeasure = command.measure;
    rCommand.m_Command.bGrooveRange = 0;
    rCommand.m_Command.bRepeatMode = 0;
    switch (command.command)
    {
    case PF_FILL:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_FILL;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_INTRO:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_INTRO;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_BREAK:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_BREAK;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_END:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_END;
        rCommand.m_Command.bGrooveLevel = 0;
        break;
    case PF_A:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 12;
        break;
    case PF_B:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 37;
        break;
    case PF_C:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 62;
        break;
    case PF_D:
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 87;
        break;
    default:  // default to a Groove with level 0 (interpretation: use previous groove level)
        // This happens in the measure following an embellishment
        rCommand.m_Command.bCommand = DMUS_COMMANDT_GROOVE;
        rCommand.m_Command.bGrooveLevel = 0;
    }
    rCommand.m_dwChord = command.chord;

    return pCommand;
}

HRESULT CDMTempl::LoadTemplate( LPSTREAM pStream, DWORD dwSize )
{
    TListItem<TemplateCommand>*     pCommand;
    DWORD         id = 0;
    DWORD         tsize = 0;
    DWORD         segsize = 0;
    SCTtemplate* pTemplate;
    long lSize = dwSize;

    if ( pStream == NULL ) return E_INVALIDARG;
    pTemplate = new SCTtemplate;
    if( pTemplate == NULL )
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }

    if (!GetMLong( pStream, tsize ))
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        delete pTemplate;
        return E_FAIL;
    }

    lSize -= 4;
    if( tsize > sizeof(SCTtemplate) )
    {
        pStream->Read( pTemplate, sizeof(SCTtemplate), NULL );
        FixBytes( FBT_SCTTEMPLATE, pTemplate );
        StreamSeek( pStream, tsize - sizeof(SCTtemplate), STREAM_SEEK_CUR );
    }
    else
    {
        pStream->Read( pTemplate, tsize, NULL );
        FixBytes( FBT_SCTTEMPLATE, pTemplate );
    }
    lSize -= tsize;

    m_pTemplateInfo = new TemplateStruct;
    if (!m_pTemplateInfo)
    {
        StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
        return E_OUTOFMEMORY;
    }
    m_pTemplateInfo->m_strName = pTemplate->achName;
    m_pTemplateInfo->m_strType = pTemplate->achType;
    m_pTemplateInfo->m_nMeasures = pTemplate->nMeasures;
    delete pTemplate;
    while( lSize > 0 )
    {
        pStream->Read( &id, 4, NULL );
        if (!GetMLong( pStream, segsize ))
        {
            StreamSeek( pStream, lSize, STREAM_SEEK_CUR );
            break;
        }

        lSize   -= 8;
        switch( id )
        {
        case mmioFOURCC( 'D', 'M', 'C', 's' ):
            pCommand = loadacommand( pStream, segsize );
            if( pCommand )
            {
                m_pTemplateInfo->m_CommandList.AddTail(pCommand);
            }
            break;

        default:
            StreamSeek( pStream, segsize, STREAM_SEEK_CUR );
            break;
        }

        lSize -= segsize;
    }

    // fix groove levels in the command list
    BYTE bLastGroove = 62; 
    pCommand = m_pTemplateInfo->m_CommandList.GetHead();
    for (; pCommand; pCommand = pCommand->GetNext())
    {
        TemplateCommand& rCommand = pCommand->GetItemValue();
        if (rCommand.m_Command.bGrooveLevel == 0)
        {
            rCommand.m_Command.bGrooveLevel = bLastGroove;
        }
        else bLastGroove = rCommand.m_Command.bGrooveLevel;
    }
    return S_OK;
}

// This loads a *single* template.  I also need to handle files that contain
// *lists* of templates (but I can just load the first one in the list)
HRESULT CDMTempl::Load( LPSTREAM pStream )
{
    FOURCC id;
    DWORD dwSize;
    HRESULT hr;

    if ( pStream == NULL ) return E_INVALIDARG;
    EnterCriticalSection( &m_CriticalSection );
    CleanUp();
    if( FAILED( pStream->Read( &id, sizeof( FOURCC ), NULL ) ) ||
        !GetMLong( pStream, dwSize ) )
    {
        hr = E_FAIL;
        goto end;
    }
    if( id != mmioFOURCC( 'L', 'P', 'T', 's' ) )
    {
        hr = E_FAIL;
        goto end;
    }
    hr = LoadTemplate( pStream, dwSize );
end:
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CDMTempl::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CDMTempl::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\iodmcomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       iodmcomp.h
//
//--------------------------------------------------------------------------

#ifndef PERSONALITYRIFF_H
#define PERSONALITYRIFF_H


// runtime chunks
#define FOURCC_PERSONALITY	mmioFOURCC('D','M','P','R')
#define FOURCC_IOPERSONALITY		mmioFOURCC('p','e','r','h')
#define DM_FOURCC_GUID_CHUNK        mmioFOURCC('g','u','i','d')
#define DM_FOURCC_INFO_LIST	        mmioFOURCC('I','N','F','O')
#define DM_FOURCC_VERSION_CHUNK     mmioFOURCC('v','e','r','s')
#define FOURCC_SUBCHORD				mmioFOURCC('c','h','d','t')
#define FOURCC_CHORDENTRY			mmioFOURCC('c','h','e','h')
#define FOURCC_SUBCHORDID			mmioFOURCC('s','b','c','n')
#define FOURCC_IONEXTCHORD			mmioFOURCC('n','c','r','d')
#define FOURCC_NEXTCHORDSEQ		  mmioFOURCC('n','c','s','q')
#define FOURCC_IOSIGNPOST			mmioFOURCC('s','p','s','h')
#define FOURCC_CHORDNAME			mmioFOURCC('I','N','A','M')

// runtime list chunks
#define FOURCC_LISTCHORDENTRY		mmioFOURCC('c','h','o','e')
#define FOURCC_LISTCHORDMAP			mmioFOURCC('c','m','a','p')
#define FOURCC_LISTCHORD			mmioFOURCC('c','h','r','d')
#define FOURCC_LISTCHORDPALETTE		mmioFOURCC('c','h','p','l')
#define FOURCC_LISTCADENCE			mmioFOURCC('c','a','d','e')
#define FOURCC_LISTSIGNPOSTITEM			mmioFOURCC('s','p','s','t')

#define FOURCC_SIGNPOSTLIST		mmioFOURCC('s','p','s','q')


// constants
const int MaxSubChords = 4;

// simple riff read/writers
inline HRESULT ReadWord(IAARIFFStream* pIRiffStream, WORD& val)
{
	assert(pIRiffStream);
	IStream* pIStream = pIRiffStream->GetStream();
	assert(pIStream);
	if(pIStream)
	{
		HRESULT hr = pIStream->Read(&val, sizeof(WORD), 0);
		pIStream->Release();
		return hr;
	}
	else
	{
		return E_FAIL;
	}
}

class ReadChunk
{
	MMCKINFO m_ck;
	MMCKINFO* m_pckParent;
	IAARIFFStream* m_pRiffStream;
	HRESULT m_hr;
public:
	ReadChunk(IAARIFFStream* pRiffStream, MMCKINFO* pckParent) : m_pRiffStream(pRiffStream)
	{
		m_pckParent = pckParent;
		m_hr = pRiffStream->Descend( &m_ck,  m_pckParent, 0 );
	}
	~ReadChunk()
	{
		if(m_hr == 0)
		{
			m_hr = m_pRiffStream->Ascend(&m_ck, 0);
		}
	}
	HRESULT	State(MMCKINFO* pck=0)
	{
		if(pck)
		{
			memcpy(pck, &m_ck, sizeof(MMCKINFO));
		}
		return m_hr;
	}
	FOURCC Id()
	{
		if(m_ck.ckid = FOURCC_LIST)
		{
			return m_ck.fccType;
		}
		else
		{
			return m_ck.ckid;
		}
	}
};


// run time data structs
struct ioPersonality
{
	char	szLoadName[20];
	DWORD	dwScalePattern;
	DWORD	dwFlags;
};

struct ioSubChord
{
	DWORD	dwChordPattern;
	DWORD	dwScalePattern;
	DWORD	dwInvertPattern;
	BYTE	bChordRoot;
	BYTE	bScaleRoot;
	WORD	wCFlags;
	DWORD	dwLevels;	// parts or which subchord levels this chord supports
};

struct ioChordEntry
{
	DWORD	dwFlags;
	WORD	wConnectionID;	// replaces runtime "pointer to this"
};

struct ioNextChord
{
	DWORD	dwFlags;
	WORD	nWeight;
	WORD	wMinBeats;
	WORD	wMaxBeats;
	WORD	wConnectionID;	// points to an ioChordEntry
};

struct ioSignPost
{
	DWORD	dwChords;	// 1bit per group
	DWORD	dwFlags;
};

/*
RIFF
(
	'DMPR'
	<perh-ck>			// Personality header chunk
	[<guid-ck>]			// guid chunk
	[<vers-ck>]			// version chunk (two DWORDS)
	<INFO-list>		  // standard MS Info chunk
	<chdt-ck>		   // subchord database
	<chpl-list>			// chord palette
	<cmap-list>		  // chord map
	<spst-list>			// signpost list
	[<ceed-ck>]		// optional chordmap position data
 )

 <chdt> ::= chdt(<cbChordSize::WORD>  <ioSubChord> ... )

<chpl-list> ::= LIST('chpl' 
								<chrd-list> ... // chord definition
							 )

<chrd-list> ::= LIST('chrd' 
								<INAM-ck> // name of chord in wide char format
								<sbcn-ck>	// list of subchords composing chord
								[<ched-ck>]   //  optional chord edit flags
								)

<cmap-list> ::= LIST('cmap' <choe-list> )

<choe-list> ::= LIST('choe'
								<cheh-ck>	// chord entry data
								<chrd-list>	// chord definition
								<ncsq-ck>	// connecting(next) chords
								)

<spst-list> ::= LIST('spst'
							 <spsh-ck>
							 <chrd-list>
							 [<cade-list>]
							 )

<cade-list> ::= LIST('cade' <chrd-list> ...)
								
<sbcn-ck> ::= sbcn(<cSubChordID:WORD>)

<ceed-ck> ::= ceed(ioChordEntryEdit)

<ched-ck> ::= ched(DMChordEdit)

<cheh-ck> ::= cheh(i<ioChordEntry>)

<ncrd-ck> ::= ncrd(<ioNextChord>)

<ncsq-ck> ::= ncsq(<wNextChordSize:WORD> <ioNextChord>...)

<spsh-ck> ::= spsh(<ioSignPost>)

*/

struct ioDMSignPost
{
	MUSIC_TIME	m_mtTime;
	DWORD		m_dwChords;
	WORD		m_wMeasure;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\fileio.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       fileio.cpp
//
//--------------------------------------------------------------------------

// FileIO.cpp
//

#include "aariff.h"

STDAPI AllocFileStream(LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream)
{
    HANDLE          hfile;          // handle to open file
    CFileStream *   pstream;        // IStream implementation

    // in case of error...
    *ppstream = NULL;

    // open the file
    if( dwDesiredAccess == GENERIC_READ )
    {
        hfile = CreateFile( szFileName, dwDesiredAccess, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else if( dwDesiredAccess == GENERIC_WRITE )
    {
        hfile = CreateFile( szFileName, dwDesiredAccess, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
    }
    else
    {
        return E_INVALIDARG;
    }
    if( hfile == INVALID_HANDLE_VALUE )
    {
        //DisplayDebug( 5, "File open error: Can't open \"%s\", error code %d", szFileName, GetLastError() );
        return E_FAIL; // to do: real error code
    }

    // create the Windows object
    if ((pstream = new CFileStream(hfile)) == NULL)
        return E_OUTOFMEMORY;

    // return an IStream pointer
    *ppstream = (IStream *) pstream;
    return S_OK;
}

STDAPI AllocRIFFStream( IStream* pStream, IAARIFFStream** ppRiff )
{
    if( ( *ppRiff = (IAARIFFStream*) new CRIFFStream( pStream ) ) == NULL )
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


/* MyRead, MyWrite, MySeek
 *
 * These are functionally identical to mmioRead, mmioWrite, and mmioSeek,
 * except for the absence of the HMMIO parameter.
 */

long CRIFFStream::MyRead(void *pv, long cb)
{
    ULONG cbRead;
    if (FAILED(m_pStream->Read(pv, cb, &cbRead)))
        return -1;
    return cbRead;
}

long CRIFFStream::MyWrite(const void *pv, long cb)
{
    ULONG cbWritten;
    if (FAILED(m_pStream->Write(pv, cb, &cbWritten)))
        return -1;
    return cbWritten;
}

long CRIFFStream::MySeek(long lOffset, int iOrigin)
{
    LARGE_INTEGER   dlibSeekTo;
    ULARGE_INTEGER  dlibNewPos;

    dlibSeekTo.HighPart = 0;
    dlibSeekTo.LowPart = lOffset;
    if (FAILED(m_pStream->Seek(dlibSeekTo, iOrigin, &dlibNewPos)))
        return -1;

    return dlibNewPos.LowPart;
}


UINT CRIFFStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    FOURCC          ckidFind;       // chunk ID to find (or NULL)
    FOURCC          fccTypeFind;    // form/list type to find (or NULL)

    /* figure out what chunk id and form/list type to search for */
    if (wFlags & MMIO_FINDCHUNK)
        ckidFind = lpck->ckid, fccTypeFind = NULL;
    else
    if (wFlags & MMIO_FINDRIFF)
        ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
    else
    if (wFlags & MMIO_FINDLIST)
        ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
    else
        ckidFind = fccTypeFind = NULL;

    lpck->dwFlags = 0L;

    for(;;)
    {
        UINT        w;

        /* read the chunk header */
        if (MyRead(lpck, 2 * sizeof(DWORD)) !=
            2 * sizeof(DWORD))
        return MMIOERR_CHUNKNOTFOUND;
        FixBytes( FBT_LONG, &lpck->cksize );

        /* store the offset of the data part of the chunk */
        if ((lpck->dwDataOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;

        /* see if the chunk is within the parent chunk (if given) */
        if ((lpckParent != NULL) &&
            (lpck->dwDataOffset - 8L >=
             lpckParent->dwDataOffset + lpckParent->cksize))
            return MMIOERR_CHUNKNOTFOUND;

        /* if the chunk if a 'RIFF' or 'LIST' chunk, read the
         * form type or list type
         */
        if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            if (MyRead(&lpck->fccType,
                     sizeof(DWORD)) != sizeof(DWORD))
                return MMIOERR_CHUNKNOTFOUND;
        }
        else
            lpck->fccType = NULL;

        /* if this is the chunk we're looking for, stop looking */
        if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
             ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
            break;

        /* ascend out of the chunk and try again */
        if ((w = Ascend(lpck, 0)) != 0)
            return w;
    }

    return 0;
}


UINT CRIFFStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    if (lpck->dwFlags & MMIO_DIRTY)
    {
        /* <lpck> refers to a chunk created by CreateChunk();
         * check that the chunk size that was written when
         * CreateChunk() was called is the real chunk size;
         * if not, fix it
         */
        LONG            lOffset;        // current offset in file
        LONG            lActualSize;    // actual size of chunk data

        if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
            return MMIOERR_CANNOTSEEK;
        if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
            return MMIOERR_CANNOTWRITE;

        if (LOWORD(lActualSize) & 1)
        {
            /* chunk size is odd -- write a null pad byte */
            if (MyWrite("\0", 1) != 1)
                return MMIOERR_CANNOTWRITE;

        }

        if (lpck->cksize == (DWORD)lActualSize)
            return 0;

        /* fix the chunk header */
        lpck->cksize = lActualSize;
        if (MySeek(lpck->dwDataOffset - sizeof(DWORD), SEEK_SET) == -1)
            return MMIOERR_CANNOTSEEK;
        FixBytes( FBT_LONG, &lpck->cksize );
        if (MyWrite(&lpck->cksize, sizeof(DWORD)) != sizeof(DWORD))  {
        	FixBytes( FBT_LONG, &lpck->cksize );
            return MMIOERR_CANNOTWRITE;
        }
        FixBytes( FBT_LONG, &lpck->cksize );
    }

    /* seek to the end of the chunk, past the null pad byte
     * (which is only there if chunk size is odd)
     */
    if (MySeek(lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L),
            SEEK_SET) == -1)
        return MMIOERR_CANNOTSEEK;

    return 0;
}


UINT CRIFFStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    int             iBytes;         // bytes to write
    LONG            lOffset;        // current offset in file

    /* store the offset of the data part of the chunk */
    if ((lOffset = MySeek(0L, SEEK_CUR)) == -1)
        return MMIOERR_CANNOTSEEK;
    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    /* figure out if a form/list type needs to be written */
    if (wFlags & MMIO_CREATERIFF)
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    else
    if (wFlags & MMIO_CREATELIST)
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    else
        iBytes = 2 * sizeof(DWORD);

    /* write the chunk header */
	FixBytes( FBT_MMCKINFO, lpck );
    if (MyWrite(lpck, (LONG) iBytes) != (LONG) iBytes)  {
    	FixBytes( FBT_MMCKINFO, lpck );
        return MMIOERR_CANNOTWRITE;
    }
    FixBytes( FBT_MMCKINFO, lpck );

    lpck->dwFlags = MMIO_DIRTY;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\oledll.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.cpp
//
//--------------------------------------------------------------------------

// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\perstrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       perstrk.h
//
//--------------------------------------------------------------------------

// PersTrk.h : Declaration of the CPersonalityTrack

#ifndef __PERSONALITYTRACK_H_
#define __PERSONALITYTRACK_H_

#include "dmusici.h"
#include "DMCompos.h"

struct StampedPersonality
{
	StampedPersonality() { m_pPersonality = NULL; }
	~StampedPersonality() { if (m_pPersonality) m_pPersonality->Release(); }
	MUSIC_TIME				m_mtTime;
	IDirectMusicChordMap*	m_pPersonality;
};

/////////////////////////////////////////////////////////////////////////////
// CPersonalityTrack
class CPersonalityTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CPersonalityTrack();
	CPersonalityTrack(const CPersonalityTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CPersonalityTrack();
	HRESULT LoadPersRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadPersRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent );
	HRESULT LoadReference(IStream *pStream,
						  IAARIFFStream *pIRiffStream,
						  MMCKINFO& ckParent,
						  IDirectMusicChordMap** ppPersonality);

public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

HRESULT STDMETHODCALLTYPE GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID						rCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

// IDirectMusicCommon Methods
HRESULT STDMETHODCALLTYPE GetName(
				/*[out]*/  BSTR*		pbstrName
			);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			);

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
// internal methods
/*
	HRESULT SendNotification(MUSIC_TIME mtTime,
						 IDirectMusicPerformance*	pPerf,
						 IDirectMusicSegment* pSegment,
						 IDirectMusicSegmentState*	pSegState,
						 DWORD dwFlags);
*/

    HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);

// attributes
    long m_cRef;
	TList<StampedPersonality>	m_PersonalityList;
    CRITICAL_SECTION			m_CriticalSection; // for load and GetParam
    BOOL                        m_fCSInitialized;
//  BOOL                        m_fNotifyRecompose;

	BYTE						m_bRequiresSave;
};

#endif //__PERSONALITYTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\opnew.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1999-1999 Microsoft Corporation
//
//  File:       opnew.cpp
//
//--------------------------------------------------------------------------

// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\perstrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       perstrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// PersTrk.cpp : Implementation of CPersonalityTrack
#include "DMPers.h"
#include "PersTrk.h"
#include "dmusicc.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CPersonalityTrack


CPersonalityTrack::CPersonalityTrack() : 
    m_bRequiresSave(0), 
    m_cRef(1),
    m_fCSInitialized(FALSE)

{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

CPersonalityTrack::CPersonalityTrack(const CPersonalityTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0),
    m_cRef(1),
    m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    TListItem<StampedPersonality>* pScan = rTrack.m_PersonalityList.GetHead();
    TListItem<StampedPersonality>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        StampedPersonality& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
            if (pNew)
            {
                StampedPersonality& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_pPersonality = rScan.m_pPersonality;
                if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
                m_PersonalityList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
        if (pNew)
        {
            StampedPersonality& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_pPersonality = pPrevious->GetItemValue().m_pPersonality;
            if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
            m_PersonalityList.AddHead(pNew);
        }
    }
}

CPersonalityTrack::~CPersonalityTrack()
{
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }
    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CPersonalityTrack::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CPersonalityTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPersonalityTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPersonalityTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CPersonalityTrack::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK;
}

HRESULT CPersonalityTrack::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    return S_OK;
}

HRESULT CPersonalityTrack::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    return S_OK;
}

HRESULT CPersonalityTrack::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{ 
    return S_OK;
}

HRESULT CPersonalityTrack::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CPersonalityTrack::GetParam(
                REFGUID                     rCommandGuid,
                MUSIC_TIME                  mtTime, 
                MUSIC_TIME*                 pmtNext,
                void*                       pData
            )
{
    V_INAME(CPersonalityTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rCommandGuid);

    if( NULL == pData )
    {
        Trace(1, "ERROR: GetParam (chord map track): pParam is NULL.\n");
        return E_POINTER;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (rCommandGuid == GUID_IDirectMusicChordMap)
    {
        TListItem<StampedPersonality>* pScan = m_PersonalityList.GetHead();
        if (pScan)
        {
            IDirectMusicChordMap* pPersonality = pScan->GetItemValue().m_pPersonality;
            for(pScan = pScan->GetNext(); pScan; pScan = pScan->GetNext())
            {
                StampedPersonality& rScan = pScan->GetItemValue();
                if (mtTime < rScan.m_mtTime  && rScan.m_pPersonality) break;  // ignore if NULL
                if (rScan.m_pPersonality) pPersonality = rScan.m_pPersonality; // skip if NULL
            }
            if (pPersonality)
            {
                pPersonality->AddRef();
                *(IDirectMusicChordMap**)pData = pPersonality;
                if (pmtNext)
                {
                    *pmtNext = (pScan != NULL) ? pScan->GetItemValue().m_mtTime - mtTime : 0;
                }
                hr = S_OK;
            }
            else
            {
                Trace(1, "ERROR: GetParam (chord map track): Chord map list item is empty.\n");
                hr = E_POINTER;
            }

        }
        else
        {
            Trace(1, "ERROR: GetParam (chord map track): Chord map track is empty.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        Trace(1, "ERROR: GetParam (chord map track): Attempt to get an unsupported parameter.\n");
        hr = DMUS_E_GET_UNSUPPORTED;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
} 

HRESULT CPersonalityTrack::SetParam( 
    REFGUID                     rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    V_INAME(CPersonalityTrack::SetParam);
    V_REFGUID(rCommandGuid);

    HRESULT hr;
    if (!pData)
    {
        Trace(1, "ERROR: SetParam (chord map track): pParam is NULL.\n");
        return E_POINTER;
    }

    EnterCriticalSection( &m_CriticalSection );
    if (rCommandGuid == GUID_IDirectMusicChordMap)
    {
        IDirectMusicChordMap* pPers = (IDirectMusicChordMap*)pData;
        TListItem<StampedPersonality>* pPersItem = m_PersonalityList.GetHead();
        TListItem<StampedPersonality>* pPrevious = NULL;
        TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
        }
        else 
        {
            pNew->GetItemValue().m_mtTime = mtTime;
            pNew->GetItemValue().m_pPersonality = pPers;
            if (pPers) pPers->AddRef();
            for(; pPersItem != NULL; pPersItem = pPersItem->GetNext())
            {
                if (pPersItem->GetItemValue().m_mtTime >= mtTime) break;
                pPrevious = pPersItem;
            }
            if (pPrevious)
            {
                pPrevious->SetNext(pNew);
                pNew->SetNext(pPersItem);
            }
            else // pPersItem is current head of list
            {
                m_PersonalityList.AddHead(pNew);
            }
            if (pPersItem && pPersItem->GetItemValue().m_mtTime == mtTime)
            {
                // remove it
                if (pPersItem->GetItemValue().m_pPersonality)
                {
                    pPersItem->GetItemValue().m_pPersonality->Release();
                }
                pPersItem->GetItemValue().m_pPersonality = NULL;
                pNew->SetNext(pPersItem->GetNext());
                pPersItem->SetNext(NULL);
                delete pPersItem;
            }
            hr = S_OK;
        }
    }
    else
    {
        Trace(1, "ERROR: SetParam (chord map track): Attempt to set an unsupported parameter.\n");
        hr = DMUS_E_SET_UNSUPPORTED;
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IPersist methods
 HRESULT CPersonalityTrack::GetClassID( LPCLSID pClassID )
{
    V_INAME(CPersonalityTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicChordMapTrack;
    return S_OK;
}

// IDirectMusicCommon Methods
HRESULT CPersonalityTrack::GetName(
                /*[out]*/  BSTR*        pbstrName
            )
{
    return E_NOTIMPL;
}

HRESULT CPersonalityTrack::IsParamSupported(
                /*[in]*/ REFGUID                        rGuid
            )
{
    V_INAME(CPersonalityTrack::IsParamSupported);
    V_REFGUID(rGuid);

    if (rGuid == GUID_IDirectMusicChordMap)
        return S_OK;
    else 
    {
        Trace(2, "WARNING: IsParamSupported (chord map track): The parameter is not supported.\n");
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

// IPersistStream methods
 HRESULT CPersonalityTrack::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CPersonalityTrack::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CPersonalityTrack::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}


BOOL Less(StampedPersonality& SP1, StampedPersonality& SP2)
{ return SP1.m_mtTime < SP2.m_mtTime; }

HRESULT CPersonalityTrack::Load(LPSTREAM pStream )
{
    V_INAME(CPersonalityTrack::Load);
    V_INTERFACE(pStream);

    IAARIFFStream*  pIRiffStream;
    //MMCKINFO      ckMain;
    MMCKINFO        ck;
    HRESULT         hr = E_FAIL;

    if ( pStream == NULL ) return E_INVALIDARG;
    EnterCriticalSection( &m_CriticalSection );
    if (m_PersonalityList.GetHead())
    {
        delete m_PersonalityList.GetHead();
        m_PersonalityList.RemoveAll();
    }

    if( SUCCEEDED( AllocRIFFStream( pStream, &pIRiffStream ) ) )
    {
        if (pIRiffStream->Descend( &ck, NULL, 0 ) == 0)
        {
            if (ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_PERS_TRACK_LIST)
            {
                hr = LoadPersRefList(pIRiffStream, &ck);
            }
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Release();
    }
    m_PersonalityList.MergeSort(Less);

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CPersonalityTrack::LoadPersRefList( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;

    while ( pIRiffStream->Descend( &ck, pckParent, 0 ) == 0  )
    {
        if ( ck.ckid == FOURCC_LIST && ck.fccType == DMUS_FOURCC_PERS_REF_LIST )
        {
            hr = LoadPersRef(pIRiffStream, &ck);
            pIRiffStream->Ascend( &ck, 0 );
        }
        pIRiffStream->Ascend( &ck, 0 );
    }

    return hr;
}

HRESULT CPersonalityTrack::LoadPersRef( IAARIFFStream* pIRiffStream, MMCKINFO* pckParent )
{
    HRESULT hr = S_OK;
    if (!pIRiffStream || !pckParent) return E_INVALIDARG;
    MMCKINFO ck;
    IStream* pIStream = pIRiffStream->GetStream();
    if(!pIStream) return E_FAIL;
    IDirectMusicChordMap* pPersonality = NULL;
    TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
    if (!pNew) return E_OUTOFMEMORY;
    StampedPersonality& rNew = pNew->GetItemValue();
    while (pIRiffStream->Descend( &ck, pckParent, 0 ) == 0)
    {
        switch (ck.ckid)
        {
        case DMUS_FOURCC_TIME_STAMP_CHUNK:
            {
                DWORD dwTime;
                DWORD cb;
                hr = pIStream->Read( &dwTime, sizeof( dwTime ), &cb );
                if (FAILED(hr) || cb != sizeof( dwTime ) ) 
                {
                    if (SUCCEEDED(hr)) hr = E_FAIL;
                    pIRiffStream->Ascend( &ck, 0 );
                    goto ON_END;
                }
                rNew.m_mtTime = dwTime;
            }
            break;
        case FOURCC_LIST:
            if (ck.fccType == DMUS_FOURCC_REF_LIST)
            {
                hr = LoadReference(pIStream, pIRiffStream, ck, &pPersonality);
                if (SUCCEEDED(hr))
                {
                    rNew.m_pPersonality = pPersonality;
                }
            }
            break;
        }
        pIRiffStream->Ascend( &ck, 0 );
    }
    if (SUCCEEDED(hr))
    {
        m_PersonalityList.AddTail(pNew);
    }
    else
    {
        delete pNew;
    }
ON_END:
    pIStream->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPersonalityTrack::LoadReference

HRESULT CPersonalityTrack::LoadReference(IStream *pStream,
                                         IAARIFFStream *pIRiffStream,
                                         MMCKINFO& ckParent,
                                         IDirectMusicChordMap** ppPersonality)
{
    if (!pStream || !pIRiffStream || !ppPersonality) return E_INVALIDARG;

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;  
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    DWORD cbRead;
    
    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;
        
    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == 0 )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_REFERENCE))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(GUID))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(FILETIME))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszName[DMUS_MAX_NAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr) && cbRead == dwSize)
                {
                    desc.wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr) && cbRead == sizeof(DMUS_IO_VERSION))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                else if(SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    
        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == 0)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = E_FAIL;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDirectMusicChordMap, (void**)ppPersonality);
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::AddNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::RemoveNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPersonalityTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CPersonalityTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1, "ERROR: Clone (chord map track): Invalid  start time.\n");
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1, "ERROR: Clone (chord map track): Invalid  end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );

    CPersonalityTrack *pDM;
    
    try
    {
        pDM = new CPersonalityTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CPersonalityTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CPersonalityTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CPersonalityTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CPersonalityTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CPersonalityTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup) 
{
    HRESULT hr = S_OK;
    CPersonalityTrack* pOtherTrack = (CPersonalityTrack*)pNewTrack;
    TListItem<StampedPersonality>* pScan = pOtherTrack->m_PersonalityList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        StampedPersonality& rScan = pScan->GetItemValue();
        TListItem<StampedPersonality>* pNew = new TListItem<StampedPersonality>;
        if (pNew)
        {
            StampedPersonality& rNew = pNew->GetItemValue();
            rNew.m_mtTime = rScan.m_mtTime + mtJoin;
            rNew.m_pPersonality = rScan.m_pPersonality;
            if (rNew.m_pPersonality) rNew.m_pPersonality->AddRef();
            m_PersonalityList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\sjpers.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       sjpers.h
//
//--------------------------------------------------------------------------

// SJPers.h  #defines and structs from SuperJam!  Used for loading personalities.

#define CM_DEFAULT  2               // Prsonality.dwflags & CM_DEFAULT

#define SP_A        1       // Use SP flags for templates
#define SP_B        2
#define SP_C        4
#define SP_D        8
#define SP_E        0x10
#define SP_F        0x20
#define SP_LETTER   (SP_A | SP_B | SP_C | SP_D | SP_E | SP_F)
#define SP_1        0x100
#define SP_2        0x200
#define SP_3        0x400
#define SP_4        0x800
#define SP_5        0x1000
#define SP_6        0x2000
#define SP_7        0x4000
#define SP_ROOT     (SP_1 | SP_2 | SP_3 | SP_4 | SP_5 | SP_6 | SP_7)
#define SP_CADENCE  0x8000

#define SPOST_CADENCE1  2   // Use the first cadence chord.
#define SPOST_CADENCE2  4   // Use the second cadence chord.

#define PF_FILL     0x0001      // Fill pattern
#define PF_START    0x0002      // May be starting pattern
#define PF_INTRO    0x0002
#define PF_WHOLE    0x0004      // Handles chords on measures
#define PF_HALF     0x0008      // Chords every two beats
#define PF_QUARTER  0x0010      // Chords on beats
#define PF_BREAK    0x0020
#define PF_END      0x0040
#define PF_A        0x0080
#define PF_B        0x0100
#define PF_C        0x0200
#define PF_D        0x0400
#define PF_E        0x0800
#define PF_F        0x1000
#define PF_G        0x2000
#define PF_H        0x10000
#define PF_STOPNOW  0x4000
#define PF_INRIFF   0x8000
#define PF_MOTIF    0x20000     // this pattern is a motif, not a regular pattern
#define PF_BEATS    ( PF_WHOLE | PF_HALF | PF_QUARTER )
#define PF_RIFF     ( PF_INTRO | PF_BREAK | PF_FILL | PF_END )
#define PF_GROOVE   ( PF_A | PF_B | PF_C | PF_D | PF_E | PF_F | PF_G | PF_H )


/*  SCTchord bBits flags ===============================================*/

#define CHORD_INVERT  0x10      /* This chord may be inverted           */
#define CHORD_FOUR    0x20      /* This should be a 4 note chord        */
#define CHORD_UPPER   0x40      /* Shift upper octave down              */
#define CHORD_SIMPLE  0x80      /* This is a simple chord               */
#define CHORD_COUNT   0x0F      /* Number of notes in chord (up to 15)  */

#pragma pack(1)

typedef struct ChordExt    FAR *LPCHORDEXT;
struct ChordExt   // Based on ChordSelection
{
    LPCHORDEXT pNext;
    long       time;
    long       pattern;      // Pattern that defines chord
    char       name[12];     // Text for display
    char       keydown;      // Currently held down
    char       root;         // Root note of chord
    char       inscale;      // Member of scale
    char       flat;         // Display with flat
    short      varflags;     // Used to select appropriate variation
    short      measure;      // What measure
    char       beat;         // What beat this falls on
    unsigned   char bits;    // Invert and item count
    long       scalepattern; // Scale Pattern for the chord
    long       melodypattern;// Melody Pattern for the chord
};

typedef struct SinePost    FAR *LPSINEPOST ;
struct SinePost
{
    LPSINEPOST      pNext ;          // The next personality in the list.
    ChordExt        chord;          // Chord for sign post.
    ChordExt        cadence[2];     // Chords for cadence.
    DWORD           chords;         // Which kinds of signpost supported.
    DWORD           flags;
    DWORD           tempflags;
};

typedef struct ChrdEntry   FAR *LPCHRDENTRY ;

typedef struct NextChrd    FAR *LPNEXTCHRD ;
struct NextChrd
{
    LPNEXTCHRD      pNext;           // List of chords to go to next.
    LPCHRDENTRY     nextchord;
    unsigned long   dwflags;
    short           nweight;        // Importance of destination chord.
    short           nminbeats;      // Min beats to wait till chord.
    short           nmaxbeats;      // Max beats to wait till chord.
    short           nid;            // ID of destination chord.
};

#define NEXTCHORD_SIZE  (sizeof(NextChrd)-sizeof(LPNEXTCHRD)-sizeof(LPCHRDENTRY))
#define CHORDENTRY_SIZE (sizeof(ChordExt)-sizeof(LPCHORDEXT)+sizeof(unsigned long)+sizeof(short))

#define CE_SELECTED 1               // This is the active chord.
#define CE_START    2
#define CE_END      4
#define CE_MEASURE  8
#define CE_PATH     16
#define CE_TREE     32

struct ChrdEntry
{
    LPCHRDENTRY     pNext ;          // The next personality in the list.
    LPNEXTCHRD      nextchordlist;  // List of chords to go to next.
    ChordExt        chord;          // Chord definition.
    unsigned long   dwflags;        // Various flags.
    short           nid;            // ID for pointer maintenance.
};

typedef struct SCTchord     FAR *LPSCTCHORD ;
struct SCTchord
{
    LPSCTCHORD      pNext;         /* The next chord in the list.      */
    long            lDLL1;          /*   Reserved for use by score.dll  */
    long            lPattern;       /* Pattern that defines chord.      */
    char            achName[12];    /* Chord name.                      */
    char            chDLL2;         /*   Reserved for use by score.dll  */
    char            chRoot;         /* Root note of chord.              */
    char            chDLL3;         /*   Reserved for use by score.dll  */
    char            chFlat;         /* Indicates root is flat.          */
    short           nDLL4;          /*   Reserved for use by score.dll  */
    short           nMeasure;       /* Measure this chord occurs.       */
    char            chBeat;         /* Beat this chord falls on.        */
    BYTE            bBits;          /* Flags used when playing chord    */
    long            lScalePattern;  /* Scale Pattern for the chord.     */
    long            lMelodyPattern; /* Melody Pattern for the chord.    */
};

typedef struct SCTpersonality FAR *LPSCTPERSONALITY ;
struct SCTpersonality
{
    LPSCTPERSONALITY pNext ;       /* Next SCTpersonality in the list. */
    char        achName[20] ;       /* Name of composition personality. */
    char        achDescription[80];/* Description of personality.      */
    char        achUserName[20];/* Description of personality.      */
    LPVOID      lpDLL1 ;            /*   Reserved for use by score.dll  */
    long        lScalePattern ;     /* Scale pattern used by personality*/
    SCTchord    chord[24] ;         /* 24 note chord palette.           */
    char        chDefault ;         /* 0=Not default. 1=Default.        */
    char        chDLL1 ;            /*  Reserved for use by score.dll   */
};

typedef struct Prsonality    FAR *LPPERSONALITY ;
struct Prsonality
{
    LPPERSONALITY   pNext ;          // The next personality in the list.
    LPCHRDENTRY     chordlist;      // All chords in the map.
    LPSINEPOST      signpostlist;   // All available sign posts.
    DWORD           dwAA;           // only valid for separately loaded personalities
    long            scalepattern;   // Scale for map.
    char            name[20];
    char            description[80];
    char            username[20];
    SCTchord        chord[24];
    unsigned long   dwflags;
    long            playlist;       // Collection of NextChords for playback.
    LPCHRDENTRY     firstchord;
    struct SCTpersonality* lpSCTpersonality;
};

typedef struct CommandExt    FAR *LPCOMMAND;
typedef struct CommandExt
{
    LPCOMMAND   pNext;
    long        time;       // Time, in clocks
    short       measure;    // Which measure
    DWORD       command;    // Command type
    DWORD       chord;      // Used by composition engine
} CommandExt;

typedef struct SCTcommand   FAR *LPSCTCOMMAND ;
typedef struct SCTcommand
{
    LPSCTCOMMAND  pNext ;    // The next command in the list.
    long          lDLL1 ;     //   Reserved for use by score.dll.
    short         nMeasure ;  // Measure this command occurs. 
    DWORD         dwCommand ; // Command type. 
    DWORD         dwChord ;   // Signpost chord.
} SCTcommand ;

typedef struct SCTtemplate  FAR *LPSCTTEMPLATE ;
typedef struct SCTtemplate
{
    LPSCTTEMPLATE pNext ;           // The next template in the list.
    char          achName[20] ;      // Template name.
    char          achType[20] ;      // Template type.
    short         nMeasures ;
    LPSCTCOMMAND  lpSCTcommandList ; // Template commands. 
} SCTtemplate ;

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmcompos

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=dmcompod
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmcompos.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1
USE_IOSTREAM=1

!if !$(FREEBUILD)

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /W3 /WX

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
	   $(SDK_LIB_PATH)\user32.lib		\
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\ole32.lib

INCLUDES=$(INCLUDES);   \
    ..\..\shared

SOURCES=\
..\debug.cpp           \
..\dmcmpdll.cpp            \
..\dmcompos.cpp            \
..\dmpers.cpp          \
..\dmtempl.cpp         \
..\fileio.cpp          \
..\oledll.cpp          \
..\spsttrk.cpp         \
..\str.cpp             \
..\perstrk.cpp             \
..\dmcompos.rc         \
..\opnew.cpp           \
..\dmcomp2.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\oledll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       oledll.h
//
//--------------------------------------------------------------------------

//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\spsttrk.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       spsttrk.cpp
//
//--------------------------------------------------------------------------

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// SPstTrk.cpp : Implementation of CSPstTrk
#include "SPstTrk.h"
#include "debug.h"
#include "..\shared\Validate.h"

/////////////////////////////////////////////////////////////////////////////
// CSPstTrk


CSPstTrk::CSPstTrk() : 
    m_bRequiresSave(0), m_pPerformance(NULL),
    m_pComposer(NULL),
    m_fNotifyRecompose(FALSE),
//  m_pSegment(NULL),
    m_cRef(1),
    m_fCSInitialized(FALSE)

{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
}

// This assumes cloning on measure boundaries
CSPstTrk::CSPstTrk(const CSPstTrk& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)  : 
    m_bRequiresSave(0), m_pPerformance(NULL),
    m_pComposer(NULL),
    m_fNotifyRecompose(FALSE),
    //m_pSegment(NULL),
    m_cRef(1),
    m_fCSInitialized(FALSE)
{
    InterlockedIncrement(&g_cComponent);

    // Do this first since it might throw an exception
    //
    ::InitializeCriticalSection( &m_CriticalSection );
    m_fCSInitialized = TRUE;
    BOOL fStarted = FALSE;
    WORD wMeasure = 0;
    TListItem<DMSignPostStruct>* pScan = rTrack.m_SignPostList.GetHead();
    TListItem<DMSignPostStruct>* pPrevious = NULL;
    for(; pScan; pScan = pScan->GetNext())
    {
        DMSignPostStruct& rScan = pScan->GetItemValue();
        if (rScan.m_mtTime < mtStart)
        {
            pPrevious = pScan;
        }
        else if (rScan.m_mtTime < mtEnd)
        {
            if (rScan.m_mtTime == mtStart)
            {
                pPrevious = NULL;
            }
            if (!fStarted)
            {
                fStarted = TRUE;
                wMeasure = rScan.m_wMeasure;
            }
            TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>;
            if (pNew)
            {
                DMSignPostStruct& rNew = pNew->GetItemValue();
                rNew.m_mtTime = rScan.m_mtTime - mtStart;
                rNew.m_wMeasure = rScan.m_wMeasure - wMeasure;
                rNew.m_dwChords = rScan.m_dwChords;
                m_SignPostList.AddTail(pNew);
            }
        }
        else break;
    }
    if (pPrevious)
    {
        TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>;
        if (pNew)
        {
            DMSignPostStruct& rNew = pNew->GetItemValue();
            rNew.m_mtTime = 0;
            rNew.m_wMeasure = 0;
            rNew.m_dwChords = pPrevious->GetItemValue().m_dwChords;
            m_SignPostList.AddHead(pNew);
        }
    }
}

CSPstTrk::~CSPstTrk()
{
    if (m_pComposer)
    {
        delete m_pComposer;
    }
    if (m_fCSInitialized)
    {
        ::DeleteCriticalSection( &m_CriticalSection );
    }

    InterlockedDecrement(&g_cComponent);
}

void CSPstTrk::Clear()
{
    m_SignPostList.CleanUp();
}


STDMETHODIMP CSPstTrk::QueryInterface(
    const IID &iid, 
    void **ppv) 
{
    V_INAME(CSPstTrk::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSPstTrk::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CSPstTrk::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CSPstTrk::Init(
                /*[in]*/  IDirectMusicSegment*      pSegment
            )
{
    return S_OK; // if I return an error, dmime gives me an assertion failure
}

HRESULT CSPstTrk::InitPlay(
                /*[in]*/  IDirectMusicSegmentState* pSegmentState,
                /*[in]*/  IDirectMusicPerformance*  pPerformance,
                /*[out]*/ void**                    ppStateData,
                /*[in]*/  DWORD                     dwTrackID,
                /*[in]*/  DWORD                     dwFlags
            )
{
    EnterCriticalSection(&m_CriticalSection);
    // get rid of any existing composer object
    if (m_pComposer)
    {
        delete m_pComposer;
        m_pComposer = NULL;
    }

    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr = pSegmentState->GetSegment(&pSegment);
    if (SUCCEEDED(hr))
    {
        m_pComposer = new CDMCompos;
        if(!m_pComposer) 
        {
            hr = E_OUTOFMEMORY;
        }
        pSegment->Release();
    }
    else
    {
        Trace(2, "WARNING: InitPlay (Signpost Track): Segment State does not contain a segment.\n");
        hr = S_OK; // Let it succeed anyway.  Just means we can't compose on the fly.
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSPstTrk::EndPlay(
                /*[in]*/  void*                     pStateData
            )
{
    EnterCriticalSection(&m_CriticalSection);
    // get rid of any existing composer object
    if (m_pComposer)
    {
        delete m_pComposer;
        m_pComposer = NULL;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSPstTrk::Play(
                /*[in]*/  void*                     pStateData, 
                /*[in]*/  MUSIC_TIME                mtStart, 
                /*[in]*/  MUSIC_TIME                mtEnd, 
                /*[in]*/  MUSIC_TIME                mtOffset,
                          DWORD                     dwFlags,
                          IDirectMusicPerformance*  pPerf,
                          IDirectMusicSegmentState* pSegState,
                          DWORD                     dwVirtualID
            )
{
    bool fStart = (dwFlags & DMUS_TRACKF_START) ? true : false;
    bool fLoop = (dwFlags & DMUS_TRACKF_LOOP) ? true : false;
    bool fCompose = (dwFlags & DMUS_TRACKF_RECOMPOSE) ? true : false;
    bool fPlayOff = (dwFlags & DMUS_TRACKF_PLAY_OFF) ? true : false;
    EnterCriticalSection(&m_CriticalSection);
    if ( fStart || fLoop ) 
    {
        if ( fCompose && !fPlayOff )
        {
            IDirectMusicSegment* pSegment = NULL;
            if (SUCCEEDED(pSegState->GetSegment(&pSegment)))
            {
                // call ComposeSegmentFromTemplateEx on this segment
                if (m_pComposer)
                {
                    // Should an activity level be allowed if desired?
                    // This could be handled via a SetParam.
                    m_pComposer->ComposeSegmentFromTemplateEx(
                        NULL,
                        pSegment,
                        0,      // ignore activity level, don't clone
                        0,      // for activity level
                        NULL,
                        NULL
                    );
                    // if we recomposed, send a recompose notification
                    SendNotification(mtStart + mtOffset, pPerf, pSegment, pSegState, dwFlags);
                }
                pSegment->Release();
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSPstTrk::SendNotification(MUSIC_TIME mtTime,
                                        IDirectMusicPerformance*    pPerf,
                                        IDirectMusicSegment* pSegment,
                                        IDirectMusicSegmentState*   pSegState,
                                        DWORD dwFlags)
{
    if (!m_fNotifyRecompose || (dwFlags & DMUS_TRACKF_NOTIFY_OFF))
    {
        return S_OK;
    }
    DMUS_NOTIFICATION_PMSG* pEvent = NULL;
    HRESULT hr = pPerf->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), (DMUS_PMSG**)&pEvent );
    if( SUCCEEDED( hr ))
    {
        pEvent->dwField1 = 0;
        pEvent->dwField2 = 0;
        pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
        pEvent->mtTime = mtTime;
        pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
        pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

        pEvent->dwNotificationOption = DMUS_NOTIFICATION_RECOMPOSE;
        pEvent->guidNotificationType = GUID_NOTIFICATION_RECOMPOSE;

        if (FAILED(pSegment->GetTrackGroup(this, &pEvent->dwGroupID)))
        {
            pEvent->dwGroupID = 0xffffffff;
        }

        IDirectMusicGraph* pGraph;
        hr = pSegState->QueryInterface( IID_IDirectMusicGraph, (void**)&pGraph );
        if( SUCCEEDED( hr ))
        {
            pGraph->StampPMsg((DMUS_PMSG*) pEvent );
            pGraph->Release();
        }
        hr = pPerf->SendPMsg((DMUS_PMSG*) pEvent );
        if( FAILED(hr) )
        {
            pPerf->FreePMsg((DMUS_PMSG*) pEvent );
        }
    }
    return hr;
}

HRESULT CSPstTrk::GetPriority( 
                /*[out]*/ DWORD*                    pPriority 
            )
    {
        return E_NOTIMPL;
    }

HRESULT CSPstTrk::GetParam(
                REFGUID                     rCommandGuid,
                MUSIC_TIME                  mtTime, 
                MUSIC_TIME*                 pmtNext,
                void*                       pData
            )
{
    return E_NOTIMPL;
} 

HRESULT CSPstTrk::SetParam( 
    REFGUID                     rCommandGuid,
    MUSIC_TIME mtTime,
    void __RPC_FAR *pData)
{
    return E_NOTIMPL;
}

// IPersist methods
 HRESULT CSPstTrk::GetClassID( LPCLSID pClassID )
{
    V_INAME(CSPstTrk::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicSignPostTrack;
    return S_OK;
}

// IDirectMusicCommon Methods
HRESULT CSPstTrk::GetName(
                /*[out]*/  BSTR*        pbstrName
            )
{
    return E_NOTIMPL;
}

HRESULT CSPstTrk::IsParamSupported(
                /*[in]*/ REFGUID                        rGuid
            )
{
    return E_NOTIMPL;
}

// IPersistStream methods
 HRESULT CSPstTrk::IsDirty()
{
     return m_bRequiresSave ? S_OK : S_FALSE;
}

HRESULT CSPstTrk::Save( LPSTREAM pStream, BOOL fClearDirty )
{
    V_INAME(CSPstTrk::Save);
    V_INTERFACE(pStream);

    IAARIFFStream* pRIFF = NULL;
    MMCKINFO        ck;
    HRESULT         hr;
    DWORD           cb;
    DWORD           dwSize;
    DMUS_IO_SIGNPOST    oSignPost;
    TListItem<DMSignPostStruct>* pSignPost;

    EnterCriticalSection( &m_CriticalSection );
    hr = AllocRIFFStream( pStream, &pRIFF );
    if ( FAILED( hr ) )
    {
        goto ON_END;
    }
    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( pRIFF->CreateChunk( &ck, 0 ) == 0 )
    {
        dwSize = sizeof( oSignPost );
        hr = pStream->Write( &dwSize, sizeof( dwSize ), &cb );
        if( FAILED( hr ) || cb != sizeof( dwSize ) )
        {
            if (SUCCEEDED(hr)) hr = E_FAIL;
            goto ON_END;
        }
        for( pSignPost = m_SignPostList.GetHead(); pSignPost != NULL ; pSignPost = pSignPost->GetNext() )
        {
            DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
            memset( &oSignPost, 0, sizeof( oSignPost ) );
            oSignPost.mtTime = rSignPost.m_mtTime;
            oSignPost.wMeasure = rSignPost.m_wMeasure;
            oSignPost.dwChords = rSignPost.m_dwChords;
            if( FAILED( pStream->Write( &oSignPost, sizeof( oSignPost ), &cb ) ) ||
                cb != sizeof( oSignPost ) )
            {
                break;
            }
        }
        if( pSignPost == NULL &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
        }
    }
ON_END:
    if (pRIFF) pRIFF->Release();
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT CSPstTrk::GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ )
{
    return E_NOTIMPL;
}


BOOL Less(DMSignPostStruct& SP1, DMSignPostStruct& SP2)
{ return SP1.m_wMeasure < SP2.m_wMeasure; }

HRESULT CSPstTrk::Load(LPSTREAM pStream )
{
    V_INAME(CSPstTrk::Load);
    V_INTERFACE(pStream);

    HRESULT         hr = E_FAIL;
    DWORD dwPos;
    IAARIFFStream*  pRIFF;

    EnterCriticalSection( &m_CriticalSection );
    Clear();
    dwPos = StreamTell( pStream );
    StreamSeek( pStream, dwPos, STREAM_SEEK_SET );
    MMCKINFO        ck;
    long lFileSize = 0;
    DWORD dwNodeSize;
    DWORD       cb;
    DMUS_IO_SIGNPOST        iSignPost;

    ck.ckid = DMUS_FOURCC_SIGNPOST_TRACK_CHUNK;
    if( SUCCEEDED( AllocRIFFStream( pStream, &pRIFF ) ) &&
        pRIFF->Descend( &ck, NULL, MMIO_FINDCHUNK ) == 0 )
    {
        lFileSize = (long) ck.cksize;
        hr = pStream->Read( &dwNodeSize, sizeof( dwNodeSize ), &cb );
        if( SUCCEEDED( hr ) && cb == sizeof( dwNodeSize ) )
        {
            lFileSize -= 4; // for the size dword
            TListItem<DMSignPostStruct>* pSignPost;
            if (lFileSize % dwNodeSize)
            {
                hr = E_FAIL;
            }
            else
            {
                while( lFileSize > 0 )
                {
                    //TraceI(0, "File size: %d\n", lFileSize);
                    pSignPost = new TListItem<DMSignPostStruct>;
                    if( pSignPost )
                    {
                        DMSignPostStruct& rSignPost = pSignPost->GetItemValue();
                        if( dwNodeSize <= sizeof( iSignPost ) )
                        {
                            pStream->Read( &iSignPost, dwNodeSize, NULL );
                        }
                        else
                        {
                            pStream->Read( &iSignPost, sizeof( iSignPost ), NULL );
                            DWORD dw = (lFileSize >= sizeof( iSignPost ) ) ? lFileSize - sizeof( iSignPost ) : 0;
                            StreamSeek( pStream, dw, STREAM_SEEK_CUR );
                        }
                        memset( &rSignPost, 0, sizeof( rSignPost ) );
                        rSignPost.m_mtTime = iSignPost.mtTime;
                        rSignPost.m_wMeasure = iSignPost.wMeasure;
                        rSignPost.m_dwChords = iSignPost.dwChords;
                        m_SignPostList.AddTail(pSignPost);
                        lFileSize -= dwNodeSize;
                    }
                    else break;
                }
            }
        }
        if( lFileSize == 0 &&
            pRIFF->Ascend( &ck, 0 ) == 0 )
        {
            hr = S_OK;
            m_SignPostList.MergeSort(Less);
        }
        pRIFF->Release();
    }
    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

HRESULT STDMETHODCALLTYPE CSPstTrk::AddNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::AddNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = TRUE;
        return S_OK;
    }
    else
    {
        Trace(2, "WARNING: AddNotificationType (signpost track): Notification type not supported.\n");
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CSPstTrk::RemoveNotificationType(
    /* [in] */  REFGUID                     rGuidNotify)
{
    V_INAME(CPersonalityTrack::RemoveNotificationType);
    V_REFGUID(rGuidNotify);

    if( rGuidNotify == GUID_NOTIFICATION_RECOMPOSE )
    {
        m_fNotifyRecompose = FALSE;
        return S_OK;
    }
    else
    {
        Trace(2, "WARNING: RemoveNotificationType (signpost track): Notification type not supported.\n");
        return S_FALSE;
    }
}

HRESULT STDMETHODCALLTYPE CSPstTrk::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(CSPstTrk::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1, "ERROR: Clone (signpost map): Invalid  start time.\n");
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1, "ERROR: Clone (signpost map): Invalid  end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection( &m_CriticalSection );
    
    CSPstTrk *pDM;
    
    try
    {
        pDM = new CSPstTrk(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL) {
        LeaveCriticalSection( &m_CriticalSection );
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    LeaveCriticalSection( &m_CriticalSection );
    return hr;
}

// IDirectMusicTrack8 Methods

// For consistency with other track types
STDMETHODIMP CSPstTrk::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
    if (prtNext)
    {
        *prtNext = mtNext;
    }
    return hr;
}

// For consistency with other track types
STDMETHODIMP CSPstTrk::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}

// For consistency with other track types
STDMETHODIMP CSPstTrk::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    hr = Play(pStateData, (MUSIC_TIME)rtStart, (MUSIC_TIME)rtEnd,
          (MUSIC_TIME)rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID);
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSPstTrk::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Compose)

    V_INTERFACE(pContext);
    V_PTRPTR_WRITE(ppResultTrack);

    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = S_OK;
    IDirectMusicTrack* pChordTrack = NULL;
    IDirectMusicTrack8* pCommandTrack = NULL;
    IDirectMusicStyle* pStyle = NULL;
    IDirectMusicTrack8* pChordMapTrack = NULL;
    IAARIFFStream*          pChordRIFF              = NULL;
    IStream*                pIChordStream           = NULL;
    IPersistStream*         pIChordTrackStream      = NULL;
    CDMCompos* pComposer = NULL;

    MUSIC_TIME mtLength = 0;

    IDirectMusicSegment* pTempSeg = NULL;
    IDirectMusicSong* pSong = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pTempSeg)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            Trace(1, "ERROR: Compose (signpost track): Missing segment or song.\n");
            hr = E_INVALIDARG;
            goto ON_END;
        }
    }

    if (pTempSeg)
    {
        if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle)))
        {
            if (FAILED(hr = pTempSeg->GetParam(GUID_IDirectMusicPatternStyle, dwTrackGroup, 0, 0, NULL, (void*)&pStyle)))
            {
                goto ON_END;
            }
        }
        hr = pTempSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pChordMapTrack);
        if (FAILED(hr)) goto ON_END;
        if (FAILED(hr = pTempSeg->GetLength(&mtLength))) goto ON_END;
        hr = pTempSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pCommandTrack);
        if (FAILED(hr)) goto ON_END;
    }
    else if (pSong)
    {
        MUSIC_TIME mtNow = 0;
        MUSIC_TIME mtNext = 0;
        while (FAILED(hr = pSong->GetParam(GUID_IDirectMusicStyle, dwTrackGroup, 0, mtNow, &mtNext, (void*)&pStyle)))
        {
            if (SUCCEEDED(hr = pSong->GetParam(GUID_IDirectMusicPatternStyle, dwTrackGroup, 0, mtNow, NULL, (void*)&pStyle)))
            {
                break;
            }
            if (mtNext <= 0) goto ON_END;
            mtNow = mtNext;
        }
        IDirectMusicSegment* pSeg = NULL;
        DWORD dwSeg = 0;
        while (S_OK == hr)
        {
            if (FAILED(hr = pSong->EnumSegment(dwSeg, &pSeg))) goto ON_END;
            if (hr == S_OK)
            {
                HRESULT hrCommand = S_OK;
                HRESULT hrChordMap = S_OK;
                MUSIC_TIME mt = 0;
                hr = pSeg->GetLength(&mt);
                if (FAILED(hr))
                {
                    pSeg->Release();
                    goto ON_END;
                }

                IDirectMusicTrack8* pSegTrack = NULL;
                IDirectMusicTrack8* pSegTrack2 = NULL;
                hrCommand = pSeg->GetTrack(CLSID_DirectMusicCommandTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pSegTrack);
                hrChordMap = pSeg->GetTrack(CLSID_DirectMusicChordMapTrack, dwTrackGroup, 0, (IDirectMusicTrack**)&pSegTrack2);
                pSeg->Release();
                pSeg = NULL;
                if (SUCCEEDED(hrCommand))
                {
                    if (!pCommandTrack)
                    {
                        hr = pSegTrack->Clone(0, 0, (IDirectMusicTrack**)&pCommandTrack);
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = pCommandTrack->Join(pSegTrack, mtLength, pSong, dwTrackGroup, NULL);
                    }
                    pSegTrack->Release();
                }
                if (SUCCEEDED(hrChordMap))
                {
                    if (!pChordMapTrack)
                    {
                        hr = pSegTrack2->Clone(0, 0, (IDirectMusicTrack**)&pChordMapTrack);
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = pChordMapTrack->Join(pSegTrack2, mtLength, pSong, dwTrackGroup, NULL);
                    }
                    pSegTrack2->Release();
                }
                if (FAILED(hr))  goto ON_END;
                mtLength += mt;
                dwSeg++;
            }
        }
    }

    pComposer = new CDMCompos;
    if(!pComposer) 
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        TList<PlayChord> PlayList;
        BYTE bRoot = 0; 
        DWORD dwScale;
        hr = pComposer->ComposePlayListFromTemplate(
            pStyle, NULL, pChordMapTrack, (IDirectMusicTrack*)this, pCommandTrack, dwTrackGroup,
            mtLength, false, 0, PlayList, bRoot, dwScale);
        // create a new chord track
        DMUS_TIMESIGNATURE      TimeSig;
        // Fill in the time sig event with default values (4/4, 16th note resolution)
        TimeSig.mtTime = 0;
        TimeSig.bBeatsPerMeasure = 4;
        TimeSig.bBeat = 4;
        TimeSig.wGridsPerBeat = 4;
        hr = ::CoCreateInstance(
            CLSID_DirectMusicChordTrack,
            NULL,
            CLSCTX_INPROC, 
            IID_IDirectMusicTrack,
            (void**)&pChordTrack
            );
        if (!SUCCEEDED(hr)) goto ON_END;
        hr = CreateStreamOnHGlobal(NULL, TRUE, &pIChordStream);
        if (S_OK != hr) goto ON_END;
        hr = AllocRIFFStream( pIChordStream, &pChordRIFF);
        if (S_OK != hr) goto ON_END;
        pComposer->SaveChordList(pChordRIFF, PlayList, bRoot, dwScale, TimeSig);
        hr = pChordTrack->QueryInterface(IID_IPersistStream, (void**)&pIChordTrackStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        StreamSeek(pIChordStream, 0, STREAM_SEEK_SET);
        hr = pIChordTrackStream->Load(pIChordStream);
        if (!SUCCEEDED(hr)) goto ON_END;
        *ppResultTrack = pChordTrack;
    }

ON_END:
    if (pComposer) pComposer->CleanUp();
    if (pStyle) pStyle->Release();
    if (pChordRIFF) pChordRIFF->Release();
    if (pIChordStream) pIChordStream->Release();
    if (pIChordTrackStream) pIChordTrackStream->Release();
    if (pCommandTrack) pCommandTrack->Release();
    if (pChordMapTrack) pChordMapTrack->Release();
    if (pComposer) delete pComposer;
    if (pSong) pSong->Release();
    if (pTempSeg) pTempSeg->Release();

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSPstTrk::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    TList<DMSignPostStruct> ResultList;
    CSPstTrk* pResultTrack = NULL;
    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        pResultTrack = (CSPstTrk*)*ppResultTrack;
        while(!pResultTrack->m_SignPostList.IsEmpty())
        {
            ResultList.AddHead(pResultTrack->m_SignPostList.RemoveHead());
        }
    }
    else
    {
        pResultTrack = this;
        while(!m_SignPostList.IsEmpty() && 
              m_SignPostList.GetHead()->GetItemValue().m_mtTime < mtJoin)
        {
            ResultList.AddHead(m_SignPostList.RemoveHead());
        }
        m_SignPostList.CleanUp();
    }
    WORD wMeasure = 0;
    HRESULT hrTimeSig = S_OK;
    MUSIC_TIME mtTimeSig = 0;
    MUSIC_TIME mtOver = 0;
    IDirectMusicSong* pSong = NULL;
    IDirectMusicSegment* pSegment = NULL;
    if (FAILED(pContext->QueryInterface(IID_IDirectMusicSegment, (void**)&pSegment)))
    {
        if (FAILED(pContext->QueryInterface(IID_IDirectMusicSong, (void**)&pSong)))
        {
            hrTimeSig = E_FAIL;
        }
    }
    while (SUCCEEDED(hrTimeSig) && mtTimeSig < mtJoin)
    {
        DMUS_TIMESIGNATURE TimeSig;
        MUSIC_TIME mtNext = 0;
        if (pSegment)
        {
            hrTimeSig = pSegment->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        else
        {
            hrTimeSig = pSong->GetParam(GUID_TimeSignature, dwTrackGroup, 0, mtTimeSig, &mtNext, (void*)&TimeSig);
        }
        if (SUCCEEDED(hrTimeSig))
        {
            if (!mtNext) mtNext = mtJoin - mtTimeSig; // means no more time sigs
            WORD wMeasureOffset = ClocksToMeasure(mtNext + mtOver, TimeSig);
            MUSIC_TIME mtMeasureOffset = (MUSIC_TIME) wMeasureOffset;
            // The following line crashes on certain builds on certain machines.
            // mtOver = mtMeasureOffset ? (mtNext % mtMeasureOffset) : 0;
            if (mtMeasureOffset)
            {
                mtOver = mtNext % mtMeasureOffset;
            }
            else
            {
                mtOver = 0;
            }
            wMeasure += wMeasureOffset;
            mtTimeSig += mtNext;
        }
    }
    CSPstTrk* pOtherTrack = (CSPstTrk*)pNewTrack;
    TListItem<DMSignPostStruct>* pScan = pOtherTrack->m_SignPostList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        TListItem<DMSignPostStruct>* pNew = new TListItem<DMSignPostStruct>(pScan->GetItemValue());
        if (pNew)
        {
            pNew->GetItemValue().m_mtTime += mtJoin;
            pNew->GetItemValue().m_wMeasure += wMeasure;
            ResultList.AddHead(pNew);
        }
        else
        {
            ResultList.CleanUp();
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        pResultTrack->m_SignPostList.CleanUp();
        while(!ResultList.IsEmpty() )
        {
            pResultTrack->m_SignPostList.AddHead(ResultList.RemoveHead());
        }
    }
    if (pSong) pSong->Release();
    if (pSegment) pSegment->Release();
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\spsttrk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       spsttrk.h
//
//--------------------------------------------------------------------------

// SPstTrk.h : Declaration of the CSPstTrk

#ifndef __SPSTTRK_H_
#define __SPSTTRK_H_

#include "dmusici.h"
#include "DMCompos.h"

/////////////////////////////////////////////////////////////////////////////
// CSPstTrk
class CSPstTrk : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSPstTrk();
	CSPstTrk(const CSPstTrk& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSPstTrk();

// ISPstTrk
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

// ICommandTrack Methods
HRESULT STDMETHODCALLTYPE Init(
				/*[in]*/  IDirectMusicSegment*		pSegment
			);

HRESULT STDMETHODCALLTYPE InitPlay(
				/*[in]*/  IDirectMusicSegmentState*	pSegmentState,
				/*[in]*/  IDirectMusicPerformance*	pPerformance,
				/*[out]*/ void**					ppStateData,
				/*[in]*/  DWORD						dwTrackID,
                /*[in]*/  DWORD                     dwFlags
			);

HRESULT STDMETHODCALLTYPE EndPlay(
				/*[in]*/  void*						pStateData
			);

HRESULT STDMETHODCALLTYPE Play(
				/*[in]*/  void*						pStateData, 
				/*[in]*/  MUSIC_TIME				mtStart, 
				/*[in]*/  MUSIC_TIME				mtEnd, 
				/*[in]*/  MUSIC_TIME				mtOffset,
						  DWORD						dwFlags,
						  IDirectMusicPerformance*	pPerf,
						  IDirectMusicSegmentState*	pSegState,
						  DWORD						dwVirtualID
			);

HRESULT STDMETHODCALLTYPE GetPriority( 
				/*[out]*/ DWORD*					pPriority 
			);

HRESULT STDMETHODCALLTYPE GetParam(
				REFGUID						rCommandGuid,
				MUSIC_TIME					mtTime, 
				MUSIC_TIME*					pmtNext,
				void*						pData
			);

	HRESULT STDMETHODCALLTYPE SetParam( 
		/* [in] */ REFGUID						rCommandGuid,
		/* [in] */ MUSIC_TIME mtTime,
		/* [out] */ void __RPC_FAR *pData);

	HRESULT STDMETHODCALLTYPE AddNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE RemoveNotificationType(
				/* [in] */  REFGUID						rGuidNotify
			);

	HRESULT STDMETHODCALLTYPE Clone(
		MUSIC_TIME mtStart,
		MUSIC_TIME mtEnd,
		IDirectMusicTrack** ppTrack);

// IDirectMusicCommon Methods
HRESULT STDMETHODCALLTYPE GetName(
				/*[out]*/  BSTR*		pbstrName
			);

HRESULT STDMETHODCALLTYPE IsParamSupported(
				/*[in]*/ REFGUID						rGuid
			);

// IPersist methods
 HRESULT STDMETHODCALLTYPE GetClassID( LPCLSID pclsid );

// IPersistStream methods
 HRESULT STDMETHODCALLTYPE IsDirty();

HRESULT STDMETHODCALLTYPE Save( LPSTREAM pStream, BOOL fClearDirty );

HRESULT STDMETHODCALLTYPE GetSizeMax( ULARGE_INTEGER* /*pcbSize*/ );

HRESULT STDMETHODCALLTYPE Load( LPSTREAM pStream );

// IDirectMusicTrack8 Methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

protected:
// internal methods
	HRESULT SendNotification(MUSIC_TIME mtTime,
						 IDirectMusicPerformance*	pPerf,
						 IDirectMusicSegment* pSegment,
						 IDirectMusicSegmentState*	pSegState,
						 DWORD dwFlags);

	void Clear();

// attributes
    long m_cRef;
	TList<DMSignPostStruct>		m_SignPostList;
    CRITICAL_SECTION			m_CriticalSection; // for load and SetParam
    BOOL                        m_fCSInitialized;
	IDirectMusicPerformance*	m_pPerformance; // is this necessary?
	CDMCompos*					m_pComposer; // for Segment Recompose on loop
//	IDirectMusicSegment*		m_pSegment;
    BOOL                        m_fNotifyRecompose;

	BYTE						m_bRequiresSave;
};

#endif //__SPSTTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\tlist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.cpp
//
//--------------------------------------------------------------------------

//
// tlist.cpp
//

//#include "stdafx.h"
#include "tlist.h"

template <class T>
TListItem<T>::~TListItem()
{
	//if (m_pNext != NULL) { delete m_pNext; }
	// IMPORTANT: user of the list is required to delete content first!
	//ZeroMemory(&m_Tinfo, sizeof(T));
}

template <class T>
void TListItem<T>::Delete(TListItem<T>* pFirst)
{
	TListItem<T>* pScan = pFirst;
	TListItem<T>* pNext = NULL;
	while (pScan)
	{
		pNext = pScan->m_pNext;
		delete pScan;
		pScan = pNext;
	}
}

template <class T>
LONG TListItem<T>::GetCount(void) const
{
    LONG l;
    const TListItem<T> *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

template <class T>
TListItem<T>* TListItem<T>::Cat(TListItem<T> *pItem)
{
    TListItem<T> *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::Remove(TListItem<T> *pItem)
{
    TListItem<T> *li,*prev;

    if(pItem==this)
        return m_pNext;
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);
    return this;
}

template <class T>
TListItem<T>* TListItem<T>::GetPrev(TListItem<T> *pItem) const
{
    const TListItem<T> *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (TListItem<T>*)prev;
}

template <class T>
TListItem<T> * TListItem<T>::GetItem(LONG index)

{
	TListItem<T> *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

template <class T>
TListItem<T>* TListItem<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pNext != NULL)
	{
		TListItem<T> *pList1, *pList2;
		Divide(pList1, pList2);
		return pList1->MergeSort(fcnCompare)->Merge(pList2->MergeSort(fcnCompare), fcnCompare);
	}
	return this;
}

template <class T>
void TListItem<T>::Divide(TListItem<T>*& pHead1, TListItem<T>*& pHead2)
{
	TListItem<T> *pCurrent = this, *pTail1 = NULL, *pTail2 = NULL;
	do
	{
		pHead1 = pCurrent;
		pCurrent = pCurrent->m_pNext;
		pHead1->m_pNext = pTail1;
		pTail1 = pHead1;
		if (pCurrent != NULL)
		{
			pHead2 = pCurrent;
			pCurrent = pCurrent->m_pNext;
			pHead2->m_pNext = pTail2;
			pTail2 = pHead2;
		}
	} while (pCurrent != NULL);
}

template <class T>
TListItem<T>* TListItem<T>::Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&))
{
	if (!pOtherList) return this;
	TListItem<T>
		*pThisList = this, *pResultHead = NULL, *pResultTail = NULL, *pMergeItem = NULL;
	while (pThisList && pOtherList)
	{
		if ( fcnCompare(pThisList->m_Tinfo, pOtherList->m_Tinfo) )
		{
			pMergeItem = pThisList;
			pThisList = pThisList->GetNext();
		}
		else
		{
			pMergeItem = pOtherList;
			pOtherList = pOtherList->GetNext();
		}
		pMergeItem->SetNext(NULL);
		if (!pResultTail)
		{
			pResultHead = pResultTail = pMergeItem;
		}
		else
		{
			pResultTail->SetNext(pMergeItem);
			pResultTail = pMergeItem;
		}
	}
	if (pThisList) pResultTail->SetNext(pThisList);
	else pResultTail->SetNext(pOtherList);
	return pResultHead;
}

template <class T>
void TList<T>::InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert)

{
	TListItem<T> *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

template <class T>
void TList<T>::AddTail(TListItem<T> *pItem) 

{
	m_pHead = m_pHead->AddTail(pItem);
}

template <class T>
void TList<T>::MergeSort(BOOL (* fcnCompare) (T&, T&))
{
	if (m_pHead != NULL && m_pHead->GetNext() != NULL)
		m_pHead = m_pHead->MergeSort(fcnCompare);
}

template <class T>
void TList<T>::Reverse(void)
{
	if( m_pHead )
	{
		TListItem<T>* pNewHead = m_pHead;
		TListItem<T>* pNext = m_pHead->GetNext();
		pNewHead->SetNext(NULL);
		for( m_pHead = pNext; m_pHead; m_pHead = pNext )
		{
			pNext = m_pHead->GetNext();
			m_pHead->SetNext(pNewHead);
			pNewHead = m_pHead;
		}
		m_pHead = pNewHead;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\tlist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       tlist.h
//
//--------------------------------------------------------------------------

//
// tlist.h --- template version of AList
//
#ifndef __TLIST_H__
#define __TLIST_H__

//#include "stdafx.h"

//template <class T>
//typedef BOOL (* TRelation) (T, T);

// TListItem<> contains four more members than AListItem: one additional constructor,
// a destructor, one member function, and one data member.
template <class T>
class TListItem
{
public:
    TListItem() { m_pNext=NULL; };
    ~TListItem();												// new destructor
	static void Delete(TListItem<T>* pFirst);                           // new deletion helper
    TListItem(const T& item) { m_Tinfo = item; m_pNext=NULL; };	// additional constructor.
    TListItem<T> *GetNext() const {return m_pNext;};
    void SetNext(TListItem<T> *pNext) {m_pNext=pNext;};
    LONG GetCount() const;
    TListItem<T>* Cat(TListItem<T>* pItem);
    TListItem<T>* AddTail(TListItem<T>* pItem) {return Cat(pItem);};
    TListItem<T>* Remove(TListItem<T>* pItem);
    TListItem<T>* GetPrev(TListItem<T> *pItem) const;
    TListItem<T>* GetItem(LONG index);
    T& GetItemValue() { return m_Tinfo; }  // additional member function
	TListItem<T>* MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list items 
private:
	void Divide(TListItem<T>* &pHalf1, TListItem<T>* &pHalf2);
	TListItem<T>* Merge(TListItem<T>* pOtherList, BOOL (* fcnCompare) (T&, T&));
	T m_Tinfo;  // additional data member, but memory is the same since in AListItem 
				// you put the extra data member in the derived class 
    TListItem<T> *m_pNext;
};

// TList<> adds a destructor to AList.
template <class T>
class TList
{
public:
    TList() {m_pHead=NULL;}
	~TList()
	{ 
		//if (m_pHead != NULL) delete m_pHead;
		TListItem<T>::Delete(m_pHead);
	} // new destructor
    TListItem<T> *GetHead() const { return m_pHead;};

    void RemoveAll() { m_pHead=NULL;};
    void CleanUp() 
	{ 
		//if (m_pHead) delete m_pHead;
		if (m_pHead) TListItem<T>::Delete(m_pHead);
		m_pHead=NULL;
	}
    LONG GetCount() const {return m_pHead->GetCount();}; 
    TListItem<T> *GetItem(LONG index) { return m_pHead->GetItem(index);}; 
    void InsertBefore(TListItem<T> *pItem,TListItem<T> *pInsert);
    void Cat(TListItem<T> *pItem) {m_pHead=m_pHead->Cat(pItem);};
    void Cat(TList<T> *pList)
        {
//            assert(pList!=NULL);
            m_pHead=m_pHead->Cat(pList->GetHead());
        };
    void AddHead(TListItem<T> *pItem)
        {
//            assert(pItem!=NULL);
            pItem->SetNext(m_pHead);
            m_pHead=pItem;
        }
    void AddTail(TListItem<T> *pItem);// {m_pHead=m_pHead->AddTail(pItem);};
    void Remove(TListItem<T> *pItem) {m_pHead=m_pHead->Remove(pItem);};
    TListItem<T> *GetPrev(TListItem<T> *pItem) const {return m_pHead->GetPrev(pItem);};
    TListItem<T> *GetTail() const {return GetPrev(NULL);};
    BOOL IsEmpty(void) const {return (m_pHead==NULL);};
    TListItem<T> *RemoveHead(void)
        {
            TListItem<T> *li;
            li=m_pHead;
            if(m_pHead)
			{
                m_pHead=m_pHead->GetNext();
				li->SetNext(NULL);
			}
            return li;
        }
	void MergeSort(BOOL (* fcnCompare) (T&, T&)); // Destructively mergeSorts the list
	void Reverse(void); // Reverses the entire list

protected:
    TListItem<T> *m_pHead;
};

#include "tlist.cpp"

#endif // __TLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\audpath.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// audpath.cpp : Implementation of CAudioPath

#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "dmsegobj.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "..\shared\Validate.h"
#include "audpath.h"
#include "debug.h"
#include "..\shared\dmusiccp.h"


#define ASSERT  assert

CBufferNode::CBufferNode()

{
    m_lActivateCount = 0;
    m_cRef = 1;
    m_pBuffer = NULL;
    m_pManager = NULL;
}

CBufferNode::~CBufferNode()

{
    FinalDeactivate();
    if (m_pManager)
    {
        m_pManager->Remove(this);
    }
}

ULONG CBufferNode::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CBufferNode::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CBufferNode::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    if (m_pBuffer)
    {
        if (fActivate)
        {
            if (!m_lActivateCount)
            {
                // Don't bother starting if the primary buffer.
                if (SUCCEEDED(hr) && !(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                {
                    TraceI(2,"Play buffer %lx\n",m_pBuffer);
                    hr = m_pBuffer->Play(0,0,DSBPLAY_LOOPING);
#ifdef DBG
                    if (FAILED(hr))
                    {
                        Trace(1,"Error: Activate on audiopath failed because buffer failed Play command.\n");
                    }
#endif
                }
            }
            if (hr == S_OK)
            {
                m_lActivateCount++;
            }
            TraceI(3,"Incrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
        }
        else
        {
            if (m_lActivateCount > 0)
            {
                m_lActivateCount--;
                if (!m_lActivateCount)
                {
                    // Don't bother stopping the primary buffer.
                    if (!(m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                    {
                        TraceI(2,"Stop buffer %lx\n",m_pBuffer);
                        hr = m_pBuffer->Stop();
                    }
                }
                TraceI(3,"Decrementing %lx to %ld\n",m_pBuffer,m_lActivateCount);
                if (hr != S_OK)
                {
                    m_lActivateCount++;
                }
            }
        }
    }
    return hr;
}


void CBufferNode::FinalDeactivate()

{
    if (m_lActivateCount)
    {
        Activate(FALSE);
    }
    if (m_pBuffer)
    {
        m_pBuffer->Release();
        m_pBuffer = NULL;
    }
}

CBufferManager::CBufferManager()
{
    m_pFirstBuffer = NULL;
    m_pSinkConnect = NULL;
    m_pSynthSink = NULL;
    m_pPerf = NULL;
}

CBufferManager::~CBufferManager()
{
    Clear();
    if (m_pSinkConnect)
    {
        m_pSinkConnect->Release();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Release();
    }
}

HRESULT CBufferManager::Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams)

{
    HRESULT hr = S_OK;
    m_pPerf = pPerf;
    m_AudioParams = *pAudioParams;
    CBufferNode *pNode = new CBufferNode;
    if (pNode)
    {
        pNode->m_BufferHeader.guidBufferID = GUID_Buffer_Primary;
        pNode->m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_PRIMARY;
        pNode->m_pManager = this;
        AddHead(pNode);
        // Create the primary buffer. This will be used for requests to access the listener.
        DSBUFFERDESC dsbdesc;
        memset(&dsbdesc, 0, sizeof(dsbdesc));
        dsbdesc.dwSize = sizeof(dsbdesc);
        dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;

        // create primary buffer
        if (SUCCEEDED(hr = pPerf->m_pDirectSound->CreateSoundBuffer(&dsbdesc, &pNode->m_pBuffer, NULL)))
        {
            WAVEFORMATEX wfPrimary;
            memset(&wfPrimary, 0, sizeof(wfPrimary));

            if (SUCCEEDED(hr = pNode->m_pBuffer->GetFormat(&wfPrimary, sizeof(wfPrimary), NULL)))
            {
                assert(wfPrimary.wFormatTag == WAVE_FORMAT_PCM);

                BOOL fUpgrade = FALSE;
                if (wfPrimary.nSamplesPerSec < m_AudioParams.dwSampleRate)
                {
                    wfPrimary.nSamplesPerSec = m_AudioParams.dwSampleRate;
                    fUpgrade = TRUE;
                }
                if (wfPrimary.wBitsPerSample < 16)
                {
                    wfPrimary.wBitsPerSample = 16;
                    fUpgrade = TRUE;
                }

                if (fUpgrade)
                {
                    wfPrimary.nBlockAlign = wfPrimary.nChannels * (wfPrimary.wBitsPerSample / 8);
                    wfPrimary.nAvgBytesPerSec = wfPrimary.nSamplesPerSec * wfPrimary.nBlockAlign;

                    // the existing format is of lesser quality than we desire, so let's upgrade it
                    if (FAILED(hr = pNode->m_pBuffer->SetFormat( &wfPrimary )))
                    {
                        if (hr == DSERR_PRIOLEVELNEEDED)
                        {
                            // okay, so maybe the app doen't want us changing primary buffer
                            Trace(0, "SynthSink - SetFormat on primary buffer failed, lacking priority\n");
                        }
                        else
                        {
                            Trace(0, "SynthSink - Activation failed, couldn't set primary buffer format\n");
                        }
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CBufferManager::InitSink(/*WAVEFORMATEX *pSinkFormat*/)

{
    HRESULT hr = S_OK;
    // Only init the sink if it's needed. If the audiopaths will be using buffers,
    // we need the sink. If not, bypass setting it up.
    if (!m_pSinkConnect && (m_pPerf->m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
    {
        static WAVEFORMATEX sDefaultFormat = { WAVE_FORMAT_PCM,1,22050,22050*2,2,16,0 };
        sDefaultFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
        sDefaultFormat.nAvgBytesPerSec = m_AudioParams.dwSampleRate * 2;
        sDefaultFormat.cbSize = 0;
        sDefaultFormat.nBlockAlign = 2;
        sDefaultFormat.nChannels = 1;
        sDefaultFormat.wBitsPerSample = 16;
        sDefaultFormat.wFormatTag = WAVE_FORMAT_PCM;

        IDirectSoundPrivate* pDSPrivate;
        hr = m_pPerf->m_pDirectSound->QueryInterface(IID_IDirectSoundPrivate, (void**)&pDSPrivate);

        if (SUCCEEDED(hr))
        {
            hr = pDSPrivate->AllocSink(&sDefaultFormat, &m_pSinkConnect);
            pDSPrivate->Release();
        }

        if (SUCCEEDED(hr))
        {
            IReferenceClock *pClock = NULL;
            hr = m_pPerf->m_pDirectMusic->GetMasterClock(NULL, &pClock);
            if (SUCCEEDED(hr))
            {
                hr = m_pSinkConnect->SetMasterClock(pClock);
                pClock->Release();
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pSinkConnect->QueryInterface(IID_IDirectSoundSynthSink,(void **) &m_pSynthSink);
            if (SUCCEEDED(hr))
            {
                hr = m_pSynthSink->Activate(TRUE);
            }
        }
        if (SUCCEEDED(hr))
        {
            // Create a dummy buffer that gets activated at the start and stays active until
            // the sink closes down. This is an unfortunate patch to the "clock-hopping" bug.
            // Once we come up with a better solution for providing timing from the sink, this
            // can go away.
            CBufferConfig Config(BUFFER_MONO);
            hr = CreateBuffer(&Config,&m_pFirstBuffer);
            if (SUCCEEDED(hr))
            {
                hr = m_pFirstBuffer->Activate(TRUE);
            }
        }
    }
    return hr;
}

void CBufferManager::FinalDeactivate()
{
    // Kill dummy buffer.
    if (m_pFirstBuffer)
    {
        m_pFirstBuffer->Activate(FALSE);
        delete m_pFirstBuffer;
        m_pFirstBuffer = NULL;
    }
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        pNode->FinalDeactivate();
    }
    if (m_pSynthSink)
    {
        m_pSynthSink->Activate(FALSE);
        m_pSynthSink->Release();
        m_pSynthSink = NULL;
    }
    if (m_pSinkConnect)
    {
        m_pSinkConnect->SetMasterClock(NULL);
        m_pSinkConnect->Release();
        m_pSinkConnect = NULL;
    }
}

void CBufferManager::Clear()
{
    CBufferNode *pNode;
    FinalDeactivate();
    while (pNode = GetHead())
    {
        delete pNode;
    }
}

CBufferNode *CBufferManager::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pNode = GetHead();
    for (;pNode;pNode = pNode->GetNext())
    {
        if (pNode->m_BufferHeader.guidBufferID == guidBufferID)
        {
            pNode->AddRef();
            break;
        }
    }
    return pNode;
}

HRESULT CBufferManager::CreateBuffer(CBufferConfig *pConfig, CBufferConfig ** ppNew)

{
    HRESULT hr = S_OK;
    if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
    {
        ASSERT(m_pSinkConnect);

        CBufferConfig *pNew = new CBufferConfig(pConfig->m_dwStandardBufferID);
        if (pNew)
        {
            *ppNew = pNew;
            pNew->m_BufferHeader = pConfig->m_BufferHeader;
            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
            {
                // Check to see if there already is a buffer in the list with this GUID.
                CBufferNode *pNode = GetHead();
                for (;pNode;pNode = pNode->GetNext())
                {
                    if (pNode->m_BufferHeader.dwFlags & DMUS_BUFFERF_SHARED)
                    {
                        if (pNode->m_BufferHeader.guidBufferID == pConfig->m_BufferHeader.guidBufferID)
                        {
                            pNew->m_pBufferNode = pNode;
                            pNode->AddRef();
                            TraceI(2,"Found shared Buffer %lx\n",pNode->m_pBuffer);
                            return S_OK;
                        }
                    }
                }
            }
            // Either the buffer does not already exist, or it is not to be shared, so
            // create a new buffer node and requested buffer.
            CBufferNode *pNode = new CBufferNode;
            if (pNode)
            {
                pNode->m_BufferHeader = pConfig->m_BufferHeader;
                // Predefined buffer type?
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_DEFINED)
                {
                    // Must be a standard type. Create by hand.
                    CBufferNode *pSendNode = NULL;
                    DSBUFFERDESC BufferDesc;
                    WAVEFORMATEX WaveFormat;
                    DWORD dwFunctionIDs[2];
                    CLSID clsidDMO;
                    BOOL fDMO = FALSE;
                    DWORD dwNumFunctionIDs;
                    memset(&BufferDesc, 0, sizeof(BufferDesc));
                    BufferDesc.dwSize  = sizeof(BufferDesc);
                    BufferDesc.lpwfxFormat = &WaveFormat;
                    BufferDesc.dwBufferBytes = 0;
                    BufferDesc.dwFlags = 0;
                    memset(&WaveFormat,0,sizeof(WaveFormat));
                    WaveFormat.nChannels = 2;
                    switch (pConfig->m_dwStandardBufferID)
                    {
                    case BUFFER_REVERB :
                        dwFunctionIDs[0] = DSBUSID_REVERB_SEND;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        clsidDMO = GUID_DSFX_WAVES_REVERB;
                        fDMO = TRUE;
                        break;
                    case BUFFER_ENVREVERB :
                        dwNumFunctionIDs = 0;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags = DSBCAPS_MIXIN | DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME;
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2REVERB;
                        fDMO = TRUE;
                        if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
                        {
                            hr = DMUS_E_AUDIOPATH_NOBUFFER;
                            Trace(1,"Audiopath Creation error: Requested Environmental reverb buffer when DMUS_AUDIOF_ENVIRON not enabled via InitAudio.\n");
                        }
                        break;
                        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*                    case BUFFER_3D :
                        clsidDMO = GUID_DSFX_STANDARD_I3DL2SOURCE;
                        fDMO = TRUE;
                        pSendNode = GetBufferNode(GUID_Buffer_EnvReverb);
                        if (!pSendNode)
                        {
                            Trace(1,"Error: Failed creating 3D audiopath because the environmental reverb audiopath has not been created.\n");
                            hr = DMUS_E_AUDIOPATH_NOGLOBALFXBUFFER;
                            break;
                        }*/
                    case BUFFER_3D_DRY :
                        dwFunctionIDs[0] = DSBUSID_DYNAMIC_0;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY |
                            DSBCAPS_CTRL3D | DSBCAPS_MUTE3DATMAXDISTANCE | DSBCAPS_LOCDEFER;
                        BufferDesc.guid3DAlgorithm = DS3DALG_NO_VIRTUALIZATION;
                        break;
                    case BUFFER_MONO :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwNumFunctionIDs = 1;
                        WaveFormat.nChannels = 1;
                        BufferDesc.dwFlags = DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPAN | DSBCAPS_LOCDEFER;
                        break;
                    case BUFFER_STEREO :
                        BufferDesc.dwFlags = DSBCAPS_CTRLFREQUENCY;
                    case BUFFER_MUSIC :
                        dwFunctionIDs[0] = DSBUSID_LEFT;
                        dwFunctionIDs[1] = DSBUSID_RIGHT;
                        dwNumFunctionIDs = 2;
                        WaveFormat.nChannels = 2;
                        BufferDesc.dwFlags |= DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_LOCDEFER;
                        break;
                    default:
                        hr = E_INVALIDARG;
                    }
                    if (SUCCEEDED(hr))
                    {
                        WaveFormat.nBlockAlign = WaveFormat.nChannels * 2;
                        WaveFormat.nSamplesPerSec = m_AudioParams.dwSampleRate;
                        WaveFormat.nAvgBytesPerSec = WaveFormat.nChannels * WaveFormat.nSamplesPerSec * 2;
                        WaveFormat.wBitsPerSample = 16;
                        WaveFormat.wFormatTag = WAVE_FORMAT_PCM;
                        // Ensure that the mixin flag and number of bus ids are in sync (you can't combine mixin with buses.)
                        if ((pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN) || (dwNumFunctionIDs == 0))
                        {
                            dwNumFunctionIDs = 0;
                            BufferDesc.dwFlags |= DSBCAPS_MIXIN;
                            pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            BufferDesc.dwFlags &= ~DSBCAPS_LOCDEFER;
                        }
                        // Always allow effects to be created on the buffer, regardless of whether we need them now.
                        BufferDesc.dwFlags |= DSBCAPS_CTRLFX;
                        hr = m_pSinkConnect->CreateSoundBuffer(&BufferDesc, &dwFunctionIDs[0], dwNumFunctionIDs,
                                                               pConfig->m_BufferHeader.guidBufferID, &pNode->m_pBuffer);
#ifdef DBG
                        if (FAILED(hr))
                        {
                            if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                            {
                                Trace(1,"Error: Failed creating global (MIXIN) buffer for standard path.\n");
                            }
                            else
                            {
                                Trace(1,"Error: Failed creating buffer for standard path.\n");
                            }
                        }
#endif
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (fDMO)
                        {
                            IDirectSoundBuffer8 *pBuff8;
                            if (SUCCEEDED(pNode->m_pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **)&pBuff8)))
                            {
                                DWORD dwResult;
                                DSEFFECTDESC FXDesc;
                                FXDesc.dwSize = sizeof(DSEFFECTDESC);
                                FXDesc.dwFlags = 0;
                                FXDesc.guidDSFXClass = clsidDMO;
                                FXDesc.dwReserved1 = 0;
                                FXDesc.dwReserved2 = 0;
                                if (pSendNode)
                                {
                                    FXDesc.dwReserved1 = DWORD_PTR(pSendNode->GetBuffer());
                                }
                                hr = pBuff8->SetFX(1, &FXDesc, &dwResult);
                                if (FXDesc.dwReserved1)
                                {
                                    ((IDirectSoundBuffer*)FXDesc.dwReserved1)->Release();
                                }
                                pBuff8->Release();
                            }
                        }
                    }
                    if (pSendNode)
                    {
                        pSendNode->Release();
                    }
                }
                else
                {
                    pConfig->m_BufferHeader.dwFlags &= ~DMUS_BUFFERF_MIXIN;
                    hr = m_pSinkConnect->CreateSoundBufferFromConfig(pConfig->m_pBufferConfig,&pNode->m_pBuffer);
                    if (SUCCEEDED(hr))
                    {
                        // We need to know if this is a mixin buffer so we can identify it later.
                        DWORD dwBusIDs[32];
                        DWORD dwFuncIDs[32];
                        DWORD dwCount = 32;
                        dwFuncIDs[0] = 0;
                        if (SUCCEEDED(m_pSinkConnect->GetSoundBufferBusIDs(pNode->m_pBuffer,dwBusIDs,dwFuncIDs,&dwCount)))
                        {
                            if (dwFuncIDs[0] == 0xFFFFFFFF)
                            {
                                pConfig->m_BufferHeader.dwFlags |= DMUS_BUFFERF_MIXIN;
                            }
                        }
                    }
                    else
                    {
                        Trace(1,"Error: Failed creation of buffer defined in audio path configuration file.\n");
                    }
                }

                if (SUCCEEDED(hr))
                {
                    TraceI(2,"Created Buffer %lx\n",pNode->m_pBuffer);
                    pNew->m_pBufferNode = pNode;
                    pNode->m_pManager = this;
                    AddHead(pNode);
                }
                else
                {
                    delete pNode;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (FAILED(hr) && pNew)
        {
            delete pNew;
            *ppNew = NULL;
        }
    }
    else
    {
        hr = DMUS_E_AUDIOPATH_NOBUFFER;
        Trace(0,"Audiopath Creation error: Requested buffer when DMUS_AUDIOF_BUFFERS not enabled via InitAudio.\n");
    }
    return hr;
}

CBufferConnect::CBufferConnect()

{
    m_ppBufferNodes = NULL;
    m_pguidBufferIDs = NULL;
    m_ConnectHeader.dwBufferCount = 0;
}

HRESULT CBufferConnect::Load(CRiffParser *pParser)

{
    HRESULT hr = pParser->Read(&m_ConnectHeader, sizeof(DMUS_IO_PCHANNELTOBUFFER_HEADER));
    if (SUCCEEDED(hr))
    {
        DWORD dwBufferCount = m_ConnectHeader.dwBufferCount;
        m_pguidBufferIDs = new GUID[dwBufferCount];
        if (m_pguidBufferIDs )
        {
            hr = pParser->Read(m_pguidBufferIDs,sizeof(GUID)*dwBufferCount);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

CBufferConnect *CBufferConnect::CreateRunTimeVersion(CPortConfig *pParent)

{
    CBufferConnect *pCopy = new CBufferConnect;
    if (pCopy && m_pguidBufferIDs)
    {
        pCopy->m_ConnectHeader = m_ConnectHeader;
        pCopy->m_ppBufferNodes = new CBufferNode *[m_ConnectHeader.dwBufferCount];
        if (pCopy->m_ppBufferNodes)
        {
            for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
            {
                pCopy->m_ppBufferNodes[dwIndex] = pParent->GetBufferNode(m_pguidBufferIDs[dwIndex]);
            }
        }
        else
        {
            delete pCopy;
            pCopy = NULL;
        }
    }
    return pCopy;
}


CBufferConnect::~CBufferConnect()

{
    if (m_ppBufferNodes)
    {
        for (DWORD dwIndex = 0; dwIndex < m_ConnectHeader.dwBufferCount; dwIndex++)
        {
            if (m_ppBufferNodes[dwIndex]) m_ppBufferNodes[dwIndex]->Release();
        }
        delete [] m_ppBufferNodes;
    }
    if (m_pguidBufferIDs)
    {
        delete [] m_pguidBufferIDs;
    }
}

HRESULT CBufferConnectList::CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent)

{
    CBufferConnect *pScan = GetHead();
    CBufferConnect *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        pCopy = pScan->CreateRunTimeVersion(pParent);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

void CBufferConnectList::Clear()

{
    CBufferConnect *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

HRESULT CBufferConfig::Activate(BOOL fActivate)

{
    if (m_pBufferNode)
    {
        return m_pBufferNode->Activate(fActivate);
    }
    return S_OK;
}

CBufferConfig::CBufferConfig(DWORD dwType)

{
    m_pBufferNode = NULL;
    m_BufferHeader.guidBufferID = GUID_NULL;
    m_BufferHeader.dwFlags = DMUS_BUFFERF_DEFINED;
    m_dwStandardBufferID = dwType;
    switch (dwType)
    {
    case BUFFER_REVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_Reverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    case BUFFER_ENVREVERB :
        m_BufferHeader.guidBufferID = GUID_Buffer_EnvReverb;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED | DMUS_BUFFERF_MIXIN;
        break;
    // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
//    case BUFFER_3D :
//        m_BufferHeader.guidBufferID = GUID_Buffer_3D;
//        break;
    case BUFFER_3D_DRY :
        m_BufferHeader.guidBufferID = GUID_Buffer_3D_Dry;
        break;
    case BUFFER_MONO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Mono;
        break;
    case BUFFER_STEREO :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        break;
    case BUFFER_MUSIC :
        m_BufferHeader.guidBufferID = GUID_Buffer_Stereo;
        m_BufferHeader.dwFlags = DMUS_BUFFERF_SHARED | DMUS_BUFFERF_DEFINED;
        break;
    default:
        m_BufferHeader.dwFlags = 0;
        break;
    }
    m_pBufferConfig = NULL;
}

CBufferConfig::~CBufferConfig()

{
    if (m_pBufferNode)
        m_pBufferNode->Release();
    if (m_pBufferConfig)
        m_pBufferConfig->Release();
}

void CBufferConfig::DecideType()

{
    if (m_BufferHeader.guidBufferID == GUID_Buffer_Reverb)
    {
        m_dwStandardBufferID = BUFFER_REVERB;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_EnvReverb)
    {
        m_dwStandardBufferID = BUFFER_ENVREVERB;
    }
    // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D)
    {
        m_dwStandardBufferID = BUFFER_3D;
    }*/
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_3D_Dry)
    {
        m_dwStandardBufferID = BUFFER_3D_DRY;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Mono)
    {
        m_dwStandardBufferID = BUFFER_MONO;
    }
    else if (m_BufferHeader.guidBufferID == GUID_Buffer_Stereo)
    {
        m_dwStandardBufferID = BUFFER_STEREO;
    }
}



HRESULT CBufferConfig::Load(IStream *pStream)

{
    IPersistStream *pPersist;
    HRESULT hr = CoCreateInstance( CLSID_DirectSoundBufferConfig,
        NULL, CLSCTX_INPROC, IID_IPersistStream,
        (void**)&pPersist );
    if (SUCCEEDED(hr))
    {
        hr = pPersist->Load(pStream);
        if (SUCCEEDED(hr))
        {
            m_pBufferConfig = pPersist;
            IDirectMusicObject *pObject;
            hr = pPersist->QueryInterface(IID_IDirectMusicObject,(void **) &pObject);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC Desc;
                Desc.dwSize = sizeof(Desc);
                pObject->GetDescriptor(&Desc);
                if (Desc.dwValidData & DMUS_OBJ_OBJECT)
                {
                    m_BufferHeader.guidBufferID = Desc.guidObject;
                }
                else
                {
                    Trace(1,"Error: Unable to load Buffer Configuration in AudioPath Config - Missing buffer GUID in file.\n");
                    hr = E_FAIL;
                }
                pObject->Release();
            }
        }
        else
        {
            pPersist->Release();
        }
    }
    return hr;
}

void CBufferConfigList::Clear()

{
    CBufferConfig *pBuffer;
    while (pBuffer = RemoveHead())
    {
        delete pBuffer;
    }
}

CBufferNode * CBufferConfigList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        if (pBuffer->m_BufferHeader.guidBufferID == guidBufferID)
        {
            if (pBuffer->m_pBufferNode)
            {
                pBuffer->m_pBufferNode->AddRef();
                pBuff = pBuffer->m_pBufferNode;
            }
            break;
        }
    }
    return pBuff;
}

HRESULT CBufferConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        hr = pBuffer->Activate(fActivate);
        if (FAILED(hr))
        {
            CBufferConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pBuffer);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CBufferConfigList::CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager)

/*  To create a runtime version, we scan through all bufferconfigs and, for each one, we call the
    buffer manager to create a new one, managed by CBufferNode. In the case where the buffer already exists, it just
    addrefs the CBufferNode and returns that.
*/

{
    HRESULT hr = S_OK;
    CBufferConfig *pBuffer;
    for (pBuffer = GetHead();pBuffer;pBuffer = pBuffer->GetNext())
    {
        CBufferConfig *pNew = NULL;
        hr = pManager->CreateBuffer(pBuffer,&pNew);
        if (SUCCEEDED(hr))
        {
            pCopy->AddTail(pNew);
        }
        else
        {
            break;
        }
    }
    return hr;
}


CPortConfig::CPortConfig()

{
    m_fAlreadyHere = FALSE;
    m_pPort = NULL;
    m_dwPortID = 0;
    m_pParent = NULL;
    m_PortHeader.guidPort = GUID_Synth_Default;     // Default synth, as specified by DMUS_AUDPARAMS.
    m_PortHeader.dwFlags = DMUS_PORTCONFIGF_DRUMSON10;
    m_PortHeader.dwPChannelBase = 0;
    m_PortHeader.dwPChannelCount = 32;
    m_PortParams.dwChannelGroups = 2;
    m_PortParams.dwSize = sizeof(DMUS_PORTPARAMS8);
    m_PortParams.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS | DMUS_PORTPARAMS_FEATURES;
    m_PortParams.dwFeatures = DMUS_PORT_FEATURE_AUDIOPATH | DMUS_PORT_FEATURE_STREAMING;
}

CPortConfig::~CPortConfig()

{
    if (m_pPort) m_pPort->Release();
    m_BufferConnectList.Clear();
    m_BufferConfigList.Clear();
}


HRESULT CPortConfig::Activate(BOOL fActivate)

{
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr) && fActivate && m_pPort)
    {
        HRESULT hrTemp = m_pPort->Activate(TRUE);
        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }
    return hr;
}

HRESULT CPortConfig::CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent, CBufferManager *pManager)

{
    HRESULT hr = E_OUTOFMEMORY;
    CPortConfig *pCopy = new CPortConfig();
    if (pCopy)
    {
        pCopy->m_pParent = pParent;
        pCopy->m_PortHeader = m_PortHeader;
        pCopy->m_PortParams = m_PortParams;
        hr = m_BufferConfigList.CreateRunTimeVersion(&pCopy->m_BufferConfigList,pManager);
        if (SUCCEEDED(hr))
        {
            hr = m_BufferConnectList.CreateRunTimeVersion(&pCopy->m_BufferConnectList,pCopy);
        }
    }
    *ppCopy = pCopy;
    return hr;
}

CBufferNode * CPortConfig::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff && !m_fAlreadyHere)
    {
        m_fAlreadyHere = TRUE;
        pBuff = m_pParent->GetBufferNode(guidBuffer);
        m_fAlreadyHere = FALSE;
    }
    return pBuff;
}


HRESULT CPortConfig::Load(CRiffParser *pParser)
{
    RIFFIO ckNext;
    HRESULT hr = S_OK;
    DWORD dwLoadedBoth = 0;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_PORTCONFIG_ITEM:
            hr = pParser->Read(&m_PortHeader, sizeof(DMUS_IO_PORTCONFIG_HEADER));
            dwLoadedBoth |= 1;
            break;
        case DMUS_FOURCC_PORTPARAMS_ITEM:
            hr = pParser->Read(&m_PortParams, sizeof(DMUS_PORTPARAMS8));
            dwLoadedBoth |= 2;
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
                RIFFIO ckChild;
                case DMUS_FOURCC_PCHANNELS_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        switch( ckChild.ckid )
                        {
                        case DMUS_FOURCC_PCHANNELS_ITEM:
                            {
                                CBufferConnect *pBufferConnect = new CBufferConnect;
                                if (pBufferConnect)
                                {
                                    hr = pBufferConnect->Load(pParser);
                                    if (SUCCEEDED(hr))
                                    {
                                        m_BufferConnectList.AddTail(pBufferConnect);
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            break;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_DSBUFFER_LIST:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->EnterList(&ckChild);
                            while (pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                    hr = pParser->Read(&pSource->m_BufferHeader,
                                        sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                    pSource->DecideType();
                                    break;
                                case FOURCC_LIST:
                                case FOURCC_RIFF:
                                    if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                    {
                                        pParser->SeekBack();
                                        hr = pSource->Load(pParser->GetStream());
                                        pParser->SeekForward();
                                        if (FAILED(hr))
                                        {
                                            Trace(1,"AudioPath Configuration failed loading buffer\n");
                                        }
                                    }
                                }
                            }
                            pParser->LeaveList();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                case DMUS_FOURCC_DSBC_FORM:
                    {
                        CBufferConfig *pSource = new CBufferConfig(0);
                        if (pSource)
                        {
                            pParser->SeekBack();
                            hr = pSource->Load(pParser->GetStream());
                            pParser->SeekForward();
                            if (SUCCEEDED(hr))
                            {
                                m_BufferConfigList.AddTail(pSource);
                            }
                            else
                            {
                                Trace(1,"AudioPath Configuration failed loading buffer\n");
                                delete pSource;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    break;
                default:
                    break;
            }
            break;
        default:
            break;
        }
    }
    if (dwLoadedBoth != 3)
    {
        hr = DMUS_E_CHUNKNOTFOUND;
        Trace(1,"Error: Failure loading port configuration chunk in Audio Path Configuration.\n");
    }

    // Make sure the channel groups in the portparams is large enough to handle the requested
    // channels in portheader.
    m_PortParams.dwChannelGroups = (m_PortHeader.dwPChannelCount + 15) / 16;
    m_PortParams.dwValidParams |= DMUS_PORTPARAMS_CHANNELGROUPS;
    pParser->LeaveList();

    return hr;
}

HRESULT CPortConfigList::Activate(BOOL fActivate)

{
    HRESULT hr = S_OK;
    CPortConfig *pPort;
    for (pPort = GetHead();pPort;pPort = pPort->GetNext())
    {
        hr = pPort->Activate(fActivate);
        if (FAILED(hr))
        {
            CPortConfig *pUndo;
            for (pUndo = GetHead();pUndo && (pUndo != pPort);pUndo = pUndo->GetNext())
            {
                pUndo->Activate(!fActivate);
            }
            break;
        }
    }
    return hr;
}

HRESULT CPortConfigList::CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager)

{
    HRESULT hr = S_OK;
    CPortConfig *pScan = GetHead();
    CPortConfig *pCopy;
    for (;pScan;pScan = pScan->GetNext())
    {
        hr = pScan->CreateRunTimeVersion(&pCopy,pParent,pManager);
        if (pCopy)
        {
            pDestination->AddTail(pCopy);
        }
        else
        {
            break;
        }
    }
    return hr;
}

BOOL CPortConfigList::UsesPort(IDirectMusicPort *pPort)

{
    CPortConfig *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pScan->m_pPort == pPort) return TRUE;
    }
    return FALSE;
}


void CPortConfigList::Clear()

{
    CPortConfig *pPort;
    while (pPort = RemoveHead())
    {
        delete pPort;
    }
}

CAudioPath::CAudioPath()

{
    TraceI(2,"Creating AudioPath %lx\n",this);
    InitializeCriticalSection(&m_CriticalSection);
    m_fDeactivating = FALSE;
    m_bLastVol = 127;
    m_cRef = 0;
    m_fActive = FALSE;
    m_pdwVChannels = NULL;
    m_pdwPChannels = NULL;
    m_dwChannelCount = 0;
    m_pPerformance = NULL;
    m_pGraph = NULL;
    m_pConfig = NULL;
    m_pUnkDispatch = NULL;
}


CAudioPath::~CAudioPath()
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    LeaveCriticalSection(&m_CriticalSection);
    Deactivate();
    DeleteCriticalSection(&m_CriticalSection);
}

STDMETHODIMP_(ULONG) CAudioPath::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPath::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPath::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CAudioPath::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicAudioPath)
    {
        *ppv = static_cast<IDirectMusicAudioPath*>(this);
    } else
    if (iid == IID_CAudioPath)
    {
        *ppv = static_cast<CAudioPath*>(this);
    } else
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicAudioPath,
                static_cast<IDirectMusicAudioPath*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPath object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


static BYTE VolumeToMidi(long lVolume)

{
    static long lDBToMIDI[97] = {        // Array used to convert db to MIDI.
        127, 119, 113, 106, 100, 95, 89, 84, 80, 75,
        71, 67, 63, 60, 56, 53, 50, 47, 45, 42,
        40, 37, 35, 33, 31, 30, 28, 26, 25, 23,
        22, 21, 20, 19, 17, 16, 15, 15, 14, 13,
        12, 11, 11, 10, 10, 9, 8, 8, 8, 7,
        7, 6, 6, 6, 5, 5, 5, 4, 4, 4,
        4, 3, 3, 3, 3, 3, 2, 2, 2, 2,
        2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
        1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0
    };
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = lDBToMIDI[lVolume];
    lResult += ((lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

STDMETHODIMP CAudioPath::SetVolume(long lVolume,DWORD dwDuration)

{
    if (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = E_FAIL; // This should never happen, since the audiopath is created by the performance.
    BYTE bMIDIVol = VolumeToMidi(lVolume);

    DMUS_CURVE_PMSG *pCurve;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pPerformance)
    {
        hr = m_pPerformance->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG **)&pCurve);
        if (SUCCEEDED(hr))
        {
            REFERENCE_TIME rtTimeNow = 0;
            m_pPerformance->GetLatencyTime(&rtTimeNow);
            pCurve->rtTime = rtTimeNow;
            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
            pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_AUDIOPATH;
            // dwVirtualTrackID: this isn't a track so leave as 0
            pCurve->dwType = DMUS_PMSGT_CURVE;
            pCurve->dwGroupID = -1; // this isn't a track so just say all groups

            // curve PMsg fields
            pCurve->mtDuration = dwDuration; // setting the DMUS_PMSGF_LOCKTOREFTIME is interpreted by the performance that mtDuration is milliseconds
            // mtResetDuration: no reset so leave as 0
            pCurve->nStartValue = m_bLastVol;
            m_bLastVol = bMIDIVol;
            // nStartValue: will be ignored
            pCurve->nEndValue = bMIDIVol;
            // nResetValue: no reset so leave as 0
            pCurve->bType = DMUS_CURVET_CCCURVE;
            pCurve->bCurveShape = dwDuration ? DMUS_CURVES_LINEAR : DMUS_CURVES_INSTANT;
            pCurve->bCCData = 7; // MIDI volume controller number
            pCurve->bFlags = DMUS_CURVE_START_FROM_CURRENT;
            // wParamType: leave as zero since this isn't a NRPN/RPN curve
            pCurve->wMergeIndex = 0xFFFF; //  special merge index so this won't get stepped on. is a big number OK? define a constant for this value?

            // send it

            StampPMsg((DMUS_PMSG *)pCurve);
            hr = m_pPerformance->SendPMsg((DMUS_PMSG*)pCurve);
        }
    }
    else
    {
        hr = DMUS_E_NOT_INIT;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CAudioPath::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,
                                          DWORD dwBuffer, REFGUID guidObject,
                                          DWORD dwIndex, REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicAudioPath::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    CPortConfig *pPortConfig;
    EnterCriticalSection(&m_CriticalSection);
    switch (dwStage)
    {
    case DMUS_PATH_AUDIOPATH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            hr = QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_AUDIOPATH_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_AUDIOPATH_TOOL:
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                // Convert from audiopath channel to performance channel.
                ConvertPChannel( dwPChannel,&dwPChannel);
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PORT:
        pPortConfig = m_PortConfigList.GetHead();
        for (;pPortConfig;pPortConfig = pPortConfig->GetNext())
        {
            // First, see if this matches the port guid.
            if ((pPortConfig->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
            {
                // Then, see if we have a pchannel match.
                if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                    ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelBase + pPortConfig->m_PortHeader.dwPChannelCount) > dwPChannel)))
                {
                    // If everything matches, there is always the chance that we have multiple instances of
                    // this in the list and we are actually looking at a second or third pointer to the same port.
                    // So, scan through the list again, making the exact same matches. If this port is found in
                    // an earlier instance, fail the match.
                    BOOL fSuccess = true;
                    CPortConfig *pScan = m_PortConfigList.GetHead();
                    for (;pScan;pScan = pScan->GetNext())
                    {
                        // First, see if this matches the port guid.
                        if ((pScan->m_PortHeader.guidPort == guidObject) || (guidObject == GUID_All_Objects))
                        {
                            // Then, see if we have a pchannel match.
                            if ((dwPChannel == DMUS_PCHANNEL_ALL) ||
                                ((pScan->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                                ((pScan->m_PortHeader.dwPChannelBase + pScan->m_PortHeader.dwPChannelCount) > dwPChannel)))
                            {
                                // If this is the same as the outer loop, we have arrived.
                                if (pScan == pPortConfig)
                                {
                                    break;
                                }
                                else
                                {
                                    // Else, if this points to the same port, we have failed.
                                    if (pScan->m_pPort == pPortConfig->m_pPort)
                                    {
                                        fSuccess = false;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    if (fSuccess)
                    {
                        if (dwIndex)
                        {
                            dwIndex--;
                        }
                        else
                        {
                            IDirectMusicPort *pPort;
                            if (SUCCEEDED(m_pPerformance->GetPort(pPortConfig->m_dwPortID,&pPort)))
                            {
                                hr = pPort->QueryInterface(iidInterface,ppObject);
                                pPort->Release();
                            }
                            break;
                        }
                    }
                }
            }
        }
        break;
    case DMUS_PATH_SINK:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0) &&
            m_pPerformance->m_BufferManager.m_pSinkConnect)
        {
            hr = m_pPerformance->m_BufferManager.m_pSinkConnect->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_BUFFER:
    case DMUS_PATH_BUFFER_DMO:
        {
            CBufferConnect *pConnect = NULL;
            BOOL fAllChannels = (dwPChannel == DMUS_PCHANNEL_ALL);
            pPortConfig = m_PortConfigList.GetHead();
            for (;pPortConfig && FAILED(hr);pPortConfig = pPortConfig->GetNext())
            {
                if (fAllChannels || ((pPortConfig->m_PortHeader.dwPChannelBase <= dwPChannel) &&
                    ((pPortConfig->m_PortHeader.dwPChannelCount +
                    pPortConfig->m_PortHeader.dwPChannelBase) > dwPChannel)))
                {
                    pConnect = pPortConfig->m_BufferConnectList.GetHead();
                    for (;pConnect;)
                    {
                        if (fAllChannels || ((pConnect->m_ConnectHeader.dwPChannelBase <= dwPChannel) &&
                            ((pConnect->m_ConnectHeader.dwPChannelCount +
                            pConnect->m_ConnectHeader.dwPChannelBase) > dwPChannel)))
                        {
                            // Found the buffer connect. Which buffer will be determined
                            // by dwBuffer. If dwBuffer is greater than the count of buffer,
                            // decrement and move on to the next pConnect.
                            if (pConnect->m_ConnectHeader.dwBufferCount > dwBuffer)
                            {
                                if (pConnect->m_ppBufferNodes[dwBuffer])
                                {
                                    IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwBuffer]->GetBuffer();
                                    if (pBuffer)
                                    {
                                        if (dwStage == DMUS_PATH_BUFFER)
                                        {
                                            if (dwIndex == 0)
                                            {
                                                hr = pBuffer->QueryInterface(iidInterface,ppObject);
                                            }
                                        }
                                        else
                                        {
                                            IDirectSoundBuffer8 *pBuffer8;
                                            hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                                pBuffer8->Release();
                                            }
                                        }
                                        pBuffer->Release();
                                    }
                                }
                                pConnect = NULL;
                            }
                            else
                            {
                                dwBuffer -= pConnect->m_ConnectHeader.dwBufferCount;
                            }
                        }
                        if (pConnect)
                        {
                            pConnect = pConnect->GetNext();
                        }
                    }
                }
            }

        }
        break;
    case DMUS_PATH_MIXIN_BUFFER :
    case DMUS_PATH_MIXIN_BUFFER_DMO :
        if (dwPChannel == 0)
        {
            CBufferConfig *pConfig = m_BufferConfigList.GetHead();
            for (;pConfig; pConfig = pConfig->GetNext())
            {
                if (pConfig->m_BufferHeader.dwFlags & DMUS_BUFFERF_MIXIN)
                {
                    if (!dwBuffer)
                    {
                        IDirectSoundBuffer *pBuffer = pConfig->m_pBufferNode->GetBuffer();
                        if (pBuffer)
                        {
                            if (dwStage == DMUS_PATH_MIXIN_BUFFER)
                            {
                                if (dwIndex == 0)
                                {
                                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                                }
                            }
                            else
                            {
                                IDirectSoundBuffer8 *pBuffer8;
                                hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8,(void **) &pBuffer8);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pBuffer8->GetObjectInPath(guidObject,dwIndex,iidInterface,ppObject);
                                    pBuffer8->Release();
                                }
                            }
                            pBuffer->Release();
                        }
                        break;
                    }
                    dwBuffer--;
                }
            }
        }
        break;
    case DMUS_PATH_PRIMARY_BUFFER :
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            CBufferNode *pNode = m_pPerformance->m_BufferManager.GetBufferNode(GUID_Buffer_Primary);
            if (pNode)
            {
                IDirectSoundBuffer *pBuffer = pNode->GetBuffer();
                if (pBuffer)
                {
                    hr = pBuffer->QueryInterface(iidInterface,ppObject);
                    pBuffer->Release();
                }
                pNode->Release();
            }
        }
        break;
    default:
        hr = E_INVALIDARG;
#ifdef DBG
        Trace(1,"Error: Audiopath does not support stage 0x%lx\n",dwStage);
#endif
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(3,"Warning: Requested AudioPath object not found\n");
    }
#endif
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Activate(BOOL fActivate)

{
    TraceI(2,"Audiopath %lx Activate: %ld\n",this,fActivate);
    if (fActivate == m_fActive)
    {
#ifdef DBG
        if (fActivate) Trace(2,"Warning: Attempt to activate already active audiopath.\n");
        else Trace(2,"Warning: Attempt to deactivate already inactive audiopath.\n");
#endif
        return S_FALSE;
    }
    m_fActive = fActivate;
    if (!fActivate && !m_fDeactivating)
    {
        EnterCriticalSection(&m_CriticalSection);
        CPerformance *pPerf = m_pPerformance;
        LeaveCriticalSection(&m_CriticalSection);
        if (pPerf)
        {
            // Kill anything currently playing on the audiopath.
            pPerf->StopEx(static_cast<IDirectMusicAudioPath*>(this),0,0);
        }
    }
    EnterCriticalSection(&m_CriticalSection);
    HRESULT hr = m_BufferConfigList.Activate(fActivate);
    if (SUCCEEDED(hr))
    {
        hr = m_PortConfigList.Activate(fActivate);
        if (FAILED(hr))
        {
            m_BufferConfigList.Activate(!fActivate);
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (FAILED(hr))
    {
        m_fActive = !fActivate;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CAudioPath::ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut)

{
    V_INAME(IDirectMusicAudioPath::ConvertPChannel);
    V_PTR_WRITE(pdwPChannelOut,DWORD);

    // If any special PMsg address (for example, broadcast), leave as is.
    if (dwPChannelIn >= DMUS_PCHANNEL_KILL_ME)
    {
        *pdwPChannelOut = dwPChannelIn;
        return S_OK;
    }
    DWORD dwScan = 0;
    for (;dwScan < m_dwChannelCount;dwScan++)
    {
        if (m_pdwVChannels[dwScan] == dwPChannelIn)
        {
            *pdwPChannelOut = m_pdwPChannels[dwScan];
            return S_OK;
        }
    }
    Trace(1,"Error: Audiopath failed request to convert out of range PChannel %ld\n",dwPChannelIn);
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CAudioPath::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CAudioPath::StampPMsg(
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicAudioPath::StampPMsg);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = E_FAIL;

    if (!m_fActive)
    {
        // Only kill notes and wave messages, since they are the only PMsgs that make sound.
        if ((pPMsg->dwType == DMUS_PMSGT_NOTE) || (pPMsg->dwType == DMUS_PMSGT_WAVE))
        {
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            Trace(1,"Error: Attempting to play on an inactive AudioPath, PMsg being ignored.\n");
            return DMUS_E_AUDIOPATH_INACTIVE;
        }
    }
    EnterCriticalSection(&m_CriticalSection);
    if (!m_pPerformance)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return DMUS_E_NOT_INIT;
    }
    // First, check if the audio path has its own graph.
    if (m_pGraph)
    {
        // Could return DMUS_S_LAST_TOOL, indicating end of graph.
        // If so, we'll treat that as a failure and drop on through to the next graph...
        if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
        {
            if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
            {
                if( pPMsg->pGraph )
                {
                    pPMsg->pGraph->Release();
                    pPMsg->pGraph = NULL;
                }
                pPMsg->pGraph = this;
                AddRef();
            }
        }
    }

    // If done with the graph, send to the performance. Also, check for the special case of
    // DMUS_PCHANNEL_BROADCAST_AUDIOPATH. If so, duplicate the pMsg
    // and send all the copies with the appropriate pchannel values.
    // Otherwise, convert the vchannel to the matching pchannel (this is the
    // point where the pchannel mapping occurs.)
    if( FAILED(hr) || (hr == DMUS_S_LAST_TOOL))
    {
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_AUDIOPATH)
        {
            DWORD dwIndex;
            for (dwIndex = 1;dwIndex < m_dwChannelCount;dwIndex++)
            {
                DWORD dwNewChannel = m_pdwPChannels[dwIndex];
                // Don't broadcast any broadcast messages!
                // And, if this is a transpose on the drum channel, don't send it.
                if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                    ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                {
                    DMUS_PMSG *pNewMsg;
                    if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                    {
                        pNewMsg->dwPChannel = dwNewChannel;
                        m_pPerformance->StampPMsg(pNewMsg);
                        m_pPerformance->SendPMsg(pNewMsg);
                    }
                }
            }
            // Now, set the pchannel for this one. First check that there are any
            // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
            // Also, mark it this way if the PMsg is a broadcast PMsg.
            pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            if (m_dwChannelCount)
            {
                if (m_pdwPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[0];
                }
            }
        }
        else
        {
            DWORD dwScan = 0;
            for (;dwScan < m_dwChannelCount;dwScan++)
            {
                if (m_pdwVChannels[dwScan] == pPMsg->dwPChannel)
                {
                    pPMsg->dwPChannel = m_pdwPChannels[dwScan];
                    break;
                }
            }
            // If a map was not found, kill the message.
            // But, ignore for notifications, since they really don't care about pchannel.
            // And, ignore for performance broadcast PMsgs.
            if ((dwScan == m_dwChannelCount) &&
                (pPMsg->dwType != DMUS_PMSGT_NOTIFICATION) &&
                (pPMsg->dwPChannel < DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
            }
        }
        hr = m_pPerformance->StampPMsg(pPMsg);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CGraph *CAudioPath::GetGraph()

{
    CGraph *pGraph;
    EnterCriticalSection(&m_CriticalSection);
    // Return the graph, and AddRef if it exists.
    if (pGraph = m_pGraph)
    {
        m_pGraph->AddRef();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return pGraph;
}

void CAudioPath::Deactivate()
{
    m_fDeactivating = TRUE;
    Activate(FALSE);
    EnterCriticalSection(&m_CriticalSection);
    m_fActive = FALSE;
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    if (m_pGraph)
    {
        m_pGraph->Release();
        m_pGraph = NULL;
    }
    if (m_pConfig)
    {
        m_pConfig->Release();
        m_pConfig = NULL;
    }
    if (m_pPerformance)
    {
        if (m_pdwVChannels && m_pdwPChannels)
        {
            DWORD dwIndex;
            for (dwIndex = 0;dwIndex <m_dwChannelCount;dwIndex++)
            {
                m_pPerformance->ReleasePChannel(m_pdwPChannels[dwIndex]);
            }
            delete [] m_pdwVChannels;
            delete [] m_pdwPChannels;
        }
        m_pPerformance->m_AudioPathList.Remove(this);
        m_pPerformance->RemoveUnusedPorts();
        m_pPerformance->Release();
        m_pPerformance = NULL;
    }
    m_fDeactivating = FALSE;
    LeaveCriticalSection(&m_CriticalSection);
}

void CAudioPath::SetGraph(CGraph *pGraph)

{
    EnterCriticalSection(&m_CriticalSection);
    // Is this a change?
    if (!m_pGraph)
    {
        pGraph->Clone((IDirectMusicGraph **) &m_pGraph);
    }
    LeaveCriticalSection(&m_CriticalSection);
}


CBufferNode * CAudioPath::GetBufferNode(REFGUID guidBuffer)

{
    CBufferNode *pBuff = NULL;
    EnterCriticalSection(&m_CriticalSection);
    pBuff = m_BufferConfigList.GetBufferNode(guidBuffer);
    if (!pBuff)
    {
        CPortConfig *pConfig = m_PortConfigList.GetHead();
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            pBuff = pConfig->GetBufferNode(guidBuffer);
            if (pBuff)
            {
                break;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (!pBuff)
    {
        pBuff = m_pPerformance->m_BufferManager.GetBufferNode(guidBuffer);
    }
    return pBuff;
}


HRESULT CAudioPath::Init(IUnknown *pSourceConfig,CPerformance *pPerf)

{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_CriticalSection);
    m_pPerformance = pPerf;
    pPerf->m_AudioPathList.AddHead(this);
    pPerf->AddRef();
    if (pPerf && pSourceConfig)
    {
        if (SUCCEEDED(hr = pSourceConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pConfig)))
        {
            if (m_pConfig->m_pGraph)
            {
                SetGraph(m_pConfig->m_pGraph);
            }
            // The very first audio path has to create the sink.
            hr = pPerf->m_BufferManager.InitSink();

            if (SUCCEEDED(hr))
            {
                // First, install any global buffers that are required.
                hr = m_pConfig->m_BufferConfigList.CreateRunTimeVersion(&m_BufferConfigList,&pPerf->m_BufferManager);
                if (SUCCEEDED(hr))
                {
                    // Then, install the ports and buffers.
                    hr = m_pConfig->m_PortConfigList.CreateRunTimeVersion(&m_PortConfigList,this,&pPerf->m_BufferManager);
                    if (SUCCEEDED(hr))
                    {
                        hr = ConnectToPorts(pPerf,pPerf->m_AudioParams.dwSampleRate);
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPath::ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate)

/*  This must be called from within a critical section.
*/

{
    HRESULT hr = S_OK;
    // Scan through the list of portconfigs and hook them up with active ports
    // in the performance. If a port is not available, create the port.
    CPortConfig *pConfig = m_PortConfigList.GetHead();
    DWORD dwChannelCount = 0;   // Used to add up total PChannels needed.
    for (;pConfig && SUCCEEDED(hr);pConfig = pConfig->GetNext())
    {
        // Given the configuration, either find a port with a matching id, or create one.
        hr = pPerf->GetPathPort(pConfig);
        dwChannelCount += pConfig->m_PortHeader.dwPChannelCount;
    }
    if (SUCCEEDED(hr))
    {
        // Now, allocate the VChannels needed for each portconfig.
        m_pdwVChannels = new DWORD[dwChannelCount];
        if (m_pdwVChannels)
        {
            m_pdwPChannels = new DWORD[dwChannelCount];
            if (!m_pdwPChannels)
            {
                delete [] m_pdwVChannels;
                m_pdwVChannels = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Scan through the port configs and allocate the pchannels, copying the assignments
        // into virtual channel assignment arrays.
        pConfig = m_PortConfigList.GetHead();
        DWORD dwIndex = 0;
        for (;pConfig;pConfig = pConfig->GetNext())
        {
            // If this port uses buffers, then connect them up.
            if (((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) &&
                (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH)))
            {
                CBufferConnect *pConnect = pConfig->m_BufferConnectList.GetHead();
                for (;pConnect && SUCCEEDED(hr);pConnect = pConnect->GetNext())
                {
                    // For each connect block, there should be an array of buffers
                    // to connect the range of PChannels to.
                    // For each PChannel, get a virtual pchannel and then assign
                    // it to the bus ids that belong to the buffers.
                    if (pConnect->m_ppBufferNodes)
                    {
                        DWORD dwCount = 0;
                        DWORD dwBusIDs[32];
                        DWORD *pdwBusIDBase = &dwBusIDs[0];
                        DWORD dwTotalRead = 0;
                        DWORD dwAmountLeft = 32;
                        for (;(dwCount < pConnect->m_ConnectHeader.dwBufferCount) && dwAmountLeft; dwCount++)
                        {
                            if (pConnect->m_ppBufferNodes[dwCount] && !(pConnect->m_ppBufferNodes[dwCount]->m_BufferHeader.dwFlags & DMUS_BUFFERF_PRIMARY))
                            {
                                IDirectSoundBuffer *pBuffer = pConnect->m_ppBufferNodes[dwCount]->GetBuffer();
                                if (pBuffer)
                                {
                                    dwTotalRead = dwAmountLeft;
                                    hr = m_pPerformance->m_BufferManager.m_pSinkConnect->GetSoundBufferBusIDs(pBuffer,pdwBusIDBase,NULL,&dwTotalRead);
                                    pBuffer->Release();
                                    if (FAILED(hr)) break;
                                    pdwBusIDBase += dwTotalRead; // Increment pointer by how many was read.
                                    dwAmountLeft -=  dwTotalRead;
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            dwTotalRead = 32 - dwAmountLeft;
                            // Now, allocate the pchannels and assign them to buses.
                            IDirectMusicPortP* pPortP = NULL;
                            if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP, (void**)&pPortP)))
                            {
                                for (dwCount = 0;dwCount < pConnect->m_ConnectHeader.dwPChannelCount; dwCount++)
                                {
                                    DWORD dwDrumFlags = 0;
                                    m_pdwVChannels[dwIndex] = pConnect->m_ConnectHeader.dwPChannelBase + dwCount;
                                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10)
                                    {
                                        dwDrumFlags = 1;
                                        if (((pConnect->m_ConnectHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                                        {
                                            // This is a drum on channel 10.
                                            dwDrumFlags |= 2;
                                        }
                                    }
                                    // Now, allocate a virtual pchannel for this and get back the equivalent group and midi channel.
                                    DWORD dwGroup;
                                    DWORD dwMChannel;
                                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
                                    if (dwTotalRead && SUCCEEDED(hr))
                                    {
                                        hr = pPortP->AssignChannelToBuses(dwGroup,dwMChannel,dwBusIDs,dwTotalRead);
                                    }
                                    dwIndex++;
                                }
                                pPortP->Release();
                            }
                        }
                    }
                }
            }
            else
            {
                DWORD dwCount;
                for (dwCount = 0;SUCCEEDED(hr) && (dwCount < pConfig->m_PortHeader.dwPChannelCount); dwCount++)
                {
                    DWORD dwDrumFlags = 0;
                    m_pdwVChannels[dwIndex] = pConfig->m_PortHeader.dwPChannelBase + dwCount;
                    if (pConfig->m_PortHeader.dwFlags & DMUS_PORTCONFIGF_DRUMSON10)
                    {
                        dwDrumFlags = 1;
                        if (((pConfig->m_PortHeader.dwPChannelBase + dwCount) & 0xF) == 9)
                        {
                            // This is a drum on channel 10.
                            dwDrumFlags |= 2;
                        }
                    }
                    // Now, allocate a virtual pchannel for this.
                    DWORD dwGroup; // These won't be used since we won't be assigning pchannels on the port to buffers.
                    DWORD dwMChannel;
                    hr = pPerf->AllocVChannel(pConfig->m_dwPortID,dwDrumFlags,&m_pdwPChannels[dwIndex],&dwGroup,&dwMChannel);
/*                    Trace(0,"%ld: Mapping %ld to %ld (Port %ld, Group %ld, Channel %ld)\n",
                        dwIndex,m_pdwVChannels[dwIndex],m_pdwPChannels[dwIndex],
                        pConfig->m_dwPortID,dwGroup,dwMChannel);*/

                    dwIndex++;
                }
            }
        }
    }
    m_dwChannelCount = dwChannelCount;
    return hr;
}

void CAudioPathList::Clear()
{
    CAudioPath *pPath;
    while (pPath = GetHead())
    {
        pPath->Deactivate(); // This should also remove it from the list.
        assert(pPath != GetHead()); // Make sure this is always the case!
    }
}

CBufferNode * CAudioPathList::GetBufferNode(REFGUID guidBufferID)

{
    CBufferNode *pBuff = NULL;
    CAudioPath *pPath;
    for (pPath = GetHead();pPath;pPath = pPath->GetNext())
    {
        pBuff = pPath->GetBufferNode(guidBufferID);
        if (pBuff)
        {
            break;
        }
    }
    return pBuff;
}

BOOL CAudioPathList::UsesPort(IDirectMusicPort *pPort)

{
    CAudioPath *pPath = GetHead();
    for (;pPath;pPath = pPath->GetNext())
    {
        if (pPath->UsesPort(pPort))
        {
            return TRUE;
        }
    }
    return FALSE;
}

CAudioPathConfig::CAudioPathConfig()
{
    m_pGraph = NULL;
    m_fPartialLoad = 0;
    m_cRef = 1;
    memset(&m_guidObject,0,sizeof(m_guidObject));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_pUnkDispatch = NULL;

    InitializeCriticalSection(&m_CriticalSection);
    InterlockedIncrement(&g_cComponent);
}

CAudioPathConfig::~CAudioPathConfig()
{
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    m_PortConfigList.Clear();
    m_BufferConfigList.Clear();
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
}

CAudioPathConfig *CAudioPathConfig::CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate)

{
    CAudioPathConfig *pConfig = new CAudioPathConfig;
    if (pConfig)
    {
        DWORD dwGlobalType = 0;         // Global mixin buffer.
        DWORD dwTypes[3];               // What types of buffers to create.
        DWORD dwTotal = 0;              // How many buffers.
        GUID  guidBufferIDs[3];         // IDs of buffers that should be connected to.
        DWORD dwConnections = 0;        // How many buffer connections.
        BOOL fCreatePort = TRUE;
        switch (dwType)
        {
        case DMUS_APATH_SHARED_STEREOPLUSREVERB:
            dwTypes[0] = BUFFER_MUSIC;
            dwTypes[1] = BUFFER_REVERB;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            guidBufferIDs[1] = GUID_Buffer_Reverb;
            dwConnections = 2;
            dwTotal = 2;
            break;
        // Following removed for DX8, should be reintroduced for Whistler and DX8.1...
/*        case DMUS_APATH_DYNAMIC_ENV3D:
            dwGlobalType = BUFFER_ENVREVERB;
            dwTypes[0] = BUFFER_3D;
            guidBufferIDs[0] = GUID_Buffer_3D;
            dwConnections = 1;
            dwTotal = 1;
            break;*/
        case DMUS_APATH_DYNAMIC_3D:
            dwTypes[0] = BUFFER_3D_DRY;
            guidBufferIDs[0] = GUID_Buffer_3D_Dry;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_MONO:
            dwTypes[0] = BUFFER_MONO;
            guidBufferIDs[0] = GUID_Buffer_Mono;
            dwConnections = 1;
            dwTotal = 1;
            break;
        case DMUS_APATH_DYNAMIC_STEREO:
            dwTypes[0] = BUFFER_STEREO;
            guidBufferIDs[0] = GUID_Buffer_Stereo;
            dwConnections = 1;
            dwTotal = 1;
            break;
        }
        if (dwGlobalType)
        {
            CBufferConfig *pBuffer = new CBufferConfig(dwGlobalType);
            if (pBuffer)
            {
                // This buffer configuration just has an id to identify which standard
                // buffer, instead of a pointer to a DSoundBufferConfig object,
                // which is what you'd see in the file io case.
                pConfig->m_BufferConfigList.AddHead(pBuffer);
            }
            else
            {
                delete pConfig;
                return NULL;
            }
        }
        if (fCreatePort)
        {
            CPortConfig *pPort = new CPortConfig();
            if (pPort)
            {
                pConfig->m_PortConfigList.AddHead(pPort);
                for (DWORD dwIndex = 0; dwIndex < dwTotal; dwIndex++)
                {
                    CBufferConfig *pBuffer = new CBufferConfig(dwTypes[dwIndex]);
                    if (pBuffer)
                    {
                        // This buffer configuration just has an id to identify which standard
                        // buffer, instead of a pointer to a DSoundBufferConfig object,
                        // which is what you'd see in the file io case.
                        pPort->m_BufferConfigList.AddHead(pBuffer);
                    }
                    else
                    {
                        delete pConfig;
                        return NULL;
                    }
                }
                // If there are connections to buffers, create the connection structure.
                if (dwConnections)
                {
                    CBufferConnect *pConnect = new CBufferConnect;
                    if (pConnect)
                    {
                        pPort->m_BufferConnectList.AddHead(pConnect);
                        pConnect->m_ConnectHeader.dwBufferCount = dwConnections;
                        pConnect->m_ConnectHeader.dwFlags = 0;
                        pConnect->m_ConnectHeader.dwPChannelBase = 0;
                        pConnect->m_ConnectHeader.dwPChannelCount = dwPChannelCount;
                        pConnect->m_pguidBufferIDs = new GUID[dwConnections];
                        if (pConnect->m_pguidBufferIDs)
                        {
                            for (DWORD dwIndex = 0; dwIndex < dwConnections; dwIndex++)
                            {
                                pConnect->m_pguidBufferIDs[dwIndex] = guidBufferIDs[dwIndex];
                            }
                        }
                        else
                        {
                            delete pConfig;
                            return NULL;
                        }
                    }
                }
                pPort->m_PortHeader.dwPChannelCount = dwPChannelCount;
                pPort->m_PortParams.dwChannelGroups = (dwPChannelCount + 15) / 16;
            }
            else
            {
                delete pConfig;
                pConfig = NULL;
            }
        }
    }
    return pConfig;
}



STDMETHODIMP CAudioPathConfig::QueryInterface(
    const IID &iid,
    void **ppv)
{
    V_INAME(CAudioPathConfig::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if ((iid == IID_IUnknown ) || (iid == IID_IDirectMusicObject))
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_CAudioPathConfig)
    {
        *ppv = static_cast<CAudioPathConfig*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicAudioPathConfig,
                static_cast<IDirectMusicObject*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on AudioPathConfig object\n");
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CAudioPathConfig::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CAudioPathConfig::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CAudioPathConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicAudioPathConfig;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

STDMETHODIMP CAudioPathConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CAudioPathConfig::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: AudioPathConfig::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Descriptor size is larger than AudioPathConfig::SetDescriptor can handle\n");
    }
    return hr;
}

STDMETHODIMP CAudioPathConfig::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)

{
    V_INAME(CAudioPathConfig::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicAudioPathConfig;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CAudioPathConfig::GetClassID( CLSID* pClassID )
{
    V_INAME(CAudioPathConfig::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicAudioPathConfig;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CAudioPathConfig::IsDirty()
{
    return S_FALSE;
}

HRESULT CAudioPathConfig::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_AUDIOPATH_FORM))
    {
        EnterCriticalSection(&m_CriticalSection);
        // Clear out any data that was previously loaded.
        if (m_pGraph)
        {
            m_pGraph->Release();
        }
        m_PortConfigList.Clear();
        m_BufferConfigList.Clear();
        hr = Load(&Parser);
        LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        Trace(1,"Error: Failed parsing - file is not AudioPathConfig format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CAudioPathConfig::Load(CRiffParser *pParser)

{
    RIFFIO ckNext;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CriticalSection);

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read( &m_guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                if( SUCCEEDED(hr) )
                {
                    m_dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    m_dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    RIFFIO ckChild;
                    case DMUS_FOURCC_UNFO_LIST:
                        pParser->EnterList(&ckChild);
                        while (pParser->NextChunk(&hr))
                        {
                            switch( ckChild.ckid )
                            {
                                case DMUS_FOURCC_UNAM_CHUNK:
                                {
                                    hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                                    if(SUCCEEDED(hr) )
                                    {
                                        m_dwValidData |= DMUS_OBJ_NAME;
                                    }
                                    break;
                                }
                                default:
                                    break;
                            }
                        }
                        pParser->LeaveList();
                        break;
                    case DMUS_FOURCC_PORTCONFIGS_LIST:
                        pParser->EnterList(&ckChild);
                        while (pParser->NextChunk(&hr))
                        {
                            switch( ckChild.ckid )
                            {
                            case FOURCC_LIST:
                                if (ckChild.fccType == DMUS_FOURCC_PORTCONFIG_LIST)
                                {
                                    CPortConfig *pConfig = new CPortConfig();
                                    if (pConfig)
                                    {
                                        hr = pConfig->Load(pParser);
                                        if (SUCCEEDED(hr))
                                        {
                                            m_PortConfigList.AddTail(pConfig);
                                        }
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                }
                                break;
                            }
                        }
                        pParser->LeaveList();
                        break;
                    case DMUS_FOURCC_DSBUFFER_LIST:
                        {
                            CBufferConfig *pSource = new CBufferConfig(0);
                            if (pSource)
                            {
                                pParser->EnterList(&ckChild);
                                while (pParser->NextChunk(&hr))
                                {
                                    switch( ckChild.ckid )
                                    {
                                    case DMUS_FOURCC_DSBUFFATTR_ITEM:
                                        hr = pParser->Read(&pSource->m_BufferHeader,
                                            sizeof(DMUS_IO_BUFFER_ATTRIBUTES_HEADER));
                                        pSource->DecideType();
                                        break;
                                    case FOURCC_LIST:
                                    case FOURCC_RIFF:
                                        if ( ckChild.fccType == DMUS_FOURCC_DSBC_FORM)
                                        {
                                            pParser->SeekBack();
                                            hr = pSource->Load(pParser->GetStream());
                                            pParser->SeekForward();
                                        }
                                    }
                                }
                                if (SUCCEEDED(hr))
                                {
                                    m_BufferConfigList.AddTail(pSource);
                                }
                                else
                                {
                                    delete pSource;
                                    Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                }
                                pParser->LeaveList();
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                    case DMUS_FOURCC_DSBC_FORM:
                        {
                            CBufferConfig *pSource = new CBufferConfig(0);
                            if (pSource)
                            {
                                pParser->SeekBack();
                                hr = pSource->Load(pParser->GetStream());
                                pParser->SeekForward();
                                if (SUCCEEDED(hr))
                                {
                                    m_BufferConfigList.AddTail(pSource);
                                }
                                else
                                {
                                    Trace(1,"Error: AudioPath Configuration failed loading buffer\n");
                                    delete pSource;
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                    case DMUS_FOURCC_TOOLGRAPH_FORM:
                        {
                            CGraph *pGraph = new CGraph;
                            if (pGraph)
                            {
                                hr = pGraph->Load(pParser);
                                if(m_pGraph)
                                {
                                    m_pGraph->Release();
                                }
                                m_pGraph = pGraph;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        break;
                }
                break;
        }
    }
    pParser->LeaveList();
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CAudioPathConfig::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CAudioPathConfig::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\curve.h ===
// Copyright (c) 1998 Microsoft Corporation
// curve.h

#ifndef __CURVE_H_
#define __CURVE_H_

#define CT_MAX  192 // curve table maximum
#define CT_FACTOR	100	// curve table multiplication factor
#define CT_DIVFACTOR	( ( CT_MAX ) * CT_FACTOR ) // curve division factor

// linear curves
static short ganCT_Linear[CT_MAX + 1] = {
	0,100,200,300,400,500,600,700,
	800,900,1000,1100,1200,1300,1400,1500,
	1600,1700,1800,1900,2000,2100,2200,2300,
	2400,2500,2600,2700,2800,2900,3000,3100,
	3200,3300,3400,3500,3600,3700,3800,3900,
	4000,4100,4200,4300,4400,4500,4600,4700,
	4800,4900,5000,5100,5200,5300,5400,5500,
	5600,5700,5800,5900,6000,6100,6200,6300,
	6400,6500,6600,6700,6800,6900,7000,7100,
	7200,7300,7400,7500,7600,7700,7800,7900,
	8000,8100,8200,8300,8400,8500,8600,8700,
	8800,8900,9000,9100,9200,9300,9400,9500,
	9600,9700,9800,9900,10000,10100,10200,10300,
	10400,10500,10600,10700,10800,10900,11000,11100,
	11200,11300,11400,11500,11600,11700,11800,11900,
	12000,12100,12200,12300,12400,12500,12600,12700,
	12800,12900,13000,13100,13200,13300,13400,13500,
	13600,13700,13800,13900,14000,14100,14200,14300,
	14400,14500,14600,14700,14800,14900,15000,15100,
	15200,15300,15400,15500,15600,15700,15800,15900,
	16000,16100,16200,16300,16400,16500,16600,16700,
	16800,16900,17000,17100,17200,17300,17400,17500,
	17600,17700,17800,17900,18000,18100,18200,18300,
	18400,18500,18600,18700,18800,18900,19000,19100,19200 };

// sine curves
static short ganCT_Sine[CT_MAX + 1] = {
	0,1,5,11,20,32,46,62,
	82,103,128,155,184,216,250,287,
	327,369,413,460,509,561,615,671,
	730,792,855,921,990,1060,1133,1208,
	1286,1365,1447,1531,1617,1706,1796,1889,
	1983,2080,2179,2279,2382,2486,2593,2701,
	2811,2923,3037,3153,3270,3389,3509,3632,
	3755,3881,4008,4136,4266,4397,4530,4664,
	4799,4936,5074,5213,5354,5495,5638,5781,
	5926,6071,6218,6365,6514,6663,6813,6963,
	7115,7267,7420,7573,7727,7881,8036,8191,
	8346,8502,8659,8815,8972,9128,9285,9442,
	9600,9757,9914,10071,10227,10384,10540,10697,
	10853,11008,11163,11318,11472,11626,11779,11932,
	12084,12236,12386,12536,12685,12834,12981,13128,
	13273,13418,13561,13704,13845,13986,14125,14263,
	14399,14535,14669,14802,14933,15063,15191,15318,
	15444,15567,15690,15810,15929,16046,16162,16276,
	16388,16498,16606,16713,16817,16920,17020,17119,
	17216,17310,17403,17493,17582,17668,17752,17834,
	17913,17991,18066,18139,18209,18278,18344,18407,
	18469,18528,18584,18638,18690,18739,18786,18830,
	18872,18912,18949,18983,19015,19044,19071,19096,
	19117,19137,19153,19167,19179,19188,19194,19198,19200 };

// log curve
static short ganCT_Log[CT_MAX + 1] = {
	0,381,747,1097,1432,1755,2066,2366,
	2655,2934,3205,3467,3721,3967,4207,4439,
	4666,4886,5101,5310,5515,5714,5909,6099,
	6285,6467,6645,6819,6990,7157,7321,7482,
	7640,7795,7947,8096,8243,8387,8529,8668,
	8805,8940,9073,9204,9332,9459,9584,9707,
	9828,9947,10065,10181,10295,10408,10520,10630,
	10738,10845,10951,11056,11159,11261,11361,11461,
	11559,11656,11752,11847,11941,12034,12126,12216,
	12306,12395,12483,12570,12656,12741,12826,12909,
	12992,13074,13155,13235,13315,13394,13472,13549,
	13626,13702,13777,13851,13925,13998,14071,14143,
	14214,14285,14355,14425,14494,14562,14630,14698,
	14764,14831,14896,14962,15026,15091,15154,15218,
	15280,15343,15405,15466,15527,15587,15647,15707,
	15766,15825,15883,15941,15999,16056,16113,16169,
	16225,16281,16336,16391,16446,16500,16554,16607,
	16661,16713,16766,16818,16870,16921,16973,17024,
	17074,17124,17174,17224,17273,17323,17371,17420,
	17468,17516,17564,17611,17658,17705,17752,17798,
	17844,17890,17936,17981,18026,18071,18116,18160,
	18204,18248,18292,18335,18379,18422,18464,18507,
	18549,18592,18634,18675,18717,18758,18799,18840,
	18881,18921,18962,19002,19042,19081,19121,19160,19200 };

// exponential curve
static short ganCT_Exp[CT_MAX + 1] = {
	0,40,79,119,158,198,238,279,
	319,360,401,442,483,525,566,608,
	651,693,736,778,821,865,908,952,
	996,1040,1084,1129,1174,1219,1264,1310,
	1356,1402,1448,1495,1542,1589,1636,1684,
	1732,1780,1829,1877,1927,1976,2026,2076,
	2126,2176,2227,2279,2330,2382,2434,2487,
	2539,2593,2646,2700,2754,2809,2864,2919,
	2975,3031,3087,3144,3201,3259,3317,3375,
	3434,3493,3553,3613,3673,3734,3795,3857,
	3920,3982,4046,4109,4174,4238,4304,4369,
	4436,4502,4570,4638,4706,4775,4845,4915,
	4986,5057,5129,5202,5275,5349,5423,5498,
	5574,5651,5728,5806,5885,5965,6045,6126,
	6208,6291,6374,6459,6544,6630,6717,6805,
	6894,6984,7074,7166,7259,7353,7448,7544,
	7641,7739,7839,7939,8041,8144,8249,8355,
	8462,8570,8680,8792,8905,9019,9135,9253,
	9372,9493,9616,9741,9868,9996,10127,10260,
	10395,10532,10671,10813,10957,11104,11253,11405,
	11560,11718,11879,12043,12210,12381,12555,12733,
	12915,13101,13291,13486,13685,13890,14099,14314,
	14534,14761,14993,15233,15479,15733,15995,16266,
	16545,16834,17134,17445,17768,18103,18453,18819,19200 };

#endif // __CURVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\audpath.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __AUDIOPATH_H_
#define __AUDIOPATH_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "TrkList.h"
#include "alist.h"
#include "..\shared\dmstrm.h"
#include "dmscriptautguids.h"
#include "..\shared\dmusiccp.h"

class CPerformance;
class CSegState;
class CGraph;
class CAudioPathConfig;
class CBufferConfig;
struct IDirectSoundConnect;

class CBufferNode : public AListItem
{
friend class CBufferManager;
friend class CAudioPath;
public:
    CBufferNode();
    ~CBufferNode();
    ULONG AddRef();
    ULONG Release();
    IDirectSoundBuffer *GetBuffer() { if (m_pBuffer) m_pBuffer->AddRef(); return m_pBuffer;}
    HRESULT Activate(BOOL fActivate);
private:
    void FinalDeactivate();
    CBufferNode* GetNext() { return (CBufferNode*)AListItem::GetNext();}
    IDirectSoundBuffer *   m_pBuffer;           // DSound buffer that this manages. 
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags (can it be shared?).
    CBufferManager * m_pManager; // Pointer to parent list. 
    long m_lActivateCount;  // How many times this has been activated.
    long m_cRef;            // How many objects point at this.
};

class CBufferManager : public AList
{    

public:
    CBufferManager(); 
    ~CBufferManager() ;
    HRESULT Init(CPerformance *pPerf, DMUS_AUDIOPARAMS *pAudioParams) ;
    HRESULT InitSink();
    void AddHead(CBufferNode* pBufferNode) { AList::AddHead((AListItem*)pBufferNode);}
    CBufferNode* GetHead(){return (CBufferNode*)AList::GetHead();}
    CBufferNode* RemoveHead() {return (CBufferNode *) AList::RemoveHead();}
    void Remove(CBufferNode* pBufferNode){AList::Remove((AListItem*)pBufferNode);}
    void AddTail(CBufferNode* pBufferNode){AList::AddTail((AListItem*)pBufferNode);}
    void Clear();
    void FinalDeactivate();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateBuffer(CBufferConfig *pConfig, CBufferConfig **pNew); 
private:
    CPerformance *m_pPerf;                  // Pointer to parent performance. 
    CBufferConfig *m_pFirstBuffer;          // Actual buffer created by config.
public:
    IDirectSoundConnect* m_pSinkConnect;    // The sink object which manages creation of buffers in dsound.
    IDirectSoundSynthSink *m_pSynthSink;    // Used to activate sink.
    DMUS_AUDIOPARAMS m_AudioParams;
};

#define BUFFER_REVERB       1
#define BUFFER_ENVREVERB    2
#define BUFFER_3D           3
#define BUFFER_3D_DRY       4
#define BUFFER_MONO         6
#define BUFFER_STEREO       7
#define BUFFER_MUSIC        8

DEFINE_GUID(GUID_Buffer_Primary,0x186cc544, 0xdb29, 0x11d3, 0x9b, 0xd1, 0x0, 0x80, 0xc7, 0x15, 0xa, 0x74);

#define DMUS_BUFFERF_PRIMARY    4   // This buffer flag is a private definition.

#define DMUS_STANDARD_PATH_DX7  20 // This is for internal use only.

#define MAX_CONNECTIONS     32  // Maximum of 32 buffers connected to one PChannel.

class CBufferConfig : public AListItem
{
public:
    CBufferConfig(DWORD dwType) ;
    ~CBufferConfig();
    void DecideType();         // Looks at embedded GUID and infers default type, if one exists.
    HRESULT Load(IStream *pStream);
    CBufferConfig* GetNext() { return (CBufferConfig*)AListItem::GetNext();}
    IUnknown *              m_pBufferConfig;     // Buffer definition. 
    CBufferNode *           m_pBufferNode;      // Manages the DSound buffer.
    DMUS_IO_BUFFER_ATTRIBUTES_HEADER m_BufferHeader;  // GUID that identifies this buffer and flags.
    DWORD                   m_dwStandardBufferID;// Optionally, one of the standard buffer types.
    HRESULT Activate(BOOL fActivate);
};

class CBufferConfigList : public AList
{
public:
    void AddHead(CBufferConfig* pBufferConfig) { AList::AddHead((AListItem*)pBufferConfig);}
    CBufferConfig* GetHead(){return (CBufferConfig*)AList::GetHead();}
    CBufferConfig* RemoveHead() {return (CBufferConfig *) AList::RemoveHead();}
    void Remove(CBufferConfig* pBufferConfig){AList::Remove((AListItem*)pBufferConfig);}
    void AddTail(CBufferConfig* pBufferConfig){AList::AddTail((AListItem*)pBufferConfig);}
    void Clear();
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
    HRESULT CreateRunTimeVersion(CBufferConfigList *pCopy, CBufferManager *pManager);
    HRESULT Activate(BOOL fActivate);
};

class CPortConfig;

class CBufferConnect : public AListItem
{
public:
    CBufferConnect() ;
    ~CBufferConnect();
    CBufferConnect *CreateRunTimeVersion(CPortConfig *pParent);
    HRESULT Load(CRiffParser *pParser);
    CBufferConnect* GetNext() { return (CBufferConnect*)AListItem::GetNext();}
    DMUS_IO_PCHANNELTOBUFFER_HEADER m_ConnectHeader;
    GUID *                          m_pguidBufferIDs;// Set of guids identifying buffers to connect to.
    CBufferNode **                  m_ppBufferNodes; // Array of equivalent Buffer nodes. 
};

class CBufferConnectList : public AList
{
public:
    void AddHead(CBufferConnect* pBufferConnect) { AList::AddHead((AListItem*)pBufferConnect);}
    CBufferConnect* GetHead(){return (CBufferConnect*)AList::GetHead();}
    CBufferConnect* RemoveHead() {return (CBufferConnect *) AList::RemoveHead();}
    void Remove(CBufferConnect* pBufferConnect){AList::Remove((AListItem*)pBufferConnect);}
    void AddTail(CBufferConnect* pBufferConnect){AList::AddTail((AListItem*)pBufferConnect);}
    HRESULT CreateRunTimeVersion(CBufferConnectList *pDestination, CPortConfig *pParent);
    void Clear();
};

class CAudioPath;

class CPortConfig : public AListItem
{
public:
    CPortConfig() ;
    ~CPortConfig();
    HRESULT CreateRunTimeVersion(CPortConfig ** ppCopy, CAudioPath *pParent,CBufferManager *pManager);
    CPortConfig* GetNext() { return (CPortConfig*)AListItem::GetNext();}
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    HRESULT Activate(BOOL fActivate);
    HRESULT CPortConfig::Load(CRiffParser *pParser);
    DMUS_IO_PORTCONFIG_HEADER   m_PortHeader; // Port configuration header, from file.
    DMUS_PORTPARAMS8            m_PortParams; // Port params for opening the port, also from file. 
    DWORD                       m_dwPortID;   // Used to track the index of a created port, once connecting.
    CBufferConnectList          m_BufferConnectList; // Pchannel to buffer mappings. 
    CBufferConfigList           m_BufferConfigList; // List of dsound buffer configurations.
    CAudioPath *                m_pParent;    // Parent audio path.
    IDirectMusicPort *         m_pPort;      // Pointer to port, if run time version.
	BOOL						m_fAlreadyHere; // Check for recursive case looking for buffer nodes.
};

class CPortConfigList : public AList
{
public:
    void AddHead(CPortConfig* pPortConfig) { AList::AddHead((AListItem*)pPortConfig);}
    CPortConfig* GetHead(){return (CPortConfig*)AList::GetHead();}
    CPortConfig* RemoveHead() {return (CPortConfig *) AList::RemoveHead();}
    void Remove(CPortConfig* pPortConfig){AList::Remove((AListItem*)pPortConfig);}
    void AddTail(CPortConfig* pPortConfig){AList::AddTail((AListItem*)pPortConfig);}
    HRESULT CreateRunTimeVersion(CPortConfigList *pDestination,CAudioPath *pParent,CBufferManager *pManager);
    void Clear();
    HRESULT Activate(BOOL fActivate);
    BOOL UsesPort(IDirectMusicPort *pPort);
};

class CAudioPath;

DEFINE_GUID(IID_CAudioPath,0xb06c0c23, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/*  The AudioPath represents a configuration of pchannels, ports, and buffers to play
    segments. The performance creates CAudioPath objects from CAudioPathConfig file
    objects and stores them in a linked list, which it uses to keep track of them.
*/

class CAudioPath : 
    public IDirectMusicAudioPath, 
	public IDirectMusicGraph,
    public AListItem
{
public:
    CAudioPath();
    ~CAudioPath();
    CAudioPath* GetNext() { return (CAudioPath*)AListItem::GetNext();}
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicAudioPath 
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    STDMETHODIMP Activate(BOOL fActivate) ;
    STDMETHODIMP SetVolume(long lVolume,DWORD dwDuration) ;
    STDMETHODIMP ConvertPChannel( DWORD dwPChannelIn,DWORD *pdwPChannelOut) ; 

// IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    HRESULT Init(IUnknown *pSourceConfig,CPerformance *pPerf);
    HRESULT ConnectToPorts(CPerformance *pPerf,DWORD dwSampleRate);
    CBufferNode * GetBufferNode(REFGUID guidBuffer);
    void SetGraph(CGraph *pGraph);
    CGraph *GetGraph();
    void Deactivate();
    BOOL IsActive() { return m_fActive; }
    BOOL NoPorts() { return m_PortConfigList.IsEmpty(); }
    BOOL UsesPort(IDirectMusicPort *pPort) { return m_PortConfigList.UsesPort(pPort); }
private:
    BOOL                m_fDeactivating;    // State variable.
    BYTE                m_bLastVol;         // Last volume change.
    CRITICAL_SECTION    m_CriticalSection;
	BOOL				m_fActive;			// Indicates that the audio path is active.
    long			    m_cRef;             // Reference counter. 
    DWORD *             m_pdwVChannels;     // Array of source VChannels.
    DWORD *             m_pdwPChannels;     // Array of destination PChannels.
    DWORD               m_dwChannelCount;   // Size of arrays.
    CGraph *            m_pGraph;           // Route tool graph.
    CPerformance *      m_pPerformance;     // Pointer to performance, needed to release PChannels.
    CAudioPathConfig *  m_pConfig;          // Source configuration.
    CPortConfigList     m_PortConfigList;   // List of port definitions (copied from source.)
    CBufferConfigList   m_BufferConfigList; // List of DSound buffers connected to the ports.
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch
};

class CAudioPathList : public AList
{
public:
    void Clear();
    void AddHead(CAudioPath* pAudioPath) { AList::AddHead((AListItem*)pAudioPath);}
    CAudioPath* GetHead(){return (CAudioPath*)AList::GetHead();}
    CAudioPath* RemoveHead() {return (CAudioPath *) AList::RemoveHead();}
    void Remove(CAudioPath* pAudioPath){AList::Remove((AListItem*)pAudioPath);}
    void AddTail(CAudioPath* pAudioPath){AList::AddTail((AListItem*)pAudioPath);}
    BOOL IsMember(CAudioPath* pAudioPath){return AList::IsMember((AListItem*)pAudioPath);}
    BOOL UsesPort(IDirectMusicPort *pPort); 
    CBufferNode * GetBufferNode(REFGUID guidBufferID);
};

DEFINE_GUID(IID_CAudioPathConfig,0xe9874261, 0xab52, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

class CAudioPathConfig : 
    public IPersistStream, 
    public IDirectMusicObject
{
friend class CAudioPath;
public:
    CAudioPathConfig();
    ~CAudioPathConfig();
    static CAudioPathConfig *CreateStandardConfig(DWORD dwType,DWORD dwPChannelCount,DWORD dwSampleRate);


// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT Load( CRiffParser *pParser);

protected:
    CGraph *            m_pGraph;                   // Audio path tool graph.
    CPortConfigList     m_PortConfigList;           // List of port definitions.
    CBufferConfigList   m_BufferConfigList;         // List of global dsound buffer configurations.
    CRITICAL_SECTION    m_CriticalSection;
	long		        m_cRef;
	DWORD               m_fPartialLoad;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
};

#endif // __AUDIOPATH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\str.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       str.h
//
//--------------------------------------------------------------------------

//
// string.h
//

#include <objbase.h>

#ifndef __BRSTRING_H__
#define __BRSTRING_H__

class Archive;

class String
{
    friend String operator+( const String& str1, const String& str2 );
    friend String operator+( const String& str1, LPCSTR lpszStr );
    friend String operator+( LPCSTR lpszStr, const String& str1 );
    friend String operator+( const String& str1, char ch );
    friend String operator+( char ch, const String& str1 );

public:
    String();
    String( LPCSTR lpszStr );
    String( const String& str );
    String( LPCWSTR pszWstr );
    ~String();

    //BOOL LoadString( UINT nID, HINSTANCE hInstance );

    BOOL IsEmpty() const
    {
        return ( m_wLength == 0 );
    };
    WORD GetLength() const
    {
        return m_wLength;
    };
    int Compare( const String& str ) const
    {
		if (m_pBuf && str.m_pBuf)
		{
			return _wcsicmp( m_pBuf, str.m_pBuf );
		}
		else if (!m_pBuf && !str.m_pBuf)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    int Compare( LPCWSTR lpwzStr ) const
    {
		if (m_pBuf && lpwzStr)
		{
			return _wcsicmp( m_pBuf, lpwzStr );
		}
		else if (!m_pBuf && !lpwzStr)
		{
			return 0;
		}
		else if (!m_pBuf)
		{
			return -1;
		}
		else
		{
			return 1;
		}
    };
    void Concat( const String& str );
    void Concat( LPCWSTR lpwzStr );
    void Concat( WCHAR wch );
    void TrimTrailingSpaces();
    WCHAR GetAt( UINT nIndex ) const
    {
        if( nIndex >= m_wLength )
        {
            return L'\0';
        }
        return m_pBuf[nIndex];
    };
    void SetAt( UINT nIndex, char ch )
    {
        if( nIndex < m_wLength )
        {
            m_pBuf[nIndex] = ch;
        }
    };
    HRESULT ReadWCS( LPSTREAM pStream, DWORD cSize );
    //HRESULT WriteWCS( LPSTREAM pStream );

// operators
    const String& operator+=( const String& str )   // concatenation
    {
        Concat( str );
        return *this;
    };
    const String& operator+=( LPCSTR lpszStr )      // concatenation
    {
        Concat( lpszStr );
        return *this;
    };
    const String& operator+=( char ch )             // concatenation
    {
        Concat( ch );
        return *this;
    };
    String& operator=( const String& str );
	String& operator=( LPCSTR pszStr );
    String& operator=( LPCWSTR pszWstr );
    operator const WCHAR*() const
    {
        return m_pBuf;
    }

private:
    WORD figureblocksize( WORD slen )
    {
        ++slen;         // for '\0'
        slen = static_cast<WORD>( slen / sm_wBlockSize );
        return static_cast<WORD>( ( slen + 1 ) * sm_wBlockSize );
    };

private:
    WORD m_wLength;
    WORD m_wAllocated;
    WCHAR* m_pBuf;

    static WORD sm_wBlockSize;  // size blocks are allocated in for strings
};

inline BOOL operator==( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator==( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) == 0 );
}

inline BOOL operator==( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) == 0 );
}

inline BOOL operator!=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator!=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) != 0 );
}

inline BOOL operator!=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) != 0 );
}

inline BOOL operator<( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator<( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) > 0 );
}

inline BOOL operator<( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) < 0 );
}

inline BOOL operator>( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator>( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) < 0 );
}

inline BOOL operator>( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) > 0 );
}

inline BOOL operator<=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator<=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) >= 0 );
}

inline BOOL operator<=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const String& s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}

inline BOOL operator>=( const WCHAR* s1, const String& s2 )
{
    return ( s2.Compare( s1 ) <= 0 );
}

inline BOOL operator>=( const String& s1, const WCHAR* s2 )
{
    return ( s1.Compare( s2 ) >= 0 );
}
#endif // __BRSTRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\templats.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1998 Microsoft Corporation
//
//  File:       templats.h
//
//--------------------------------------------------------------------------

// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmcompos\str.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (c) 1998-1999 Microsoft Corporation
//
//  File:       str.cpp
//
//--------------------------------------------------------------------------

//
// string.cpp

#include "str.h"

WORD String::sm_wBlockSize = 16;

String::String()
{
	m_wAllocated = 0;
    m_pBuf = NULL;
    m_wLength = 0;
}

String::String( const String& str )
{
    m_wLength = str.m_wLength;
	if (m_wLength == 0)
	{
		m_wAllocated = 0;
		m_pBuf = NULL;
	}
	else
	{
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];
		if( m_pBuf != NULL )
		{
			wcscpy( m_pBuf, str.m_pBuf );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
	}
}

String::String( LPCSTR pszStr )
{
    if( pszStr != NULL && pszStr[0] != '\0' )
    {
        m_wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::String( LPCWSTR pszWstr )
{
    if( pszWstr != NULL && pszWstr[0] != L'\0')
    {
        m_wLength = static_cast<WORD>( wcslen(pszWstr) );
		m_wAllocated = figureblocksize( m_wLength );
		m_pBuf = new WCHAR[m_wAllocated];

		if( m_pBuf != NULL )
		{
			wcscpy(m_pBuf, pszWstr);
		}
		else
		{
			m_wLength = 0;
			m_wAllocated = 0;
		}
    }
    else
    {
        m_wLength = 0;
		m_wAllocated = 0;
		m_pBuf = NULL;
    }

}

String::~String()
{
    if (m_pBuf) delete[] m_pBuf;
}

String& String::operator=( const String& str )
{
    WORD wBlockSize;

    if( m_pBuf != str.m_pBuf )
    {
		if (!str.m_pBuf)
		{
            if (m_pBuf)
			{
				m_pBuf[0] = L'\0';
			}
            m_wLength = 0;
		}
		else
		{
			wBlockSize = figureblocksize( str.m_wLength );
			if( wBlockSize <= m_wAllocated )
			{
				m_wLength = str.m_wLength;
				wcscpy( m_pBuf, str.m_pBuf );
			}
			else
			{
				if (m_pBuf) delete [] m_pBuf;
				m_wLength = str.m_wLength;
				m_wAllocated = wBlockSize;
				m_pBuf = new WCHAR[m_wAllocated];
				if( m_pBuf != NULL )
				{
					wcscpy( m_pBuf, str.m_pBuf );
				}
				else
				{
					m_wLength = 0;
					m_wAllocated = 0;
				}
			}
		}
    }
    return *this;
}

String& String::operator=( LPCSTR pszStr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszStr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( MultiByteToWideChar( CP_ACP, 0, pszStr, -1, NULL, 0 ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
			MultiByteToWideChar( CP_ACP, 0, pszStr, -1, m_pBuf, m_wAllocated );
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

String& String::operator=( LPCWSTR pszWstr )
{
    WORD wLength;
    WORD wBlockSize;

    if( pszWstr == NULL )
    {
        m_wLength = 0;
        return *this;
    }

    wLength = static_cast<WORD>( wcslen( pszWstr ) );
    wBlockSize = figureblocksize( wLength );
    if( wBlockSize <= m_wAllocated )
    {
        m_wLength = wLength;
        wcscpy(m_pBuf, pszWstr);
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wLength = wLength;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy(m_pBuf, pszWstr);
        }
        else
        {
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }
    return *this;
}

/*
#ifndef _MAC
BOOL String::LoadString( UINT nID, HINSTANCE hInstance )
{
    char szBuf[256];    // this is safe since resource strings
                        // are limited to 255 characters

    if( ::LoadString( hInstance, nID, szBuf, sizeof( szBuf ) ) == 0 )
    {
        return FALSE;
    }
    delete[] m_pBuf;
    m_wLength = static_cast<WORD>( ::lstrlen( szBuf ) );
    m_wAllocated = figureblocksize( m_wLength );
    m_pBuf = new WCHAR[m_wAllocated];
    if( m_pBuf == NULL )
    {
        m_wLength = 0;
        return FALSE;
    }
    ::lstrcpy( m_pBuf, szBuf );
    m_pBuf[m_wLength] = '\0';
    return TRUE;
}
#endif
*/

void String::TrimTrailingSpaces()
{
    while( m_wLength > 0 && m_pBuf[m_wLength - 1] == ' ' )
    {
        m_pBuf[m_wLength - 1] = '\0';
        --m_wLength;
    }
}

void String::Concat( const String& str )
{
    if( ( str.m_wLength + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        wcscat( m_pBuf, str.m_pBuf );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + str.m_wLength );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, str.m_pBuf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( LPCWSTR lpwzStr )
{
    int len;

    len = wcslen( lpwzStr );
    if( ( len + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength = static_cast<WORD>( m_wLength + len );
        wcscat( m_pBuf, lpwzStr );
    }
    else
    {
        WCHAR* p;

        m_wLength = static_cast<WORD>( m_wLength + len );
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, lpwzStr );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

void String::Concat( WCHAR wch )
{
    WCHAR buf[2];

    buf[0] = wch;
    buf[1] = '\0';
    if( ( 1 + m_wLength + 1 ) < m_wAllocated )
    {
        m_wLength += 1;
        wcscat( m_pBuf, buf );
    }
    else
    {
        WCHAR* p;

        m_wLength += 1;
        m_wAllocated = figureblocksize( m_wLength );
        p = new WCHAR[m_wAllocated];
        if( p != NULL )
        {
            wcscpy( p, m_pBuf );
            wcscat( p, buf );
            if (m_pBuf) delete[] m_pBuf;
            m_pBuf = p;
        }
    }
}

HRESULT String::ReadWCS( LPSTREAM pStream, DWORD cSize )
{
	HRESULT		hr = S_OK;
	WCHAR*		wstrText = NULL;
	DWORD		cb;
    WORD        wBlockSize;

    wstrText = new WCHAR[cSize / sizeof( WCHAR )];
	if( NULL == wstrText )
	{
		hr = E_OUTOFMEMORY;
		goto ON_ERR;
	}
    hr = pStream->Read( reinterpret_cast<LPWSTR>( wstrText ), cSize, &cb );
    if( FAILED( hr ) || cb != cSize )
	{
        hr = E_FAIL;
        goto ON_ERR;
	}

	cSize = wcslen(wstrText);
	if (cSize == 0)
	{
        if (m_pBuf)
		{
			m_pBuf[0] = L'\0';
		}
        m_wLength = 0;
		goto ON_ERR;
	}
    wBlockSize = figureblocksize( static_cast<WORD>( cSize ) );
    m_wLength = static_cast<WORD>( cSize );
    if( wBlockSize <= m_wAllocated )
    {
        wcscpy( m_pBuf, wstrText );
    }
    else
    {
        if (m_pBuf) delete[] m_pBuf;
        m_wAllocated = wBlockSize;
        m_pBuf = new WCHAR[m_wAllocated];
        if( m_pBuf != NULL )
        {
            wcscpy( m_pBuf, wstrText );
        }
        else
        {
            hr = E_OUTOFMEMORY;
            m_wLength = 0;
            m_wAllocated = 0;
        }
    }

ON_ERR:
    if( wstrText != NULL )
    {
		delete [] wstrText;
    }
    return hr;
}

/*
HRESULT String::WriteWCS( LPSTREAM pStream )
{
    HRESULT     hr;
    wchar_t*    wstrText;
	DWORD		cb;
    DWORD       cSize;

    cSize = MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, NULL, 0 );  // get number of wide characters required

	wstrText = new wchar_t[cSize];
    if( wstrText == NULL )
	{
		hr = E_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar( CP_ACP, 0, m_pBuf, -1, wstrText, cSize );
        hr = pStream->Write( reinterpret_cast<LPSTR>( wstrText ), cSize * sizeof( wchar_t ), &cb );
        if( FAILED( hr ) || cb != ( cSize * sizeof( wchar_t ) ) )
        {
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
        delete [] wstrText;
    }

    return hr;
}
*/

String operator+( const String& str1, const String& str2 )
{
    String str;

    str = str1;
    str.Concat( str2 );
    return str;
}

String operator+( const String& str1, LPCSTR lpszStr )
{
    String str;

    str = str1;
    str.Concat( lpszStr );
    return str;
}

String operator+( LPCSTR lpszStr, const String& str1 )
{
    String str;

    str = lpszStr;
    str.Concat( str1 );
    return str;
}

String operator+( const String& str1, char ch )
{
    String str;

    str = str1;
    str.Concat( ch );
    return str;
}

String operator+( char ch, const String& str1 )
{
    String str;

    str.Concat( ch );
    str.Concat( str1 );
    return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMIME"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\curvetrk.h ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmgraph.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// DMGraph.cpp : Implementation of CGraph

#include "dmime.h"
#include "DMGraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validp.h"
#include "dls1.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include <strsafe.h>
#define ASSERT  assert

CGraph::CGraph()
{
    m_cRef = 1;
    memset(&m_guidObject,0,sizeof(m_guidObject));
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    memset(m_wszName, 0, sizeof(WCHAR) * DMUS_MAX_NAME);
    memset(m_wszCategory, 0, sizeof(WCHAR) * DMUS_MAX_CATEGORY);
    memset(m_wszFileName, 0, sizeof(WCHAR) * DMUS_MAX_FILENAME);
    InitializeCriticalSection(&m_CrSec);
    InterlockedIncrement(&g_cComponent);
}

CGraph::~CGraph()
{
    Shutdown();  // shouldn't be needed, but doesn't hurt
    DeleteCriticalSection(&m_CrSec);
    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CGraph::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CGraph::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicGraph || iid == IID_IDirectMusicGraph8)
    {
        *ppv = static_cast<IDirectMusicGraph8*>(this);
    }
    else if (iid == IID_CGraph)
    {
        *ppv = static_cast<CGraph*>(this);
    }
    else if (iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IGraphClone)
    {
        *ppv = static_cast<IGraphClone*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on ToolGraph object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | AddRef | Standard AddRef implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicGraph | Release | Standard Release implementation for <i IDirectMusicGraph>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CGraph::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
Made internal 9/25/98
  method HRESULT | IDirectMusicGraph | Shutdown |
  Shuts down the graph. This must be called when the graph is no longer needed,
  in order to release the tools and other memory. A call to Release is not
  sufficient, because there is circular referencing between the graph and the tools.
  However, only the segment, performance, or whatever owns the graph
  should call this function.
  rvalue S_OK | Success.
  rvalue S_FALSE | Success, but didn't need to do anything.
*/
HRESULT STDMETHODCALLTYPE CGraph::Shutdown()
{
    // release all Tools
    CToolRef*   pObj;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);
    if( IsEmpty() )
    {
        hr = S_FALSE;
    }
    else
    {
        while( pObj = RemoveHead() )
        {
            delete pObj;
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CGraph::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex,
    GUID *pguidClassID)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);

    CToolRef*   pToolRef;
    // make sure that this Tool instance isn't already in the Graph
    for( pToolRef = GetHead(); pToolRef; pToolRef = pToolRef->GetNext() )
    {
        if( pTool == pToolRef->m_pTool )
        {
            LeaveCriticalSection(&m_CrSec);
            Trace(1,"Error: Multiple install of the same tool in a graph\n");
            return DMUS_E_ALREADY_EXISTS;
        }
    }
    // insert this Tool instance into the Graph
    pToolRef = new CToolRef;
    if( pToolRef )
    {
        DWORD       dwTemp;
        DWORD*      pdwArray = NULL;

        pToolRef->m_pTool = pTool;
        pTool->AddRef();
        pTool->Init(this);
        dwTemp = 0;
        IDirectMusicTool8 *pTool8;
        if (SUCCEEDED(pTool->QueryInterface(IID_IDirectMusicTool8,(void **) &pTool8)))
        {
            pToolRef->m_fSupportsClone = TRUE;
            pTool8->Release();
        }
        if (pguidClassID)
        {
            pToolRef->m_guidClassID = *pguidClassID;
        }
        else
        {
            IPersistStream *pPersist;
            if (SUCCEEDED(pTool->QueryInterface(IID_IPersistStream,(void **) &pPersist)))
            {
                pPersist->GetClassID(&pToolRef->m_guidClassID);
                pPersist->Release();
            }
        }
        pTool->GetMsgDeliveryType(&dwTemp);
        if( (dwTemp != DMUS_PMSGF_TOOL_IMMEDIATE) && (dwTemp != DMUS_PMSGF_TOOL_QUEUE) && (dwTemp != DMUS_PMSGF_TOOL_ATTIME) )
        {
            dwTemp = DMUS_PMSGF_TOOL_IMMEDIATE;
        }
        pToolRef->m_dwQueue = dwTemp;
        if( FAILED( pTool->GetMediaTypeArraySize(&dwTemp)))
        {
            dwTemp = 0;
        }
        pToolRef->m_dwMTArraySize = dwTemp;
        if( dwTemp )
        {
            pdwArray = new DWORD[dwTemp];
            if( pdwArray )
            {
                HRESULT hrTemp = pTool->GetMediaTypes( &pdwArray, dwTemp );
                if( hrTemp == E_NOTIMPL )
                {
                    delete [] pdwArray;
                    pToolRef->m_dwMTArraySize = 0;
                }
                else
                {
                    pToolRef->m_pdwMediaTypes = pdwArray;
                }
            }
            else
            {
                delete pToolRef;
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
        }
        if( pdwPChannels )
        {
            pToolRef->m_pdwPChannels = new DWORD[cPChannels];
            if( pToolRef->m_pdwPChannels )
            {
                memcpy( pToolRef->m_pdwPChannels, pdwPChannels, sizeof(DWORD) * cPChannels );
                pToolRef->m_dwPCArraySize = cPChannels;
            }
            else
            {
                delete pToolRef;
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
        }

        if (lIndex < 0)
        {
            lIndex += AList::GetCount();       // Make index be offset from end.
        }
        CToolRef *pNext = GetItem(lIndex);
        if (pNext)
        {
            InsertBefore(pNext,pToolRef);
        }
        else
        {
            AList::AddTail(pToolRef);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
HRESULT STDMETHODCALLTYPE CGraph::InsertTool(
    IDirectMusicTool *pTool,    // @parm The Tool to insert.
    DWORD *pdwPChannels,    // @parm An array of which PChannels to place the tool in. These are
                            // id's which are converted to MIDI Channel + Port on output. If the
                            // tool accepts messages on all PChannels, this is NULL. <p cPChannels>
                            // is the count of how many this array points to.
    DWORD cPChannels,       // @parm Count of how many PChannels are pointed to by <p pdwPChannels>.
    LONG lIndex)            // @parm At what position to place the tool. This is an index from either the start
                            // of the current tool list or, working backwards from the end (in which case, it is
                            // a negative number.) If <p lIndex> is out of range, the Tool will be placed at
                            // the very beginning or end of the Tool list. 0 is the beginning. To place a Tool
                            // at the end of the list, use a number for <p lIndex> that is larger than the number
                            // of tools in the current tool list.
{
    V_INAME(IDirectMusicGraph::InsertTool);
    V_INTERFACE(pTool);
    V_BUFPTR_READ_OPT(pdwPChannels, sizeof(DWORD) * cPChannels);

    return InsertTool(pTool,pdwPChannels,cPChannels,lIndex,NULL);
}

HRESULT CGraph::GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)

{
    V_INAME(IDirectMusicGraph::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    HRESULT hr = DMUS_E_NOT_FOUND;
    CToolRef*   pPlace;
    if( !IsEmpty() )
    {
        pPlace = NULL;
        // search for the tool
        EnterCriticalSection(&m_CrSec);
        for( pPlace = GetHead(); pPlace;
            pPlace = pPlace->GetNext() )
        {
            if ((guidObject == pPlace->m_guidClassID) || (guidObject == GUID_All_Objects))
            {
                BOOL fFound = (!pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_ALL));
                if( !fFound )
                {
                    DWORD cCount;
                    // scan through the array of PChannels to see if this one
                    // supports dwPChannel
                    for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
                    {
                        if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
                        {
                            fFound = TRUE;
                            // yep, it supports it
                            break;
                        }
                    }
                }
                if (fFound)
                {
                    if (!dwIndex)
                    {
                        break;
                    }
                    else
                    {
                        dwIndex--;
                    }
                }
            }
        }
        if( pPlace )
        {
            hr = pPlace->m_pTool->QueryInterface(iidInterface,ppObject);
        }
        LeaveCriticalSection(&m_CrSec);
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: Requested Tool not found in Graph\n");
    }
#endif
    return hr;

}

/*
  @method HRESULT | IDirectMusicGraph | GetTool |
  Returns the Tool at the specified index.

  @rvalue DMUS_E_NOT_FOUND | Unable to find a Tool at the position described.
  @rvalue E_POINTER | ppTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The retrieved tool is AddRef'd by this call, so be sure to Release it.
*/
HRESULT STDMETHODCALLTYPE CGraph::GetTool(
    DWORD dwIndex,              // @parm The index, from the beginning and starting at 0,
                                // at which to retrieve the Tool from the Graph.
    IDirectMusicTool **ppTool)  // @parm The <i IDirectMusicTool> pointer to use
                                // for returning the requested tool.
{
    V_INAME(IDirectMusicGraph::GetTool);
    V_PTRPTR_WRITE(ppTool);
    CToolRef*   pPlace;
    HRESULT hr = S_OK;

    if( IsEmpty() )
    {
        Trace(1,"Error: GetTool failed because the Tool Graph is empty\n");
        return DMUS_E_NOT_FOUND;
    }
    pPlace = NULL;
    // search for the indexed tool
    EnterCriticalSection(&m_CrSec);
    for( pPlace = GetHead(); ( dwIndex > 0 ) && pPlace;
        pPlace = pPlace->GetNext() )
    {
        dwIndex--;
    }
    if( NULL == pPlace )
    {
        hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        *ppTool = pPlace->m_pTool;
        (*ppTool)->AddRef();
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicGraph | RemoveTool |
  Removes the Tool from the Graph.

  @rvalue DMUS_E_NOT_FOUND | The specified Tool is not in the Graph.
  @rvalue E_POINTER | pTool is NULL or invalid.
  @rvalue S_OK | Success.

  @comm The Tool is removed from the Graph, and the Graph's reference on the Tool
  object is released.
*/
HRESULT STDMETHODCALLTYPE CGraph::RemoveTool(
    IDirectMusicTool *pTool)    // @parm The <i IDirectMusicTool> pointer of the Tool to remove.
{
    V_INAME(IDirectMusicGraph::RemoveTool);
    V_INTERFACE(pTool);
    CToolRef*   pPlace;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);
    // search for the tool
    for( pPlace = GetHead(); pPlace; pPlace = pPlace->GetNext() )
    {
        if( pPlace->m_pTool == pTool )
            break;
    }
    if( NULL == pPlace )
    {
        Trace(1,"Error: RemoveTool - Tool not in Graph.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    else
    {
        AList::Remove(pPlace);
        delete pPlace;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}


STDMETHODIMP CGraph::Clone(IDirectMusicGraph **ppGraph)

{
    V_INAME(IDirectMusicGraph::Clone);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr = E_OUTOFMEMORY;
    EnterCriticalSection(&m_CrSec);
    CGraph *pNew = new CGraph;
    if (pNew)
    {
        pNew->m_dwValidData = m_dwValidData;
        pNew->m_ftDate = m_ftDate;
        pNew->m_guidObject = m_guidObject;
        pNew->m_vVersion = m_vVersion;
        StringCchCopyW(pNew->m_wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
        StringCchCopyW(pNew->m_wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
        StringCchCopyW(pNew->m_wszName, DMUS_MAX_NAME, m_wszName);
        CToolRef *pSource = GetHead();
        CToolRef *pDest;
        for (;pSource;pSource = pSource->GetNext())
        {
            pDest = new CToolRef;
            if (pDest)
            {
                pNew->AList::AddTail(pDest);
                pDest->m_dwMTArraySize = pSource->m_dwMTArraySize;
                pDest->m_dwPCArraySize = pSource->m_dwPCArraySize;
                pDest->m_dwQueue = pSource->m_dwQueue;
                pDest->m_fSupportsClone = pSource->m_fSupportsClone;
                pDest->m_guidClassID = pSource->m_guidClassID;
                if (pSource->m_dwMTArraySize)
                {
                    pDest->m_pdwMediaTypes = new DWORD[pSource->m_dwMTArraySize];
                    if (pDest->m_pdwMediaTypes)
                    {
                        memcpy(pDest->m_pdwMediaTypes,pSource->m_pdwMediaTypes,
                            sizeof(DWORD)*pDest->m_dwMTArraySize);
                    }
                    else
                    {
                        pDest->m_dwMTArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwMediaTypes = NULL;
                }
                if (pSource->m_dwPCArraySize)
                {
                    pDest->m_pdwPChannels = new DWORD[pSource->m_dwPCArraySize];
                    if (pDest->m_pdwPChannels)
                    {
                        memcpy(pDest->m_pdwPChannels,pSource->m_pdwPChannels,
                            sizeof(DWORD)*pDest->m_dwPCArraySize);
                    }
                    else
                    {
                        pDest->m_dwPCArraySize = 0;
                    }
                }
                else
                {
                    pDest->m_pdwPChannels = NULL;
                }
                if (pSource->m_pTool)
                {
                    if (pDest->m_fSupportsClone)
                    {
                        IDirectMusicTool8 *pTool8 = (IDirectMusicTool8 *) pSource->m_pTool;
                        pTool8->Clone(&pDest->m_pTool);
                    }
                    else
                    {
                        pDest->m_pTool = pSource->m_pTool;
                        pDest->m_pTool->AddRef();
                    }
                }
            }
            else
            {
                delete pNew;
                pNew = NULL;
                break;
            }
        }
    }
    *ppGraph = (IDirectMusicGraph *) pNew;
    if (pNew) hr = S_OK;
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

// returns TRUE if dwType is supported by pToolRef
inline BOOL CGraph::CheckType( DWORD dwType, CToolRef* pToolRef )
{
    BOOL fReturn = FALSE;
    if( pToolRef->m_dwMTArraySize == 0 )
    {
        fReturn = TRUE; // supports all types
    }
    else
    {
        DWORD dw;
        ASSERT( pToolRef->m_pdwMediaTypes );
        for( dw = 0; dw < pToolRef->m_dwMTArraySize; dw++ )
        {
            if( dwType == pToolRef->m_pdwMediaTypes[dw] )
            {
                fReturn = TRUE;
                break;
            }
        }
    }
    return fReturn;
}

HRESULT STDMETHODCALLTYPE CGraph::StampPMsg(
    DMUS_PMSG* pPMsg)   // @parm The message to stamp.
{
    V_INAME(IDirectMusicGraph::StampPMsg);
    V_BUFPTR_WRITE(pPMsg, sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;
    if( NULL == pPMsg )
    {
        return E_INVALIDARG;
    }
    EnterCriticalSection(&m_CrSec);

    CToolRef*   pPlace = GetHead();
    IDirectMusicTool*   pPriorTool;
    DWORD       dwType;
    DWORD       dwPChannel;


    pPriorTool = pPMsg->pTool;
    dwType = pPMsg->dwType;
    dwPChannel = pPMsg->dwPChannel;
    if( pPriorTool )
    {
        for( ; pPlace; pPlace = pPlace->GetNext() )
        {
            if( pPriorTool == pPlace->m_pTool )
            {
                pPlace = pPlace->GetNext();
                break;
            }
        }
    }
    BOOL fFound = FALSE;
    for( ; pPlace ; pPlace = pPlace->GetNext() )
    {
        if( CheckType(dwType, pPlace) )
        {
            if( !pPlace->m_pdwPChannels || (dwPChannel >= DMUS_PCHANNEL_BROADCAST_GROUPS))
            {
                // supports all tracks, or requested channel is broadcast.
                break;
            }
            DWORD cCount;
            // scan through the array of PChannels to see if this one
            // supports dwPChannel
            for( cCount = 0; cCount < pPlace->m_dwPCArraySize; cCount++)
            {
                if( dwPChannel == pPlace->m_pdwPChannels[cCount] )
                {
                    fFound = TRUE;
                    // yep, it supports it
                    break;
                }
            }
        }
        if (fFound) break;
    }
    // release the current tool
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }
    if( NULL == pPlace )
    {
        hr = DMUS_S_LAST_TOOL;
    }
    else
    {
        // if there is no graph pointer, set it to this
        if( NULL == pPMsg->pGraph )
        {
            pPMsg->pGraph = this;
            AddRef();
        }
        // set to the new tool and addref
        if (pPlace->m_pTool) // Just in case, the ptool sometimes goes away in debugging situations after a long break.
        {
            pPMsg->pTool = pPlace->m_pTool;
            pPMsg->pTool->AddRef();
        }
        // set the event's queue type
        pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
        pPMsg->dwFlags |= pPlace->m_dwQueue;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CGraph::GetClassID( CLSID* pClassID )
{
    V_INAME(CGraph::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicGraph;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CGraph::IsDirty()
{
    return S_FALSE;
}

HRESULT CGraph::Load( IStream* pIStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        Shutdown(); // Clear out the tools that are currently in the graph.
        hr = Load(&Parser);
    }
    else
    {
        Trace(1,"Error: Unknown file format when parsing Tool Graph\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    return hr;
}

HRESULT CGraph::Load(CRiffParser *pParser)

{
    RIFFIO ckNext;
    RIFFIO ckChild;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            hr = pParser->Read( &m_guidObject, sizeof(GUID) );
            m_dwValidData |= DMUS_OBJ_OBJECT;
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pParser->Read( &m_vVersion, sizeof(DMUS_VERSION) );
            m_dwValidData |= DMUS_OBJ_VERSION;
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
            hr = pParser->Read( &m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            m_wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
            m_dwValidData |= DMUS_OBJ_CATEGORY;
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pParser->Read( &m_ftDate, sizeof(FILETIME) );
            m_dwValidData |= DMUS_OBJ_DATE;
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    pParser->EnterList(&ckChild);
                    while (pParser->NextChunk(&hr))
                    {
                        if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = pParser->Read(&m_wszName, sizeof(m_wszName));
                            m_wszName[DMUS_MAX_NAME-1] = '\0';
                            m_dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    pParser->LeaveList();
                    break;
                case DMUS_FOURCC_TOOL_LIST:
                    pParser->EnterList(&ckChild);
                    while(pParser->NextChunk(&hr))
                    {
                        if ((ckChild.ckid == FOURCC_RIFF) &&
                            (ckChild.fccType == DMUS_FOURCC_TOOL_FORM))
                        {
                            hr = LoadTool(pParser);
                        }
                    }
                    pParser->LeaveList();
                    break;
            }
            break;
        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CGraph::LoadTool(CRiffParser *pParser)
{
    RIFFIO ckNext;
    DWORD cbSize;

    DMUS_IO_TOOL_HEADER ioDMToolHdr;
    DWORD *pdwPChannels = NULL;

    HRESULT hr = S_OK;

    pParser->EnterList(&ckNext);

    if (pParser->NextChunk(&hr))
    {
        if(ckNext.ckid != DMUS_FOURCC_TOOL_CHUNK)
        {
            pParser->LeaveList();
            Trace(1,"Error: Tool header chunk not first in tool list.\n");
            return DMUS_E_TOOL_HDR_NOT_FIRST_CK;
        }

        hr = pParser->Read(&ioDMToolHdr, sizeof(DMUS_IO_TOOL_HEADER));

        if(ioDMToolHdr.ckid == 0 && ioDMToolHdr.fccType == NULL)
        {
            pParser->LeaveList();
            Trace(1,"Error: Invalid Tool header.\n");
            return DMUS_E_INVALID_TOOL_HDR;
        }

        if(ioDMToolHdr.cPChannels)
        {
            pdwPChannels = new DWORD[ioDMToolHdr.cPChannels];
            // subtract 1 from cPChannels, because 1 element is actually stored
            // in the ioDMToolHdr array.
            cbSize = (ioDMToolHdr.cPChannels - 1) * sizeof(DWORD);
            if(pdwPChannels)
            {
                pdwPChannels[0] = ioDMToolHdr.dwPChannels[0];
                if( cbSize )
                {
                    hr = pParser->Read(&pdwPChannels[1], cbSize);
                    if(FAILED(hr))
                    {
                        delete [] pdwPChannels;
                        pdwPChannels = NULL;
                        pParser->LeaveList();
                        Trace(1,"Error: File read error loading Tool.\n");
                        return DMUS_E_CANNOTREAD;
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        pParser->LeaveList();
        Trace(1,"Error reading Tool chunk - not RIFF format.\n");
        hr = DMUS_E_DESCEND_CHUNK_FAIL;
    }
    while (pParser->NextChunk(&hr))
    {
        if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
            && ckNext.fccType == ioDMToolHdr.fccType) ||
            (ckNext.ckid == ioDMToolHdr.ckid))
        {
            pParser->SeekBack();
            hr = CreateTool(ioDMToolHdr, pParser->GetStream(), pdwPChannels);
            pParser->SeekForward();
        }
    }

    pParser->LeaveList();

    if( pdwPChannels )
    {
        delete [] pdwPChannels;
        pdwPChannels = NULL;
    }

    return hr;
}

HRESULT CGraph::CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels)
{
    assert(pStream);

    IDirectMusicTool* pDMTool = NULL;
    HRESULT hr = CoCreateInstance(ioDMToolHdr.guidClassID,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicTool,
                                  (void**)&pDMTool);

    IPersistStream *pIPersistStream = NULL;

    if(SUCCEEDED(hr))
    {
        hr = pDMTool->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
    }
    else
    {
        Trace(1,"Error creating tool for loading\n");
    }

    if(SUCCEEDED(hr))
    {
        hr = pIPersistStream->Load(pStream);
        if (FAILED(hr))
        {
            Trace(1,"Error loading data into tool\n");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertTool(pDMTool, pdwPChannels, ioDMToolHdr.cPChannels, ioDMToolHdr.lIndex, &ioDMToolHdr.guidClassID);
    }

    if(pIPersistStream)
    {
        pIPersistStream->Release();
    }

    if(pDMTool)
    {
        pDMTool->Release();
    }

    return hr;
}

HRESULT CGraph::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CGraph::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CGraph::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CGraph::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicGraph;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    StringCchCopyW( pDesc->wszName, DMUS_MAX_NAME, m_wszName);
    StringCchCopyW( pDesc->wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
    StringCchCopyW( pDesc->wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );
    return S_OK;
}

STDMETHODIMP CGraph::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CGraph::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            StringCchCopyW(m_wszName, DMUS_MAX_NAME, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            StringCchCopyW(m_wszCategory, DMUS_MAX_CATEGORY, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            StringCchCopyW(m_wszFileName, DMUS_MAX_FILENAME, pDesc->wszFileName);
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: ToolGraph::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Size of descriptor too large for Tool Graph to parse.\n");
    }
    return hr;
}


STDMETHODIMP CGraph::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CGraph::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_TOOLGRAPH_FORM))
    {
        dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicGraph;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                dwValidData |= DMUS_OBJ_VERSION;
                break;
            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                pDesc->wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
                dwValidData |= DMUS_OBJ_CATEGORY;
                break;
            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            pDesc->wszName[DMUS_MAX_NAME-1] = '\0';
                            dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Parsing Tool Graph - invalid file format\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    return hr;
}

void CGraphList::Clear()
{
    CGraph *pGraph;
    while (pGraph = RemoveHead())
    {
        pGraph->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmgraph.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMGraph.h : Declaration of the CGraph

#ifndef __DMGRAPH_H_
#define __DMGRAPH_H_

#include "alist.h"
#include "dmusici.h"
#include "dmusicf.h"

class CRiffParser;

class CToolRef : public AListItem
{
public:
	CToolRef()
	{
        m_fSupportsClone = FALSE;
		m_pTool = NULL;
		m_dwQueue = 0;
		m_dwMTArraySize = 0;
        m_dwPCArraySize = 0;
		m_pdwMediaTypes = NULL;
		m_pdwPChannels = NULL;
        m_guidClassID = GUID_NULL;
	};

	// the memory for pdwTracks and pidType better have been allocated with
	// something compatible with delete!!!
	~CToolRef()
	{
		if( m_pdwPChannels )
		{
			delete [] m_pdwPChannels;
		}
		if( m_pdwMediaTypes )
		{
			delete [] m_pdwMediaTypes;
		}
		if( m_pTool )
		{
			m_pTool->Release();
		}
	};
    CToolRef* GetNext()
	{
		return (CToolRef*)AListItem::GetNext();
	};

    GUID                m_guidClassID;      // Class ID of tool.
    BOOL                m_fSupportsClone;   // Indicates this is a DX8 tool with support for cloning.
	IDirectMusicTool*	m_pTool;
	DWORD	            m_dwQueue;	// type of queue the tool wants messages to be
	DWORD	            m_dwMTArraySize; // size of the pdwMediaTypes array
	DWORD*	            m_pdwMediaTypes; // types of media the tool supports
	DWORD               m_dwPCArraySize;  // size of the pdwPChannels array
	DWORD*	            m_pdwPChannels;	// array of PChannel id's - messages stamped with these id's are
						// sent to the tool

};

class CGraph;

//#undef  INTERFACE
//#define INTERFACE  IGraphClone
DECLARE_INTERFACE_(IGraphClone, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IGraphClone */
    STDMETHOD(Clone)                (THIS_ IDirectMusicGraph **ppGraph) PURE;
};

DEFINE_GUID(IID_CGraph,0xb06c0c24, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);
DEFINE_GUID(IID_IGraphClone,0xb06c0c27, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CGraph
class CGraph :
	public IDirectMusicGraph8,
	public IPersistStream,
    public IDirectMusicObject,
    public IGraphClone,
    public AList,
    public AListItem
{
public:
	CGraph();
	~CGraph();
    CToolRef* GetHead(){return (CToolRef*)AList::GetHead();};
    CToolRef* RemoveHead(){return (CToolRef*)AList::RemoveHead();};
    CToolRef* GetItem(LONG lIndex){return (CToolRef*) AList::GetItem(lIndex);};
    CGraph* GetNext() { return (CGraph*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicGraph
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD dwPosition,IDirectMusicTool** ppTool);
    STDMETHODIMP RemoveTool(IDirectMusicTool* pTool);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pPMsg);
//  IGraphClone 
    STDMETHODIMP Clone(IDirectMusicGraph **ppGraph); 

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    HRESULT GetObjectInPath( DWORD dwPChannel,REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);
    HRESULT Load(CRiffParser *pParser);
protected:
	HRESULT BuildToolList(CRiffParser *pParser);
	HRESULT LoadTool(CRiffParser *pParser);
	HRESULT CreateTool(DMUS_IO_TOOL_HEADER ioDMToolHdr, IStream *pStream, DWORD *pdwPChannels);
	HRESULT STDMETHODCALLTYPE Shutdown();
    HRESULT InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,
                DWORD cPChannels,LONG lIndex, GUID *pguidClassID);
    inline BOOL CheckType( DWORD dwType, CToolRef* pToolRef );
protected:
	CRITICAL_SECTION    m_CrSec;
	long		        m_cRef;
//	DWORD               m_fPartialLoad;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
public:
    DWORD               m_dwLoadID;         // Identifier, used when loaded as part of a song.
};

class CGraphList : public AList
{
public:
    void Clear();
    void AddHead(CGraph* pGraph) { AList::AddHead((AListItem*)pGraph);}
    void Insert(CGraph* pGraph);
    CGraph* GetHead(){return (CGraph*)AList::GetHead();}
    CGraph* GetItem(LONG lIndex){return (CGraph*)AList::GetItem(lIndex);}
    CGraph* RemoveHead() {return (CGraph *) AList::RemoveHead();}
    void Remove(CGraph* pGraph){AList::Remove((AListItem*)pGraph);}
    void AddTail(CGraph* pGraph){AList::AddTail((AListItem*)pGraph);}
    CGraph* GetTail(){ return (CGraph*)AList::GetTail();}
};

#endif //__DMGRAPH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\curvetrk.cpp ===
// Copyright (c) 1998 Microsoft Corporation
/* This file no longer needed */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmime.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmime.h
//
#ifndef _DMIME_H_
#define _DMIME_H_

// Must be before dmusicc.h, which includes dsound.h
//
#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "dmusici.h"

#define COM_NO_WINDOWS_H
#include <objbase.h>

#include <mmsystem.h>
#define RELEASE(x)	if( NULL != x ) { x->Release(); }

#ifdef __cplusplus
extern "C" {
#endif

extern long g_cComponent;
extern bool g_fInitCS;
extern CRITICAL_SECTION g_CritSec;


#define	PARTIALLOAD_S_OK	(1 << 1)
#define PARTIALLOAD_E_FAIL	(1 << 2)

#ifdef __cplusplus
}; /* extern "C" */
#endif
DEFINE_GUID(IID_IDirectMusicPerformanceStats, 0x9301e312, 0x1f22, 0x11d3, 0x82, 0x26, 0xd2, 0xfa, 0x76, 0x25, 0x5d, 0x47);
DEFINE_GUID(IID_IDirectMusicParamHook,0x58880561, 0x5481, 0x11d3, 0x9b, 0xd1, 0xc2, 0x9f, 0xc4, 0xd1, 0xe6, 0x35);
DEFINE_GUID(IID_IDirectMusicSetParamHook,0x679c4138, 0xc62e, 0x4147, 0xb2, 0xb4, 0x9d, 0x56, 0x9a, 0xcb, 0x25, 0x4c);

#endif // _DMIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmhall.cpp ===
// Copyright (c) 1998 Microsoft Corporation
// dmhall.cpp
// No longer used.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmime_i.c ===
/* Copyright (c) 1998-1999 Microsoft Corporation */
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__ 

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_IDirectMusicSegmentObject = {0x04742AFE,0x141F,0x11D1,{0xBC,0x1C,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ITempoTrack = {0x31A1066B,0x31DD,0x11D1,{0xBC,0x2B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ITimeSigTrack = {0x31A1066D,0x31DD,0x11D1,{0xBC,0x2B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ISeqTrack = {0x30E6B076,0x3B49,0x11D1,{0xBC,0x37,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_IDMGraph = {0xA1198389,0x4EF1,0x11D1,{0xBC,0x4B,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_ISysExTrack = {0x4ECFF912,0x56DD,0x11D1,{0xBC,0x50,0x00,0xA0,0xC9,0x22,0xE6,0xEB}};


const IID IID_IPrivatePerformance = { 0xb982d7cb, 0x8177, 0x11d1, { 0xbc, 0x60, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xeb } };


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmprfdll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmprfdll.h
//
// Class factory
//

#ifndef __DMPRFDLL_H_
#define __DMPRFDLL_H_
 
class CClassFactory : public IClassFactory
{
public:
	// IUnknown
    //
	STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CClassFactory(DWORD dwToolType);

	// Destructor
	~CClassFactory(); 

private:
	long m_cRef;
    DWORD m_dwClassType;
};

// We use one class factory to create all classes. We need an identifier for each 
// type so the class factory knows what it is creating.

#define CLASS_PERFORMANCE   1
#define CLASS_GRAPH         2
#define CLASS_SEGMENT       3
#define CLASS_SONG          4
#define CLASS_AUDIOPATH     5
#define CLASS_SEQTRACK      6
#define CLASS_SYSEXTRACK    7
#define CLASS_TEMPOTRACK    8
#define CLASS_TIMESIGTRACK  9
#define CLASS_LYRICSTRACK   10
#define CLASS_MARKERTRACK   11
#define CLASS_PARAMSTRACK   12
#define CLASS_TRIGGERTRACK  13
#define CLASS_WAVETRACK     14
#define CLASS_SEGSTATE      15



#endif // __DMPRFDLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmperf.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// dmperf.h
// @doc EXTERNAL

#ifndef _DMPERF_H_ 
#define _DMPERF_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "audpath.h"
#include "..\shared\dmusicp.h"

#define DMUS_PCHANNEL_KILL_ME   0xFFFFFFF0

typedef struct _DMUS_SEGSTATEDATA
{
    _DMUS_SEGSTATEDATA *    pNext;        // Linked list of these.
    DWORD                   dwQueue;      // Which queue it is in.
    WCHAR                   wszName[DMUS_MAX_NAME]; // Name of object. 
    MUSIC_TIME              mtLoopStart;  // Loop start point.
    MUSIC_TIME              mtLoopEnd;    // Loop end point.
    DWORD                   dwRepeats;    // The original repeat setting (before countdown)
    MUSIC_TIME              mtLength;     // Length of segment.
    REFERENCE_TIME          rtGivenStart; // Start time given in PlaySegment, unquantized
    MUSIC_TIME              mtResolvedStart;// Start time resolved to desired resolution
    MUSIC_TIME              mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME              mtLastPlayed; // The last played absolute time
    MUSIC_TIME              mtPlayTo;     // Used to stop play at a specific time. Ignored when 0.
    MUSIC_TIME              mtSeek;       // How far into the segment we are.
    MUSIC_TIME              mtStartPoint; // Point in the segment where playback started
    DWORD                   dwRepeatsLeft;// Current repeats left.
    DWORD                   dwPlayFlags;// Segment playback control flags
    BOOL                    fStartedPlay; // Indicates if the segstate has started to play yet
    IDirectMusicSegmentState *pSegState;  // Pointer to segstate.
} DMUS_SEGSTATEDATA;

/*////////////////////////////////////////////////////////////////////
// IDirectMusicParamHook */
#undef  INTERFACE
#define INTERFACE  IDirectMusicParamHook
DECLARE_INTERFACE_(IDirectMusicParamHook, IUnknown)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /*  IDirectMusicParamHook */
    STDMETHOD(GetParam)             (THIS_ REFGUID rguidType, 
                                           DWORD dwGroupBits, 
                                           DWORD dwIndex, 
                                           MUSIC_TIME mtTime, 
                                           MUSIC_TIME* pmtNext, 
                                           void* pData,
                                           IDirectMusicSegmentState *pSegState,
                                           DWORD dwTrackFlags,
                                           HRESULT hr) PURE;
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSetParamHook
DECLARE_INTERFACE_(IDirectMusicSetParamHook, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSetParamHook */
    STDMETHOD(SetParamHook)         (THIS_ IDirectMusicParamHook *pIHook) PURE; 
};


#undef  INTERFACE
#define INTERFACE  IDirectMusicPerformanceStats
DECLARE_INTERFACE_(IDirectMusicPerformanceStats, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicPerformanceStats */
    STDMETHOD(TraceAllSegments)     (THIS) PURE;
    STDMETHOD(CreateSegstateList)   (THIS_ DMUS_SEGSTATEDATA ** ppList) PURE;     
    STDMETHOD(FreeSegstateList)     (THIS_ DMUS_SEGSTATEDATA * pList) PURE; 
};



#define DEFAULT_BUFFER_SIZE 1024
// the following constants represent time in milliseconds
#define TRANSPORT_RES 100
#define REALTIME_RES 10

// the following constants represent time in 100 nanosecond increments

#define REF_PER_MIL     10000       // For converting from reference time to mils 
#define MARGIN_MIN      (100 * REF_PER_MIL) // 
#define MARGIN_MAX      (400 * REF_PER_MIL) // 
#define PREPARE_TIME    (m_dwPrepareTime * REF_PER_MIL) // Time
#define NEARTIME        (100 * REF_PER_MIL)
#define NEARMARGIN      (REALTIME_RES * REF_PER_MIL)
/*
// here's a convenience inline function that helps using resolution bits
inline DWORD SIMPLIFY_RESOLUTION(DWORD x)
{   
    if( x & DMUS_SEGF_DEFAULT )     
    {                               
        return DMUS_SEGF_DEFAULT;
    }                               
    else if( x & DMUS_SEGF_SEGMENTEND )
    {
        return DMUS_SEGF_SEGMENTEND;
    }
    else if( x & DMUS_SEGF_MARKER )
    {
        return DMUS_SEGF_MARKER;
    }
    else if( x & DMUS_SEGF_MEASURE )        
    {                               
        return DMUS_SEGF_MEASURE;       
    }                               
    else if( x & DMUS_SEGF_BEAT )   
    {                               
        return DMUS_SEGF_BEAT;          
    }                               
    else if( x & DMUS_SEGF_GRID )   
    {                               
        return DMUS_SEGF_GRID;          
    }   
    else return 0;                      
}
*/

struct PRIV_PMSG;

// pNext contains the next pointer for the next PMsg
// dwPrivFlags contains private flags used by the performance
// rtLast contains the previous time when an event is requeued,
//      which is used by the flush routine
#define PRIV_PART                       \
    struct PRIV_PMSG*   pNext;          \
    DWORD               dwPrivFlags;    \
    DWORD               dwPrivPubSize;  \
    REFERENCE_TIME      rtLast; 

typedef struct PRIV_PART_STRUCT
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
} PRIV_PART_STRUCT;

#define PRIV_PART_SIZE  sizeof(PRIV_PART_STRUCT)
#define PRIV_TO_DMUS(x) ((DMUS_PMSG*)(LPBYTE(x) + PRIV_PART_SIZE))
#define DMUS_TO_PRIV(x) ((PRIV_PMSG*)(LPBYTE(x) - PRIV_PART_SIZE))

typedef struct PRIV_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    /* begin DMUS_PMSG_PART */
    DMUS_PMSG_PART
    /* end DMUS_PMSG_PART */
} PRIV_PMSG;

typedef struct PRIV_TEMPO_PMSG
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
} PRIV_TEMPO_PMSG;

#define PRIV_FLAG_ALLOC_MASK    0x0000FFFF0 // using 4 bits for this for now
#define PRIV_FLAG_ALLOC         0x0000CAFE0 // arbitrary pattern for allocated
#define PRIV_FLAG_FREE			0x0000DEAD0 // pattern for in free list
#define PRIV_FLAG_QUEUED        0x000000001 // set if in a queue
#define PRIV_FLAG_REMOVE        0x000000002 // set if this needs to be removed from a queue
#define PRIV_FLAG_TRACK 		0x000000004 // indicates this message was generated by a track 
#define PRIV_FLAG_FLUSH 		0x000000008 // this is a curve that needs to be flushed after
                                            // its end value has played 
#define PRIV_FLAG_REQUEUE       0x000100000 // set if this needs to be requeued to a queue


class CPMsgQueue
{
public:
    CPMsgQueue();
    ~CPMsgQueue();
    void            Enqueue(PRIV_PMSG *pItem);
    PRIV_PMSG *     Dequeue();
    PRIV_PMSG *     Dequeue(PRIV_PMSG *pItem);
    PRIV_PMSG *     GetHead() { return (m_pTop);}
    PRIV_PMSG *     FlushOldest(REFERENCE_TIME rtTime);
    long            GetCount();
    void            Sort();
private:
    PRIV_PMSG *     m_pTop;             // Top of list.
    PRIV_PMSG *     m_pLastAccessed;    // Last item access in list.
};

// structure used to hold Ports and Buffers
typedef struct PortTable
{
    REFERENCE_TIME      rtLast; // last message time packed
    IDirectMusicPort*  pPort;
    IDirectMusicBuffer* pBuffer;
    IReferenceClock*    pLatencyClock;
    BOOL                fBufferFilled;   // TRUE if there are messages in the buffer that should be sent to the port
    DWORD               dwChannelGroups; // Number of channel groups active on the port.
    CLSID               guidPortID;      // The class id of the port, for matching with audio path requests.
    DMUS_PORTPARAMS8    PortParams;      // PortParams returned when this port was created.  
    DWORD               dwGMFlags;       // DM_PORTFLAGS_XG, DM_PORTFLAGS_GM, and DM_PORTFLAGS_GS.
} PortTable;

// structure to hold a channel of an accumulated parameter.
// The CChannelMap keeps a linked list of these, one list each
// for each parameter type.

class CMergeParam : public AListItem
{
public:
    CMergeParam* GetNext() { return (CMergeParam*)AListItem::GetNext();}
    long                m_lData;    // Current parameter data.
    DWORD               m_dwIndex;  // Which layer.
};

class CParamMerger : public AList
{
public:
    CParamMerger();
    void Clear(long lInitValue);
    BYTE MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume);
    BYTE GetVolumeStart(DWORD dwIndex);
    short MergeTranspose(DWORD dwIndex, short nTranspose);
    long MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange);
    long GetIndexedValue(DWORD dwIndex);
private:
    long MergeData(DWORD dwIndex, long lData);
    void AddHead(CMergeParam* pMergeParam) { AList::AddHead((AListItem*)pMergeParam);}
    CMergeParam* GetHead(){return (CMergeParam*)AList::GetHead();}
    CMergeParam* RemoveHead() {return (CMergeParam *) AList::RemoveHead();}
    void Remove(CMergeParam* pMergeParam){AList::Remove((AListItem*)pMergeParam);}
    void AddTail(CMergeParam* pMergeParam){AList::AddTail((AListItem*)pMergeParam);}
    BYTE VolumeToMidi(long lVolume);
    static long m_lMIDIToDB[128];   // Array for converting MIDI to centibel volume.
    static long m_lDBToMIDI[97];    // For converting volume to MIDI.
    long                m_lMergeTotal;   // Total for all parameters in the list, but not including m_lData.
    long                m_lZeroIndexData;    // Default (no index) data.
};

// structure to hold a single ChannelMap
class CChannelMap
{
public:
    void                Clear();            // Completely clears and resets structure. 
    void                Reset(BOOL fVolumeAndPanToo); // Clears just the midi controllers.
    CParamMerger        m_VolumeMerger;     // Set of volumes to merge.
    CParamMerger        m_ExpressionMerger; // Set of expression controllers to merge.
    CParamMerger        m_TransposeMerger;  // Set of transpositions to merge.
    CParamMerger        m_PitchbendMerger;  // Set of pitchbends to merge.
    CParamMerger        m_PanMerger;        // Set of pans to merge.
    CParamMerger        m_FilterMerger;     // Set of filters to merge.
    CParamMerger        m_ModWheelMerger;   // Set of mod wheel controls to merge.
    CParamMerger        m_ReverbMerger;     // Set of reverb levels to merge.
    CParamMerger        m_ChorusMerger;     // Set of chorus levels to merge.
    DWORD               dwPortIndex;        // index into the PortTable
    DWORD               dwGroup;            // group number of the port
    DWORD               dwMChannel;         // channel number in the group
    short               nTranspose;         // amount to transpose
    WORD                wFlags;             // CMAP_X flags
} ;

#define CMAP_FREE       (WORD) 1        // This channel is currently not in use.
#define CMAP_STATIC     (WORD) 2        // This channel is in use as a regular, static pchannel.
#define CMAP_VIRTUAL    (WORD) 4        // This channel is in use for a dynamic, virtual pchannel.

// structure used to hold a PChannelMap block of 16.
#define PCHANNEL_BLOCKSIZE  16

class CChannelBlock : public AListItem
{
public:
    CChannelBlock* GetNext() { return (CChannelBlock*)AListItem::GetNext();}
    void Init(DWORD dwPChannelStart, DWORD dwPortIndex, DWORD dwGroup, WORD wFlags);
    DWORD               m_dwPChannelStart;  // first PChannel index
    CChannelMap         m_aChannelMap[PCHANNEL_BLOCKSIZE];
    DWORD               m_dwFreeChannels;   // Number of channels currently free.
    DWORD               m_dwPortIndex;      // Port id, if this is completely assigned to one port.
};

class CChannelBlockList : public AList
{
public:
    void Clear();
    void AddHead(CChannelBlock* pChannelBlock) { AList::AddHead((AListItem*)pChannelBlock);}
    CChannelBlock* GetHead(){return (CChannelBlock*)AList::GetHead();}
    CChannelBlock* RemoveHead() {return (CChannelBlock *) AList::RemoveHead();}
    void Remove(CChannelBlock* pChannelBlock){AList::Remove((AListItem*)pChannelBlock);}
    void AddTail(CChannelBlock* pChannelBlock){AList::AddTail((AListItem*)pChannelBlock);}
};

// structure to hold a global GUID and its data
typedef struct GlobalData
{
    ~GlobalData()
    {
        if( pData )
        {
            delete [] pData;
        }
    }
    struct GlobalData*  pNext;
    GUID    guidType;
    void*   pData;
    DWORD   dwSize;
} GlobalData;

// structure to hold internal tempo message with relative tempo
typedef struct DMInternalTempo
{
    /* begin PRIV_PART */
    PRIV_PART
    /* end PRIV_PART */
    DMUS_TEMPO_PMSG tempoPMsg;
    float   fltRelTempo; // the current relative tempo, from .5 to 2
} DMInternalTempo;

/*  Integer constants for defining each segstate queue */

#define SQ_PRI_WAIT     0   
#define SQ_CON_WAIT     1
#define SQ_SEC_WAIT     2
#define SQ_PRI_PLAY     3   
#define SQ_CON_PLAY     4
#define SQ_SEC_PLAY     5
#define SQ_PRI_DONE     6
#define SQ_CON_DONE     7
#define SQ_SEC_DONE     8
#define SQ_COUNT        9

#define IsPriQueue( dwCount ) ((dwCount % 3) == 0)
#define IsConQueue( dwCount ) ((dwCount % 3) == 1)
#define IsSecQueue( dwCount ) ((dwCount % 3) == 2)
#define IsWaitQueue( dwCount ) (dwCount <= SQ_SEC_WAIT)
#define IsPlayQueue( dwCount ) ((dwCount >= SQ_PRI_PLAY) && (dwCount <= SQ_SEC_PLAY))
#define IsDoneQueue( dwCount ) (dwCount >= SQ_PRI_DONE)
 


DEFINE_GUID(IID_CPerformance, 0xade66ea2, 0xe1c5, 0x4552, 0x85, 0x27, 0x1e, 0xef, 0xa5, 0xa, 0xfd, 0x7b);

class CSong;

// class CPerformance
class CPerformance : 
    public IDirectMusicPerformance8,
    public IDirectMusicTool,
    public IDirectMusicGraph,
    public IDirectMusicPerformanceStats,
    public IDirectMusicPerformanceP,
    public IDirectMusicSetParamHook
{
    friend class CAudioPath;
    friend class CSegState;
    friend class CBufferManager;

public:
    CPerformance();
    ~CPerformance();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDirectMusicPerformance
    STDMETHODIMP Init(IDirectMusic** ppDirectMusic,LPDIRECTSOUND pDSound,HWND hWnd );
    STDMETHODIMP PlaySegment(IDirectMusicSegment *pSegment,DWORD dwFlags,
        __int64 i64StartTime,IDirectMusicSegmentState **ppSegmentState);
    STDMETHODIMP Stop(IDirectMusicSegment *pSegment,
        IDirectMusicSegmentState *pSegmentState,MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetSegmentState(IDirectMusicSegmentState **ppSegmentState,MUSIC_TIME mtTime);
    STDMETHODIMP SetPrepareTime(DWORD dwMilliSeconds);
    STDMETHODIMP GetPrepareTime(DWORD* pdwMilliSeconds);
    STDMETHODIMP SetBumperLength(DWORD dwMilliSeconds);
    STDMETHODIMP GetBumperLength(DWORD* pdwMilliSeconds);
    STDMETHODIMP SendPMsg(DMUS_PMSG *pPMsg);
    STDMETHODIMP MusicToReferenceTime(MUSIC_TIME mtTime,REFERENCE_TIME *prtTime);
    STDMETHODIMP ReferenceToMusicTime(REFERENCE_TIME rtTime,MUSIC_TIME *pmtTime);
    STDMETHODIMP IsPlaying(IDirectMusicSegment *pSegment,IDirectMusicSegmentState *pSegState);
    STDMETHODIMP GetTime(REFERENCE_TIME *prtNow,MUSIC_TIME  *pmtNow);
    STDMETHODIMP AllocPMsg(ULONG cb,DMUS_PMSG** ppPMsg);
    STDMETHODIMP FreePMsg(DMUS_PMSG* pPMsg);
    STDMETHODIMP SetNotificationHandle(HANDLE hNotificationEvent,REFERENCE_TIME rtMinimum);
    STDMETHODIMP GetNotificationPMsg(DMUS_NOTIFICATION_PMSG** ppNotificationPMsg);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddPort(IDirectMusicPort* pPort);
    STDMETHODIMP RemovePort(IDirectMusicPort* pPort);
    STDMETHODIMP AssignPChannelBlock(DWORD dwBlockNum,IDirectMusicPort* pPort,DWORD dwGroup);
    STDMETHODIMP AssignPChannel(DWORD dwPChannel,IDirectMusicPort* pPort,DWORD dwGroup,DWORD dwMChannel);
    STDMETHODIMP PChannelInfo(DWORD dwPChannel,IDirectMusicPort** ppPort,DWORD* pdwGroup,DWORD* pdwMChannel);
    STDMETHODIMP DownloadInstrument(IDirectMusicInstrument* pInst,DWORD dwPChannel, 
                IDirectMusicDownloadedInstrument**,DMUS_NOTERANGE* pNoteRanges,
                DWORD dwNumNoteRanges,IDirectMusicPort**,DWORD*,DWORD*);
    STDMETHODIMP Invalidate(MUSIC_TIME mtTime,DWORD dwFlags);
    STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits,DWORD dwIndex, 
                MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP GetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP SetGlobalParam(REFGUID rguidType,void* pData,DWORD dwSize);
    STDMETHODIMP GetLatencyTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP GetQueueTime(REFERENCE_TIME* prtTime);
    STDMETHODIMP AdjustTime(REFERENCE_TIME rtAmount);
    STDMETHODIMP CloseDown(void);
    STDMETHODIMP GetResolvedTime(REFERENCE_TIME rtTime,REFERENCE_TIME* prtResolved,DWORD dwFlags);
    STDMETHODIMP MIDIToMusic(BYTE bMIDIValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,WORD *pwMusicValue);
    STDMETHODIMP MusicToMIDI(WORD wMusicValue,DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,BYTE bChordLevel,BYTE *pbMIDIValue);
    STDMETHODIMP TimeToRhythm(MUSIC_TIME mtTime,DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,BYTE *pbBeat,BYTE *pbGrid,short *pnOffset);
    STDMETHODIMP RhythmToTime(WORD wMeasure,BYTE bBeat,BYTE bGrid,
                short nOffset,DMUS_TIMESIGNATURE *pTimeSig,MUSIC_TIME *pmtTime);   
    //  IDirectMusicPerformance8 
    STDMETHODIMP InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,                          
                           DMUS_AUDIOPARAMS *pParams);
    STDMETHODIMP PlaySegmentEx(IUnknown* pSource, 
                    WCHAR *pwzSegmentName,
                    IUnknown* pTransition,
                    DWORD dwFlags, 
                    __int64 i64StartTime, 
                    IDirectMusicSegmentState** ppSegmentState,
                    IUnknown *pFrom,
                    IUnknown *pAudioPath); 
    STDMETHODIMP StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags) ;
    STDMETHODIMP ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG) ;
    STDMETHODIMP CreateAudioPath( IUnknown *pSourceConfig, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);
    STDMETHODIMP CreateStandardAudioPath(DWORD dwType, DWORD dwPChannelCount, BOOL fActivate, 
                                           IDirectMusicAudioPath **ppNewPath);    
    STDMETHODIMP SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath) ;
    STDMETHODIMP GetDefaultAudioPath(IDirectMusicAudioPath **pAudioPath) ;
    STDMETHODIMP GetParamEx(REFGUID rguidType,
                    DWORD dwTrackID,
                    DWORD dwGroupBits,
                    DWORD dwIndex,
                    MUSIC_TIME mtTime,
                    MUSIC_TIME* pmtNext,
                    void* pParam); 

// IDirectMusicTool
    STDMETHODIMP Init(IDirectMusicGraph* pGraph);
    STDMETHODIMP ProcessPMsg(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg);
    STDMETHODIMP Flush(IDirectMusicPerformance* pPerf,DMUS_PMSG* pPMsg,REFERENCE_TIME mtTime);
    STDMETHODIMP GetMsgDeliveryType(DWORD*);
    STDMETHODIMP GetMediaTypeArraySize(DWORD*);
    STDMETHODIMP GetMediaTypes(DWORD**,DWORD);

// IDirectMusicGraph
    STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg( DMUS_PMSG* pPMsg );
// IDirectMusicPerformanceStats 
    STDMETHODIMP TraceAllSegments() ;
    STDMETHODIMP CreateSegstateList(DMUS_SEGSTATEDATA ** ppList) ;     
    STDMETHODIMP FreeSegstateList(DMUS_SEGSTATEDATA * pList) ;     
// IDirectMusicPerformanceP
    STDMETHODIMP GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags);
// IDirectMusicSetParamHook 
    STDMETHODIMP SetParamHook(IDirectMusicParamHook *pIHook); 

// Access from segstate, audiopath and segment...
    HRESULT GetGraphInternal(IDirectMusicGraph** ppGraph);
    HRESULT FlushVirtualTrack(DWORD dwId,MUSIC_TIME mtTime, BOOL fLeaveNotesOn);
    HRESULT GetControlSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPriSegTime(MUSIC_TIME mtTime,MUSIC_TIME* pmtNextSeg);
    HRESULT GetPathPort(CPortConfig *pConfig);
    void RemoveUnusedPorts();
    DWORD GetPortID(IDirectMusicPort * pPort);
    HRESULT AddPort(IDirectMusicPort* pPort,GUID *pguidPortID,
        DMUS_PORTPARAMS8 *pParams,DWORD *pdwPortID);
private:
    // private member functions
    void Init();
    friend DWORD WINAPI _Transport(LPVOID);
    friend DWORD WINAPI _Realtime(LPVOID);   
    HRESULT CreateThreads();
    HRESULT AllocPMsg(ULONG cb,PRIV_PMSG** ppPMsg);
    HRESULT FreePMsg(PRIV_PMSG* pPMsg);
    inline bool SendShortMsg(IDirectMusicBuffer* pBuffer,
                               IDirectMusicPort* pPort,DWORD dwMsg,
                               REFERENCE_TIME rt, DWORD dwGroup);
    HRESULT PackNote(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackCurve(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackMidi(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackSysEx(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackPatch(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    HRESULT PackWave(DMUS_PMSG* pPMsg,REFERENCE_TIME rt );
    void SendBuffers();
    void Realtime();
    void Transport();
    void ProcessEarlyPMsgs();
    PRIV_PMSG *GetNextPMsg();
    REFERENCE_TIME GetTime();
    REFERENCE_TIME GetLatency();
    REFERENCE_TIME GetBestSegLatency( CSegState* pSeg );
    void PrepSegToPlay(CSegState *pSegState, bool fQueue = false);
    void ManageControllingTracks();
    void PerformSegStNode(DWORD dwList,CSegState* pSegStNode);
    void AddEventToTempoMap( PRIV_PMSG* pPMsg );
    void FlushMainEventQueues( DWORD, MUSIC_TIME mtFlush,  MUSIC_TIME mtFlushUnresolved, BOOL fLeaveNotesOn); // flush all events in all queues.
    void FlushEventQueue( DWORD dwId,CPMsgQueue *pQueue, REFERENCE_TIME rtFlush, REFERENCE_TIME rtFlushUnresolved, BOOL fLeaveNotesOn );
    void ClearMusicStoppedNotification();
    HRESULT PlayOneSegment(
        CSegment* pSegment, 
        DWORD dwFlags, 
        __int64 i64StartTime, 
        CSegState **ppSegState,
        CAudioPath *pAudioPath);
    HRESULT PlaySegmentInternal( CSegment* pSegment, 
        CSong * pSong,
        WCHAR *pwzSegmentName,
        CSegment* pTransition,
        DWORD dwFlags, 
        __int64 i64StartTime, 
        IDirectMusicSegmentState** ppSegmentState,
        IUnknown *pFrom,
        CAudioPath *pAudioPath);
    CSegState *GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom);
    void QueuePrimarySegment( CSegState* pSeg );
    void QueueSecondarySegment( CSegState* pSeg );
    void CalculateSegmentStartTime( CSegState* pSeg );
    MUSIC_TIME ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize );
    void GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig );
    void SyncTimeSig( CSegState *pSegState );
    void DequeueAllSegments();
    void AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime );
    void UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas = true);
    void IncrementTempoMap();
    void RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtOffset, bool fAllDeltas = true);
    void RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime );
    void AddNotificationTypeToAllSegments( REFGUID rguidNotification );
    void RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification );
    CNotificationItem* FindNotification( REFGUID rguidNotification );
    HRESULT GetPort(DWORD dwPortID, IDirectMusicPort **ppPort);
    HRESULT AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup);
    HRESULT AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel);
    HRESULT ReleasePChannel(DWORD dwPChannel);
    CChannelMap * GetPChannelMap( DWORD dwPChannel );
    HRESULT AssignPChannelBlock(DWORD dwBlockNum,DWORD dwPortIndex,DWORD dwGroup,WORD wFlags);
    HRESULT AssignPChannel(DWORD dwPChannel,DWORD dwPortIndex,DWORD dwGroup,DWORD dwMChannel,WORD wFlags);
    HRESULT PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
                DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose = NULL );
    void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime, IDirectMusicSegmentState* pSegSt );
    CSegState* GetPrimarySegmentAtTime( MUSIC_TIME mtTime );
    void ResetAllControllers( REFERENCE_TIME rtTime);
    void ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset);
    void DoStop( CSegState* pSegState, MUSIC_TIME mtTime, BOOL fInvalidate );
    void DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate );
    HRESULT GetChordNotificationStatus(
		DMUS_NOTE_PMSG* pNote, 
		DWORD dwTrackGroup, 
		REFERENCE_TIME rtTime, 
		DMUS_PMSG** ppNew);
	void OnChordUpdateEventQueues( DMUS_NOTIFICATION_PMSG* pNotify);
	void OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush );
#ifdef DBG
    void TraceAllChannelMaps();
#endif

    // private member variables
    IDirectMusic8*      m_pDirectMusic;
    IDirectSound8*      m_pDirectSound;
    IReferenceClock*    m_pClock;
    IDirectMusicGraph*  m_pGraph;
    CAudioPath *        m_pDefaultAudioPath; // Default audio path.
    DWORD               m_dwNumPorts; // the number of ports
    PortTable*          m_pPortTable; // array of ports, number equals m_dwNumPorts
    CChannelBlockList   m_ChannelBlockList; // List of pchannel maps, in blocks of 16
    CChannelBlockList   m_FreeChannelBlockList; // List of pchannel maps that are no longer in use
    CSegStateList       m_SegStateQueues[SQ_COUNT]; // Lists of all active segment states.
    CSegStateList       m_ShutDownQueue;    // List of segments that are pending shutdown.

    CAudioPathList      m_AudioPathList; // List of all active audio paths in this performance.
    CBufferManager      m_BufferManager; // List of all buffers currently in use.
    DMUS_AUDIOPARAMS    m_AudioParams;  // Initial requirements, as set in InitAudio, by app. 

    HANDLE      m_hNotification; // notification handle set in SetNotificationHandle
    REFERENCE_TIME  m_rtNotificationDiscard; // minimum time to hold onto a notification message
    CNotificationList   m_NotificationList;
    GlobalData* m_pGlobalData; // list of global data structs

    DWORD       m_dwAudioPathMode;  // 0 for not yet set, 1 for old methods, 2 for using AudioPaths.
    BOOL        m_fInTransportThread; // This is used to signal that the transport thread
                                     // is active and the realtime thread should hold
                                     // off on processing the early queue.
	BOOL		m_fInTrackPlay;		// This is used to signal that a track is in the process of
									// generating events. These will have the PRIV_FLAG_TRACK flag set.
    CPMsgQueue m_EarlyQueue;        // List of PMsgs that play immediately.
    CPMsgQueue m_NearTimeQueue;     // List of PMsgs that play a little early.
    CPMsgQueue m_OnTimeQueue;       // List of PMsgs that play exactly when due.
    CPMsgQueue m_TempoMap;          // List of tempo changes.
    CPMsgQueue m_OldTempoMap;       // List of old tempo changes.
    CPMsgQueue m_NotificationQueue; // List of notification messages.
    CPMsgQueue m_TimeSigQueue;      // List of time signature changes.

    // cache of allocated pmsg's
#define PERF_PMSG_CB_MIN 48
#define PERF_PMSG_CB_MAX 101
    PRIV_PMSG* m_apPMsgCache[ PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN ];

    DWORD            m_dwInitCS;
    CRITICAL_SECTION m_PMsgCacheCrSec;
    CRITICAL_SECTION m_SegmentCrSec;
    CRITICAL_SECTION m_PipelineCrSec;   // For all the CPMsgQueues
    CRITICAL_SECTION m_PChannelInfoCrSec;
    CRITICAL_SECTION m_GlobalDataCrSec;
    CRITICAL_SECTION m_RealtimeCrSec;
    CRITICAL_SECTION m_MainCrSec;

    HANDLE          m_hTransport;       // to wake up the Transport thread when needed
    HANDLE          m_hRealtime;
    HANDLE          m_hTransportThread; // to kill the Transport thread if needed
    HANDLE          m_hRealtimeThread;

    REFERENCE_TIME  m_rtStart;          // time when this performance started
    REFERENCE_TIME  m_rtAdjust;         // adjustment time to compensate for e.g. smpte drift
    REFERENCE_TIME  m_rtHighestPackedNoteOn; // highest time of packed note on
    REFERENCE_TIME  m_rtEarliestStartTime; // Time of last Stop(0,0,0). New segment can not start before this.
    REFERENCE_TIME  m_rtQueuePosition;  // the highest time a message has been packed, or the latency + m_rtBumperLength, whichever is greater
    REFERENCE_TIME  m_rtNextWakeUp;     // Next time the pipeline thread needs to wake up to deliver a message.
    REFERENCE_TIME  m_rtBumperLength;   // Distance ahead of latency clock to send events down to synth.
    MUSIC_TIME      m_mtTransported;    // the highest time transported
    MUSIC_TIME      m_mtPlayTo;         // the time to play to on the next transport cycle
    MUSIC_TIME      m_mtTempoCursor;    // Tempo map has been generated up to this point.
    DWORD           m_dwPrepareTime;    // time ahead, in milliseconds, to transport
    DWORD           m_dwBumperLength;   // Millisecond version of m_rtBumperLength. 
    long            m_lMasterVolume;    // master volume.
    float           m_fltRelTempo;      // relative tempo, can be from 0 to 200
    long            m_cRef;
    WORD            m_wRollOverCount;   // tracks when timeGetTime rolls over
    DWORD           m_dwTransportThreadID;  // transport thread id
    DWORD           m_dwRealtimeThreadID;
    BOOL            m_fKillThread;      // signal to transport thread to die
    BOOL            m_fKillRealtimeThread;
    BOOL            m_fPlaying;
    BOOL            m_fMusicStopped;
    BOOL            m_fTempoChanged;    // When a tempo change occurs, refresh transport so clock time tracks don't get clobbered.

    IUnknown *      m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    DWORD           m_dwVersion;        // Version number, indicating DX6, DX7, or DX8. Determined by which interface requested.
    IDirectMusicSegmentState * m_pGetParamSegmentState; // Set prior to playing a segment, so GetParam() can know which segment called it.
    DWORD           m_dwGetParamFlags;  // Set prior to playing a segment track, so GetParam() can know how to search for the parameter.
    IDirectMusicParamHook * m_pParamHook;
    bool            m_fReleasedInTransport; // The performance had its final release in the transport thread
    bool            m_fReleasedInRealtime; // The performance had its final release in the realtime thread
};

#endif // _DMPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmprfdll.cpp ===
//
// dmprfdll.cpp
// 
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Note: Dll entry points as well as class factory implementations.
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

#include <objbase.h>
#include <initguid.h>
#include <mmsystem.h>
#include <dsoundp.h>

#include "debug.h"
#define ASSERT  assert 
#include "debug.h"
#include "dmprfdll.h"
#include "dmperf.h"
#include "dmsegobj.h"
#include "song.h"
#include "seqtrack.h"
#include "sysextrk.h"
#include "tempotrk.h"
#include "tsigtrk.h"
#include "marktrk.h"
#include "wavtrack.h"
#include "segtrtrk.h"
#include "lyrictrk.h"
#include "ParamTrk.h"
#include "dmgraph.h"
#include "dmusicc.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "..\shared\oledll.h"
#include "..\dmstyle\dmstylep.h"
#include "..\dmband\dmbndtrk.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "dmksctrl.h"
#include "dmscriptautguids.h"
#include "audpath.h"
#include "..\dswave\dswave.h"
#include "dsoundp.h"            // For IDirectSoundPrivate

bool g_fInitCS = false;
CRITICAL_SECTION g_CritSec;


//////////////////////////////////////////////////////////////////////
// Globals

// Dll's hModule
//
HMODULE g_hModule = NULL;

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;

// Flags DMI_F_xxx from dmusicp.h
//
DWORD g_fFlags;

static char const g_szDoEmulation[] = "DoEmulation";

// CClassFactory::QueryInterface
//
HRESULT __stdcall
CClassFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CClassFactory::CClassFactory(DWORD dwClassType)

{
    m_cRef = 1;
    m_dwClassType = dwClassType;
    InterlockedIncrement(&g_cLock);
}

CClassFactory::~CClassFactory()

{
    InterlockedDecrement(&g_cLock);
}

// CClassFactory::AddRef
//
ULONG __stdcall
CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CClassFactory::Release
//
ULONG __stdcall
CClassFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CClassFactory::CreateInstance
//
//
HRESULT __stdcall
CClassFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    switch (m_dwClassType)
    {
    case CLASS_PERFORMANCE:
        {
            CPerformance *pInst;

            try
            {
                pInst = new CPerformance;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_GRAPH:
        {
            CGraph *pInst = new CGraph;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEGMENT:
        {
            CSegment *pInst = new CSegment;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            // The segment is initialized with a ref count of 0, so QI will set it to 1.
            hr = pInst->QueryInterface(iid, ppv);
        }
        break;
    case CLASS_SONG:
        {
            CSong *pInst = new CSong;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_AUDIOPATH:
        {
            CAudioPathConfig *pInst;

            try
            {
                pInst = new CAudioPathConfig;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SEQTRACK:
        {
            CSeqTrack *pInst;

            try
            {
                pInst = new CSeqTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_SYSEXTRACK:
        {
            CSysExTrack *pInst;

            try
            {
                pInst = new CSysExTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TEMPOTRACK:
        {
            CTempoTrack *pInst;

            try
            {
                pInst = new CTempoTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TIMESIGTRACK:
        {
            CTimeSigTrack *pInst;
    
            try
            {
                pInst = new CTimeSigTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_MARKERTRACK:
        {
            CMarkerTrack *pInst;
    
            try
            {
                pInst = new CMarkerTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_WAVETRACK:
        {
            CWavTrack *pInst;
    
            try
            {
                pInst = new CWavTrack;
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
        break;
    case CLASS_TRIGGERTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CSegTriggerTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_LYRICSTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CLyricsTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_PARAMSTRACK:
        {
            try
            {
                hr = TrackHelpCreateInstance<CParamControlTrack>(pUnknownOuter, iid, ppv);
            }
            catch( ... )
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case CLASS_SEGSTATE:
        {
            CSegState *pInst = new CSegState;
            if (pInst == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = pInst->QueryInterface(iid, ppv);
            pInst->Release();
        }
    }
    return hr;
}

// CClassFactory::LockServer
//
HRESULT __stdcall
CClassFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}


// Version information for our class
//
TCHAR g_szDMPerformanceFriendlyName[]    = TEXT("DirectMusicPerformance");
TCHAR g_szDMPerformanceVerIndProgID[]    = TEXT("Microsoft.DirectMusicPerformance");
TCHAR g_szDMPerformanceProgID[]          = TEXT("Microsoft.DirectMusicPerformance.1");

TCHAR g_szDMSegmentFriendlyName[]    = TEXT("DirectMusicSegment");
TCHAR g_szDMSegmentVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegment");
TCHAR g_szDMSegmentProgID[]          = TEXT("Microsoft.DirectMusicSegment.1");

TCHAR g_szDMSegmentStateFriendlyName[]    = TEXT("DirectMusicSegmentState");
TCHAR g_szDMSegmentStateVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegmentState");
TCHAR g_szDMSegmentStateProgID[]          = TEXT("Microsoft.DirectMusicSegmentState.1");

TCHAR g_szSongFriendlyName[]    = TEXT("DirectMusicSong");
TCHAR g_szSongVerIndProgID[]    = TEXT("Microsoft.DirectMusicSong");
TCHAR g_szSongProgID[]          = TEXT("Microsoft.DirectMusicSong.1");

TCHAR g_szAudioPathFriendlyName[]    = TEXT("DirectMusicAudioPath");
TCHAR g_szAudioPathVerIndProgID[]    = TEXT("Microsoft.DirectMusicAudioPath");
TCHAR g_szAudioPathProgID[]          = TEXT("Microsoft.DirectMusicAudioPath.1");

TCHAR g_szDMGraphFriendlyName[]    = TEXT("DirectMusicGraph");
TCHAR g_szDMGraphVerIndProgID[]    = TEXT("Microsoft.DirectMusicGraph");
TCHAR g_szDMGraphProgID[]          = TEXT("Microsoft.DirectMusicGraph.1");

TCHAR g_szDMSeqTrackFriendlyName[]    = TEXT("DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSeqTrack");
TCHAR g_szDMSeqTrackProgID[]          = TEXT("Microsoft.DirectMusicSeqTrack.1");

TCHAR g_szDMSysExTrackFriendlyName[]    = TEXT("DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSysExTrack");
TCHAR g_szDMSysExTrackProgID[]          = TEXT("Microsoft.DirectMusicSysExTrack.1");

TCHAR g_szDMTempoTrackFriendlyName[]    = TEXT("DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTempoTrack");
TCHAR g_szDMTempoTrackProgID[]          = TEXT("Microsoft.DirectMusicTempoTrack.1");

TCHAR g_szDMTimeSigTrackFriendlyName[]    = TEXT("DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicTimeSigTrack");
TCHAR g_szDMTimeSigTrackProgID[]          = TEXT("Microsoft.DirectMusicTimeSigTrack.1");

TCHAR g_szMarkerTrackFriendlyName[]    = TEXT("DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicMarkerTrack");
TCHAR g_szMarkerTrackProgID[]          = TEXT("Microsoft.DirectMusicMarkerTrack.1");

TCHAR g_szWaveTrackFriendlyName[]    = TEXT("DirectMusicWaveTrack");
TCHAR g_szWaveTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicWaveTrack");
TCHAR g_szWaveTrackProgID[]          = TEXT("Microsoft.DirectMusicWaveTrack.1");

TCHAR g_szSegTriggerTrackFriendlyName[]    = TEXT("DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicSegTriggerTrack");
TCHAR g_szSegTriggerTrackProgID[]          = TEXT("Microsoft.DirectMusicSegTriggerTrack.1");

TCHAR g_szLyricsTrackFriendlyName[]    = TEXT("DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicLyricsTrack");
TCHAR g_szLyricsTrackProgID[]          = TEXT("Microsoft.DirectMusicLyricsTrack.1");

TCHAR g_szParamControlTrackFriendlyName[]    = TEXT("DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackVerIndProgID[]    = TEXT("Microsoft.DirectMusicParamControlTrack");
TCHAR g_szParamControlTrackProgID[]          = TEXT("Microsoft.DirectMusicParamControlTrack.1");

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
// Standard calls needed to be an inproc server

//////////////////////////////////////////////////////////////////////
// DllCanUnloadNow

STDAPI DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllGetClassObject

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    IUnknown* pIUnknown = NULL;
    DWORD dwTypeID = 0;

    if(clsid == CLSID_DirectMusicPerformance)
    {
        dwTypeID = CLASS_PERFORMANCE;
    }
    else if(clsid == CLSID_DirectMusicSegment) 
    {
        dwTypeID = CLASS_SEGMENT;
    }
    else if(clsid == CLSID_DirectMusicSong) 
    {
        dwTypeID = CLASS_SONG;
    }
    else if(clsid == CLSID_DirectMusicAudioPathConfig) 
    {
        dwTypeID = CLASS_AUDIOPATH;
    }
    else if(clsid == CLSID_DirectMusicSeqTrack) 
    {
        dwTypeID = CLASS_SEQTRACK;
    }
    else if(clsid == CLSID_DirectMusicGraph) 
    {
        dwTypeID = CLASS_GRAPH;
    }
    else if(clsid == CLSID_DirectMusicSysExTrack) 
    {
        dwTypeID = CLASS_SYSEXTRACK;
    }
    else if(clsid == CLSID_DirectMusicTempoTrack) 
    {
        dwTypeID = CLASS_TEMPOTRACK;
    }
    else if(clsid == CLSID_DirectMusicTimeSigTrack) 
    {
        dwTypeID = CLASS_TIMESIGTRACK;
    }
    else if(clsid == CLSID_DirectMusicMarkerTrack) 
    {
        dwTypeID = CLASS_MARKERTRACK;
    }
    else if(clsid == CLSID_DirectMusicWaveTrack) 
    {
        dwTypeID = CLASS_WAVETRACK;
    }
    else if(clsid == CLSID_DirectMusicSegmentTriggerTrack)
    {
        dwTypeID = CLASS_TRIGGERTRACK;
    }
    else if(clsid == CLSID_DirectMusicLyricsTrack)
    {
        dwTypeID = CLASS_LYRICSTRACK;
    }
    else if(clsid == CLSID_DirectMusicParamControlTrack)
    {
        dwTypeID = CLASS_PARAMSTRACK;
    }
    else if(clsid == CLSID_DirectMusicSegmentState)
    {
        dwTypeID = CLASS_SEGSTATE;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
    pIUnknown = static_cast<IUnknown*> (new CClassFactory(dwTypeID));
    if(pIUnknown) 
    {
        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();
        return hr;
    }
    return E_OUTOFMEMORY;
}

//////////////////////////////////////////////////////////////////////
// DllUnregisterServer

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    UnregisterServer(CLSID_DirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    UnregisterServer(CLSID_DirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    UnregisterServer(CLSID_DirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    UnregisterServer(CLSID_DirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);
    
    UnregisterServer(CLSID_DirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    UnregisterServer(CLSID_DirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    UnregisterServer(CLSID_DirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    UnregisterServer(CLSID_DirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    UnregisterServer(CLSID_DirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);

    UnregisterServer(CLSID_DirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);

    UnregisterServer(CLSID_DirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);

    UnregisterServer(CLSID_DirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);

    UnregisterServer(CLSID_DirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);

    UnregisterServer(CLSID_DirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// DllRegisterServer

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicPerformance,
                     g_szDMPerformanceFriendlyName,
                     g_szDMPerformanceVerIndProgID,
                     g_szDMPerformanceProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSegment,
                     g_szDMSegmentFriendlyName,
                     g_szDMSegmentVerIndProgID,
                     g_szDMSegmentProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSegmentState,
                     g_szDMSegmentStateFriendlyName,
                     g_szDMSegmentStateVerIndProgID,
                     g_szDMSegmentStateProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSong,
                     g_szSongFriendlyName,
                     g_szSongVerIndProgID,
                     g_szSongProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicAudioPathConfig,
                     g_szAudioPathFriendlyName,
                     g_szAudioPathVerIndProgID,
                     g_szAudioPathProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicGraph,
                     g_szDMGraphFriendlyName,
                     g_szDMGraphVerIndProgID,
                     g_szDMGraphProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSeqTrack,
                     g_szDMSeqTrackFriendlyName,
                     g_szDMSeqTrackVerIndProgID,
                     g_szDMSeqTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicSysExTrack,
                     g_szDMSysExTrackFriendlyName,
                     g_szDMSysExTrackVerIndProgID,
                     g_szDMSysExTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicTempoTrack,
                     g_szDMTempoTrackFriendlyName,
                     g_szDMTempoTrackVerIndProgID,
                     g_szDMTempoTrackProgID);

    RegisterServer(g_hModule,
                   CLSID_DirectMusicTimeSigTrack,
                     g_szDMTimeSigTrackFriendlyName,
                     g_szDMTimeSigTrackVerIndProgID,
                     g_szDMTimeSigTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicMarkerTrack,
                     g_szMarkerTrackFriendlyName,
                     g_szMarkerTrackVerIndProgID,
                     g_szMarkerTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicWaveTrack,
                     g_szWaveTrackFriendlyName,
                     g_szWaveTrackVerIndProgID,
                     g_szWaveTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicSegmentTriggerTrack,
                     g_szSegTriggerTrackFriendlyName,
                     g_szSegTriggerTrackVerIndProgID,
                     g_szSegTriggerTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicLyricsTrack,
                     g_szLyricsTrackFriendlyName,
                     g_szLyricsTrackVerIndProgID,
                     g_szLyricsTrackProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicParamControlTrack,
                     g_szParamControlTrackFriendlyName,
                     g_szParamControlTrackVerIndProgID,
                     g_szParamControlTrackProgID);
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Standard Win32 DllMain

//////////////////////////////////////////////////////////////////////
// DllMain

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        TraceI(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        TraceI(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            if (++nReferenceCount == 1)
            {
                g_fInitCS = false;
                try
                {
                    InitializeCriticalSection(&g_CritSec);
                    InitializeCriticalSection(&WaveItem::st_WaveListCritSect);
                }
                catch( ... )
                {
                    TraceI(0, "InitializeCriticalSection failed.\n");
                    return FALSE;
                }
                g_fInitCS = true;

                #ifdef DBG
                    DebugInit();
                #endif

                if (!DisableThreadLibraryCalls(hModule))
                {
                    TraceI(1, "DisableThreadLibraryCalls failed.\n");
                }

                g_hModule = hModule;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (--nReferenceCount == 0)
            {
                TraceI(-1, "Unloading g_cLock %d  g_cComponent %d\n", g_cLock, g_cComponent);
                if (g_fInitCS)
                {
                    DeleteCriticalSection(&g_CritSec);
                    DeleteCriticalSection(&WaveItem::st_WaveListCritSect);
                }

                // Assert if we still have some objects hanging around
                assert(g_cComponent == 0);
                assert(g_cLock == 0);
            }
            break;
            
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmperf.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmperf.cpp

#include <windows.h>
#include <mmsystem.h>
#include <time.h>       // To seed random number generator
#include <dsoundp.h>
#include "debug.h"
#define ASSERT assert
#include "dmperf.h"
#include "dmime.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "song.h"
#include "curve.h"
#include "math.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\dmstylep.h"
#include <ks.h>
#include "dmksctrl.h"
#include <dsound.h>
#include "dmscriptautguids.h"
#include "..\shared\dmusiccp.h"
#include "wavtrack.h"
#include "tempotrk.h"
#include <strsafe.h>

#pragma warning(disable:4296)

#define PORT_CHANNEL 0

// @doc EXTERNAL
#define MIDI_NOTEOFF        0x80
#define MIDI_NOTEON         0x90
#define MIDI_PTOUCH         0xA0
#define MIDI_CCHANGE        0xB0
#define MIDI_PCHANGE        0xC0
#define MIDI_MTOUCH         0xD0
#define MIDI_PBEND          0xE0
#define MIDI_SYSX           0xF0
#define MIDI_MTC            0xF1
#define MIDI_SONGPP         0xF2
#define MIDI_SONGS          0xF3
#define MIDI_EOX            0xF7
#define MIDI_CLOCK          0xF8
#define MIDI_START          0xFA
#define MIDI_CONTINUE       0xFB
#define MIDI_STOP           0xFC
#define MIDI_SENSE          0xFE
#define MIDI_CC_BS_MSB      0x00
#define MIDI_CC_BS_LSB      0x20
#define MIDI_CC_DATAENTRYMSB 0x06
#define MIDI_CC_DATAENTRYLSB 0x26
#define MIDI_CC_NRPN_LSB    0x62
#define MIDI_CC_NRPN_MSB    0x63
#define MIDI_CC_RPN_LSB     0x64
#define MIDI_CC_RPN_MSB     0x65
#define MIDI_CC_MOD_WHEEL   0x01
#define MIDI_CC_VOLUME      0x07
#define MIDI_CC_PAN         0x0A
#define MIDI_CC_EXPRESSION  0x0B
#define MIDI_CC_FILTER      0x4A
#define MIDI_CC_REVERB      0x5B
#define MIDI_CC_CHORUS      0x5D
#define MIDI_CC_RESETALL    0x79
#define MIDI_CC_ALLSOUNDSOFF 0x78

#define CLEARTOOLGRAPH(x)   { \
    if( (x)->pTool ) \
    { \
        (x)->pTool->Release(); \
        (x)->pTool = NULL; \
    } \
    if( (x)->pGraph ) \
    { \
        (x)->pGraph->Release(); \
        (x)->pGraph = NULL; }}

#define GetLatencyWithPrePlay() ( GetLatency() + m_rtBumperLength )

void CChannelBlockList::Clear()
{
    CChannelBlock* pCB;
    while( pCB = RemoveHead() )
    {
        delete pCB;
    }
}

void CChannelMap::Clear()

{
    Reset(TRUE);                // Clear all MIDI controllers
    m_TransposeMerger.Clear(0); // No transpose.
    nTranspose = 0;
    wFlags = CMAP_FREE;
}

void CChannelMap::Reset(BOOL fVolumeAndPanToo)

{
    if (fVolumeAndPanToo)
    {
        m_PanMerger.Clear(0);       // Panned to center.
        m_VolumeMerger.Clear(-415); // Equivalent to MIDI value 100.
    }
    m_PitchbendMerger.Clear(0); // No pitch bend.
    m_ExpressionMerger.Clear(0);// Full volume for expression (MIDI 127.)
    m_FilterMerger.Clear(0);    // No filter change.
    m_ReverbMerger.Clear(-87); // Start at default level (MIDI 40).
    m_ChorusMerger.Clear(-127);    // Start with no chorus.
    m_ModWheelMerger.Clear(-127);  // Start with no mod wheel.
}

void CParamMerger::Clear(long lInitValue )

{
    CMergeParam *pParam;
    while (pParam = RemoveHead())
    {
        delete pParam;
    }
    m_lZeroIndexData = lInitValue;
    m_lMergeTotal = 0;
}


long CParamMerger::m_lMIDIToDB[128] = {       // Global array used to convert MIDI to dB.
    -9600, -8415, -7211, -6506, -6006, -5619, -5302, -5034,
    -4802, -4598, -4415, -4249, -4098, -3959, -3830, -3710,
    -3598, -3493, -3394, -3300, -3211, -3126, -3045, -2968,
    -2894, -2823, -2755, -2689, -2626, -2565, -2506, -2449,
    -2394, -2341, -2289, -2238, -2190, -2142, -2096, -2050,
    -2006, -1964, -1922, -1881, -1841, -1802, -1764, -1726,
    -1690, -1654, -1619, -1584, -1551, -1518, -1485, -1453,
    -1422, -1391, -1361, -1331, -1302, -1273, -1245, -1217,
    -1190, -1163, -1137, -1110, -1085, -1059, -1034, -1010,
    -985, -961, -938, -914, -891, -869, -846, -824,
    -802, -781, -759, -738, -718, -697, -677, -657,
    -637, -617, -598, -579, -560, -541, -522, -504,
    -486, -468, -450, -432, -415, -397, -380, -363,
    -347, -330, -313, -297, -281, -265, -249, -233,
    -218, -202, -187, -172, -157, -142, -127, -113,
    -98, -84, -69, -55, -41, -27, -13, 0
};


long CParamMerger::m_lDBToMIDI[97] = {        // Global array used to convert db to MIDI.
    127, 119, 113, 106, 100, 95, 89, 84, 80, 75,
    71, 67, 63, 60, 56, 53, 50, 47, 45, 42,
    40, 37, 35, 33, 31, 30, 28, 26, 25, 23,
    22, 21, 20, 19, 17, 16, 15, 15, 14, 13,
    12, 11, 11, 10, 10, 9, 8, 8, 8, 7,
    7, 6, 6, 6, 5, 5, 5, 4, 4, 4,
    4, 3, 3, 3, 3, 3, 2, 2, 2, 2,
    2, 2, 2, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0
};


CParamMerger::CParamMerger()
{
    m_lMergeTotal = 0;
    m_lZeroIndexData = 0;
}

BYTE CParamMerger::VolumeToMidi(long lVolume)

{
    if (lVolume < -9600) lVolume = -9600;
    if (lVolume > 0) lVolume = 0;
    lVolume = -lVolume;
    long lFraction = lVolume % 100;
    lVolume = lVolume / 100;
    long lResult = m_lDBToMIDI[lVolume];
    lResult += ((m_lDBToMIDI[lVolume + 1] - lResult) * lFraction) / 100;
    return (BYTE) lResult;
}

/*  MergeMidiVolume() takes an incoming volume and updates the matching
    MergeParam structure (determined by index.) If there is no such matching
    structure, it creates one. Also, the volumes are totaled to create a new
    total volume, which is converted back to MIDI volume and returned.
    This mechanism allows us to introduce additional volume controllers
    that are summed.
*/

BYTE CParamMerger::MergeMidiVolume(DWORD dwIndex, BYTE bMIDIVolume)

{
    long lVolume = MergeData(dwIndex,m_lMIDIToDB[bMIDIVolume]);
    if (m_lMergeTotal || dwIndex) // Optimization for simplest and most frequent case - there are no additional indexes.
    {
        return (BYTE) VolumeToMidi(lVolume);
    }
    return bMIDIVolume;
}

BYTE CParamMerger::GetVolumeStart(DWORD dwIndex)

{
    if (dwIndex == 0)
    {
        return VolumeToMidi(m_lZeroIndexData);
    }
    return VolumeToMidi(GetIndexedValue(dwIndex));
}

/*  MergeValue is used for all data types that have a plus and minus range
    around a center bias. These include pitch bend, pan and filter.
    MergeValue takes an incoming data value, adds the bias (in lRange),
    calls MergeData to combine it with the other merged inputs,
    adds the bias back in and checks for over or underflow.
*/

long CParamMerger::MergeValue(DWORD dwIndex, long lData, long lCenter, long lRange)

{
    lData = MergeData(dwIndex,lData - lCenter) + lCenter;
    if (lData < 0) lData = 0;
    if (lData > lRange) lData = lRange;
    return lData;
}


short CParamMerger::MergeTranspose(DWORD dwIndex, short nTranspose)

{
    return (short) MergeData(dwIndex,nTranspose);
}

long CParamMerger::MergeData(DWORD dwIndex, long lData)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, update it
        // with the new data. Meanwhile, add up all the data fields.
        // If it is not found, add an entry for it.
        m_lMergeTotal = 0;   // Recalculate
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                // Found the index. Store the new value.
                pParam->m_lData = lData;
                fNoEntry = FALSE;
            }
            // Sum all values to create the merged total.
            m_lMergeTotal += pParam->m_lData;
        }
        if (fNoEntry)
        {
            // Didn't find the index. Create one and store the value.
            pParam = new CMergeParam;
            if (pParam)
            {
                pParam->m_dwIndex = dwIndex;
                pParam->m_lData = lData;
                m_lMergeTotal += lData;
                AddHead(pParam);
            }
        }
        // Add the initial value for merge index 0.
        lData = m_lMergeTotal + m_lZeroIndexData;
    }
    else
    {
        m_lZeroIndexData = lData;
        lData += m_lMergeTotal;
    }
    return lData;
}


long CParamMerger::GetIndexedValue(DWORD dwIndex)

{
    if (dwIndex)
    {
        // If this has an index, scan the indexes. Look
        // for the matching index. If it is found, return its data.
        // If not, return the default 0.
        BOOL fNoEntry = TRUE;
        CMergeParam *pParam = GetHead();
        for (;pParam;pParam = pParam->GetNext())
        {
            if (pParam->m_dwIndex == dwIndex)
            {
                return pParam->m_lData;
            }
        }
        return 0;
    }
    return m_lZeroIndexData;
}

void CChannelBlock::Init(DWORD dwPChannelStart,
                         DWORD dwPortIndex, DWORD dwGroup,
                         WORD wFlags)

{
    DWORD dwIndex;
    m_dwPortIndex = dwPortIndex;
    m_dwPChannelStart = ( dwPChannelStart / PCHANNEL_BLOCKSIZE ) * PCHANNEL_BLOCKSIZE;
    for( dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++ )
    {
        m_aChannelMap[dwIndex].Clear();
        m_aChannelMap[dwIndex].dwPortIndex = dwPortIndex;
        m_aChannelMap[dwIndex].dwGroup = dwGroup;
        m_aChannelMap[dwIndex].dwMChannel = dwIndex;
        m_aChannelMap[dwIndex].nTranspose = 0;
        m_aChannelMap[dwIndex].wFlags = wFlags;
    }
    if (wFlags == CMAP_FREE) m_dwFreeChannels = 16;
    else m_dwFreeChannels = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CPerformance

// Flags for which critical sections have been initialized
//

#define PERF_ICS_SEGMENT        0x0001
#define PERF_ICS_PIPELINE       0x0002
#define PERF_ICS_PCHANNEL       0x0004
#define PERF_ICS_GLOBAL         0x0010
#define PERF_ICS_REALTIME       0x0020
#define PERF_ICS_PORTTABLE      0x0040
#define PERF_ICS_MAIN           0x0100
#define PERF_ICS_PMSGCACHE      0x0200

CPerformance::CPerformance()
{
    m_pGraph = NULL;
    m_dwPrepareTime = 1000;
    m_dwBumperLength = 50;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    m_pGlobalData = NULL;
    m_fInTrackPlay = FALSE;
    m_fPlaying = FALSE;
    m_wRollOverCount = 0;
    m_mtTransported = 0;
    m_mtTempoCursor = 0;
    m_pParamHook = NULL;
    m_hNotification = 0;
    m_rtNotificationDiscard = 20000000;
    m_rtStart = 0;
    m_rtAdjust = 0;
    m_mtPlayTo = 0;
    m_cRef = 1;
    m_pUnkDispatch = NULL;
    m_dwVersion = 6;
    m_dwNumPorts = 0;
    m_pPortTable = NULL;
    m_fKillThread = 0;
    m_fKillRealtimeThread = 0;
    m_fInTransportThread = 0;
    m_dwTransportThreadID = 0;
    m_pDirectMusic = NULL;
    m_pDirectSound = NULL;
    m_pClock = NULL;
    m_fReleasedInTransport = false;
    m_fReleasedInRealtime = false;
    InterlockedIncrement(&g_cComponent);

    TraceI(3,"CPerformance %lx\n", this);
    m_dwInitCS = 0;

    InitializeCriticalSection(&m_SegmentCrSec);         m_dwInitCS |= PERF_ICS_SEGMENT;
    InitializeCriticalSection(&m_PipelineCrSec);        m_dwInitCS |= PERF_ICS_PIPELINE;
    InitializeCriticalSection(&m_PChannelInfoCrSec);    m_dwInitCS |= PERF_ICS_PCHANNEL;
    InitializeCriticalSection(&m_GlobalDataCrSec);      m_dwInitCS |= PERF_ICS_GLOBAL;
    InitializeCriticalSection(&m_RealtimeCrSec);        m_dwInitCS |= PERF_ICS_REALTIME;
    InitializeCriticalSection(&m_PMsgCacheCrSec);       m_dwInitCS |= PERF_ICS_PMSGCACHE;
    InitializeCriticalSection(&m_MainCrSec);            m_dwInitCS |= PERF_ICS_MAIN;
    memset( m_apPMsgCache, 0, sizeof(DMUS_PMSG*) * (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN) );
    DWORD dwCount;
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        m_SegStateQueues[dwCount].SetID(dwCount);
    }
    Init();
}

void CPerformance::Init()

{
    m_rtEarliestStartTime = 0;
    m_lMasterVolume = 0;
    if (m_dwVersion >= 8)
    {
        m_rtQueuePosition = 0;
        m_dwPrepareTime = 1000;
        m_dwBumperLength = 50;
        m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
        if (m_dwAudioPathMode)
        {
            CloseDown();
        }
    }
    m_pDefaultAudioPath = NULL;
    m_fltRelTempo = 1;
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    m_rtHighestPackedNoteOn = 0;
    m_dwAudioPathMode = 0;
    m_hTransport = 0;
    m_hTransportThread = 0;
    m_dwRealtimeThreadID = 0;
    m_hRealtime = 0;
    m_hRealtimeThread = 0;
    m_fMusicStopped = TRUE;
    BOOL fAuto = FALSE;
    SetGlobalParam(GUID_PerfAutoDownload,&fAuto,sizeof(BOOL));
    DMUS_TIMESIG_PMSG* pTimeSig;
    if (SUCCEEDED(AllocPMsg(sizeof(DMUS_TIMESIG_PMSG),(DMUS_PMSG **) &pTimeSig)))
    {
        pTimeSig->wGridsPerBeat = 4;
        pTimeSig->bBeatsPerMeasure = 4;
        pTimeSig->bBeat = 4;
        pTimeSig->dwFlags = DMUS_PMSGF_REFTIME;
        pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
        EnterCriticalSection(&m_PipelineCrSec);
        m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pTimeSig) );
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

CPerformance::~CPerformance()
{
    TraceI(3,"~CPerformance %lx\n", this);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    CloseDown(); // this should have already been called, but just in case...
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed

    if (m_dwInitCS & PERF_ICS_SEGMENT)  DeleteCriticalSection(&m_SegmentCrSec);
    if (m_dwInitCS & PERF_ICS_PIPELINE) DeleteCriticalSection(&m_PipelineCrSec);
    if (m_dwInitCS & PERF_ICS_PCHANNEL) DeleteCriticalSection(&m_PChannelInfoCrSec);
    if (m_dwInitCS & PERF_ICS_GLOBAL)   DeleteCriticalSection(&m_GlobalDataCrSec);
    if (m_dwInitCS & PERF_ICS_REALTIME) DeleteCriticalSection(&m_RealtimeCrSec);
    if (m_dwInitCS & PERF_ICS_PMSGCACHE)DeleteCriticalSection(&m_PMsgCacheCrSec);
    if (m_dwInitCS & PERF_ICS_MAIN)     DeleteCriticalSection(&m_MainCrSec);

    InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CPerformance::CloseDown(void)
{
    V_INAME(CPerformance::CloseDown);
    DWORD dwThreadID = GetCurrentThreadId();
    if( m_dwAudioPathMode )
    {
        // kill the transport thread
        m_fKillThread = 1;
        m_fKillRealtimeThread = 1;
        if (dwThreadID != m_dwTransportThreadID)
        {
            // signal the transport thread so we don't have to wait for it to wake up on its own
            if( m_hTransport ) SetEvent( m_hTransport );
            // wait until the transport thread quits
            WaitForSingleObject(m_hTransportThread, INFINITE);
        }
        if (dwThreadID != m_dwRealtimeThreadID)
        {
            // signal the realtime thread so we don't have to wait for it to wake up on its own
            if( m_hRealtime ) SetEvent( m_hRealtime );
            // wait until the realtime thread quits
            WaitForSingleObject(m_hRealtimeThread, INFINITE);
        }
    }

    if (m_pGraph) SetGraph(NULL); // shut down the graph and release it (needs to happen before clearing audio path)

    EnterCriticalSection(&m_SegmentCrSec);
    EnterCriticalSection(&m_RealtimeCrSec);

    m_fPlaying = FALSE; // prevents transport thread from doing anything more
    IDirectMusicPerformance* pPerf = NULL;
    if (SUCCEEDED(QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)))
    {
        CWavTrack::UnloadAllWaves(pPerf);
        pPerf->Release();
    }
    DequeueAllSegments();
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_dwAudioPathMode = 0;
    m_AudioPathList.Clear();
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        CNotificationItem* pNext = pItem->GetNext();
        m_NotificationList.Remove( pItem );
        delete pItem;
        pItem = pNext;
    }
    LeaveCriticalSection(&m_RealtimeCrSec);
    LeaveCriticalSection(&m_SegmentCrSec);

    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    while( pPMsg = m_EarlyQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NearTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OnTimeQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_OldTempoMap.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_NotificationQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }
    while( pPMsg = m_TimeSigQueue.Dequeue() )
    {
        FreePMsg(pPMsg);
    }

    LeaveCriticalSection(&m_PipelineCrSec);

    EnterCriticalSection(&m_GlobalDataCrSec);
    GlobalData* pGD = m_pGlobalData;
    while( pGD )
    {
        m_pGlobalData = pGD->pNext;
        delete pGD;
        pGD = m_pGlobalData;
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);

    EnterCriticalSection(&m_PChannelInfoCrSec);
    // clear out ports, buffers, and pchannel maps
    if( m_pPortTable )
    {
        DWORD dwIndex;
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pPort )
            {
                m_pPortTable[dwIndex].pPort->Release();
            }
            if( m_pPortTable[dwIndex].pBuffer )
            {
                m_pPortTable[dwIndex].pBuffer->Release();
            }
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
        }
        delete [] m_pPortTable;
        m_pPortTable = NULL;
        m_dwNumPorts = 0;
    }
    m_ChannelBlockList.Clear();
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock )
    {
        m_pClock->Release();
        m_pClock = NULL;
    }
    m_BufferManager.Clear();
    if( m_pDirectMusic )
    {
        m_pDirectMusic->Release();
        m_pDirectMusic = NULL;
    }
    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
    m_hNotification = NULL;
    LeaveCriticalSection(&m_MainCrSec);

    EnterCriticalSection(&m_PMsgCacheCrSec);
    for( int i = 0; i < (PERF_PMSG_CB_MAX - PERF_PMSG_CB_MIN); i++ )
    {
        while( m_apPMsgCache[i] )
        {
            PRIV_PMSG* pPriv = m_apPMsgCache[i];
            m_apPMsgCache[i] = pPriv->pNext;
            delete [] pPriv;
        }
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);

    DWORD dwExitCode = 0;
    if (m_hTransportThread)
    {
        CloseHandle( m_hTransportThread );
        m_hTransportThread = 0;
    }
    if( m_hTransport )
    {
        CloseHandle( m_hTransport );
        m_hTransport = 0;
    }
    if (m_hRealtimeThread)
    {
        CloseHandle( m_hRealtimeThread );
        m_hRealtimeThread = 0;
    }
    if( m_hRealtime )
    {
        CloseHandle( m_hRealtime );
        m_hRealtime = 0;
    }
    m_mtPlayTo = 0;
    return S_OK;
}

// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CPerformance::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CPerformance::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicPerformance)
    {
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicPerformance8*>(this);
    } else
    if (iid == IID_IDirectMusicPerformance2)
    {
        m_dwVersion = 7;
        *ppv = static_cast<IDirectMusicPerformance*>(this);
    } else
    if( iid == IID_IDirectMusicPerformanceStats )
    {
        *ppv = static_cast<IDirectMusicPerformanceStats*>(this);
    } else
    if( iid == IID_IDirectMusicSetParamHook )
    {
        *ppv = static_cast<IDirectMusicSetParamHook*>(this);
    } else
    if (iid == IID_IDirectMusicTool)
    {
        *ppv = static_cast<IDirectMusicTool*>(this);
    } else
    if (iid == IID_CPerformance)
    {
        *ppv = static_cast<CPerformance*>(this);
    }
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    }
    if (iid == IID_IDirectMusicPerformanceP)
    {
        *ppv = static_cast<IDirectMusicPerformanceP*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicPerformance,
                static_cast<IDirectMusicPerformance*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }
    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Performance object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | AddRef | Standard AddRef implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicPerformance | Release | Standard Release implementation for <i IDirectMusicPerformance>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CPerformance::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        DWORD dwThreadID = GetCurrentThreadId();
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        if (dwThreadID == m_dwTransportThreadID)
        {
            m_fReleasedInTransport = true;
            m_fKillThread = TRUE;
        }
        else if (dwThreadID == m_dwRealtimeThreadID)
        {
            m_fReleasedInRealtime = true;
            m_fKillRealtimeThread = TRUE;
        }
        else
        {
            delete this;
        }
        return 0;
    }

    return m_cRef;
}

// call this only from within a m_SegmentCrSec critical section
// if fSendNotify, then send segment end notifications for segments that were
// playing
void CPerformance::DequeueAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        while( pNode = m_SegStateQueues[dwCount].RemoveHead())
        {
            pNode->ShutDown();
        }
    }
    while( pNode = m_ShutDownQueue.RemoveHead())
    {
        pNode->ShutDown();
    }
}

// IDirectMusicPerformanceStats

STDMETHODIMP CPerformance::TraceAllSegments()
{
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            TraceI(0,"%x %ld: Playing: %ld, Start: %ld, Seek: %ld, LastPlayed: %ld\n",
                pNode,dwCount,pNode->m_fStartedPlay, pNode->m_mtResolvedStart,
                pNode->m_mtSeek, pNode->m_mtLastPlayed);
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::CreateSegstateList(DMUS_SEGSTATEDATA ** ppList)

{
    if (!ppList) return E_POINTER;
    CSegState *pNode;
    DWORD dwCount;
    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for ( pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode=pNode->GetNext())
        {
            DMUS_SEGSTATEDATA *pData = new DMUS_SEGSTATEDATA;
            if (pData)
            {
                CSegment *pSegment = pNode->m_pSegment;
                if (pSegment && (pSegment->m_dwValidData & DMUS_OBJ_NAME))
                {
                    StringCchCopyW(pData->wszName, DMUS_MAX_NAME, pSegment->m_wszName);
                }
                else
                {
                    pData->wszName[0] = 0;
                }
                pData->dwQueue = dwCount;
                pData->pSegState = (IDirectMusicSegmentState *) pNode;
                pNode->AddRef();
                pData->pNext = *ppList;
                pData->mtLoopEnd = pNode->m_mtLoopEnd;
                pData->mtLoopStart = pNode->m_mtLoopStart;
                pData->dwRepeats = pNode->m_dwRepeats;
                pData->dwPlayFlags = pNode->m_dwPlaySegFlags;
                pData->mtLength = pNode->m_mtLength;
                pData->rtGivenStart = pNode->m_rtGivenStart;
                pData->mtResolvedStart = pNode->m_mtResolvedStart;
                pData->mtOffset = pNode->m_mtOffset;
                pData->mtLastPlayed = pNode->m_mtLastPlayed;
                pData->mtPlayTo = pNode->m_mtStopTime;
                pData->mtSeek = pNode->m_mtSeek;
                pData->mtStartPoint = pNode->m_mtStartPoint;
                pData->dwRepeatsLeft = pNode->m_dwRepeatsLeft;
                pData->fStartedPlay = pNode->m_fStartedPlay;
                *ppList = pData;
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::FreeSegstateList(DMUS_SEGSTATEDATA * pList)

{
    DMUS_SEGSTATEDATA *pState;
    while (pList)
    {
        pState = pList;
        pList = pList->pNext;
        pState->pSegState->Release();
        delete pState;
    }
    return S_OK;
}

void CPerformance::SendBuffers()
{
    DWORD dwIndex;
    PortTable* pPortTable;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].fBufferFilled && m_pPortTable[dwIndex].pBuffer )
        {
            pPortTable = &m_pPortTable[dwIndex];
            pPortTable->fBufferFilled = FALSE;
            ASSERT( pPortTable->pBuffer );
            if( pPortTable->pPort )
            {
                pPortTable->pPort->PlayBuffer( pPortTable->pBuffer );
//  TraceI(5, "SENT BUFFERS time=%ld latency=%ld\n", (long)(GetTime() / 10000),(long)(GetLatency()/10000));
            }
            pPortTable->pBuffer->Flush();
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime SendBuffers %u\n", dwDebugTime);
    }
#endif
}

static DWORD WINAPI _Realtime(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->Realtime();
        ::CoUninitialize();
    }
    return 0;
}

void CPerformance::Realtime()
{
    while (!m_fKillRealtimeThread)
    {
        EnterCriticalSection(&m_RealtimeCrSec);
        PRIV_PMSG *pEvent;
        HRESULT hr;
        REFERENCE_TIME  rtFirst = 0;
        REFERENCE_TIME  rtEnter = GetLatencyWithPrePlay();
        DWORD   dwTestTime;
        DWORD   dwBeginTime = timeGetTime();
        DWORD   dwLimitLoop = 0;

        if( rtEnter > m_rtQueuePosition )
        {
            m_rtQueuePosition = rtEnter;
        }

        while (1)
        {
            // rtFirst equals the time that the first event was packed into a buffer.
            // Once this time is greater than the latency clock (minus a delay) we need
            // to queue the buffers so the events get down in time to be rendered.
            // If rtFirst is 0 it means it hasn't been initialized yet.
            dwTestTime = timeGetTime();
            if( dwTestTime - dwBeginTime > REALTIME_RES )
            {
                if( ++dwLimitLoop > 10 )
                {
                    TraceI(1,"Error! We've been in the realtime thread too long!!! Breaking out without completing.\n");
                    break;
                }
                SendBuffers();
                dwBeginTime = dwTestTime;
            }
            pEvent = GetNextPMsg();
            if( NULL == pEvent )
            {
                break;
            }
            ASSERT( pEvent->pNext == NULL );
            if( !pEvent->pTool )
            {
                // this event doesn't have a Tool pointer, so stamp it with the
                // final output Tool.
                pEvent->pTool = (IDirectMusicTool*)this;
                AddRef();
            }

            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
        SendBuffers();
        LeaveCriticalSection(&m_RealtimeCrSec);
        if( m_hRealtime )
        {
            WaitForSingleObject( m_hRealtime, REALTIME_RES );
        }
        else
        {
            Sleep(REALTIME_RES);
        }
    }
    m_fKillRealtimeThread = FALSE;
    TraceI(2, "dmperf: LEAVE realtime\n");
    if (m_fReleasedInRealtime)
    {
        delete this;
    }
}

void CPerformance::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime,
                                          IDirectMusicSegmentState* pSegSt)
{
    GUID guid;
    guid = GUID_NOTIFICATION_PERFORMANCE;
    if( FindNotification( guid ))
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG),
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_PERFORMANCE;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            if( pSegSt )
            {
                pSegSt->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);
            }
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                FreePMsg((DMUS_PMSG*)pEvent);
            }
        }
    }
}

void CPerformance::PrepSegToPlay(CSegState *pSegState, bool fQueue)

/*  Called when a segment is first queued, once the start time of the segment is known.
    This calculates various fields that need to be initialized and also regenerates the
    tempo map if the new segment has an active tempo map in it.
*/

{
    if (!pSegState->m_fPrepped)
    {
        pSegState->m_fPrepped = TRUE;
        pSegState->m_mtLastPlayed = pSegState->m_mtResolvedStart;
        // if this is queued to play after the current segment ends, no need to recalc the tempo map;
        // it will be updated as necessary by the transport thread.
        if (!fQueue)
        {
            RecalcTempoMap(pSegState, pSegState->m_mtResolvedStart);
        }
        MusicToReferenceTime(pSegState->m_mtLastPlayed,&pSegState->m_rtLastPlayed);
        // Calculate the total duration of the segment and store in m_mtEndTime.
        pSegState->m_mtEndTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart);
    }
}

/*

  void | CPerformance | PerformSegStNode |
  Perform a Segment State contained in the CSegState.

  Note that this ppSegStNode may be dequeued, so don't depend on it
  staying around!

*/
void CPerformance::PerformSegStNode(
    DWORD dwList,   // The list the segmentstate comes from.
    CSegState* pSegStNode)  // The segmentstate node.
{
    MUSIC_TIME mtMargin; // tracks how much of a segment to play
    HRESULT hr;
    CSegStateList *pList = &m_SegStateQueues[dwList];
    CSegState *pNext;

    if( !m_fPlaying || m_fInTrackPlay )
    {
        return;
    }
    if( pSegStNode )
    {
        m_fInTransportThread = TRUE;    // Disable realtime processing of early queue messages.
        hr = S_OK;
//Trace(0,"%ld: Performing %lx, Active: %ld, Start Time: %ld, End Time: %ld\n",m_mtPlayTo,
//      pSegStNode->m_pSegment,pSegStNode->m_fStartedPlay,pSegStNode->m_mtResolvedStart,pSegStNode->m_mtEndTime);
        if( !pSegStNode->m_fStartedPlay )
        {
            // check to see if this SegState should start playing.
            ASSERT( !(pSegStNode->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ));
            if( pSegStNode->m_mtResolvedStart < m_mtPlayTo )
            {
                pSegStNode->m_fStartedPlay = TRUE;
                PrepSegToPlay(pSegStNode);
                // send a MUSICSTARTED notification if needed
                if(m_fMusicStopped)
                {
                    m_fMusicStopped = FALSE;
                    GenerateNotification( DMUS_NOTIFICATION_MUSICSTARTED, pSegStNode->m_mtResolvedStart, NULL );
                }
                // We don't want the music to start with a big BLURP in track
                // order, so we send a little dribble out on each track.
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                if( mtMargin >= 50 )
                {
                    hr = pSegStNode->Play( 50 );
                    ProcessEarlyPMsgs();
                    // Once done processing all the early messages, make sure that the realtime
                    // thread wakes up and does whatever it needs to do. This ensures that the starting
                    // notes in a sequence get to the output port immediately.
                    if( m_hRealtime ) SetEvent( m_hRealtime );
                    mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
                    // Then, we send a larger chunk out on each track to catch up a little more...
                    if ((hr == S_OK) && ( mtMargin >= 200 ))
                    {
                        hr = pSegStNode->Play( 200 );
                        ProcessEarlyPMsgs();
                    }
                }
            }
            else
            {
                MusicToReferenceTime(pSegStNode->m_mtLastPlayed,&pSegStNode->m_rtLastPlayed);
            }
        }
        if( pSegStNode->m_fStartedPlay )
        {
            if( pSegStNode->m_mtStopTime && ( pSegStNode->m_mtStopTime < m_mtPlayTo ) )
            {
                mtMargin = pSegStNode->m_mtStopTime - pSegStNode->m_mtLastPlayed;
            }
            else
            {
                mtMargin = m_mtPlayTo - pSegStNode->m_mtLastPlayed;
            }
            while ((hr == S_OK) && (mtMargin > 0))
            {
                // Do not allow more than a quarter note's worth to be done at once.
                MUSIC_TIME mtRange = mtMargin;
                if (mtRange > DMUS_PPQ)
                {
                    mtRange = DMUS_PPQ;
                    mtMargin -= mtRange;
                }
                else
                {
                    mtMargin = 0;
                }
                hr = pSegStNode->Play( mtRange );
                ProcessEarlyPMsgs();
            }
        }
        if( (hr == DMUS_S_END) || ( pSegStNode->m_mtStopTime &&
                                  ( pSegStNode->m_mtStopTime <= pSegStNode->m_mtLastPlayed ) ) )
        {

            if( pSegStNode->m_mtStopTime && (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed) )
            {
                pSegStNode->AbortPlay(pSegStNode->m_mtStopTime - 1, FALSE);
            }
            MUSIC_TIME mtEnd = pSegStNode->m_mtLastPlayed;
            if( pList == &m_SegStateQueues[SQ_PRI_PLAY] )
            {
                // move primary segments to PriPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_PRI_DONE].Insert(pSegStNode);
                pNext = pList->GetHead();
                if( pNext )
                {
                    if (!( pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE ))
                    {
                        if (IsConQueue(dwList))
                        {
                            Invalidate( pNext->m_mtResolvedStart, 0 );
                        }
                    }
                }
                else    // No more primary segments, send DMUS_NOTIFICATION_MUSICALMOSTEND
                {
                    if (m_dwVersion >= 8)
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegStNode );
                    }
                }
                ManageControllingTracks();
            }
            else if ( pList == &m_SegStateQueues[SQ_CON_PLAY] )
            {
                pList->Remove(pSegStNode );
                if (pSegStNode->m_mtStopTime == pSegStNode->m_mtLastPlayed)
                {
                    m_ShutDownQueue.Insert(pSegStNode);
                }
                else
                {
                    m_SegStateQueues[SQ_CON_DONE].Insert(pSegStNode);
                }
            }
            else
            {
                // move 2ndary segments to SecPastList
                pList->Remove(pSegStNode);
                m_SegStateQueues[SQ_SEC_DONE].Insert(pSegStNode);
            }
            // if there aren't any more segments to play, send a Music Stopped
            // notification
            if( (m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
                m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
                m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty()))
            {
                m_fMusicStopped = TRUE;
                GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtEnd, NULL );
            }
        }
        m_fInTransportThread = FALSE;
    }
}

static DWORD WINAPI _Transport(LPVOID lpParam)
{
    if (SUCCEEDED(::CoInitialize(NULL)))
    {
        ((CPerformance *)lpParam)->Transport();
        ::CoUninitialize();
    }
    return 0;
}

// call Segment's play code on a periodic basis. This routine is in its
// own thread.
void CPerformance::Transport()
{
    srand((unsigned int)time(NULL));
    while (!m_fKillThread)
    {
        DWORD dwCount;
        CSegState*  pNode;
        CSegState*  pNext;
        CSegState*  pTempQueue = NULL;
        REFERENCE_TIME rtNow = GetTime();

        EnterCriticalSection(&m_SegmentCrSec);
        // Compute the time we should play all the segments to.
        REFERENCE_TIME rtPlayTo = rtNow + PREPARE_TIME;
        MUSIC_TIME mtAmount, mtResult, mtPlayTo;
        mtPlayTo = 0;
        ReferenceToMusicTime( rtPlayTo, &mtPlayTo );
        if (m_fTempoChanged)
        {
            // If there has been a tempo change to slower, any clock time tracks could
            // be delayed to long as the transport holds off sending out events. That's
            // okay for music time tracks, but bad news for clock time tracks. This
            // makes sure that the clock time tracks get a chance to spew.
            if (m_mtPlayTo >= mtPlayTo)
            {
                mtPlayTo = m_mtPlayTo + 10;
            }
            m_fTempoChanged = FALSE;
        }
        IncrementTempoMap();
        while (m_mtPlayTo < mtPlayTo)
        {
            BOOL fDirty = FALSE; // see below
            m_mtPlayTo = mtPlayTo; // Start out optimistic
            // We need to set play boundaries at the end of control segments.
            // The beginnings of control segments are handled inside the segment state code.
            pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
            if( pNode && pNode->m_fStartedPlay )
            {
                mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                pNode->CheckPlay( mtAmount, &mtResult );
                if( mtResult < mtAmount )
                {
                    m_mtPlayTo -= ( mtAmount - mtResult );
                    // don't need dirty flag when primary segment loops or ends normally (bug 30829)
                    // fDirty = TRUE; // see below
                }
            }
            // if a control segment ended prematurely, mtPlayTo will have a value besides 0
            // check for upcoming endings to control segments
            for( pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_fStartedPlay )
                {
                    if( pNode->m_mtStopTime && (m_mtPlayTo > pNode->m_mtStopTime) )
                    {
                        m_mtPlayTo = pNode->m_mtStopTime;
                        fDirty = TRUE; // see below
                    }
                    else
                    {
                        mtAmount = m_mtPlayTo - pNode->m_mtLastPlayed;
                        pNode->CheckPlay( mtAmount, &mtResult );
                        if( mtResult < mtAmount )
                        {
                            m_mtPlayTo -= ( mtAmount - mtResult );
                            fDirty = TRUE; // see below
                        }
                    }
                }
            }
            // play the primary segment
            PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
            // check to see if the next primary segment in the queue is ready to play
            while( (pNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead()) &&
                (pNext = pNode->GetNext()) &&
                ( pNext->m_mtResolvedStart <= pNode->m_mtLastPlayed ) )
            {
                // the next primary segment is indeed ready to begin playing.
                // save the old one in the primary past list so Tools can reference
                // it if they're looking for chord progressions and such.
                pNode->AbortPlay(pNext->m_mtResolvedStart-1,TRUE && (pNext->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                ManageControllingTracks();
                // we need to flush primary events after the new start time
                if(!( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                {
                    Invalidate( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart, 0 );
                }
                // and play the new segment
                PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead());
            }
            // play the controlling segments
            pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            pNext = NULL;
            for(; pNode != NULL; pNode = pNext)
            {
                pNext = pNode->GetNext();
                PerformSegStNode(SQ_CON_PLAY,pNode );
            }
            // play the secondary segments
            pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
            pNext = NULL;
            for(; pNode != NULL; pNode = pNext)
            {
                pNext = pNode->GetNext();
                PerformSegStNode( SQ_SEC_PLAY,pNode );
            }

            // if we set fDirty above, it means that we truncated the playback of a control
            // segment because of a loop or end condition. Therefore, we want all segments
            // to set the DMUS_TRACKF_DIRTY flag on the next play cycle.
            if( fDirty )
            {
                for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if( pNode->m_fStartedPlay )
                        {
                            pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                        }
                    }
                }
                ManageControllingTracks();
            }
            m_mtTransported = m_mtPlayTo;

        }

        // check segments queued in ref-time to see if it's time for them to
        // play. Add some extra time just in case. We'll bet that a tempo pmsg won't come
        // in in the intervening 200 ms.
        REFERENCE_TIME rtLatency = GetLatencyWithPrePlay();
        for (dwCount = SQ_PRI_WAIT;dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            while( m_SegStateQueues[dwCount].GetHead() )
            {
                if( m_SegStateQueues[dwCount].GetHead()->m_rtGivenStart > rtLatency + PREPARE_TIME + (200 * REF_PER_MIL) )
                {
                    // it's not yet time to handle this one
                    break;
                }
                if (dwCount == SQ_PRI_WAIT)
                {
                    QueuePrimarySegment( m_SegStateQueues[SQ_PRI_WAIT].RemoveHead());
                }
                else
                {
                    QueueSecondarySegment( m_SegStateQueues[dwCount].RemoveHead());
                }
            }
        }

        // Check to see if Segments in the done queues
        // can be released. They can be released if their
        // final play times are older than the current time.
        for (dwCount = SQ_PRI_DONE;dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for (pNode = m_SegStateQueues[dwCount].GetHead();pNode;pNode = pNext)
            {
                pNext = pNode->GetNext();
                if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
                {
                    m_SegStateQueues[dwCount].Remove(pNode);
                    pNode->ShutDown();
                }
            }
        }
        for (pNode = m_ShutDownQueue.GetHead();pNode;pNode = pNext)
        {
            pNext = pNode->GetNext();
            if( pNode->m_rtLastPlayed < rtNow - 1000 * REF_PER_MIL ) // Let it last an additional second
            {
                m_ShutDownQueue.Remove(pNode);
                pNode->ShutDown();
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);

        // check to see if there are old notifications that haven't been
        // retrieved by the application and need to be removed.
        EnterCriticalSection(&m_PipelineCrSec);
        while( m_NotificationQueue.GetHead() )
        {
            if( m_NotificationQueue.GetHead()->rtTime <
                (rtNow - m_rtNotificationDiscard) )
            {
                FreePMsg(m_NotificationQueue.Dequeue());
            }
            else
            {
                break;
            }
        }
        LeaveCriticalSection(&m_PipelineCrSec);
        if( m_hTransport )
        {
            WaitForSingleObject( m_hTransport, TRANSPORT_RES );
        }
        else
        {
            Sleep(TRANSPORT_RES);
        }
    }
    m_fKillThread = FALSE;
    if (m_fReleasedInTransport)
    {
        delete this;
    }
}

//////////////////////////////////////////////////////////////////////
// CPerformance::GetNextPMsg
/*
HRESULT | CPerformance | GetNextPMsg |
Returns messages from the queues in priority order.  Any message in the
OnTime queue that is scheduled to be played at the current time is
returned above any other.  Secondly, any message in the NearTime queue
that is scheduled to be played within the next NEARTIME ms is returned.
Lastly, any message in the Early queue is returned.

rvalue PRIV_PMSG* | The message, or NULL if there are no messages.
*/
inline PRIV_PMSG *CPerformance::GetNextPMsg()
{
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    PRIV_PMSG* pEvent = NULL;

    EnterCriticalSection(&m_PipelineCrSec);
    if (m_OnTimeQueue.GetHead())
    {
        ASSERT( m_OnTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
        if ( m_OnTimeQueue.GetHead()->rtTime - GetTime() <= 0 )
        {
            pEvent = m_OnTimeQueue.Dequeue();
        }
    }
    if( !pEvent )
    {
        if (m_NearTimeQueue.GetHead())
        {
            ASSERT( m_NearTimeQueue.GetHead()->dwFlags & DMUS_PMSGF_REFTIME );
            if ( m_NearTimeQueue.GetHead()->rtTime < (m_rtQueuePosition + (m_rtBumperLength >> 1)))
            {
                pEvent = m_NearTimeQueue.Dequeue();
            }
        }
        if( !pEvent && !m_fInTransportThread)
        {
            if (m_EarlyQueue.GetHead())
            {
                pEvent = m_EarlyQueue.Dequeue();
            }
        }
    }
    LeaveCriticalSection(&m_PipelineCrSec);
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetNextPMsg %u\n", dwDebugTime);
    }
#endif

    return pEvent;
}

/*  This next function is used just by the transport thread
    which can process messages in the early queue, but not
    the other types. This allows all the tools that process
    events right after they are generated by tracks to process
    the events right after they were generated, and in sequential
    order. This allows them to take a little longer, since it's
    not as time critical, and it's much more likely to ensure
    that they are in sequential order. If the realtime thread were
    allowed to process these, it would preempt and process them
    as soon as generated, so they would be processed in the order
    of the tracks. The m_fInTransportThread is set by the
    transport thread when it is generating and processing events
    and this disallows the realtime thread from processing
    early events (but not others.) At other times, the realtime
    thread is welcome to process early events.
*/

void CPerformance::ProcessEarlyPMsgs()
{
    PRIV_PMSG* pEvent;

    //  Exit if the thread is exiting.  If we don't test here
    //  we can actually loop forever because tools and queue more
    //  early PMSGs (the Echo tool does this)
    while (!m_fKillThread)
    {
        EnterCriticalSection(&m_PipelineCrSec);
        pEvent = m_EarlyQueue.Dequeue();
        LeaveCriticalSection(&m_PipelineCrSec);
        if (!pEvent) break; // Done?
        ASSERT( pEvent->pNext == NULL );
        if( !pEvent->pTool )
        {
            // this event doesn't have a Tool pointer, so stamp it with the
            // final output Tool.
            pEvent->pTool = (IDirectMusicTool*)this;
            AddRef();
            // Don't process it. Instead, send to neartime queue so
            // realtime thread will deal with it.
            pEvent->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
            pEvent->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            SendPMsg( PRIV_TO_DMUS(pEvent) );
        }
        else
        {
            // before processing the event, set rtLast to the event's current time
            pEvent->rtLast = pEvent->rtTime;

            HRESULT hr = pEvent->pTool->ProcessPMsg( this, PRIV_TO_DMUS(pEvent) );
            if( hr != S_OK ) // S_OK means do nothing
            {
                if( hr == DMUS_S_REQUEUE )
                {
                    if(FAILED(SendPMsg( PRIV_TO_DMUS(pEvent) )))
                    {
                        FreePMsg(pEvent);
                    }
                }
                else // e.g. DMUS_S_FREE or error code
                {
                    FreePMsg( pEvent );
                }
            }
        }
    }
}

REFERENCE_TIME CPerformance::GetTime()
{
    REFERENCE_TIME rtTime;
    REFERENCE_TIME rtCurrent = 0;
    WORD    w;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_MainCrSec);
    if (m_pClock) hr = m_pClock->GetTime( &rtCurrent );
    if( !m_pClock || FAILED( hr ) || rtCurrent == 0 )
    {
        // this only gets called with machines that don't support m_pClock
        rtTime = timeGetTime();
        rtCurrent = rtTime * REF_PER_MIL; // 100 ns increments
        // take care of timeGetTime rolling over every 49 days
        if( rtCurrent < 0 )
        {
            m_wRollOverCount++;
        }
        for( w = 0; w < m_wRollOverCount; w++ )
        {
            rtCurrent += 4294967296;
        }
        // if rtCurrent is negative, it means we've rolled over rtCurrent. Ignore
        // this case for now, as it will be quite uncommon.
    }
    LeaveCriticalSection(&m_MainCrSec);

    return rtCurrent;
}

REFERENCE_TIME CPerformance::GetLatency(void)
{
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;

#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( m_pPortTable )
    {
        for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetTime();
    }
#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    if( dwDebugTime > 1 )
    {
        TraceI(5, "Hall, debugtime GetLatency %u\n", dwDebugTime);
    }
#endif
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return rtLatency;
}

// return the most desireable Segment latency, based on which ports this
// segment plays on.
REFERENCE_TIME CPerformance::GetBestSegLatency( CSegState* pSeg )
{
    // If we're using audiopaths, the code below doesn't work because it doesn't
    // take converting pchannels into account. So, just use the worse case
    // latency. 99% of the time, there is only one port, so this results
    // in just a performance enhancement.
    if (m_dwAudioPathMode == 2)
    {
        return GetLatency();
    }
    DWORD dwIndex;
    REFERENCE_TIME rtLatency = 0;
    REFERENCE_TIME rtTemp;
    BOOL* pafIndexUsed = NULL;
    DWORD dwCount;

    if( m_dwNumPorts == 1 )
    {
        return GetLatency();
    }
    pafIndexUsed = new BOOL[m_dwNumPorts];
    if( NULL == pafIndexUsed )
    {
        return GetLatency();
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        pafIndexUsed[dwCount] = FALSE;
    }
    DWORD dwNumPChannels, dwGroup, dwMChannel;
    DWORD* paPChannels;
    pSeg->m_pSegment->GetPChannels( &dwNumPChannels, &paPChannels );
    for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
    {
        if( SUCCEEDED( PChannelIndex( paPChannels[dwCount],
            &dwIndex, &dwGroup, &dwMChannel )))
        {
            pafIndexUsed[dwIndex] = TRUE;
        }
    }
    for( dwCount = 0; dwCount < m_dwNumPorts; dwCount++ )
    {
        if( pafIndexUsed[dwCount] )
            break;
    }
    if( dwCount >= m_dwNumPorts )
    {
        delete [] pafIndexUsed;
        return GetLatency();
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( pafIndexUsed[dwIndex] )
        {
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                {
                    if( rtTemp > rtLatency )
                        rtLatency = rtTemp;
                }
            }
            else if( m_pPortTable[dwIndex].pPort )
            {
                if( SUCCEEDED( m_pPortTable[dwIndex].pPort->GetLatencyClock( &m_pPortTable[dwIndex].pLatencyClock )))
                {
                    if( SUCCEEDED( m_pPortTable[dwIndex].pLatencyClock->GetTime( &rtTemp )))
                    {
                        if( rtTemp > rtLatency )
                            rtLatency = rtTemp;
                    }
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( 0 == rtLatency )
    {
        rtLatency = GetLatency();
    }
    delete [] pafIndexUsed;
    return rtLatency;
}

/*  Called from either QueuePrimarySegment or QueueSecondarySegment,
    this calculates the appropriate boundary time to start the segment
    playback. Most of the logic takes care of the new DMUS_SEGF_ALIGN
    capabilities.
*/


void CPerformance::CalculateSegmentStartTime( CSegState* pSeg )
{
    BOOL fNoValidStart = TRUE;
    if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_ALIGN)
    {
        // If the ALIGN flag is set, see if we can align with the requested resolution,
        // but switch to the new segment at an earlier point, as defined by
        // a "valid start" point in the new segment.
        DMUS_VALID_START_PARAM ValidStart;    // Used to read start parameter from segment.
        MUSIC_TIME mtIntervalSize = 0;      // Quantization value.
        MUSIC_TIME mtTimeNow = (MUSIC_TIME)pSeg->m_rtGivenStart; // The earliest time this can start.
        // Call resolve time to get the last quantized interval that precedes mtTimeNow.
        MUSIC_TIME mtStartTime = ResolveTime( mtTimeNow, pSeg->m_dwPlaySegFlags, &mtIntervalSize );
        // StartTime actually shows the next time after now, so subtract the interval time to get the previous position.
        mtStartTime -= mtIntervalSize;
        // If the segment was supposed to start after the very beginning, quantize it.
        if (mtIntervalSize && pSeg->m_mtStartPoint)
        {
            pSeg->m_mtStartPoint = ((pSeg->m_mtStartPoint + (mtIntervalSize >> 1))
                / mtIntervalSize) * mtIntervalSize;
            // If this ends up being longer than the segment, do we need to drop back?
        }
        // Now, get the next start point after the point in the segment that
        // corresponds with mtTimeNow, adjusted for the startpoint.
        if (SUCCEEDED(pSeg->m_pSegment->GetParam( GUID_Valid_Start_Time,-1,0,
            pSeg->m_mtStartPoint + mtTimeNow - mtStartTime,NULL,(void *) &ValidStart)))
        {
            // If the valid start point is within the range, we can cut in at the start point.
            if ((mtTimeNow - mtStartTime + ValidStart.mtTime) < (mtIntervalSize + pSeg->m_mtStartPoint))
            {
                pSeg->m_mtResolvedStart = mtTimeNow + ValidStart.mtTime;
                pSeg->m_mtStartPoint += mtTimeNow - mtStartTime + ValidStart.mtTime;
                fNoValidStart = FALSE;
            }
        }
        if (fNoValidStart)
        {
            // Couldn't find a valid start point. Was DMUS_SEGF_VALID_START_XXX set so we can override?
            if (pSeg->m_dwPlaySegFlags &
                (DMUS_SEGF_VALID_START_MEASURE | DMUS_SEGF_VALID_START_BEAT | DMUS_SEGF_VALID_START_GRID | DMUS_SEGF_VALID_START_TICK))
            {
                MUSIC_TIME mtOverrideTime;
                // Depending on the flag, we need to get the appropriate interval resolution.
                if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_MEASURE)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_MEASURE, 0 );
                }
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_BEAT)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_BEAT, 0 );
                }
                else if (pSeg->m_dwPlaySegFlags & DMUS_SEGF_VALID_START_GRID)
                {
                    mtOverrideTime = ResolveTime( mtTimeNow, DMUS_SEGF_GRID, 0 );
                }
                else
                {
                    mtOverrideTime = mtTimeNow;
                }
                // If the valid start point is within the range, we can cut in at the start point.
                if ((mtOverrideTime - mtTimeNow) < (mtIntervalSize + pSeg->m_mtStartPoint))
                {
                    pSeg->m_mtResolvedStart = mtOverrideTime;
                    if ((mtOverrideTime - mtStartTime) >= mtIntervalSize)
                    {
                        mtOverrideTime -= mtIntervalSize;
                    }
/*Trace(0,"Startpoint %ld plus OverrideTime %ld - StartTime %ld = %ld\n",
      pSeg->m_mtStartPoint, mtOverrideTime - mtSegmentTime, mtStartTime - mtSegmentTime,
        pSeg->m_mtStartPoint + mtOverrideTime - mtStartTime);*/
                    pSeg->m_mtStartPoint += mtOverrideTime - mtStartTime;
                    fNoValidStart = FALSE;
                }
            }
        }
    }
    if (fNoValidStart)
    {
        pSeg->m_mtResolvedStart = ResolveTime( (MUSIC_TIME)pSeg->m_rtGivenStart,
            pSeg->m_dwPlaySegFlags, NULL );
    }
    else
    {
        // If we succeeded in finding a place to switch over, make sure it isn't deep inside
        // a loop. This is specifically a problem when syncing to segment and switching inside
        // or after a loop.
        while (pSeg->m_dwRepeats && (pSeg->m_mtStartPoint >= pSeg->m_mtLoopEnd))
        {
            pSeg->m_dwRepeats--;
            pSeg->m_mtStartPoint -= (pSeg->m_mtLoopEnd - pSeg->m_mtLoopStart);
        }
        // Since we were decrementing the repeats, we need to also decrement the repeats left.
        pSeg->m_dwRepeatsLeft = pSeg->m_dwRepeats;
        // Finally, if the startpoint is after the end of the segment, cut it back to the end of the
        // segment. This will cause it to play for time 0 and, if this is a transition segment, whatever
        // should play after will play immediately.
        if (pSeg->m_mtStartPoint > pSeg->m_mtLength)
        {
            pSeg->m_mtStartPoint = pSeg->m_mtLength;
        }
    }
    pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
    pSeg->m_mtLastPlayed = pSeg->m_mtResolvedStart;
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueuePrimarySegment( CSegState* pSeg )
{
    CSegState* pTemp;
    BOOL fInCrSec = TRUE;
    BOOL fNotDone = TRUE;
    EnterCriticalSection(&m_PipelineCrSec);
    pSeg->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_QUEUE )
    {
        MUSIC_TIME mtStart = 0;

        pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetTail();
        if( pTemp )
        {
            mtStart = pTemp->GetEndTime( pTemp->m_mtResolvedStart );
        }
        else
        {
            pTemp = m_SegStateQueues[SQ_PRI_DONE].GetTail();
            if( pTemp )
            {
                mtStart = pTemp->m_mtLastPlayed;
            }
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE;
        if( NULL == pTemp )
        {
            // if there's nothing in the queue, this means play it now
            if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
            {
                // we want to queue this at the last transported time,
                // so we don't need to do an invalidate
                if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
                {
                    REFERENCE_TIME rtTrans;
                    MusicToReferenceTime( m_mtTransported, &rtTrans );
                    if( pSeg->m_rtGivenStart < rtTrans )
                    {
                        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
                else
                {
                    if( pSeg->m_rtGivenStart < m_mtTransported )
                    {
                        pSeg->m_rtGivenStart = m_mtTransported;
                    }
                }
            }
            else
            {
                // This will be changed to Queue time below
                pSeg->m_rtGivenStart = 0;
            }
        }
        else
        {
            REFERENCE_TIME rtQueue;

            // otherwise, time stamp it with the time corresponding to
            // the end time of all segments currently in the queue.
            pSeg->m_mtResolvedStart = mtStart;
            // make sure the resolved start time isn't before the latency
            GetQueueTime(&rtQueue);
            ReferenceToMusicTime( rtQueue, &mtStart );
            if( pSeg->m_mtResolvedStart < mtStart )
            {
                pSeg->m_mtResolvedStart = 0; // below code will take care of this case
            }
            else
            {
                pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSeg->m_mtOffset = pSeg->m_mtResolvedStart;
                m_SegStateQueues[SQ_PRI_PLAY].Insert(pSeg);
                TraceI(2, "dmperf: queueing primary seg/DMUS_SEGF_QUEUE. Prev time=%ld, this=%ld\n",
                    pTemp->m_mtResolvedStart, pSeg->m_mtResolvedStart);
                fNotDone = FALSE;
                PrepSegToPlay(pSeg, true);
            }
        }
    }
    if( fNotDone && (pSeg->m_rtGivenStart == 0) )
    {
        // if the given start time is 0, it means play now.
        MUSIC_TIME mtStart;
        REFERENCE_TIME rtStart;

        GetQueueTime( &rtStart );
        ReferenceToMusicTime( rtStart, &mtStart );
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
        // we definitely want to get rid of all segments following
        // the currently playing segment
        if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            while( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead()->GetNext() )
            {
                m_SegStateQueues[SQ_PRI_PLAY].Remove(pTemp);
                pTemp->AbortPlay(mtStart,FALSE);
                m_ShutDownQueue.Insert(pTemp);
            }
        }
    }
    if( fNotDone && pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units.
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow = m_rtQueuePosition;
        MUSIC_TIME mtTime;
        if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() || ( pSeg->m_rtGivenStart <= rtNow ) )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_PRI_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }
    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded. Also, segments that are in
        // the wait queue as RefTime are discarded.

        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        while( (pTemp = m_SegStateQueues[SQ_PRI_WAIT].RemoveHead()) )
        {
            pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
            m_ShutDownQueue.Insert(pTemp);
        }
        if( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
        {
            if( pSeg->m_mtResolvedStart > pTemp->m_mtResolvedStart )
            {
                while( pTemp->GetNext() )
                {
                    if( pTemp->GetNext()->m_mtResolvedStart >= pSeg->m_mtResolvedStart )
                    {
                        break;
                    }
                    pTemp = pTemp->GetNext();
                }
                pSeg->SetNext(pTemp->GetNext());
                pTemp->SetNext(pSeg);
                while( pTemp = pSeg->GetNext() )
                {
                    // delete the remaining pSegs after this one
                    pSeg->SetNext(pTemp->GetNext());
                    pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                    m_ShutDownQueue.Insert(pTemp);
                }
            }
            else
            {
                if( !pTemp->m_fStartedPlay )
                {
                    // blow away the entire queue
                    while( m_SegStateQueues[SQ_PRI_PLAY].GetHead() )
                    {
                        pTemp = m_SegStateQueues[SQ_PRI_PLAY].RemoveHead();
                        pTemp->AbortPlay(pSeg->m_mtResolvedStart,FALSE);
                        m_ShutDownQueue.Insert(pTemp);
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    // give this a chance to start performing if it's near
                    // enough to time
                    if( fInCrSec )
                    {
                        LeaveCriticalSection(&m_PipelineCrSec);
                        fInCrSec = FALSE;
                    }
                    SyncTimeSig( pSeg );
                    ManageControllingTracks();
                    PerformSegStNode( SQ_PRI_PLAY,pSeg);
                }
                else
                {
                    // else, place this segment after the current one
                    // and count on the routine below to take care of dequeing
                    // the current one, because in this case m_mtLastPlayed
                    // must be greater than m_mtResolvedStart.
                    if ( m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtLastPlayed <=
                        m_SegStateQueues[SQ_PRI_PLAY].GetHead()->m_mtResolvedStart )
                    {
                        TraceI(0,"Current Primary segment has not started playing.\n");
                    }
                    m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
                    MUSIC_TIME mtTime = pSeg->m_mtResolvedStart;
                    while( pTemp = pSeg->GetNext() )
                    {
                        pTemp->AbortPlay( mtTime, TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) );
                        // delete the remaining pSegs after this one
                        pSeg->SetNext(pTemp->GetNext());
                        m_ShutDownQueue.Insert(pTemp);
                    }
                }
            }
            // m_pPriSegQueue could have become NULL from the PerformSegStNode call above.
            if( m_SegStateQueues[SQ_PRI_PLAY].GetHead() && (pSeg != m_SegStateQueues[SQ_PRI_PLAY].GetHead()) )
            {
                CSegState *pCurrentSeg = m_SegStateQueues[SQ_PRI_PLAY].GetHead();
                if( pCurrentSeg->m_fStartedPlay &&
                    ( pSeg->m_mtResolvedStart <= pCurrentSeg->m_mtLastPlayed ))
                {
                    // If Playsegment is recursively called by the end of a previous segment in a song, don't abort.
                    if (!pCurrentSeg->m_fInPlay || !pCurrentSeg->m_fSongMode)
                    {
                        // the new segment wants to play on top of stuff that's
                        // already been transported by the current primary segment.
                        pCurrentSeg->AbortPlay(pSeg->m_mtResolvedStart-1,TRUE && (pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE));
                        m_SegStateQueues[SQ_PRI_DONE].Insert(m_SegStateQueues[SQ_PRI_PLAY].RemoveHead());
                        // make sure none of the last played times in the past list
                        // are past the resolved start
                        for( CSegState* pSegTemp = m_SegStateQueues[SQ_PRI_DONE].GetHead();
                            pSegTemp; pSegTemp = pSegTemp->GetNext() )
                        {
                            if( pSegTemp->m_mtLastPlayed > pSeg->m_mtResolvedStart )
                            {
                                pSegTemp->m_mtLastPlayed = pSeg->m_mtResolvedStart;
                            }
                        }
                        if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ) )
                        {
                            // if we set the PREPARE flag it means we specifically
                            // don't want to invalidate
                            Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                        }
                        else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                                 !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                        {
                            pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                        }
                        ASSERT( m_SegStateQueues[SQ_PRI_PLAY].GetHead() == pSeg ); // this should be the case
                        if( fInCrSec )
                        {
                            LeaveCriticalSection(&m_PipelineCrSec);
                            fInCrSec = FALSE;
                        }
                        SyncTimeSig( pSeg );
                        ManageControllingTracks();
                        PerformSegStNode( SQ_PRI_PLAY,m_SegStateQueues[SQ_PRI_PLAY].GetHead() );
                    }
                }
                else
                {
                    if( !( pSeg->m_dwPlaySegFlags & (DMUS_SEGF_NOINVALIDATE | DMUS_SEGF_INVALIDATE_PRI) ))
                    {
                        Invalidate( pSeg->m_mtResolvedStart, pSeg->m_dwPlaySegFlags );
                    }
                    else if ( (pSeg->m_dwPlaySegFlags & DMUS_SEGF_INVALIDATE_PRI) &&
                             !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
                    {
                        pCurrentSeg->Flush(pSeg->m_mtResolvedStart);
                    }
                }
            }
        }
        else
        {
            m_SegStateQueues[SQ_PRI_PLAY].AddHead(pSeg);
            // give this a chance to start performing if it's near
            // enough to time
            if( fInCrSec )
            {
                LeaveCriticalSection(&m_PipelineCrSec);
                fInCrSec = FALSE;
            }
            //DWORD dwDebugTime = timeGetTime();
            SyncTimeSig( pSeg );
            //DWORD dwDebugTime2 = timeGetTime();
            //Trace(0, "perf, debugtime SyncTimeSig %u\n", dwDebugTime2 - dwDebugTime);

            ManageControllingTracks();
            //dwDebugTime = timeGetTime();
            //Trace(0, "perf, debugtime ManageControllingTracks %u\n", dwDebugTime - dwDebugTime2);

            PerformSegStNode( SQ_PRI_PLAY,pSeg );
            //dwDebugTime2 = timeGetTime();
            //Trace(0, "perf, debugtime PerformSegStNode %u\n", dwDebugTime2 - dwDebugTime);
        }
    }
    if( fInCrSec )
    {
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

// this function should only be called from within a SegmentCrSec
// critical section!
void CPerformance::QueueSecondarySegment( CSegState* pSeg)
{
    BOOL fInCrSec = FALSE;
    BOOL fNotDone = TRUE;

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
    {
        EnterCriticalSection(&m_PipelineCrSec);
        fInCrSec = TRUE;
    }
    pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_QUEUE; // not legal for 2ndary segs.
    if( pSeg->m_rtGivenStart == 0 )
    {
        MUSIC_TIME mtStart;

        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            REFERENCE_TIME rtStart;
            GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
            ReferenceToMusicTime( rtStart, &mtStart );
        }
        else
        {
            ReferenceToMusicTime( GetBestSegLatency(pSeg), &mtStart );
        }
        pSeg->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
        pSeg->m_rtGivenStart = mtStart;
    }

    if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
    {
        // rtStartTime is in RefTime units.
        // We can convert this to Music Time immediately if either there
        // is no currently playing Primary Segment, or the conversion
        // falls within the time that has already played. If the time
        // falls within PREPARE_TIME, we need to get this Segment
        // playing right away.
        REFERENCE_TIME rtNow;
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            GetQueueTime( &rtNow ); // need queue time because control segments cause invalidations
        }
        else
        {
            rtNow = GetBestSegLatency(pSeg);
        }
        MUSIC_TIME mtTime;
        if( pSeg->m_rtGivenStart <= rtNow )
        {
            ReferenceToMusicTime( rtNow, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
            // let the block of code below that handles music time
            // deal with it from here on
        }
        else if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() )
        {
            ReferenceToMusicTime( pSeg->m_rtGivenStart, &mtTime );
            pSeg->m_dwPlaySegFlags &= ~( DMUS_SEGF_REFTIME );
            pSeg->m_rtGivenStart = mtTime;
        }
        else
        {
            // Otherwise, we must wait until rtStartTime
            // has been performed in order to convert to music time, because
            // we require the tempo map at that time to do the conversion.
            // This will be handled by the Transport code.
            m_SegStateQueues[SQ_SEC_WAIT].Insert(pSeg);
            fNotDone = FALSE; // prevents the next block of code from operating on
                        // this Segment.
        }
    }

    if( fNotDone ) // music time
    {
        // if we're in music time units, we can queue this segment in the
        // main queue, in time order. If this segment's music time is less
        // than the start time of other segments in the queue, all of those
        // segments are removed and discarded.
        ASSERT( !(pSeg->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )); // m_m_rtGivenStart must be in music time
        CalculateSegmentStartTime( pSeg );
        TraceI(2,"Queuing 2ndary seg time %ld\n",pSeg->m_mtResolvedStart);
        if( pSeg->m_dwPlaySegFlags & DMUS_SEGF_CONTROL)
        {
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSeg );
            // If this is a control segment, we need to do an invalidate.
            if(!(pSeg->m_dwPlaySegFlags & DMUS_SEGF_NOINVALIDATE) )
            {
                ManageControllingTracks();
                Invalidate( pSeg->m_mtResolvedStart, 0 );
            }
        }
        else
        {
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSeg );
        }
        // give this a chance to start performing if it's near
        // enough to time
        if( fInCrSec )
        {
            LeaveCriticalSection(&m_PipelineCrSec);
            fInCrSec = FALSE;
        }
        // play the secondary segments
        CSegState *pNode = m_SegStateQueues[SQ_SEC_PLAY].GetHead();
        CSegState *pNext;
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_SEC_PLAY,pNode );
        }
        // play the controlling segments
        pNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
        for(; pNode != NULL; pNode = pNext)
        {
            pNext = pNode->GetNext();
            PerformSegStNode( SQ_CON_PLAY,pNode );
        }
    }
    if( fInCrSec )
    {
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

/*  If a segment is controlling, this establishes which tracks in the currently playing
    primary segment are disabled.
    We store temporary information in each playing track's m_dwInternalFlags, which is not used
    otherwise in segmentstates.

    Four scenarios, each for play and notify:
    1) An officially enabled track is currently enabled and gets disabled.
    2) An officially enabled track is currently disabled and continues to be disabled.
    3) An officially enabled track is currently disabled and gets enabled.
    4) An officially disabled track is left disabled. If none of the CONTROL_ flags are set and the track is disabled,
       set the _WAS_DISABLED flag, which also indicates that this should be left alone.

    This should get called every time a primary or secondary segment starts or stop, so it
    can recalculate the behavior of all tracks in the primary segment.
*/

void CPerformance::ManageControllingTracks()

{
    EnterCriticalSection(&m_SegmentCrSec);
    CSegState* pSegNode;
    // First, prepare all tracks in the primary segment, putting them back to normal.
    // so they are ready to be reset by the controlling tracks.
    // To do this, check for WAS_ENABLED or WAS_DISABLED and set the appropriate flags in m_dwFlags.
    // Else, if these weren't set, then it's time to set them, since this is the first pass through this segment.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        EnterCriticalSection(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwInternalFlags) // This has been touched before.
            {
                // First transfer and reset the is disabled flags.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_PLAY_WAS_DISABLED;
                }
                pTrack->m_dwInternalFlags &= ~(CONTROL_PLAY_IS_DISABLED | CONTROL_NTFY_IS_DISABLED);
                // Then, set the play flags based on the original state.
                if (pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_PLAY_ENABLED;
                }
                if (pTrack->m_dwInternalFlags & CONTROL_NTFY_DEFAULT_ENABLED)
                {
                    pTrack->m_dwFlags |= DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                }
            }
            else
            {
                // Since this has never been touched before, set the flags so we can know what to return to.
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED)
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags = CONTROL_PLAY_DEFAULT_DISABLED;
                }
                if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED)
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_ENABLED;
                }
                else
                {
                    pTrack->m_dwInternalFlags |= CONTROL_NTFY_DEFAULT_DISABLED;
                }
            }
        }
        LeaveCriticalSection(&pSegNode->m_CriticalSection);
    }
    CSegState* pControlNode;
    // Now, go through all the controlling segments and, for each controlling track that matches
    // a primary segment track, clear the enable flags on the segment track.
    for( pControlNode = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pControlNode; pControlNode = pControlNode->GetNext() )
    {
        EnterCriticalSection(&pControlNode->m_CriticalSection);
        CTrack *pTrack = pControlNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            // If the track has never been overridden, the internal flags for IS_DISABLED should be clear.
            // If the track is currently overridden, the internal flags should be CONTROL_PLAY_IS_DISABLED and/or
            // CONTROL_NTFY_IS_DISABLED
            if (pTrack->m_dwFlags & (DMUS_TRACKCONFIG_CONTROL_PLAY | DMUS_TRACKCONFIG_CONTROL_NOTIFICATION)) // This overrides playback and/or notification.
            {
                for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
                {
                    EnterCriticalSection(&pSegNode->m_CriticalSection);
                    CTrack *pPrimaryTrack = pSegNode->m_TrackList.GetHead();
                    for (;pPrimaryTrack;pPrimaryTrack = pPrimaryTrack->GetNext())
                    {
                        // A track matches if it has the same class id and overlapping group bits.
                        if ((pPrimaryTrack->m_guidClassID == pTrack->m_guidClassID) &&
                            (pPrimaryTrack->m_dwGroupBits & pTrack->m_dwGroupBits))
                        {
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_PLAY) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_PLAY_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_PLAY_IS_DISABLED; // Mark so we can turn on later.
                            }
                            if ((pTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_NOTIFICATION) &&
                                (pPrimaryTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                            {
                                pPrimaryTrack->m_dwFlags &= ~DMUS_TRACKCONFIG_NOTIFICATION_ENABLED;
                                pPrimaryTrack->m_dwInternalFlags |= CONTROL_NTFY_IS_DISABLED; // Mark so we can turn on later.
                            }
                        }
                    }
                    LeaveCriticalSection(&pSegNode->m_CriticalSection);
                }
            }
        }
        LeaveCriticalSection(&pControlNode->m_CriticalSection);
    }
    // Now, go back to the primary segment and find all tracks that have been reenabled
    // and tag them so they will generate refresh data on the next play (by seeking, as if they
    // were starting or looping playback.) We only do this for play, not notify, because no
    // notifications have state.
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        EnterCriticalSection(&pSegNode->m_CriticalSection);
        CTrack *pTrack = pSegNode->m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            if ((pTrack->m_dwInternalFlags & CONTROL_PLAY_DEFAULT_ENABLED) &&
                (pTrack->m_dwInternalFlags & CONTROL_PLAY_WAS_DISABLED) &&
                !(pTrack->m_dwInternalFlags & CONTROL_PLAY_IS_DISABLED))
            {
                pTrack->m_dwInternalFlags |= CONTROL_PLAY_REFRESH; // Mark so we can turn on later.
            }
        }
        LeaveCriticalSection(&pSegNode->m_CriticalSection);
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

void CPerformance::GetTimeSig( MUSIC_TIME mtTime, DMUS_TIMESIG_PMSG* pTimeSig )
{
    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
    for (;pEvent;pEvent = pEvent->pNext)
    {
        // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
        if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
        {
            DMUS_TIMESIG_PMSG* pNewTimeSig = (DMUS_TIMESIG_PMSG*)PRIV_TO_DMUS(pEvent);
            memcpy( pTimeSig, pNewTimeSig, sizeof(DMUS_TIMESIG_PMSG) );
            LeaveCriticalSection(&m_PipelineCrSec);
            return;
        }
    }
    // This should only happen if there is no timesig at all. Should only happen before any segments play.
    memset( pTimeSig, 0, sizeof(DMUS_TIMESIG_PMSG ) );
    pTimeSig->wGridsPerBeat = 4;
    pTimeSig->bBeatsPerMeasure = 4;
    pTimeSig->bBeat = 4;
    LeaveCriticalSection(&m_PipelineCrSec);
}

void CPerformance::SyncTimeSig( CSegState *pSegState )

/*  If a primary segment is played that does not have a time signature track,
    this forces the current time signature to line up with the start of the
    primary segment.
*/

{
    // First, test to see if the segment has a time signature.
    // If it doesn't then we need to do this.
    DMUS_TIMESIGNATURE TimeSig;
    if (FAILED(pSegState->GetParam(this,GUID_TimeSignature,-1,0,0,NULL,(void *)&TimeSig)))
    {
        MUSIC_TIME mtTime = pSegState->m_mtResolvedStart;
        EnterCriticalSection(&m_PipelineCrSec);
        PRIV_PMSG* pEvent = m_TimeSigQueue.GetHead();
        // Scan through the time signatures until the most recent one is found.
        for (;pEvent;pEvent = pEvent->pNext)
        {
            // If this is the last time sig, return it. Or, if the next time sig is after mtTime.
            if (!pEvent->pNext || ( pEvent->pNext->mtTime > mtTime ))
            {
                pEvent->mtTime = mtTime;
                MusicToReferenceTime(mtTime,&pEvent->rtTime);
                break;
            }
        }
        // Should never fall through to here without finding a time signature because Init() creates a timesig.
        LeaveCriticalSection(&m_PipelineCrSec);
    }
}

// Convert mtTime into the resolved time according to the resolution in
// dwResolution.
// This should only be called from within a segment critical section.
MUSIC_TIME CPerformance::ResolveTime( MUSIC_TIME mtTime, DWORD dwResolution, MUSIC_TIME *pmtIntervalSize )
{
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = 0;
    }
    if (dwResolution & DMUS_SEGF_MARKER)
    {
        DMUS_PLAY_MARKER_PARAM Marker;
        MUSIC_TIME mtNext;
        // First, get the time of the marker preceding this one.
        if (SUCCEEDED (GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
        {
            BOOL fIsMarker = FALSE;
            MUSIC_TIME mtInitialTime = mtTime;
            MUSIC_TIME mtFirst = mtTime + Marker.mtTime; // This is the time of the preceding marker.
            MUSIC_TIME mtSecond = mtTime + mtNext;  // This might be the time of the next marker.
            // Then, scan forward until a marker is found after or equal to this time.
            // If a loop point or end of segment is encountered, the value in Marker.mtTime will
            // continue to be negative. Once we hit the actual marker, it will become 0, since
            // we are asking for the marker at that specific time.
            while (mtNext)
            {
                mtTime += mtNext;
                if (SUCCEEDED(GetParam(GUID_Play_Marker,-1,0,mtTime,&mtNext,(void *) &Marker)))
                {
                    // If the marker time is 0, this means we are sitting right on the marker,
                    // so we are done.
                    if (fIsMarker = (Marker.mtTime == 0))
                    {
                        mtSecond = mtTime;
                        break;
                    }
                    // Otherwise, this was a loop boundary or segment end, so we should continue scanning forward.
                }
                else
                {
                    // GetParam failed, must be nothing more to search.
                    break;
                }
            }
            // If the caller wants the interval size, then we know they are interested in
            // aligning to a previous marker as well as a future one. In that case,
            // if we didn't find a marker in the future, it's okay because it will
            // use the previous marker (mtFirst) anyway.
            // For all other cases, we only return if the upcoming marker is legal.
            // Otherwise, we drop through and try other resolutions.
            if (pmtIntervalSize || fIsMarker)
            {
                if (pmtIntervalSize)
                {
                    *pmtIntervalSize = mtSecond - mtFirst;
                }
                return mtSecond;
            }
            mtTime = mtInitialTime;
        }
        // If marker fails, we can drop down to the other types...
    }
    if( dwResolution & DMUS_SEGF_SEGMENTEND )
    {
        // In this mode, we don't actually get the time signature. Instead, we
        // find out the time of the next segment start after the requested time.
        CSegState *pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            // First, calculate the end time of the segment.
            // Include any starting offset so we see the full span of the segment.
            mtTime = pSegNode->GetEndTime( pSegNode->m_mtStartPoint );
            if (pmtIntervalSize)
            {
                // Interval would be the length of the primary segment!
                *pmtIntervalSize = mtTime;
            }
            // Return the end of the segment.
            LONGLONG llEnd = mtTime + (LONGLONG)(pSegNode->m_mtResolvedStart - pSegNode->m_mtStartPoint);
            if(llEnd > 0x7fffffff) llEnd = 0x7fffffff;
            mtTime = (MUSIC_TIME) llEnd;
            return mtTime;
        }
        // If there was no segment, we should fail and try the other flags.
    }
    long        lQuantize;
    MUSIC_TIME  mtNewTime;
    MUSIC_TIME  mtStartOfTimeSig = 0;
    DMUS_TIMESIGNATURE  timeSig;
    if (!(dwResolution & DMUS_SEGF_TIMESIG_ALWAYS))
    {
        if (!GetPrimarySegmentAtTime(mtTime))
        {
            return mtTime;
        }
    }
    GetParam(GUID_TimeSignature,-1,0,mtTime,NULL,(void *) &timeSig);
    mtStartOfTimeSig = timeSig.mtTime + mtTime;
    mtNewTime = mtTime - mtStartOfTimeSig;
    if (dwResolution & DMUS_SEGF_MEASURE)
    {
        lQuantize = ( DMUS_PPQ * 4 * timeSig.bBeatsPerMeasure ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_BEAT)
    {
        lQuantize = ( DMUS_PPQ * 4 ) / timeSig.bBeat;
    }
    else if (dwResolution & DMUS_SEGF_GRID)
    {
        lQuantize = ( ( DMUS_PPQ * 4 ) / timeSig.bBeat ) / timeSig.wGridsPerBeat;
    }
    else
    {
        lQuantize = 1;
    }
    if (lQuantize == 0) // Avoid divide by 0 error.
    {
        lQuantize = 1;
    }
    if (pmtIntervalSize)
    {
        *pmtIntervalSize = lQuantize;
    }
    if( mtNewTime ) // if it's 0 it stays 0
    {
        // round up to next boundary
        mtNewTime = ((mtNewTime-1) / lQuantize ) * lQuantize;
        mtNewTime += lQuantize;
    }
    return (mtNewTime + mtStartOfTimeSig);
}

// returns:
// true if the note should be invalidated (any other return code will invalidate)
// false if the note should not be invalidated
inline bool GetInvalidationStatus(DMUS_PMSG* pPMsg)
{
    bool fResult = true; // default: invalidate the note

    if( pPMsg->dwType == DMUS_PMSGT_NOTE )
    {
        DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
        if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_WAVE )
    {
        DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
        if(pWave->bFlags & DMUS_WAVEF_NOINVALIDATE)
        {
            fResult = false;
        }
    }
    else if( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        // Don't invalidate segment abort messages
        DMUS_NOTIFICATION_PMSG* pNotification = (DMUS_NOTIFICATION_PMSG*) pPMsg;
        if ((pNotification->guidNotificationType == GUID_NOTIFICATION_SEGMENT) &&
            (pNotification->dwNotificationOption == DMUS_NOTIFICATION_SEGABORT))
        {
            fResult = false;
        }
    }
    return fResult;
}

static inline long ComputeCurveTimeSlice(DMUS_CURVE_PMSG* pCurve)
{
    long lTimeIncrement;
    DWORD dwTotalDistance;
    DWORD dwResolution;
    if ((pCurve->bType == DMUS_CURVET_PBCURVE) ||
        (pCurve->bType == DMUS_CURVET_RPNCURVE) ||
        (pCurve->bType == DMUS_CURVET_NRPNCURVE))
    {
        dwResolution = 100;
    }
    else
    {
        dwResolution = 3;
    }
    if (pCurve->nEndValue > pCurve->nStartValue)
        dwTotalDistance = pCurve->nEndValue - pCurve->nStartValue;
    else
        dwTotalDistance = pCurve->nStartValue - pCurve->nEndValue;
    if (dwTotalDistance == 0) dwTotalDistance = 1;
    lTimeIncrement = (pCurve->mtDuration * dwResolution) / dwTotalDistance;
    // Force to no smaller than 192nd note (10ms at 120 bpm.)
    if( lTimeIncrement < (DMUS_PPQ/48) ) lTimeIncrement = DMUS_PPQ/48;
    return lTimeIncrement;
}

static DWORD ComputeCurve( DMUS_CURVE_PMSG* pCurve )
{
    DWORD dwRet;
    short *panTable;
    MUSIC_TIME mtCurrent;
    long lIndex;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            pCurve->rtTime = 0;
            return (DWORD)pCurve->nResetValue;
        }
        if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && ( pCurve->mtResetDuration > 0 ) )
        {
            pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart;
            pCurve->mtDuration = 0;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // setting this to 0 will free the event upon return
        }
        return (DWORD)pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    // compute index into table
    // there are CT_MAX + 1 elements in the table.
    mtCurrent = pCurve->mtTime - pCurve->mtOriginalStart;

    // if we're flushing this event, send the reset value
    if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
    {
        // it will only get here if pCurve->bFlags & 1, because that is checked in
        // the :Flush() routine.
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }

    // this should now never happen, as a result of fixing 33987: Transition on a beat boundary invalidates CC's right away (doesn't wait for the beat)
    if( (pCurve->bFlags & DMUS_CURVE_RESET) &&
        (pCurve->mtResetDuration < 0 ) && // this can happen from flushing
        (pCurve->mtTime >= pCurve->mtOriginalStart + pCurve->mtDuration + pCurve->mtResetDuration ))
    {
        pCurve->rtTime = 0;
        return pCurve->nResetValue;
    }
    else if( (pCurve->mtDuration == 0) ||
        (pCurve->mtTime - pCurve->mtOriginalStart >= pCurve->mtDuration ))
    {
        // if we're supposed to send the return value (m_bFlags & 1) then
        // set it up to do so. Otherwise, free the event.
        if( pCurve->bFlags & DMUS_CURVE_RESET )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
            pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;
        }
        else
        {
            pCurve->rtTime = 0; // time to free the event, we're done
        }
        dwRet = pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            dwRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            dwRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) /
                CT_DIVFACTOR) + pCurve->nStartValue;
        }

        // this should now never happen, as a result of fixing 33987
        if( (pCurve->bFlags & DMUS_CURVE_RESET) && (pCurve->mtResetDuration < 0) )
        {
            // this can happen as a result of flushing. We want to make sure the next
            // time is the reset flush time.
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtResetDuration +
                pCurve->mtOriginalStart;
        }
        else
        {
            // Within curve, so increment time.
            if (!pCurve->wMeasure) // oops --- better compute this.
            {
                TraceI(2, "Warning: Computing curve time slice...\n");
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);  // Use this to store the time slice interval.
            }
            pCurve->mtTime += pCurve->wMeasure; // We are storing the time increment here.
        }
        if( pCurve->mtTime > pCurve->mtDuration + pCurve->mtOriginalStart )
        {
            pCurve->mtTime = pCurve->mtDuration + pCurve->mtOriginalStart;
        }
        pCurve->dwFlags &= ~DMUS_PMSGF_REFTIME;

    }
    return dwRet;
}

static int RecomputeCurveEnd( DMUS_CURVE_PMSG* pCurve, MUSIC_TIME mtCurrent )
{
    int nRet = 0;
    short *panTable;

    switch( pCurve->bCurveShape )
    {
    case DMUS_CURVES_INSTANT:
    default:
        return pCurve->nEndValue;
        break;
    case DMUS_CURVES_LINEAR:
        panTable = &ganCT_Linear[ 0 ];
        break;
    case DMUS_CURVES_EXP:
        panTable = &ganCT_Exp[ 0 ];
        break;
    case DMUS_CURVES_LOG:
        panTable = &ganCT_Log[ 0 ];
        break;
    case DMUS_CURVES_SINE:
        panTable = &ganCT_Sine[ 0 ];
        break;
    }

    if( (pCurve->mtDuration == 0) || (mtCurrent >= pCurve->mtDuration ))
    {
        return pCurve->nEndValue;
    }
    else
    {
        // Calculate how far into the table we should be.
        long lIndex = (mtCurrent * (CT_MAX + 1)) / pCurve->mtDuration;

        // find an amount of time to add to the curve event such that there is at
        // least a change by CT_FACTOR. This will be used as the time stamp
        // for the next iteration of the curve.

        // clamp lIndex
        if( lIndex < 0 )
        {
            lIndex = 0;
        }
        if( lIndex >= CT_MAX )
        {
            lIndex = CT_MAX;
            nRet = pCurve->nEndValue;
        }
        else
        {
            // Okay, in the curve, so calculate the return value.
            nRet = ((panTable[lIndex] * (pCurve->nEndValue - pCurve->nStartValue)) /
                CT_DIVFACTOR) + pCurve->nStartValue;
        }
    }
    return nRet;
}

void CPerformance::FlushEventQueue( DWORD dwId,
    CPMsgQueue *pQueue,                 // Queue to flush events from.
    REFERENCE_TIME rtFlush,             // Time that flush occurs. This may be resolved to a timing resolution.
    REFERENCE_TIME rtFlushUnresolved,   // Queue time at time flush was requested. This is not resolved to the timing resolution.
                                        // Instead, it is the actual time at which that the flush was requested. This is used only by curves.
    BOOL fLeaveNotesOn)                 // If notes or waves are currently on, do not cut short their durations.
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    HRESULT hr = S_OK;

    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        // Clear the remove bit. This will be set for each event that should be removed from the queue.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        // Also clear the requeue bit, which will be set for each event that needs to be requeued.
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
        if( ( 0 == dwId ) || ( pEvent->dwVirtualTrackID == dwId ) )
        {
            // First, create the correct mtTime and rtTime for invalidation.
            REFERENCE_TIME rtTime = pEvent->rtTime;
            if( pEvent->dwType == DMUS_PMSGT_NOTE )
            {
                DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    // If this is a note on, we want to take the offset into consideration for
                    // determining whether or not to invalidate.
                    MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset;
                    MusicToReferenceTime( mtNote, &rtTime );
                }
                // If note off and we want to leave notes playing, turn on the noinvalidate flag.
                else if (fLeaveNotesOn)
                {
                    pNote->bFlags |= DMUS_NOTEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_WAVE )
            {
                DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                {
                    if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                    {
                        rtTime = pWave->rtTime;
                    }
                    else
                    {
                        MusicToReferenceTime(pWave->mtTime, &rtTime);
                    }
                }
                // If wave off and we want to leave waves playing, turn on the noinvalidate flag.
                else if (fLeaveNotesOn)
                {
                    pWave->bFlags |= DMUS_WAVEF_NOINVALIDATE;
                }
            }
            else if( pEvent->dwType == DMUS_PMSGT_CURVE )
            {
                if (fLeaveNotesOn)
                {
                    rtTime = 0;
                }
                else
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtCurve;
                    MUSIC_TIME mtStart;
                    mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

                    // if rtFlush is before the beginning of the curve minus the offset of
                    // the curve, we want to prevent the curve from playing
                    mtCurve = mtStart - pCurve->nOffset;
                    MusicToReferenceTime( mtCurve, &rtTime );
                    if( rtFlush > rtTime ) // if it isn't...
                    {
                        // if the curve has a reset value and has already begun,
                        // we may want to flush right away.
                        if( ( pCurve->bFlags & DMUS_CURVE_RESET) &&
                              pCurve->mtOriginalStart &&
                              rtFlush <= rtFlushUnresolved )
                        {
                            mtCurve = mtStart + pCurve->mtDuration;
                            MusicToReferenceTime( mtCurve, &rtTime );
                            if( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                            {
                                MUSIC_TIME mt = 0;
                                ReferenceToMusicTime(rtFlush, &mt);
                                pCurve->mtDuration = (mt - mtStart) - 1;
                                pCurve->mtResetDuration = 1;
                            }
                            else
                            {
                                mtCurve = mtStart + pCurve->mtDuration + pCurve->mtResetDuration;
                                MusicToReferenceTime( mtCurve, &rtTime );
                                if ( rtTime >= rtFlush && !(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH) )
                                {
                                    MUSIC_TIME mt = 0;
                                    ReferenceToMusicTime(rtFlush, &mt);
                                    pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);
                                }
                            }
                        }
                        else
                        {
                            // Otherwise, we may cut the curve short in the code below.
                            rtTime = 0;
                        }
                    }
                }
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                if (!(pEvent->dwPrivFlags & PRIV_FLAG_FLUSH))
                {
                    if( pEvent->pTool)
                    {
                        bool fFlush = false;
                        if (pEvent->dwType == DMUS_PMSGT_WAVE)
                        {
                            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                            if( !(pWave->bFlags & DMUS_WAVEF_OFF) )
                            {
                                // this wave on is due to start after the flush time.
                                // we never want to hear it.
                                fFlush = true;
                            }
                            else
                            {
                                // cut the duration short, but don't actually flush here,
                                // since it's possible to invalidate the same wave more
                                // than once, and the second invalidation might have a
                                // time prior to the first one (e.g., first is from a loop,
                                // second is from a transition)
                                if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)) &&
                                    rtFlush < pWave->rtTime)
                                {
                                    pEvent->dwPrivFlags |= PRIV_FLAG_REQUEUE;
                                    MUSIC_TIME mtFlush = 0;
                                    ReferenceToMusicTime(rtFlush, &mtFlush);
                                    pWave->rtTime = rtFlush;
                                    pWave->mtTime = mtFlush;
                                }
                            }
                        }
                        if (fFlush ||
                            (pEvent->dwType != DMUS_PMSGT_WAVE &&
                             GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                        {
                            pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                            pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                            if( rtFlush <= pEvent->rtLast )
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), pEvent->rtLast + REF_PER_MIL );
                            }
                            else
                            {
                                pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlush );
                            }
                        }
                    }
                    else
                    {
                        pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    }
                }
            }
            else // cut notes, waves, and curves short if needed
            {
                if( pEvent->dwType == DMUS_PMSGT_NOTE && !fLeaveNotesOn )
                {
                    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                    {
                        if (GetInvalidationStatus(PRIV_TO_DMUS(pEvent)))
                        {
                            // subtract 2 from the duration to guarantee the note cuts short
                            // 1 clock before the flush time.
                            MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                            REFERENCE_TIME rtNoteOff;
                            MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                            if( rtNoteOff >= rtFlush )
                            {
                                ReferenceToMusicTime( rtFlush, &mtNoteOff );
                                mtNoteOff -= pNote->mtTime;
                                // Make any duration < 1 be 0; this will cause the note not to
                                // sound.  Can happen if the note's logical time is well before
                                // its physical time.
                                if( mtNoteOff < 1 ) mtNoteOff = 0;
                                pNote->mtDuration = mtNoteOff;
                            }
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_WAVE && !fLeaveNotesOn )
                {
                    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    if( !(pWave->bFlags & DMUS_WAVEF_OFF) &&
                        (GetInvalidationStatus(PRIV_TO_DMUS(pEvent))) )
                    {
                        if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                        {
                            // This is a clock time message.
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((rtTime + pWave->rtDuration - 2) >= rtFlush)
                            {
                                pWave->rtDuration = rtFlush - rtTime;
                            }

                        }
                        else
                        {
                            MUSIC_TIME mtTime = 0;
                            MUSIC_TIME mtFlush = 0;
                            ReferenceToMusicTime(rtTime, &mtTime);
                            ReferenceToMusicTime(rtFlush, &mtFlush);
                            // subtract 2 from the duration to guarantee the wave cuts short
                            // 1 clock before the flush time.
                            if ((mtTime + (MUSIC_TIME)pWave->rtDuration - 2) >= mtFlush)
                            {
                                pWave->rtDuration = mtFlush - mtTime;
                            }
                        }
                        if (pWave->rtDuration < 1) // disallow durations less than 1. This should never happen anyway.
                        {
                            pWave->rtDuration = 1;
                        }
                    }
                }
                else if( pEvent->dwType == DMUS_PMSGT_CURVE && !fLeaveNotesOn )
                {
                    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)PRIV_TO_DMUS(pEvent);
                    MUSIC_TIME mtEnd;
                    MUSIC_TIME mtStart = pCurve->mtOriginalStart ? pCurve->mtOriginalStart : pCurve->mtTime;

                    if( pCurve->bFlags & DMUS_CURVE_RESET )
                    {
                        mtEnd = mtStart + pCurve->mtResetDuration + pCurve->mtDuration;
                    }
                    else
                    {
                        mtEnd = mtStart + pCurve->mtDuration;
                    }
                    REFERENCE_TIME rtEnd;
                    MusicToReferenceTime( mtEnd, &rtEnd );
                    // Note: as a result of fixing 33987, the curve is no longer given
                    // a negative reset duration.  Now, the curve's duration is recomputed
                    // and its time slice is recalculated.
                    if( rtEnd >= rtFlush )
                    {
                        // reset the curve's duration
                        ReferenceToMusicTime( rtFlush, &mtEnd );
                        mtEnd -= mtStart;
                        // get the curve value at the flush time, and make that the end value
                        pCurve->nEndValue = (short) RecomputeCurveEnd(pCurve, mtEnd);
                        // subtract 2 from the duration to guarantee the curve cuts short
                        // 1 clock before the flush time.
                        mtEnd -= 2;
                        if ( mtEnd < 1)
                        {
                            mtEnd = 1;
                        }
                        else if (pCurve->bFlags & DMUS_CURVE_RESET)
                        {
                            if (mtEnd > pCurve->mtDuration)
                            {
                                // curve ends in the reset duration; keep regular duration the
                                // same as it was and adjust reset duration
                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                                MUSIC_TIME mt = 0;
                                ReferenceToMusicTime(rtFlush, &mt);
                                pCurve->mtResetDuration = mt - (mtStart + pCurve->mtDuration);
                                mtEnd = pCurve->mtDuration;
                                if (pCurve->mtTime > mtEnd + pCurve->mtResetDuration + mtStart)
                                {
                                    pCurve->mtTime = mtEnd + pCurve->mtResetDuration + mtStart;
                                    MusicToReferenceTime(pCurve->mtTime, &pCurve->rtTime);
                                }
                            }
                            else
                            {
                                // curve ends in the regular duration; reduce it by 1 and
                                // give the reset duration a value of 1
                                mtEnd--;
                                pCurve->mtResetDuration = 1;
                                if (mtEnd < 1)
                                {
                                    // this is unlikely, but the curve really should have
                                    // a duration...
                                    mtEnd = 1;
                                }
                                pEvent->dwPrivFlags |= PRIV_FLAG_FLUSH;
                            }
                            // If this is an instant curve that's already started, we
                            // don't want it to play again, so reset its start time
                            if ( pCurve->bCurveShape == DMUS_CURVES_INSTANT &&
                                 pCurve->mtOriginalStart )
                            {
                                pCurve->mtTime = pCurve->mtResetDuration + pCurve->mtOriginalStart + mtEnd;
                            }
                        }
                        pCurve->mtDuration = mtEnd;
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & (PRIV_FLAG_REMOVE | PRIV_FLAG_REQUEUE))
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                if (pEvent->dwPrivFlags & PRIV_FLAG_REQUEUE)
                {
                    pEvent->dwPrivFlags &= ~PRIV_FLAG_REQUEUE;
                    pQueue->Enqueue(pEvent);
                }
                else
                {
                    FreePMsg(pEvent);
                }
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    SendBuffers();
}

/*

  Flushes all events in all queues from time <p mtFlush> on.

  comm Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::FlushMainEventQueues(
    DWORD dwId,                      // Virtual Track ID to flush, or zero for all.
    MUSIC_TIME mtFlush,              // Time to flush (resolved to timing resolution).
    MUSIC_TIME mtFlushUnresolved,    // Time to flush (unresolved).
    BOOL fLeaveNotesOn)              // If true, notes currently on are left to play through their duration.
{
    REFERENCE_TIME rt;
    if( mtFlush )
    {
        MusicToReferenceTime( mtFlush, &rt );
    }
    else
    {
        rt = 0;
    }
    REFERENCE_TIME rtUnresolved;
    if( mtFlushUnresolved && mtFlushUnresolved != mtFlush)
    {
        MusicToReferenceTime( mtFlushUnresolved, &rtUnresolved );
    }
    else
    {
        rtUnresolved = rt;
    }
    FlushEventQueue( dwId, &m_OnTimeQueue, rt, rtUnresolved, fLeaveNotesOn );
    FlushEventQueue( dwId, &m_NearTimeQueue, rt, rtUnresolved, fLeaveNotesOn );
    FlushEventQueue( dwId, &m_EarlyQueue, rt, rtUnresolved, fLeaveNotesOn );
    if (dwId == 0)
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime(rt,&mtTime);
        FlushEventQueue( dwId, &m_TempoMap, rt, rtUnresolved, fLeaveNotesOn );
        RecalcTempoMap(NULL, mtTime );
    }
}

// the only kinds of events we care about are note events.
void CPerformance::OnChordUpdateEventQueue( DMUS_NOTIFICATION_PMSG* pNotify, CPMsgQueue *pQueue, REFERENCE_TIME rtFlush )
{
    PRIV_PMSG* pEvent;
    PRIV_PMSG* pNext;
    HRESULT hr = S_OK;
    DWORD dwId = pNotify->dwVirtualTrackID;
    DWORD dwTrackGroup = pNotify->dwGroupID;
    CPMsgQueue UpdateQueue;        // List of PMsgs to be inserted into a queue during update.

    REFERENCE_TIME rtTemp;
    GetQueueTime(&rtTemp);
    pNext = NULL;
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
        DMUS_PMSG* pNew = NULL;
        if( ( 0 == dwId || pEvent->dwVirtualTrackID == dwId ) &&
            (pEvent->dwType == DMUS_PMSGT_NOTE) )
        {
            REFERENCE_TIME rtTime = pEvent->rtTime;
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)PRIV_TO_DMUS(pEvent);
            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                MUSIC_TIME mtNote = pNote->mtTime - pNote->nOffset;
                MusicToReferenceTime( mtNote, &rtTime );
            }
            // now flush the event if needed
            if( rtTime >= rtFlush )
            {
                REFERENCE_TIME rtFlushTime = (rtFlush <= pEvent->rtLast) ? pEvent->rtLast + REF_PER_MIL : rtFlush;
                if( pEvent->pTool &&
                    !(pNote->bFlags & DMUS_NOTEF_NOTEON) &&
                    S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlushTime, &pNew)))
                {
                    pEvent->dwPrivFlags |= PRIV_FLAG_REMOVE;
                    pEvent->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                    pEvent->pTool->Flush( this, PRIV_TO_DMUS(pEvent), rtFlushTime );
                }
                if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                {
                    UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                }
            }
            else // cut notes short if needed
            {
                if( pNote->bFlags & DMUS_NOTEF_NOTEON )
                {
                    if (S_OK == (hr = GetChordNotificationStatus(pNote, dwTrackGroup, rtFlush, &pNew)))
                    {
                        // subtract 2 from the duration to guarantee the note cuts short
                        // 1 clock before the flush time.
                        MUSIC_TIME mtNoteOff = pNote->mtTime + pNote->mtDuration - 2;
                        REFERENCE_TIME rtNoteOff;
                        MusicToReferenceTime( mtNoteOff, &rtNoteOff );
                        if( rtNoteOff >= rtFlush )
                        {
                            ReferenceToMusicTime( rtFlush, &mtNoteOff );
                            mtNoteOff -= pNote->mtTime;
                            if( mtNoteOff < 1 ) mtNoteOff = 1; // disallow durations less than 1. This should never happen anyway.
                            pNote->mtDuration = mtNoteOff;
                        }
                    }
                    if (SUCCEEDED(hr) && pNew) // add to temp queue for later insertion into regular queue
                    {
                        UpdateQueue.Enqueue( DMUS_TO_PRIV(pNew) );
                    }
                }
            }
        }
    }
    // remove (and unmark) all marked PMsgs from the current queue
    for(pEvent = pQueue->GetHead(); pEvent; pEvent = pNext )
    {
        pNext = pEvent->pNext;
        if (pEvent->dwPrivFlags & PRIV_FLAG_REMOVE)
        {
            pEvent->dwPrivFlags &= ~PRIV_FLAG_REMOVE;
            if (pQueue->Dequeue(pEvent))
            {
                FreePMsg(pEvent);
            }
            else
            {
                TraceI(0,"Error dequeing event for flushing\n");
            }
        }
    }
    // empty the Update queue into the current queue
    while( pEvent = UpdateQueue.Dequeue() )
    {
        pQueue->Enqueue(pEvent);
    }
    SendBuffers();
}

/*

  Only call this from withing a PipelineCrSec critical section!

*/
void CPerformance::OnChordUpdateEventQueues(
    DMUS_NOTIFICATION_PMSG* pNotify)    // notification PMsg that caused this to be called
{
    IDirectMusicSegmentState* pSegState = NULL;
    if (!pNotify || !pNotify->punkUser) return;
    REFERENCE_TIME rt = 0;
    if( pNotify->mtTime )
    {
        MusicToReferenceTime( pNotify->mtTime, &rt );
    }
    OnChordUpdateEventQueue( pNotify, &m_OnTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_NearTimeQueue, rt );
    OnChordUpdateEventQueue( pNotify, &m_EarlyQueue, rt );
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicPerformance

HRESULT CPerformance::CreateThreads()

{
    // initialize the realtime thread
    m_hRealtimeThread = CreateThread(NULL, 0, _Realtime, this, 0, &m_dwRealtimeThreadID);
    if( m_hRealtimeThread )
    {
        m_hRealtime = CreateEvent(NULL,FALSE,FALSE,NULL);
        SetThreadPriority( m_hRealtimeThread, THREAD_PRIORITY_TIME_CRITICAL );
    }
    else
    {
        TraceI(0, "Major error! Realtime thread not created.\n");
        return E_OUTOFMEMORY;
    }
    // initialize the transport thread
    m_hTransportThread = CreateThread(NULL, 0, _Transport, this, 0, &m_dwTransportThreadID);
    if( m_hTransportThread )
    {
        m_hTransport = CreateEvent(NULL, FALSE, FALSE, NULL);
        SetThreadPriority( m_hTransportThread, THREAD_PRIORITY_ABOVE_NORMAL );
    }
    else
    {
        TraceI(0, "Major error! Transport thread not created.\n");
        m_fKillRealtimeThread = TRUE;
        if( m_hRealtime ) SetEvent( m_hRealtime );
        return E_OUTOFMEMORY;
    }
    m_pDirectMusic->GetMasterClock( NULL, &m_pClock );
    m_rtStart = GetTime();
    m_rtQueuePosition = m_rtStart;
    return S_OK;
}


STDMETHODIMP CPerformance::InitAudio(IDirectMusic** ppDirectMusic,
                           IDirectSound** ppDirectSound,
                           HWND hWnd,
                           DWORD dwDefaultPathType,
                           DWORD dwPChannelCount,
                           DWORD dwFlags,
                           DMUS_AUDIOPARAMS *pParams)

{
    V_INAME(IDirectMusicPerformance::InitAudio);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_PTRPTR_WRITE_OPT(ppDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if (ppDirectSound)
    {
        V_INTERFACE_OPT(*ppDirectSound);
    }
    if( m_dwAudioPathMode )
    {
        Trace(1,"Error: InitAudio called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    if (dwFlags == 0)
    {
        dwFlags = DMUS_AUDIOF_ALL;
    }
    Init();
    m_AudioParams.dwFeatures = dwFlags;
    m_AudioParams.dwSampleRate = 22050;
    m_AudioParams.dwSize = sizeof (m_AudioParams);
    m_AudioParams.dwValidData = DMUS_AUDIOPARAMS_FEATURES | DMUS_AUDIOPARAMS_VOICES | DMUS_AUDIOPARAMS_SAMPLERATE | DMUS_AUDIOPARAMS_DEFAULTSYNTH;
    m_AudioParams.dwVoices = 64;
    m_AudioParams.fInitNow = TRUE;
    m_AudioParams.clsidDefaultSynth = CLSID_DirectMusicSynth;
    if (pParams)
    {
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
        {
            m_AudioParams.dwFeatures = pParams->dwFeatures;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
        {
            m_AudioParams.dwVoices = pParams->dwVoices;
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
        {
            // If they requested the DX7 default synth and yet also asked for audiopath
            // features, force to DX8 default synth.
            if ((pParams->clsidDefaultSynth != GUID_NULL) ||
                !((m_AudioParams.dwValidData & DMUS_AUDIOPARAMS_FEATURES) &&
                (m_AudioParams.dwFeatures & DMUS_AUDIOF_ALL)))
            {
                m_AudioParams.clsidDefaultSynth = pParams->clsidDefaultSynth;
            }
        }
        if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
        {
            if (pParams->dwSampleRate > 96000)
            {
                m_AudioParams.dwSampleRate = 96000;
            }
            else if (pParams->dwSampleRate < 11025)
            {
                m_AudioParams.dwSampleRate = 11025;
            }
            else
            {
                m_AudioParams.dwSampleRate = pParams->dwSampleRate;
            }
        }
    }
    m_dwAudioPathMode = 2;
    EnterCriticalSection(&m_MainCrSec);
    if (ppDirectMusic && *ppDirectMusic)
    {
        hr = (*ppDirectMusic)->QueryInterface(IID_IDirectMusic8,(void **) &m_pDirectMusic);
    }
    if (SUCCEEDED(hr))
    {
        if (ppDirectSound && *ppDirectSound)
        {
            hr = (*ppDirectSound)->QueryInterface(IID_IDirectSound8,(void **) &m_pDirectSound);
        }
        if (SUCCEEDED(hr))
        {
            if (!m_pDirectSound)
            {
                hr = DirectSoundCreate8(NULL,&m_pDirectSound,NULL);
                if (SUCCEEDED(hr))
                {
                    if (!hWnd)
                    {
                        hWnd = GetForegroundWindow();
                        if (!hWnd)
                        {
                            hWnd = GetDesktopWindow();
                        }
                    }
                    m_pDirectSound->SetCooperativeLevel(hWnd, DSSCL_PRIORITY);
                }
            }

            if (SUCCEEDED(hr))
            {
                if (!m_pDirectMusic)
                {
                    hr = CoCreateInstance(CLSID_DirectMusic,
                                          NULL,
                                          CLSCTX_INPROC,
                                          IID_IDirectMusic8,
                                          (LPVOID*)&m_pDirectMusic);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pDirectMusic->SetDirectSound(m_pDirectSound,hWnd);
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = m_BufferManager.Init(this,&m_AudioParams);
        if (SUCCEEDED(hr))
        {
            // If we are going to be connecting the synth to Buffers,
            // force the use of the dsound clock.
            if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
            {
                DMUS_CLOCKINFO ClockInfo;
                ClockInfo.dwSize = sizeof(ClockInfo);
                DWORD dwIndex;
                GUID guidMasterClock = GUID_NULL;
                for (dwIndex = 0; ;dwIndex++)
                {
                    if (S_OK == m_pDirectMusic->EnumMasterClock(dwIndex, &ClockInfo))
                    {
                        if (!wcscmp(ClockInfo.wszDescription, L"DirectSound Clock"))
                        {
                            guidMasterClock = ClockInfo.guidClock;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
                m_pDirectMusic->SetMasterClock(guidMasterClock);
            }
            hr = CreateThreads();
            if (SUCCEEDED(hr))
            {
                if (dwDefaultPathType)
                {
                    IDirectMusicAudioPath *pPath;
                    hr = CreateStandardAudioPath(dwDefaultPathType,dwPChannelCount,m_AudioParams.fInitNow,&pPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetDefaultAudioPath(pPath);
                        pPath->Release();
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (m_pDirectMusic && ppDirectMusic && !*ppDirectMusic)
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
        if (m_pDirectSound && ppDirectSound && !*ppDirectSound)
        {
            *ppDirectSound = m_pDirectSound;
            m_pDirectSound->AddRef();
        }
        if (pParams && pParams->fInitNow)
        {
            if (pParams->clsidDefaultSynth != m_AudioParams.clsidDefaultSynth)
            {
                pParams->clsidDefaultSynth = m_AudioParams.clsidDefaultSynth;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_DEFAULTSYNTH)
                {
                    Trace(2,"Warning: Default synth choice has been changed.\n");
                    hr = S_FALSE;
                }
            }
            if (pParams->dwFeatures != m_AudioParams.dwFeatures)
            {
                pParams->dwFeatures = m_AudioParams.dwFeatures;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_FEATURES)
                {
                    Trace(2,"Warning: Features flags has been changed to %lx.\n",pParams->dwFeatures);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwSampleRate != m_AudioParams.dwSampleRate)
            {
                pParams->dwSampleRate = m_AudioParams.dwSampleRate;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_SAMPLERATE)
                {
                    Trace(2,"Warning: Sample rate has been changed to %ld.\n",pParams->dwSampleRate);
                    hr = S_FALSE;
                }
            }
            if (pParams->dwVoices != m_AudioParams.dwVoices)
            {
                pParams->dwVoices = m_AudioParams.dwVoices;
                if (pParams->dwValidData & DMUS_AUDIOPARAMS_VOICES)
                {
                    Trace(2,"Warning: Number of requested voices has been changed to %ld.\n",pParams->dwVoices);
                    hr = S_FALSE;
                }
            }
            pParams->dwValidData = m_AudioParams.dwValidData;
        }
        LeaveCriticalSection(&m_MainCrSec);
    }
    else
    {
        LeaveCriticalSection(&m_MainCrSec);
        CloseDown();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Init(
    IDirectMusic** ppDirectMusic,   LPDIRECTSOUND pDirectSound,HWND hWnd)
{
    V_INAME(IDirectMusicPerformance::Init);
    V_PTRPTR_WRITE_OPT(ppDirectMusic);
    V_INTERFACE_OPT(pDirectSound);
    V_HWND_OPT(hWnd);
    HRESULT hr = S_OK;

    // Further validate, checking for a pointer to a bad interface pointer...
    if (ppDirectMusic)
    {
        V_INTERFACE_OPT(*ppDirectMusic);
    }
    if( m_dwAudioPathMode )
    {
        Trace(1,"Error: Init called on an already initialized Performance.\n");
        return DMUS_E_ALREADY_INITED;
    }
    Init();
    m_dwAudioPathMode = 1;
    EnterCriticalSection(&m_MainCrSec);

    if(( NULL == ppDirectMusic ) || ( NULL == *ppDirectMusic ))
    {
        // intialize DirectMusic.

        if( FAILED( CoCreateInstance(CLSID_DirectMusic,
                              NULL,
                              CLSCTX_INPROC,
                              IID_IDirectMusic,
                              (LPVOID*)&m_pDirectMusic)))
        {
            m_pDirectMusic = NULL;
            LeaveCriticalSection(&m_MainCrSec);
            return E_OUTOFMEMORY;
        }

        // If version2 was requested by the app (in the process of requesting the
        // IDirectMusicPerformance2 interface), do the same for IDirectMusic.
        if (m_dwVersion > 6)
        {
            IDirectMusic *pTemp = NULL;
            if (SUCCEEDED(m_pDirectMusic->QueryInterface(
                IID_IDirectMusic2,
                (LPVOID*)&pTemp)))
            {
                // Succeeded in requesting DX7 and up behavior...
                pTemp->Release();
            }
        }

        hr = m_pDirectMusic->SetDirectSound(pDirectSound, hWnd);
        if( FAILED( hr ) )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
            LeaveCriticalSection(&m_MainCrSec);
            return hr;
        }

        if( ppDirectMusic )
        {
            *ppDirectMusic = m_pDirectMusic;
            m_pDirectMusic->AddRef();
        }
    }
    else
    {
        m_pDirectMusic = (IDirectMusic8 *) *ppDirectMusic;
        m_pDirectMusic->AddRef();
    }
    if (FAILED(hr = CreateThreads()))
    {
        if( m_pDirectMusic )
        {
            m_pDirectMusic->Release();
            m_pDirectMusic = NULL;
        }
    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}

CSegState *CPerformance::GetSegmentForTransition(DWORD dwFlags,MUSIC_TIME mtTime, IUnknown *pFrom)

{
    CSegState *pSegState = NULL;

    // If the source segment was provided, use it.
    if (pFrom)
    {
        if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegState)))
        {
            pSegState->Release();
        }
    }
    // Else, if this is a primary segment, get the current primary segment.
    if (!pSegState && !(dwFlags & DMUS_SEGF_SECONDARY))
    {
        pSegState = GetPrimarySegmentAtTime(mtTime);
    }
    return pSegState;
}

void CPerformance::ClearMusicStoppedNotification()

{
    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPMsg;
    PRIV_PMSG* pNext;
    DMUS_NOTIFICATION_PMSG* pNotification;

    pPMsg = m_OnTimeQueue.GetHead(); // where notifications live normally
    for (; pPMsg ; pPMsg = pNext)
    {
        pNext = pPMsg->pNext;
        pNotification = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPMsg);
        if( ( pPMsg->dwType == DMUS_PMSGT_NOTIFICATION ) &&
            ( pNotification->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE ) &&
            ( pNotification->dwNotificationOption == DMUS_NOTIFICATION_MUSICSTOPPED ) )
        {
            pPMsg = m_OnTimeQueue.Dequeue(pPMsg);
            if( pPMsg ) // Should always succeeed
            {
                FreePMsg(pPMsg);
            }
            m_fMusicStopped = FALSE;
        }
    }
    LeaveCriticalSection(&m_PipelineCrSec);
}

HRESULT CPerformance::PlayOneSegment(
    CSegment* pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    CSegState **ppSegState,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
#ifdef DBG_PROFILE
    DWORD dwDebugTime;
    dwDebugTime = timeGetTime();
#endif

    TraceI(0,"Play Segment %lx (%ls) at time %ld with flags %lx\n",pSegment,pSegment->m_wszName,(long)i64StartTime,dwFlags);
    if( dwFlags & DMUS_SEGF_CONTROL )
    {
        dwFlags |= DMUS_SEGF_SECONDARY;
    }
    if( i64StartTime )
    {
        if(dwFlags & DMUS_SEGF_REFTIME)
        {
            // Give a grace period of 100ms.
            if( i64StartTime < (GetLatency() - (100 * REF_PER_MIL)))
            {
                Trace(1,"Error: Unable to play segment, requested clock time %ld is past current time %ld\n",
                    (long)i64StartTime,(long)(GetLatency() - (100 * REF_PER_MIL)));
                return DMUS_E_TIME_PAST;
            }
        }
        else
        {
            MUSIC_TIME mtPrePlay;
            // Give a grace period of 100ms.
            ReferenceToMusicTime( (GetLatency() - (100 * REF_PER_MIL)), &mtPrePlay );
            if( (MUSIC_TIME)i64StartTime < mtPrePlay )
            {
                Trace(1,"Error: Unable to play segment, requested music time %ld is past current time %ld\n",
                    (long)i64StartTime,(long)mtPrePlay);
                return DMUS_E_TIME_PAST;
            }
        }
    }

    CSegState *pSegState = NULL;
    hr = pSegment->CreateSegmentState( &pSegState, this, pAudioPath, dwFlags);
    *ppSegState = pSegState;
    if (FAILED(hr))
    {
        Trace(1,"Error: Unable to play segment because of failure creating segment state.\n");
        return DMUS_E_SEGMENT_INIT_FAILED;
    }
    pSegState->m_rtGivenStart = i64StartTime;

    pSegState->m_dwPlaySegFlags = dwFlags;

    // add the pSegState to the appropriate queue
    EnterCriticalSection(&m_SegmentCrSec);
    m_fPlaying = 1; // turn on the transport
    // add all notifications to the segment. First, clear it, in case old notifications
    // are in effect.
    pSegment->RemoveNotificationType(GUID_NULL,TRUE);
    CNotificationItem* pItem;
    pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pSegment->AddNotificationType( pItem->guidNotificationType, TRUE );
        pItem = pItem->GetNext();
    }

    if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERPREPARETIME )
    {
        // we want to queue this at the last transported time,
        // so we don't need to do an invalidate
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            REFERENCE_TIME rtTrans;
            MusicToReferenceTime( m_mtTransported, &rtTrans );
            if( pSegState->m_rtGivenStart < rtTrans )
            {
                pSegState->m_dwPlaySegFlags &= ~DMUS_SEGF_REFTIME;
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
        else
        {
            if( pSegState->m_rtGivenStart < m_mtTransported )
            {
                pSegState->m_rtGivenStart = m_mtTransported;
            }
        }
    }
    else if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_AFTERQUEUETIME )
    {
        // we want to queue this at the queue time, as opposed to latency time,
        // which is an option for secondary segments.
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( pSegState->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
        {
            if( pSegState->m_rtGivenStart < rtStart )
            {
                pSegState->m_rtGivenStart = rtStart;
            }
        }
        else
        {
            MUSIC_TIME mtStart;
            ReferenceToMusicTime( rtStart, &mtStart );
            if( pSegState->m_rtGivenStart < mtStart )
            {
                pSegState->m_rtGivenStart = mtStart;
            }
        }
    }
    // need to get rid of any pending musicstopped notifications
    ClearMusicStoppedNotification();

    pSegState->AddRef();

    if( dwFlags & DMUS_SEGF_SECONDARY ) // queue a secondary segment
    {
        QueueSecondarySegment( pSegState );
    }
    else // queue a primary segment
    {
        QueuePrimarySegment( pSegState );
    }

    LeaveCriticalSection(&m_SegmentCrSec);

#ifdef DBG_PROFILE
    dwDebugTime = timeGetTime() - dwDebugTime;
    TraceI(5, "perf, debugtime PlaySegment %u\n", dwDebugTime);
#endif

    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );

    return S_OK;
}


HRESULT CPerformance::PlaySegmentInternal(
    CSegment* pSegment,
    CSong * pSong,
    WCHAR *pwzSegmentName,
    CSegment* pTransition,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    CAudioPath *pAudioPath)
{
    HRESULT hr;
    CAudioPath *pInternalPath = NULL;
    if( m_pClock == NULL )
    {
        Trace(1,"Error: Can not play segment because master clock has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    if (pAudioPath && (pAudioPath->NoPorts()))
    {
        // This audiopath can't be used for playback since it doesn't have any ports.
        Trace(1,"Error: Audiopath can't be used for playback because it doesn't have any ports.\n");
        return DMUS_E_AUDIOPATH_NOPORT;
    }

    // Pointer to segment or song provided audio path config.
    IUnknown *pConfig = NULL;

    /*  If this is a song, use the segment name to get the segment.
        Then, it looks like a normal segment except the
        existence of the pSong will let the segstate know
        that it is a member of a song, so it should chain segments.
    */
    if (pSong)
    {
        IDirectMusicSegment *pISegment = NULL;
        hr = pSong->GetSegment(pwzSegmentName,&pISegment);
        if (hr != S_OK)
        {
            return DMUS_E_NOT_FOUND;
        }
        pSegment = (CSegment *) pISegment;
        // If the app wants an audiopath created dynamically from the song, find it and use it.
        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
        {
            pSong->GetAudioPathConfig(&pConfig);
        }
    }
    else if (pSegment)
    {
        // Addref so we can release later.
        pSegment->AddRef();
    }
    else
    {
        // No Segment!
        Trace(1,"Error: No segment - nothing to play!\n");
        return E_FAIL;
    }
    if (dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwResTemp;
        pSegment->GetDefaultResolution( &dwResTemp );
        dwFlags &= ~DMUS_SEGF_DEFAULT;
        dwFlags |= dwResTemp;
    }
    // If the app wants an audiopath created dynamically from the segment, find it and use it.
    // Note that this overrides an audiopath created from the song.
    if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
    {
        IUnknown *pSegConfig;
        if (SUCCEEDED(pSegment->GetAudioPathConfig(&pSegConfig)))
        {
            if (pConfig)
            {
                pConfig->Release();
            }
            pConfig = pSegConfig;
        }
    }

    // If we got an audiopath config from the segment or song, use it.
    if (pConfig)
    {
        IDirectMusicAudioPath *pNewPath;
        if (SUCCEEDED(CreateAudioPath(pConfig,TRUE,&pNewPath)))
        {
            // Now, get the CAudioPath structure.
            if (SUCCEEDED(pNewPath->QueryInterface(IID_CAudioPath,(void **) &pInternalPath)))
            {
                pAudioPath = pInternalPath;
            }
            pNewPath->Release();
        }
        else
        {
            pConfig->Release();
            Trace(1,"Error: Embedded audiopath failed to create, segment will not play.\n");
            return DMUS_E_NO_AUDIOPATH;
        }
        pConfig->Release();
    }

    if (pTransition)
    {
        pTransition->AddRef();
    }

    if ((dwFlags & DMUS_SEGF_SECONDARY) && (dwFlags & DMUS_SEGF_QUEUE))
    {
        // Can only queue if there's a segment to queue after.
        if (pFrom)
        {
            CSegState *pSegFrom = NULL;
            if (SUCCEEDED(pFrom->QueryInterface(IID_CSegState,(void **) &pSegFrom)))
            {
                // Calculate the time at which the preceding segment will stop.
                MUSIC_TIME mtStartTime = pSegFrom->GetEndTime( pSegFrom->m_mtResolvedStart );
                i64StartTime = mtStartTime;
                dwFlags &= ~DMUS_SEGF_REFTIME;
                pSegFrom->Release();
            }
        }
    }

    // If auto-transition is requested,
    // get the transition template, if it exists,
    // and compose a segment with it.
    CSegment *pPlayAfter = NULL;    // This will hold the second segment, if we end up with a transition.
    DWORD dwFlagsAfter = dwFlags & (DMUS_SEGF_SECONDARY | DMUS_SEGF_CONTROL);
    if ( dwFlags & DMUS_SEGF_AUTOTRANSITION )
    {
        // First, calculate the time to start the transition.
        // Note: this will be done again later. We really need to fold this all together.
        REFERENCE_TIME rtTime;
        if (i64StartTime == 0)
        {
            GetQueueTime( &rtTime );
        }
        else if (dwFlags & DMUS_SEGF_REFTIME)
        {
            rtTime = i64StartTime;
        }
        else
        {
            MusicToReferenceTime((MUSIC_TIME) i64StartTime,&rtTime);
        }
        REFERENCE_TIME rtResolved;
        GetResolvedTime(rtTime, &rtResolved,dwFlags);
        MUSIC_TIME mtTime;  // Actual time to start transition.
        ReferenceToMusicTime(rtResolved,&mtTime);

        CSegment *pPriorSeg = NULL;
        // Find the segment that is active at transition time.
        CSegState *pPriorState = GetSegmentForTransition(dwFlags,mtTime,pFrom);
        if (pPriorState)
        {
            pPriorSeg = pPriorState->m_pSegment;
        }
        // If this is a song, use the id to get the transition.
        if (pSong && !pTransition)
        {
            DMUS_IO_TRANSITION_DEF Transition;
            // Now, find out what sort of transition is expected.
            if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,pSegment,&Transition)))
            {
                if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                {
                    if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                    {
                        dwFlags = Transition.dwPlayFlags;
                    }
                }
                else
                {
                    dwFlags = Transition.dwPlayFlags;
                }
            }
        }
        if (pTransition)
        {
            IDirectMusicSegment *pITransSegment = NULL;
            if (pPriorState)
            {
                pTransition->Compose(mtTime - pPriorState->m_mtOffset, pPriorSeg, pSegment, &pITransSegment);
            }
            else
            {
                pTransition->Compose(0,pPriorSeg,pSegment,&pITransSegment);
            }
            // Now, if we successfully composed a transition segment, set it up to be the one we
            // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
            // to play after the transition.
            if (pITransSegment)
            {
                pPlayAfter = pSegment;
                pSegment = (CSegment *) pITransSegment;
            }
        }
    }
    if (pSegment)
    {
        CSegState *pSegState;
        if (!pAudioPath)
        {
            pAudioPath = m_pDefaultAudioPath;
        }
        if (pAudioPath && !pAudioPath->IsActive())
        {
            Trace(1,"Error: Can not play segment on inactive audiopath\n");
            hr = DMUS_E_AUDIOPATH_INACTIVE;
        }
        else if ((m_dwAudioPathMode != 1) && !pAudioPath)
        {
            Trace(1,"Error: No audiopath to play segment on.\n");
            hr = DMUS_E_NO_AUDIOPATH;
        }
        else
        {
            if (ppSegmentState)
            {
                *ppSegmentState = NULL;
            }
            hr = PlayOneSegment(
                pSegment,
                dwFlags,
                i64StartTime,
                &pSegState,
                pAudioPath);
            if (SUCCEEDED(hr))
            {
                if (pFrom)
                {
                    pSegState->m_fCanStop = FALSE;
                    StopEx(pFrom, pSegState->m_mtResolvedStart, 0);
                    pSegState->m_fCanStop = TRUE;
                }
                // If this was actually a transition segment, now we need to play the original segment!
                if (pPlayAfter)
                {
                    MUSIC_TIME mtStartTime = pSegState->GetEndTime(pSegState->m_mtResolvedStart );
                    pSegState->Release();
                    hr = PlayOneSegment(pPlayAfter,dwFlagsAfter,mtStartTime,&pSegState,pAudioPath);
                }
                if (SUCCEEDED(hr))
                {
                    if (pSong)
                    {
                        pSegState->m_fSongMode = TRUE;
                    }
                    if (ppSegmentState)
                    {
                        *ppSegmentState = pSegState;
                    }
                    else
                    {
                        pSegState->Release();
                    }
                }
            }
        }
    }
    else
    {
        // There never was a segment to play, not even a transition.
        Trace(1,"Error: No segment to play.\n");
        hr = E_INVALIDARG;
    }
    // Before leaving, reduce the reference counts on variables that have been addref'd.
    if (pSegment)
    {
        pSegment->Release();
    }
    if (pTransition)
    {
        pTransition->Release();
    }
    if (pPlayAfter)
    {
        pPlayAfter->Release();
    }
    if (pInternalPath)
    {
        pInternalPath->Release();
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegment(
    IDirectMusicSegment *pSegment,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState **ppSegmentState)
{
    V_INAME(IDirectMusicPerformance::PlaySegment);
    V_INTERFACE(pSegment);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    CSegment *pCSourceSegment = NULL;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
    {
        pCSourceSegment->Release();
    }
    else
    {
        Trace(1,"Error: Invalid segment object passed to PlaySegment(). Segment must be created using CLSID_DirectMusicSegment object.\n");
        return E_POINTER;
    }
    return PlaySegmentInternal(pCSourceSegment,NULL,0,NULL,dwFlags,i64StartTime,ppSegmentState,NULL,NULL);
}

HRESULT STDMETHODCALLTYPE CPerformance::PlaySegmentEx(
    IUnknown* pSource,
    WCHAR *pwzSegmentName,
    IUnknown* pTransition,
    DWORD dwFlags,
    __int64 i64StartTime,
    IDirectMusicSegmentState** ppSegmentState,
    IUnknown *pFrom,
    IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::PlaySegmentEx);
    V_INTERFACE_OPT(pSource);
    V_INTERFACE_OPT(pTransition);
    V_PTRPTR_WRITE_OPT(ppSegmentState);
    V_INTERFACE_OPT(pFrom);
    V_INTERFACE_OPT(pAudioPath);

    CSegment *pCSourceSegment = NULL;
    CSong *pCSourceSong = NULL;
    CSegment *pCTransition = NULL;
    CAudioPath *pCAudioPath = NULL;
//    TraceI(0,"Playing %lx at time %ld, flags %lx, Transition %lx\n",pSource,(long)i64StartTime,dwFlags,pTransition);

    // We may not have a source segment in the special case of transitioning from NULL.
    if (!pSource && !pTransition)
    {
        Trace(1,"Error: Must pass either a segment or transition segment to PlaySegmentEx()\n");
        return E_POINTER;
    }
    if (pSource)
    {
        // Figure out if we have a source song or segment and get the internal representations.
        if (SUCCEEDED(pSource->QueryInterface(IID_CSegment,(void **) &pCSourceSegment)))
        {
            pCSourceSegment->Release();
        }
        else if (SUCCEEDED(pSource->QueryInterface(IID_CSong,(void **) &pCSourceSong)))
        {
            pCSourceSong->Release();
        }
        else
        {
            Trace(1,"Error: Invalid segment or song passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    // If we have a transition segment, get the CSegment representation.
    if (pTransition)
    {
        if (SUCCEEDED(pTransition->QueryInterface(IID_CSegment,(void **) &pCTransition)))
        {
            pCTransition->Release();
        }
        else
        {
            Trace(1,"Error: Invalid transition passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCAudioPath)))
        {
            pCAudioPath->Release();
        }
        else
        {
            Trace(1,"Error: Invalid audiopath passed to PlaySegmentEx().\n");
            return E_POINTER;
        }
    }
    return PlaySegmentInternal(pCSourceSegment,pCSourceSong,pwzSegmentName,
        pCTransition,dwFlags,i64StartTime,
        ppSegmentState,pFrom,
        pCAudioPath);
}

STDMETHODIMP CPerformance::SetDefaultAudioPath(IDirectMusicAudioPath *pAudioPath)
{
    V_INAME(IDirectMusicPerformance::SetDefaultAudioPath);
    V_INTERFACE_OPT(pAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance initialized not to support Audiopaths.\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    CAudioPath *pCPath = NULL;
    if (pAudioPath)
    {
        if (SUCCEEDED(pAudioPath->QueryInterface(IID_CAudioPath,(void **) &pCPath)))
        {
            pCPath->Release();
            if (!m_AudioPathList.IsMember(pCPath))
            {
                // This is not a legal audiopath, since it wasn't created by this performance.
                Trace(1,"Error: Invalid audiopath - not created by this Performance.\n");
                return E_INVALIDARG;
            }
            if (pCPath->NoPorts())
            {
                // This is an audiopath that doesn't have any port configurations.
                // For example, it might be environmental reverb.
                Trace(1,"Error: Failure setting default audiopath - does not have any ports, so can not be played on.\n");
                return DMUS_E_AUDIOPATH_NOPORT;
            }
        }
        else
        {
            // This is not a legal audiopath object at all.
            Trace(1,"Error: Invalid audiopath - not created by call to Performance->CreateAudioPath().\n");
            return E_INVALIDARG;
        }
    }
    if (m_pDefaultAudioPath)
    {
        m_pDefaultAudioPath->Release();
        m_pDefaultAudioPath = NULL;
    }
    m_pDefaultAudioPath = pCPath;
    if (pCPath)
    {
        pCPath->AddRef();
        pCPath->Activate(TRUE);
    }
    return S_OK;
}

STDMETHODIMP CPerformance::GetDefaultAudioPath(IDirectMusicAudioPath **ppAudioPath)
{
    V_INAME(IDirectMusicPerformance::GetDefaultAudioPath);
    V_PTRPTR_WRITE(ppAudioPath);
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance was initialized not to support audiopaths.\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    if (m_pDefaultAudioPath)
    {
        *ppAudioPath = (IDirectMusicAudioPath *) m_pDefaultAudioPath;
        m_pDefaultAudioPath->AddRef();
        return S_OK;
    }
    Trace(3,"Warning: No default audiopath\n");
    return DMUS_E_NOT_FOUND;
}

HRESULT STDMETHODCALLTYPE CPerformance::CreateAudioPath( IUnknown *pSourceConfig,
                                                        BOOL fActivate,
                                                        IDirectMusicAudioPath **ppNewPath)

{
    V_INAME(IDirectMusicPerformance::CreateAudioPath);
    V_INTERFACE(pSourceConfig);
    V_PTRPTR_WRITE_OPT(ppNewPath);

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    if (m_dwAudioPathMode == 1)
    {
        Trace(1,"Error: Performance not initialized to support audiopaths (must use InitAudio.)\n");
        return DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    HRESULT hr = E_OUTOFMEMORY;
    CAudioPath *pPath = new CAudioPath;
    if (pPath)
    {
        hr = pPath->Init(pSourceConfig,this);
        if (SUCCEEDED(hr) && fActivate)
        {
            hr = pPath->Activate(TRUE);
#ifdef DBG
            if (FAILED(hr))
            {
                Trace(1,"Error: Audiopath creation failed because one or more buffers could not be activated.\n");
            }
#endif
        }
        if (SUCCEEDED(hr))
        {
            hr = pPath->QueryInterface(IID_IDirectMusicAudioPath,(void **) ppNewPath);
        }
        else
        {
            delete pPath;
        }
    }
    return hr;
}

STDMETHODIMP CPerformance::CreateStandardAudioPath(DWORD dwType,
                                                   DWORD dwPChannelCount,
                                                   BOOL fActivate,
                                                   IDirectMusicAudioPath **ppNewPath)
{
    V_INAME(IDirectMusicPerformance::CreateStandardAudioPath);
    V_PTRPTR_WRITE_OPT(ppNewPath);
    HRESULT hr = S_OK;
    if (m_dwAudioPathMode == 2)
    {
        if ((dwType <= DMUS_APATH_DYNAMIC_STEREO) && (dwType >= DMUS_APATH_DYNAMIC_3D)
            || (dwType == DMUS_APATH_SHARED_STEREOPLUSREVERB))
        {
            if (!(m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS))
            {
                Trace(4,"Warning: Creating a standard audiopath without buffers - InitAudio specified no buffer support.\n");
                // If the default synth doesn't support buffers, then create a simple port with no buffers.
                dwType = 0;
            }
            CAudioPathConfig *pConfig = CAudioPathConfig::CreateStandardConfig(dwType,dwPChannelCount,m_AudioParams.dwSampleRate);
            if (pConfig)
            {
                hr = CreateAudioPath((IPersistStream *) pConfig,fActivate,ppNewPath);
                pConfig->Release();
            }
            else
            {
                // CreateStandardConfig only returns NULL if we've run out of memory.
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            Trace(1,"Error: %ld is not a valid predefined audiopath.\n",dwType);
            hr  = E_INVALIDARG;
        }
    }
    else
    {
        Trace(1,"Error: Performance not initialized to support audiopaths.\n");
        hr = DMUS_E_AUDIOPATHS_NOT_VALID;
    }
    return hr;
}

// Stop the segment state at mtTime. If NULL, stop all.
void CPerformance::DoStop( CSegState* pSegState, MUSIC_TIME mtTime,
                                     BOOL fInvalidate)
{
    HRESULT hrAbort = S_OK;
    DWORD dwCount;
    if( NULL == pSegState ) return;
    EnterCriticalSection(&m_SegmentCrSec);
    CSegStateList *pSourceList = NULL;
    CSegStateList *pDestList = NULL;
    CSegState *pNode = NULL;
    // Mark the length of the segstate to be only as far as it played
    // to keep GetParam() from accessing the unplayed portion.
    if (pSegState)
    {
        if (mtTime < pSegState->m_mtEndTime)
        {
            pSegState->m_mtLength = mtTime - pSegState->m_mtResolvedStart +
                pSegState->m_mtStartPoint;
            if (pSegState->m_mtLength < 0)
            {
                pSegState->m_mtLength = 0;
            }
            // Make endtime one greater than mtTime so Abort notification will still happen.
            pSegState->m_mtEndTime = mtTime + 1;
        }
    }
    RecalcTempoMap(pSegState,mtTime);
    // check each play queue
    for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
        {
            if( pNode == pSegState )
            {
                // we want to move this to the approprate done queue
                pDestList = &m_SegStateQueues[SQ_PRI_DONE - SQ_PRI_PLAY + dwCount];
                pSourceList = &m_SegStateQueues[dwCount];
                if ((dwCount == SQ_PRI_PLAY) && (m_SegStateQueues[SQ_PRI_PLAY].GetCount() == 1))
                {
                    if (m_dwVersion >= 8)
                    {
                        MUSIC_TIME mtNow;
                        GetTime( NULL, &mtNow );
                        GenerateNotification( DMUS_NOTIFICATION_MUSICALMOSTEND, mtNow, pSegState );
                    }
                }
                dwCount = SQ_SEC_PLAY;  // Force out of outer loop.
                break;
            }
        }
    }
    if (!pNode)
    {
        // check each done queue
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext())
            {
                if( pNode == pSegState )
                {
                    pSourceList = &m_SegStateQueues[dwCount];
                    dwCount = SQ_SEC_DONE;  // Force out of outer loop.
                    break;
                }
            }
        }
    }
    if( pNode && pSourceList)
    {
        REFERENCE_TIME rtTime;
        MusicToReferenceTime(mtTime,&rtTime);
        if( pNode->m_mtLastPlayed >= mtTime )
        {
            pNode->Flush( mtTime );
            pNode->m_mtLastPlayed = mtTime; // must set this to indicate it only played until then
            pNode->m_rtLastPlayed = rtTime;
        }
        if( fInvalidate )
        {
            if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
            {
                Invalidate( mtTime, 0 ); // must call Invalidate before AbortPlay so we don't
                // invalidate the abort notification
            }
            else if ( !(pNode->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY ))
            {
                // If this is a primary segment, kill the tempo map.
                FlushEventQueue( 0, &m_TempoMap, rtTime, rtTime, FALSE );
            }
        }
        hrAbort = pNode->AbortPlay( mtTime, FALSE );
        if( pNode->m_dwPlaySegFlags & DMUS_SEGF_CONTROL )
        {
            pSourceList->Remove(pNode);
            m_ShutDownQueue.Insert(pNode); // we're guaranteed to never need this again

            // set dirty flags on all other segments

            for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if( pNode->m_fStartedPlay )
                    {
                        pNode->m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
                    }
                }
            }
        }
        else if( pDestList )
        {
            pSourceList->Remove(pNode);
            pDestList->Insert(pNode);
        }
    }
    else
    {
        // check the wait lists.
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode == pSegState )
                {
                    hrAbort = pNode->AbortPlay( mtTime, FALSE );
                    m_SegStateQueues[dwCount].Remove(pNode);
                    RecalcTempoMap(pNode, mtTime);
                    m_ShutDownQueue.Insert(pNode);
                    break;
                }
            }
        }
    }
    // if there aren't any more segments to play, send a Music Stopped
    // notification
    if( m_SegStateQueues[SQ_PRI_PLAY].IsEmpty() && m_SegStateQueues[SQ_SEC_PLAY].IsEmpty() &&
        m_SegStateQueues[SQ_PRI_WAIT].IsEmpty() && m_SegStateQueues[SQ_SEC_WAIT].IsEmpty() &&
        m_SegStateQueues[SQ_CON_PLAY].IsEmpty() && m_SegStateQueues[SQ_CON_WAIT].IsEmpty())
    {
        m_fMusicStopped = TRUE;
        // S_FALSE means we tried to abort this segstate, but it's already been aborted
        if (hrAbort != S_FALSE)
        {
            GenerateNotification( DMUS_NOTIFICATION_MUSICSTOPPED, mtTime, NULL );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

// Stop all segment states based off of the segment.
void CPerformance::DoStop( CSegment* pSeg, MUSIC_TIME mtTime, BOOL fInvalidate )
{
    DWORD dwCount;
    CSegState* pNode;
    CSegState* pNext;
    EnterCriticalSection(&m_SegmentCrSec);
    // find all seg pSegStates based off this segment that have played through time mtTime
    // if pSeg is NULL, go through all of the segment lists. Flush any
    // segment that played through time mtTime. Move any active segments
    // into past lists.
    if( pSeg )
    {
        for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
        {
            pNode = m_SegStateQueues[dwCount].GetHead();
            while( pNode )
            {
                pNext = pNode->GetNext();
                if( pNode->m_pSegment == pSeg )
                {
                    if (IsDoneQueue(dwCount))
                    {
                        if (pNode->m_mtLastPlayed >= mtTime)
                        {
                             DoStop( pNode, mtTime, fInvalidate );
                        }
                    }
                    else
                    {
                        DoStop( pNode, mtTime, fInvalidate );
                    }
                }
                pNode = pNext;
            }
        }
    }
    else // pSeg is NULL, stop everything.
    {
        // go ahead and flush the event queues
        EnterCriticalSection(&m_PipelineCrSec);
        FlushMainEventQueues( 0, mtTime, mtTime, FALSE );
        LeaveCriticalSection(&m_PipelineCrSec);
        // clear out the wait lists
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_WAIT; dwCount++)
        {
            while (pNode = m_SegStateQueues[dwCount].GetHead())
            {
                pNode->AbortPlay( mtTime, FALSE );
                m_SegStateQueues[dwCount].RemoveHead();
                m_ShutDownQueue.Insert(pNode);
            }
        }
        // stop any segment that is currently playing.
        for (dwCount = SQ_PRI_DONE; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( pNode->m_mtLastPlayed >= mtTime )
                {
                    DoStop( pNode, mtTime, fInvalidate );
                }
            }
        }
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            while( m_SegStateQueues[dwCount].GetHead() )
            {
                DoStop( m_SegStateQueues[dwCount].GetHead(), mtTime, fInvalidate );
            }
        }
        // reset controllers and force all notes off.
        ResetAllControllers( GetLatency() );
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}


STDMETHODIMP CPerformance::StopEx(IUnknown *pObjectToStop,__int64 i64StopTime,DWORD dwFlags)
{
    V_INAME(IDirectMusicPerformance::StopEx);
    V_INTERFACE_OPT(pObjectToStop);
    HRESULT hr = E_INVALIDARG;
    IDirectMusicSegmentState *pState;
    IDirectMusicSegment *pSegment;
    CSong *pSong;
    CAudioPath *pAudioPath;
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
TraceI(0,"StopExing %lx at time %ld, flags %lx\n",pObjectToStop,(long)i64StopTime,dwFlags);
    if (pObjectToStop == NULL)
    {
        return Stop(NULL,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
    }
    if (dwFlags & DMUS_SEGF_AUTOTRANSITION)
    {
        // I this is an autotransition, it will only work if the currently playing segment in question
        // is a member of a song. So, check the segstate, segment, song, and audiopath
        // to find the segstate. And, if found, see if it is part of a song. If so,
        // then go ahead and do the transition.
        EnterCriticalSection(&m_SegmentCrSec);
        BOOL fTransition = FALSE;
        dwFlags &= ~DMUS_SEGF_AUTOTRANSITION;
        CSegState *pCState = NULL;
        // First, see if this is a segstate.
        HRESULT hrTemp = pObjectToStop->QueryInterface(IID_CSegState,(void **)&pCState);
        if (FAILED(hrTemp))
        {
            // Segstate failed. Is this a Song? If so, find the first correlating segstate.
            CSong *pCSong = NULL;
            CAudioPath *pCAudioPath = NULL;
            CSegment *pCSegment = NULL;
            hrTemp = pObjectToStop->QueryInterface(IID_CSong,(void **)&pCSong);
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CSegment,(void **)&pCSegment);
            }
            if (FAILED(hrTemp))
            {
                hrTemp = pObjectToStop->QueryInterface(IID_CAudioPath,(void **)&pCAudioPath);
            }
            if (SUCCEEDED(hrTemp))
            {
                CSegState *pNode;
                DWORD dwCount;
                for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
                {
                    for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                    {
                        if (pNode->m_fCanStop)
                        {
                            // Can only do this if the segstate ultimately points to a song.
                            if (pNode->m_pSegment && pNode->m_pSegment->m_pSong)
                            {
                                if ((pNode->m_pSegment == pCSegment) ||
                                    (pNode->m_pSegment->m_pSong == pCSong) ||
                                    (pCAudioPath && (pNode->m_pAudioPath == pCAudioPath)))
                                {
                                    pCState = pNode;
                                    pCState->AddRef();
                                    break;
                                }
                            }
                        }
                    }
                    if (pCState) break;
                }
            }
            if (pCSong) pCSong->Release();
            else if (pCAudioPath) pCAudioPath->Release();
            else if (pCSegment) pCSegment->Release();
        }
        if (pCState)
        {
            CSegment *pPriorSeg = pCState->m_pSegment;
            if (pPriorSeg)
            {
                pSong = pPriorSeg->m_pSong;
                if (pSong)
                {
                    // If this is an autotransition, compose a transition segment from the
                    // current position in the song and play it.
                    // This will, in turn, call stop on the song, so we don't need to do it here.
                    // First, calculate the time to start the transition.
                    REFERENCE_TIME rtTime;
                    if (i64StopTime == 0)
                    {
                        GetQueueTime( &rtTime );
                    }
                    else if (dwFlags & DMUS_SEGF_REFTIME)
                    {
                        rtTime = i64StopTime;
                    }
                    else
                    {
                        MusicToReferenceTime((MUSIC_TIME) i64StopTime,&rtTime);
                    }
                    REFERENCE_TIME rtResolved;
                    GetResolvedTime(rtTime, &rtResolved,dwFlags);
                    MUSIC_TIME mtTime;  // Actual time to start transition.
                    ReferenceToMusicTime(rtResolved,&mtTime);

                    CSegment *pTransition = NULL;
                    // Now, get the transition.
                    DMUS_IO_TRANSITION_DEF Transition;
                    if (SUCCEEDED(pSong->GetTransitionSegment(pPriorSeg,NULL,&Transition)))
                    {
                        if (Transition.dwTransitionID != DMUS_SONG_NOSEG)
                        {
                            if (S_OK == pSong->GetPlaySegment(Transition.dwTransitionID,&pTransition))
                            {
                                dwFlags = Transition.dwPlayFlags;
                            }
                        }
                    }
                    if (pTransition)
                    {
                        IDirectMusicSegment *pITransSegment = NULL;
                        pTransition->Compose(mtTime - pCState->m_mtOffset, pPriorSeg, NULL, &pITransSegment);
                        // Now, if we successfully composed a transition segment, set it up to be the one we
                        // will play first. Later, we fill call PlaySegment() with pPlayAfter, to queue it
                        // to play after the transition.
                        if (pITransSegment)
                        {
                            hr = PlaySegmentEx(pITransSegment,NULL,NULL,dwFlags,i64StopTime,NULL,(IDirectMusicSegmentState *)pCState,NULL);
                            pITransSegment->Release();
                            fTransition = TRUE;
                        }
                        pTransition->Release();
                    }
                }
            }
            pCState->Release();
        }
        LeaveCriticalSection(&m_SegmentCrSec);
        if (fTransition)
        {
            return hr;
        }
    }
    if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegmentState,(void **) &pState)))
    {
        hr = Stop(NULL,pState,(MUSIC_TIME)i64StopTime,dwFlags);
        pState->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_IDirectMusicSegment,(void **) &pSegment)))
    {
        hr = Stop(pSegment,NULL,(MUSIC_TIME)i64StopTime,dwFlags);
        pSegment->Release();
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CAudioPath,(void **) &pAudioPath)))
    {
        pAudioPath->Release();
        EnterCriticalSection(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            CSegState *pNext;
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNext )
            {
                pNext = pNode->GetNext();
                if (pNode->m_fCanStop && (pNode->m_pAudioPath == pAudioPath))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    else if (SUCCEEDED(pObjectToStop->QueryInterface(IID_CSong,(void **) &pSong)))
    {
        pSong->Release();
        EnterCriticalSection(&m_SegmentCrSec);
        CSegState *pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_WAIT; dwCount <= SQ_SEC_DONE; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if (pNode->m_fCanStop && pNode->m_pSegment && (pNode->m_pSegment->m_pSong == pSong))
                {
                    hr = Stop(NULL,(IDirectMusicSegmentState *)pNode,(MUSIC_TIME)i64StopTime,dwFlags);
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
     }

    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::Stop(
    IDirectMusicSegment *pISegment, // @parm The Segment to stop playing. All SegmentState's based upon this Segment are
                                    // stopped playing at time <p mtTime>.
    IDirectMusicSegmentState *pISegmentState, // @parm The SegmentState to stop playing.
    MUSIC_TIME mtTime,  // @parm The time at which to stop the Segments, Segment State, or everything. If
                                    // this time is in the past, stop everything right away. Therefore, a value of
                                    // 0 indicates stop everything NOW.
    DWORD dwFlags)      // @parm Flag that indicates whether we should stop immediately at time <p mtTime>,
                                    // or on the grid, measure, or beat following <p mtTime>. This is only valid in
                                    // relation to the currently playing primary segment. (For flag descriptions,
                                    // see <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicPerformance::Stop);
    V_INTERFACE_OPT(pISegment);
    V_INTERFACE_OPT(pISegmentState);

    EnterCriticalSection(&m_SegmentCrSec);

    CSegment *pSegment = NULL;
    CSegState *pSegmentState = NULL;
TraceI(0,"Stopping Segment %lx, SegState %lx at time %ld, flags %lx\n",pISegment,pISegmentState,mtTime,dwFlags);
    if (pISegmentState)
    {
        if (SUCCEEDED(pISegmentState->QueryInterface(IID_CSegState,(void **)&pSegmentState)))
        {
            pISegmentState->Release();
        }
        else
        {
            Trace(1,"Error: Pointer in SegState parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pISegment)
    {
        if (SUCCEEDED(pISegment->QueryInterface(IID_CSegment,(void **)&pSegment)))
        {
            pISegment->Release();
        }
        else
        {
            Trace(1,"Error: Pointer in Segment parameter to Stop() is invalid.\n");
            return E_INVALIDARG;
        }
    }
    if (pSegmentState)
    {
        // If this is the starting segstate from a playing song, find the
        // current active segstate within that song.
        // The current active segstate keeps a pointer to
        // this segstate.
        if (pSegmentState->m_fSongMode)
        {
            CSegState* pNode;
            DWORD dwCount;
            for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                {
                    if (pNode->m_pSongSegState == pSegmentState)
                    {
                        pSegmentState = pNode;
                        dwCount = SQ_COUNT;
                        break;
                    }
                }
            }
        }
    }
    if( dwFlags & DMUS_SEGF_DEFAULT )
    {
        DWORD   dwNewRes = 0;
        if( pSegment )
        {
            pSegment->GetDefaultResolution( &dwNewRes );
        }
        else if( pSegmentState )
        {
            IDirectMusicSegment*    pSegTemp;
            if( SUCCEEDED( pSegmentState->GetSegment( &pSegTemp ) ) )
            {
                pSegTemp->GetDefaultResolution( &dwNewRes );
                pSegTemp->Release();
            }
            else
            {
                dwNewRes = 0;
            }
        }
        else
        {
            dwNewRes = 0;
        }
        dwFlags |= dwNewRes;
        dwFlags &= ~DMUS_SEGF_DEFAULT;
    }
    // Make sure mtTime is greater or equal to QueueTime, which is the last time notes were
    // queued down (or latency time, whichever is later) so we can stop everything after it.
    MUSIC_TIME mtLatency;
    REFERENCE_TIME rtQueueTime;
    GetQueueTime( &rtQueueTime );
    ReferenceToMusicTime( rtQueueTime, &mtLatency );
    if( mtTime < mtLatency ) mtTime = mtLatency;
    // Resolve the time according to the resolution
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // if mtTime is less than the current transported time, we can take
    // care of the Stop now. Otherwise, we need to cue a Stop PMsg and
    // take care of it at QUEUE time.
    if( mtTime <= m_mtTransported )
    {
        if( pSegmentState )
        {
            DoStop( pSegmentState, mtTime, TRUE );
            if( pSegment )
            {
                DoStop( pSegment, mtTime, TRUE );
            }
        }
        else
        {
            DoStop( pSegment, mtTime, TRUE );
        }
    }
    else
    {
        // find and mark the segment and/or segment state to not play beyond
        // the stop point.
        CSegState* pNode;
        DWORD dwCount;
        for (dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++)
        {
            for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
            {
                if( (pNode->m_pSegment == pSegment) ||
                    (pNode == pSegmentState) )
                {
                    if (pNode->m_fCanStop)
                    {
                        pNode->m_mtStopTime = mtTime;
                        // Make sure GetParams ignore the rest of the segment from now on.
                        if (mtTime < pNode->m_mtEndTime)
                        {
                            pNode->m_mtLength = mtTime - pNode->m_mtResolvedStart +
                                pNode->m_mtStartPoint;
                            if (pNode->m_mtLength < 0)
                            {
                                pNode->m_mtLength = 0;
                            }
                            // Make endtime one greater than mtTime so Abort notification will still happen.
                            pNode->m_mtEndTime = mtTime + 1;
                        }
                        // Force the tempo map to be recalculated IF this has a tempo track.
                        RecalcTempoMap(pNode,mtTime);
                    }
                }
            }
        }

        // create a Stop PMsg and cue it for QUEUE time
        // I've removed this to fix bugs. A stop message at queue time, 
        // if in a controlling or primary segment, results in invalidation.
        // This is particularily bad for controlling segments.
        // Can't figure out why we even need the stop message...
/*      DMUS_PMSG* pPMsg;

        if( SUCCEEDED( AllocPMsg( sizeof(DMUS_PMSG), &pPMsg )))
        {
            pPMsg->dwType = DMUS_PMSGT_STOP;
            pPMsg->mtTime = mtTime;
            pPMsg->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_QUEUE;
            if( pSegment )
            {
                pSegment->QueryInterface( IID_IUnknown, (void**)&pPMsg->punkUser );
                if( pSegmentState )
                {
                    // if there is also a segment state pointer, we need to create two
                    // pmsg's
                    DMUS_PMSG* pPMsg2;

                    if( SUCCEEDED( AllocPMsg( sizeof(DMUS_PMSG), &pPMsg2 )))
                    {
                        pPMsg2->dwType = DMUS_PMSGT_STOP;
                        pPMsg2->mtTime = mtTime;
                        pPMsg2->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_QUEUE;
                        pSegmentState->QueryInterface( IID_IUnknown, (void**)&pPMsg2->punkUser );
                        pPMsg2->pTool = this;
                        AddRef();
                        if(FAILED(SendPMsg( pPMsg2 )))
                        {
                            FreePMsg(pPMsg2);
                        }
                    }
                }
            }
            else if( pSegmentState )
            {
                pSegmentState->QueryInterface( IID_IUnknown, (void**)&pPMsg->punkUser );
            }
            pPMsg->pTool = this;
            AddRef();
            if(FAILED(SendPMsg( pPMsg )))
            {
                FreePMsg(pPMsg);
            }
        }*/
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return S_OK;
}

void CPerformance::ResetAllControllers(CChannelMap* pChannelMap, REFERENCE_TIME rtTime, bool fGMReset)

{
    DWORD dwIndex = pChannelMap->dwPortIndex;
    DWORD dwGroup = pChannelMap->dwGroup;
    DWORD dwMChannel = pChannelMap->dwMChannel;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    IDirectMusicPort* pPort = m_pPortTable[dwIndex].pPort;
    IDirectMusicBuffer* pBuffer = m_pPortTable[dwIndex].pBuffer;
    if( pPort && pBuffer )
    {
        m_pPortTable[dwIndex].fBufferFilled = TRUE;
        if (!rtTime)
        {
            rtTime = m_pPortTable[dwIndex].rtLast + 1;
        }
        else
        {
            m_pPortTable[dwIndex].rtLast = rtTime;
        }
        pChannelMap->Reset(true);
        DWORD dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_ALLSOUNDSOFF << 8); // 0x78 is all sounds off.
        if( FAILED( pBuffer->PackStructured( rtTime, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime, dwGroup, dwMsg );
        }
        dwMsg = dwMChannel | MIDI_CCHANGE | (MIDI_CC_RESETALL << 8) | (1 << 16) ; // 0x79 is reset all controllers. Data byte set to indicate volume and pan too.
        if( FAILED( pBuffer->PackStructured( rtTime + 30 * REF_PER_MIL, dwGroup, dwMsg ) ) )
        {
            pPort->PlayBuffer( pBuffer );
            pBuffer->Flush();
            // try one more time
            pBuffer->PackStructured( rtTime + (30 * REF_PER_MIL), dwGroup, dwMsg );
        }
        // Send one GM Reset per channel group, but only under DX8 (and only if we need to).
        if ((dwMChannel == 0) && (m_dwVersion >= 8) && fGMReset)
        {
            // create a buffer of the right size
            DMUS_BUFFERDESC dmbd;
            IDirectMusicBuffer *pLocalBuffer;
            static BYTE abGMReset[6] = { (BYTE)MIDI_SYSX,0x7E,0x7F,9,1,(BYTE)MIDI_EOX };
            memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
            dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
            dmbd.cbBuffer = 50;

            EnterCriticalSection(&m_MainCrSec);
            if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pLocalBuffer, NULL)))
            {
                if( SUCCEEDED( pLocalBuffer->PackUnstructured( rtTime + (30 * REF_PER_MIL), dwGroup,
                    6, abGMReset ) ) )
                {
                    pPort->PlayBuffer(pLocalBuffer);
                }
                pLocalBuffer->Release();
            }
            LeaveCriticalSection(&m_MainCrSec);
        }
        m_rtEarliestStartTime = rtTime + (60 * REF_PER_MIL); // Give synth chance to stabilize
                                                             // before next start.
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}


void CPerformance::ResetAllControllers( REFERENCE_TIME rtTime )
{
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock;
    SendBuffers();
    for( pChannelBlock = m_ChannelBlockList.GetHead(); pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        CChannelMap* pChannelMap;
        for( DWORD dwPChannel = pChannelBlock->m_dwPChannelStart;
            dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE;
            dwPChannel++ )
        {
            pChannelMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
            if( pChannelMap->dwGroup ) // Valid group?
            {
                // Reset controllers and send a GM reset.
                ResetAllControllers(pChannelMap, rtTime, true);
            }
        }
    }
    SendBuffers();

    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

// internal: return CSegState* at time mtTime
// only call this from within a segment critical section
CSegState* CPerformance::GetPrimarySegmentAtTime( MUSIC_TIME mtTime )
{
    CSegState* pSegNode;
    CSegState* pSegReturn = NULL;
    BOOL fCheckedPri = FALSE;
    for( pSegNode = m_SegStateQueues[SQ_PRI_DONE].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        // if we're checking the past list, only check up until the last time played.
        if( (mtTime >= pSegNode->m_mtResolvedStart) && (mtTime <= pSegNode->m_mtLastPlayed) )
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    for( pSegNode = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
    {
        MUSIC_TIME mtTest = mtTime;
        MUSIC_TIME mtOffset;
        DWORD dwRepeat;
        // if we're checking the current list, check the full segment time
        if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
        {
            pSegReturn = pSegNode;
            break;
        }
    }
    if (!pSegReturn)
    {
        for( pSegNode = m_SegStateQueues[SQ_PRI_WAIT].GetHead(); pSegNode; pSegNode = pSegNode->GetNext() )
        {
            MUSIC_TIME mtTest = mtTime;
            MUSIC_TIME mtOffset;
            DWORD dwRepeat;
            // if we're checking the current list, check the full segment time
            if( S_OK == pSegNode->ConvertToSegTime( &mtTest, &mtOffset, &dwRepeat ))
            {
                pSegReturn = pSegNode;
                break;
            }
        }
    }
    return pSegReturn;
}

/*

  @method HRESULT | IDirectMusicPerformance | GetSegmentState |
  Returns the Primary SegmentState at time <p mtTime>.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | ppSegmentState is NULL or invalid.
  @rvalue DMUS_E_NOT_FOUND | There is no currently playing SegmentState or one at <p mtTime>.

  @comm This function is intended for routines that need to access the currently
  playing SegmentState, e.g. to obtain the chord or command track. "Currently
  Playing" in this context means that it is being called into to perform messages.
  I.e., this includes all latencies and doesn't imply that this
  SegmentState is currenty being "heard" through the speakers.

*/
HRESULT STDMETHODCALLTYPE CPerformance::GetSegmentState(
    IDirectMusicSegmentState **ppSegmentState,  // @parm Returns the SegmentState pointer to the one currently playing.
                                                // The caller is responsible for calling Release on this pointer.
    MUSIC_TIME mtTime ) // @parm Return the SegmentState which played, is playing, or will
                        // be playing at mtTime. To get the currently playing segment, pass the
                        // mtTime retrieved from <om .GetTime>.
{
    V_INAME(IDirectMusicPerformance::GetSegmentState);
    V_PTRPTR_WRITE(ppSegmentState);

    CSegState* pSegNode;
    HRESULT hr;
    EnterCriticalSection(&m_SegmentCrSec);
    if( pSegNode = GetPrimarySegmentAtTime( mtTime ))
    {
        *ppSegmentState = pSegNode;
        pSegNode->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(3,"Unable to find a segment state at time %ld\n",mtTime);
        hr  = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetPrepareTime |
  Sets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetPrepareTime(
    DWORD dwMilliSeconds) // @parm The amount of time.
{
    m_dwPrepareTime = dwMilliSeconds;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetPrepareTime |
  Gets the prepare time. The prepare time is the amount of time ahead that
  <om IDirectMusicTrack.Play> is called before the messages should actually
  be heard through the loudspeaker. The midi messages from the tracks are placed in
  the early queue, are processed by Tools, and then placed in the near-time
  queue to await being sent to the midi ports.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 1000 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetPrepareTime(
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetPrepareTime);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwPrepareTime;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetBumperLength |
  Sets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetBumperLength(
    DWORD dwMilliSeconds)   // @parm The amount of time.
{
    m_dwBumperLength = dwMilliSeconds;
    m_rtBumperLength = m_dwBumperLength * REF_PER_MIL;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetBumperLength |
  Gets the bumper length. The bumper length is the amount of time to buffer ahead
  of the Port's latency for midi messages to be sent to the Port for rendering.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | pdwMilliSeconds is NULL or invalid.
  @comm The default value is 50 milliseconds.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetBumperLength(
    DWORD* pdwMilliSeconds) // @parm The amount of time.
{
    V_INAME(IDirectMusicPerformance::GetBumperLength);
    V_PTR_WRITE(pdwMilliSeconds,DWORD);

    *pdwMilliSeconds = m_dwBumperLength;
    return S_OK;
}

#define RESOLVE_FLAGS (DMUS_TIME_RESOLVE_AFTERPREPARETIME | \
                       DMUS_TIME_RESOLVE_AFTERLATENCYTIME | \
                       DMUS_TIME_RESOLVE_AFTERQUEUETIME | \
                       DMUS_TIME_RESOLVE_BEAT | \
                       DMUS_TIME_RESOLVE_MEASURE | \
                       DMUS_TIME_RESOLVE_GRID | \
                       DMUS_TIME_RESOLVE_MARKER | \
                       DMUS_TIME_RESOLVE_SEGMENTEND)


HRESULT STDMETHODCALLTYPE CPerformance::SendPMsg(
    DMUS_PMSG *pDMUS_PMSG)

{
    V_INAME(IDirectMusicPerformance::SendPMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pDMUS_PMSG,sizeof(DMUS_PMSG));
#else
        if (!pDMUS_PMSG)
        {
            return E_POINTER;
        }
#endif
    }
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to Send PMsg because performance not initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if (pDMUS_PMSG->dwSize < sizeof(DMUS_PMSG))
    {
        TraceI(1,"Warning: PMsg size field has been cleared.\n");
    }

    // If this is a PMsg that was marked by STampPMsg as one that should be removed,
    // do so now.
    if (pDMUS_PMSG->dwPChannel == DMUS_PCHANNEL_KILL_ME)
    {
        FreePMsg(pDMUS_PMSG);
        return S_OK;
    }

    EnterCriticalSection(&m_PipelineCrSec);
    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pDMUS_PMSG);
    if( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED ) ||
        ( ( pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK ) != PRIV_FLAG_ALLOC ) )
    {
        Trace(1, "Error: Attempt to send an improperly allocated PMsg, or trying to send it after it is already sent.\n" );
        LeaveCriticalSection(&m_PipelineCrSec);
        return DMUS_E_ALREADY_SENT;
    }

    if (m_dwVersion >= 8)
    {
        // If the music and ref times are both 0, set to latency time.
        if ((pDMUS_PMSG->mtTime == 0) && ( pDMUS_PMSG->rtTime == 0 ))
        {
            // If this needs to resolve, use the worse case latency
            // because this needs to sync with other pmsgs.
            if (pDMUS_PMSG->dwFlags & RESOLVE_FLAGS)
            {
                GetLatencyTime(&pDMUS_PMSG->rtTime);
            }
            else
            {
                // Otherwise, we want to play as soon as possible.
                pDMUS_PMSG->rtTime = GetTime();
            }
            pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
            pDMUS_PMSG->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
        }
    }

    // fill in missing time value
    if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_MUSICTIME))
    {
        if( !(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME ) )
        {
            LeaveCriticalSection(&m_PipelineCrSec);
            Trace(1,"Error: Unable to send PMsg because neither clock time (DMUS_PMSGF_REFTIME) nor music time (DMUS_PMSGF_MUSICTIME) has been set.\n");
            return E_INVALIDARG; // one or the other MUST be set
        }
        // quantize to resolution boundaries
        GetResolvedTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->rtTime, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        // if time is zero, set it to time now plus latency
        if( pDMUS_PMSG->rtTime == 0 )
        {
            pDMUS_PMSG->rtTime = GetLatency();
        }
        ReferenceToMusicTime(pDMUS_PMSG->rtTime,
            &pDMUS_PMSG->mtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_MUSICTIME;
    }
    else if (!(pDMUS_PMSG->dwFlags & DMUS_PMSGF_REFTIME))
    {
        MusicToReferenceTime(pDMUS_PMSG->mtTime,
            &pDMUS_PMSG->rtTime);
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_REFTIME;
        // quantize to resolution boundaries
        REFERENCE_TIME rtNew;
        GetResolvedTime( pDMUS_PMSG->rtTime, &rtNew, pDMUS_PMSG->dwFlags );
        pDMUS_PMSG->dwFlags &= ~RESOLVE_FLAGS;
        if( rtNew != pDMUS_PMSG->rtTime )
        {
            pDMUS_PMSG->rtTime = rtNew;
            ReferenceToMusicTime( pDMUS_PMSG->rtTime, &pDMUS_PMSG->mtTime );
        }
    }

    // insert into the proper queue by music value
    if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_QUEUE)
    {
        m_NearTimeQueue.Enqueue(pPrivPMsg);
    }
    else if (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_ATTIME)
    {
        m_OnTimeQueue.Enqueue(pPrivPMsg);
    }
    else // (pDMUS_PMSG->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        pDMUS_PMSG->dwFlags |= DMUS_PMSGF_TOOL_IMMEDIATE;
        m_EarlyQueue.Enqueue(pPrivPMsg);
    }
    LeaveCriticalSection(&m_PipelineCrSec);
    return S_OK;
}

/*

  Call this only from within a PipelineCrSec.
*/
void CPerformance::RevalidateRefTimes( CPMsgQueue * pList, MUSIC_TIME mtTime )
{
    PRIV_PMSG* pCheck;
    BOOL fError = FALSE;
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->mtTime > mtTime)
        {
            if (pCheck->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
            {
                ReferenceToMusicTime(pCheck->rtTime,&pCheck->mtTime);
            }
            else // if(pCheck->dwFlags & DMUS_PMSGF_MUSICTIME)
            {
                MusicToReferenceTime(pCheck->mtTime,&pCheck->rtTime);
            }
        }
    }
    // Make sure that we do not end up with out of order RTimes. This can happen with
    // DMUS_PMSGF_LOCKTOREFTIME messages or very abrupt changes in tempo.
    for( pCheck = pList->GetHead(); pCheck; pCheck = pCheck->pNext )
    {
        if (pCheck->pNext && ( pCheck->rtTime > pCheck->pNext->rtTime ))
        {
            fError = TRUE;  // Need to sort the list.
        }
    }
    if (fError)
    {
        TraceI(2,"Rearrangement of times in message list due to tempo change, resorting\n");
        pList->Sort();
    }
}

void CPerformance::AddToTempoMap( double dblTempo, MUSIC_TIME mtTime, REFERENCE_TIME rtTime )
{
    DMInternalTempo* pITempo = NULL;

    if( FAILED( AllocPMsg( sizeof(DMInternalTempo), (PRIV_PMSG**)&pITempo )))
    {
        return; // out of memory!
    }
    if( dblTempo > DMUS_TEMPO_MAX ) dblTempo = DMUS_TEMPO_MAX;
    else if( dblTempo < DMUS_TEMPO_MIN ) dblTempo = DMUS_TEMPO_MIN;
    pITempo->tempoPMsg.dblTempo = dblTempo;
    pITempo->tempoPMsg.rtTime = rtTime;
    pITempo->tempoPMsg.mtTime = mtTime;
    pITempo->tempoPMsg.dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_REFTIME;
    pITempo->pNext = NULL;
    // set the relative tempo field
    EnterCriticalSection(&m_GlobalDataCrSec);
    pITempo->fltRelTempo = m_fltRelTempo;
    // add the tempo event to the tempo map and clear the tool and graph pointers
    pITempo->tempoPMsg.pTool = NULL;
    EnterCriticalSection(&m_PipelineCrSec);
    // remove stale tempo events from the tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
    PRIV_PMSG* pCheck;
    while (pCheck = m_TempoMap.FlushOldest(rtNow))
    {
        m_OldTempoMap.Enqueue(pCheck);
    }
    // add the new tempo event to the queue
    m_TempoMap.Enqueue( (PRIV_PMSG*) pITempo );
    // now that it's been added, scan forward from it and change the relative tempo
    // times of everyone after it
    DMInternalTempo* pChange;
    for( pChange = (DMInternalTempo*)pITempo->pNext; pChange;
        pChange = (DMInternalTempo*)pChange->pNext )
    {
        pChange->fltRelTempo = pITempo->fltRelTempo;
    }
    // remove stale tempo events from the old tempo map.
    // as long as there is another tempo with a time stamp before the current
    // time, get rid of the first in the list.
    rtNow = GetTime() - ((REFERENCE_TIME)10000 * 300000); // keep around for five minutes.
    while (pCheck = m_OldTempoMap.FlushOldest(rtNow))
    {
        FreePMsg(pCheck);
    }
    m_fTempoChanged = TRUE;
    LeaveCriticalSection(&m_PipelineCrSec);
    LeaveCriticalSection(&m_GlobalDataCrSec);
}

void CPerformance::AddEventToTempoMap( PRIV_PMSG* pEvent )
{
    PRIV_TEMPO_PMSG* pTempo = (PRIV_TEMPO_PMSG*)pEvent;
    MUSIC_TIME mtTime = pTempo->tempoPMsg.mtTime;
    AddToTempoMap( pTempo->tempoPMsg.dblTempo, mtTime, pTempo->tempoPMsg.rtTime );
    pEvent->dwPrivFlags = PRIV_FLAG_ALLOC;
    EnterCriticalSection(&m_GlobalDataCrSec);
    EnterCriticalSection(&m_PipelineCrSec);
    // revalidate the ref times of the events in the queues
    RevalidateRefTimes( &m_TempoMap, mtTime );
    RevalidateRefTimes( &m_OnTimeQueue, mtTime );
    RevalidateRefTimes( &m_NearTimeQueue, mtTime );
    RevalidateRefTimes( &m_EarlyQueue, mtTime );
    m_fTempoChanged = TRUE;
    LeaveCriticalSection(&m_PipelineCrSec);
    LeaveCriticalSection(&m_GlobalDataCrSec);
    RecalcTempoMap(NULL, mtTime+1, false);
}

#define TEMPO_AHEAD 768 * 4 * 10    // 10 measures ahead is plenty!

void CPerformance::IncrementTempoMap()

{
    if (m_mtTempoCursor <= (m_mtTransported + TEMPO_AHEAD))
    {
        UpdateTempoMap(m_mtTempoCursor, false, NULL);
    }
}

void CPerformance::RecalcTempoMap(CSegState *pSegState, MUSIC_TIME mtStart, bool fAllDeltas)

/*  Called whenever a primary or controlling segment that has a tempo
    track is played or stopped.
    1) Convert the music time at transport time to ref time using the old
    map.
    2) Build a replacement tempo map starting at mtStart, by
    calling GetParam() until there is no next time.
    3) Install the new map.
    4) Convert with the new map.
    5) If the two numbers are not identical, recalculate all message times.
*/

{
    if( mtStart > 0) // Don't do this for invalid values.
    {
        if (!pSegState || (pSegState->m_pSegment && pSegState->m_pSegment->IsTempoSource()))
        {
            REFERENCE_TIME rtCompareTime;
            REFERENCE_TIME rtAfterTime;
            MUSIC_TIME mtCompareTime = m_mtTransported;
            MusicToReferenceTime(mtCompareTime,&rtCompareTime);
            EnterCriticalSection(&m_PipelineCrSec);
            FlushEventQueue( 0, &m_TempoMap, rtCompareTime, rtCompareTime, FALSE );
            LeaveCriticalSection(&m_PipelineCrSec);
            UpdateTempoMap(mtStart, true, pSegState, fAllDeltas);
            MusicToReferenceTime(mtCompareTime,&rtAfterTime);
            if (rtAfterTime != rtCompareTime)
            {
                EnterCriticalSection(&m_GlobalDataCrSec);
                EnterCriticalSection(&m_PipelineCrSec);
                // revalidate the ref times of the events in the queues
                RevalidateRefTimes( &m_TempoMap, mtStart );
                RevalidateRefTimes( &m_OnTimeQueue, mtStart );
                RevalidateRefTimes( &m_NearTimeQueue, mtStart );
                RevalidateRefTimes( &m_EarlyQueue, mtStart );
                m_fTempoChanged = TRUE;
                LeaveCriticalSection(&m_PipelineCrSec);
                LeaveCriticalSection(&m_GlobalDataCrSec);
            }
        }
    }
}


void CPerformance::UpdateTempoMap(MUSIC_TIME mtStart, bool fFirst, CSegState *pSegState, bool fAllDeltas)

{
    HRESULT hr = S_OK;
    DWORD dwIndex = 0;
    PrivateTempo Tempo;
    TList<PrivateTempo> TempoList;
    TListItem<PrivateTempo>* pScan = NULL;
    MUSIC_TIME mtNext = 0;
    MUSIC_TIME mtTime = mtStart;
    MUSIC_TIME mtCursor = mtStart;
    REFERENCE_TIME rtTime;
    do
    {
        hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
        Tempo.mtTime = mtTime;
        if (hr == S_OK && Tempo.mtDelta > 0)
        {
            mtTime += Tempo.mtDelta;
            hr = GetParam(GUID_PrivateTempoParam,-1,dwIndex,mtTime,&mtNext,(void *)&Tempo );
            Tempo.mtTime = mtTime;
        }
        if (hr == S_FALSE && fFirst && !pSegState)
        {
            // If this was the very first try, there might not be any tempo track, and
            // so global tempo is called. If so, S_FALSE is returned. This is okay
            // for the NULL segstate case where we are recomputing the tempo map in response
            // to a change in global tempo, or stop of all segments.
            if (fAllDeltas) // Never do this in response to adding a new event to the tempo map
            {
                MusicToReferenceTime(mtTime,&rtTime);
                // the rtTime in the tempo map needs to be the non-adjusted value (305694)
                AddToTempoMap( Tempo.dblTempo, mtTime, rtTime + m_rtAdjust );
            }
            break;
        }
        if (hr == S_OK)
        {
            TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>(Tempo);
            if (pNew)
            {
                // add to TempoList, replacing duplicate times with the most recent mtDelta
                TListItem<PrivateTempo>* pNext = TempoList.GetHead();
                if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                {
                    TempoList.AddHead(pNew);
                }
                else for (pScan = TempoList.GetHead(); pScan; pScan = pNext)
                {
                    pNext = pScan->GetNext();
                    if (Tempo.mtTime == pScan->GetItemValue().mtTime)
                    {
                        if (Tempo.mtDelta > pScan->GetItemValue().mtDelta)
                        {
                            pScan->GetItemValue() = Tempo;
                        }
                        delete pNew;
                        break;
                    }
                    else if (!pNext || Tempo.mtTime < pNext->GetItemValue().mtTime)
                    {
                        pScan->SetNext(pNew);
                        pNew->SetNext(pNext);
                        break;
                    }
                }
            }
            mtTime += mtNext;
            fFirst = false;
            // If this was the last tempo in the track (that we care about),
            // reset the time and bump the track index
            if (Tempo.fLast || mtTime > (m_mtTransported + TEMPO_AHEAD))
            {
                dwIndex++;
                mtCursor = mtTime;
                mtTime = mtStart;
            }
            else if (!mtNext) break; // should never happen but if it does, infinite loop
        }
        else if (Tempo.fLast) // There was an empty tempo track
        {
            dwIndex++;
            hr = S_OK;
        }
        Tempo.fLast = false;
    } while (hr == S_OK);
    if (TempoList.GetHead() && TempoList.GetHead()->GetItemValue().mtTime > mtStart)
    {
        // add a tempo of 120 at time mtStart
        TListItem<PrivateTempo>* pNew = new TListItem<PrivateTempo>();
        if (pNew)
        {
            PrivateTempo& rNew = pNew->GetItemValue();
            rNew.dblTempo = 120.0;
            rNew.mtTime = mtStart;
            TempoList.AddHead(pNew);
        }
        else
        {
#ifdef DBG
            Trace(1, "Error: Out of memory; Tempo map is incomplete.\n");
#endif
            TempoList.GetHead()->GetItemValue().mtTime = mtStart;
        }
    }
    for (pScan = TempoList.GetHead(); pScan; pScan = pScan->GetNext())
    {
        PrivateTempo& rTempo = pScan->GetItemValue();
        if (fAllDeltas || rTempo.mtTime + rTempo.mtDelta >= mtStart)
        {
            MusicToReferenceTime(rTempo.mtTime,&rtTime);
            // the rtTime in the tempo map needs to be the non-adjusted value (305694)
            AddToTempoMap( rTempo.dblTempo, rTempo.mtTime, rtTime + m_rtAdjust );
        }
    }
    m_mtTempoCursor = mtCursor;
}

HRESULT STDMETHODCALLTYPE CPerformance::MusicToReferenceTime(
    MUSIC_TIME mtTime,          // @parm The time in MUSIC_TIME format to convert.
    REFERENCE_TIME *prtTime)    // @parm Returns the converted time in REFERENCE_TIME format.
{
    V_INAME(IDirectMusicPerformance::MusicToReferenceTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to convert music to reference time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;
    REFERENCE_TIME rtTemp;

    EnterCriticalSection( &m_PipelineCrSec );
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( mtTime >= pEvent->mtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->mtTime > mtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map
            // (which goes five minutes into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( mtTime >= pEvent->mtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->mtTime > mtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LeaveCriticalSection( &m_PipelineCrSec );
    rtTempo -= m_rtAdjust;

    rtTemp = ( mtTime - mtTempo );
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dbl);
    *prtTime = rtTempo + rtTemp;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::ReferenceToMusicTime(
    REFERENCE_TIME rtTime,  // @parm The time in REFERENCE_TIME format to convert.
    MUSIC_TIME *pmtTime)    // @parm Returns the converted time in MUSIC_TIME format.
{
    V_INAME(IDirectMusicPerformance::ReferenceToMusicTime);
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: Unable to convert reference to music time because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    PRIV_PMSG*  pEvent;
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = m_rtStart;

    EnterCriticalSection( &m_PipelineCrSec );
    pEvent = m_TempoMap.GetHead();
    if( pEvent )
    {
        if( rtTime >= pEvent->rtTime )
        {
            while( pEvent->pNext )
            {
                if( pEvent->pNext->rtTime > rtTime )
                {
                    break;
                }
                pEvent = pEvent->pNext;
            }
            DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
            dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
            mtTempo = pTempo->tempoPMsg.mtTime;
            rtTempo = pTempo->tempoPMsg.rtTime;
        }
        else
        {
            // If mtTime is less than everything in the tempo map, look in the old tempo map
            // (which goes five minutes into the past).  This keeps the regular tempo map
            // small, but allows us to get a valid tempo in the cases where the regular tempo
            // map no longer contains the tempo we need.
            pEvent = m_OldTempoMap.GetHead();
            if( pEvent )
            {
                if( rtTime >= pEvent->rtTime )
                {
                    while( pEvent->pNext )
                    {
                        if( pEvent->pNext->rtTime > rtTime )
                        {
                            break;
                        }
                        pEvent = pEvent->pNext;
                    }
                    DMInternalTempo* pTempo = (DMInternalTempo*)pEvent;
                    dbl = pTempo->tempoPMsg.dblTempo * pTempo->fltRelTempo;
                    mtTempo = pTempo->tempoPMsg.mtTime;
                    rtTempo = pTempo->tempoPMsg.rtTime;
                }
            }
        }
    }
    LeaveCriticalSection( &m_PipelineCrSec );
    rtTempo -= m_rtAdjust;
    if( rtTime < rtTempo )
    {
        rtTime = rtTempo;
    }
    rtTime -= rtTempo;
    rtTime *= DMUS_PPQ;
    rtTime = (REFERENCE_TIME)(rtTime * dbl);
    rtTime += 300000000;
    rtTime /= 600000000;
#ifdef DBG
    if ( rtTime & 0xFFFFFFFF00000000 )
    {
        Trace(1,"Error: Invalid Reference to Music time conversion resulted in overflow.\n");
    }
#endif
    *pmtTime = (long) (rtTime & 0xFFFFFFFF);
    *pmtTime += mtTempo;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | AdjustTime |
  Adjust the internal Performance time forward or backward. This is mostly used to
  compensate for drift when synchronizing to another source, such as SMPTE.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | rtAmount is too large or too small.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AdjustTime(
    REFERENCE_TIME rtAmount)    // @parm The amount of time to adjust. This may be a
                                // number from -10000000 to 10000000 (-1 second to +1 second.)
{
    if( ( rtAmount < -10000000 ) || ( rtAmount > 10000000 ) )
    {
        Trace(1,"Error: Time parameter passed to AdjustTime() is out of range.\n");
        return E_INVALIDARG;
    }
    m_rtAdjust += rtAmount;
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetResolvedTime |
  Quantize a time to a resolution boundary. Given a time, in REFERENCE_TIME,
  return the next time on a given boundary after the time given.

  @rvalue S_OK | Success.
  @rvalue E_POINTER <prtResolved> is not valid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetResolvedTime(
    REFERENCE_TIME rtTime,
    REFERENCE_TIME* prtResolved,
    DWORD dwResolvedTimeFlags)
{
    V_INAME(IDirectMusicPerformance::GetResolvedTime);
    V_PTR_WRITE(prtResolved,REFERENCE_TIME);

    if (rtTime == 0)
    {
        dwResolvedTimeFlags |= DMUS_TIME_RESOLVE_AFTERQUEUETIME ;
    }
    if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERPREPARETIME )
    {
        REFERENCE_TIME rtTrans;
        MusicToReferenceTime( m_mtTransported, &rtTrans );
        if( rtTime < rtTrans ) rtTime = rtTrans;
    }
    else if (dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERLATENCYTIME )
    {
        REFERENCE_TIME rtStart;
        rtStart = GetLatency();
        if( rtTime < rtStart ) rtTime = rtStart;
    }
    else if( dwResolvedTimeFlags & DMUS_TIME_RESOLVE_AFTERQUEUETIME )
    {
        REFERENCE_TIME rtStart;
        GetQueueTime( &rtStart ); // need queue time because control segments cause invalidations
        if( rtTime < rtStart ) rtTime = rtStart;
    }


    if( dwResolvedTimeFlags & ( DMUS_TIME_RESOLVE_BEAT | DMUS_TIME_RESOLVE_MEASURE |
        DMUS_TIME_RESOLVE_GRID | DMUS_TIME_RESOLVE_MARKER | DMUS_TIME_RESOLVE_SEGMENTEND))
    {
        MUSIC_TIME mtTime; //, mtResolved;

        ReferenceToMusicTime( rtTime, &mtTime );
        EnterCriticalSection(&m_SegmentCrSec);
        mtTime = ResolveTime( mtTime, dwResolvedTimeFlags, NULL);
        LeaveCriticalSection(&m_SegmentCrSec);
        MusicToReferenceTime( mtTime, prtResolved );
    }
    else
    {
        *prtResolved = rtTime;
    }
    return S_OK;
}


/*
  @method HRESULT | IDirectMusicPerformance | IsPlaying |
  Find out if a particular Segment or SegmentState is currently playing.

  @rvalue E_POINTER | Both pSegment and pSegState are null, or one or both are invalid.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
  @rvalue S_OK | Yes, it is playing.
  @rvalue S_FALSE | No, it is not playing.
*/
HRESULT STDMETHODCALLTYPE CPerformance::IsPlaying(
    IDirectMusicSegment *pSegment,          // @parm The Segment to check. If NULL, check
                                            // <p pSegState>.
    IDirectMusicSegmentState *pSegState)    // @parm The SegmentState to check. If NULL,
                                            // check <p pSegment>.
{
    CSegState* pNode;
    DWORD dwCount;

    V_INAME(IDirectMusicPerformance::IsPlaying);
    V_INTERFACE_OPT(pSegment);
    V_INTERFACE_OPT(pSegState);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: IsPlaying() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if( !pSegment && !pSegState )
    {
        Trace(1,"Error: IsPlaying() failed because segment and segment state are both NULL pointers.\n");
        return E_POINTER;
    }

    MUSIC_TIME mtNow;
    GetTime(NULL, &mtNow);
    EnterCriticalSection(&m_SegmentCrSec);

    for( dwCount = 0; dwCount < SQ_COUNT; dwCount++ )
    {
        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
        {
            if( !pNode->m_fStartedPlay )
            {
                continue;
            }
            if( mtNow >= pNode->m_mtResolvedStart )
            {
                if( mtNow < pNode->m_mtLastPlayed )
                {
                    if(( pNode == (CSegState*) pSegState ) ||
                        ( pNode->m_pSegment == (CSegment *) pSegment ))
                    {
                        LeaveCriticalSection(&m_SegmentCrSec);
                        return S_OK;
                    }
                }
            }
            else
            {
                // if mtNow is before this pSegState's resolved start, it is before every
                // pSegState after this too, so break now.
                break;
            }
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return S_FALSE;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetTime(
        REFERENCE_TIME *prtNow, // @parm Returns the current time in REFERENCE_TIME
                                            // format. May be NULL.
        MUSIC_TIME  *pmtNow)    // @parm Returns the current time in MUSIC_TIME
                                            // format. May be NULL.
{
    V_INAME(IDirectMusicPerformance::GetTime);
    V_PTR_WRITE_OPT(prtNow,REFERENCE_TIME);
    V_PTR_WRITE_OPT(pmtNow,MUSIC_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    REFERENCE_TIME rtTime = GetTime();
    if( prtNow )
    {
        *prtNow = rtTime;
    }
    if( pmtNow )
    {
        MUSIC_TIME mtTime;
        ReferenceToMusicTime( rtTime, &mtTime );
        *pmtNow = mtTime;
    }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetLatencyTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current latency time.
{
    V_INAME(IDirectMusicPerformance::GetLatencyTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetLatencyTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    *prtTime = GetLatency();
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::GetQueueTime(
        REFERENCE_TIME *prtTime)    // @parm Returns the current queue time.
{
    V_INAME(IDirectMusicPerformance::GetQueueTime);
    V_PTR_WRITE(prtTime,REFERENCE_TIME);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetQueueTime() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    DWORD dw;
    REFERENCE_TIME rtLatency;

    *prtTime = 0;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dw = 0; dw < m_dwNumPorts; dw++ )
    {
        if( m_pPortTable[dw].rtLast > *prtTime )
            *prtTime = m_pPortTable[dw].rtLast;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    rtLatency = GetLatency();
    if( *prtTime < rtLatency )
    {
        *prtTime = rtLatency;
    }
    if (m_rtEarliestStartTime > rtLatency)
    {
        rtLatency = m_rtEarliestStartTime;
    }
    return S_OK;
}

// private version of AllocPMsg
HRESULT CPerformance::AllocPMsg(
    ULONG cb,
    PRIV_PMSG** ppPMSG)
{
    ASSERT( cb >= sizeof(PRIV_PMSG) );
    DMUS_PMSG* pDMUS_PMSG;
    HRESULT hr;

    hr = AllocPMsg( cb - PRIV_PART_SIZE, &pDMUS_PMSG );
    if( SUCCEEDED(hr) )
    {
        *ppPMSG = DMUS_TO_PRIV(pDMUS_PMSG);
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ClonePMsg(DMUS_PMSG* pSourcePMSG,DMUS_PMSG** ppCopyPMSG)
{
    V_INAME(IDirectMusicPerformance::ClonePMsg);
#ifdef DBG
    V_PTRPTR_WRITE(ppCopyPMSG);
    V_BUFPTR_READ(pSourcePMSG,sizeof(DMUS_PMSG));
#else
    if (!ppCopyPMSG || !pSourcePMSG)
    {
        return E_POINTER;
    }
#endif
    HRESULT hr = AllocPMsg(pSourcePMSG->dwSize,ppCopyPMSG);
    if (SUCCEEDED(hr))
    {
        memcpy(*ppCopyPMSG,pSourcePMSG,pSourcePMSG->dwSize);
        if (pSourcePMSG->punkUser)
        {
            pSourcePMSG->punkUser->AddRef();
        }
        if (pSourcePMSG->pTool)
        {
            pSourcePMSG->pTool->AddRef();
        }
        if (pSourcePMSG->pGraph)
        {
            pSourcePMSG->pGraph->AddRef();
        }
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////
// CPerformance::AllocPMsg
/*
  @method HRESULT | IDirectMusicPerformance | AllocPMsg |
  Allocate a DMUS_PMSG.

  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p cb> is smaller than sizeof(DMUS_PMSG)
  @rvalue E_POINTER | <p ppPMSG> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::AllocPMsg(
    ULONG cb,               // @parm Size of the <p ppPMSG>. Must be equal to or greater
                            // than sizeof(DMUS_PMSG).
    DMUS_PMSG** ppPMSG  // @parm Returns the pointer to the allocated message, which will
                            // be of size <p cb>. All fields are initialized to zero,
                            // except dwSize which is initialized to <p cb>.
    )
{
    V_INAME(IDirectMusicPerformance::AllocPMsg);
    if( m_dwVersion < 8)
    {
        V_PTRPTR_WRITE(ppPMSG);
    }
    else
    {
#ifdef DBG
        V_PTRPTR_WRITE(ppPMSG);
#else
        if (!ppPMSG)
        {
            return E_POINTER;
        }
#endif
    }
    PRIV_PMSG* pPrivPMsg;

    if( cb < sizeof(DMUS_PMSG) )
        return E_INVALIDARG;

    EnterCriticalSection(&m_PMsgCacheCrSec);
    // cached pmsg's are stored in an array based on their public size.
    // If a cached pmsg exists, return it. Otherwise, make a new one.
    if( (cb >= PERF_PMSG_CB_MIN) && (cb < PERF_PMSG_CB_MAX) )
    {
        ULONG cbIndex = cb - PERF_PMSG_CB_MIN;
        if( m_apPMsgCache[ cbIndex ] )
        {
            pPrivPMsg = m_apPMsgCache[ cbIndex ];
            m_apPMsgCache[ cbIndex ] = pPrivPMsg->pNext;
            pPrivPMsg->pNext = NULL;
            if (pPrivPMsg->dwPrivFlags != PRIV_FLAG_FREE)
            {
                Trace(0,"Error - previously freed PMsg has been mangled.\n");
                LeaveCriticalSection(&m_PMsgCacheCrSec);
                return E_FAIL;
            }
            pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
            if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
            *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
            LeaveCriticalSection(&m_PMsgCacheCrSec);
            return S_OK;
        }
    }

    HRESULT hr = S_OK;
    // no cached pmsg exists. Return a new one.
    ULONG cbPriv = cb + PRIV_PART_SIZE;
    pPrivPMsg = (PRIV_PMSG*)(new char[cbPriv]);
    if( pPrivPMsg )
    {
        memset( pPrivPMsg, 0, cbPriv );
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cb; // size of public part only
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_ALLOC;
        if (m_fInTrackPlay) pPrivPMsg->dwPrivFlags |= PRIV_FLAG_TRACK;
        *ppPMSG = PRIV_TO_DMUS(pPrivPMsg);
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);
    return hr;
}

// private version of FreePMsg
HRESULT CPerformance::FreePMsg(
    PRIV_PMSG* pPMSG)
{
    return FreePMsg( PRIV_TO_DMUS(pPMSG) );
}


HRESULT STDMETHODCALLTYPE CPerformance::FreePMsg(
    DMUS_PMSG*  pPMSG   // @parm The message to free. This message must have been allocated
                            // using <om .AllocPMsg>.
    )
{
    V_INAME(IDirectMusicPerformance::FreePMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMSG,sizeof(DMUS_PMSG));
#else
        if (!pPMSG)
        {
            return E_POINTER;
        }
#endif
    }

    PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMSG);

    if( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_ALLOC_MASK) != PRIV_FLAG_ALLOC )
    {
        Trace(0, "Error --- Attempt to free a PMsg that is not allocated memory.\n");
        // this isn't a msg allocated by AllocPMsg.
        return DMUS_E_CANNOT_FREE;
    }
    if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_QUEUED )
    {
        TraceI(1, "Attempt to free a PMsg that is currently in the Performance queue.\n");
        return DMUS_E_CANNOT_FREE;
    }

    EnterCriticalSection(&m_PMsgCacheCrSec);
    if( pPMSG->pTool )
    {
        pPMSG->pTool->Release();
    }
    if( pPMSG->pGraph )
    {
        pPMSG->pGraph->Release();
    }
    if( pPMSG->punkUser )
    {
        pPMSG->punkUser->Release();
    }

    ULONG cbSize = pPrivPMsg->dwPrivPubSize;
    if( (cbSize >= PERF_PMSG_CB_MIN) && (cbSize < PERF_PMSG_CB_MAX) )
    {
        memset( pPrivPMsg, 0, cbSize + PRIV_PART_SIZE );
        pPrivPMsg->dwPrivFlags = PRIV_FLAG_FREE; // Mark this as in the free queue.
        pPrivPMsg->dwSize = pPrivPMsg->dwPrivPubSize = cbSize;
        pPrivPMsg->pNext = m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ];
        m_apPMsgCache[ cbSize - PERF_PMSG_CB_MIN ] = pPrivPMsg;
    }
    else
    {
        delete [] pPrivPMsg;
    }
    LeaveCriticalSection(&m_PMsgCacheCrSec);
    return S_OK;
}

HRESULT CPerformance::FlushVirtualTrack(
    DWORD       dwId,
    MUSIC_TIME  mtTime,
    BOOL fLeaveNotesOn)
{
    EnterCriticalSection(&m_PipelineCrSec);
    FlushMainEventQueues( dwId, mtTime, mtTime, fLeaveNotesOn );
    LeaveCriticalSection(&m_PipelineCrSec);
    return S_OK;
}

/*
  Given a time, mtTime, returns the time of the next control segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/

HRESULT CPerformance::GetControlSegTime(
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    EnterCriticalSection( &m_SegmentCrSec );
    // search the secondary lists for a control segment
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_CON_DONE].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart >= mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    if( S_FALSE == hr ) // if this is still zero, check the current queue
    {
        for( pTemp = m_SegStateQueues[SQ_CON_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
        {
            if( pTemp->m_mtResolvedStart >= mtTime )
            {
                *pmtNextSeg = pTemp->m_mtResolvedStart;
                hr = S_OK;
                break;
            }
        }
    }
    LeaveCriticalSection( &m_SegmentCrSec );
    return hr;
}

/*
  Given a time, mtTime, returns the time of the next primary segment in pmtNextSeg.
  Returns S_FALSE if none found, and sets pmtNextSeg to zero.
*/
HRESULT CPerformance::GetPriSegTime(
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNextSeg)
{
    HRESULT hr = S_FALSE;
    *pmtNextSeg = 0;
    EnterCriticalSection( &m_SegmentCrSec );
    CSegState* pTemp;
    for( pTemp = m_SegStateQueues[SQ_PRI_PLAY].GetHead(); pTemp; pTemp = pTemp->GetNext() )
    {
        if( pTemp->m_mtResolvedStart > mtTime )
        {
            *pmtNextSeg = pTemp->m_mtResolvedStart;
            hr = S_OK;
            break;
        }
    }
    LeaveCriticalSection( &m_SegmentCrSec );
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGraph |
  Returns the performance's Tool Graph, AddRef'd.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NOT_FOUND | There is no graph in the performance, and therefore
  one couldn't be returned.
  @rvalue E_POINTER | <p ppGraph> is NULL or invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGraph(
         IDirectMusicGraph** ppGraph // @parm Returns the tool graph pointer.
        )
{
    V_INAME(IDirectMusicPerformance::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    HRESULT hr;
    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph )
    {
        *ppGraph = m_pGraph;
        m_pGraph->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Performance does not currently have a tool graph installed.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}


HRESULT CPerformance::GetGraphInternal(
         IDirectMusicGraph** ppGraph )
{
    EnterCriticalSection(&m_MainCrSec);
    if( !m_pGraph )
    {
        m_pGraph = new CGraph;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return GetGraph(ppGraph);
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGraph |
  Replaces the performance's Tool Graph. <p pGraph> is AddRef'd inside this
  method. Any messages flowing through Tools in the current Tool Graph are deleted.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pGraph> is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGraph(
         IDirectMusicGraph* pGraph  // @parm The tool graph pointer. May be NULL to clear
                                    // the current graph out of the performance.
        )
{
    V_INAME(IDirectMusicPerformance::SetGraph);
    V_INTERFACE_OPT(pGraph);

    if ((m_dwVersion >= 8) && (m_dwAudioPathMode == 0))
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }

    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CPerformance::SetNotificationHandle(
     HANDLE hNotification,      // @parm The event handle created by CreateEvent, or
                                // 0 to clear out an existing handle.
     REFERENCE_TIME rtMinimum ) // @parm The minimum amount of time that the
                                // performance should hold notify messages before discarding them.
                                // 0 means to use the default minimum time of 20000000 reference time units,
                                // which is 2 seconds, or the previous value if this API has been called previously.
                                // If the application hasn't called <om .GetNotificationPMsg> by this time, the message is
                                // discarded to free the memory.
{
    EnterCriticalSection(&m_MainCrSec);
    m_hNotification = hNotification;
    if( rtMinimum )
    {
        m_rtNotificationDiscard = rtMinimum;
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetNotificationPMsg(
     DMUS_NOTIFICATION_PMSG** ppNotificationPMsg )

{
    V_INAME(IDirectMusicPerformance::GetNotificationPMsg);
    V_PTRPTR_WRITE(ppNotificationPMsg);

    HRESULT hr;
    EnterCriticalSection(&m_PipelineCrSec);
    if( m_NotificationQueue.GetHead() )
    {
        PRIV_PMSG* pPriv = m_NotificationQueue.Dequeue();
        ASSERT(pPriv);
        *ppNotificationPMsg = (DMUS_NOTIFICATION_PMSG*)PRIV_TO_DMUS(pPriv);
        hr = S_OK;
    }
    else
    {
        *ppNotificationPMsg = NULL;
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_PipelineCrSec);
    return hr;
}

void CPerformance::AddNotificationTypeToAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    EnterCriticalSection(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->AddNotificationType( rguidNotification, TRUE );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

void CPerformance::RemoveNotificationTypeFromAllSegments( REFGUID rguidNotification )
{
    CSegState* pSegSt;
    DWORD dwCount;
    // Note: might be nice to optimize this so the same segment
    // doesn't get called multiple times
    EnterCriticalSection(&m_SegmentCrSec);
    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            pSegSt->m_pSegment->RemoveNotificationType( rguidNotification, TRUE );
        }
    }
    LeaveCriticalSection(&m_SegmentCrSec);
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CPerformance::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

/*
  @method HRESULT | IDirectMusicPerformance | AddNotificationType |
  Adds a notification type to the performance. Notifications are identified
  by a guid. When a notification is added to the performance, notify messages
  are sent to the application, which provides a message handle on which to
  block through <om IDirectMusicPerformance.SetNotificationHandle>. All segments
  and tracks are automatically updated with the new notification by calling
  their AddNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification is already on the performance.
  @rvalue E_OUTOFMEMORY | Out of memory.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .RemoveNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::AddNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to add.
{
    V_INAME(IDirectMusicPerformance::AddNotificationType);
    V_REFGUID(rguidNotification);

    CNotificationItem*  pItem;
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_SegmentCrSec);
    if( NULL == FindNotification( rguidNotification ) )
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllSegments( rguidNotification );
        }
    }
    else
    {
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | RemoveNotificationType |
  Removes a previously added notification type from the performance. All
  segments and tracks are updated with the removed notification by calling
  their RemoveNotificationType methods.

  @rvalue S_OK | Success.
  @rvalue S_FALSE | The requested notification isn't currently active.

  @xref <om .SetNotificationHandle>, <om .GetNotificationPMsg>, <om .AddNotificationType>
*/
HRESULT STDMETHODCALLTYPE CPerformance::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The guid of the notification message to remove.
                        // If GUID_NULL, remove all notifications.
{
    V_INAME(IDirectMusicPerformance::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    HRESULT hr = S_OK;
    CNotificationItem* pItem;

    if( GUID_NULL == rguidNotification )
    {
        while (pItem = m_NotificationList.RemoveHead())
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            delete pItem;
        }
    }
    else
    {
        if( pItem = FindNotification( rguidNotification ))
        {
            RemoveNotificationTypeFromAllSegments( pItem->guidNotificationType );
            m_NotificationList.Remove( pItem );
            delete pItem;
        }
        else
        {
            Trace(2,"Warning: Unable to remove requested notification because it is not currently installed.\n");
            hr = S_FALSE;
        }
    }
    return hr;
}

void CPerformance::RemoveUnusedPorts()


{
    DWORD dwIndex;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort && !m_AudioPathList.UsesPort(m_pPortTable[dwIndex].pPort))
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            CChannelBlock *pBlock = m_ChannelBlockList.GetHead();
            CChannelBlock *pNext;
            for(;pBlock;pBlock = pNext)
            {
                pNext = pBlock->GetNext();
                if (pBlock->m_dwPortIndex == dwIndex)
                {
                    m_ChannelBlockList.Remove(pBlock);
                    delete pBlock;
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

HRESULT CPerformance::GetPathPort(CPortConfig *pConfig)

{
    HRESULT hr = S_OK;
    DWORD dwPort;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    GUID &guidScan = pConfig->m_PortHeader.guidPort;
    // If we are looking for the default synth, get the class id for the default synth.
    BOOL fDefault = (pConfig->m_PortHeader.guidPort == GUID_Synth_Default);
    if (fDefault)
    {
        guidScan = m_AudioParams.clsidDefaultSynth;
    }
    for (dwPort = 0;dwPort < m_dwNumPorts;dwPort++)
    {
        if ((m_pPortTable[dwPort].guidPortID == guidScan) && m_pPortTable[dwPort].pPort)
        {
            pConfig->m_dwPortID = dwPort;
            pConfig->m_pPort = m_pPortTable[dwPort].pPort;
            pConfig->m_PortParams = m_pPortTable[dwPort].PortParams;
            ASSERT(pConfig->m_pPort);
            pConfig->m_pPort->AddRef();
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    // Failed finding the port, so create it.
    if (dwPort >= m_dwNumPorts)
    {
        BOOL fUseBuffers = FALSE;
        pConfig->m_PortParams.dwSampleRate = m_AudioParams.dwSampleRate;
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_STREAMING)
        {
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_STREAMING;
        }
        if (m_AudioParams.dwFeatures & DMUS_AUDIOF_BUFFERS)
        {
            fUseBuffers = TRUE;
            pConfig->m_PortParams.dwFeatures |= DMUS_PORT_FEATURE_AUDIOPATH;
        }
        pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_SAMPLERATE  | DMUS_PORTPARAMS_FEATURES;
        // If this wants a default synth, consult m_AudioParams and create that synth.
        if (fDefault)
        {
            pConfig->m_PortParams.dwAudioChannels = 1;
            pConfig->m_PortParams.dwVoices = m_AudioParams.dwVoices;
            pConfig->m_PortParams.dwValidParams |= DMUS_PORTPARAMS_AUDIOCHANNELS | DMUS_PORTPARAMS_VOICES;
        }
        hr = m_pDirectMusic->CreatePort(guidScan,&pConfig->m_PortParams,&pConfig->m_pPort, NULL);
        if (SUCCEEDED(hr))
        {
            if ((pConfig->m_PortParams.dwValidParams & DMUS_PORTPARAMS_FEATURES) && (pConfig->m_PortParams.dwFeatures & DMUS_PORT_FEATURE_AUDIOPATH))
            {
                IDirectMusicPortP* pPortP = NULL;
                // QI for the private interface.
                if (SUCCEEDED(pConfig->m_pPort->QueryInterface(IID_IDirectMusicPortP,(void **) &pPortP)))
                {
                    // Connect the port to the sink.
                    hr = pPortP->SetSink(m_BufferManager.m_pSinkConnect);
                    pPortP->Release();
                }
                else
                {
                    Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because synth does not support buffers.\n");
                    hr = E_INVALIDARG;
                }
            }
            else if (fUseBuffers && fDefault)
            {
                Trace(1,"Error: Attempt to create a port with audiopath buffer support failed because default synth does not support buffers.\n");
                hr = E_INVALIDARG;
            }
        }
        if (SUCCEEDED(hr))
        {
            // Now add the port to the performance.
            hr = AddPort(pConfig->m_pPort,&pConfig->m_PortHeader.guidPort,
                &pConfig->m_PortParams,&pConfig->m_dwPortID);
        }
        if (SUCCEEDED(hr))
        {
            // Activate the port.
            hr = pConfig->m_pPort->Activate(TRUE);
            // It's okay if the synth is already active.
            if (hr == DMUS_E_SYNTHACTIVE)
            {
                hr = S_OK;
            }
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwPortID = GetPortID(pConfig->m_pPort);
            // Then create matching channel blocks for all of the channel groups in the port.
            for (DWORD dwGroup = 0;dwGroup < pConfig->m_PortParams.dwChannelGroups; dwGroup++)
            {
                AllocVChannelBlock(dwPortID,dwGroup+1);
            }
        }
    }
    return (hr);
}

HRESULT STDMETHODCALLTYPE CPerformance::AddPort(
            IDirectMusicPort* pPort)
{
    V_INAME(IDirectMusicPerformance::AddPort);
    V_INTERFACE_OPT(pPort);
    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AddPort() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    return AddPort(pPort,NULL,NULL,NULL);
}

HRESULT CPerformance::AddPort(
            IDirectMusicPort* pPort,
            GUID *pguidPortID,
            DMUS_PORTPARAMS8 *pParams,
            DWORD *pdwPortID)
{
    PortTable* pPortTable;
    IDirectMusicBuffer* pBuffer;
    BOOL    fSetUpBlock = FALSE;
    BOOL    fBuiltNewTable = FALSE;
    HRESULT hr = S_OK;
    GUID guidPortID;             // Class ID of port.
    DWORD dwChannelGroups;       // Number of channel groups at initialization.
    DWORD dwNewPortIndex = 0;    // Index into port array for new port.

    EnterCriticalSection(&m_MainCrSec);
    EnterCriticalSection(&m_PChannelInfoCrSec);

    if( NULL == m_pDirectMusic )
    {
        Trace(1,"Error: Performance is not initialized, ports can not be added.\n");
        hr = DMUS_E_NOT_INIT;
        goto END;
    }

    for (;dwNewPortIndex < m_dwNumPorts; dwNewPortIndex++)
    {
        if (!m_pPortTable[dwNewPortIndex].pPort)
        {
            break;
        }
    }

    if (dwNewPortIndex == m_dwNumPorts)
    {
        pPortTable = new PortTable[m_dwNumPorts + 1];
        if( !pPortTable )
        {
            hr = E_OUTOFMEMORY;
            goto END;
        }
        fBuiltNewTable = TRUE;
    }

    // if pPort is NULL, create a software synth port
    DMUS_PORTPARAMS dmpp;
    if( NULL == pPort )
    {
        pParams = &dmpp;
        memset(&dmpp, 0, sizeof(DMUS_PORTPARAMS) );
        dmpp.dwSize = sizeof(DMUS_PORTPARAMS);
        dmpp.dwChannelGroups = dwChannelGroups = 1;
        dmpp.dwValidParams = DMUS_PORTPARAMS_CHANNELGROUPS |
            DMUS_PORTPARAMS_AUDIOCHANNELS;
        dmpp.dwAudioChannels = 2;
        guidPortID = GUID_NULL;
        hr = m_pDirectMusic->CreatePort(GUID_NULL, &dmpp, &pPort, NULL);

        if ( SUCCEEDED( hr ) )
        {
            hr = pPort->Activate(TRUE);
        }


        fSetUpBlock = TRUE;
    }
    else
    {
        if (pguidPortID)
        {
            guidPortID = *pguidPortID;
        }
        else
        {
            DMUS_PORTCAPS PortCaps;
            PortCaps.dwSize = sizeof (PortCaps);
            pPort->GetCaps(&PortCaps);
            guidPortID = PortCaps.guidPort;
        }
        pPort->GetNumChannelGroups(&dwChannelGroups);
        pPort->AddRef();
    }
    if( FAILED(hr) || ( pPort == NULL ) )
    {
        if (fBuiltNewTable) delete [] pPortTable;
        Trace(1,"Error: Unable to open requested port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    // Create a buffer
    DMUS_BUFFERDESC dmbd;
    memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
    dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
    dmbd.cbBuffer = DEFAULT_BUFFER_SIZE;
    if( FAILED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
    {
        if (fBuiltNewTable) delete [] pPortTable;
        pPort->Release();
        Trace(1,"Error: Unable to create MIDI buffer for port.\n");
        hr = DMUS_E_CANNOT_OPEN_PORT;
        goto END;
    }

    if (fBuiltNewTable)
    {
        // if there is an existing port table, copy its contents to the new, bigger, port table
        if( m_pPortTable )
        {
            if( m_dwNumPorts > 0 )
            {
                memcpy( pPortTable, m_pPortTable, sizeof(PortTable) * ( m_dwNumPorts ) );
            }
            delete [] m_pPortTable;
        }
        m_pPortTable = pPortTable;
    }
    if (pdwPortID)
    {
        *pdwPortID = dwNewPortIndex;
    }
    pPortTable = &m_pPortTable[dwNewPortIndex];
    pPortTable->pPort = pPort;
    // If we have a passed params structure, copy it. This will be used for identifying the
    // params as initialized by the synth.
    if (pParams)
    {
        pPortTable->PortParams = *pParams;
    }
    pPortTable->dwGMFlags = 0;
    //set master volume
    IKsControl *pControl;
    if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
    {
        KSPROPERTY ksp;
        ULONG cb;

        memset(&ksp, 0, sizeof(ksp));
        ksp.Set   = GUID_DMUS_PROP_Volume;
        ksp.Id    = 0;
        ksp.Flags = KSPROPERTY_TYPE_SET;

        pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&m_lMasterVolume,
                            sizeof(m_lMasterVolume),
                            &cb);
        // Now, find out if it has a gm, gs, or xg sets in rom...
        BOOL bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GM_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GM;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_GS_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_GS;
        }
        bIsSupported = FALSE;
        ksp.Set     = GUID_DMUS_PROP_XG_Hardware;
        ksp.Flags   = KSPROPERTY_TYPE_GET;

        hr = pControl->KsProperty(&ksp,
                            sizeof(ksp),
                            (LPVOID)&bIsSupported,
                            sizeof(bIsSupported),
                            &cb);
        if (SUCCEEDED(hr) && (bIsSupported))
        {
            pPortTable->dwGMFlags |= DM_PORTFLAGS_XG;
        }
        pControl->Release();
    }

    if( FAILED( pPort->GetLatencyClock( &pPortTable->pLatencyClock )))
    {
        pPortTable->pLatencyClock = NULL;
    }
    pPortTable->dwChannelGroups = dwChannelGroups;
    pPortTable->guidPortID = guidPortID;
    pPortTable->pBuffer = pBuffer;
    pPortTable->fBufferFilled = FALSE;
    pPortTable->rtLast = 0;
    if (fBuiltNewTable) m_dwNumPorts++; // must do this before calling AssignPChannelBlock
    if( fSetUpBlock && m_ChannelBlockList.IsEmpty() ) // set up default PChannel map if none already set
    {
        AssignPChannelBlock( 0, pPort, 1);
    }
    hr = S_OK;
END:
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    LeaveCriticalSection(&m_MainCrSec);

    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemovePort(
            IDirectMusicPort* pPort     // @parm The port to remove.
        )
{
    V_INAME(IDirectMusicPerformance::RemovePort);
    V_INTERFACE(pPort);

    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            // release the port and buffer. NULL them in the table. PChannels
            // that map will return an error code.
            ASSERT( m_pPortTable[dwIndex].pBuffer );
            m_pPortTable[dwIndex].pPort->Release();
            m_pPortTable[dwIndex].pBuffer->Release();
            if( m_pPortTable[dwIndex].pLatencyClock )
            {
                m_pPortTable[dwIndex].pLatencyClock->Release();
            }
            memset( &m_pPortTable[dwIndex], 0, sizeof( PortTable ));
            hr = S_OK;
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Invalid port passed to RemovePort().\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,
            DWORD dwPortIndex,
            DWORD dwGroup,
            WORD wFlags)
{
    // see if we've already allocated this block before
    // blocknum is PChannel / 16, so search on that.
    DWORD dwPChannel = dwBlockNum * 16;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart == dwPChannel )
        {
            pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
            break;
        }
    }
    if( !pChannelBlock )
    {
        pChannelBlock = new CChannelBlock;
        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,dwPortIndex,dwGroup,wFlags);
        m_ChannelBlockList.AddHead(pChannelBlock);
        pChannelBlock->m_dwPChannelStart = dwPChannel;
    }
    return S_OK;
}

// this must be called from within a PChannelCrSec critical section.
HRESULT CPerformance::AssignPChannel(
            DWORD dwPChannel,
            DWORD dwPortIndex,
            DWORD dwGroup,
            DWORD dwMChannel,
            WORD wFlags)
{
    DWORD dwIndex;
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( !pChannelBlock )
    {
        // there is no currently existing block that encompases dwPChannel.
        // Create one.
        pChannelBlock = new CChannelBlock;

        if( !pChannelBlock )
        {
            return E_OUTOFMEMORY;
        }
        pChannelBlock->Init(dwPChannel,0,0,CMAP_FREE);
        m_ChannelBlockList.AddHead(pChannelBlock);
    }

    dwIndex = dwPChannel - pChannelBlock->m_dwPChannelStart;

    ASSERT( dwIndex < PCHANNEL_BLOCKSIZE );
    CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
    pMap->dwPortIndex = dwPortIndex;
    pMap->dwGroup = dwGroup;
    pMap->dwMChannel = dwMChannel;
    pMap->nTranspose = 0;
    if ((pMap->wFlags & CMAP_FREE) && !(wFlags & CMAP_FREE))
        pChannelBlock->m_dwFreeChannels--;
    else if (!(pMap->wFlags & CMAP_FREE) && (wFlags & CMAP_FREE))
        pChannelBlock->m_dwFreeChannels++;
    pMap->wFlags = wFlags;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannelBlock(
            DWORD dwBlockNum,           // @parm The block number. Should be 0 or greater.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup               // @parm The group on the port. Should be 1 or greater.
        )
{
    V_INAME(IDirectMusicPerformance::AssignPChannelBlock);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AssignPChannelBlock() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannelBlock( dwBlockNum, dwIndex, dwGroup, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: AssignPChannelBlock() called with invalid port.\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::AssignPChannel(
            DWORD dwPChannel,           // @parm The PChannel.
            IDirectMusicPort* pPort,    // @parm The port.
            DWORD dwGroup,              // @parm The group on the port.
            DWORD dwMChannel            // @parm The channel on the group.
        )
{
    V_INAME(IDirectMusicPerformance::AssignPChannel);
    V_INTERFACE(pPort);


    if (m_dwAudioPathMode == 2)
    {
        Trace(1,"Error: Can not call AssignPChannel() when using AudioPaths.\n");
        return DMUS_E_AUDIOPATHS_IN_USE;
    }
    m_dwAudioPathMode = 1;
    DWORD dwIndex;
    HRESULT hr = E_INVALIDARG;
    if( (dwMChannel < 0) || (dwMChannel > 15))
    {
        Trace(1,"Error: AssignPChannel() called with invalid MIDI Channel %ld.\n",dwMChannel);
        return E_INVALIDARG;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    for( dwIndex = 0; dwIndex < m_dwNumPorts; dwIndex++ )
    {
        if( m_pPortTable[dwIndex].pPort == pPort )
        {
            if( SUCCEEDED( hr = AssignPChannel( dwPChannel, dwIndex, dwGroup, dwMChannel, CMAP_STATIC )))
            {
                if (m_pPortTable[dwIndex].dwChannelGroups < dwGroup)
                {
                    hr = S_FALSE;
                }
            }
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

/*  ReleasePChannel finds the requested PChannel and makes it available
    for reuse.
    It also calls ResetAllControllers(), which sends MIDI CC 121 and 123,
    reset all controllers and all notes off.
*/

HRESULT CPerformance::ReleasePChannel(DWORD dwPChannel)
{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( pChannelBlock->m_dwPChannelStart <= dwPChannel )
        {
            if( pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE > dwPChannel )
            {
                break;
            }
        }
    }
    if( pChannelBlock )
    {
        // Only release if this is genuinely a virtual pchannel. Otherwise, leave alone.
        CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwPChannel - pChannelBlock->m_dwPChannelStart];
        if (pMap->wFlags & CMAP_VIRTUAL)
        {
            pChannelBlock->m_dwFreeChannels++;
            // Clear out all the merge lists, etc.
            pMap->Clear();
            // Reset controllers, but don't send a GM reset.
            ResetAllControllers(pMap,0, false);
        }
        hr = S_OK;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::GetPort(DWORD dwPortID, IDirectMusicPort **ppPort)

{
    HRESULT hr;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if (dwPortID < m_dwNumPorts)
    {
        *ppPort = m_pPortTable[dwPortID].pPort;
        (*ppPort)->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: Unable to find requested port.\n");
        hr = E_FAIL;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}


HRESULT CPerformance::AllocVChannel(DWORD dwPortID, DWORD dwDrumFlags, DWORD *pdwPChannel, DWORD *pdwGroup,DWORD *pdwMChannel)
{
    // dwDrumsFlags:
    // bit 0 determines whether this port separates out drums on channel 10.
    // bit 1 determines whether this request is for a drum.
    // First, figure out if we are scanning for drums on channel 10, melodic instruments
    // on the other channels, or any on all channels.
    static DWORD sdwSearchForDrums[1] = { 9 };
    static DWORD sdwSearchForAll[16] = { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 };
    static DWORD sdwSearchForMelodic[15] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15 };
    DWORD *pSearchArray = sdwSearchForAll;
    DWORD dwSearchSize = 16;
    if (dwDrumFlags & 1) // Do we handle drums as a special case for channel 10?
    {
        if (dwDrumFlags & 2) // And are we looking for drums on channel 10?
        {
            pSearchArray = sdwSearchForDrums;
            dwSearchSize = 1;
        }
        else
        {
            pSearchArray = sdwSearchForMelodic;
            dwSearchSize = 15;
        }
    }
    HRESULT hr = E_INVALIDARG; // Return this if the vChannel is out of range.
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    BOOL fNotFound = TRUE;              // Use to indicate when we finally find a match.
    DWORD dwHighestPChannel = 0;        // Keep track of the highest PCHannel in use, this will be
                                        // used to create a new PChannel block, if needed.
    DWORD dwChannel;
    for (;fNotFound && pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (dwHighestPChannel < pChannelBlock->m_dwPChannelStart)
        {
            dwHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
        if ((pChannelBlock->m_dwPortIndex == dwPortID) && (pChannelBlock->m_dwFreeChannels))
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwSearchSize; dwIndex++)
            {
                dwChannel = pSearchArray[dwIndex];
                if (pChannelBlock->m_aChannelMap[dwChannel].wFlags & CMAP_FREE)
                {
                    *pdwPChannel = pChannelBlock->m_dwPChannelStart + dwChannel;
                    pChannelBlock->m_dwFreeChannels--;
                    pChannelBlock->m_aChannelMap[dwChannel].wFlags = CMAP_VIRTUAL;
                    *pdwGroup = pChannelBlock->m_aChannelMap[dwChannel].dwGroup;
                    *pdwMChannel = pChannelBlock->m_aChannelMap[dwChannel].dwMChannel;
                    fNotFound = FALSE;
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    if( fNotFound )
    {
        // there is no currently existing block that has a free channel.
        // Create one.
        IDirectMusicPort *pPort = m_pPortTable[dwPortID].pPort;
        DWORD dwChannelGroupCount;
        pPort->GetNumChannelGroups(&dwChannelGroupCount);
        dwChannelGroupCount++;
        hr = pPort->SetNumChannelGroups(dwChannelGroupCount);
        if (SUCCEEDED(hr))
        {
            m_pPortTable[dwPortID].dwChannelGroups = dwChannelGroupCount;
            hr = E_OUTOFMEMORY;
            dwHighestPChannel += PCHANNEL_BLOCKSIZE;
            pChannelBlock = new CChannelBlock;
            if (pChannelBlock)
            {
                pChannelBlock->Init(dwHighestPChannel,dwPortID,dwChannelGroupCount,CMAP_FREE);
                m_ChannelBlockList.AddTail(pChannelBlock);
                dwChannel = pSearchArray[0];  // Which channel should we use?
                CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwChannel];
                pMap->dwMChannel = dwChannel;
                pMap->wFlags = CMAP_VIRTUAL;
                pChannelBlock->m_dwFreeChannels--;
                *pdwPChannel = dwChannel + dwHighestPChannel;
                *pdwGroup = pMap->dwGroup;
                *pdwMChannel = dwChannel;
                hr = S_OK;
            }
        }
    }
#ifdef DBG
    if (hr == E_INVALIDARG)
    {
        Trace(1,"Error: Unable to allocated dynamic PChannel.\n");
    }
#endif
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

HRESULT CPerformance::AllocVChannelBlock(DWORD dwPortID,DWORD dwGroup)
{
    EnterCriticalSection(&m_PChannelInfoCrSec);

    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    long lHighestPChannel = -PCHANNEL_BLOCKSIZE;
    for (;pChannelBlock;pChannelBlock = pChannelBlock->GetNext() )
    {
        if (lHighestPChannel < (long) pChannelBlock->m_dwPChannelStart)
        {
            lHighestPChannel = pChannelBlock->m_dwPChannelStart;
        }
    }
    HRESULT hr = E_OUTOFMEMORY;
    lHighestPChannel += PCHANNEL_BLOCKSIZE;
    pChannelBlock = new CChannelBlock;
    if (pChannelBlock)
    {
        pChannelBlock->Init((DWORD) lHighestPChannel,dwPortID,dwGroup,CMAP_FREE);
        m_ChannelBlockList.AddTail(pChannelBlock);
        hr = S_OK;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}


#ifdef DBG
void CPerformance::TraceAllChannelMaps()

{
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelBlock* pChannelBlock = m_ChannelBlockList.GetHead();
    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        TraceI(0,"ChannelBlock %lx, Free %ld\n",pChannelBlock->m_dwPChannelStart,pChannelBlock->m_dwFreeChannels);
        DWORD dwIndex;
        for (dwIndex = 0; dwIndex < PCHANNEL_BLOCKSIZE; dwIndex++)
        {
            CChannelMap *pMap = &pChannelBlock->m_aChannelMap[dwIndex];
            TraceI(0,"\tPort %ld, Group: %ld, MIDI: %ld, Transpose: %ld, Flags: %ld\n",
                pMap->dwPortIndex, pMap->dwGroup, pMap->dwMChannel, (long) pMap->nTranspose, (long) pMap->wFlags);
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
}

#endif


/* Note that the following must be called from within a m_PChannelInfoCrSec
   critical section and stay within that critical section for the duration
   of using the returned CChannelMap.
*/


CChannelMap * CPerformance::GetPChannelMap( DWORD dwPChannel )
{
    CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();

    for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
    {
        if( ( dwPChannel >= pChannelBlock->m_dwPChannelStart ) &&
            ( dwPChannel < pChannelBlock->m_dwPChannelStart + PCHANNEL_BLOCKSIZE ) )
        {
            CChannelMap* pChannelMap;

            pChannelMap = &pChannelBlock->m_aChannelMap[ dwPChannel - pChannelBlock->m_dwPChannelStart ];
            if( pChannelMap->dwGroup == 0 )
            {
                // this PChannel isn't on a valid group, therefore it hasn't
                // been set.
//              return NULL;
            }
            return pChannelMap;
        }
    }
    return NULL;
}

/*
  internal version
*/

HRESULT CPerformance::PChannelIndex( DWORD dwPChannel, DWORD* pdwIndex,
            DWORD* pdwGroup, DWORD* pdwMChannel, short* pnTranspose )
{
    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr;
    EnterCriticalSection(&m_PChannelInfoCrSec);
    CChannelMap *pChannelMap = GetPChannelMap(dwPChannel);
    if (pChannelMap)
    {
        ASSERT( pdwIndex && pdwGroup && pdwMChannel );

        *pdwIndex = pChannelMap->dwPortIndex;
        *pdwGroup = pChannelMap->dwGroup;
        *pdwMChannel = pChannelMap->dwMChannel;
        if( pnTranspose )
        {
            *pnTranspose = pChannelMap->nTranspose;
        }
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: PChannel %ld has not been assigned to a port.\n",dwPChannel);
        if (m_dwVersion < 8)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = DMUS_E_AUDIOPATH_NOPORT;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

DWORD CPerformance::GetPortID(IDirectMusicPort * pPort)

{
    EnterCriticalSection(&m_PChannelInfoCrSec);
    DWORD dwID = 0;
    for (;dwID < m_dwNumPorts; dwID++)
    {
        if (pPort == m_pPortTable[dwID].pPort)
        {
            break;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if (dwID == m_dwNumPorts) dwID = 0;
    return dwID;
}

STDMETHODIMP CPerformance::GetPortAndFlags(DWORD dwPChannel,IDirectMusicPort **ppPort,DWORD * pdwFlags)

{

    EnterCriticalSection(&m_PChannelInfoCrSec);
    DWORD dwIndex;
    DWORD dwGroup;
    DWORD dwMChannel;
    HRESULT hr = PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel, NULL );
    if (SUCCEEDED(hr))
    {
        *ppPort = m_pPortTable[dwIndex].pPort;
        if( *ppPort )
        {
            m_pPortTable[dwIndex].pPort->AddRef();
        }
        else
        {
            Trace(1,"Error: Performance does not have a port assigned to PChannel %ld.\n",dwPChannel);
            hr = DMUS_E_NOT_INIT;
        }
        *pdwFlags = m_pPortTable[dwIndex].dwGMFlags;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

STDMETHODIMP CPerformance::PChannelInfo(
            DWORD dwPChannel,           // @parm The PChannel to convert.
            IDirectMusicPort** ppPort,  // @parm Returns the port. May be NULL.
            DWORD* pdwGroup,            // @parm Returns the group on the port. May be NULL.
            DWORD* pdwMChannel          // @parm Returns the channel on the group. May be NULL.
        )
{
    V_INAME(IDirectMusicPerformance::PChannelInfo);
    V_PTRPTR_WRITE_OPT(ppPort);
    V_PTR_WRITE_OPT(pdwGroup,DWORD);
    V_PTR_WRITE_OPT(pdwMChannel,DWORD);

    DWORD dwIndex, dwGroup, dwMChannel;
    HRESULT hr;

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        if( ppPort )
        {
            *ppPort = m_pPortTable[dwIndex].pPort;
            if( *ppPort )
            {
                m_pPortTable[dwIndex].pPort->AddRef();
            }
        }
        if( pdwGroup )
        {
            *pdwGroup = dwGroup;
        }
        if( pdwMChannel )
        {
            *pdwMChannel = dwMChannel;
        }
        hr = S_OK;
    }
    else
    {
        // No need to print an error message because PChannelIndex() does it.
        hr = E_INVALIDARG;
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | DownloadInstrument |
  Downloads an IDirectMusicInstrument to the IDirectMusicPort specified by
  the selected PChannel.

  @rvalue E_INVALIDARG | The PChannel isn't assigned to a Port, or the Port failed
  to download the instrument. No return parameter is valid.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | One of the pointers is invalid.
*/
HRESULT STDMETHODCALLTYPE CPerformance::DownloadInstrument(
    IDirectMusicInstrument* pInst,  // @parm The instrument to download.
    DWORD dwPChannel,               // @parm The PChannel to assign the instrument.
    IDirectMusicDownloadedInstrument** ppDownInst,  // @parm Returns the downloaded instrument.
    DMUS_NOTERANGE* pNoteRanges,    // @parm A pointer to an array of DMUS_NOTERANGE structures
    DWORD dwNumNoteRanges,          // @parm Number of DMUS_NOTERANGE structures in array pointed to by pNoteRanges
    IDirectMusicPort** ppPort,      // @parm Returns the port to which the instrument was downloaded.
    DWORD* pdwGroup,                // @parm Returns the group to which the instrument was assigned.
    DWORD* pdwMChannel              // @parm Returns the MChannel to which the instrument was assigned.
        )
{
    V_INAME(IDirectMusicPerformance::DownloadInstrument);
    V_INTERFACE(pInst);
    V_PTRPTR_WRITE(ppDownInst);
    V_BUFPTR_READ_OPT(pNoteRanges, (sizeof(DMUS_NOTERANGE) * dwNumNoteRanges));
    V_PTRPTR_WRITE(ppPort);
    V_PTR_WRITE(pdwGroup,DWORD);
    V_PTR_WRITE(pdwMChannel,DWORD);


    DWORD dwIndex, dwGroup, dwMChannel;
    IDirectMusicPort* pPort = NULL;
    HRESULT hr = E_INVALIDARG;

    if (m_dwAudioPathMode == 0)
    {
        Trace(1,"Error: Performance not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED( PChannelIndex( dwPChannel, &dwIndex, &dwGroup, &dwMChannel )))
    {
        pPort = m_pPortTable[dwIndex].pPort;
        if( pPort )
        {
            hr = pPort->DownloadInstrument( pInst, ppDownInst, pNoteRanges, dwNumNoteRanges );
            pPort->AddRef();
        }
    }
    else
    {
        Trace(1,"Error: Download attempted on unassigned PChannel %ld\n",dwPChannel);
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( SUCCEEDED(hr) )
    {
        *ppPort = pPort;
        pPort->AddRef();
        *pdwGroup = dwGroup;
        *pdwMChannel = dwMChannel;
    }
    if( pPort )
    {
        pPort->Release();
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | Invalidate |
  Flushes all methods from <p mtTime> forward, and seeks all Segments back
  to <p mtTime>, thereby calling all Tracks to resend their data.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.

  @comm If <p mtTime> is so long ago that it is impossible to invalidate that time,
  the earliest possible time will be used.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Invalidate(
    MUSIC_TIME mtTime,  // @parm The time to invalidate, adjusted by <p dwFlags>. 0 means now.
    DWORD dwFlags)      // @parm Adjusts <p mtTime> to align to measures, beats, etc. See
                        // <t DMPLAYSEGFLAGS>.
{
    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
         Trace(1,"Error: Invalidate() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    EnterCriticalSection( &m_SegmentCrSec );
    EnterCriticalSection( &m_PipelineCrSec );

    SendBuffers();

    // make sure mtTime is greater than the current queue time
    REFERENCE_TIME rtQueue;
    MUSIC_TIME mtQueue;
    MUSIC_TIME mtBumperLength;

    GetQueueTime( &rtQueue );
    ReferenceToMusicTime( rtQueue, &mtQueue );
    ReferenceToMusicTime( m_rtBumperLength, &mtBumperLength );
    if( mtTime < mtQueue + mtBumperLength )
    {
        mtTime = mtQueue + mtBumperLength;
    }
    // resolve mtTime to the boundary of dwFlags
    mtTime = ResolveTime( mtTime, dwFlags, NULL );
    // flush messages
    FlushMainEventQueues( 0, mtTime, mtQueue, FALSE );
    // move any segments in the past list that are affected into the current list
    CSegState *pSegSt;
    CSegState *pNext;
    for (pSegSt = m_SegStateQueues[SQ_SEC_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_SEC_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_SEC_PLAY].Insert( pSegSt );
        }
    }
    for (pSegSt = m_SegStateQueues[SQ_CON_DONE].GetHead();pSegSt;pSegSt = pNext)
    {
        pNext = pSegSt->GetNext();
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_CON_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_CON_PLAY].Insert( pSegSt );
        }
    }
    pSegSt = m_SegStateQueues[SQ_PRI_DONE].GetTail();
    if(pSegSt)
    {
        // only check the last one in this list
        if( pSegSt->m_mtLastPlayed > mtTime )
        {
            m_SegStateQueues[SQ_PRI_DONE].Remove(pSegSt);
            m_SegStateQueues[SQ_PRI_PLAY].Insert( pSegSt );
        }
    }
    // seek back any affected segmentstates that were playing
    DWORD dwCount;
    for( dwCount = SQ_PRI_PLAY; dwCount <= SQ_SEC_PLAY; dwCount++ )
    {
        for( pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
        {
            if( pSegSt->m_fStartedPlay )
            {
                if (SQ_PRI_PLAY == dwCount && pSegSt->m_mtResolvedStart >= mtTime)
                {
                    // resend the segment start notification
                    pSegSt->GenerateNotification( DMUS_NOTIFICATION_SEGSTART, pSegSt->m_mtResolvedStart );
                    // if this is a primary or controlling segment, resend a DMUS_PMSGT_DIRTY message
                    if( !(pSegSt->m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (pSegSt->m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
                    {
                        TraceI(4, "ReSend Dirty PMsg [3] %d (%d)\n", pSegSt->m_mtSeek, pSegSt->m_mtOffset + pSegSt->m_mtSeek);
                        pSegSt->SendDirtyPMsg( pSegSt->m_mtOffset + pSegSt->m_mtSeek );
                    }
                }
                if( pSegSt->m_mtLastPlayed > mtTime )
                {
                    // if mtTime is after the actual start time of the segment,
                    // set it so the segment has never been played before and
                    // seek the segment to the beginning
                    if( pSegSt->m_mtResolvedStart > mtTime )
                    {
                        pSegSt->m_mtLastPlayed = pSegSt->m_mtResolvedStart;
                        pSegSt->m_fStartedPlay = FALSE;
                    }
                    else
                    {
                        pSegSt->m_mtLastPlayed = mtTime;
                    }
                    pSegSt->SetInvalidate( pSegSt->m_mtLastPlayed );
                }
            }
        }
    }

    LeaveCriticalSection( &m_PipelineCrSec );
    LeaveCriticalSection( &m_SegmentCrSec );
    // signal the transport thread so we don't have to wait for it to wake up on its own
    if( m_hTransport ) SetEvent( m_hTransport );
    return S_OK;
}

STDMETHODIMP CPerformance::SetParamHook(IDirectMusicParamHook *pIHook)

{   V_INAME(IDirectMusicPerformance::SetParamHook);
    V_INTERFACE_OPT(pIHook);

    EnterCriticalSection(&m_MainCrSec);
    if (m_pParamHook)
    {
        m_pParamHook->Release();
    }
    m_pParamHook = pIHook;
    if (pIHook)
    {
        pIHook->AddRef();
    }
    LeaveCriticalSection(&m_MainCrSec);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParamEx(
    REFGUID rguidType,
    DWORD dwTrackID,
    DWORD dwGroupBits,
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParamEx);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    static DWORD dwSearchOrder[SQ_COUNT] = { SQ_PRI_PLAY, SQ_SEC_PLAY,
                                      SQ_PRI_DONE, SQ_SEC_DONE,
                                      SQ_PRI_WAIT, SQ_SEC_WAIT,
                                      SQ_CON_PLAY, SQ_CON_DONE,
                                      SQ_CON_WAIT };

    DWORD dwIX;
    HRESULT hr;
    CSegState *pSegNode;
    if (dwTrackID)
    {
        EnterCriticalSection(&m_SegmentCrSec);
        for (dwIX = 0; dwIX < SQ_COUNT; dwIX++)
        {
            pSegNode = m_SegStateQueues[dwSearchOrder[dwIX]].GetHead();
            for (;pSegNode;pSegNode = pSegNode->GetNext())
            {
                if ((pSegNode->m_dwFirstTrackID <= dwTrackID) &&
                    (pSegNode->m_dwLastTrackID >= dwTrackID))
                {
                    CTrack* pCTrack;
                    for (pCTrack = pSegNode->m_TrackList.GetHead();pCTrack;pCTrack = pCTrack->GetNext())
                    {
                        if (pCTrack->m_dwVirtualID == dwTrackID)
                        {
                            m_dwGetParamFlags = pCTrack->m_dwFlags;
                            m_pGetParamSegmentState = pSegNode;
                            break;
                        }
                    }
                    break;
                }
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }
    else
    {
        m_pGetParamSegmentState = NULL;
        m_dwGetParamFlags = 0;
    }
    hr = GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData);
    m_pGetParamSegmentState = NULL;
    m_dwGetParamFlags = 0;
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetParam(
    REFGUID rguidType,
    DWORD dwGroupBits,
    DWORD dwIndex,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void* pData)

{
    V_INAME(IDirectMusicPerformance::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: GetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    if( pmtNext )
    {
        *pmtNext = 0; // this will be replaced by calls to IDMSegment::GetParam
    }
    CSegState* pSegNode;
    CSegState* pSegSource = (CSegState *) m_pGetParamSegmentState;
    DWORD dwOverrideFlags;
    HRESULT hr = DMUS_E_NOT_FOUND;
    BOOL fCheckedPast = FALSE;
    MUSIC_TIME mtOffset;
    DWORD dwRepeat = 0;
    MUSIC_TIME mtSegTime = 0;
    MUSIC_TIME mtSegEnd = 0;
    MUSIC_TIME mtLoopEnd = 0;
    DWORD dwRepeatsLeft = 0;
    if (pSegSource)
    {
        dwOverrideFlags = m_dwGetParamFlags & (DMUS_TRACKCONFIG_OVERRIDE_ALL | DMUS_TRACKCONFIG_OVERRIDE_PRIMARY | DMUS_TRACKCONFIG_FALLBACK);
    }
    else
    {
        dwOverrideFlags = 0;
    }

    if (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_ALL)
    {
        // The calling track wants the controlling param to come from the segment itself
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }
    if (FAILED(hr))
    {
        EnterCriticalSection(&m_SegmentCrSec);
        // we only care about control segments
        if( m_SegStateQueues[SQ_CON_DONE].GetHead() )
        {
            pSegNode = m_SegStateQueues[SQ_CON_DONE].GetHead();
        }
        else
        {
            pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
            fCheckedPast = TRUE;
        }
        while( pSegNode )
        {
            mtSegTime = mtTime;
            if( S_OK == pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
            {
                hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex,
                        mtSegTime, pmtNext, pData );
                if( SUCCEEDED(hr) )
                {
                    dwRepeatsLeft = pSegNode->m_dwRepeats;
                    mtLoopEnd = pSegNode->m_mtLoopEnd;
                    mtSegEnd = pSegNode->m_mtLength;
                    dwRepeatsLeft -= dwRepeat;

                    break; // got the param we want. We're outta this loop with a success.
                }
            }
            // we didn't find the param, so try the next segment.
            pSegNode = pSegNode->GetNext();

            // if we're the last segnode in the done queue, we need to
            // check against the time of the first segnode in the control play queue
            if (!pSegNode && !fCheckedPast )
            {
                pSegNode = m_SegStateQueues[SQ_CON_PLAY].GetHead();
                fCheckedPast = TRUE;
            }
        }
        LeaveCriticalSection(&m_SegmentCrSec);
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_OVERRIDE_PRIMARY))
    {
        // The calling track wants the controlling param to come from the segment
        // itself if there was no controlling segment.
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }

    if( FAILED(hr) ) // didn't find one in the previous, so check for a primary segment
    {
        IDirectMusicSegment* pSegment = NULL;
        mtSegTime = mtTime;
        EnterCriticalSection(&m_SegmentCrSec);
        pSegNode = GetPrimarySegmentAtTime( mtTime );
        if( pSegNode )
        {
            pSegment = pSegNode->m_pSegment;
            pSegment->AddRef();
            pSegNode->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat );
            dwRepeatsLeft = pSegNode->m_dwRepeats;
            mtLoopEnd = pSegNode->m_mtLoopEnd;
            mtSegEnd = pSegNode->m_mtLength;
            dwRepeatsLeft -= dwRepeat;
        }
        else
        {
            Trace(4, "Couldn't find SegState in GetParam call.\n");
        }
        LeaveCriticalSection(&m_SegmentCrSec);
        if( pSegment )
        {
            hr = pSegNode->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            pSegment->Release();
        }
    }

    if( FAILED(hr) && (dwOverrideFlags & DMUS_TRACKCONFIG_FALLBACK))
    {
        // The calling track wants the controlling param to come from the segment itself
        mtSegTime = mtTime;
        if( S_OK == pSegSource->ConvertToSegTime( &mtSegTime, &mtOffset, &dwRepeat ) )
        {
            hr = pSegSource->GetParam( this, rguidType, dwGroupBits, dwIndex,
                    mtSegTime, pmtNext, pData );
            if( SUCCEEDED(hr) )
            {
                dwRepeatsLeft = pSegSource->m_dwRepeats;
                mtLoopEnd = pSegSource->m_mtLoopEnd;
                mtSegEnd = pSegSource->m_mtLength;
                dwRepeatsLeft -= dwRepeat;
            }
        }
    }

    if( FAILED(hr) )
    {   // If we failed, fill in the end time of loop or segment anyway.
        if (pmtNext)
        {   // Check to see if the loop end is earlier than end of segment.
            if (dwRepeatsLeft && (mtLoopEnd > mtSegTime))
            {
                *pmtNext = mtLoopEnd - mtSegTime;
            }
            else // Or, mark end of segment.
            {
                *pmtNext = mtSegEnd - mtSegTime;
            }
        }
        // if we're looking for timesig, and didn't find it anywhere,
        // return the Performance timesig
        if( rguidType == GUID_TimeSignature )
        {
            if( NULL == pData )
            {
                Trace(1,"Error: Null pointer for time signature passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
                DMUS_TIMESIG_PMSG timeSig;

                GetTimeSig( mtTime, &timeSig );
                pTSigData->bBeatsPerMeasure = timeSig.bBeatsPerMeasure;
                pTSigData->bBeat = timeSig.bBeat;
                pTSigData->wGridsPerBeat = timeSig.wGridsPerBeat;
                pTSigData->mtTime = timeSig.mtTime - mtTime;
                hr = S_OK;
            }
        }
        // Likewise, if there was no tempo in a segment, we need to read directly from the tempo list.
        else if  ( rguidType == GUID_TempoParam || rguidType == GUID_PrivateTempoParam)
        {
            if( NULL == pData )
            {
                Trace(1,"Error: Null pointer for tempo passed to GetParam().\n");
                hr = E_POINTER;
            }
            else
            {
                DMInternalTempo* pInternalTempo;
                EnterCriticalSection( &m_PipelineCrSec );
                pInternalTempo = (DMInternalTempo*)m_TempoMap.GetHead();
                DMInternalTempo* pNextTempo = NULL;
                for ( ;pInternalTempo;pInternalTempo = pNextTempo )
                {
                    pNextTempo = (DMInternalTempo *) pInternalTempo->pNext;
                    if (pNextTempo && (pNextTempo->tempoPMsg.mtTime <= mtTime))
                    {
                        continue;
                    }
                    if (rguidType == GUID_TempoParam)
                    {
                        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    else // rguidType == GUID_PrivateTempoParam
                    {
                        PrivateTempo* pTempoData = (PrivateTempo*)pData;
                        pTempoData->mtTime = pInternalTempo->tempoPMsg.mtTime - mtTime;
                        pTempoData->dblTempo = pInternalTempo->tempoPMsg.dblTempo;
                    }
                    if( pmtNext )
                    {
                        *pmtNext = 0;
                    }
                    break;
                }
                LeaveCriticalSection( &m_PipelineCrSec );
                if (pInternalTempo)
                {
                    hr = S_FALSE;
                }
            }
        }
    }
    else // GetParam from a segment succeeded, so we need to clean up the next time parameter to account
         // for loops and end of segment.
    {
        if (pmtNext) // Check to see if the loop end is earlier than *pmtNext.
        {
            if (dwRepeatsLeft && (*pmtNext > (mtLoopEnd - mtSegTime)))
            {
                if (mtLoopEnd >= mtSegTime) // This should always be true, but test anyway.
                {
                    *pmtNext = mtLoopEnd - mtSegTime;
                }
            }
        }
    }
    EnterCriticalSection(&m_MainCrSec);
    if (m_pParamHook && SUCCEEDED(hr))
    {
        hr = m_pParamHook->GetParam(rguidType,dwGroupBits,dwIndex,mtTime,pmtNext,pData,
            pSegSource,m_dwGetParamFlags,hr);

    }
    LeaveCriticalSection(&m_MainCrSec);
    return hr;
}



/*
  @method HRESULT | IDirectMusicPerformance | SetParam |
  Sets data on a Track inside a Primary Segment in this Performance.

  @rvalue S_OK | Success.
  @rvalue DMUS_E_NO_MASTER_CLOCK | There is no master clock in the performance.
  Make sure to call <om .Init> before calling this method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetParam(
    REFGUID rguidType,      // @parm The type of data to set.
    DWORD dwGroupBits,      // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,          // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,      // @parm The time at which to set the data. Unlike
                            // <om IDirectMusicSegment.SetParam>, this time is in
                            // performance time. The start time of the segment is
                            // subtracted from this time, and <om IDirectMusicSegment.SetParam>
                            // is called.
    void* pData)            // @parm The struture containing the data to set. Each
                            // <p pGuidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicPerformance::SetParam);
    V_PTR_WRITE_OPT(pData,1);
    V_REFGUID(rguidType);

    EnterCriticalSection(&m_MainCrSec);
    if( m_pClock == NULL )
    {
        LeaveCriticalSection(&m_MainCrSec);
        Trace(1,"Error: SetParam() failed because the performance has not been initialized.\n");
        return DMUS_E_NO_MASTER_CLOCK;
    }
    LeaveCriticalSection(&m_MainCrSec);

    CSegState* pSegNode;
    IDirectMusicSegment* pSegment = NULL;
    HRESULT hr;

    EnterCriticalSection(&m_SegmentCrSec);
    pSegNode = GetPrimarySegmentAtTime( mtTime );

    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    if( pSegNode )
    {
        pSegment = pSegNode->m_pSegment;
        pSegment->AddRef();
        pSegNode->ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    }
    LeaveCriticalSection(&m_SegmentCrSec);
    if( pSegment )
    {
        hr = pSegment->SetParam( rguidType, dwGroupBits, dwIndex,
                mtTime, pData );
        pSegment->Release();
    }
    else
    {
        Trace(1,"Error: SetParam failed because there is no segment at requested time.\n");
        hr = DMUS_E_NOT_FOUND;
    }
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | GetGlobalParam |
  Gets global values from the Performance.

  @rvalue S_OK | Success.
  @rvalue E_INVALIDARG | <p pGuidType> isn't in the list of global data being handled by this
  Performance. Make sure to call <om IDirectMusicPerformance.SetGlobalParam> first.  Or,
  the value of <p pData> doesn't point to valid memory. Or, <p dwSize> isn't the size
  originally given in <om .SetGlobalParam>
  @rvalue E_POINTER | <p pData> is NULL or invalid.

  @xref <om .SetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::GetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm Allocated memory to receive a copy of the data. This must be
                        // the correct size, which is constant for each <p pGuidType> type of
                        // data, and was also passed in to <om .SetGlobalParam>.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::GetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_WRITE( pData, dwSize );
    }

    GlobalData* pGD;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_GlobalDataCrSec);
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    if( pGD && ( dwSize == pGD->dwSize ) )
    {
        memcpy( pData, pGD->pData, pGD->dwSize );
    }
    else
    {
#ifdef DBG
        if (pGD && ( dwSize != pGD->dwSize ))
        {
            Trace(1,"Error: GetGlobalParam() failed because the passed data size %ld was inconsistent with %ld, set previously.\n",
                dwSize, pGD->dwSize);
        }
        else
        {
            Trace(4,"Warning: GetGlobalParam() failed because the parameter had never been set.\n");
        }
#endif
        hr = E_INVALIDARG;
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);
    return hr;
}

/*
  @method HRESULT | IDirectMusicPerformance | SetGlobalParam |
  Set global values on the Performance.

  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pData> is NULL or invalid.
  @rvalue E_OUTOFMEMORY | Ran out of memory.
  @rvalue E_INVALIDARG | Other failure. pData or dwSize not correct?

  @xref <om .GetGlobalParam>
*/
HRESULT STDMETHODCALLTYPE CPerformance::SetGlobalParam(
    REFGUID rguidType,  // @parm Identifies the type of data.
    void* pData,        // @parm The data itself, which will be copied and stored by the Performance.
    DWORD dwSize        // @parm The size of the data in <p pData>. This should be constant for each
                        // <p pGuidType>. This parameter is needed because the Performance doesn't
                        // know about all types of data, allowing new ones to be created as needed.
    )
{
    V_INAME(IDirectMusicPerformance::SetGlobalParam);
    V_REFGUID(rguidType);

    if( dwSize )
    {
        V_BUFPTR_READ( pData, dwSize );
    }

    GlobalData* pGD;
    // see if this is one of our special Performance globals
    if( rguidType == GUID_PerfMasterTempo )
    {
        if( dwSize == sizeof(float) )
        {
            float flt;
            memcpy( &flt, pData, sizeof(float) );
            if( (flt >= DMUS_MASTERTEMPO_MIN) && (flt <= DMUS_MASTERTEMPO_MAX) )
            {
                if( m_fltRelTempo != flt )
                {
                    m_fltRelTempo = flt;
                    // It's only necessary to recalc the tempo map if something is playing
                    EnterCriticalSection(&m_SegmentCrSec);
                    if (GetPrimarySegmentAtTime(m_mtTransported))
                    {
                        RecalcTempoMap(NULL,m_mtTransported);
                    }
                    LeaveCriticalSection(&m_SegmentCrSec);
                }
            }
        }
        else
        {
            Trace(1,"Error: Attempt to set global tempo failed because dwSize is not size of float.\n");
            return E_INVALIDARG;
        }
    }
    else if( rguidType == GUID_PerfMasterVolume )
    {
        // master volume
        if( dwSize == sizeof(long) )
        {
            memcpy( &m_lMasterVolume, pData, sizeof(long) );
        }
        else
        {
            Trace(1,"Error: Attempt to set global volume failed because dwSize is not size of long.\n");
            return E_INVALIDARG;
        }
        // Go through all Ports and set the master volume.
        // This is also done upon adding a Port.
        IDirectMusicPort* pPort;
        DWORD dw;

        EnterCriticalSection(&m_PChannelInfoCrSec);
        for( dw = 0; dw < m_dwNumPorts; dw++ )
        {
            pPort = m_pPortTable[dw].pPort;
            if( pPort )
            {
                IKsControl *pControl;
                if(SUCCEEDED(pPort->QueryInterface(IID_IKsControl, (void**)&pControl)))
                {
                    KSPROPERTY ksp;
                    ULONG cb;

                    memset(&ksp, 0, sizeof(ksp));
                    ksp.Set   = GUID_DMUS_PROP_Volume;
                    ksp.Id    = 0;
                    ksp.Flags = KSPROPERTY_TYPE_SET;

                    pControl->KsProperty(&ksp,
                                         sizeof(ksp),
                                         (LPVOID)&m_lMasterVolume,
                                         sizeof(m_lMasterVolume),
                                         &cb);
                    pControl->Release();
                }
            }
        }
        LeaveCriticalSection(&m_PChannelInfoCrSec);
    }

    // see if this type is already there. If so, use it.
    EnterCriticalSection(&m_GlobalDataCrSec);
    for( pGD = m_pGlobalData; pGD; pGD = pGD->pNext )
    {
        if( pGD->guidType == rguidType )
        {
            break;
        }
    }
    LeaveCriticalSection(&m_GlobalDataCrSec);
    // if it already exists, just copy the new data into the
    // existing memory block and return
    if( pGD )
    {
        if( pGD->dwSize != dwSize )
        {
            Trace(1,"Error: Attempt to set global parameter failed because dwSize is not consistent with previous SetGlobalParam() call.\n");
            return E_INVALIDARG;
        }
        if( dwSize )
        {
            memcpy( pGD->pData, pData, dwSize );
        }
        return S_OK;
    }

    // otherwise, create new memory
    pGD = new GlobalData;
    if( NULL == pGD )
    {
        return E_OUTOFMEMORY;
    }
    pGD->dwSize = dwSize;
    if( dwSize )
    {
        pGD->pData = (void*)(new char[dwSize]);
        if( NULL == pGD->pData )
        {
            delete pGD;
            return E_OUTOFMEMORY;
        }
        memcpy( pGD->pData, pData, dwSize );
    }
    else
    {
        pGD->pData = NULL;
    }
    pGD->guidType = rguidType;
    EnterCriticalSection(&m_GlobalDataCrSec); // just using this one since it's available and not used much
    pGD->pNext = m_pGlobalData;
    m_pGlobalData = pGD;
    LeaveCriticalSection(&m_GlobalDataCrSec);
    return S_OK;
}

// IDirectMusicTool
/*
  @method HRESULT | IDirectMusicTool | Init |
  Called when the Tool is inserted into the Graph, providing the Tool the opportunity
  to initialize itself.

  @rvalue S_OK | Success.
  @rvalue E_NOTIMPL | Not implemented is a valid return for the method.
*/
HRESULT STDMETHODCALLTYPE CPerformance::Init(
         IDirectMusicGraph* pGraph  // @parm The calling graph.
    )
{
    return E_NOTIMPL;
}

inline bool CPerformance::SendShortMsg( IDirectMusicBuffer* pBuffer,
                                   IDirectMusicPort* pPort,DWORD dwMsg,
                                   REFERENCE_TIME rt, DWORD dwGroup)

{
    if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
    {
        // ran out of room in the buffer
        TraceI(2, "RAN OUT OF ROOM IN THE BUFFER!\n");
        pPort->PlayBuffer( pBuffer );
        pBuffer->Flush();
        // try one more time
        if( FAILED( pBuffer->PackStructured( rt, dwGroup, dwMsg ) ) )
        {
            TraceI(1, "MAJOR BUFFER PACKING FAILURE!\n");
            // if it didn't work this time, free the event because something
            // bad has happened.
            return false;
        }
    }
    return true;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackNote
/*
  HRESULT | CPerformance | PackNote |
  Converts the message into a midiShortMsg, midiLongMsg, or user message
  and packs it into the appropriate IDirectMusicBuffer in the PortTable,
  setting the m_fBufferFilled flag.

  DMUS_PMSG* | pPMsg |
  [in] The message to pack into the buffer.

  REFERENCE_TIME | mt |
  [in] The time (in the Buffer's clock coordinates) at which to queue the message.

  E_INVALIDARG | Either pPMsg or pBuffer is NULL.
  E_OUTOFMEMORY | Failed to pack the buffer.
  DMUS_S_REQUEUE | Tells the Pipeline to requeue this message.
  DMUS_S_FREE | Tells the Pipeline to free this message.
*/
HRESULT CPerformance::PackNote(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pEvent;
    PRIV_PMSG* pPriv = DMUS_TO_PRIV(pEvent);
    REFERENCE_TIME rtLogical; // the time the note occurs in logical music time (subtract offset)
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    short nTranspose = 0;
    short nValue;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pNote->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel,
        &nTranspose )))
    {
        Trace(1,"Play note failed on unassigned PChannel %ld\n",pNote->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if(pPort && pBuffer )
    {
        dwMsg = 0;
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            // transpose the note's bMidiValue, and store it in the note so the note off
            // plays the correct pitch.
            nValue = pNote->bMidiValue + nTranspose;
            if( ( nValue > 127 ) || ( nValue < 0 )
                || pNote->mtDuration <= 0 )
            {
                // don't play this out-of-range or 0-duration note
                pPort->Release();
                pBuffer->Release();
                return DMUS_S_FREE;
            }
            pNote->bMidiValue = (BYTE)nValue;
            dwMsg |= pNote->bVelocity << 16;
        }
        else if( rt < pPriv->rtLast )
        {
            // the note off will play before the note on. Bad.
            rt = pPriv->rtLast + REF_PER_MIL;
        }
        dwMsg |= pNote->bMidiValue << 8; // set note value
        dwMsg |= dwMChannel; // MIDI Channel
        if( pNote->bFlags & DMUS_NOTEF_NOTEON )
        {
            dwMsg |= MIDI_NOTEON;
        }
        else
        {
            dwMsg |= MIDI_NOTEOFF;
        }

        if (SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup))
        {
            EnterCriticalSection(&m_PipelineCrSec); // to prevent deadlock in MusicToReferenceTime
            EnterCriticalSection(&m_PChannelInfoCrSec);
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            rtLogical = rt;
            // subtract the offset if needed, but only for a note on.
            if( pNote->nOffset && (pNote->bFlags & DMUS_NOTEF_NOTEON))
            {
                MUSIC_TIME mtTemp = pNote->mtTime - pNote->nOffset + 1;
                REFERENCE_TIME rtTemp;
                MusicToReferenceTime( mtTemp, &rtTemp );
                if( rtTemp > rtLogical )
                {
                    rtLogical = rtTemp;
                }
            }
            if( m_pPortTable[dwPortTableIndex].rtLast < rtLogical )
            {
                m_pPortTable[dwPortTableIndex].rtLast = rtLogical;
            }
            LeaveCriticalSection(&m_PChannelInfoCrSec);
            LeaveCriticalSection(&m_PipelineCrSec);

            if( pNote->bFlags & DMUS_NOTEF_NOTEON )
            {
                pPriv->rtLast = rt;
                m_rtHighestPackedNoteOn = rt;
                if (pNote->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message.
                    rt = pNote->rtTime;
                    pNote->rtTime += (pNote->mtDuration * REF_PER_MIL);
                    if (pNote->mtDuration > 1)
                    {
                        pNote->rtTime -= REF_PER_MIL;
                    }
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( pNote->rtTime < rt + 1 )
                    {
                        pNote->rtTime = rt + 1;
                    }
                    pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                    pNote->dwFlags &= ~DMUS_PMSGF_MUSICTIME;
                    hr = DMUS_S_REQUEUE;
                }
                else
                {
                    pNote->mtTime += pNote->mtDuration;
                    if (pNote->mtDuration > 1)
                    {
                        pNote->mtTime--;
                    }
                    MusicToReferenceTime( pNote->mtTime, &rt );
                    // subtract 1 to guarantee that a note off at the same time as a note on doesn't
                    // stop the note on short. It's possible that rt == pNote->rtTime, if the duration
                    // was zero, so be sure to check that.
                    if( rt < pNote->rtTime + 2 )
                    {
                        rt = pNote->rtTime + 2;
                    }
                    pNote->rtTime = rt - 1;
                }
                pNote->bFlags &= ~DMUS_NOTEF_NOTEON; // make this a note off now
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackCurve
HRESULT CPerformance::PackCurve(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;
    BOOL fCalcStartValue = FALSE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pEvent )
        return E_INVALIDARG;

    // store the original start time so we know how far into the curve we are
    if( pCurve->mtOriginalStart == 0 )
    {
        // if we're flushing and have never played this curve at all, just free
        // it.
        if( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH )
        {
            return DMUS_S_FREE;
        }
        if (pCurve->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
        {
            // This is a clock time message. Convert the duration into music time. It will act as
            // a music time message from now on. This does have the downside that if a dramatic tempo
            // change occurs in the middle of a lengthy curve, the end time can be distorted.
            // But, given the purpose of curves, this is really an unlikely issue.
            MUSIC_TIME mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtDuration = mtTemp;
            ReferenceToMusicTime(pCurve->rtTime + (pCurve->mtResetDuration * REF_PER_MIL),&mtTemp);
            mtTemp -= pCurve->mtTime;
            pCurve->mtResetDuration = mtTemp;
            pCurve->dwFlags &= ~DMUS_PMSGF_LOCKTOREFTIME;
        }
        pCurve->mtOriginalStart = pCurve->mtTime;
        // check the latency clock. Adjust pCurve->mtTime if needed. This can happen
        // if the curve is time-stamped for the past. We only need do this for non-instant
        // curve types.
        if( pCurve->bCurveShape != DMUS_CURVES_INSTANT )
        {
            REFERENCE_TIME rtLatency = GetLatency();
            MUSIC_TIME mtLatency;
            ReferenceToMusicTime( rtLatency, &mtLatency );
            if( pCurve->mtTime < mtLatency )
            {
                if( pCurve->mtTime + pCurve->mtDuration < mtLatency )
                {
                    // If it is far enough in the past,
                    // we only need to send out the final value.
                    pCurve->mtTime += pCurve->mtDuration;
                }
                else
                {
                    pCurve->mtTime = mtLatency;
                }
            }
            // If this is the start of a curve and we are supposed to start with the current playing value...
            if (pCurve->bFlags & DMUS_CURVE_START_FROM_CURRENT)
            {
                fCalcStartValue = TRUE;
            }
            else
            {
                pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
            }
        }
    }
    // it is necessary to check reset duration >= 0 because it could have been set
    // to be negative by the flushing, and we don't want to toss it in that case.
    // (should no longer be necessary to check, as a result of fixing 33987)
    if( ( pCurve->bFlags & DMUS_CURVE_RESET ) && (pCurve->mtResetDuration >= 0) && ( pCurve->mtTime ==
        pCurve->mtDuration + pCurve->mtResetDuration + pCurve->mtOriginalStart ))
    {
        if( !( pCurve->dwFlags & DMUS_PMSGF_TOOL_FLUSH ) )
        {
            PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pEvent);
            if ( (pPrivPMsg->dwPrivFlags & PRIV_FLAG_FLUSH) )
            {
                pPrivPMsg->dwPrivFlags &= ~PRIV_FLAG_FLUSH;
                pCurve->dwFlags |= DMUS_PMSGF_TOOL_FLUSH;
                MUSIC_TIME mt = 0;
                if( rt <= pPrivPMsg->rtLast )
                {
                    return PackCurve( pEvent, pPrivPMsg->rtLast + REF_PER_MIL );
                }
                else
                {
                    return PackCurve( pEvent, rt );
                }
            }
            else
            {
                // the reset duration has expired, and we're not flushing, so expire the event.
                return DMUS_S_FREE;
            }
        }
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pCurve->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play curve failed on unassigned PChannel %ld\n",pCurve->dwPChannel);
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
    {
        DWORD dwCurve;
        DWORD dwMergeIndex = 0;
        dwMsg = 0;
        if (pCurve->dwFlags & DMUS_PMSGF_DX8)
        {
            dwMergeIndex = pCurve->wMergeIndex;
        }
        switch( pCurve->bType )
        {
        case DMUS_CURVET_PBCURVE:
            if (fCalcStartValue)
            {
                pCurve->nStartValue =
                    (short) pChannelMap->m_PitchbendMerger.GetIndexedValue(dwMergeIndex) + 0x2000;
            }
            dwCurve = ComputeCurve( pCurve );
            dwCurve = pChannelMap->m_PitchbendMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x2000,0x3FFF);
            dwMsg = MIDI_PBEND;
            dwMsg |= ( (dwCurve & 0x7F) << 8);
            dwCurve = dwCurve >> 7;
            dwMsg |= ( (dwCurve & 0x7F) << 16);
            break;
        case DMUS_CURVET_CCCURVE:
            switch (pCurve->bCCData)
            {
            case MIDI_CC_MOD_WHEEL:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ModWheelMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ModWheelMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_VolumeMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_VolumeMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_PAN:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_PanMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_PanMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ExpressionMerger.GetVolumeStart(dwMergeIndex);
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ExpressionMerger.MergeMidiVolume(dwMergeIndex,(BYTE) dwCurve);
                break;
            case MIDI_CC_FILTER:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_FilterMerger.GetIndexedValue(dwMergeIndex) + 0x40;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_FilterMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ReverbMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ReverbMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                if (fCalcStartValue)
                {
                    pCurve->nStartValue =
                        (short) pChannelMap->m_ChorusMerger.GetIndexedValue(dwMergeIndex) + 0x7F;
                }
                dwCurve = ComputeCurve( pCurve );
                dwCurve = pChannelMap->m_ChorusMerger.MergeValue(dwMergeIndex,(long)dwCurve,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                dwCurve = ComputeCurve( pCurve );
                pChannelMap->Reset(pCurve->nEndValue);
                break;
            default:
                dwCurve = ComputeCurve( pCurve );
                break;
            }
            dwMsg = MIDI_CCHANGE;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_MATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_MTOUCH;
            dwMsg |= (dwCurve << 8);
            break;
        case DMUS_CURVET_PATCURVE:
            dwCurve = ComputeCurve( pCurve );
            dwMsg = MIDI_PTOUCH;
            dwMsg |= (pCurve->bCCData << 8);
            dwMsg |= (dwCurve << 16);
            break;
        case DMUS_CURVET_RPNCURVE:
        case DMUS_CURVET_NRPNCURVE:
            if (pCurve->dwFlags & DMUS_PMSGF_DX8)
            {
                dwCurve = ComputeCurve( pCurve );
                DWORD dwMsg2 = MIDI_CCHANGE;
                dwMsg = MIDI_CCHANGE;
                // First, send the two CC commands to select which RPN or NRPN event.
                if (pCurve->bType == DMUS_CURVET_RPNCURVE)
                {
                    dwMsg |= (MIDI_CC_RPN_MSB << 8);
                    dwMsg2 |= (MIDI_CC_RPN_LSB << 8);
                }
                else
                {
                    dwMsg |= (MIDI_CC_NRPN_MSB << 8);
                    dwMsg2 |= (MIDI_CC_NRPN_LSB << 8);
                }
                dwMsg |= (pCurve->wParamType  & 0x3F80) << 9;  // Upper 8 bits of command #
                dwMsg2 |= (pCurve->wParamType & 0x7F) << 16;   // Lower 8 bits.
                dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                dwMsg2 |= pChannelMap->dwMChannel; // MIDI Channel
                SendShortMsg(pBuffer,pPort,dwMsg,rt-3,pChannelMap->dwGroup); // Too bad if it fails!
                SendShortMsg(pBuffer,pPort,dwMsg2,rt-2,pChannelMap->dwGroup);
                // Then, send the two data CC commands.
                dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYMSB << 8);
                dwMsg |= (dwCurve & 0x3F80) << 9;  // Upper 8 bits of data
                dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
                SendShortMsg(pBuffer,pPort,dwMsg,rt-1,pChannelMap->dwGroup);
                dwMsg = MIDI_CCHANGE | (MIDI_CC_DATAENTRYLSB << 8);
                dwMsg |= (dwCurve & 0x7F) << 16;  // Lower 8 bits of data
            }
        }
        if (dwMsg) // Make sure we successfully created a message.
        {
            dwMsg |= pChannelMap->dwMChannel; // MIDI Channel
            if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
            {
                m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
                m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;

                // ComputeCurve() will set this to 0 if it's time to free the event. Otherwise, it
                // will set it to the next time this event should be performed.
                if( pCurve->rtTime )
                {
                    // If we didn't calculate the time slice because we didn't know
                    // what the start value was, do it now.
                    if (fCalcStartValue)
                    {
                        pCurve->wMeasure = (WORD) ComputeCurveTimeSlice(pCurve);    // Use this to store the time slice interval.
                    }
                    hr = DMUS_S_REQUEUE;
                }
            }
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackMidi
HRESULT CPerformance::PackMidi(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_MIDI_PMSG* pMidi = (DMUS_MIDI_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwMsg;
//  DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;
    CChannelMap *pChannelMap = NULL;

    if( NULL == pMidi )
        return E_INVALIDARG;

    EnterCriticalSection(&m_PChannelInfoCrSec);
    pChannelMap = GetPChannelMap(pMidi->dwPChannel);
    if (!pChannelMap)
    {
        Trace(1,"Play MIDI failed on unassigned PChannel %ld\n",pMidi->dwPChannel);
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }

    if( pChannelMap->dwPortIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[pChannelMap->dwPortIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[pChannelMap->dwPortIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if(pPort && pBuffer )
    {
        pMidi->bStatus &= 0xF0;
        if (pMidi->bStatus == MIDI_CCHANGE)
        {
            switch (pMidi->bByte1)
            {
            case MIDI_CC_MOD_WHEEL:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ModWheelMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_VOLUME:
                pMidi->bByte2 = pChannelMap->m_VolumeMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_PAN:
                pMidi->bByte2 = (BYTE) pChannelMap->m_PanMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_EXPRESSION:
                pMidi->bByte2 = pChannelMap->m_ExpressionMerger.MergeMidiVolume(0,pMidi->bByte2);
                break;
            case MIDI_CC_FILTER:
                pMidi->bByte2 = (BYTE) pChannelMap->m_FilterMerger.MergeValue(0,pMidi->bByte2,0x40,0x7F);
                break;
            case MIDI_CC_REVERB:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ReverbMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_CHORUS:
                pMidi->bByte2 = (BYTE) pChannelMap->m_ChorusMerger.MergeValue(0,pMidi->bByte2,0x7F,0x7F);
                break;
            case MIDI_CC_RESETALL:
                pChannelMap->Reset(pMidi->bByte2);
                break;
            }

        }
        else if (pMidi->bStatus == MIDI_PBEND)
        {
            WORD wBend = pMidi->bByte1 | (pMidi->bByte2 << 7);
            wBend = (WORD) pChannelMap->m_PitchbendMerger.MergeValue(0,wBend,0x2000,0x3FFF);
            pMidi->bByte1 = wBend & 0x7F;
            pMidi->bByte2 = (wBend >> 7) & 0x7F;
        }
        dwMsg = pMidi->bByte1 << 8;
        dwMsg |= pMidi->bByte2 << 16;
        dwMsg |= pMidi->bStatus;
        dwMsg |= pChannelMap->dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,pChannelMap->dwGroup))
        {
            m_pPortTable[pChannelMap->dwPortIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[pChannelMap->dwPortIndex].rtLast = rt;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackSysEx
HRESULT CPerformance::PackSysEx(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_SYSEX_PMSG* pSysEx = (DMUS_SYSEX_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( NULL == m_pDirectMusic )
        return DMUS_E_NOT_INIT;

    if( FAILED( PChannelIndex( pSysEx->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play SysEx failed on unassigned PChannel %ld\n",pSysEx->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort )
    {
        // create a buffer of the right size
        DMUS_BUFFERDESC dmbd;
        memset( &dmbd, 0, sizeof(DMUS_BUFFERDESC) );
        dmbd.dwSize = sizeof(DMUS_BUFFERDESC);
        dmbd.cbBuffer = pSysEx->dwLen + 48;

        EnterCriticalSection(&m_MainCrSec);
        if( SUCCEEDED( m_pDirectMusic->CreateMusicBuffer(&dmbd, &pBuffer, NULL)))
        {
            if( SUCCEEDED( pBuffer->PackUnstructured( rt - 4, dwGroup, pSysEx->dwLen, pSysEx->abData ) ) )
            {
                pPort->PlayBuffer(pBuffer);
            }
            pBuffer->Release();
        }
        LeaveCriticalSection(&m_MainCrSec);
    }
    if( pPort ) pPort->Release();
    return hr;
}

//////////////////////////////////////////////////////////////////////
// CPerformance::PackPatch
HRESULT CPerformance::PackPatch(
            DMUS_PMSG* pEvent,
            REFERENCE_TIME rt )
{
    DMUS_PATCH_PMSG* pPatch = (DMUS_PATCH_PMSG*)pEvent;
    IDirectMusicBuffer* pBuffer = NULL;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup, dwMChannel, dwPortTableIndex;
    DWORD dwMsg;
    HRESULT hr = DMUS_S_FREE;

    if( NULL == pEvent )
        return E_INVALIDARG;

    if( FAILED( PChannelIndex( pPatch->dwPChannel, &dwPortTableIndex, &dwGroup, &dwMChannel)))
    {
        Trace(1,"Play Patch failed on unassigned PChannel %ld\n",pPatch->dwPChannel);
        return DMUS_S_FREE; // the PChannel map wasn't found. Just free the event.
    }
    EnterCriticalSection(&m_PChannelInfoCrSec);
    if( dwPortTableIndex > m_dwNumPorts )
    {
        pPort = NULL; // the PChannel map is out of range of the number of ports
                    // so return outta here! (see after the LeaveCriticalSection)
    }
    else
    {
        pPort = m_pPortTable[dwPortTableIndex].pPort;
        if( pPort ) pPort->AddRef();
        pBuffer = m_pPortTable[dwPortTableIndex].pBuffer;
        if( pBuffer ) pBuffer->AddRef();
    }
    if( pPort && pBuffer)
    {
        // subtract 10 from rt to guarantee that patch events always go out earlier than
        // notes with the same time stamp.
        rt -= 10;
        // send the bank select lsb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_LSB << 8 );
        dwMsg |= (pPatch->byLSB << 16);
        ASSERT( dwMChannel < 16 );
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-2,dwGroup);
        // send the bank select msb
        dwMsg = MIDI_CCHANGE;
        dwMsg |= ( MIDI_CC_BS_MSB << 8 );
        dwMsg |= (pPatch->byMSB << 16);
        dwMsg |= dwMChannel;
        SendShortMsg(pBuffer,pPort,dwMsg,rt-1,dwGroup);
        // send the program change
        dwMsg = MIDI_PCHANGE;
        dwMsg |= (pPatch->byInstrument << 8);
        dwMsg |= dwMChannel;
        if (SendShortMsg(pBuffer,pPort,dwMsg,rt,dwGroup))
        {
            m_pPortTable[dwPortTableIndex].fBufferFilled = TRUE; // so we send this in SendBuffers
            m_pPortTable[dwPortTableIndex].rtLast = rt;
        }
    }
    LeaveCriticalSection(&m_PChannelInfoCrSec);
    if( pPort ) pPort->Release();
    if( pBuffer ) pBuffer->Release();
    return hr;
}

HRESULT CPerformance::PackWave(DMUS_PMSG* pPMsg, REFERENCE_TIME rtTime)
{
    DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
    HRESULT hr = DMUS_S_FREE;

    IDirectMusicVoiceP *pVoice = (IDirectMusicVoiceP *) pWave->punkUser;
    if (pVoice)
    {
        if (pWave->bFlags & DMUS_WAVEF_OFF)
        {
            pVoice->Stop(rtTime);
            EnterCriticalSection(&m_SegmentCrSec);
            for (DWORD dwCount = 0; dwCount < SQ_COUNT; dwCount++)
            {
                for( CSegState* pSegSt = m_SegStateQueues[dwCount].GetHead(); pSegSt; pSegSt = pSegSt->GetNext() )
                {
                    CTrack* pTrack = pSegSt->m_TrackList.GetHead();
                    while( pTrack )
                    {
                        if (pTrack->m_guidClassID == CLSID_DirectMusicWaveTrack)
                        {
                            IPrivateWaveTrack* pWaveTrack = NULL;
                            if (pTrack->m_pTrack &&
                                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pWaveTrack)))
                            {
                                pWaveTrack->OnVoiceEnd(pVoice, pTrack->m_pTrackState);
                                pWaveTrack->Release();
                            }
                        }
                        pTrack = pTrack->GetNext();
                    }
                }
            }
            LeaveCriticalSection(&m_SegmentCrSec);
        }
        else
        {
            if (SUCCEEDED(pVoice->Play(rtTime, pWave->lPitch, pWave->lVolume)))
            {
                if (pWave->dwFlags & DMUS_PMSGF_LOCKTOREFTIME)
                {
                    // This is a clock time message.
                    pWave->rtTime += pWave->rtDuration ;
                    pWave->dwFlags &= ~DMUS_PMSGF_MUSICTIME;

                }
                else
                {
                    pWave->mtTime += (MUSIC_TIME) pWave->rtDuration;
                    pWave->dwFlags &= ~DMUS_PMSGF_REFTIME;
                }
                pWave->bFlags |= DMUS_WAVEF_OFF;   // Queue this back up as a wave off.
                hr = DMUS_S_REQUEUE;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::ProcessPMsg(
    IDirectMusicPerformance* pPerf, // @parm The performance pointer.
    DMUS_PMSG* pPMsg            // @parm The message to process.
    )
{
    V_INAME(IDirectMusicTool::ProcessPMsg);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    if (m_rtQueuePosition > pPMsg->rtTime + 50000000)
    {
        // pMSg is more than 5 seconds in the past; get rid of it unless it's signalling the
        // end of something that's already been started.
        if (pPMsg->dwType == DMUS_PMSGT_NOTIFICATION)
        {
            DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
            if ( (pNotify->guidNotificationType == GUID_NOTIFICATION_PERFORMANCE &&
                  pNotify->dwNotificationOption != DMUS_NOTIFICATION_MUSICSTOPPED) ||
                 (pNotify->guidNotificationType == GUID_NOTIFICATION_SEGMENT &&
                  pNotify->dwNotificationOption != DMUS_NOTIFICATION_SEGEND) )
            {
                return DMUS_S_FREE;
            }
        }
        else if (pPMsg->dwType == DMUS_PMSGT_NOTE)
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if (pNote->bFlags & DMUS_NOTEF_NOTEON)
            {
                return DMUS_S_FREE;
            }
        }
        else if (pPMsg->dwType == DMUS_PMSGT_WAVE)
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (!(pWave->bFlags & DMUS_WAVEF_OFF))
            {
                return DMUS_S_FREE;
            }
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    HRESULT hr = DMUS_S_FREE;

    ASSERT( pPerf == this );
    if( pPMsg->dwType == DMUS_PMSGT_TEMPO )
    {
        PRIV_PMSG* pPrivPMsg = DMUS_TO_PRIV(pPMsg);
        // If the pmsg was generated by a track, discard it
        // because it was already placed in the tempo map.
        if( pPrivPMsg->dwPrivFlags & PRIV_FLAG_TRACK )
        {
            return DMUS_S_FREE;
        }
        // Otherwise, this was generated by the application, so it's not already
        // in the tempo map and we need to add it.
        AddEventToTempoMap( DMUS_TO_PRIV(pPMsg));
        return DMUS_S_FREE; // OK to free this event; not requeued
    }

    if ((pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) ||
        (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_PERFORMANCE))
    {
        // Scan through all the pchannels and make copies of the message for each pchannel.
        // Then, release this one.
        DWORD dwMax = PCHANNEL_BLOCKSIZE;
        // If one per channel group (for sysex, for example,) do only one per block.
        if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_GROUPS) dwMax = 1;
        EnterCriticalSection(&m_PipelineCrSec); // Make sure we are in this so we don't deadlock in SendPMsg().
        EnterCriticalSection(&m_PChannelInfoCrSec);
        CChannelBlock*  pChannelBlock = m_ChannelBlockList.GetHead();
        for( ; pChannelBlock; pChannelBlock = pChannelBlock->GetNext() )
        {
            DWORD dwIndex;
            for (dwIndex = 0; dwIndex < dwMax; dwIndex++)
            {
                CChannelMap* pChannelMap = &pChannelBlock->m_aChannelMap[ dwIndex ];
                if( pChannelMap->dwGroup &&
                    (pChannelMap->wFlags & (CMAP_STATIC | CMAP_VIRTUAL)))
                {
                    DWORD dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                    // If this is a transpose on the drum channel, don't send it.
                    if ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwPChannel & 0xF) != 9))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            pNewMsg->dwPChannel = dwIndex + pChannelBlock->m_dwPChannelStart;
                            SendPMsg(pNewMsg);
                        }
                    }
                }
            }
        }
        LeaveCriticalSection(&m_PChannelInfoCrSec);
        LeaveCriticalSection(&m_PipelineCrSec);
        return DMUS_S_FREE;
    }

    if(pPMsg->dwType == DMUS_PMSGT_TRANSPOSE)
    {
        if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_QUEUE ))
        {
            // requeue any tranpose event to be queue time
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            DMUS_TRANSPOSE_PMSG* pTrans = (DMUS_TRANSPOSE_PMSG*)pPMsg;
            // set the PChannel for this transpose message
            EnterCriticalSection(&m_PChannelInfoCrSec);
            CChannelMap * pChannelMap = GetPChannelMap(pPMsg->dwPChannel);
            if (pChannelMap)
            {
                WORD wMergeIndex = 0;
                if (pPMsg->dwFlags & DMUS_PMSGF_DX8)
                {
                    wMergeIndex = pTrans->wMergeIndex;
                }
                pChannelMap->nTranspose = pChannelMap->m_TransposeMerger.MergeTranspose(
                    wMergeIndex,pTrans->nTranspose);
            }
            LeaveCriticalSection(&m_PChannelInfoCrSec);
            return DMUS_S_FREE;
        }
    }

    if(pPMsg->dwType == DMUS_PMSGT_NOTIFICATION )
    {
        DMUS_NOTIFICATION_PMSG* pNotify = (DMUS_NOTIFICATION_PMSG*)pPMsg;
        if (pNotify->guidNotificationType == GUID_NOTIFICATION_PRIVATE_CHORD)
        {
            // if we've got a GUID_NOTIFICATION_PRIVATE_CHORD,
            // invalidate/regenerate queued note events as necessary
            EnterCriticalSection(&m_PipelineCrSec);
            OnChordUpdateEventQueues(pNotify);
            LeaveCriticalSection(&m_PipelineCrSec);
            return DMUS_S_FREE;
        }
        else if( !( pPMsg->dwFlags & DMUS_PMSGF_TOOL_ATTIME ))
        {
            // requeue any notification event to be ontime
            pPMsg->dwFlags |= DMUS_PMSGF_TOOL_ATTIME;
            pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_IMMEDIATE );
            return DMUS_S_REQUEUE;
        }
        else
        {
            // otherwise, fire the notification
            // first, move the event into the notification queue.
            // The app then calls GetNotificationPMsg to get the event.
            CLEARTOOLGRAPH(pPMsg);
            EnterCriticalSection(&m_PipelineCrSec);
            m_NotificationQueue.Enqueue( DMUS_TO_PRIV(pPMsg) );
            LeaveCriticalSection(&m_PipelineCrSec);
            EnterCriticalSection(&m_MainCrSec);
            if( m_hNotification )
            {
                SetEvent(m_hNotification);
            }
            LeaveCriticalSection(&m_MainCrSec);
            return S_OK; // don't free since we've placed the event into the
            // notification queue
        }
    }

    // add time signature changes to the time sig queue
    if(pPMsg->dwType == DMUS_PMSGT_TIMESIG )
    {
        CLEARTOOLGRAPH(pPMsg);
        DMUS_TIMESIG_PMSG* pTimeSig = (DMUS_TIMESIG_PMSG*)pPMsg;

        // check for a legal time signature, which may not have any
        // members equal to 0, and bBeat must be evenly divisible by 2.
        if( pTimeSig->wGridsPerBeat &&
            pTimeSig->bBeatsPerMeasure &&
            pTimeSig->bBeat &&
            ( 0 == ( pTimeSig->bBeat % 2 )))
        {
            EnterCriticalSection(&m_PipelineCrSec);
            REFERENCE_TIME rtNow = GetTime() - (10000 * 1000); // keep around for a second.
            PRIV_PMSG* pCheck;
            while (pCheck = m_TimeSigQueue.FlushOldest(rtNow))
            {
                FreePMsg(pCheck);
            }
            m_TimeSigQueue.Enqueue(  DMUS_TO_PRIV(pPMsg) );
            LeaveCriticalSection(&m_PipelineCrSec);
            return S_OK;
        }
        else
        {
            return DMUS_S_FREE;
        }
    }

    // requeue anything else that's early to be neartime
    if (pPMsg->dwFlags & DMUS_PMSGF_TOOL_IMMEDIATE)
    {
        // if this is a stop command, make sure the segment state doesn't keep going
        if( pPMsg->dwType == DMUS_PMSGT_STOP )
        {
            IDirectMusicSegment* pSeg = NULL;
            IDirectMusicSegmentState* pSegState = NULL;
            if( pPMsg->punkUser )
            {
                if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegment,
                    (void**)&pSeg )))
                {
                    pSeg = NULL;
                }
                else if( FAILED( pPMsg->punkUser->QueryInterface( IID_IDirectMusicSegmentState,
                    (void**)&pSegState )))
                {
                    pSegState = NULL;
                }
            }
            if( pSeg || pSegState )
            {
                EnterCriticalSection(&m_SegmentCrSec);
                if( pPMsg->mtTime > m_mtTransported )
                {
                    // find and mark the segment and/or segment state to not play beyond
                    // the stop point.
                    CSegState* pNode;
                    DWORD dwCount;
                    for (dwCount = 0; dwCount < SQ_COUNT; dwCount++)
                    {
                        for( pNode = m_SegStateQueues[dwCount].GetHead(); pNode; pNode = pNode->GetNext() )
                        {
                            if( (pNode->m_pSegment == pSeg) ||
                                (pNode == pSegState) )
                            {
                                pNode->m_mtStopTime = pPMsg->mtTime;
                            }
                        }
                    }
                }
                LeaveCriticalSection(&m_SegmentCrSec);
                if( pSeg )
                {
                    pSeg->Release();
                }
                if( pSegState )
                {
                    pSegState->Release();
                }
            }
        }
        pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
        pPMsg->dwFlags &= ~( DMUS_PMSGF_TOOL_ATTIME | DMUS_PMSGF_TOOL_IMMEDIATE );
        return DMUS_S_REQUEUE;
    }

    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            hr = PackNote(  pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            hr = PackCurve( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_SYSEX:
        {
            hr = PackSysEx( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_MIDI:
        {
            hr = PackMidi( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_PATCH:
        {
            hr = PackPatch( pPMsg, pPMsg->rtTime );
        }
        break;
    case DMUS_PMSGT_CHANNEL_PRIORITY:
        {
            DMUS_CHANNEL_PRIORITY_PMSG* pPriPMsg = (DMUS_CHANNEL_PRIORITY_PMSG*)pPMsg;
            DWORD dwPortTableIndex, dwGroup, dwMChannel;
            IDirectMusicPort* pPort;

            hr = DMUS_S_FREE;
            if( SUCCEEDED( PChannelIndex( pPriPMsg->dwPChannel, &dwPortTableIndex, &dwGroup,
                &dwMChannel )))
            {
                EnterCriticalSection(&m_PChannelInfoCrSec);
                if( dwPortTableIndex <= m_dwNumPorts )
                {
                    pPort = m_pPortTable[dwPortTableIndex].pPort;
                    if( pPort )
                    {
                        pPort->SetChannelPriority( dwGroup, dwMChannel,
                            pPriPMsg->dwChannelPriority );
                    }
                }
                LeaveCriticalSection(&m_PChannelInfoCrSec);
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            hr = PackWave( pPMsg, pPMsg->rtTime );
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::Flush(
    IDirectMusicPerformance* pPerf, // @parm The Performance pointer.
     DMUS_PMSG* pPMsg,          // @parm The event to flush.
     REFERENCE_TIME rtTime          // @parm The time at which to flush.
    )
{
    V_INAME(IDirectMusicTool::Flush);
    V_INTERFACE(pPerf);
    V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));

    HRESULT hr = S_OK;

    ASSERT( pPerf == this );
    switch( pPMsg->dwType )
    {
    case DMUS_PMSGT_NOTE:
        {
            DMUS_NOTE_PMSG* pNote = (DMUS_NOTE_PMSG*)pPMsg;
            if( !(pNote->bFlags & DMUS_NOTEF_NOTEON) )
            {
                PackNote( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_CURVE:
        {
            DMUS_CURVE_PMSG* pCurve = (DMUS_CURVE_PMSG*)pPMsg;
            if( pCurve->bFlags & DMUS_CURVE_RESET )
            {
                PackCurve( pPMsg, rtTime );
            }
        }
        break;
    case DMUS_PMSGT_WAVE:
        {
            DMUS_WAVE_PMSG* pWave = (DMUS_WAVE_PMSG*)pPMsg;
            if (pWave->bFlags & DMUS_WAVEF_OFF)
            {
                PackWave( pPMsg, rtTime );
            }
        }
    default:
        break;
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMsgDeliveryType(
    DWORD* pdwDeliveryType) // @parm Should return either DMUS_PMSGF_TOOL_IMMEDIATE, DMUS_PMSGF_TOOL_QUEUE, or DMUS_PMSGF_TOOL_ATTIME.
                    // An illegal return value will be treated as DMUS_PMSGF_TOOL_IMMEDIATE by the <i IDirectMusicGraph>.
{
    V_INAME(IDirectMusicTool::GetMsgDeliveryType);
    V_PTR_WRITE(pdwDeliveryType,DWORD);

    *pdwDeliveryType = DMUS_PMSGF_TOOL_IMMEDIATE;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypeArraySize(
    DWORD* pdwNumElements) // @parm Returns the number of media types, with 0 meaning all.
{
    V_INAME(IDirectMusicTool::GetMediaTypeArraySize);
    V_PTR_WRITE(pdwNumElements,DWORD);

    *pdwNumElements = 0;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetMediaTypes(
    DWORD** padwMediaTypes, // @parm This should be a DWORD array of size <p dwNumElements>.
                            // Upon return, the elements will be filled with the media types
                            // this Tool supports.
    DWORD dwNumElements)    // @parm Contains the number of elements, i.e. the size, of the
                            // array <p padwMediaTypes>. <p dwNumElements> should be equal
                            // to the number returned in
                            // <om IDirectMusicTool.GetMediaTypeArraySize>. If dwNumElements
                            // is less than this number, this method can't return all of the
                            // message types that are supported. If it is greater than this
                            // number, the element fields in the array will be set to zero.
{
    return E_NOTIMPL;
}

// IDirectMusicGraph
HRESULT STDMETHODCALLTYPE CPerformance::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::InsertTool(
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CPerformance::StampPMsg( DMUS_PMSG* pPMsg )
{
    V_INAME(IDirectMusicGraph::StampPMsg);
    if( m_dwVersion < 8)
    {
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_PTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }

    EnterCriticalSection(&m_MainCrSec);
    if( m_pGraph && ( S_OK == m_pGraph->StampPMsg( pPMsg )))
    {
        if (pPMsg->pGraph != this)
        {
            if( pPMsg->pGraph )
            {
                pPMsg->pGraph->Release();
                pPMsg->pGraph = NULL;
            }
            pPMsg->pGraph = this;
            pPMsg->pGraph->AddRef();
        }
        LeaveCriticalSection(&m_MainCrSec);
        return S_OK;
    }
    LeaveCriticalSection(&m_MainCrSec);
    if( pPMsg->pGraph )
    {
        pPMsg->pGraph->Release();
        pPMsg->pGraph = NULL;
    }
    if( pPMsg->pTool )
    {
        pPMsg->pTool->Release();
        pPMsg->pTool = NULL;
    }

    //otherwise there is no graph: set it to the internal Performance Tool
    pPMsg->dwFlags &= ~(DMUS_PMSGF_TOOL_IMMEDIATE | DMUS_PMSGF_TOOL_QUEUE | DMUS_PMSGF_TOOL_ATTIME);
    pPMsg->dwFlags |= DMUS_PMSGF_TOOL_QUEUE;
    pPMsg->pTool = this;
    pPMsg->pTool->AddRef();
    return S_OK;
}

// default scale is C Major
const DWORD DEFAULT_SCALE_PATTERN = 0xab5ab5;

inline DWORD BitCount(DWORD dwPattern)

{
    DWORD dwCount = 0;

    while (dwPattern)
    {
        dwPattern &= (dwPattern - 1);
        dwCount++;
    }

    return dwCount;
}

inline bool InScale(BYTE bMIDI, BYTE bRoot, DWORD dwScale)
{
    TraceI(3, "note: %d root: %d scale: %x\n", bMIDI, bRoot, dwScale);
    // shift the note by the scale root, and put it in a one-octave range
    bMIDI = ((bMIDI + 12) - (bRoot % 12)) % 12;
     // merge two octaves of scale into one
    dwScale = (dwScale & 0x0fff) | ((dwScale >> 12) & 0x0fff);
    // note n is in scale if there's a bit in position n
    TraceI(3, "shifted note: %d shifted scale: %x\n", bMIDI, dwScale);
    return ((1 << bMIDI) & dwScale) ? true : false;
}

inline DWORD CleanupScale(DWORD dwPattern)

//  Force scale to be exactly two octaves

{
    dwPattern &= 0x0FFF;            // Clear upper octave.
    dwPattern |= (dwPattern << 12); // Copy lower octave to top.
    return dwPattern;
}

inline DWORD PatternMatch(DWORD dwA, DWORD dwB)

{
    DWORD dwHit = 0;
    DWORD dwIndex = 0;
    for (;dwIndex < 24; dwIndex++)
    {
        if ((dwA & (1 << dwIndex)) == (dwB & (1 << dwIndex)))
        {
            dwHit++;
        }
    }
    return dwHit;
}

static DWORD dwFallbackScales[12] =
{
    0xab5ab5,0x6ad6ad,
    0x5ab5ab,0xad5ad5,
    0x6b56b5,0x5ad5ad,
    0x56b56b,0xd5ad5a,
    0xb56b56,0xd6ad6a,
    0xb5ab5a,0xad6ad6,
};

inline DWORD FixScale(DWORD dwScale)

{
    if (BitCount(dwScale & 0xFFF) > 4)
    {
        return dwScale;
    }
    DWORD dwBest = 0;
    DWORD dwBestPattern = DEFAULT_SCALE_PATTERN;
    DWORD dwX;
    for (dwX = 0;dwX < 12; dwX++)
    {
        DWORD dwTest = PatternMatch(dwScale,dwFallbackScales[dwX]);
        if (dwTest > dwBest)
        {
            dwBestPattern = dwFallbackScales[dwX];
            dwBest = dwTest;
        }
    }
    return dwBestPattern;
}

inline DWORD ThreeOctave(DWORD dwScale)
{
    DWORD dwResult = dwScale;
     // don't change third octave if there's something there
    if ( !(0xFFF000000 & dwScale) )
    {
        // copy second octave to third octave
        dwResult |= (dwScale & 0xFFF000) << 12;
    }
    return dwResult;
}

inline DWORD AddRootToScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (12 - (bScaleRoot % 12));
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

inline DWORD SubtractRootFromScale(BYTE bScaleRoot, DWORD dwScalePattern)

{
    dwScalePattern = CleanupScale(dwScalePattern);
    dwScalePattern >>= (bScaleRoot % 12);
    dwScalePattern = CleanupScale(dwScalePattern);
    return dwScalePattern;
}

static DWORD ChordFromScale(BYTE bRoot, DWORD dwScalePattern)

{
    DWORD dwChordPattern = CleanupScale(dwScalePattern >> (bRoot % 12));
    DWORD dwX;
    DWORD dwBitCount = 0;
    for (dwX = 0; dwX < 24; dwX++)
    {
        DWORD dwBit = 1 << dwX;
        if (dwChordPattern & dwBit)
        {
            if ((dwBitCount & 1) || (dwBitCount > 7))
            {
                dwChordPattern &= ~dwBit;
            }
            dwBitCount++;
        }
    }
    return dwChordPattern;
}

static DWORD InvertChord(BYTE bKey, BYTE bChordRoot, DWORD dwChordPattern, bool& rfBelowRoot)

{
    // rotate the chord by the difference between the key and chord root
    rfBelowRoot = false;
    bKey %= 12;
    bChordRoot %= 12;
    if (bKey < bChordRoot) bKey += 12;
    BYTE bRotate = bKey - bChordRoot;
    // first check if the whole chord fits into one octave
    if ( !(dwChordPattern & 0xFFF000) )
    {
        dwChordPattern = ThreeOctave(CleanupScale(dwChordPattern));
        dwChordPattern >>= bRotate;
        dwChordPattern &= 0xFFF;
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) ||
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)))
        {
            dwChordPattern |= (dwChordPattern << 12);
            dwChordPattern &= 0x3FFC00;
            rfBelowRoot = true;
        }
    }
    else
    {
        dwChordPattern &= 0xFFFFFF; // make sure there are only notes in the two-octave range
        // do a circular shift in the closest direction
        BYTE bRotate2 = (bChordRoot + 12) - bKey;
        if (bRotate <= bRotate2)
        {
            dwChordPattern = (dwChordPattern << (24 - bRotate)) | (dwChordPattern >> bRotate);
        }
        else
        {
            dwChordPattern = (dwChordPattern >> (24 - bRotate2)) | (dwChordPattern << bRotate2);
        }
        dwChordPattern &= 0xFFFFFF;
        if (!(dwChordPattern & 0x7) &&
            (!(dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000)) ||
             !(dwChordPattern & 0x3000) && ((dwChordPattern & 0x800000)) ||
             !(dwChordPattern & 0x1000) && ((dwChordPattern & 0x1000000)) ||
             !(dwChordPattern & 0x7) && (dwChordPattern & 0x7000) && ((dwChordPattern & 0xc00000))) )
        {
            dwChordPattern = (dwChordPattern << 12) | (dwChordPattern >> 12);
            dwChordPattern &= 0xFFFFFF;
        }
        if (!(dwChordPattern & 0x7) && ((dwChordPattern & 0xc00)) ||
            !(dwChordPattern & 0x3) && ((dwChordPattern & 0x800)) ||
            !(dwChordPattern & 0x1) && ((dwChordPattern & 0x1000)) )
        {
            // put everything up to the G in the first octave two octaves up;
            // put G# and A one octave up
            dwChordPattern |= (((dwChordPattern & 0xFF) << 24) | ((dwChordPattern & 0x300) << 12));
            // get rid of everything below A# in the first octave
            dwChordPattern &= 0xFFFFFC00;
            // If there are no notes lower than C2, shift everything back down an octave
            if (!(dwChordPattern & 0xFFF))
            {
                dwChordPattern >>= 12;
            }
            else
            {
                rfBelowRoot = true;
            }
        }
    }
    return dwChordPattern;

}

/*  This is SuperJAM! code */

static unsigned char OldMusicValueToNote(

unsigned short value,   // Music value to convert.
char scalevalue,        // Scale value if chord failes.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   result ;
    char            octpart   = (char)(value >> 12) ;
    char            chordpart = (char)((value >> 8) & 0xF) ;
    char            keypart   = (char)((value >> 4) & 0xF) ;
    char            accpart   = (char)(value & 0xF) ;

    result  = unsigned char(12 * octpart) ;
    result += chordroot ;

    if( accpart > 8 )
        accpart -= 16 ;

    for( ;  chordpattern ;  result++ ) {
        if( chordpattern & 1L ) {
            if( !chordpart )
                break ;
            chordpart-- ;
        }
        chordpattern = chordpattern >> 1L ;
        if( !chordpattern ) {
            if( !scalevalue )
                return( 0 ) ;
            result  = unsigned char(12 * octpart) ;
            result += chordroot ;
            keypart = char(scalevalue >> 4) ;
            accpart = char(scalevalue & 0x0F) ;
            break ;
        }
    }

    if( keypart ) {
        keypattern = CleanupScale(keypattern) ;
        keypattern  = keypattern >> (LONG)((result - keyroot) % 12) ;
        for( ;  keypattern ;  result++ ) {
            if( keypattern & 1L ) {
                if( !keypart )
                    break ;
                keypart-- ;
            }
            keypattern = keypattern >> 1L ;
        }
    }

    result += unsigned char(accpart) ;
    return( result ) ;

}


/*  This is SuperJAM! code */

static unsigned short OldNoteToMusicValue(

unsigned char note,     // MIDI note to convert.
long keypattern,        // Description of key as interval pattern.
char keyroot,           // Root note of key.
long chordpattern,      // Description of chord as interval pattern.
char chordroot)         // Root note of chord.

{
    unsigned char   octpart = 0 ;
    unsigned char   chordpart = 0;
    unsigned char   keypart = (BYTE)-1 ;
    unsigned char   accpart = 0 ;
    unsigned char   scan, test, base, last ;    // was char
    long            pattern ;
    short           testa, testb ;


    scan = chordroot ;

    // If we're trying to play a note below the bottom of our chord, forget it
    if( note < scan)
    {
        return 0;
    }

    while( scan < (note - 24) )
    {
        scan += 12 ;
        octpart++ ;
    }

    base = last = scan ;

    for( ;  base<=note ;  base+=12 )
    {
        chordpart = (unsigned char)-1 ;
        pattern   = chordpattern ;
        scan      = last = base ;
        if( scan == note )
        {
            accpart = 0;
            while (!(pattern & 1) && pattern)
            {
                accpart--;
                pattern >>= 1;
            }
            return( (unsigned short) (octpart << 12) + (accpart & 0xF)) ;           // if octave, return.
        }
        for( ;  pattern ;  pattern=pattern >> 1 )
        {
            if( pattern & 1 )                   // chord interval?
            {
                if( scan == note )              // note in chord?
                {
                    chordpart++ ;
                    return((unsigned short) ((octpart << 12) | (chordpart << 8))) ; // yes, return.
                }
                else if (scan > note)           // above note?
                {
                    test = scan ;
                    break ;                     // go on to key.
                }
                chordpart++ ;
                last = scan ;
            }
            scan++ ;
        }
        if( !pattern )                          // end of chord.
        {
            test = unsigned char(base + 12) ;                  // set to next note.
        }
        octpart++ ;
        if( test > note )
        {
            break ;                             // above our note?
        }
    }

    octpart-- ;

//  To get here, the note is not in the chord.  Scan should show the last
//  note in the chord.  octpart and chordpart have their final values.
//  Now, increment up the key to find the match.

    scan        = last ;
    pattern     = CleanupScale(keypattern);
    pattern     = pattern >> ((scan - keyroot) % 12) ;

    for( ;  pattern ;  pattern=pattern >> 1 )
    {
        if( 1 & pattern )
        {
            keypart++ ;
            accpart = 0 ;
        }
        else
        {
            accpart++ ;
        }
        if( scan == note )
            break ;
        scan++;
    }

    if( accpart && keypart )
    {
        testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + accpart + 1);
        testb = short((octpart << 12) + ((chordpart + 1) << 8) + 0);
        testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        testb = OldMusicValueToNote( testb, 0, keypattern, keyroot,
                                     chordpattern, chordroot );
        if( testa == testb )
        {
            chordpart++ ;
            keypart = 0 ;
            accpart = -1 ;
        }
    }

    // If the conversion didn't find an exact match, fudge accpart to make it work
    testa = short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));
    testa = OldMusicValueToNote( testa, 0, keypattern, keyroot,
                                 chordpattern, chordroot );

    if( testa != note )
    {
        accpart += note - testa;
    }

    return unsigned short((octpart << 12) + (chordpart << 8) + (keypart << 4) + (accpart & 0xF));

}

inline short MusicValueOctave(WORD wMusicValue)
{ return short((wMusicValue >> 12) & 0xf) * 12; }

inline short MusicValueAccidentals(WORD wMusicValue)
{
    short acc = short(wMusicValue & 0xf);
    return (acc > 8) ? acc - 16 : acc;
}

inline short BitsInChord(DWORD dwChordPattern)
{

    for (short nResult = 0; dwChordPattern != 0; dwChordPattern >>= 1)
        if (dwChordPattern & 1) nResult++;
    return nResult;
}

#define S_OVER_CHORD    0x1000      // Success code to indicate the musicval could not be
                                    // converted because the note is above the top of the chord.

short MusicValueIntervals(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bRoot)
{
    if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) || (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS))
    {
        DWORD dwDefaultScale =
            (pSubChord->dwScalePattern) ? (pSubChord->dwScalePattern) : DEFAULT_SCALE_PATTERN;
        dwDefaultScale = AddRootToScale(pSubChord->bScaleRoot, dwDefaultScale);
        dwDefaultScale = ThreeOctave(FixScale(dwDefaultScale));
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        if (!dwChordPattern) dwChordPattern = 1;
        bool fBelowRoot = false;
        if ((bPlayModes & DMUS_PLAYMODE_KEY_ROOT) && bPlayModes != DMUS_PLAYMODE_PEDALPOINT)
        {
            dwChordPattern = InvertChord(bRoot, pSubChord->bChordRoot, dwChordPattern, fBelowRoot);
        }
        const short nChordPosition = (wMusicValue >> 8) & 0xf;
//      const short nScalePosition = (wMusicValue >> 4) & 0xf;
        // ensure that scale position is < 8
        const short nScalePosition = (wMusicValue >> 4) & 0x7;
        const short nChordBits = BitsInChord(dwChordPattern);
        short nSemitones = 0;
        // If the chord doesn't have a root or second, but does have a seventh, it's been inverted and
        // we need to start below the root
        short nTransposetones;
        DWORD dwPattern;
        short nPosition;
        BYTE bOctRoot = bRoot % 12; // root in one octave
        // if using chord intervals and the note is in the chord
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
            !nScalePosition &&
            (nChordPosition < nChordBits) )
        {
            nTransposetones = bRoot + MusicValueAccidentals(wMusicValue);
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
        }
        // if using chord intervals and note is inside the chord (including 6ths)
        else if ((bPlayModes & DMUS_PLAYMODE_CHORD_INTERVALS) &&
                 (nChordPosition < nChordBits) )
        {
            dwPattern = dwChordPattern;
            nPosition = nChordPosition;
            if (dwPattern)
            {
                // skip to the first note in the chord
                while (!(dwPattern & 1))
                {
                    dwPattern >>= 1;
                    nSemitones++;
                }
            }
            if (nPosition > 0)
            {
                do
                {
                    dwPattern >>= 1; // this will ignore the first note in the chord
                    nSemitones++;
                    if (dwPattern & 1)
                    {
                        nPosition--;
                    }
                    if (!dwPattern)
                    {
                        nSemitones += nPosition;
//                      assert (0); // This shouldn't happen...
                        break;
                    }
                } while (nPosition > 0);
            }

            nSemitones += bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> (nSemitones % 12);  // start comparing partway through the pattern
            nPosition = nScalePosition;
        }
        // if using scale intervals
        else if (bPlayModes & DMUS_PLAYMODE_SCALE_INTERVALS)
        {
            fBelowRoot = false; // forget about chord inversions
            nSemitones = bOctRoot;
            nTransposetones = MusicValueAccidentals(wMusicValue) + bRoot - bOctRoot;
            dwPattern = dwDefaultScale >> bOctRoot;  // start comparing partway through the pattern
            nPosition = nChordPosition * 2 + nScalePosition;
        }
        else
        {
            return S_OVER_CHORD;  //
        }
        nPosition++; // Now nPosition corresponds to actual scale positions
        for (; nPosition > 0; dwPattern >>= 1)
        {
            nSemitones++;
            if (dwPattern & 1)
            {
                nPosition--;
            }
            if (!dwPattern)
            {
                nSemitones += nPosition;
//              assert (0); // This shouldn't happen...
                break;
            }
        }
        nSemitones--; // the loop counts one too many semitones...
        if (fBelowRoot)
        {
            nSemitones -=12;
        }
        return nSemitones + nTransposetones;
    }
    else
    {
        // should be impossible for 2.5 format
        return bRoot + wMusicValue;
    }
}

inline short MusicValueChord(WORD wMusicValue, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{
    // first, get the root for transposition.
    BYTE bRoot = 0;
    if (bPlayModes & DMUS_PLAYMODE_CHORD_ROOT)
    {
        bRoot = pSubChord->bChordRoot;
    }
    else if (bPlayModes & DMUS_PLAYMODE_KEY_ROOT)
        bRoot = bKey;
    // Next, get an interval and combine it with the root.
    return MusicValueIntervals(wMusicValue, bPlayModes, pSubChord, bRoot);
}

inline short MusicValueConvert(WORD wMV, BYTE bPlayModes, DMUS_SUBCHORD *pSubChord, BYTE bKey)
{
    short nResult = 0;
    // First, make sure the octave is not negative.
    short nOffset = 0;
    while (wMV >= 0xE000)
    {
        wMV += 0x1000;
        nOffset -= 12;
    }

    // If the music value has a negative scale offset, convert to an equivalent
    // music value with a positive offset (up an octave) and shift the whole thing
    // down an octave
    WORD wTemp = (wMV & 0x00f0) + 0x0070;
    if (wTemp & 0x0f00)
    {
        wMV = (wMV & 0xff0f) | (wTemp & 0x00f0);
        nOffset = -12;
    }

    short nChordValue = MusicValueChord(wMV, bPlayModes, pSubChord, bKey);
    if (nChordValue != S_OVER_CHORD)
    {
        nChordValue += nOffset;
        // If the chord root is < 12, take the result down an octave.
        if ((bPlayModes & DMUS_PLAYMODE_CHORD_ROOT))
            nResult = MusicValueOctave(wMV) + nChordValue - 12;
        else
            nResult = MusicValueOctave(wMV) + nChordValue;
    }
    else
        nResult = S_OVER_CHORD;
    return nResult;
}

HRESULT STDMETHODCALLTYPE CPerformance::MIDIToMusic(
                BYTE bMIDIValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                WORD *pwMusicValue
            )

{
    V_INAME(IDirectMusicPerformance::MIDIToMusic);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pwMusicValue,WORD);

    long lMusicValue;
    HRESULT hr = S_OK;
#ifdef DBG
    long lMIDIInTraceValue = bMIDIValue;
#endif

    if ((bPlayMode & DMUS_PLAYMODE_NONE ) || (bMIDIValue & 0x80))
    {
        Trace(1,"Error: MIDIToMusic conversion failed either because there is no playmode or MIDI value %ld is out of range.\n",(long)bMIDIValue);
        return E_INVALIDARG;
    }
    else if( bPlayMode == DMUS_PLAYMODE_FIXED )
    {
        *pwMusicValue = bMIDIValue & 0x7F;
        return S_OK;
    }
    else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to key
    {
        lMusicValue = bMIDIValue - pChord->bKey;
        while (lMusicValue < 0)
        {
            lMusicValue += 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_UP_OCTAVE;
        }
        while (lMusicValue > 127)
        {
            lMusicValue -= 12;
            Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOKEY note.\n");
            hr = DMUS_S_DOWN_OCTAVE;
        }
        *pwMusicValue = (WORD) lMusicValue;
        return hr;
    }
    else
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lMusicValue = bMIDIValue - (pSubChord->bChordRoot % 24);
            while (lMusicValue < 0)
            {
                lMusicValue += 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_UP_OCTAVE;
            }
            while (lMusicValue > 127)
            {
                lMusicValue -= 12;
                Trace(2,"Warning: MIDIToMusic had to bump the music value down an octave for DMUS_PLAYMODE_FIXEDTOCHORD note.\n");
                hr = DMUS_S_DOWN_OCTAVE;
            }
            *pwMusicValue = (WORD) lMusicValue;
            return hr;
        }
        bool fBelowRoot = false;
        DWORD dwScalePattern = AddRootToScale(pSubChord->bScaleRoot, pSubChord->dwScalePattern);
        DWORD dwChordPattern = pSubChord->dwChordPattern;
        BYTE bKeyRoot = pChord->bKey;
        BYTE bChordRoot = pSubChord->bChordRoot;
        dwScalePattern = FixScale(dwScalePattern);
        bPlayMode &= 0xF;   // We only know about the bottom four flags, at this point.
//        if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT)
        // Do this for any non-fixed key root mode (Pedalpoint, PedalpointChord, PedalpointAlways)
        if (bPlayMode & DMUS_PLAYMODE_KEY_ROOT)
        {
            while (bKeyRoot > bMIDIValue)
            {
                hr = DMUS_S_UP_OCTAVE;
                Trace(2,"Warning: MIDIToMusic had to bump the music value up an octave for DMUS_PLAYMODE_KEY_ROOT note.\n");
                bMIDIValue += 12;
            }
            dwScalePattern = SubtractRootFromScale(bKeyRoot,dwScalePattern);
            if (bPlayMode == DMUS_PLAYMODE_PEDALPOINT || !dwChordPattern)
            {
                bChordRoot = bKeyRoot;
                dwChordPattern = ChordFromScale(0,dwScalePattern);
            }
            else
            {
                dwChordPattern = InvertChord(bKeyRoot, bChordRoot, dwChordPattern, fBelowRoot);
                BYTE bNewChordRoot = 0;
                if (dwChordPattern)
                {
                    for (; !(dwChordPattern & (1 << bNewChordRoot)); bNewChordRoot++);
                }
                bChordRoot = bNewChordRoot + bKeyRoot;
                dwChordPattern >>= bNewChordRoot;
            }
        }
        else if (bPlayMode == DMUS_PLAYMODE_MELODIC)
        {
            bKeyRoot = 0;
            dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
        }
        else
        {
            bKeyRoot = 0;
            if (!dwChordPattern)
            {
                dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
            }
        }
        BOOL fDropOctave = FALSE;
        if (bMIDIValue < 24)
        {
            fDropOctave = TRUE;
            bMIDIValue += 24;
        }
        WORD wNewMusicValue = OldNoteToMusicValue( bMIDIValue,
            dwScalePattern,
            bKeyRoot,
            dwChordPattern,
            bChordRoot );
        if (fDropOctave)
        {
            wNewMusicValue -= 0x2000;
            bMIDIValue -= 24;
        }

        // If DMUS_PLAYMODE_CHORD_ROOT is set, take the result up an octave.
        // // also take the result up for the new pedalpoint chord modes.
        if( (bPlayMode & DMUS_PLAYMODE_CHORD_ROOT)  ||
            fBelowRoot)
            //((bPlayMode & DMUS_PLAYMODE_KEY_ROOT) && bPlayMode != DMUS_PLAYMODE_PEDALPOINT) )
        {
            wNewMusicValue += 0x1000;
        }
        short nTest =
            MusicValueConvert(wNewMusicValue, bPlayMode,
                pSubChord, pChord->bKey);

        if (nTest == (short) bMIDIValue)
        {
            *pwMusicValue = wNewMusicValue;
        }
        else
        {
            if (nTest == S_OVER_CHORD)
            {
                if (BitCount(pSubChord->dwChordPattern) < 4)
                {
                    DWORD dwOldChordPattern = pSubChord->dwChordPattern;
                    pSubChord->dwChordPattern = ChordFromScale(bChordRoot,dwScalePattern);
                    nTest =
                        MusicValueConvert(wNewMusicValue, bPlayMode,
                            pSubChord, pChord->bKey);
                    pSubChord->dwChordPattern = dwOldChordPattern;
                    if (nTest == (short) bMIDIValue)
                    {
                        *pwMusicValue = wNewMusicValue;
                        return hr;
                    }
                }
            }
            *pwMusicValue = wNewMusicValue;
#ifdef DBG // Put in brackets just in case the compiler is using something different than DBG for turning on Trace.
            Trace(1,"Error: Unable to convert MIDI value %ld to Music value. This usually means the DMUS_CHORD_KEY structure has an invalid chord or scale pattern.\n",
                lMIDIInTraceValue);
#endif
            return DMUS_E_CANNOT_CONVERT;
        }
    }
    return hr;
}


HRESULT STDMETHODCALLTYPE CPerformance::MusicToMIDI(
                WORD wMusicValue,
                DMUS_CHORD_KEY* pChord,
                BYTE bPlayMode,
                BYTE bChordLevel,
                BYTE *pbMIDIValue
            )

{
    V_INAME(IDirectMusicPerformance::MusicToMIDI);
    V_BUFPTR_READ( pChord, sizeof(DMUS_CHORD_KEY) );
    V_PTR_WRITE(pbMIDIValue,BYTE);

    long lReturnVal = wMusicValue;
    HRESULT hr = S_OK;

    if (bPlayMode != DMUS_PLAYMODE_FIXED)
    {
        DMUS_SUBCHORD *pSubChord;
        DWORD dwLevel = 1 << bChordLevel;
        bool fFoundLevel = false;
        for (int i = 0; i < pChord->bSubChordCount; i++)
        {
            if (dwLevel & pChord->SubChordList[i].dwLevels)
            {
                pSubChord = &pChord->SubChordList[i];
                fFoundLevel = true;
                break;
            }
        }
        if (!fFoundLevel) // No luck? Use first chord.
        {
            pSubChord = &pChord->SubChordList[0];
        }
        if (bPlayMode & DMUS_PLAYMODE_NONE )
        {
            *pbMIDIValue = 0;
            Trace(1,"Error: Unable to convert Music value to MIDI because the playmode is DMUS_PLAYMODE_NONE.\n");
            return E_INVALIDARG;
        }
        if (bPlayMode == DMUS_PLAYMODE_FIXEDTOCHORD) // fixed to chord
        {
            lReturnVal += (pSubChord->bChordRoot % 24);
        }
        else if (bPlayMode == DMUS_PLAYMODE_FIXEDTOKEY) // fixed to scale
        {
            lReturnVal += pChord->bKey;
        }
        else
        {
            lReturnVal =
                MusicValueConvert((WORD)lReturnVal, bPlayMode, pSubChord, pChord->bKey);
        }
    }
    if (lReturnVal == S_OVER_CHORD)
    {
        Trace(5,"Warning: MIDIToMusic unable to convert because note out of chord range.\n");
        return DMUS_S_OVER_CHORD;
    }
    while (lReturnVal < 0)
    {
        lReturnVal += 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value up an octave to stay in MIDI range.\n");
        hr = DMUS_S_UP_OCTAVE;
    }
    while (lReturnVal > 127)
    {
        lReturnVal -= 12;
        Trace(2,"Warning: MusicToMIDI had to bump the music value down an octave to stay in MIDI range.\n");
        hr = DMUS_S_DOWN_OCTAVE;
    }
    *pbMIDIValue = (BYTE) lReturnVal;
    return hr;
}

// returns:
// S_OK if the note should be invalidated (any other return code will not invalidate)
// S_FALSE if processing otherwise succeeded, but the note should not be invalidated
// E_OUTOFMEMORY if allocation of a new note failed
HRESULT CPerformance::GetChordNotificationStatus(DMUS_NOTE_PMSG* pNote,
                                                 //IDirectMusicSegment* pSegment,
                                                 DWORD dwTrackGroup,
                                                 REFERENCE_TIME rtTime,
                                                 DMUS_PMSG** ppNew)
{
    HRESULT hr = S_FALSE; // default: succeed, but don't invalidate the note

    DMUS_CHORD_PARAM CurrentChord;
    MUSIC_TIME mtTime;
    ReferenceToMusicTime(rtTime, &mtTime);

    if (pNote->bFlags & (DMUS_NOTEF_NOINVALIDATE_INSCALE | DMUS_NOTEF_NOINVALIDATE_INCHORD))
    {
        // If the note is inconsistent with the current scale/chord, invalidate it
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK,
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            if (CurrentChord.bSubChordCount > 0)
            {
                BYTE bRoot = CurrentChord.SubChordList[0].bChordRoot;
                DWORD dwScale = CurrentChord.SubChordList[0].dwScalePattern;
                if (pNote->bFlags & DMUS_NOTEF_NOINVALIDATE_INCHORD)
                {
                    dwScale = CurrentChord.SubChordList[0].dwChordPattern;
                }
                else
                {
                    dwScale = FixScale(SubtractRootFromScale(bRoot, dwScale));
                }
                if (!InScale(pNote->bMidiValue, bRoot, dwScale))
                {
                    hr = S_OK;
                }
            }
        }
    }
    else if (pNote->bFlags & DMUS_NOTEF_REGENERATE)
    {
        // this always causes an invalidation, and in addition generates a new note event,
        // based on the Music Value of the current one, that starts at rtTime
        // and continues until pNote->mtTime + pNote->Duration
        // EXCEPTION: the newly generated note is the same as the currently playing one
        if (SUCCEEDED(GetParam(GUID_ChordParam, dwTrackGroup, DMUS_SEG_ANYTRACK,
                                mtTime, NULL, (void*) &CurrentChord)))
        {
            BYTE bNewMidiValue = 0;
            if (SUCCEEDED(MusicToMIDI(pNote->wMusicValue, &CurrentChord, pNote->bPlayModeFlags,
                                        pNote->bSubChordLevel, &bNewMidiValue)) &&
                bNewMidiValue != pNote->bMidiValue)
            {
                MUSIC_TIME mtDuration = (pNote->bFlags & DMUS_NOTEF_NOTEON) ? pNote->mtDuration - (mtTime - pNote->mtTime) : pNote->mtTime - mtTime;
                // Make any duration < 1 be 0; this will cause the note not to
                // sound.  Can happen if the note's logical time is well before
                // its physical time.
                if( mtDuration < 1 ) mtDuration = 0;
                DMUS_PMSG* pNewPMsg = NULL;
                if( SUCCEEDED( AllocPMsg( sizeof(DMUS_NOTE_PMSG), &pNewPMsg )))
                {
                    DMUS_NOTE_PMSG* pNewNote = (DMUS_NOTE_PMSG*)pNewPMsg;
                    // start by copying the current note into the new one
                    pNewNote->dwFlags = pNote->dwFlags;
                    pNewNote->dwPChannel = pNote->dwPChannel;
                    pNewNote->dwVirtualTrackID = pNote->dwVirtualTrackID;
                    pNewNote->pTool = pNote->pTool;
                    if (pNewNote->pTool) pNewNote->pTool->AddRef();
                    pNewNote->pGraph = pNote->pGraph;
                    if (pNewNote->pGraph) pNewNote->pGraph->AddRef();
                    pNewNote->dwType = pNote->dwType;
                    pNewNote->dwVoiceID = pNote->dwVoiceID;
                    pNewNote->dwGroupID = pNote->dwGroupID;
                    pNewNote->punkUser = pNote->punkUser;
                    if (pNewNote->punkUser) pNewNote->punkUser->AddRef();
                    pNewNote->wMusicValue = pNote->wMusicValue;
                    pNewNote->wMeasure = pNote->wMeasure;
                    pNewNote->nOffset = pNote->nOffset;
                    pNewNote->bBeat = pNote->bBeat;
                    pNewNote->bGrid = pNote->bGrid;
                    pNewNote->bVelocity = pNote->bVelocity;
                    pNewNote->bTimeRange = pNote->bTimeRange;
                    pNewNote->bDurRange = pNote->bDurRange;
                    pNewNote->bVelRange = pNote->bVelRange;
                    pNewNote->bPlayModeFlags = pNote->bPlayModeFlags;
                    pNewNote->bSubChordLevel = pNote->bSubChordLevel;
                    pNewNote->cTranspose = pNote->cTranspose;
                    // only things that need to change are flags, MIDI value, start time, and duration
                    pNewNote->mtTime = mtTime;
                    MusicToReferenceTime(pNewNote->mtTime, &pNewNote->rtTime);
                    pNewNote->mtDuration = mtDuration;
                    pNewNote->bMidiValue = bNewMidiValue;
                    pNewNote->bFlags = DMUS_NOTEF_NOTEON | DMUS_NOTEF_REGENERATE;
                    PackNote(pNewPMsg, rtTime + 1); // play the note on
                    *ppNew = pNewPMsg;  // PackNote modifies event to be note-off; queue this
                    // invalidate the current note
                    hr = S_OK;
                }
                else hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT STDMETHODCALLTYPE CPerformance::TimeToRhythm(
                MUSIC_TIME mtTime,
                DMUS_TIMESIGNATURE *pTimeSig,
                WORD *pwMeasure,
                BYTE *pbBeat,
                BYTE *pbGrid,
                short *pnOffset
            )

{
    V_INAME(IDirectMusicPerformance::TimeToRhythm);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pwMeasure,WORD);
    V_PTR_WRITE(pbBeat,BYTE);
    V_PTR_WRITE(pbGrid,BYTE);
    V_PTR_WRITE(pnOffset,short);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = mtTime - pTimeSig->mtTime;
    *pwMeasure = (WORD)((lTemp / lMeasureLength));
    lTemp = lTemp % lMeasureLength;
    *pbBeat = (BYTE)(lTemp / lBeatLength);
    lTemp = lTemp % lBeatLength;
    *pbGrid = (BYTE)(lTemp / lGridLength);
    *pnOffset = (short)(lTemp % lGridLength);
    if (*pnOffset > (lGridLength >> 1))
    {
        *pnOffset -= (short) lGridLength;
        (*pbGrid)++;
        if (*pbGrid == pTimeSig->wGridsPerBeat)
        {
            *pbGrid = 0;
            (*pbBeat)++;
            if (*pbBeat == pTimeSig->bBeatsPerMeasure)
            {
                *pbBeat = 0;
                (*pwMeasure)++;
            }
        }
    }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CPerformance::RhythmToTime(
                WORD wMeasure,
                BYTE bBeat,
                BYTE bGrid,
                short nOffset,
                DMUS_TIMESIGNATURE *pTimeSig,
                MUSIC_TIME *pmtTime
            )

{
    V_INAME(IDirectMusicPerformance::RhythmToTime);
    V_BUFPTR_READ( pTimeSig, sizeof(DMUS_TIMESIGNATURE) );
    V_PTR_WRITE(pmtTime,MUSIC_TIME);

    long lMeasureLength;
    long lBeatLength = DMUS_PPQ;
    long lGridLength;

    if( pTimeSig->bBeat )
    {
        lBeatLength = DMUS_PPQ * 4 / pTimeSig->bBeat;
    }
    lMeasureLength = lBeatLength * pTimeSig->bBeatsPerMeasure;
    if( pTimeSig->wGridsPerBeat )
    {
        lGridLength = lBeatLength / pTimeSig->wGridsPerBeat;
    }
    else
    {
        lGridLength = lBeatLength / 256;
    }
    long lTemp = nOffset + pTimeSig->mtTime;
    lTemp += wMeasure * lMeasureLength;
    lTemp += bBeat * lBeatLength;
    lTemp += bGrid * lGridLength;
    *pmtTime = lTemp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmsegobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSEGMENTOBJECT_H_
#define __DIRECTMUSICSEGMENTOBJECT_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"

#include "TrkList.h"
#include "ntfylist.h"
#include "dmsstobj.h"
#include "..\shared\dmusicp.h"

#define COMPOSE_TRANSITION1 (DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART | DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT | DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)

class CSegment;

DEFINE_GUID(IID_CSegment,0xb06c0c21, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegment
class CSegment : 
	public IDirectMusicSegment8,
	public IDirectMusicSegment8P,
	public IPersistStream,
	public IDirectMusicObject,
    public AListItem,
    public IDirectMusicObjectP
{
friend class CPerformance;
friend class CSegState;
friend class CSong;
public:
	CSegment();
    CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource);
	~CSegment();
    CSegment* GetNext() { return (CSegment*)AListItem::GetNext();}

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSegment
    STDMETHODIMP GetLength(MUSIC_TIME *pmtLength);
    STDMETHODIMP SetLength(MUSIC_TIME pmtLength);
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
    STDMETHODIMP SetRepeats(DWORD dwRepeats);
    STDMETHODIMP GetDefaultResolution(DWORD *pdwResolution);
    STDMETHODIMP SetDefaultResolution(DWORD dwResolution);
    STDMETHODIMP GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex,IDirectMusicTrack **ppTrack);
    STDMETHODIMP GetTrackGroup(IDirectMusicTrack* pTrack,DWORD* pdwGroupBits);
    STDMETHODIMP InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits);
    STDMETHODIMP RemoveTrack(IDirectMusicTrack *pTrack);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState **ppSegState,IDirectMusicPerformance *pPerformance,DWORD dwFlags);
    STDMETHODIMP GetGraph(IDirectMusicGraph** ppGraph);
    STDMETHODIMP SetGraph(IDirectMusicGraph* pGraph);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
	STDMETHODIMP GetParam(REFGUID rguidDataType,DWORD dwGroupBits,
                    DWORD dwIndex,MUSIC_TIME mtTime, 
				    MUSIC_TIME* pmtNext,void* pData); 
    STDMETHODIMP SetParam(REFGUID rguidDataType,DWORD dwGroupBits, 
				    DWORD dwIndex,MUSIC_TIME mtTime,void* pData);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicSegment** ppSegment);
	STDMETHODIMP GetStartPoint(MUSIC_TIME* pmtStart);
    STDMETHODIMP SetStartPoint(MUSIC_TIME mtStart);
    STDMETHODIMP GetLoopPoints(MUSIC_TIME* pmtStart,MUSIC_TIME* pmtEnd);
    STDMETHODIMP SetLoopPoints(MUSIC_TIME mtStart,MUSIC_TIME mtEnd);
    STDMETHODIMP SetPChannelsUsed(DWORD dwNumPChannels,DWORD* paPChannels);
//  IDirectMusicSegment8 
    STDMETHODIMP SetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppIAudioPathConfig);
    STDMETHODIMP Compose(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment,
		IDirectMusicSegment** ppComposedSegment);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);
// IDirectMusicSegment8P
    STDMETHODIMP GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                    DWORD dwStage,       /* Which stage in the path. */
                                    DWORD dwBuffer,
                                    REFGUID guidObject,  /* ClassID of object. */
                                    DWORD dwIndex,       /* Which object of that class. */
                                    REFGUID iidInterface,/* Requested COM interface. */
                                    void ** ppObject) ; /* Pointer to interface. */
    STDMETHODIMP GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader); /* Header chunk to fill. */
    STDMETHODIMP SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority);       /* Priority to set. */
    STDMETHODIMP SetAudioPathConfig(
        IUnknown *pAudioPathConfig);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

	HRESULT GetPChannels( DWORD* pdwNumPChannels, DWORD** ppaPChannels );
	HRESULT CheckNotification( REFGUID );

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTrackConfig(REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags) ;
    HRESULT AddNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    HRESULT RemoveNotificationType(REFGUID rguidNotification, BOOL fFromPerformance);
    BOOL IsTempoSource();	
    HRESULT CreateSegmentState(CSegState **ppSegState,CPerformance *pPerformance, 
        IDirectMusicAudioPath *pAudioPath, DWORD dwFlags); 
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack * GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck);
    HRESULT GetTrackByParam(REFGUID rgCommandGuid,DWORD dwGroupBits,
        DWORD dwIndex,IDirectMusicTrack **ppTrack);
	HRESULT LoadDirectMusicSegment(IStream* pIStream);	
	void AddNotificationTypeToAllTracks( REFGUID rguidNotification );
	void RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification );
	CNotificationItem* FindNotification( REFGUID rguidNotification );
	HRESULT LoadTrack(CRiffParser *pParser);
	HRESULT CreateTrack(DMUS_IO_TRACK_HEADER& ioDMHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream);
    HRESULT InsertTrack(IDirectMusicTrack *pTrack,DWORD dwGroupBits, DWORD dwFlags, DWORD dwPriority, DWORD dwPosition);
	HRESULT LoadGraph(CRiffParser *pParser,CGraph **ppGraph);
    HRESULT LoadAudioPath(IStream *pStream);
	HRESULT ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc);
    void Init();
    HRESULT ComposeTransition(MUSIC_TIME mtTime,
		IDirectMusicSegment* pFromSegment,
		IDirectMusicSegment* pToSegment);
    HRESULT ComposeInternal();
	HRESULT SetClockTimeDuration(REFERENCE_TIME rtDuration);
	HRESULT SetFlags(DWORD dwFlags);
    void Clear(bool fZombie);
    HRESULT MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime);
    HRESULT ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime);

// Attributes
protected:
    CRITICAL_SECTION    m_CriticalSection;
	DWORD	            m_dwRepeats;	// # of times to repeat the segment. 0xffffffff is infinite
	DWORD	            m_dwResolution; // the default resolution to start motifs and such.
    DWORD               m_dwSegFlags;   // Flags loaded in with segment. 
	CTrackList	        m_TrackList;	// list of Tracks held in this Segment
    CAudioPathConfig*   m_pAudioPathConfig; // Optional audio path loaded from file. 
    CGraph*	            m_pGraph;       // Optional tool graph for segment.
	CNotificationList	m_NotificationList;
    REFERENCE_TIME      m_rtLength;     // Optional length in reference time units. 
	MUSIC_TIME	        m_mtLength;
	MUSIC_TIME	        m_mtStart;
	MUSIC_TIME	        m_mtLoopStart;
	MUSIC_TIME	        m_mtLoopEnd;
	DWORD	            m_dwNumPChannels;
	DWORD*	            m_paPChannels;
	long                m_cRef;
    IUnknown *          m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?

    bool                m_fZombie;

public:
    DWORD               m_dwLoadID;     // Identifier, used when loaded as part of a song.
    CSong*              m_pSong;        // Optional parent song that segment belongs to. This is not AddRef'd.
    DWORD               m_dwPlayID;     // ID of segment, if within a song.
    DWORD               m_dwNextPlayID; // ID of next segment, if within a song.
    DWORD               m_dwNextPlayFlags; // DMUS_SEGF flags for playing next segment, if within a song.
    BOOL                m_fPlayNext;    // Whether the next segment should be played.
};

class CSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CSegment* pSegment) { AList::AddHead((AListItem*)pSegment);}
    void Insert(CSegment* pSegment);
    BOOL IsMember(CSegment *pSegment) { return AList::IsMember((AListItem*)pSegment);}
    CSegment* GetHead(){return (CSegment*)AList::GetHead();}
    CSegment* GetItem(LONG lIndex){return (CSegment*)AList::GetItem(lIndex);}
    CSegment* RemoveHead() {return (CSegment *) AList::RemoveHead();}
    void Remove(CSegment* pSegment){AList::Remove((AListItem*)pSegment);}
    void AddTail(CSegment* pSegment){AList::AddTail((AListItem*)pSegment);}
    CSegment* GetTail(){ return (CSegment*)AList::GetTail();}
};


#endif //__DIRECTMUSICSEGMENTOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmsegobj.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmsegobj.cpp : Implementation of CSegment

#include "dmime.h"
#include "DMSegObj.h"
#include "DMSStObj.h"
#include "DMGraph.h"
#include "dmusici.h"
#include "tlist.h"
#include "midifile.h"
#include "dmusicc.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "wavtrack.h"
#include "..\shared\validp.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "..\dmstyle\dmstyle.h"
#include "..\dmcompos\dmcompp.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "tempotrk.h"
#include <strsafe.h>
#define ASSERT assert

// @doc EXTERNAL

long g_lNewTrackID = 0; // shared by all instances of Segments, this keeps track of the
    // next available TrackID when creating new Track states.

/////////////////////////////////////////////////////////////////////////////
// CSegment

void CSegment::Init()
{
    InitializeCriticalSection(&m_CriticalSection);
    m_pSong = NULL;
    m_dwNextPlayFlags = 0;
    m_dwNextPlayID = 0xFFFFFFFF;
    m_dwPlayID = 0;
//    m_fPartialLoad = FALSE;
    m_mtLength = 1;
    m_mtStart = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = 0;
    m_rtLength = 0;
    m_dwRepeats = 0;
    m_dwResolution = 0;
    m_dwNumPChannels = 0;
    m_paPChannels = NULL;
    m_pGraph = NULL;
    m_pAudioPathConfig = NULL;
    m_pUnkDispatch = NULL;
    m_dwSegFlags = 0;
    m_cRef = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_fZombie = false;
    InterlockedIncrement(&g_cComponent);
    TraceI(2, "Segment %lx created\n", this );
}

CSegment::CSegment()
{
    Init();
}

CSegment::CSegment(DMUS_IO_SEGMENT_HEADER *pHeader, CSegment *pSource)
{
    Init();
    AddRef(); // so that this doesn't get deleted in Track::Init...
    // Force the version to at least 8 so audiopath functionality will be turned on.
    m_dwVersion = 8;
    m_dwResolution = pHeader->dwResolution;
    m_mtLength = pHeader->mtLength;
    m_mtStart = pHeader->mtPlayStart;
    m_mtLoopStart = pHeader->mtLoopStart;
    m_mtLoopEnd = pHeader->mtLoopEnd;
    m_dwRepeats = pHeader->dwRepeats;
    m_dwSegFlags = pHeader->dwFlags;
    if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
    {
        m_rtLength = pHeader->rtLength;
    }
    else
    {
        m_rtLength = 0;
    }
    if (pSource)
    {
        pSource->m_TrackList.CreateCopyWithBlankState(&m_TrackList);
        CTrack *pTrack = m_TrackList.GetHead();
        for (;pTrack;pTrack = pTrack->GetNext())
        {
            pTrack->m_pTrack->Init( this );
        }
    }
}

CSegment::~CSegment()
{
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    Clear(false);
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
    TraceI(2, "Segment %lx destroyed\n", this );
}

void CSegment::Clear(bool fZombie)
{
    m_TrackList.Clear();
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    SetGraph(NULL); // shut down the graph and release it
    // We need the following stuff to hang around if the segment is being zombied.
    if (!fZombie)
    {
        // remove all notifies
        CNotificationItem* pItem = m_NotificationList.GetHead();
        while( pItem )
        {
            CNotificationItem* pNext = pItem->GetNext();
            m_NotificationList.Remove( pItem );
            delete pItem;
            pItem = pNext;
        }
        if( m_paPChannels )
        {
            delete [] m_paPChannels;
            m_paPChannels = NULL;
        }
        m_dwNumPChannels = 0;
    }
}

STDMETHODIMP_(void) CSegment::Zombie()
{
    Clear(true);
    m_fZombie = true;
}

STDMETHODIMP CSegment::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSegment::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegment)
    {
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_CSegment)
    {
        *ppv = static_cast<CSegment*>(this);
    }
    else if (iid == IID_IDirectMusicSegment8)
    {
        m_dwVersion = 8;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_IDirectMusicSegment8P)
    {
        *ppv = static_cast<IDirectMusicSegment8P*>(this);
    }
    else if (iid == IID_IDirectMusicSegment2)
    {
        m_dwVersion = 2;
        *ppv = static_cast<IDirectMusicSegment*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSegment,
                static_cast<IDirectMusicSegment*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Segment queried for unknown interface.\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSegment::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegment::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSegment::GetLength(
    MUSIC_TIME *pmtLength) // @parm Returns the Segment's length.
{
    V_INAME(IDirectMusicSegment::GetLength);
    V_PTR_WRITE(pmtLength, MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetLength after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtLength = m_mtLength;
    return S_OK;
}


STDMETHODIMP CSegment::SetLength(
    MUSIC_TIME mtLength) // @parm The desired length.
{
    if( mtLength <=0 )
    {
        Trace(1,"Error: Can not set segment length to a negative number (%ld.)\n",mtLength);
        return E_INVALIDARG;
    }
    if(( mtLength <= m_mtStart ) || ( mtLength < m_mtLoopEnd ))
    {
        Trace(1,"Error: Can not set segment length to %ld, which is either less that the start time %ld or the loop end %ld\n",
            mtLength,m_mtStart,m_mtLoopEnd);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetLength after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtLength = mtLength;
    return S_OK;
}

STDMETHODIMP CSegment::GetRepeats(
    DWORD *pdwRepeats) // @parm Returns the number of repeats.
{
    V_INAME(IDirectMusicSegment::GetRepeats);
    V_PTR_WRITE(pdwRepeats, DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetRepeats after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pdwRepeats = m_dwRepeats;
    return S_OK;
}

STDMETHODIMP CSegment::SetRepeats(
    DWORD dwRepeats)    // @parm The desired number of repeats.
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetRepeats after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_dwRepeats = dwRepeats;
    return S_OK;
}

STDMETHODIMP CSegment::GetDefaultResolution(
    DWORD *pdwResolution)    // @parm Returns the default resolution. (See <t DMPLAYSEGFLAGS>.)
{
    V_INAME(IDirectMusicSegment::GetDefaultResolution);
    V_PTR_WRITE(pdwResolution, DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetDefaultResolution after the segment has been garbage collected.\n");

        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pdwResolution = m_dwResolution;
    return S_OK;
}

#define LEGAL_RES_FLAGS (DMUS_SEGF_SECONDARY | \
                        DMUS_SEGF_QUEUE | \
                        DMUS_SEGF_CONTROL | \
                        DMUS_SEGF_AFTERPREPARETIME  | \
                        DMUS_SEGF_GRID | \
                        DMUS_SEGF_BEAT | \
                        DMUS_SEGF_MEASURE | \
                        DMUS_SEGF_NOINVALIDATE | \
                        DMUS_SEGF_ALIGN | \
                        DMUS_SEGF_VALID_START_BEAT | \
                        DMUS_SEGF_VALID_START_GRID | \
                        DMUS_SEGF_VALID_START_TICK | \
                        DMUS_SEGF_AFTERQUEUETIME | \
                        DMUS_SEGF_AFTERLATENCYTIME | \
                        DMUS_SEGF_SEGMENTEND | \
                        DMUS_SEGF_MARKER | \
                        DMUS_SEGF_TIMESIG_ALWAYS | \
                        DMUS_SEGF_USE_AUDIOPATH | \
                        DMUS_SEGF_VALID_START_MEASURE)

STDMETHODIMP CSegment::SetDefaultResolution(
    DWORD dwResolution)    // @parm The desired default resolution. (See <t DMPLAYSEGFLAGS>.)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetDefaultResolution after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }
#ifdef DBG
    if ((dwResolution & LEGAL_RES_FLAGS) != dwResolution)
    {
        Trace(1,"Warning: Attempt to set resolution includes inappropriate or non-existant flag: %lx\n",
            dwResolution & ~LEGAL_RES_FLAGS);
    }
#endif
    m_dwResolution = dwResolution;
    return S_OK;
}

STDMETHODIMP CSegment::GetHeaderChunk(
        DWORD *pdwSize,      /* Size of passed header chunk. Also, returns size written. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetHeaderChunk after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DMUS_IO_SEGMENT_HEADER Header;
    Header.dwFlags = m_dwSegFlags;
    Header.dwRepeats = m_dwRepeats;
    Header.dwResolution = m_dwResolution;
    Header.mtLength = m_mtLength;
    Header.mtLoopEnd = m_mtLoopEnd;
    Header.mtLoopStart = m_mtLoopStart;
    Header.mtPlayStart = m_mtStart;
    Header.dwReserved = 0;
    Header.rtLength = m_rtLength;
    if (pdwSize && pHeader)
    {
        *pdwSize = min(sizeof(Header),*pdwSize);
        memcpy(pHeader,&Header,*pdwSize);
        return S_OK;
    }
    Trace(1,"Error: GetHeaderChunk() was passed a NULL for either pdwSize or pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetHeaderChunk(
        DWORD dwSize,        /* Size of passed header chunk. */
        DMUS_IO_SEGMENT_HEADER *pHeader)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetHeaderChunk after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pHeader)
    {
        DMUS_IO_SEGMENT_HEADER Header;
        dwSize = min(sizeof(Header),dwSize);
        // Initialize all fields so we don't have to worry about the passed size.
        Header.dwFlags = m_dwSegFlags;
        Header.dwRepeats = m_dwRepeats;
        Header.dwResolution = m_dwResolution;
        Header.mtLength = m_mtLength;
        Header.mtLoopEnd = m_mtLoopEnd;
        Header.mtLoopStart = m_mtLoopStart;
        Header.mtPlayStart = m_mtStart;
        Header.dwReserved = 0;
        Header.rtLength = m_rtLength;
        memcpy(&Header,pHeader,dwSize);
        m_dwSegFlags = Header.dwFlags;
        m_dwRepeats = Header.dwRepeats;
        m_dwResolution = Header.dwResolution;
        m_mtLength = Header.mtLength;
        m_mtLoopEnd = Header.mtLoopEnd;
        m_mtLoopStart = Header.mtLoopStart;
        m_mtStart = Header.mtPlayStart;
        m_rtLength = Header.rtLength;
        return S_OK;
    }
    Trace(1,"Error: SetHeaderChunk() was passed a NULL for pHeader.\n");
    return E_POINTER;
}

STDMETHODIMP CSegment::SetTrackPriority(
        REFGUID rguidTrackClassID,  /* ClassID of Track. */
        DWORD dwGroupBits,          /* Group bits. */
        DWORD dwIndex,              /* Nth track. */
        DWORD dwPriority)       /* Priority to set. */
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackPriority after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroupBits,dwCounter))
    {
        pCTrack->m_dwPriority = dwPriority;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::SetAudioPathConfig(
        IUnknown *pAudioPathConfig)
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetAudioPathConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (m_dwVersion < 8) m_dwVersion = 8;
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    if (pAudioPathConfig)
    {
        return pAudioPathConfig->QueryInterface(IID_CAudioPathConfig,(void **) &m_pAudioPathConfig);
    }
    return S_OK;
}

STDMETHODIMP CSegment::GetTrack(
    REFCLSID rType,
    DWORD dwGroupBits,
    DWORD dwIndex,
    IDirectMusicTrack **ppTrack)
{
    V_INAME(IDirectMusicSegment::GetTrack);
    V_PTRPTR_WRITE(ppTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CTrack* pCTrack;
    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrack(rType,dwGroupBits,dwIndex);
    if (pCTrack)
    {
        *ppTrack = pCTrack->m_pTrack;
        pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else
    {
        Trace(1,"Error: GetTrack could not find the requested track at index %ld.\n",dwIndex);
        hr = DMUS_E_NOT_FOUND;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack *CSegment::GetTrack(
    REFCLSID rType,
    DWORD dwGroupBits,
    DWORD dwIndex)
{
    CTrack* pCTrack;
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_dwGroupBits & dwGroupBits )
        {
            if( (GUID_NULL == rType) || (pCTrack->m_guidClassID == rType))
            {
                if( 0 == dwIndex )
                {
                    break;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return pCTrack;
}

BOOL CSegment::IsTempoSource()

{
    EnterCriticalSection(&m_CriticalSection);
    BOOL fHasTempo = (NULL != GetTrackByParam(NULL, GUID_TempoParam,-1,0, FALSE));
    LeaveCriticalSection(&m_CriticalSection);
    return fHasTempo;
}

STDMETHODIMP CSegment::GetTrackGroup(
    IDirectMusicTrack* pTrack,    // @parm The Track to find the group bits.
    DWORD* pdwGroupBits)// @parm Returns the group(s) to which a Track belongs.
                        // Each bit in <p pdwGroupBits> corresponds to a Track
                        // group.
{
    V_INAME(IDirectMusicSegment::GetTrackGroup);
    V_INTERFACE(pTrack);
    V_PTR_WRITE(pdwGroupBits,DWORD);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetTrackGroup after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CTrack* pCTrack;
    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_pTrack == pTrack )
        {
            *pdwGroupBits = pCTrack->m_dwGroupBits;
            hr = S_OK;
            break;
        }
        pCTrack = pCTrack->GetNext();
    }
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(1,"Error: GetTrackGroup could not find the requested track.\n");
    }
#endif
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack * CSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex, BOOL fDontCheck)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) && (fDontCheck ||
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED)))
        {
            if( (GUID_NULL == rguidType) ||
                (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

HRESULT CSegment::GetTrackByParam(
    REFGUID rguidType,    // The command type of the Track to find. A value of GUID_NULL
                        // will get any track.
    DWORD dwGroupBits,    // Which track groups to scan for the track in. A value of 0
                        // is invalid. Each bit in <p dwGroupBits> corresponds to a Track
                        // group. To scan all tracks regardless of groups, set all bits in
                        // this parameter (0xffffffff).
    DWORD dwIndex,        // The index into the list of tracks of type <p rguidType>
                        // and in group <p dwGroupBits> to return. 0 means the first
                        // one found, 1 would be the second, etc. If multiple groups are
                        // selected in <p dwGroupBits>, this index will indicate the nth
                        // track of type <p pCommandGuid> encountered in the union
                        // of the groups selected.
    IDirectMusicTrack **ppTrack)    // Returns the Track (AddRef'd), or NULL if the
                                    // Track isn't found.
{
    HRESULT hr;
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,TRUE);
    if (pCTrack)
    {
        *ppTrack = pCTrack->m_pTrack;
        pCTrack->m_pTrack->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = DMUS_E_NOT_FOUND;
        // Don't think we need an error message here since SetParam also does one...
        // Trace(1,"Error: Could not find the requested track for SetParam.\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::InsertTrack(
    IDirectMusicTrack *pTrack,    // @parm The Track to add to the Segment.
    DWORD dwGroupBits )            // @parm Identifies the group(s) this should be inserted into.
                                // May not be 0.
{
    V_INAME(IDirectMusicSegment::InsertTrack);
    V_INTERFACE(pTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::InsertTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return InsertTrack(pTrack,dwGroupBits,DMUS_TRACKCONFIG_DEFAULT,0, 0);
}

HRESULT CSegment::InsertTrack(
    IDirectMusicTrack *pTrack,
    DWORD dwGroupBits,
    DWORD dwFlags,
    DWORD dwPriority,
    DWORD dwPosition)
{
    CTrack* pCTrack;

    if( 0 == dwGroupBits )
    {
        Trace(1,"Error: InsertTrack called with dwGroupBits set to 0.\n");
        return E_INVALIDARG;
    }
    if( FAILED( pTrack->Init( this ) ))
    {
        TraceI(1,"Error: Track failed to initialize\n");
        return DMUS_E_NOT_INIT;
    }
    pCTrack = new CTrack;
    if( NULL == pCTrack )
    {
        return E_OUTOFMEMORY;
    }
    pCTrack->m_pTrack = pTrack;
    pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pCTrack->m_pTrack8);
    IPersist *pPersist;
    if (S_OK == pTrack->QueryInterface(IID_IPersistStream,(void **) &pPersist))
    {
        pPersist->GetClassID( &pCTrack->m_guidClassID );
        pPersist->Release();
    }
    pCTrack->m_dwGroupBits = dwGroupBits;
    pCTrack->m_dwFlags = dwFlags;
    pCTrack->m_dwPriority = dwPriority;
    pCTrack->m_dwPosition = dwPosition;
    pTrack->AddRef();
    EnterCriticalSection(&m_CriticalSection);
    // Add the track based on position.
    CTrack* pScan = m_TrackList.GetHead();
    CTrack* pPrevTrack = NULL;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (pCTrack->Less(pScan))
        {
            break;
        }
        pPrevTrack = pScan;
    }
    if (pPrevTrack)
    {
        pPrevTrack->SetNext(pCTrack);
        pCTrack->SetNext(pScan);
    }
    else
    {
        m_TrackList.AddHead( pCTrack );
    }

    // send notifications to track
    CNotificationItem* pItem = m_NotificationList.GetHead();
    while( pItem )
    {
        pTrack->AddNotificationType( pItem->guidNotificationType );
        pItem = pItem->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSegment::RemoveTrack(
    IDirectMusicTrack *pTrack)    // @parm The Track to remove from the Segment's Track list.
{
    V_INAME(IDirectMusicSegment::RemoveTrack);
    V_INTERFACE(pTrack);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::RemoveTrack after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CTrack* pCTrackTemp;
    pCTrackTemp = m_TrackList.GetHead();
    while( pCTrackTemp )
    {
        if( pTrack == pCTrackTemp->m_pTrack )
        {
            hr = S_OK;
            m_TrackList.Remove( pCTrackTemp );
            delete pCTrackTemp;
            break;
        }
        pCTrackTemp = pCTrackTemp->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == S_FALSE)
    {
        Trace(1,"Warning: RemoveTrack failed because the requested track is not in the segment.\n");
    }
#endif
    return hr;
}

HRESULT CSegment::CreateSegmentState(
    CSegState **ppSegState,
    CPerformance *pPerformance,
    IDirectMusicAudioPath *pAudioPath,
    DWORD dwFlags)

{
    IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
        pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    EnterCriticalSection(&m_CriticalSection);
    if( FAILED( m_TrackList.CreateCopyWithBlankState(&pState->m_TrackList)))
    {
        LeaveCriticalSection(&m_CriticalSection);
        pState->Release();
        return E_OUTOFMEMORY;
    }
    // set the segstate's parent and performance
    pState->PrivateInit( this, pPerformance );

    if (m_pGraph)
    {
        m_pGraph->Clone((IDirectMusicGraph **) &pState->m_pGraph);
    }
    pState->InitRoute(pAudioPath);
    CTrack* pCTrack = pState->m_TrackList.GetHead();
    while( pCTrack )
    {
        DWORD dwTempID;
        InterlockedIncrement(&g_lNewTrackID);
        dwTempID = g_lNewTrackID;
        if (!pState->m_dwFirstTrackID)
            pState->m_dwFirstTrackID = dwTempID;
        pState->m_dwLastTrackID = dwTempID;
        ASSERT(pCTrack->m_pTrack);
        if( FAILED(pCTrack->m_pTrack->InitPlay(
            pSegmentState, (IDirectMusicPerformance *) pPerformance,
            &pCTrack->m_pTrackState, dwTempID, dwFlags )))
        {
            pCTrack->m_pTrackState = NULL;
        }
        pCTrack->m_dwVirtualID = dwTempID;
        pCTrack = pCTrack->GetNext();
    }
    *ppSegState = pState;
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

/*  The following function is kept around only for DX6.1 compatibility just
    in case some mindless bureaucrat actually uses this somehow.
    For internal use, we've switched to the function above.
*/

STDMETHODIMP CSegment::InitPlay(
    IDirectMusicSegmentState **ppSegState,    // @parm Returns the SegmentState created
            // by this method call. It is returned with a reference count of 1, thus a
            // call to its Release will fully release it.
    IDirectMusicPerformance *pPerformance,    // @parm The IDirectMusicPerformance pointer.
            // This is needed by the Segment and SegmentState in order to call methods on
            // the Performance object. This pointer is not AddRef'd. It is a weak reference
            // because it is assumed that the Performance will outlive the Segment.
    DWORD dwFlags)                          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicSegment::InitPlay);
    V_INTERFACE(pPerformance);
    V_PTRPTR_WRITE(ppSegState);

    if (m_dwVersion)
    {
        return E_NOTIMPL;
    }

    IDirectMusicSegmentState* pSegmentState;
    CSegState *pState = new CSegState;
    if (pState)
    {
        pState->QueryInterface( IID_IDirectMusicSegmentState,
            (void**)&pSegmentState);
        pState->m_dwVersion = m_dwVersion;
        pState->Release();
        if (pPerformance)
        {
            // QI addref's the performance but we want only a weak refrenece with the segment state
            HRESULT hr = pPerformance->QueryInterface(IID_CPerformance,(void **) &pState->m_pPerformance);
            if(FAILED(hr))
            {
                return E_FAIL;
            }

            pPerformance->Release();
        }
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    *ppSegState = pSegmentState;
    return S_OK;
}

STDMETHODIMP CSegment::GetGraph(
    IDirectMusicGraph**    ppGraph    // @parm Returns the Tool Graph pointer.
        )
{
    V_INAME(IDirectMusicSegment::GetGraph);
    V_PTRPTR_WRITE(ppGraph);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetGraph after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if( NULL == m_pGraph )
    {
        Trace(1,"Error: GetGraph failed because segment does not have a tool graph.\n");
        return DMUS_E_NOT_FOUND;
    }
    EnterCriticalSection(&m_CriticalSection);
    *ppGraph = m_pGraph;
    m_pGraph->AddRef();
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

STDMETHODIMP CSegment::SetGraph(
    IDirectMusicGraph*    pGraph    // @parm The Tool Graph pointer. May be NULL to
                                // clear out the Segment graph.
        )
{
    V_INAME(IDirectMusicSegment::SetGraph);
    V_INTERFACE_OPT(pGraph);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetGraph after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    EnterCriticalSection(&m_CriticalSection);
    if( m_pGraph )
    {
        m_pGraph->Release();
    }
    m_pGraph = (CGraph *) pGraph;
    if( pGraph )
    {
        pGraph->AddRef();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSegment::SetClockTimeDuration(REFERENCE_TIME rtDuration)

{
    m_rtLength = rtDuration;
    return S_OK;
}

HRESULT CSegment::SetFlags(DWORD dwFlags)

{
    m_dwSegFlags = dwFlags;
    return S_OK;
}

/*
  Check to see if this notification is already being tracked.
*/
CNotificationItem* CSegment::FindNotification( REFGUID rguidNotification )
{
    CNotificationItem* pItem;

    pItem = m_NotificationList.GetHead();
    while(pItem)
    {
        if( rguidNotification == pItem->guidNotificationType )
        {
            break;
        }
        pItem = pItem->GetNext();
    }
    return pItem;
}

void CSegment::AddNotificationTypeToAllTracks( REFGUID rguidNotification )
{
    CTrack* pTrack;

    // add the notify to the tracks
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        pTrack->m_pTrack->AddNotificationType( rguidNotification );
        pTrack = pTrack->GetNext();
    }
}

void CSegment::RemoveNotificationTypeFromAllTracks( REFGUID rguidNotification )
{
    CTrack* pTrack;

    // add the notify to the tracks
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        pTrack->m_pTrack->RemoveNotificationType( rguidNotification );
        pTrack = pTrack->GetNext();
    }
}

HRESULT CSegment::AddNotificationType(
     REFGUID rguidNotification, BOOL fFromPerformance)
{
    CNotificationItem* pItem;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    pItem = FindNotification( rguidNotification );
    if (pItem)
    {
        // If the item was installed previously, but by
        // a difference source (performance vs. app)
        // then treat this as a normal addition.
        // Otherwise, indicate that the same operation
        // was done twice.
        if (pItem->fFromPerformance == fFromPerformance)
        {
            hr = S_FALSE;
        }
        else
        {
            // Clear the fFromPerformance flag since this has
            // now been added by the app and the performance.
            pItem->fFromPerformance = FALSE;
        }
    }
    else
    {
        pItem = new CNotificationItem;
        if( NULL == pItem )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pItem->fFromPerformance = fFromPerformance;
            pItem->guidNotificationType = rguidNotification;
            m_NotificationList.Cat( pItem );
            AddNotificationTypeToAllTracks( rguidNotification );
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::AddNotificationType(
     REFGUID rguidNotification)    // @parm The notification guid to add.
{
    V_INAME(IDirectMusicSegment::AddNotificationType);
    V_REFGUID(rguidNotification);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::AddNotificationType after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return AddNotificationType(rguidNotification,FALSE);
}

HRESULT CSegment::RemoveNotificationType(
     REFGUID rguidNotification,BOOL fFromPerformance)
{

    CNotificationItem* pItem;
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    if( GUID_NULL == rguidNotification )
    {
        CNotificationList TempList;
        while( pItem = m_NotificationList.RemoveHead() )
        {
            // If this is being called on an item that was installed by the
            // performance OR we are calling this directly from the app,
            // go ahead and remove. However, do not remove in the specific
            // case where the app installed the notification and the performance
            // is clearing notifications.
            if (pItem->fFromPerformance || !fFromPerformance)
            {
                RemoveNotificationTypeFromAllTracks( pItem->guidNotificationType );
                delete pItem;
            }
            else
            {
                TempList.AddHead(pItem);
            }
        }
        // Now, put the saved notifications back.
        while (pItem = TempList.RemoveHead())
        {
            m_NotificationList.AddHead(pItem);
        }
    }
    else if( pItem = FindNotification( rguidNotification ))
    {
        m_NotificationList.Remove( pItem );
        delete pItem;
        RemoveNotificationTypeFromAllTracks( rguidNotification );
    }
    else
    {
        Trace(2,"Warning: Unable to remove requested notification from segment, it was not currently installed.\n");
        hr = S_FALSE;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::RemoveNotificationType(
     REFGUID rguidNotification)    // @parm The notification guid to remove. GUID_NULL to remove all notifies.
{
    V_INAME(IDirectMusicSegment::RemoveNotificationType);
    V_REFGUID(rguidNotification);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::RemoveNotificationType after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return RemoveNotificationType(rguidNotification,FALSE);
}

STDMETHODIMP CSegment::GetParam(
    REFGUID rguidType,        // @parm The type of data to obtain.
    DWORD dwGroupBits,        // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,            // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to obtain the data from.
    MUSIC_TIME mtTime,        // @parm The segment time from which to obtain the data.
    MUSIC_TIME* pmtNext,    // @parm Returns the segment time until which the data is valid. <p pmtNext>
                            // may be NULL. If this returns a value of 0, it means that this
                            // data will either be always valid, or it is unknown when it will
                            // become invalid.
    void* pParam)            // @parm The struture in which to return the data. Each
                            // <p rguidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicSegment::GetParam);
    V_REFGUID(rguidType);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetParam after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // App must be using IDirectMusicSegment8 interface for this to be enabled...
        // Nah, nobody would ever have a use for an index that high, so this is safe.
        fMultipleTry = TRUE; // (m_dwVersion > 2);
    }
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrackByParam(NULL,rguidType,dwGroupBits,dwIndex,FALSE);
    while (pCTrack)
    {
        if (pCTrack->m_pTrack8)
        {
            REFERENCE_TIME rtNext, *prtNext;
            // We need to store the next time in a 64 bit pointer. But, don't
            // make 'em fill it in unless the caller requested it.
            if (pmtNext)
            {
                prtNext = &rtNext;
            }
            else
            {
                prtNext = NULL;
            }
            hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam, NULL, 0 );
            if (pmtNext)
            {
                *pmtNext = (MUSIC_TIME) rtNext;
            }
        }
        else
        {
            hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
            if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
            {
                *pmtNext = m_mtLength - mtTime;
            }
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pCTrack = GetTrackByParam( pCTrack, rguidType, dwGroupBits, 0, FALSE);
        }
        else
        {
            pCTrack = NULL;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment GetParam failed to find a track.\n");
    }
#endif
    return hr;
}


STDMETHODIMP CSegment::SetParam(
    REFGUID rguidType,        // @parm The type of data to set.
    DWORD dwGroupBits,        // @parm The group the desired track is in. Use 0xffffffff
                            // for all groups.
    DWORD dwIndex,            // @parm Identifies which track, by index, in the group
                            // identified by <p dwGroupBits> to set the data.
    MUSIC_TIME mtTime,        // @parm The time at which to set the data.
    void* pParam)            // @parm The struture containing the data to set. Each
                            // <p rguidType> identifies a particular structure of a
                            // particular size. It is important that this field contain
                            // the correct structure of the correct size. Otherwise,
                            // fatal results can occur.
{
    V_INAME(IDirectMusicSegment::SetParam);
    V_REFGUID(rguidType);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetParam after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    IDirectMusicTrack* pTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    while (SUCCEEDED( GetTrackByParam( rguidType, dwGroupBits, dwCounter, &pTrack )))
    {
        hr = pTrack->SetParam( rguidType, mtTime, pParam );
        pTrack->Release();
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Warning: Segment SetParam failed to find the requested track.\n");
    }
#endif
    return hr;
}

STDMETHODIMP CSegment::Download(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSegment::Download);
    V_INTERFACE(pAudioPath);
    HRESULT hr = S_OK;

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Download after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Validate that pAudioPath is either a performance or an audio path
    IDirectMusicPerformance* pPerf = NULL;
    if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicPerformance, (void**)&pPerf)) )
    {
        IDirectMusicAudioPath* pAP = NULL;
        if ( FAILED(hr = pAudioPath->QueryInterface(IID_IDirectMusicAudioPath, (void**)&pAP)) )
        {
            return hr; // nothing to release, since all the QI's failed.
        }
        else
        {
            pAP->Release();
        }
    }
    else
    {
        pPerf->Release();
    }

    hr = SetParam(GUID_DownloadToAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted download to a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::Unload(IUnknown *pAudioPath)

{
    V_INAME(IDirectMusicSegment::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Unload after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = SetParam(GUID_UnloadFromAudioPath,-1,DMUS_SEG_ALLTRACKS,0,pAudioPath);
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(2,"Attempted unload from a segment that has no tracks that support downloading (wave and band tracks.)\n");
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CSegment::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex,
                                      DWORD dwFlagsOn, DWORD dwFlagsOff)
{
    V_INAME(IDirectMusicSegment::SetTrackConfig);
    V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetTrackConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwCounter))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segment SetTrackConfig failed to find the requested track.\n");
    }
#endif
    return hr;
}

HRESULT CSegment::GetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, DWORD *pdwFlags)
{

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex);
    if (pCTrack)
    {
        *pdwFlags = pCTrack->m_dwFlags;
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegment::Clone(
            MUSIC_TIME mtStart,    // @parm The start of the part to clone. If less than 0,
                                // or greater than the length of the Segment, 0 will be used.
            MUSIC_TIME mtEnd,    // @parm The end of the part to clone. If past the end of the
                                // Segment, it will clone to the end. Also, a value of 0 or
                                // anything less than <p mtStart> will also clone to the end.
            IDirectMusicSegment** ppSegment    // @parm Returns the created Segment, if successful.
                                // It is caller's responsibility to call Release() when finished
                                // with it.
        )
{
    V_INAME(IDirectMusicSegment::Clone);
    V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Clone after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CSegment* pCSegment;
    HRESULT hr = S_OK;

    if( (mtEnd < mtStart) || (mtEnd > m_mtLength) )
    {
        mtEnd = m_mtLength;
    }
    if( ( mtEnd == 0 ) && ( mtStart == 0 ))
    {
        mtEnd = m_mtLength;
    }
    if( (mtStart < 0) || (mtStart > m_mtLength) )
    {
        mtStart = 0;
    }
    pCSegment = new CSegment;
    if (pCSegment == NULL) {
        return E_OUTOFMEMORY;
    }
    // Addref to 1 and assign to ppSegment.
    pCSegment->AddRef();
    (*ppSegment) = (IDirectMusicSegment *) pCSegment;
    if( m_pGraph )
    {
        pCSegment->m_pGraph = m_pGraph;
        m_pGraph->AddRef();
    }
    if (m_pAudioPathConfig)
    {
        pCSegment->m_pAudioPathConfig = m_pAudioPathConfig;
        m_pAudioPathConfig->AddRef();
    }
    pCSegment->m_dwRepeats = m_dwRepeats;
    pCSegment->m_dwResolution = m_dwResolution;
    pCSegment->m_dwSegFlags = m_dwSegFlags;
    pCSegment->m_mtLength = mtEnd - mtStart;
    pCSegment->m_rtLength = m_rtLength;
    pCSegment->m_mtStart = m_mtStart;
    pCSegment->m_mtLoopStart = m_mtLoopStart;
    pCSegment->m_mtLoopEnd = m_mtLoopEnd;
    pCSegment->m_dwValidData = m_dwValidData;
    pCSegment->m_guidObject = m_guidObject;
    pCSegment->m_ftDate = m_ftDate;
    pCSegment->m_vVersion = m_vVersion;
    StringCchCopyW(pCSegment->m_wszName, DMUS_MAX_NAME, m_wszName);
    StringCchCopyW(pCSegment->m_wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
    StringCchCopyW(pCSegment->m_wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
    pCSegment->m_dwVersion = m_dwVersion;
    pCSegment->m_dwLoadID = m_dwLoadID;
    pCSegment->m_dwPlayID = m_dwPlayID;
    pCSegment->m_dwNextPlayID = m_dwNextPlayID;
    pCSegment->m_dwNextPlayFlags = m_dwNextPlayFlags;

    CTrack* pCTrack;
    IDirectMusicTrack* pTrack;
    EnterCriticalSection(&m_CriticalSection);
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        if( SUCCEEDED( pCTrack->m_pTrack->Clone( mtStart, mtEnd, &pTrack )))
        {
            if( FAILED( pCSegment->InsertTrack( pTrack, pCTrack->m_dwGroupBits, pCTrack->m_dwFlags, pCTrack->m_dwPriority, pCTrack->m_dwPosition )))
            {
                Trace(1,"Warning: Insertion of cloned track failed, cloned segment is incomplete.\n");
                hr = S_FALSE;
            }
            pTrack->Release();
        }
        else
        {
            Trace(1,"Warning: Track clone failed, cloned segment is incomplete.\n");
            hr = S_FALSE;
        }
        pCTrack = pCTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)

{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetAudioPathConfig after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the segment.\n");
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegment::GetObjectInPath(DWORD dwPChannel,    /* PChannel to search. */
                                DWORD dwStage,       /* Which stage in the path. */
                                DWORD dwBuffer,
                                REFGUID guidObject,  /* ClassID of object. */
                                DWORD dwIndex,       /* Which object of that class. */
                                REFGUID iidInterface,/* Requested COM interface. */
                                void ** ppObject)

{
    V_INAME(IDirectMusicSegment::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetObjectInPath after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    if (dwStage == DMUS_PATH_SEGMENT_TRACK)
    {
        CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
        if (pCTrack)
        {
            if (pCTrack->m_pTrack)
            {
                hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_GRAPH)
    {
        if (dwIndex == 0)
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if (dwStage == DMUS_PATH_SEGMENT_TOOL)
    {
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (dwStage >= DMUS_PATH_BUFFER)
    {
        // Nothing here now. But, in DX9, we may add support for addressing the buffer configuration
        // and DMOS in it.
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSegment::Compose(MUSIC_TIME mtTime,
                                IDirectMusicSegment* pFromSegment,
                                IDirectMusicSegment* pToSegment,
                                IDirectMusicSegment** ppComposedSegment)

{
    V_INAME(IDirectMusicSegment::Compose);
    V_INTERFACE_OPT(pFromSegment);
    V_INTERFACE_OPT(pToSegment);
    V_PTRPTR_WRITE_OPT(ppComposedSegment);
#ifdef DBG
    if (pFromSegment)
    {
        MUSIC_TIME mtLength, mtLoopEnd, mtLoopStart;
        DWORD dwRepeats;
        // To calculate the full length, we need to access the loop parameters.
        pFromSegment->GetLoopPoints(&mtLoopStart,&mtLoopEnd);
        pFromSegment->GetRepeats(&dwRepeats);
        pFromSegment->GetLength(&mtLength);
        // If repeats is set to infinite, the total length will be greater than 32 bits.
        LONGLONG llTotalLength = dwRepeats * (mtLoopEnd - mtLoopStart) + mtLength;
        if (mtTime >= (llTotalLength & 0x7FFFFFFF))
        {
            Trace(2,"Warning: A time value of %ld was passed to Compose for a segment of length %ld.\n",
                mtTime, (long) llTotalLength);
        }
    }
#endif
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Compose after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);

    if (ppComposedSegment)
    {
        hr = Clone(0, m_mtLength, ppComposedSegment);
        if (SUCCEEDED(hr))
        {
            hr = ((CSegment*)*ppComposedSegment)->ComposeTransition(mtTime, pFromSegment, pToSegment);
        }
    }
    else
    {
        hr = ComposeTransition(mtTime, pFromSegment, pToSegment);
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSegment::ComposeTransition(MUSIC_TIME mtTime,
                                    IDirectMusicSegment* pFromSegment,
                                    IDirectMusicSegment* pToSegment)
{
    HRESULT hr = S_OK;
    bool fTrackPadded = false;

    // Compute amount of time to pad any tracks that need padding.
    DMUS_TIMESIGNATURE TimeSig;
    if (!pFromSegment ||
        FAILED(pFromSegment->GetParam(GUID_TimeSignature, 0xffffffff, 0, mtTime, NULL, (void*) &TimeSig)))
    {
        TimeSig.mtTime = 0;
        TimeSig.bBeatsPerMeasure = 4;
        TimeSig.bBeat = 4;
        TimeSig.wGridsPerBeat = 4;
    }
    else // avoid divide-by-zero
    {
        if (!TimeSig.bBeat) TimeSig.bBeat = 4;
    }
    MUSIC_TIME mtBar = ( DMUS_PPQ * 4 * TimeSig.bBeatsPerMeasure ) / TimeSig.bBeat;
    MUSIC_TIME mtStartPad = min(mtBar, mtTime);
    if (!pFromSegment) mtStartPad = 0;
    MUSIC_TIME mtToLength = 0;
    if (pToSegment) pToSegment->GetLength(&mtToLength);
    MUSIC_TIME mtEndPad = min(mtBar, mtToLength);

    // Instantiate tracks
    CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
    {
        pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
        IDirectMusicTrack* pTransTrack1 = NULL;
        IDirectMusicTrack* pTransTrack2 = NULL;
        GUID guidClassID;
        memset(&guidClassID, 0, sizeof(guidClassID));
        IPersist* pPersist = NULL;
        if (SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)))
        {
            pPersist->GetClassID(&guidClassID);
            pPersist->Release();
        }
        DWORD dwTrackGroup = 0;
        GetTrackGroup(pTrack->m_pTrack, &dwTrackGroup);

        // Get track info
        if (pTrack->m_dwFlags & COMPOSE_TRANSITION1)
        {
            // Clone the appropriate track, with length m_mtLength
            MUSIC_TIME mtStart = 0;
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT)
            {
                mtStart = mtTime;
            }
            MUSIC_TIME mtEnd = mtStart + m_mtLength;
            IDirectMusicTrack* pSourceTrack = NULL;
            if ( (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGSTART) ||
                 (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_FROMSEGCURRENT) )
            {
                if (pFromSegment)
                {
                    hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                }
            }
            else if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_TRANS1_TOSEGSTART)
            {
                if (pToSegment)
                {
                    hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                }
            }
            if (pSourceTrack)
            {
                hr = pSourceTrack->Clone(mtStart, mtEnd, &pTransTrack1);
                pSourceTrack->Release();
                pSourceTrack = NULL;
            }
        }
        if (!pTransTrack1)
        {
            pTransTrack1 = pTrack->m_pTrack;
            pTransTrack1->AddRef();

        }
        if (pTransTrack1)
        {
            // Pad the track with an extra bar of header and trailer, by cloning header and trailer
            // tracks (from From and To segments, respectively --- *not* using transition flags) and
            // joining them onto the transition segment track.
            IDirectMusicTrack* pStartPadTrack = NULL;
            IDirectMusicTrack* pEndPadTrack = NULL;
            IDirectMusicTrack* pSourceTrack = NULL;
            if (pFromSegment && mtStartPad)
            {
                hr = pFromSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                if (SUCCEEDED(hr))
                {
                    pSourceTrack->Clone(mtTime - mtStartPad, mtTime, &pStartPadTrack);
                    pSourceTrack->Release();
                    pSourceTrack = NULL;
                }
            }
            if (pToSegment && mtEndPad)
            {
                hr = pToSegment->GetTrack(guidClassID, dwTrackGroup, 0, &pSourceTrack);
                if (SUCCEEDED(hr))
                {
                    pSourceTrack->Clone(0, mtEndPad, &pEndPadTrack);
                    pSourceTrack->Release();
                    pSourceTrack = NULL;
                }
            }
            IDirectMusicTrack8* pTrack8 = NULL;
            if (pEndPadTrack)
            {
                if (SUCCEEDED(pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
                {
                    if (SUCCEEDED(pTrack8->Join(pEndPadTrack, m_mtLength, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
                    {
                        fTrackPadded = true;
                        pTrack->m_dwInternalFlags |= TRACKINTERNAL_END_PADDED;
                    }
                    pTrack8->Release();
                }
                pEndPadTrack->Release();
            }
            if (SUCCEEDED(hr) && pStartPadTrack)
            {
                if (SUCCEEDED(hr = pStartPadTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTrack8)))
                {
                    if (SUCCEEDED(pTrack8->Join(pTransTrack1, mtStartPad, (IDirectMusicSegment*)this, dwTrackGroup, NULL)))
                    {
                        fTrackPadded = true;
                        pTrack->m_dwInternalFlags |= TRACKINTERNAL_START_PADDED;
                        pTransTrack1->Release();
                        pTransTrack1 = pStartPadTrack;
                    }
                    else
                    {
                        pStartPadTrack->Release();
                    }
                    pTrack8->Release();
                }
                else
                {
                    pStartPadTrack->Release();
                }
            }
            else if(pStartPadTrack)
            {
                pStartPadTrack->Release();
            }

            // Replace the current track with the instantiated one
            IDirectMusicTrack8* pTempTrack8 = NULL;
            pTransTrack1->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
            if (pTrack->m_pTrack) pTrack->m_pTrack->Release();
            pTrack->m_pTrack = pTransTrack1;
            pTrack->m_pTrack->Init( this );
            if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
            pTrack->m_pTrack8 = pTempTrack8;
        }

        if (FAILED(hr)) break;
    }
    MUSIC_TIME mtOldLength = m_mtLength;
    if (fTrackPadded) // any tracks got joined with header/trailer info
    {
        // pad the length of the segment, to account for the header/trailer
        m_mtLength += mtStartPad + mtEndPad;
    }

    // Compose
    if (SUCCEEDED(hr))
    {
        hr = ComposeInternal();
    }

    // Back end
    if (fTrackPadded) // any tracks got joined with header/trailer info
    {
        // Trim header and trailer from each track that was joined, using Clone.
        pTrack = m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_START_PADDED) )
            {
                IDirectMusicTrack* pTempTrack = NULL;
                IDirectMusicTrack8* pTempTrack8 = NULL;
                pTrack->m_pTrack->Clone(mtStartPad, mtOldLength + mtStartPad, &pTempTrack);
                pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
                pTrack->m_pTrack->Release();
                pTrack->m_pTrack = pTempTrack;
                pTrack->m_pTrack->Init( this );
                if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
                pTrack->m_pTrack8 = pTempTrack8;
            }
            else if ( (pTrack->m_pTrack) && (pTrack->m_dwInternalFlags & TRACKINTERNAL_END_PADDED) )
            {
                IDirectMusicTrack* pTempTrack = NULL;
                IDirectMusicTrack8* pTempTrack8 = NULL;
                pTrack->m_pTrack->Clone(0, mtOldLength, &pTempTrack);
                pTempTrack->QueryInterface(IID_IDirectMusicTrack8, (void**)&pTempTrack8);
                pTrack->m_pTrack->Release();
                pTrack->m_pTrack = pTempTrack;
                pTrack->m_pTrack->Init( this );
                if (pTrack->m_pTrack8) pTrack->m_pTrack8->Release();
                pTrack->m_pTrack8 = pTempTrack8;
            }
            pTrack->m_dwInternalFlags &= ~(TRACKINTERNAL_START_PADDED | TRACKINTERNAL_END_PADDED);
        }
        // Return the length of the segment to its original value.
         m_mtLength = mtOldLength;
    }

    return hr;
}

HRESULT CSegment::ComposeInternal()
{
    HRESULT hr = S_OK;
    TList<CTrack*> TrackList;
    // Find the composing tracks and put them in priority order
    CTrack* pTrack = m_TrackList.GetHead();
    for (; pTrack; pTrack = pTrack->GetNext())
    {
        if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
        {
            TListItem<CTrack*>* pTrackItem = new TListItem<CTrack*>(pTrack);
            if (!pTrackItem)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                TListItem<CTrack*>* pMaster = TrackList.GetHead();
                TListItem<CTrack*>* pPrevious = NULL;
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    CTrack*& rpMaster = pMaster->GetItemValue();
                    if (pTrack->m_dwPriority > rpMaster->m_dwPriority) break;
                    pPrevious = pMaster;
                }
                if (!pPrevious) // this has higher priority than anything in the list
                {
                    TrackList.AddHead(pTrackItem);
                }
                else // lower priority than pPrevious, higher than pMaster
                {
                    pTrackItem->SetNext(pMaster);
                    pPrevious->SetNext(pTrackItem);
                }
            }
        }
        if (FAILED(hr)) break;
    }
    // Compose a new track from each from each composing track; put the results
    // in the segment (remove any existing composed tracks)
    if (SUCCEEDED(hr))
    {
        TListItem<CTrack*>* pTrackItem = TrackList.GetHead();
        for (; pTrackItem; pTrackItem = pTrackItem->GetNext())
        {
            CTrack*& rpTrack = pTrackItem->GetItemValue();
            IDirectMusicTrack8* pComposedTrack = NULL;
            hr = rpTrack->m_pTrack8->Compose((IDirectMusicSegment*)this, rpTrack->m_dwGroupBits, (IDirectMusicTrack**)&pComposedTrack);
            if (SUCCEEDED(hr))
            {
                // Remove any tracks of this type (in the same group) from the segment.
                IDirectMusicTrack* pOldTrack = NULL;
                GUID guidClassId;
                memset(&guidClassId, 0, sizeof(guidClassId));
                IPersistStream* pPersist = NULL;
                if (SUCCEEDED(pComposedTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                {
                    if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                        SUCCEEDED( GetTrack( guidClassId, rpTrack->m_dwGroupBits, 0, &pOldTrack ) ) )
                    {
                        RemoveTrack( pOldTrack );
                        pOldTrack->Release();
                    }
                    pPersist->Release();
                }
                hr = InsertTrack(pComposedTrack, rpTrack->m_dwGroupBits);
                pComposedTrack->Release();
            }
            if (FAILED(hr)) break;
        }
    }
    return hr;
}


STDMETHODIMP CSegment::GetStartPoint(
            MUSIC_TIME* pmtStart    // @parm Returns the Segment's start point.
        )
{
    V_INAME(IDirectMusicSegment::GetStartPoint);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetStartPoint after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtStart = m_mtStart;
    return S_OK;
}

STDMETHODIMP CSegment::SetStartPoint(
            MUSIC_TIME mtStart    // @parm The start point at which to begin playing the
                                // Segment. If it is less than zero or greater than the
                                // length of the Segment, the start point will be set
                                // to zero.
        )
{
    if( (mtStart < 0) || (mtStart >= m_mtLength) )
    {
        Trace(1,"Error: Unable to set start point %ld because not within the range of the segment, which is %ld.\n",
            mtStart,m_mtLength);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetStartPoint after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtStart = mtStart;
    return S_OK;
}

STDMETHODIMP CSegment::GetLoopPoints(
            MUSIC_TIME* pmtStart,    // @parm Returns the start point of the loop.
            MUSIC_TIME* pmtEnd        // @parm Returns the end point of the loop. A value of
                                    // 0 indicates that the entire Segment will loop.
        )
{
    V_INAME(IDirectMusicSegment::GetLoopPoints);
    V_PTR_WRITE(pmtStart, MUSIC_TIME);
    V_PTR_WRITE(pmtEnd, MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetLoopPoints after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pmtStart = m_mtLoopStart;
    *pmtEnd = m_mtLoopEnd;
    return S_OK;
}

STDMETHODIMP CSegment::SetLoopPoints(
            MUSIC_TIME mtStart,    // @parm The start point at which to begin the loop.
            MUSIC_TIME mtEnd    // @parm The end point at which to begin the loop. Set
                                // <p mtStart> and <p mtEnd> to 0
                                // to loop the entire Segment.
        )
{
    if( (mtStart < 0) || (mtEnd > m_mtLength) || (mtStart > mtEnd) )
    {
        Trace(1,"Error: Unable to set loop points %ld, %ld because they are not within the range of the segment, which is %ld.\n",
            mtStart,mtStart,mtEnd,m_mtLength);
        return DMUS_E_OUT_OF_RANGE;
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetLoopPoints after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    m_mtLoopStart = mtStart;
    m_mtLoopEnd = mtEnd;
    return S_OK;
}

STDMETHODIMP CSegment::SetPChannelsUsed(
    DWORD dwNumPChannels,    // @parm The number of PChannels to set. This must be equal
                            // to the number of members in the array pointed to by
                            // <p paPChannels>.
    DWORD* paPChannels        // @parm Points to an array of PChannels. The array should
                            // have the same number of elements as specified by <p dwNumPChannels>.
    )
{
    V_INAME(IDirectMusicSegment::SetPChannelsUsed);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetPChannelsUsed after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if( dwNumPChannels )
    {
        if( NULL == paPChannels )
        {
            Trace(1,"Error: Bad call to SetPChannelsUsed, pointer to PChannel array is NULL.\n");
            return E_INVALIDARG;
        }
        V_BUFPTR_READ(paPChannels, sizeof(DWORD)*dwNumPChannels);

        DWORD* padwTemp = new DWORD[dwNumPChannels]; // temp array
        DWORD dwTotalNum = 0;
        if( NULL == padwTemp )
        {
            return E_OUTOFMEMORY;
        }
        // count the number of unique PChannels are in the array. That is, the ones
        // that we don't already have stored.
        DWORD dwCount;
        for( dwCount = 0; dwCount < dwNumPChannels; dwCount++ )
        {
            DWORD dwCurrent;
            for( dwCurrent = 0; dwCurrent < m_dwNumPChannels; dwCurrent++ )
            {
                if( m_paPChannels[dwCurrent] == paPChannels[dwCount] )
                {
                    // we already track this one
                    break;
                }
            }
            if( dwCurrent >= m_dwNumPChannels )
            {
                // we're not already tracking this one
                padwTemp[dwTotalNum] = paPChannels[dwCount];
                dwTotalNum++;
            }
        }
        // dwTotalNum equals the total number of new PChannels, and they are indexed
        // inside adwTemp.
        DWORD* paNewPChannels = new DWORD[m_dwNumPChannels + dwTotalNum];
        if( NULL == paNewPChannels )
        {
            delete [] padwTemp;
            return E_OUTOFMEMORY;
        }
        if( m_paPChannels )
        {
            memcpy( paNewPChannels, m_paPChannels, sizeof(DWORD) * m_dwNumPChannels );
            delete [] m_paPChannels;
        }
        memcpy( &paNewPChannels[m_dwNumPChannels], padwTemp, sizeof(DWORD) * dwTotalNum );
        delete [] padwTemp;
        m_dwNumPChannels += dwTotalNum;
        m_paPChannels = paNewPChannels;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentObject (private)
HRESULT CSegment::GetPChannels(
    DWORD* pdwNumPChannels,    // returns the number of pchannels
    DWORD** ppaPChannels)    // returns a pointer to the array of pchannels. Don't free this
                            // memory or keep it, as it is owned by the Segment.
{
    ASSERT(pdwNumPChannels && ppaPChannels);
    *pdwNumPChannels = m_dwNumPChannels;
    *ppaPChannels = m_paPChannels;
    return S_OK;
}

// return S_OK if the notification is active, S_FALSE if not.
HRESULT CSegment::CheckNotification( REFGUID rguid )
{
    if( NULL == FindNotification( rguid ) )
    {
        return S_FALSE;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSegment::GetClassID( CLSID* pClassID )
{
    V_INAME(CSegment::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetClassID after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pClassID = CLSID_DirectMusicSegment;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSegment::IsDirty()
{
    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::IsDirty after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    return S_FALSE;
}

#define DMUS_FOURCC_RMID_FORM    mmioFOURCC('R','M','I','D')
#define DMUS_FOURCC_data_FORM    mmioFOURCC('d','a','t','a')
#define DMUS_FOURCC_DLS_FORM    mmioFOURCC('D','L','S',' ')
#define FOURCC_SECTION_FORM     mmioFOURCC('A','A','S','E')

HRESULT CSegment::Load( IStream* pIStream )
{
    V_INAME(CSegment::Load);
    V_INTERFACE(pIStream);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::Load after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Save stream's current position
    LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pIStream->Seek(li, STREAM_SEEK_CUR, &ul);

    if(FAILED(hr))
    {
        return hr;
    }

    EnterCriticalSection(&m_CriticalSection);
    Clear(false);

    DWORD dwSavedPos = ul.LowPart;

    // Read first 4 bytes to determine what type of stream we
    // have been passed

    FOURCC type;
    DWORD dwRead;
    hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
    {
        // Check for a RIFF file
        if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
        {
            long lFileLength = 0;
            pIStream->Read(&lFileLength, sizeof(long), &dwRead);
            // Check to see if what type of RIFF file we have
            hr = pIStream->Read(&type, sizeof(FOURCC), &dwRead);

            if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
            {
                if(type == DMUS_FOURCC_SEGMENT_FORM)    // We have a DirectMusic segment
                {
                    // Since we now know what type of stream we need to
                    // seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    hr = LoadDirectMusicSegment(pIStream);
                }
                else if(type == FOURCC_SECTION_FORM)    // We have section
                {
                    // Since we now know what type of stream we need to seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Create Section
                    IDMSection* pSection;
                    if(SUCCEEDED(hr))
                    {
                        hr = ::CoCreateInstance(CLSID_DMSection,
                                                NULL,
                                                CLSCTX_INPROC,
                                                IID_IDMSection,
                                                (void**)&pSection);
                    }

                    if(SUCCEEDED(hr))
                    {
                        // Load Section
                        IPersistStream* pIPersistStream;
                        hr = pSection->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                        if(SUCCEEDED(hr))
                        {
                            hr = pIPersistStream->Load(pIStream);
                            pIPersistStream->Release();
                        }

                        if(SUCCEEDED(hr))
                        {
                            HRESULT hrTemp = pSection->CreateSegment(static_cast<IDirectMusicSegment*>(this));
                            if (hrTemp != S_OK)
                            {
                                hr = hrTemp;
                            }
                        }

                        pSection->Release();
                    }
                }
                else if(type == DMUS_FOURCC_RMID_FORM)    // We have an RMID MIDI file
                {
                    IDirectMusicCollection *pCollection = NULL;
                    BOOL fLoadedMIDI = FALSE;
                    // Since it's a RIFF file, it could have more than one top level chunk.
                    while (SUCCEEDED(hr) && (lFileLength > 8))
                    {
                        FOURCC dwType = 0;
                        DWORD dwLength;
                        pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                        hr = pIStream->Read(&dwLength, sizeof(DWORD), &dwRead);
                        lFileLength -= 8;
                        if (FAILED(hr))
                        {
                            break;
                        }
                        ULARGE_INTEGER ulPosition;  // Memorize start of chunk.
                        LARGE_INTEGER liStart;
                        liStart.QuadPart = 0;
                        hr = pIStream->Seek(liStart, STREAM_SEEK_CUR, &ulPosition);
                        liStart.QuadPart = ulPosition.QuadPart;
                        if (dwType == DMUS_FOURCC_data_FORM)
                        {   // Get MIDI file header.
                            hr = pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if(SUCCEEDED(hr) && (dwType == mmioFOURCC( 'M', 'T', 'h', 'd' )))
                            {
                                // Since we now know what type of stream we need to seek back to saved position
                                hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

                                if(SUCCEEDED(hr))
                                {
                                    hr = CreateSegmentFromMIDIStream(pIStream,
                                                                      static_cast<IDirectMusicSegment*>(this));
                                }
                                if (SUCCEEDED(hr)) fLoadedMIDI = TRUE;
                            }
                        }
                        else if ((dwType == mmioFOURCC( 'R', 'I', 'F', 'F' ) ||
                            (dwType == mmioFOURCC( 'L', 'I', 'S', 'T' ))))
                        {
                            pIStream->Read(&dwType, sizeof(FOURCC), &dwRead);
                            if (dwType == DMUS_FOURCC_DLS_FORM)
                            {
                                hr = CoCreateInstance(CLSID_DirectMusicCollection,
                                        NULL,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IDirectMusicCollection,
                                        (void**)&pCollection);
                                if (SUCCEEDED(hr))
                                {
                                    IPersistStream* pIPS;
                                    hr = pCollection->QueryInterface( IID_IPersistStream, (void**)&pIPS );
                                    if (SUCCEEDED(hr))
                                    {
                                        // We need to seek back to start of chunk
                                        liStart.QuadPart -= 8;
                                        pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);

                                        hr = pIPS->Load( pIStream );
                                        pIPS->Release();
                                    }
                                    if (FAILED(hr))
                                    {
                                        pCollection->Release();
                                        pCollection = NULL;
                                    }
                                }
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (dwLength & 1) ++dwLength;
                            ulPosition.QuadPart += dwLength; // Point to start of next chunk.
                            liStart.QuadPart = ulPosition.QuadPart;
                            hr = pIStream->Seek(liStart, STREAM_SEEK_SET, NULL);
                            lFileLength -= dwLength; // Decrement amount left in file.
                        }
                    }
                    if (pCollection)
                    {
                        if (fLoadedMIDI)
                        {
                            SetParam(GUID_ConnectToDLSCollection,-1,0,0,(void *) pCollection);
                        }
                        pCollection->Release();
                    }
                }
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    IDirectSoundWave* pWave = NULL;
                    // Seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

                    // Check to see if this wave is embedded
                    if (dwSavedPos == 0)
                    {
                        // CoCreate the wave and load it from the stream
                        if (SUCCEEDED(hr))
                        {
                            hr = CoCreateInstance(CLSID_DirectSoundWave,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IDirectSoundWave,
                                    (void**)&pWave);

                            if (SUCCEEDED(hr))
                            {
                                IPersistStream* pIPS = NULL;

                                hr = pWave->QueryInterface(IID_IPersistStream, (void**)&pIPS);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pIPS->Load( pIStream );
                                    pIPS->Release();
                                }

                                if (FAILED(hr))
                                {
                                    pWave->Release();
                                    pWave = NULL;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Have the loader load the wave object from the stream
                        DMUS_OBJECTDESC descWave;
                        ZeroMemory(&descWave, sizeof(descWave));
                        descWave.dwSize = sizeof(descWave);
                        descWave.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                        descWave.guidClass = CLSID_DirectSoundWave;
                        descWave.pStream = pIStream;
                        IDirectMusicLoader *pLoader = NULL;
                        IDirectMusicGetLoader *pGetLoader = NULL;
                        hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **)&pGetLoader);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                            {
                                hr = pLoader->GetObject(&descWave, IID_IDirectSoundWave, (void **)&pWave);
                                descWave.pStream = NULL;
                                descWave.dwValidData &= ~DMUS_OBJ_STREAM;
                                if (SUCCEEDED(hr))
                                {
                                    IDirectMusicObject* pObject = NULL;
                                    hr = pWave->QueryInterface(IID_IDirectMusicObject, (void **)&pObject);
                                    if (SUCCEEDED(hr))
                                    {
                                        // set this object to be a segment with the same GUID
                                        pObject->GetDescriptor(&descWave);
                                        descWave.guidClass = CLSID_DirectMusicSegment;
                                        SetDescriptor(&descWave);
                                        pObject->Release();
                                    }
                                }
                                pLoader->Release();
                            }
                            pGetLoader->Release();
                        }
                    }

                    if(pWave)
                    {

                        // CoCreate a wave track
                        IDirectMusicTrack* pWaveTrack = NULL;
                        if (SUCCEEDED(hr))
                        {
                            hr = ::CoCreateInstance(CLSID_DirectMusicWaveTrack,
                                                    NULL,
                                                    CLSCTX_INPROC,
                                                    IID_IDirectMusicTrack,
                                                    (void**)&pWaveTrack);
                        }

                        // Add the wave object to the wave track, and insert the track in the segment.
                        if (SUCCEEDED(hr))
                        {
                            IPrivateWaveTrack* pPrivateWave = NULL;
                            hr = pWaveTrack->QueryInterface(IID_IPrivateWaveTrack, (void**)&pPrivateWave);
                            if (SUCCEEDED(hr))
                            {
                                REFERENCE_TIME rt = 0;
                                hr = pPrivateWave->AddWave(pWave, 0, 0, 0, &rt);
                                if (SUCCEEDED(hr))
                                {
                                    SetClockTimeDuration(rt * REF_PER_MIL);
                                    SetFlags(DMUS_SEGIOF_REFLENGTH);
                                }
                                InsertTrack(pWaveTrack, 1);
                                SetTrackConfig(CLSID_DirectMusicWaveTrack, 1, 0, DMUS_TRACKCONFIG_DEFAULT | DMUS_TRACKCONFIG_PLAY_CLOCKTIME,0);
                                pPrivateWave->Release();
                            }
                        }

                        // Clean up anything that's still hanging around
                        if (pWaveTrack) pWaveTrack->Release();
                        if (pWave) pWave->Release();
                    }
                }
            }
            else
            {
                hr = DMUS_E_CANNOTREAD;
            }
        }
        // Check for a template file
        else if(type == mmioFOURCC('L', 'P', 'T', 's'))
        {
            // Since we now know what type of stream we need to seek back to saved position
            li.HighPart = 0;
            li.LowPart = dwSavedPos;
            hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

            // Create Template
            IDMTempl* pTemplate;
            if(SUCCEEDED(hr))
            {
                hr = ::CoCreateInstance(CLSID_DMTempl,
                                        NULL,
                                        CLSCTX_INPROC,
                                        IID_IDMTempl,
                                        (void**)&pTemplate);
            }

            if(SUCCEEDED(hr))
            {
                // Load Template
                IPersistStream* pIPersistStream;
                hr = pTemplate->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);

                if(SUCCEEDED(hr))
                {
                    hr = pIPersistStream->Load(pIStream);
                    pIPersistStream->Release();
                }

                if(SUCCEEDED(hr))
                {
                    hr = pTemplate->CreateSegment(static_cast<IDirectMusicSegment*>(this));
                }

                pTemplate->Release();
            }
        }
        // Check for normal MIDI file
        else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
        {
            // Since we now know what type of stream we need to seek back to saved position
            li.HighPart = 0;
            li.LowPart = dwSavedPos;
            hr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

            if(SUCCEEDED(hr))
            {
                hr = CreateSegmentFromMIDIStream(pIStream,
                                                  static_cast<IDirectMusicSegment*>(this));
            }
        }
        else
        {
            // Not a DirectMusic Segment file, MIDI file or section or
            // template; unsupported
            Trace(1,"Error: Segment unable to parse file. Must be segment, midi, wave, or rmi file format.\n");
            hr = DMUS_E_UNSUPPORTED_STREAM;
        }
    }
    else
    {
        hr = DMUS_E_CANNOTREAD;
    }
    if( SUCCEEDED(hr) )
    {
        m_dwValidData |= DMUS_OBJ_LOADED;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


HRESULT CSegment::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSegment::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

HRESULT CSegment::LoadDirectMusicSegment(IStream* pIStream)
{
    // Argument validation
    assert(pIStream);
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    HRESULT hr = S_OK;
    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM)
        {
            RIFFIO ckNext;    // Descends into the next chunk.
            RIFFIO ckChild;   // For scanning through children lists.
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                case DMUS_FOURCC_SEGMENT_CHUNK:
                    DMUS_IO_SEGMENT_HEADER ioSegHdr;
                    ioSegHdr.rtLength = 0;
                    ioSegHdr.dwFlags = 0;
                    hr = Parser.Read(&ioSegHdr, sizeof(DMUS_IO_SEGMENT_HEADER));
                    if(SUCCEEDED(hr))
                    {
                        m_dwResolution = ioSegHdr.dwResolution;
                        m_mtLength = ioSegHdr.mtLength;
                        m_mtStart = ioSegHdr.mtPlayStart;
                        m_mtLoopStart = ioSegHdr.mtLoopStart;
                        m_mtLoopEnd = ioSegHdr.mtLoopEnd;
                        m_dwRepeats = ioSegHdr.dwRepeats;
                        m_dwSegFlags = ioSegHdr.dwFlags;
                        if (m_dwSegFlags & DMUS_SEGIOF_REFLENGTH)
                        {
                            m_rtLength = ioSegHdr.rtLength;
                        }
                        else
                        {
                            m_rtLength = 0;
                        }
                    }
                    break;

                case DMUS_FOURCC_GUID_CHUNK:
                    if( ckNext.cksize == sizeof(GUID) )
                    {
                        hr = Parser.Read(&m_guidObject, sizeof(GUID));
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_OBJECT;
                        }
                    }
                    break;

                case DMUS_FOURCC_VERSION_CHUNK:
                    hr = Parser.Read(&m_vVersion, sizeof(DMUS_VERSION) );
                    if( SUCCEEDED(hr) )
                    {
                        m_dwValidData |= DMUS_OBJ_VERSION;
                    }
                    break;

                case DMUS_FOURCC_CATEGORY_CHUNK:
                    hr = Parser.Read( m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                    m_wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
                    if( SUCCEEDED(hr) )
                    {
                        m_dwValidData |= DMUS_OBJ_CATEGORY;
                    }
                    break;

                case DMUS_FOURCC_DATE_CHUNK:
                    if( sizeof(FILETIME) == ckNext.cksize )
                    {
                        hr = Parser.Read( &m_ftDate, sizeof(FILETIME));
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_DATE;
                        }
                    }
                    break;

                case FOURCC_LIST:
                case FOURCC_RIFF:
                    switch(ckNext.fccType)
                    {
                        case DMUS_FOURCC_UNFO_LIST:
                            Parser.EnterList(&ckChild);
                            while (Parser.NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_UNAM_CHUNK:
                                    {
                                        hr = Parser.Read(&m_wszName, sizeof(m_wszName));
                                        m_wszName[DMUS_MAX_NAME-1] = '\0';
                                        if(SUCCEEDED(hr) )
                                        {
                                            m_dwValidData |= DMUS_OBJ_NAME;
                                        }
                                        break;
                                    }
                                    default:
                                        break;
                                }
                            }
                            Parser.LeaveList();
                            break;
                        case DMUS_FOURCC_CONTAINER_FORM:
                            // An embedded container RIFF chunk which includes a bunch
                            // of objects referenced by the segment. This should precede the
                            // tracks and gets loaded prior to the tracks. Loading this
                            // causes all of its objects to get SetObject'd in the loader,
                            // so they later get pulled in as requested by the tracks.
                            // After the tracks are loaded, the loader references are
                            // released by a call to release the IDirectMusicContainer.
                            {
                                DMUS_OBJECTDESC Desc;
                                IDirectMusicLoader *pLoader;
                                IDirectMusicGetLoader *pGetLoader;
                                HRESULT hrTemp = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                if (SUCCEEDED(hrTemp))
                                {
                                    if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                    {
                                        // Move back stream's current position
                                        Parser.SeekBack();
                                        Desc.dwSize = sizeof(Desc);
                                        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                        Desc.guidClass = CLSID_DirectMusicContainer;
                                        Desc.pStream = pIStream;
                                        pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                        if (pContainer)
                                        {
                                            // Don't cache the container object! We want it and the
                                            // objects it references to go away when the segment is done loading.
                                            IDirectMusicObject *pObject = NULL;
                                            pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                            if (pObject)
                                            {
                                                pLoader->ReleaseObject(pObject);
                                                pObject->Release();
                                            }
                                        }
                                        // Now, seek to the end of this chunk.
                                        Parser.SeekForward();
                                        pLoader->Release();
                                    }
                                    pGetLoader->Release();
                                }
                            }
                            break;
                        case DMUS_FOURCC_TRACK_LIST:
                            Parser.EnterList(&ckChild);
                            while(Parser.NextChunk(&hr))
                            {
                                if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_TRACK_FORM))
                                {
                                    hr = LoadTrack(&Parser);
                                }
                            }
                            Parser.LeaveList();
                            break;
                        case DMUS_FOURCC_TOOLGRAPH_FORM:
                            hr = LoadGraph(&Parser,&m_pGraph);
                            break;
                        case DMUS_FOURCC_AUDIOPATH_FORM:
                            // Move back to start of this chunk.
                            Parser.SeekBack();
                            hr = LoadAudioPath(pIStream);
                            // Now, seek to the end of this chunk.
                            Parser.SeekForward();
                            break;
                    }
                    break;
                }
            }
            Parser.LeaveList();
            if (pContainer)
            {
                pContainer->Release();
            }
        }
        else
        {
            Trace(1,"Error: Unknown file format.\n");
            hr = DMUS_E_DESCEND_CHUNK_FAIL;
        }
    }
    Parser.LeaveList();
    if (SUCCEEDED(hr) && Parser.ComponentFailed())
    {
        Trace(1,"Warning: Segment successfully loaded but one or more tracks within it did not.\n");
        hr = DMUS_S_PARTIALLOAD;
    }

    return hr;
}

HRESULT CSegment::LoadTrack(CRiffParser *pParser)
{
    BOOL fHeaderRead = FALSE;

    DMUS_IO_TRACK_HEADER ioTrackHdr;
    DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
    ioTrackExtrasHdr.dwPriority = 0;
    ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    ioTrackHdr.ckid = 0;
    ioTrackHdr.fccType = 0;
    ioTrackHdr.dwPosition = 0;

    RIFFIO ckNext;
    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        if (ckNext.ckid == DMUS_FOURCC_TRACK_CHUNK)
        {
            fHeaderRead = TRUE;
            hr = pParser->Read(&ioTrackHdr, sizeof(DMUS_IO_TRACK_HEADER));
            if(ioTrackHdr.ckid == 0 && ioTrackHdr.fccType == NULL)
            {
                Trace(1,"Error: Invalid track header in Segment.\n");
                hr = DMUS_E_INVALID_TRACK_HDR;
            }
        }
        else if (ckNext.ckid == DMUS_FOURCC_TRACK_EXTRAS_CHUNK)
        {
            hr = pParser->Read(&ioTrackExtrasHdr, sizeof(DMUS_IO_TRACK_EXTRAS_HEADER));
        }
        else if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
            && ckNext.fccType == ioTrackHdr.fccType) ||
            (ckNext.ckid == ioTrackHdr.ckid))
        {
            if (fHeaderRead)
            {
                // Okay, this is the chunk we are looking for.
                // Seek back to start of chunk.
                pParser->SeekBack();
                // Let the parser know it's okay to fail this.
                pParser->EnteringComponent();
                hr = CreateTrack(ioTrackHdr, ioTrackExtrasHdr.dwFlags, ioTrackExtrasHdr.dwPriority, pParser->GetStream());
                // Now, make sure we are at the end of the chunk.
                pParser->SeekForward();
            }
            else
            {
                Trace(1,"Error: Invalid track in Segment - track header is not before track data.\n");
                hr = DMUS_E_TRACK_HDR_NOT_FIRST_CK;
            }

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSegment::CreateTrack(DMUS_IO_TRACK_HEADER& ioTrackHdr, DWORD dwFlags, DWORD dwPriority, IStream *pStream)
{
    assert(pStream);

    IDirectMusicTrack* pDMTrack = NULL;
    HRESULT hrTrack = S_OK;
    HRESULT hr = CoCreateInstance(ioTrackHdr.guidClassID,
                                  NULL,
                                  CLSCTX_INPROC,
                                  IID_IDirectMusicTrack,
                                  (void**)&pDMTrack);

    IPersistStream *pIPersistStream = NULL;

    if(SUCCEEDED(hr))
    {
        hr = pDMTrack->QueryInterface(IID_IPersistStream, (void **)&pIPersistStream);
    }

    if(SUCCEEDED(hr))
    {
        hr = hrTrack = pIPersistStream->Load(pStream);
    }

    if(SUCCEEDED(hr))
    {
        hr = InsertTrack(pDMTrack, ioTrackHdr.dwGroup, dwFlags, dwPriority, ioTrackHdr.dwPosition);
    }

    if(pIPersistStream)
    {
        pIPersistStream->Release();
    }

    if(pDMTrack)
    {
        pDMTrack->Release();
    }

    if (hr == S_OK && hrTrack != S_OK)
    {
        hr = hrTrack;
    }
    return hr;
}

HRESULT CSegment::LoadGraph(CRiffParser *pParser,CGraph **ppGraph)
{
    CGraph *pGraph = new CGraph;
    if (pGraph == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pGraph->Load(pParser);

    EnterCriticalSection(&m_CriticalSection);
    if(*ppGraph)
    {
        (*ppGraph)->Release();
    }
    *ppGraph = pGraph;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSegment::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    if (FAILED(hr))
    {
        Trace(1,"Segment failed loading embedded AudioPath Configuration\n");
    }

    EnterCriticalSection(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    if (m_dwVersion < 8) m_dwVersion = 8;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSegment::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSegment::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::GetDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    pDesc->guidClass = CLSID_DirectMusicSegment;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    StringCchCopyW( pDesc->wszName, DMUS_MAX_NAME, m_wszName);
    StringCchCopyW( pDesc->wszCategory, DMUS_MAX_CATEGORY, m_wszCategory);
    StringCchCopyW( pDesc->wszFileName, DMUS_MAX_FILENAME, m_wszFileName);
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CSegment::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSegment::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::SetDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    if (pDesc->dwSize)
    {
        V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);
    }

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if(pDesc->dwValidData & DMUS_OBJ_CLASS)
        {
            dw |= DMUS_OBJ_CLASS;
        }

        if(pDesc->dwValidData & DMUS_OBJ_LOADED)
        {
            dw |= DMUS_OBJ_LOADED;
        }

        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            StringCchCopyW( m_wszName, DMUS_MAX_NAME, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            StringCchCopyW( m_wszCategory, DMUS_MAX_CATEGORY, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            StringCchCopyW( m_wszFileName, DMUS_MAX_FILENAME, pDesc->wszFileName);
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: Segment::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        Trace(1,"Error: Unable to set segment descriptor, size field is too small.\n");
    }
    return hr;
}

STDMETHODIMP CSegment::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CSegment::ParseDescriptor);
    V_INTERFACE(pStream);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC);
    if (pDesc->dwSize)
    {
        V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);
    }
    else
    {
        pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    }

    if (m_fZombie)
    {
        Trace(2, "Warning: Call of IDirectMusicSegment::ParseDescriptor after the segment has been garbage collected.\n");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hret = E_FAIL;
    // Save stream's current position
    LARGE_INTEGER li;
    ULARGE_INTEGER ul;

    li.HighPart = 0;
    li.LowPart = 0;

    HRESULT hr = pStream->Seek(li, STREAM_SEEK_CUR, &ul);

    if(FAILED(hr))
    {
        return hr;
    }
    pDesc->dwValidData = 0;
    DWORD dwSavedPos = ul.LowPart;

    // Read first 4 bytes to determine what type of stream we
    // have been passed

    FOURCC type;
    DWORD dwRead;
    hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);

    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
    {
        // Check for a RIFF file
        if(type == mmioFOURCC( 'R', 'I', 'F', 'F' ))
        {
            // Check to see if what type of RIFF file we have
            li.HighPart = 0;
            li.LowPart = dwSavedPos + 8; // Length needed to seek to form type of RIFF chunk

            hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
            if(SUCCEEDED(hr))
            {
                hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
            }

            if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
            {
                if(type == DMUS_FOURCC_SEGMENT_FORM)    // We have a DirectMusic segment
                {
                    // Since we now know what type of stream we need to
                    // seek back to saved position
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos;
                    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                    if( SUCCEEDED(hr) ) // should always succeed.
                    {
                        hret = ParseSegment(pStream, pDesc);
                    }
                }
                else if(type == FOURCC_SECTION_FORM)    // We have section
                {
                    long lTemp;
                    hr = pStream->Read(&lTemp, sizeof(long), &dwRead);
                    if( lTemp == mmioFOURCC('s','e','c','n') )
                    {
                        hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // length
                        hr = pStream->Read(&lTemp, sizeof(long), &dwRead); // time
                        if( SUCCEEDED(hr) && (dwRead == sizeof(long) ))
                        {
                            hr = pStream->Read(&pDesc->wszName, sizeof(WCHAR)*16, &dwRead);
                            pDesc->wszName[16-1] = '\0';
                            if(SUCCEEDED(hr) && (dwRead == sizeof(WCHAR)*16))
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                        }
                        hret = S_OK;
                    }
                }
                else if (type == mmioFOURCC('W','A','V','E')) // we have a wave file
                {
                    // Create a wave object and have it parse the file.
                    IDirectMusicObject *pObject;
                    hret = CoCreateInstance(CLSID_DirectSoundWave,NULL,CLSCTX_INPROC_SERVER,
                        IID_IDirectMusicObject,(void **) &pObject);
                    if(SUCCEEDED(hret))
                    {
                        // seek back to saved position
                        li.HighPart = 0;
                        li.LowPart = dwSavedPos;
                        hret = pStream->Seek(li, STREAM_SEEK_SET, NULL);
                        if (SUCCEEDED(hret))
                        {
                            hret = pObject->ParseDescriptor(pStream,pDesc);
                        }
                        pObject->Release();
                    }
                }
                // Check to see if we have a MIDI file
                else
                {
                    li.HighPart = 0;
                    li.LowPart = dwSavedPos + 20; // Length needed to seek to start of normal MIDI file
                                                  // contained within the Riff chunk

                    hr = pStream->Seek(li, STREAM_SEEK_SET, NULL);

                    if(SUCCEEDED(hr))
                    {
                        hr = pStream->Read(&type, sizeof(FOURCC), &dwRead);
                    }

                    if(SUCCEEDED(hr) && dwRead == sizeof(FOURCC))
                    {
                        if(type == mmioFOURCC( 'M', 'T', 'h', 'd' ))
                        {
                            hret = S_OK;
                        }
                    }
                }
            }
        }
        // Check for a template file
        else if(type == mmioFOURCC('L', 'P', 'T', 's'))
        {
            hret = S_OK;
        }
        // Check for normal MIDI file
        else if(type == mmioFOURCC('M', 'T', 'h', 'd'))
        {
            hret = S_OK;
        }
    }
    if (SUCCEEDED(hret))
    {
        pDesc->dwValidData |= DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicSegment;
    }
#ifdef DBG
    if (hret == E_FAIL)
    {
        Trace(1,"Error: Segment unable to parse file - unknown format.\n");
    }
#endif
    return hret;
}

HRESULT CSegment::ParseSegment(IStream* pIStream, LPDMUS_OBJECTDESC pDesc)
{
    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_SEGMENT_FORM))
    {
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                pDesc->wszCategory[DMUS_MAX_CATEGORY-1] = '\0';
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            pDesc->wszName[DMUS_MAX_NAME-1] = '\0';
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    return hr;
}

void CSegmentList::Clear()
{
    CSegment *pSeg;
    while (pSeg = RemoveHead())
    {
        pSeg->SetNext(NULL);
        pSeg->m_pSong = NULL;
        pSeg->Release();
    }
}

inline REFERENCE_TIME ConvertToReference(MUSIC_TIME mtSpan, double dblTempo)
{
    REFERENCE_TIME rtTemp = mtSpan;
    rtTemp *= 600000000;
    rtTemp += (DMUS_PPQ / 2);
    rtTemp /= DMUS_PPQ;
    rtTemp = (REFERENCE_TIME)(rtTemp / dblTempo);
    return rtTemp;
}

inline MUSIC_TIME ConvertToMusic(REFERENCE_TIME rtSpan, double dblTempo)
{
    rtSpan *= DMUS_PPQ;
    rtSpan = (REFERENCE_TIME)(rtSpan * dblTempo);
    rtSpan += 300000000;
    rtSpan /= 600000000;
#ifdef DBG
    if ( rtSpan & 0xFFFFFFFF00000000 )
    {
        Trace(1,"Error: Invalid Reference to Music time conversion resulted in overflow.\n");
    }
#endif
    return (MUSIC_TIME) (rtSpan & 0xFFFFFFFF);
}

HRESULT CSegment::MusicToReferenceTime(MUSIC_TIME mtTime, REFERENCE_TIME *prtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || mtTempo + mtNext >= mtTime) break;
            rtTempo += ConvertToReference(mtNext, dbl);
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *prtTime = rtTempo + ConvertToReference(mtTime - mtTempo, dbl);
    return S_OK;
}

HRESULT CSegment::ReferenceToMusicTime(REFERENCE_TIME rtTime, MUSIC_TIME *pmtTime)
{
    double dbl = 120;
    MUSIC_TIME mtTempo = 0;
    REFERENCE_TIME rtTempo = 0;
    MUSIC_TIME mtNext = 0;
    PrivateTempo Tempo;
    HRESULT hr;

    do
    {
        hr = GetParam(GUID_PrivateTempoParam, -1, 0, mtTempo, &mtNext,(void *)&Tempo );
        if (hr == S_OK)
        {
            REFERENCE_TIME rtNext = rtTempo + ConvertToReference(mtNext, dbl);
            dbl = Tempo.dblTempo;
            if (Tempo.fLast || rtNext >= rtTime) break;
            rtTempo = rtNext;
            mtTempo += mtNext;
        }

    } while (hr == S_OK);

    *pmtTime = mtTempo + ConvertToMusic(rtTime - rtTempo, dbl);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmsstobj.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// dmsstobj.cpp : Implementation of CSegState

#include "dmime.h"
#include "DMSStObj.h"
#include "dmsegobj.h"
#include "song.h"
#include "dmgraph.h"
#include "dmperf.h"
#include "dmusici.h"
#include "..\shared\Validate.h"
#include "debug.h"
#include "dmscriptautguids.h"
#include "paramtrk.h"
#define ASSERT assert

CSegState::CSegState()
{
    InitializeCriticalSection(&m_CriticalSection);
    InterlockedIncrement(&g_cComponent);
    m_fDelayShutDown = false;
    m_fInPlay = false;
    m_cRef = 1;
    m_dwPlayTrackFlags = DMUS_TRACKF_START | DMUS_TRACKF_SEEK;
    m_dwFirstTrackID = 0;
    m_dwLastTrackID = 0;
    m_mtEndTime = 0;
    m_mtAbortTime = 0;
    m_mtOffset = 0;
    m_rtOffset = 0;
    m_rtEndTime = 0;
    m_mtStartPoint = 0;
    m_rtStartPoint = 0;
    m_mtSeek = 0;
    m_rtSeek = 0;
    m_rtFirstLoopStart = 0;
    m_rtCurLoopStart = 0;
    m_rtCurLoopEnd = 0;
    m_mtLength = 0;
    m_rtLength = 0;
    m_mtLoopStart = 0;
    m_mtLoopEnd = 0;
    m_dwRepeatsLeft = 0;
    m_dwRepeats = 0;
    m_dwVersion = 0; // Init to 6.1 behavior.
    m_fPrepped = FALSE;
    m_fCanStop = TRUE;
    m_rtGivenStart = -1;
    m_mtResolvedStart = -1;
    m_mtLastPlayed = 0;
    m_rtLastPlayed = 0;
    m_mtStopTime = 0;
    m_dwPlaySegFlags = 0;
    m_dwSegFlags = 0;
    m_fStartedPlay = FALSE;
    m_pUnkDispatch = NULL;
    m_pSegment = NULL;
    m_pPerformance = NULL;
    m_pAudioPath = NULL;
    m_pGraph = NULL;
    m_fSongMode = FALSE;
    m_pSongSegState = NULL;
    TraceI(2, "SegmentState %lx created\n", this );
}

CSegState::~CSegState()
{
    if (m_pUnkDispatch)
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    if (m_pAudioPath) m_pAudioPath->Release();
    if (m_pGraph) m_pGraph->Release();
    if (m_pSongSegState) m_pSongSegState->Release();
    InterlockedDecrement(&g_cComponent);
    DeleteCriticalSection(&m_CriticalSection);
    TraceI(2, "SegmentState %lx destroyed with %ld releases outstanding\n", this, m_cRef );
}


STDMETHODIMP CSegState::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSegState::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IDirectMusicSegmentState || 
        iid == IID_IDirectMusicSegmentState8)
    {
        *ppv = static_cast<IDirectMusicSegmentState*>(this);
    } else
    if (iid == IID_CSegState)
    {
        *ppv = static_cast<CSegState*>(this);
    } else 
    if (iid == IID_IDirectMusicGraph)
    {
        *ppv = static_cast<IDirectMusicGraph*>(this);
    } else
    if (iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose from the
        // Performance object via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSegmentState,
                static_cast<IDirectMusicSegmentState*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on SegmentState object\n");
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CSegState::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSegState::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

/*
  Private initialization function called by IDirectMusicSegment to set this
  state object's parent segment and performance. Addref's the parent segment
  but only retains a weak reference to the performance.
*/
HRESULT CSegState::PrivateInit(
    CSegment *pParentSegment,
    CPerformance *pPerformance)
{
    HRESULT hr = S_OK;
    ASSERT(pParentSegment);
    ASSERT(pPerformance);

    m_pSegment = pParentSegment;
    pParentSegment->AddRef();
    m_pPerformance = pPerformance; // retain only a weak reference
    m_rtLength = pParentSegment->m_rtLength;
    if (m_rtLength) // It's a ref time segment, so convert the length to music time
    {
        pParentSegment->ReferenceToMusicTime(m_rtLength, &m_mtLength);
    }
    else
    {
        m_mtLength = pParentSegment->m_mtLength;
    }
    m_mtStartPoint = pParentSegment->m_mtStart;
    pParentSegment->MusicToReferenceTime(m_mtStartPoint, &m_rtStartPoint);
    m_mtLoopStart = pParentSegment->m_mtLoopStart;
    m_mtLoopEnd = pParentSegment->m_mtLoopEnd;
    m_dwSegFlags = pParentSegment->m_dwSegFlags;
    m_dwRepeats = pParentSegment->m_dwRepeats;
    // Don't allow repeat count to overflow and cause mathematical errors. 
    // Make it so it can't create a segment length larger than 0x3FFFFFFF, 
    // which would last for 8 days at 120 bpm!
    if (m_dwRepeats)
    {
        if ((m_mtLoopEnd == 0) && (m_mtLoopStart == 0))
        {
            // This happens when loading waves and MIDI files. 
            m_mtLoopEnd = m_mtLength;
        }
        // Make sure the loop is real.
        if (m_mtLoopEnd > m_mtLoopStart)
        {
            // Take the maximum length, subtract out the full length, then divide by the loop size.
            DWORD dwMax = (0x3FFFFFFF - m_mtLength) / (m_mtLoopEnd - m_mtLoopStart);
            // dwMax is the maximum number of loops that can be done without overflowing the time.
            if (m_dwRepeats > dwMax)
            {
                m_dwRepeats = dwMax;
            }
        }
        else
        {
            m_dwRepeats = 0;
        }
    }
    m_dwRepeatsLeft = m_dwRepeats;
    if( m_mtLoopEnd == 0 )
    {
        m_mtLoopEnd = m_mtLength;
    }
    if( m_mtStartPoint >= m_mtLoopEnd )
    {
        // in this case, we're not doing any looping.
        m_mtLoopEnd = m_mtLoopStart = 0;
        m_dwRepeats = m_dwRepeatsLeft = 0;
    }
    return hr;
}

HRESULT CSegState::InitRoute(IDirectMusicAudioPath *pAudioPath)

{
    HRESULT hr = E_INVALIDARG;
    EnterCriticalSection(&m_CriticalSection);
    if (pAudioPath)
    {
        if (m_dwVersion < 8) m_dwVersion = 8;
        m_pAudioPath = (CAudioPath *) pAudioPath;
        pAudioPath->AddRef();
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/*
  This is called from the performance when it wants to release a
  segmentstate. This ensures that the segstate is
  no longer valid once outside the Performance.
*/
HRESULT CSegState::ShutDown(void)
{
    if (this)
    {
        if (m_fInPlay)
        {
            m_fDelayShutDown = true;
            return S_OK;
        }
        EnterCriticalSection(&m_CriticalSection);
        m_TrackList.Clear();
        if( m_pSegment )
        {
            m_pSegment->Release();
            m_pSegment = NULL;
        }
        if( m_pAudioPath)
        {
            m_pAudioPath->Release();
            m_pAudioPath = NULL;
        }
        if (m_pSongSegState)
        {
            m_pSongSegState->Release();
            m_pSongSegState = NULL;
        }
        m_pPerformance = NULL;
        LeaveCriticalSection(&m_CriticalSection);
        if( int nCount = Release() )
        {
            TraceI( 2, "Warning! SegmentState %lx still referenced %d times after Performance has released it.\n", this, nCount );
        }

        return S_OK;
    }
    TraceI(0,"Attempting to delete a NULL SegmentState!\n");
    return E_FAIL;
}

/*
  Retrieve the internal track list. Used by IDirectMusicSegment.
*/
HRESULT CSegState::GetTrackList(
    void** ppTrackList)
{
    ASSERT(ppTrackList);
    *ppTrackList = (void*)&m_TrackList;
    return S_OK;
}

/*
  Computes the length of the segmentstate using the internal length, loop points,
  and repeat count. This is the length of the segstate that will actually play,
  not necessarily the length if it played from the beginning.
*/
MUSIC_TIME CSegState::GetEndTime(MUSIC_TIME mtStartTime)
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_rtLength && m_pPerformance)
    {
        // If there is a reference time length, convert it into Music Time.
        // ALSO: convert m_mtLength and re-adjust loop points.
        MUSIC_TIME mtOffset = m_mtResolvedStart;
        REFERENCE_TIME rtOffset = 0;
        m_pPerformance->MusicToReferenceTime(mtOffset, &rtOffset);
        REFERENCE_TIME rtEndTime = (m_rtLength - m_rtStartPoint) + rtOffset; // Convert from length to actual end time.
        m_pPerformance->ReferenceToMusicTime(rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - mtOffset + m_mtStartPoint;
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength ) // shrink loop end to equal length
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    LONGLONG length;
    length = m_mtLength + ((m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats);
    length -= m_mtStartPoint;
    length += mtStartTime;
    if(length > 0x7fffffff) length = 0x7fffffff;
    return (MUSIC_TIME)length;
}

/*
  Converts an absolute Performance time to the index into the SegmentState, using
  the SegmentState's offset, internal length, loop points, and repeat count.
  Also returns the offset and repeat count for that time.
*/
HRESULT CSegState::ConvertToSegTime(
    MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat )
{
    ASSERT( pmtTime );
    ASSERT( pmtOffset );
    ASSERT( pdwRepeat );

    MUSIC_TIME mtPos = *pmtTime - m_mtResolvedStart + m_mtStartPoint;
    MUSIC_TIME mtLoopLength = m_mtLoopEnd - m_mtLoopStart;
    DWORD dwRepeat = 0;
    DWORD mtOffset = m_mtResolvedStart - m_mtStartPoint;

    while( mtPos >= m_mtLoopEnd )
    {
        if( dwRepeat >= m_dwRepeats ) break;
        mtPos -= mtLoopLength;
        mtOffset += mtLoopLength;
        dwRepeat++;
    }
    *pmtTime = mtPos;
    *pmtOffset = mtOffset;
    *pdwRepeat = dwRepeat;
    if( (mtPos >= 0) && (mtPos < m_mtLength) )
    {
        return S_OK;    // time is in range of the Segment
    }
    else
    {
        return S_FALSE; // time is out of range of the Segment
    }
}

void CSegState::GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime )
{
    GUID guid;
    HRESULT hr;
    guid = GUID_NOTIFICATION_SEGMENT;

    hr = m_pSegment->CheckNotification( guid );

    if( S_FALSE != hr )
    {
        DMUS_NOTIFICATION_PMSG* pEvent = NULL;
        if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->dwField1 = 0;
            pEvent->dwField2 = 0;
            pEvent->guidNotificationType = GUID_NOTIFICATION_SEGMENT;
            pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
            pEvent->dwNotificationOption = dwNotification;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->punkUser = (IUnknown*)(IDirectMusicSegmentState*)this;
            AddRef();
            StampPMsg((DMUS_PMSG*)pEvent);
            if(FAILED(m_pPerformance->SendPMsg( (DMUS_PMSG*)pEvent )))
            {
                m_pPerformance->FreePMsg((DMUS_PMSG*) pEvent );
            }
        }
    }
}

/* 
  Called to send the tools in the tool graph a dirty pmsg so they update any
  cached GetParam() info.
*/
void CSegState::SendDirtyPMsg( MUSIC_TIME mtTime )
{
    DMUS_PMSG* pEvent = NULL;
    if (m_pPerformance)
    {
        if( SUCCEEDED( m_pPerformance->AllocPMsg( sizeof(DMUS_PMSG), 
            (DMUS_PMSG**)&pEvent )))
        {
            pEvent->mtTime = mtTime;
            pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_IMMEDIATE;
            pEvent->dwGroupID = 0xffffffff;
            pEvent->dwType = DMUS_PMSGT_DIRTY;
            StampPMsg((DMUS_PMSG*)pEvent);
            if( FAILED( m_pPerformance->SendPMsg( pEvent )))
            {
                m_pPerformance->FreePMsg( pEvent );
            }
        }
    }
}

/*
  Called when the SegState is stopped prematurely, so we can send a SEGABORT
  Notification.
  Also, flushes all events that were sent after the stop time. 
*/
HRESULT CSegState::AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn )
{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pPerformance)
    {
        if( m_mtLastPlayed > mtTime )
        {
            // If we've played past the abort time, we need to flush messages. 
            // Note that if we were aborted by playing another segment that had
            // the DMUS_SEGF_NOINVALIDATE flag set, don't truncate notes
            // that are currently on.
            CTrack* pTrack;
            pTrack = m_TrackList.GetHead();
            while( pTrack )
            {
                m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, fLeaveNotesOn );
                pTrack = pTrack->GetNext();
            }
            m_mtLastPlayed = mtTime;
        }
        // Always fill in the updated value for lastplayed so the ShutDown or Done queue will flush this
        // at the right time.
        m_pPerformance->MusicToReferenceTime(mtTime,&m_rtLastPlayed);
    }
    LeaveCriticalSection(&m_CriticalSection);
    // Always generate an abort for a segment that has not started playing yet. 
    if (m_fStartedPlay && (m_mtEndTime <= mtTime))
    {
        return S_FALSE; // Abort was too late to matter.
    }
    if (m_mtAbortTime)  // Previous abort.
    {
        if (m_mtAbortTime <= mtTime) // Is this earlier?
        {
            return S_FALSE;     // No, don't send abort message.
        }
    }
    m_mtAbortTime = mtTime;
    // Find all the parameter control tracks and invalidate any parameter envelopes
    // that need invalidation.
    CTrack* pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        if (pTrack->m_guidClassID == CLSID_DirectMusicParamControlTrack)
        {
            CParamControlTrack* pParamTrack = NULL;
            if (pTrack->m_pTrack &&
                SUCCEEDED(pTrack->m_pTrack->QueryInterface(IID_CParamControlTrack, (void**)&pParamTrack)))
            {
                pParamTrack->OnSegmentEnd(m_rtLastPlayed, pTrack->m_pTrackState);
                pParamTrack->Release();
            }
        }
        pTrack = pTrack->GetNext();
    }
    GenerateNotification( DMUS_NOTIFICATION_SEGABORT, mtTime );
    // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
    if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
    {
        TraceI(4, "Send Dirty PMsg [4] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
        SendDirtyPMsg( m_mtOffset + m_mtSeek );
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState

//////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetRepeats
/*
@method HRESULT | IDirectMusicSegmentState | GetRepeats |
Returns the number of times the SegmentState is set to repeat. A value of zero indicates
to play through only once (no repeats.) This value remains constant throughout the life
of the SegmentState.

@rvalue E_POINTER | if <p pdwRepeats> is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetRepeats( 
    DWORD *pdwRepeats)  // @parm Returns the repeat count.
{
    V_INAME(IDirectMusicSegmentState::GetRepeats);
    V_PTR_WRITE(pdwRepeats,DWORD);

    *pdwRepeats = m_dwRepeats;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSegment
/*
@method HRESULT | IDirectMusicSegmentState | GetSegment |
Returns a pointer to the Segment that owns this SegmentState.

@rvalue E_POINTER | if ppSegment is NULL or invalid.
@rvalue S_OK | Success.
*/
HRESULT STDMETHODCALLTYPE CSegState::GetSegment( 
    IDirectMusicSegment **ppSegment)    // @parm The Segment interface pointer to this
                                        // SegmentState. Call Release() on this pointer when
                                        // through.
{
    V_INAME(IDirectMusicSegmentState::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

    *ppSegment = (IDirectMusicSegment *) m_pSegment;
    if( m_pSegment )
    {
        m_pSegment->AddRef();
    }
    else
    {
        Trace(1,"Error: Segmentstate doesn't have an associated segment.\n");
        return DMUS_E_NOT_FOUND;
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::Play
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | Play |
<om IDirectMusicSegmentState.Play> is called regularly by the Performance object, 
usually every 200 ms or so, at a time ahead of playback that is set by 
<om IDirectMusicPerformance.SetPerformTime>
.
parm MUSIC_TIME | mtAmount |
    [in] The length of time to play, starting at the current Seek time.
    The SegmentState updates its Seek time to be the current Seek time
    plus mtAmount. Therefore, the SegmentState should play from the current
    Seek time to Seek time plus mtAmount, not including the last clock.

comm 
Play calls each Track's Play method in priority order, instructing the Track to 
create events from the current Seek time up to, but not including the current Seek
time plus <p mtAmount.>
Since the Segment started at the point designated by m_mtOffset (set by
<im IDirectMusicSegmentState.SetOffset>
m_mtOffset sets the starting offset to add to the times of all events.

rvalue E_INVALIDARG | mtAmount <= 0
rvalue S_OK | Success.
*/

HRESULT STDMETHODCALLTYPE CSegState::Play( 
    /* [in] */ MUSIC_TIME mtAmount, MUSIC_TIME* pmtPlayed )
{
    return E_FAIL;      // We don't want to support this publicly!
}

HRESULT CSegState::Play( MUSIC_TIME mtAmount )
{
    CTrack* pCTrack;
    MUSIC_TIME mtMyAmount = mtAmount;
    REFERENCE_TIME rtMyAmount;
    HRESULT hr = DMUS_S_END;
    BOOL fUseClockTime = FALSE;

    if( mtAmount <= 0 )
        return E_INVALIDARG;

    EnterCriticalSection(&m_CriticalSection);
    if (m_fInPlay)
    {
        LeaveCriticalSection(&m_CriticalSection);
        return S_OK;
    }
    m_fInPlay = true;
    m_pPerformance->m_pGetParamSegmentState = (IDirectMusicSegmentState *) this;
    // if this is the first call to play, we need to send a SegStart notification.
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // send a segment start notification
        GenerateNotification( DMUS_NOTIFICATION_SEGSTART, m_mtOffset );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [1] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // set the current seek to the start point
        m_mtSeek = m_mtStartPoint;
        // convert current offset to ref time
        m_pPerformance->MusicToReferenceTime(m_mtOffset,&m_rtOffset);
        m_rtEndTime = m_rtOffset + m_rtLength;
        // subtract the start points from the offsets
        m_mtOffset -= m_mtStartPoint;
        m_rtOffset -= m_rtStartPoint;
        m_rtEndTime -= m_rtStartPoint;
        m_rtSeek = m_rtLastPlayed - m_rtOffset;

        m_rtFirstLoopStart = 0;
    }
    if (m_rtLength)
    {
        // If there is a reference time length, convert it into mtTime.
        // Because there's always the danger of a tempo change, we do this every
        // time. It doesn't require the tight precision that song time
        // requires, so that's okay.
        // ALSO: convert m_mtLength and re-adjust loop points. (RSW)
        m_pPerformance->ReferenceToMusicTime(m_rtEndTime, &m_mtEndTime);
        MUSIC_TIME mtOldLength = m_mtLength;
        m_mtLength = m_mtEndTime - m_mtOffset; 
        if (m_mtLoopEnd >= mtOldLength) // keep loop end equal to length
        {
            m_mtLoopEnd = m_mtLength;
        }
        if( m_mtLoopEnd > m_mtLength )
        {
            m_mtLoopEnd = m_mtLength;
            if( m_mtStartPoint >= m_mtLoopEnd )
            {
                // in this case, we're not doing any looping.
                m_mtLoopEnd = m_mtLoopStart = 0;
                m_dwRepeats = m_dwRepeatsLeft = 0;
            }
        }
        
        //m_mtEndTime += (m_mtLoopEnd - m_mtLoopStart) * m_dwRepeats;

        fUseClockTime = TRUE;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
//  ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - m_mtSeek;
        }
    }
    else 
    {
        if (fUseClockTime)
        {
            if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
            {
                mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
            }
        }
        else if( mtMyAmount > m_mtLength - m_mtSeek )
        {
            mtMyAmount = m_mtLength - m_mtSeek;
        }
    }
    if (mtMyAmount <= 0)
    {
        hr = DMUS_S_END;
    }
    else
    {
        // check the primary segment queue for a segment that might begin 
        // before mtMyAmount is up
        MUSIC_TIME mtNextPri;
        if (S_OK == m_pPerformance->GetPriSegTime( m_mtOffset + m_mtSeek, &mtNextPri ))
        {
            if( m_mtOffset + m_mtSeek + mtMyAmount > mtNextPri )
            {
                mtMyAmount = mtNextPri - m_mtOffset - m_mtSeek;
            }
        }
        TraceI(3, "SegState %ld Play from %ld to %ld at %ld = %ld - %ld\n", this, m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_mtSeek + m_mtOffset, m_mtSeek + mtMyAmount + m_mtOffset );
        
        // find out if there's a control segment interrupting this period of time.
        MUSIC_TIME mtControlSeg;
        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
        {
            if( m_mtOffset + m_mtSeek == mtControlSeg )
            {
                // we're at the beginning of a new control seg, so tell the tracks
                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY;
            }
            else if( m_mtOffset + m_mtSeek + mtMyAmount > mtControlSeg )
            {
                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
            }
        }
        // Now that mtMyAmount is calculated for how far to play in music time,
        // create the equivalent value in reference time.
        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
        rtMyAmount -= m_rtLastPlayed;
        pCTrack = m_TrackList.GetHead();
        while( pCTrack )
        {
            if( mtMyAmount )
            {
                m_pPerformance->m_fInTrackPlay = TRUE; // This causes the Pmsgs to be stamped with PRIV_FLAG_TRACK.
                ASSERT( pCTrack->m_pTrack );
                // If either notification or play are enabled, we need to call the play method and set the behavior
                // with the DMUS_TRACKF_NOTIFY_OFF and DMUS_TRACKF_PLAY_OFF flags. 
                if (pCTrack->m_dwFlags & (DMUS_TRACKCONFIG_PLAY_ENABLED | DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                {
                    DWORD dwAdditionalFlags = 0;
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_NOTIFICATION_ENABLED))
                    {
                        dwAdditionalFlags = DMUS_TRACKF_NOTIFY_OFF;
                    }
                    if (!(pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_ENABLED))
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_PLAY_OFF;
                    }
                    // If the track was authored to generate new data on start or loop, let it know.
                    if ( ((m_dwPlayTrackFlags & DMUS_TRACKF_START) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_COMPOSE)) ||
                        ((m_dwPlayTrackFlags & DMUS_TRACKF_LOOP) && (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_LOOP_COMPOSE)) )
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_RECOMPOSE;
                    }
                    if (pCTrack->m_dwInternalFlags & CONTROL_PLAY_REFRESH)
                    {
                        dwAdditionalFlags |= DMUS_TRACKF_START;
                        pCTrack->m_dwInternalFlags &= ~CONTROL_PLAY_REFRESH;
                    }
                    // Let performance know what the priority should be in ensuing GetParam() calls from the track.
                    m_pPerformance->m_dwGetParamFlags = pCTrack->m_dwFlags;
                    // If track has DX8 interface, use it.
                    if (pCTrack->m_pTrack8)
                    {
                        //  The track can call GetParam on the segment which locks the segment so
                        //  we have to lock the segment before calling PlayEx or we'll deadlock
                        //  with a thread that's calling PlayOneSegment which locks the segment
                        //  before playing the tracks.
                        if (m_pSegment) {
                            EnterCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                        // If track plays in clock time, set time variables appropriately.
                        if (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_rtSeek,m_rtSeek + rtMyAmount, m_rtOffset, m_dwPlayTrackFlags | dwAdditionalFlags | DMUS_TRACKF_CLOCK,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }
                        else
                        {
                            if( ( S_OK == (pCTrack->m_pTrack8->PlayEx(pCTrack->m_pTrackState,
                                m_mtSeek,m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                                m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                            {
                                hr = S_OK; // if even one track isn't done playing,
                                // keep going
                            }
                            else 
                            {
                                pCTrack->m_bDone = TRUE;
                            }
                        }

                        if (m_pSegment) {
                            LeaveCriticalSection(&m_pSegment->m_CriticalSection);
                        }
                    }
                    else
                    {
                        if( ( S_OK == ( pCTrack->m_pTrack->Play( pCTrack->m_pTrackState, 
                            m_mtSeek, m_mtSeek + mtMyAmount, m_mtOffset, m_dwPlayTrackFlags | dwAdditionalFlags,
                            m_pPerformance, this, pCTrack->m_dwVirtualID ))))
                        {
                            hr = S_OK; // if even one track isn't done playing,
                            // keep going
                        }
                        else
                        {
                            pCTrack->m_bDone = TRUE;
                        }
                    }
                }
                m_pPerformance->m_fInTrackPlay = FALSE;
            }
            pCTrack = pCTrack->GetNext();
            if( pCTrack == NULL )
            {
                // none of the play flags are persistent
                m_dwPlayTrackFlags = 0;
                m_mtLastPlayed += mtMyAmount;   // increment play pointer
                m_rtLastPlayed += rtMyAmount;   // same in ref time
                m_mtSeek += mtMyAmount;         // increment seek pointer
                m_rtSeek += rtMyAmount;
                hr = S_OK;

                // If we're looping....
                // And if this is the first repeat
                if(m_dwRepeats > 0 && m_dwRepeats == m_dwRepeatsLeft)
                {
                    // If we're playing the loop start remember it's reftime value
                    if(m_mtSeek >= m_mtLoopStart && m_rtFirstLoopStart == 0)
                    {
                        m_pPerformance->MusicToReferenceTime(m_mtLoopStart + m_mtOffset + m_mtStartPoint, &m_rtFirstLoopStart);
                        m_rtFirstLoopStart -= m_rtStartPoint;
                        m_rtCurLoopStart = m_rtFirstLoopStart;
                    }
                }

                // take into account repeats if necessary
                if( m_mtSeek >= m_mtLoopEnd )
                {
                    // Remember the current loop end
                    m_pPerformance->MusicToReferenceTime(m_mtLoopEnd + m_mtOffset + m_mtStartPoint, &m_rtCurLoopEnd);
                    m_rtCurLoopEnd -= m_rtStartPoint;

                    if(m_dwRepeatsLeft)
                    {
                        m_dwPlayTrackFlags |= DMUS_TRACKF_LOOP | DMUS_TRACKF_SEEK;
                        m_dwRepeatsLeft--;
                        pCTrack = m_TrackList.GetHead();
                        while( pCTrack )
                        {
                            pCTrack->m_bDone = FALSE;
                            pCTrack = pCTrack->GetNext();
                        }
                        
                        m_mtSeek = m_mtLoopStart;
                        m_mtOffset += ( m_mtLoopEnd - m_mtLoopStart);
                        
                        
                        m_rtOffset += (m_rtCurLoopEnd - m_rtCurLoopStart);
                        m_rtFirstLoopStart += (m_rtCurLoopEnd - m_rtCurLoopStart);
                        m_rtSeek = m_rtFirstLoopStart - m_rtOffset;

                        m_rtEndTime += (m_rtCurLoopEnd - m_rtCurLoopStart);
                   
                        m_rtCurLoopStart = m_rtCurLoopEnd;

                        if( mtMyAmount < mtAmount )
                        {
                            pCTrack = m_TrackList.GetHead(); // cause outer while loop to start over
                            mtMyAmount = mtAmount - mtMyAmount;
                            mtAmount = mtMyAmount;
                            // if we need to do a loop or the end is near, restrict mtMyAmount
                            if( m_dwRepeatsLeft )
                            {
                                if( mtMyAmount > m_mtLoopEnd - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLoopEnd - m_mtSeek;
                                }
                            }
                            else 
                            {
                                if (fUseClockTime)
                                {
                                    if (mtMyAmount > (m_mtEndTime - (m_mtOffset + m_mtSeek)))
                                    {
                                        mtMyAmount = m_mtEndTime - (m_mtOffset + m_mtSeek);
                                    }
                                }
                                else if( mtMyAmount > m_mtLength - m_mtSeek )
                                {
                                    mtMyAmount = m_mtLength - m_mtSeek;
                                }
                            }
                        }
                        // send a segment looped notification
                        GenerateNotification( DMUS_NOTIFICATION_SEGLOOP, m_mtOffset + m_mtSeek );
                        // find out if there's a control segment interrupting this period of time
                        if( S_OK == m_pPerformance->GetControlSegTime( m_mtOffset + m_mtSeek, &mtControlSeg ))
                        {
                            if( m_mtOffset + m_mtSeek == mtControlSeg ) 
                            {
                                // we're at the beginning of a new control seg, so tell the tracks
                                m_dwPlayTrackFlags |= DMUS_TRACKF_DIRTY; 
                            }
                            else if( m_mtOffset + m_mtSeek + mtMyAmount < mtControlSeg )
                            {
                                mtMyAmount = mtControlSeg - m_mtOffset - m_mtSeek;
                            }
                        }
                        m_pPerformance->MusicToReferenceTime(m_mtLastPlayed + mtMyAmount,&rtMyAmount);
                        rtMyAmount -= m_rtLastPlayed;
                    }
                    else if( m_mtSeek == m_mtLength )
                    {
                        // no more repeats.
                        hr = DMUS_S_END;
                    }
                }
            }
        }
    }
    if (hr == DMUS_S_END)
    {
        // send a segment end notification
        GenerateNotification( DMUS_NOTIFICATION_SEGEND, m_mtOffset + m_mtSeek );
        // also queue the almost ended for now
        MUSIC_TIME mtNow;
        m_pPerformance->GetTime( NULL, &mtNow );
        GenerateNotification( DMUS_NOTIFICATION_SEGALMOSTEND, mtNow );
        // if this is a primary or controlling segment, send a DMUS_PMSGT_DIRTY message
        if( !(m_dwPlaySegFlags & DMUS_SEGF_SECONDARY) || (m_dwPlaySegFlags & DMUS_SEGF_CONTROL) )
        {
            TraceI(4, "Send Dirty PMsg [2] %d (%d)\n", m_mtSeek, m_mtOffset + m_mtSeek);
            SendDirtyPMsg( m_mtOffset + m_mtSeek );
        }
        // If this is part of a song, we need to queue the next segment.
        if (m_fSongMode)
        {
            if (m_pSegment)
            {
                CSong *pSong = m_pSegment->m_pSong;
                if (pSong)
                {
                    // Get the next segment from the song.
                    CSegment *pSegment;
                    if (S_OK == pSong->GetPlaySegment(m_pSegment->m_dwNextPlayID,&pSegment))
                    {
                        // Now, play it.
                        // Unless DMUS_SEGF_USE_AUDIOPATH is set, play it on the same audiopath. 
                        // And, make sure that it plays at the same level (control, secondary, or primary.)
                        CSegState *pCSegState = NULL;
                        CAudioPath *pPath = m_pAudioPath;
                        CAudioPath *pInternalPath = NULL;
                        DWORD dwFlags = m_dwPlaySegFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY);
                        dwFlags &= ~DMUS_SEGF_REFTIME;
                        if (dwFlags & DMUS_SEGF_USE_AUDIOPATH)
                        {
                            IUnknown *pConfig;
                            if (SUCCEEDED(pSegment->GetAudioPathConfig(&pConfig)))
                            {
                                IDirectMusicAudioPath *pNewPath;
                                if (SUCCEEDED(m_pPerformance->CreateAudioPath(pConfig,TRUE,&pNewPath)))
                                {
                                    // Now, get the CAudioPath structure.
                                    pConfig->QueryInterface(IID_CAudioPath,(void **) &pInternalPath);
                                    pPath = pInternalPath;
                                }
                                pConfig->Release();
                            }
                        }
                        if (SUCCEEDED(m_pPerformance->PlayOneSegment((CSegment *)pSegment,dwFlags,m_mtEndTime,&pCSegState,pPath)))
                        {
                            if (m_pSongSegState)
                            {
                                // This is not the first, so transfer the segstate pointer.
                                pCSegState->m_pSongSegState = m_pSongSegState;
                                m_pSongSegState = NULL;
                            }
                            else
                            {
                                // This is the first, so have the next segstate point to this.
                                pCSegState->m_pSongSegState = this;
                                AddRef();
                            }
                            pCSegState->m_fSongMode = TRUE;
                            pCSegState->Release();
                        }
                        if (pInternalPath)
                        {
                            pInternalPath->Release();
                        }
                        pSegment->Release();
                    }
                }
            }
        }
    }
    m_dwPlayTrackFlags &= ~DMUS_TRACKF_DIRTY;
    m_pPerformance->m_dwGetParamFlags = 0;
    m_pPerformance->m_pGetParamSegmentState = NULL;
    m_fInPlay = false;
    if (m_fDelayShutDown)
    {
        Shutdown();
        m_fDelayShutDown = false;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

CTrack * CSegState::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) && 
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
        {
            if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

/* GetParam() is called by the performance in response to a GetParam() call
   on the performance. This needs the performance pointer so it can handle
   clock time to music time conversion and back, in case the source track is a
   clock time track.
*/

HRESULT CSegState::GetParam(
    CPerformance *pPerf,
    REFGUID rguidType,
    DWORD dwGroupBits,      
    DWORD dwIndex,          
    MUSIC_TIME mtTime,      
    MUSIC_TIME* pmtNext,    
    void* pParam)           
{
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        // Even though DX7 didn't support this, this is always safe because an index this high could never happen.
        fMultipleTry = TRUE; 
    }
    CTrack * pTrack = GetTrackByParam( NULL, rguidType, dwGroupBits, dwIndex);
    while (pTrack)
    {
        if (pTrack->m_pTrack8)
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_PLAY_CLOCKTIME)
            {
                REFERENCE_TIME rtTime, rtNext;
                // Convert mtTime into reference time units:
                pPerf->MusicToReferenceTime(m_mtOffset + mtTime,&rtTime);
                rtTime -= m_rtOffset;
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, rtTime, &rtNext, 
                    pParam, pTrack->m_pTrackState, DMUS_TRACK_PARAMF_CLOCK );
                if (pmtNext)
                {
                    if (rtNext == 0) *pmtNext = 0;
                    else
                    {
                        rtNext += m_rtOffset;
                        pPerf->ReferenceToMusicTime(rtNext,pmtNext);
                        *pmtNext -= m_mtOffset;
                    }
                }
            }
            else
            {
                REFERENCE_TIME rtNext, *prtNext;
                // We need to store the next time in a 64 bit pointer. But, don't
                // make 'em fill it in unless the caller requested it. 
                if (pmtNext)
                {
                    prtNext = &rtNext;
                }
                else
                {
                    prtNext = NULL;
                }
                hr = pTrack->m_pTrack8->GetParamEx( rguidType, mtTime, prtNext, pParam,
                    pTrack->m_pTrackState, 0 );
                if (pmtNext)
                {
                    *pmtNext = (MUSIC_TIME) rtNext;
                }
            }
        }
        else
        {
            // This is a pre DX8 track...
            hr = pTrack->m_pTrack->GetParam( rguidType, mtTime, pmtNext, pParam );
        }
        if (SUCCEEDED(hr))
        {
            if( pmtNext )
            { 
                if(( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime)))
                {
                    // If no next was found OR it's greater than the end of the segment, set 
                    // it to the end of the segment. 
                    *pmtNext = m_mtLength - mtTime;
                }
            }
            pTrack = NULL;
        }
        // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
        else if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
        {
            pTrack = GetTrackByParam( pTrack, rguidType, dwGroupBits, 0);
        }
        else
        {
            pTrack = NULL;
        }
    }
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(4,"Warning: Segmentstate::GetParam failed, unable to find a track that supports the requested param.\n");
    }
#endif
    return hr;
}


CTrack *CSegState::GetTrack( 
    REFCLSID rType,     
    DWORD dwGroupBits,  
    DWORD dwIndex)
{
    CTrack* pCTrack;
    pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( pCTrack->m_dwGroupBits & dwGroupBits )
        {
            if( (GUID_All_Objects == rType) || (pCTrack->m_guidClassID == rType))
            {
                if( 0 == dwIndex )
                {
                    break;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return pCTrack;
}

STDMETHODIMP CSegState::SetTrackConfig(REFGUID rguidTrackClassID,
                                      DWORD dwGroup, DWORD dwIndex, 
                                      DWORD dwFlagsOn, DWORD dwFlagsOff) 
{
    V_INAME(IDirectMusicSegment::SetTrackConfig);
    V_REFGUID(rguidTrackClassID);
    if (rguidTrackClassID == GUID_NULL)
    {
        return E_INVALIDARG;
    }
    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
    CTrack* pCTrack;
    DWORD dwCounter = dwIndex;
    DWORD dwMax = dwIndex;
    if (dwIndex == DMUS_SEG_ALLTRACKS)
    {
        dwCounter = 0;
        dwMax = DMUS_SEG_ALLTRACKS;
    }
    EnterCriticalSection(&m_CriticalSection);
    while (pCTrack = GetTrack(rguidTrackClassID,dwGroup,dwIndex))
    {
        pCTrack->m_dwFlags &= ~dwFlagsOff;
        pCTrack->m_dwFlags |= dwFlagsOn;
        hr = S_OK;
        dwCounter++;
        if (dwCounter > dwMax) break;
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_TRACK_NOT_FOUND)
    {
        Trace(1,"Error: Segmentstate::SetTrackConfig failed, unable to find the requested track.\n");
    }
#endif
    return hr;
}

HRESULT CSegState::CheckPlay( 
    MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult )
{
    MUSIC_TIME mtMyAmount = mtAmount;
    MUSIC_TIME mtSeek = m_mtSeek;
    MUSIC_TIME mtOffset = m_mtOffset;

    ASSERT(pmtResult);
    // if this is the first call to play,
    // We also need to check to see if we are supposed to start at the beginning,
    // or at an offset.
    if( m_dwPlayTrackFlags & DMUS_TRACKF_START )
    {
        // set the current seek to the start point
        mtSeek = m_mtStartPoint;
    }
    // if we need to do a loop or the end is near, restrict mtMyAmount
    ASSERT( m_mtLength ); // length is 0, this segment won't do anything
    if( m_dwRepeatsLeft )
    {
        if( mtMyAmount > m_mtLoopEnd - mtSeek )
        {
            mtMyAmount = m_mtLoopEnd - mtSeek;
        }
    }
    else if( mtMyAmount > m_mtLength - mtSeek )
    {
        mtMyAmount = m_mtLength - mtSeek;
    }
    
    // take into account repeats if necessary
    *pmtResult = mtMyAmount;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartTime
/*
@method HRESULT | IDirectMusicSegmentState | GetStartTime |
Gets the music time this SegmentState started playing.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartTime( 
    MUSIC_TIME *pmtStart)   // @parm Returns the music time of the start of this SegmentState.
                            // This is the music time, in Performance time, that the SegmentState
                            // started or will start playing.
{
    V_INAME(IDirectMusicSegmentState::GetStartTime);
    V_PTR_WRITE(pmtStart,MUSIC_TIME);

    *pmtStart = m_mtResolvedStart;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetStartPoint
/*
@method HRESULT | IDirectMusicSegmentState | GetStartPoint |
Calling <om IDirectMusicSegment.SetStartPoint> causes the SegmentState to begin
playing from the middle instead of from the beginning. <om .GetStartPoint>
returns the amount of time from the beginning of the SegmentState that it
plays.

@rvalue E_POINTER | <p pmtStart> is NULL or invalid.
@rvalue S_OK | Success.

@xref <om IDirectMusicSegment.SetStartPoint>,
<om IDirectMusicPerformance.PlaySegment>
*/
HRESULT STDMETHODCALLTYPE CSegState::GetStartPoint( 
    MUSIC_TIME *pmtStart)   // @parm Returns the music time offset from the start of the
                            // SegmentState at which the SegmentState initially plays.
{
    V_INAME(IDirectMusicSegmentState::GetStartPoint);
    V_PTR_WRITE(pmtStart,MUSIC_TIME);

    *pmtStart = m_mtStartPoint;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::SetSeek
/*
method (INTERNAL) HRESULT | IDirectMusicSegmentState | SetSeek |
Sets the music time Seek maintained by this SegmentState.

parm MUSIC_TIME | mtSeek |
    [in] The music time Seek to store in this SegmentState.

comm The SegmentState passes this Seek value to <im IDirectMusicTrack.Play>
Note that newly created SegmentState's start with a Seek time of 0.
rvalue S_OK | Success.
*/
HRESULT CSegState::SetSeek( 
    MUSIC_TIME mtSeek, DWORD dwPlayFlags)
{
    m_mtSeek = mtSeek;
    m_dwPlayTrackFlags |= dwPlayFlags | DMUS_TRACKF_SEEK;
    return S_OK;
}

/*
Called from IDirectMusicPerformance::Invalidate, this routine helps set
the current seek pointer. Done here instead of directly inside Performance
because it's easier to compute the repeats, etc. here.
*/
HRESULT CSegState::SetInvalidate(
    MUSIC_TIME mtTime) // mtTime is in Performance time
{
    MUSIC_TIME mtOffset;
    DWORD dwRepeat;
    DWORD dwFlags = DMUS_TRACKF_FLUSH | DMUS_TRACKF_SEEK;

    HRESULT hr = ConvertToSegTime( &mtTime, &mtOffset, &dwRepeat );
    if( hr != S_OK )
    {
        mtTime = 0;
        m_dwRepeatsLeft = m_dwRepeats;
        m_mtOffset = m_mtResolvedStart;
        dwFlags |= DMUS_TRACKF_START;
    }
    else
    {
        m_dwRepeatsLeft = m_dwRepeats - dwRepeat;
        m_mtOffset = mtOffset;
    }
    EnterCriticalSection(&m_CriticalSection);
    CTrack* pCTrack = m_TrackList.GetHead();
    while( pCTrack )
    {
        pCTrack->m_bDone = FALSE;
        pCTrack = pCTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return SetSeek( mtTime, dwFlags );
}

///////////////////////////////////////////////////////////////////////
// IDirectMusicSegmentState::GetSeek

HRESULT STDMETHODCALLTYPE CSegState::GetSeek( 
    MUSIC_TIME *pmtSeek) // @parm Returns the current seek pointer, which indicates
                        // the next time that will be called inside <om IDirectMusicTrack.Play>.
{
    V_INAME(IDirectMusicSegmentState::GetSeek);
    V_PTR_WRITE(pmtSeek, MUSIC_TIME);

    *pmtSeek = m_mtSeek;
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Flush(MUSIC_TIME mtTime) // The time on and after which to flush.
{
    CTrack* pTrack;
    EnterCriticalSection(&m_CriticalSection);
    pTrack = m_TrackList.GetHead();
    while( pTrack )
    {
        m_pPerformance->FlushVirtualTrack( pTrack->m_dwVirtualID, mtTime, FALSE );
        pTrack = pTrack->GetNext();
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CSegState::Shutdown()
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::InsertTool( 
    IDirectMusicTool *pTool,
    DWORD *pdwPChannels,
    DWORD cPChannels,
    LONG lIndex)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::GetTool(
    DWORD dwIndex,
    IDirectMusicTool** ppTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::RemoveTool(
    IDirectMusicTool* pTool)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSegState::StampPMsg( 
    /* [in */ DMUS_PMSG* pPMsg)
{
    V_INAME(IDirectMusicSegmentState::StampPMsg);
    if( m_dwVersion < 8)
    {
        V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
    }
    else
    {
#ifdef DBG
        V_BUFPTR_WRITE(pPMsg,sizeof(DMUS_PMSG));
#else
        if (!pPMsg)
        {
            return E_POINTER;
        }
#endif
    }
    HRESULT hr = E_FAIL;
    EnterCriticalSection(&m_CriticalSection);

    if (m_pPerformance) 

    {
        // First, check if the segmentstate has its own graph.
        if (m_pGraph)
        {
            // Could return DMUS_S_LAST_TOOL, indicating end of graph. 
            // If so, we'll treat that as a failure and drop on through to the next graph...
            if( S_OK == ( hr = m_pGraph->StampPMsg( pPMsg )))
            {
                if( pPMsg->pGraph != this ) // Make sure this is set to point to the segstate embedded graph so it will come here again.
                {
                    if( pPMsg->pGraph )
                    {
                        pPMsg->pGraph->Release();
                        pPMsg->pGraph = NULL;
                    }
                    pPMsg->pGraph = this;
                    AddRef();
                }
            }
        }
        // If done with the graph, send to the audio path, if it exists,
        // else the performance. Also, check for the special case of 
        // DMUS_PCHANNEL_BROADCAST_SEGMENT. If so, duplicate the pMsg
        // and send all the copies with the appropriate pchannel values.
        if( FAILED(hr) || (m_dwVersion && (hr == DMUS_S_LAST_TOOL)))
        {
            if (pPMsg->dwPChannel == DMUS_PCHANNEL_BROADCAST_SEGMENT)
            {
                CSegment *pSegment = m_pSegment;
                EnterCriticalSection(&pSegment->m_CriticalSection);
                DWORD dwIndex;
                // Create new messages with new pchannels for all but one, which will
                // be assigned to this message.
                for (dwIndex = 1;dwIndex < pSegment->m_dwNumPChannels;dwIndex++)
                {
                    DWORD dwNewChannel = pSegment->m_paPChannels[dwIndex];
                    // Don't broadcast any broadcast messages!
                    // And, if this is a transpose on the drum channel, don't send it.
                    if ((dwNewChannel < DMUS_PCHANNEL_BROADCAST_GROUPS) &&
                        ((pPMsg->dwType != DMUS_PMSGT_TRANSPOSE) || ((dwNewChannel & 0xF) != 9)))
                    {
                        DMUS_PMSG *pNewMsg;
                        if (SUCCEEDED(m_pPerformance->ClonePMsg(pPMsg,&pNewMsg)))
                        {
                            HRESULT hrTemp;
                            pNewMsg->dwPChannel = dwNewChannel;
                            if (m_pAudioPath)
                            {
                                hrTemp = m_pAudioPath->StampPMsg(pNewMsg);
                            }
                            else
                            {
                                hrTemp = m_pPerformance->StampPMsg(pNewMsg);
                            }
                            if (SUCCEEDED(hrTemp))
                            {
                                m_pPerformance->SendPMsg(pNewMsg);
                            }
                            else
                            {
                                m_pPerformance->FreePMsg(pNewMsg);
                            }
                        }
                    }
                }
                // Now, set the pchannel for this one. First check that there are any
                // pchannels. If none, mark the PMsg to be deleted by the SendPMsg routine.
                // Also, mark it this way if the PMsg is a broadcast PMsg.
                pPMsg->dwPChannel = DMUS_PCHANNEL_KILL_ME;
                if (pSegment->m_dwNumPChannels)
                {
                    if (pSegment->m_paPChannels[0] < DMUS_PCHANNEL_BROADCAST_GROUPS)
                    {
                        pPMsg->dwPChannel = pSegment->m_paPChannels[0];
                    }
                }
                LeaveCriticalSection(&pSegment->m_CriticalSection);
            }
            if (m_pAudioPath)
            {
                hr = m_pAudioPath->StampPMsg(pPMsg);
            }
            else
            {
                hr = m_pPerformance->StampPMsg(pPMsg);
            }
        }

    }
    else
    {
        hr = DMUS_E_NOT_INIT;
        Trace(1,"Error: Segmentstate::StampPMsg failed because the segmentstate is not properly initialized.\n");
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}


STDMETHODIMP CSegState::GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject)
{
    V_INAME(IDirectMusicSegmentState::GetObjectInPath);
    V_PTRPTR_WRITE(ppObject);
    *ppObject = NULL;
    if (dwBuffer && ((dwStage < DMUS_PATH_BUFFER) || (dwStage >= DMUS_PATH_PRIMARY_BUFFER)))
    {
        return DMUS_E_NOT_FOUND;
    }
    HRESULT hr = DMUS_E_NOT_FOUND;
    EnterCriticalSection(&m_CriticalSection);
    switch (dwStage)
    {
    case DMUS_PATH_SEGMENT:
        if (m_pSegment && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pSegment->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_SEGMENT_TRACK:
        if (dwPChannel == 0)
        {
            CTrack * pCTrack = GetTrack(guidObject,-1,dwIndex);
            if (pCTrack)
            {
                if (pCTrack->m_pTrack)
                {
                    hr = pCTrack->m_pTrack->QueryInterface(iidInterface,ppObject);
                }
            }
        }
        break;
    case DMUS_PATH_SEGMENT_GRAPH:
        if ((dwIndex == 0) && (dwPChannel == 0))
        {
            if (!m_pGraph)
            {
                m_pGraph = new CGraph;
            }
            if (m_pGraph)
            {
                hr = m_pGraph->QueryInterface(iidInterface,ppObject);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
    case DMUS_PATH_SEGMENT_TOOL:
        if (!m_pGraph)
        {
            m_pGraph = new CGraph;
        }
        if (m_pGraph)
        {
            hr = m_pGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        break;
    case DMUS_PATH_PERFORMANCE:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            hr = m_pPerformance->QueryInterface(iidInterface,ppObject);
        }
        break;
    case DMUS_PATH_PERFORMANCE_GRAPH:
        if (m_pPerformance && (dwIndex == 0) && (dwPChannel == 0))
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                hr = pGraph->QueryInterface(iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    case DMUS_PATH_PERFORMANCE_TOOL:
        if (m_pPerformance)
        {
            IDirectMusicGraph *pGraph;
            if (SUCCEEDED(hr = m_pPerformance->GetGraphInternal(&pGraph)))
            {
                CGraph *pCGraph = (CGraph *) pGraph;
                hr = pCGraph->GetObjectInPath(dwPChannel,guidObject,dwIndex,iidInterface,ppObject);
                pGraph->Release();
            }
        }
        break;
    default:
        if (m_pAudioPath)
        {
            hr = m_pAudioPath->GetObjectInPath(dwPChannel,dwStage,dwBuffer,guidObject,dwIndex,iidInterface,ppObject);
        }
        else
        {
            Trace(1,"Error: Unable to access audiopath components of segmentstate.\n");
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\lyrictrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricTrack.
//

// This track type holds events that send DMUS_LYRIC_PMSG notifications at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct LyricInfo
{
	LyricInfo() : dwFlags(0), dwTimingFlags(0), lTriggerTime(0), lTimePhysical(0) {}

	HRESULT Clone(const LyricInfo &o, MUSIC_TIME mtStart)
	{
		*this = o;
		lTriggerTime -= mtStart;
		lTimePhysical -= mtStart;
		return S_OK;
	}

	DWORD dwFlags;
	DWORD dwTimingFlags;
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	SmartRef::WString wstrText;
};

//////////////////////////////////////////////////////////////////////
// CLyricsTrack

class CLyricsTrack;
typedef CPlayingTrack<CLyricsTrack, LyricInfo> CLyricsTrackBase;

class CLyricsTrack
  : public CLyricsTrackBase
{
public:
	// When the lyric track plays one of its items, it sends a Lyric PMsg through its segment state.  If an invalidation occurs,
	// the PMsg is retracted by the performance.  Then the track is played again (with the FLUSH bit set).  The last pameter to
	// the CSegTriggerTrackBase is true, which instructs it to play the item a second time--to replace the retracted lyric.
	CLyricsTrack(HRESULT *pHr) : CLyricsTrackBase(&g_cComponent, CLSID_DirectMusicLyricsTrack, false, true) {}

protected:
	HRESULT PlayItem(
		const LyricInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadLyric(SmartRef::RiffIter ri);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmsstobj.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSStObj.h : Declaration of the CSegState

#ifndef __DIRECTMUSICSEGMENTSTATEOBJECT_H_
#define __DIRECTMUSICSEGMENTSTATEOBJECT_H_

#include "dmusici.h"
#include "TrkList.h"
#include "alist.h"
#include "audpath.h"

class CPerformance;
class CSegState;
class CGraph;

// Control flags, placed in track->m_dwInternalFlags by ManageControllingTracks().

#define CONTROL_PLAY_IS_DISABLED       0x1   // Indicates the track is already disabled.
#define CONTROL_PLAY_WAS_DISABLED      0x2   // Indicates the track was previously disabled.
#define CONTROL_PLAY_REFRESH           0x4   // Indicates it has been reenabled and needs to be refreshed.
#define CONTROL_PLAY_DEFAULT_DISABLED  0x8   // Indicates it was disabled for playback anyway.
#define CONTROL_PLAY_DEFAULT_ENABLED   0x10  // Indicates it was enabled for playback.

#define CONTROL_NTFY_IS_DISABLED       0x20  // Indicates the track is already disabled for notifications.
#define CONTROL_NTFY_DEFAULT_DISABLED  0x40  // Indicates it was disabled for notifications anyway.
#define CONTROL_NTFY_DEFAULT_ENABLED   0x80  // Indicates it was enabled for notifications.

DEFINE_GUID(IID_CSegState,0xb06c0c26, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);

/////////////////////////////////////////////////////////////////////////////
// CSegState
class CSegState : 
	public IDirectMusicSegmentState8,
	public IDirectMusicGraph,
    public AListItem
{
friend class CSegment;
friend class CAudioPath;
friend class CPerformance;
public:
	CSegState();
	~CSegState();

// IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    // IDirectMusicSegmentState
    STDMETHODIMP GetRepeats(DWORD *pdwRepeats);
	STDMETHODIMP GetSegment(IDirectMusicSegment **ppSegment);
    STDMETHODIMP GetStartTime(MUSIC_TIME __RPC_FAR *);
	STDMETHODIMP Play(MUSIC_TIME mtAmount,MUSIC_TIME *pmtPlayed); // No longer supported.
    STDMETHODIMP GetSeek(MUSIC_TIME *pmtSeek);
	STDMETHODIMP GetStartPoint(MUSIC_TIME *pmtStart);
	STDMETHODIMP Flush(MUSIC_TIME mtTime);
    // IDirectMusicSegmentState8 
    STDMETHODIMP SetTrackConfig( REFGUID rguidTrackClassID,DWORD dwGroup, DWORD dwIndex, DWORD dwFlagsOn, DWORD dwFlagsOff) ;
    STDMETHODIMP GetObjectInPath( DWORD dwPChannel,DWORD dwStage,DWORD dwBuffer, REFGUID guidObject,
                    DWORD dwIndex,REFGUID iidInterface, void ** ppObject);

    // IDirectMusicGraph
	STDMETHODIMP Shutdown();
    STDMETHODIMP InsertTool(IDirectMusicTool *pTool,DWORD *pdwPChannels,DWORD cPChannels,LONG lIndex);
    STDMETHODIMP GetTool(DWORD,IDirectMusicTool**);
    STDMETHODIMP RemoveTool(IDirectMusicTool*);
    STDMETHODIMP StampPMsg(DMUS_PMSG* pEvent);

    // Methods used by performance to access SegmentState.
	HRESULT PrivateInit(CSegment *pParentSegment,CPerformance *pPerformance);
    HRESULT InitRoute(IDirectMusicAudioPath *pAudioPath);
    HRESULT ShutDown(void); // called from ~SEGSTNODE in dmperf.h
	HRESULT GetTrackList(void** ppTrackList);
    HRESULT SetSeek(MUSIC_TIME mtSeek,DWORD dwPlayFlags);
    HRESULT SetInvalidate(MUSIC_TIME mtTime);
	MUSIC_TIME GetEndTime(MUSIC_TIME mtStartTime);
	HRESULT ConvertToSegTime(MUSIC_TIME* pmtTime, MUSIC_TIME* pmtOffset, DWORD* pdwRepeat);
	HRESULT AbortPlay( MUSIC_TIME mtTime, BOOL fLeaveNotesOn ); // called when the segstate is stopped prematurely
	HRESULT CheckPlay( MUSIC_TIME mtAmount, MUSIC_TIME* pmtResult );
    HRESULT Play(MUSIC_TIME mtAmount);  
    HRESULT GetParam( CPerformance *pPerf,REFGUID rguidType,DWORD dwGroupBits,
        DWORD dwIndex,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void* pParam);	

    CSegState* GetNext() { return (CSegState*)AListItem::GetNext();}
private:
    CTrack *GetTrackByParam(CTrack * pCTrack,REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
    CTrack *GetTrack(REFCLSID rType,DWORD dwGroupBits,DWORD dwIndex);
	void GenerateNotification( DWORD dwNotification, MUSIC_TIME mtTime );
	void SendDirtyPMsg( MUSIC_TIME mtTime );
public:
// Attributes
    CRITICAL_SECTION            m_CriticalSection;
	IUnknown*					m_pUnkDispatch; // holds the controlling unknown of the scripting object that implements IDispatch
	CPerformance*	            m_pPerformance;
	CSegment*		            m_pSegment;     // Holds the parent segment pointer, weak reference, for convenience
    CAudioPath*                 m_pAudioPath;   // Maps vchannels to pchannels, if requested.
    CGraph*                     m_pGraph;       // Temp graph is a copy of the segment's graph.
    CTrackList	                m_TrackList;	// list of Tracks held in this SegmentState
    MUSIC_TIME					m_mtLoopStart;  // Loop start point.
	MUSIC_TIME					m_mtLoopEnd;    // Loop end point.
	DWORD						m_dwRepeats;    // The original repeat setting (before countdown)
	MUSIC_TIME					m_mtLength;     // Length of segment.
	DWORD						m_dwPlayTrackFlags;// Track playback controlflags.
    DWORD						m_dwPlaySegFlags;// Segment playback control flags.
    DWORD                       m_dwSegFlags;   // New Segment Flags from file.
    MUSIC_TIME					m_mtResolvedStart;// Start time resolved to desired resolution
	MUSIC_TIME					m_mtEndTime;    // End time that the segment should play to if not stopped. 
	MUSIC_TIME					m_mtOffset;     // Start time of the segment in absolute time, as if it were started from the beginning. 
    MUSIC_TIME					m_mtLastPlayed; // the last played absolute time
	MUSIC_TIME					m_mtStopTime;     // Used to stop play at a specific time. Ignored when 0.
	MUSIC_TIME					m_mtSeek;       // How far into the segment we are.
	MUSIC_TIME					m_mtStartPoint; // Point in the segment where playback started
    MUSIC_TIME                  m_mtAbortTime;  // Time a sudden stop occured.
	REFERENCE_TIME				m_rtGivenStart; // Start time given in PlaySegment, unquantized
    REFERENCE_TIME              m_rtLastPlayed; // Clock time version of the last played absolute time
	REFERENCE_TIME				m_rtStartPoint; // Clock time version of point in the segment where playback started
	REFERENCE_TIME				m_rtOffset;     // Clock time version of start time of the segment in absolute time, as if it were started from the beginning. 
    REFERENCE_TIME              m_rtEndTime;    // Clock time version of full length.
    REFERENCE_TIME				m_rtSeek;       // Clock time version of how far into the segment we are.
    REFERENCE_TIME              m_rtLength;     // Clock time length, read from file. If 0, ignore.
    REFERENCE_TIME              m_rtFirstLoopStart; // The clock time for the loop start when it starts looping the VERY FIRST time 
    REFERENCE_TIME              m_rtCurLoopStart;// The clock time for the loop start for the current loop repetition
    REFERENCE_TIME              m_rtCurLoopEnd; // The clock time for the loop end in the current loop repetition
    DWORD						m_dwRepeatsLeft;// Current repeats left.
	BOOL						m_fStartedPlay; // indicates if the segstate has started to play yet
    DWORD                       m_dwVersion;    // Which release does the app think it is using - 6, 7, or 8..
    DWORD                       m_dwFirstTrackID;// Virtual ID of first track in segstate.
    DWORD                       m_dwLastTrackID;// Last track's virtual id.
    BOOL                        m_fPrepped;     // Used to track whether PrepSegToPlay has been called.
    BOOL                        m_fSongMode;    // True if part of a playing song. If so, this should queue the next segment when done.
	BOOL						m_fCanStop;		// If false, Stop() should ignore this segment (it was just queued to play by PlaySegmentEx().)
    BOOL                        m_fInPlay;      // Segmentstate is currently playing.   
    BOOL                        m_fDelayShutDown;
    CSegState *                 m_pSongSegState;// Used to track the starting segstate in a song.
    long						m_cRef;         // COM reference counter.
};

class CSegStateList : public AList
{
public:
    void AddHead(CSegState* pSegState) { AList::AddHead((AListItem*)pSegState);}
    void Insert(CSegState* pSegState);
    CSegState* GetHead(){return (CSegState*)AList::GetHead();}
    CSegState* GetItem(LONG lIndex){return (CSegState*)AList::GetItem(lIndex);}
    CSegState* RemoveHead() {return (CSegState *) AList::RemoveHead();}
    void Remove(CSegState* pSegState){AList::Remove((AListItem*)pSegState);}
    void AddTail(CSegState* pSegState){AList::AddTail((AListItem*)pSegState);}
    CSegState* GetTail(){ return (CSegState*)AList::GetTail();}
    void SetID(DWORD dwID) { m_dwID = dwID; }
    DWORD GetID() { return m_dwID; }
private:
    DWORD       m_dwID;         // Identifies which segstate list this is.
};

#endif //__DIRECTMUSICSEGMENTSTATEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\lyrictrk.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Declaration of CLyricsTrack.
//

#include "dmime.h"
#include "lyrictrk.h"
#include "..\shared\Validate.h"
#include "dmperf.h"
#include "miscutil.h"

//////////////////////////////////////////////////////////////////////
// Load

HRESULT
CLyricsTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
    struct LocalFunction
    {
        // Helper used by the LoadRiff function when we expected to find something
        // but a RiffIter becomes false.  In this case, if it has a success HR
        // indicating there were no more items then we return DMUS_E_INVALID_LYRICSTRACK
        // because the stream didn't contain the data we expected.  If it has a
        // failure hr, it was unable to read from the stream and we return its HR.
        static HRESULT HrFailOK(const SmartRef::RiffIter &ri)
        {
            HRESULT hr = ri.hr();
            return SUCCEEDED(hr) ? DMUS_E_INVALID_LYRICSTRACK : hr;
        }
    };

    // find <lyrt>
    if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACK_LIST))
    {
#ifdef DBG
        if (SUCCEEDED(ri.hr()))
        {
            Trace(1, "Error: Unable to load lyric track: List 'lyrt' not found.\n");
        }
#endif
        return LocalFunction::HrFailOK(ri);
    }

    // find <lyrl>
    SmartRef::RiffIter riTrackForm = ri.Descend();
    if (!riTrackForm)
        return riTrackForm.hr();
    if (!riTrackForm.Find(SmartRef::RiffIter::List, DMUS_FOURCC_LYRICSTRACKEVENTS_LIST))
    {
#ifdef DBG
        if (SUCCEEDED(riTrackForm.hr()))
        {
            Trace(1, "Error: Unable to load lyric track: List 'lyrl' not found.\n");
        }
#endif
        return LocalFunction::HrFailOK(riTrackForm);
    }

    // process each event <lyre>
    SmartRef::RiffIter riEvent = riTrackForm.Descend();
    if (!riEvent)
        return riEvent.hr();

    for ( ; riEvent; ++riEvent)
    {
        if (riEvent.type() == SmartRef::RiffIter::List && riEvent.id() == DMUS_FOURCC_LYRICSTRACKEVENT_LIST)
        {
            HRESULT hr = this->LoadLyric(riEvent.Descend());
            if (FAILED(hr))
                return hr;
        }
    }
    return riEvent.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CLyricsTrack::PlayItem(
        const LyricInfo &item,
        statedata &state,
        IDirectMusicPerformance *pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        bool fClockTime)
{
    // get the graph from the segment state
    IDirectMusicGraph *pGraph = NULL;
    HRESULT hrG = pSegSt->QueryInterface(IID_IDirectMusicGraph, reinterpret_cast<void**>(&pGraph));
    if (FAILED(hrG))
        return hrG;

    SmartRef::PMsg<DMUS_LYRIC_PMSG> pmsg(pPerf, 2 * wcslen(item.wstrText));
    if (FAILED(pmsg.hr())) {
        pGraph->Release();
        return pmsg.hr();
    }

    assert(((char*)&pmsg.p->wszString[wcslen(item.wstrText)]) + 1 < (((char*)(pmsg.p)) + pmsg.p->dwSize)); // just to make sure we haven't miscalculated.  the last byte of the null of the string should fall before the byte just beyond the extent of the struct (and it could be several bytes before if the DMUS_LYRIC_PMSG struct ended up being padded to come out to an even multiple of bytes.
    wcscpy(pmsg.p->wszString, item.wstrText);
    if (fClockTime)
    {
        pmsg.p->rtTime = item.lTimePhysical * gc_RefPerMil + rtOffset;
        pmsg.p->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | item.dwTimingFlags;
    }
    else
    {
        pmsg.p->mtTime = item.lTimePhysical + mtOffset;
        pmsg.p->dwFlags = DMUS_PMSGF_MUSICTIME | item.dwTimingFlags;
    }
    pmsg.p->dwVirtualTrackID = dwVirtualID;
    pmsg.p->dwType = DMUS_PMSGT_LYRIC;
    pmsg.p->dwGroupID = 0xffffffff;

    pmsg.StampAndSend(pGraph);
    pGraph->Release();

    return pmsg.hr();
}

HRESULT
CLyricsTrack::LoadLyric(SmartRef::RiffIter ri)
{
    HRESULT hr = S_OK;

    if (!ri)
        return ri.hr();

    // Create an event
    TListItem<LyricInfo> *pItem = new TListItem<LyricInfo>;
    if (!pItem)
        return E_OUTOFMEMORY;
    LyricInfo &rinfo = pItem->GetItemValue();

    bool fFoundEventHeader = false;

    for ( ; ri; ++ri)
    {
        if (ri.type() != SmartRef::RiffIter::Chunk)
            continue;

        switch(ri.id())
        {
            case DMUS_FOURCC_LYRICSTRACKEVENTHEADER_CHUNK:
                // Read an event chunk
                DMUS_IO_LYRICSTRACK_EVENTHEADER ioItem;
                hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
                if (FAILED(hr))
                {
                    delete pItem;
                    return hr;
                }

                // Don't allow ref/music timing flags because these are controlled by whether
                // the overall track is playing music or clock time and can't be set in individual
                // events.  Similarly, the tool flush flag isn't appropriate for an event to be played.
                if (ioItem.dwTimingFlags & (DMUS_PMSGF_REFTIME | DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_FLUSH | DMUS_PMSGF_LOCKTOREFTIME))
                {
                    Trace(1, "Error: Unable to load lyric track: DMUS_PMSGF_REFTIME, DMUS_PMSGF_MUSICTIME, DMUS_PMSGF_TOOL_FLUSH, and DMUS_PMSGF_LOCKTOREFTIME are not allowed as dwTimingFlags in chunk 'lyrh'.\n");
                    delete pItem;
                    return DMUS_E_INVALID_LYRICSTRACK;
                }

                fFoundEventHeader = true;
                rinfo.dwFlags = ioItem.dwFlags;
                rinfo.dwTimingFlags = ioItem.dwTimingFlags;
                rinfo.lTriggerTime = ioItem.lTimeLogical;
                rinfo.lTimePhysical = ioItem.lTimePhysical;
                break;

            case DMUS_FOURCC_LYRICSTRACKEVENTTEXT_CHUNK:
                {
                    hr = ri.ReadText(&rinfo.wstrText);
                    if (FAILED(hr))
                    {
#ifdef DBG
                        if (hr == E_FAIL)
                        {
                            Trace(1, "Error: Unable to load lyric track: Problem reading 'lyrn' chunk.\n");
                        }
#endif
                        delete pItem;
                        return hr == E_FAIL ? DMUS_E_INVALID_LYRICSTRACK : hr;
                    }
                }
                break;

            default:
                break;
        }
    }
    hr = ri.hr();

    if (SUCCEEDED(hr) && (!fFoundEventHeader || !rinfo.wstrText))
    {
#ifdef DBG
        if (!fFoundEventHeader)
        {
            Trace(1, "Error: Unable to load lyric track: Chunk 'lyrh' not found.\n");
        }
        else
        {
            Trace(1, "Error: Unable to load lyric track: Chunk 'lyrn' not found.\n");
        }
#endif
        hr = DMUS_E_INVALID_LYRICSTRACK;
    }

    if (SUCCEEDED(hr))
    {
        m_EventList.AddHead(pItem);
    }
    else
    {
        delete pItem;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\marktrk.h ===
//MarkTrk.h : Declaration of the marker track

#ifndef __MARKTRK_H_
#define __MARKTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

class CValidStartItem : public AListItem
{
public:
    CValidStartItem* GetNext(){ return (CValidStartItem*)AListItem::GetNext(); };
    DMUS_IO_VALID_START  m_ValidStart;
};
   
class CValidStartList : public AList
{
public:
    CValidStartItem* GetHead() {return (CValidStartItem*)AList::GetHead();};
    CValidStartItem* RemoveHead() {return (CValidStartItem*)AList::RemoveHead();};
    CValidStartItem* GetItem(LONG lIndex) { return (CValidStartItem*) AList::GetItem(lIndex);};
};

class CPlayMarkerItem : public AListItem
{
public:
    CPlayMarkerItem* GetNext(){ return (CPlayMarkerItem*)AListItem::GetNext(); };
    DMUS_IO_PLAY_MARKER  m_PlayMarker;
};
   
class CPlayMarkerList : public AList
{
public:
    CPlayMarkerItem* GetHead() {return (CPlayMarkerItem*)AList::GetHead();};
    CPlayMarkerItem* RemoveHead() {return (CPlayMarkerItem*)AList::RemoveHead();};
    CPlayMarkerItem* GetItem(LONG lIndex) { return (CPlayMarkerItem*) AList::GetItem(lIndex);};
};

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack
class CMarkerTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CMarkerTrack();
	CMarkerTrack(CMarkerTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CMarkerTrack();

// member variables
protected:
    CValidStartList     m_ValidStartList;
    CPlayMarkerList     m_PlayMarkerList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	void Construct(void);
    void Clear();
    HRESULT LoadValidStartList( CRiffParser *pParser, long lChunkSize );
    HRESULT LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize );
protected:
};

#endif //__MARKTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\marktrk.cpp ===
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// MarkTrk.cpp : Implementation of CMarkerTrack

#include "dmime.h"
#include "..\shared\dmstrm.h"
#include "MarkTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert

/////////////////////////////////////////////////////////////////////////////
// CMarkerTrack

void CMarkerTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
}

CMarkerTrack::CMarkerTrack()
{
	Construct();
}

CMarkerTrack::CMarkerTrack(
		CMarkerTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
    // Clone the valid start point list.
	CValidStartItem* pVScan = pSourceTrack->m_ValidStartList.GetHead();
	CValidStartItem* pVPrevious = NULL;
	for(; pVScan; pVScan = pVScan->GetNext())
	{
		if (pVScan->m_ValidStart.mtTime < mtStart)
		{
			pVPrevious = pVScan;
		}
		else if (pVScan->m_ValidStart.mtTime < mtEnd)
		{
			if (pVScan->m_ValidStart.mtTime == mtStart)
			{
				pVPrevious = NULL;
			}
			CValidStartItem* pNew = new CValidStartItem;
			if (pNew)
			{
				pNew->m_ValidStart.mtTime = pVScan->m_ValidStart.mtTime - mtStart;
				m_ValidStartList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_ValidStartList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pVPrevious)
	{
		CValidStartItem* pNew = new CValidStartItem;
		if (pNew)
		{
			pNew->m_ValidStart.mtTime = 0;
			m_ValidStartList.AddHead(pNew);
		}
	}
    // Clone the play marker list. Gee, this is identical code...
	CPlayMarkerItem* pPScan = pSourceTrack->m_PlayMarkerList.GetHead();
	CPlayMarkerItem* pPPrevious = NULL;
	for(; pPScan; pPScan = pPScan->GetNext())
	{
		if (pPScan->m_PlayMarker.mtTime < mtStart)
		{
			pPPrevious = pPScan;
		}
		else if (pPScan->m_PlayMarker.mtTime < mtEnd)
		{
			if (pPScan->m_PlayMarker.mtTime == mtStart)
			{
				pPPrevious = NULL;
			}
			CPlayMarkerItem* pNew = new CPlayMarkerItem;
			if (pNew)
			{
				pNew->m_PlayMarker.mtTime = pPScan->m_PlayMarker.mtTime - mtStart;
				m_PlayMarkerList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_PlayMarkerList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPPrevious)
	{
		CPlayMarkerItem* pNew = new CPlayMarkerItem;
		if (pNew)
		{
			pNew->m_PlayMarker.mtTime = 0;
			m_PlayMarkerList.AddHead(pNew);
		}
	}
}

void CMarkerTrack::Clear()

{
	CValidStartItem* pStart;
	while( pStart = m_ValidStartList.RemoveHead() )
	{
		delete pStart;
	}
	CPlayMarkerItem* pPlay;
	while( pPlay = m_PlayMarkerList.RemoveHead() )
	{
		delete pPlay;
	}
}

CMarkerTrack::~CMarkerTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }
	InterlockedDecrement(&g_cComponent);
}

STDMETHODIMP CMarkerTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CMarkerTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Marker Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CMarkerTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CMarkerTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CMarkerTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CMarkerTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicMarkerTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CMarkerTrack::IsDirty()
{
	return S_FALSE;
}

HRESULT CMarkerTrack::Load( IStream* pIStream )
{
	V_INAME(CMarkerTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	EnterCriticalSection(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_MARKERTRACK_LIST))
    {
        Clear();
	    RIFFIO ckNext;    // Descends into the children chunks.
        Parser.EnterList(&ckNext);
        while (Parser.NextChunk(&hr))
        {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_VALIDSTART_CHUNK :
                hr = LoadValidStartList(&Parser,ckNext.cksize);
                break;
            case DMUS_FOURCC_PLAYMARKER_CHUNK :
                hr = LoadPlayMarkerList(&Parser,ckNext.cksize);
                break;
            }    
        }
        Parser.LeaveList();
    }
    else
    {
        Trace(1,"Error: Invalid Marker Track.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
    }
    Parser.LeaveList();
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::LoadPlayMarkerList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_PLAY_MARKER) )
	    {
		    dwRead = sizeof(DMUS_IO_PLAY_MARKER);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Invalid Marker Track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CPlayMarkerItem *pNew = new CPlayMarkerItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_PlayMarker, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_PlayMarkerList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_PlayMarkerList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::LoadValidStartList( CRiffParser *pParser, long lChunkSize )
{
    HRESULT hr;
	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {	
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_VALID_START) )
	    {
		    dwRead = sizeof(DMUS_IO_VALID_START);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CValidStartItem *pNew = new CValidStartItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_ValidStart, dwRead)))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
                    m_ValidStartList.AddHead(pNew); // Insert in reverse order for speed.
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_ValidStartList.Reverse(); // Reverse to put in time order.
        }
    }
	return hr;
}

HRESULT CMarkerTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CMarkerTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CMarkerTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CMarkerTrack::IsParamSupported);
	V_REFGUID(rguid);

    if ((rguid == GUID_Valid_Start_Time) || 
        (rguid == GUID_Play_Marker))
        return S_OK;
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CMarkerTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CMarkerTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	return S_OK;
}

HRESULT CMarkerTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	return S_OK;
}

HRESULT CMarkerTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	return S_OK;
}

HRESULT CMarkerTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CMarkerTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    EnterCriticalSection(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_Valid_Start_Time == rguid )
	{
        DMUS_VALID_START_PARAM* pValidStartData = (DMUS_VALID_START_PARAM*)pData;
		CValidStartItem* pScan = m_ValidStartList.GetHead();
		for (; pScan; pScan = pScan->GetNext())
		{
			if (pScan->m_ValidStart.mtTime >= mtTime)
			{
        		pValidStartData->mtTime = pScan->m_ValidStart.mtTime - mtTime;
				break;
			}
		}
        if (pScan)
        {
 		    if (pmtNext)
		    {
		        if (pScan && (pScan = pScan->GetNext()))
		        {
                    *pmtNext = pScan->m_ValidStart.mtTime - mtTime;
			    }
                else
                {
        		    *pmtNext = 0;
                }
            }
		    hr = S_OK;
        }
        else
        {
            hr = DMUS_E_NOT_FOUND;
        }
    }
	else if( GUID_Play_Marker == rguid )
	{
        // This is a little different. The marker should be the one in existence
        // BEFORE, not after the requested time. 
        DMUS_PLAY_MARKER_PARAM* pPlayMarkerData = (DMUS_PLAY_MARKER_PARAM*)pData;
		CPlayMarkerItem* pScan = m_PlayMarkerList.GetHead();
        CPlayMarkerItem* pNext;
        // For fallback, treat it as if there were a marker at the start of the segment, but return S_FALSE.
        hr = S_FALSE;
        pPlayMarkerData->mtTime = -mtTime;
		for (; pScan; pScan = pNext)
		{
            pNext = pScan->GetNext();
            if (pScan->m_PlayMarker.mtTime <= mtTime) 
            {
                if (!pNext || (pNext->m_PlayMarker.mtTime > mtTime))
                {
        		    pPlayMarkerData->mtTime = pScan->m_PlayMarker.mtTime - mtTime;
                    if (pmtNext && pNext)
                    {
                        *pmtNext = pNext->m_PlayMarker.mtTime - mtTime;
                    }
                    hr = S_OK;
				    break;
                }
			}
            else
            {
                // Didn't find a marker before the requested time.
                if (pmtNext)
                {
                    *pmtNext = pScan->m_PlayMarker.mtTime - mtTime;
                }
                break;
            }
		}
    }
#ifdef DBG
    if (hr == DMUS_E_GET_UNSUPPORTED)
    {
        Trace(1,"Error: MarkerTrack does not support requested GetParam call.\n");
    }
#endif
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CMarkerTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return DMUS_E_SET_UNSUPPORTED;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CMarkerTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if(mtStart < 0 )
	{
        Trace(1,"Error: Unable to clone marker track because the start point is less than 0.\n");
		return E_INVALIDARG;
	}
	if(mtStart > mtEnd)
	{
        Trace(1,"Error: Unable to clone marker track because the start point is greater than the length.\n");
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);
    CMarkerTrack *pDM;
    
    try
    {
        pDM = new CMarkerTrack(this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\dmstrm.cpp ===
//
// dmstrm.cpp
//
// Copyright (c) 1995-2000 Microsoft Corporation
//

#include "debug.h"
#include "dmusicc.h"
#include "..\shared\dmstrm.h"
#include "..\shared\validate.h"

/////////////////////////////////////////////////////////////////////////////
// AllocDIrectMusicStream

STDAPI AllocDirectMusicStream(IStream* pIStream, IDMStream** ppIDMStream)
{
    if(pIStream == NULL || ppIDMStream == NULL)
    {
        return E_INVALIDARG;
    }

    if((*ppIDMStream = (IDMStream*) new CDirectMusicStream()) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ((CDirectMusicStream*)*ppIDMStream)->Init(pIStream);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CDirectMusicStream

CDirectMusicStream::CDirectMusicStream() :
m_cRef(1),
m_pStream(NULL)
{
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::~CDirectMusicStream

CDirectMusicStream::~CDirectMusicStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Init

STDMETHODIMP CDirectMusicStream::Init(IStream* pStream)
{
    SetStream(pStream);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::QueryInterface

STDMETHODIMP CDirectMusicStream::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CDirectMusicStream::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if(iid == IID_IUnknown || iid == IID_IDMStream)
    {
        *ppv = static_cast<IDMStream*>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::AddRef

STDMETHODIMP_(ULONG) CDirectMusicStream::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Release

STDMETHODIMP_(ULONG) CDirectMusicStream::Release()
{
    if(!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::SetStream

STDMETHODIMP CDirectMusicStream::SetStream(IStream* pStream)
{
    if(m_pStream != NULL)
    {
        m_pStream->Release();
    }

    m_pStream = pStream;

    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::GetStream

STDMETHODIMP_(IStream*) CDirectMusicStream::GetStream()
{
    if(m_pStream != NULL)
    {
        m_pStream->AddRef();
    }

    return m_pStream;
}

//////////////////////////////////////////////////////////////////////
// IDMStream

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Descend

STDMETHODIMP CDirectMusicStream::Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags)
{
    assert(lpck);

    FOURCC ckidFind;           // Chunk ID to find (or NULL)
    FOURCC fccTypeFind;    // Form/list type to find (or NULL)

    // Figure out what chunk id and form/list type for which to search
    if(wFlags & MMIO_FINDCHUNK)
    {
        ckidFind = lpck->ckid;
        fccTypeFind = NULL;
    }
    else if(wFlags & MMIO_FINDRIFF)
    {
        ckidFind = FOURCC_RIFF;
        fccTypeFind = lpck->fccType;
    }
    else if(wFlags & MMIO_FINDLIST)
    {
        ckidFind = FOURCC_LIST;
        fccTypeFind = lpck->fccType;
    }
    else
    {
        ckidFind = fccTypeFind = NULL;
    }

    lpck->dwFlags = 0L;

    for(;;)
    {
        HRESULT hr;
        LARGE_INTEGER li;
        ULARGE_INTEGER uli;
        ULONG cbRead;

        // Read the chunk header
        hr = m_pStream->Read(lpck, 2 * sizeof(DWORD), &cbRead);

        if (FAILED(hr) || (cbRead != 2 * sizeof(DWORD)))
        {
            Trace(3,"Warning: Reached end of file.\n");
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // Store the offset of the data part of the chunk
        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to read file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lpck->dwDataOffset = uli.LowPart;
        }

        // See if the chunk is within the parent chunk (if given)
        if((lpckParent != NULL) &&
           (lpck->dwDataOffset - 8L >=
           lpckParent->dwDataOffset + lpckParent->cksize))
        {
            // This is not really a failure, just indicating we've reached the end of the list.
            return DMUS_E_DESCEND_CHUNK_FAIL;
        }

        // If the chunk is a 'RIFF' or 'LIST' chunk, read the
        // form type or list type
        if((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
        {
            hr = m_pStream->Read(&lpck->fccType, sizeof(DWORD), &cbRead);

            if(FAILED(hr) || (cbRead != sizeof(DWORD)))
            {
                Trace(1,"Error: Unable to read file.\n");
                return DMUS_E_DESCEND_CHUNK_FAIL;
            }
        }
        else
        {
            lpck->fccType = NULL;
        }

        // If this is the chunk we're looking for, stop looking
        if(((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
           ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)))
        {
            break;
        }

        // Ascend out of the chunk and try again
        HRESULT w = Ascend(lpck, 0);
        if(FAILED(w))
        {
            return w;
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::Ascend

STDMETHODIMP CDirectMusicStream::Ascend(LPMMCKINFO lpck, UINT /*wFlags*/)
{
    assert(lpck);

    HRESULT hr;
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    if (lpck->dwFlags & MMIO_DIRTY)
    {
        // <lpck> refers to a chunk created by CreateChunk();
        // check that the chunk size that was written when
        // CreateChunk() was called is the real chunk size;
        // if not, fix it
        LONG lOffset;           // current offset in file
        LONG lActualSize;   // actual size of chunk data

        li.QuadPart = 0;
        hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }
        else
        {
            lOffset = uli.LowPart;
        }

        if((lActualSize = lOffset - lpck->dwDataOffset) < 0)
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }

        if(LOWORD(lActualSize) & 1)
        {
            ULONG cbWritten;

            // Chunk size is odd -- write a null pad byte
            hr = m_pStream->Write("\0", 1, &cbWritten);

            if(FAILED(hr) || cbWritten != 1)
            {
                Trace(1,"Error: Unable to write file.\n");
                return DMUS_E_CANNOTWRITE;
            }

        }

        if(lpck->cksize == (DWORD)lActualSize)
        {
            return S_OK;
        }

        // Fix the chunk header
        lpck->cksize = lActualSize;

        li.QuadPart = lpck->dwDataOffset - sizeof(DWORD);
        hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

        if(FAILED(hr))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTSEEK;
        }

        ULONG cbWritten;

        hr = m_pStream->Write(&lpck->cksize, sizeof(DWORD), &cbWritten);

        if(FAILED(hr) || cbWritten != sizeof(DWORD))
        {
            Trace(1,"Error: Unable to write file.\n");
            return DMUS_E_CANNOTWRITE;
        }
    }

    // Seek to the end of the chunk, past the null pad byte
    // (which is only there if chunk size is odd)
    li.QuadPart = lpck->dwDataOffset + lpck->cksize + (lpck->cksize & 1L);
    hr = m_pStream->Seek(li, STREAM_SEEK_SET, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// CDirectMusicStream::CreateChunk

STDMETHODIMP CDirectMusicStream::CreateChunk(LPMMCKINFO lpck, UINT wFlags)
{
    assert(lpck);

    UINT iBytes;    // Bytes to write
    LONG lOffset;   // Current offset in file

    // Store the offset of the data part of the chunk
    LARGE_INTEGER li;
    ULARGE_INTEGER uli;

    li.QuadPart = 0;
    HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &uli);

    if(FAILED(hr))
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTSEEK;
    }
    else
    {
        lOffset = uli.LowPart;
    }

    lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

    // figure out if a form/list type needs to be written
    if(wFlags & MMIO_CREATERIFF)
    {
        lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
    }
    else if(wFlags & MMIO_CREATELIST)
    {
        lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
    }
    else
    {
        iBytes = 2 * sizeof(DWORD);
    }

    // Write the chunk header
    ULONG cbWritten;

    hr = m_pStream->Write(lpck, iBytes, &cbWritten);

    if(FAILED(hr) || cbWritten != iBytes)
    {
        Trace(1,"Error: Unable to write file.\n");
        return DMUS_E_CANNOTWRITE;
    }

    lpck->dwFlags = MMIO_DIRTY;

    return S_OK;
}

CRiffParser::CRiffParser(IStream *pStream)

{
    assert(pStream);
    m_fDebugOn = FALSE;
    m_pStream = pStream;
    m_pParent = NULL;
    m_pChunk = NULL;
    m_lRead = 0;
    m_fFirstPass = TRUE;
    m_fComponentFailed = FALSE;
    m_fInComponent = FALSE;
}

void CRiffParser::EnterList(RIFFIO *pChunk)

{
    assert (pChunk);
    pChunk->lRead = 0;
    pChunk->pParent = m_pChunk; // Previous chunk (could be NULL.)
    m_pParent = m_pChunk;
    m_pChunk = pChunk;
    m_fFirstPass = TRUE;
}

void CRiffParser::LeaveList()

{
    assert (m_pChunk);
    if (m_pChunk)
    {
        m_pChunk = m_pChunk->pParent;
        if (m_pChunk)
        {
            m_pParent = m_pChunk->pParent;
        }
    }
}

BOOL CRiffParser::NextChunk(HRESULT * pHr)

{
    BOOL fMore = FALSE;
    if (SUCCEEDED(*pHr))
    {
        // If this is the first time we've entered this list, there is no previous chunk.
        if (m_fFirstPass)
        {
            // Clear the flag.
            m_fFirstPass = FALSE;
        }
        else
        {
            // Clean up the previous pass.
            *pHr = LeaveChunk();
        }
        // Find out if there are more chunks to read.
        fMore = MoreChunks();
        // If so, and we don't have any failure, go ahead and read the next chunk header.
        if (fMore && SUCCEEDED(*pHr))
        {
            *pHr = EnterChunk();
        }
    }
    else
    {
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            Trace(0,"Error parsing %s, Read %ld of %ld\n",szName,m_pChunk->lRead,RIFF_ALIGN(m_pChunk->cksize));
        }
#endif
        // If we were in a component, it's okay to fail. Mark that fact by setting
        // m_fComponentFailed then properly pull out of the chunk so we can
        // continue reading.
        if (m_fInComponent)
        {
            m_fComponentFailed = TRUE;
            // We don't need to check for first pass, because we must have gotten
            // that far. Instead, we just clean up from the failed chunk.
            // Note that this sets the hresult to S_OK, which is what we want.
            // Later, the caller needs to call ComponentFailed() to find out if
            // this error occured.
            *pHr = LeaveChunk();
        }
        else
        {
            // Clean up but leave the error code.
            LeaveChunk();
        }
    }
    return fMore && SUCCEEDED(*pHr);
}

BOOL CRiffParser::MoreChunks()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        if (m_pParent)
        {
            // Return TRUE if there's enough room for another chunk.
            return (m_pParent->lRead < (m_pParent->cksize - 8));
        }
        else
        {
            // This must be a top level chunk, in which case there would only be one to read.
            return (m_pChunk->lRead == 0);
        }
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return false;
}

HRESULT CRiffParser::EnterChunk()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Read the chunk header
        HRESULT hr = m_pStream->Read(m_pChunk, 2 * sizeof(DWORD), NULL);
        if (SUCCEEDED(hr))
        {
#ifdef DBG
            char szName[5];
            if (m_fDebugOn)
            {
                szName[4] = 0;
                strncpy(szName,(char *)&m_pChunk->ckid,4);
                ULARGE_INTEGER ul;
                LARGE_INTEGER li;
                li.QuadPart = 0;
                m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

                Trace(0,"Entering %s, Length %ld, File position is %ld",szName,m_pChunk->cksize,(long)ul.QuadPart);
            }
#endif
            // Clear bytes read field.
            m_pChunk->lRead = 0;
            // Check to see if this is a container (LIST or RIFF.)
            if((m_pChunk->ckid == FOURCC_RIFF) || (m_pChunk->ckid == FOURCC_LIST))
            {
                hr = m_pStream->Read(&m_pChunk->fccType, sizeof(DWORD), NULL);
                if (SUCCEEDED(hr))
                {
                    m_pChunk->lRead += sizeof(DWORD);
#ifdef DBG
                    if (m_fDebugOn)
                    {
                        strncpy(szName,(char *)&m_pChunk->fccType,4);
                        Trace(0," Type %s",szName);
                    }
#endif
                }
                else
                {
                    Trace(1,"Error: Unable to read file.\n");
                }
            }
#ifdef DBG
            if (m_fDebugOn) Trace(0,"\n");
#endif
        }
        else
        {
            Trace(1,"Error: Unable to read file.\n");
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::LeaveChunk()

{
    HRESULT hr = S_OK;
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_fInComponent = false;
        // Get the rounded up size of the chunk.
        long lSize = RIFF_ALIGN(m_pChunk->cksize);
        // Increment the parent's count of bytes read so far.
        if (m_pParent)
        {
            m_pParent->lRead += lSize + (2 * sizeof(DWORD));
            if (m_pParent->lRead > RIFF_ALIGN(m_pParent->cksize))
            {
                Trace(1,"Error: Unable to read file.\n");
                hr = DMUS_E_DESCEND_CHUNK_FAIL; // Goofy error name, but need to be consistent with previous versions.
            }
        }
#ifdef DBG
        char szName[5];
        if (m_fDebugOn)
        {
            szName[4] = 0;
            strncpy(szName,(char *)&m_pChunk->ckid,4);
            ULARGE_INTEGER ul;
            LARGE_INTEGER li;
            li.QuadPart = 0;
            m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);

            Trace(0,"Leaving %s, Read %ld of %ld, File Position is %ld\n",szName,m_pChunk->lRead,lSize,(long)ul.QuadPart);
        }
#endif
        // If we haven't actually read this entire chunk, seek to the end of it.
        if (m_pChunk->lRead < lSize)
        {
            LARGE_INTEGER li;
            li.QuadPart = lSize - m_pChunk->lRead;
            hr = m_pStream->Seek(li,STREAM_SEEK_CUR,NULL);
            // There's a chance it could fail because we are at the end of file with an odd length chunk.
            if (FAILED(hr))
            {
                // If there's a parent, see if this is the last chunk.
                if (m_pParent)
                {
                    if (m_pParent->cksize >= (m_pParent->lRead - 1))
                    {
                        hr = S_OK;
                    }
                }
                // Else, see if we are an odd length.
                else if (m_pChunk->cksize & 1)
                {
                    hr = S_OK;
                }
            }
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Read(void *pv,ULONG cb)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't read beyond the end of the chunk.
        if (((long)cb + m_pChunk->lRead) > m_pChunk->cksize)
        {
            cb -= (cb - (m_pChunk->cksize - m_pChunk->lRead));
        }
        HRESULT hr = m_pStream->Read(pv,cb,NULL);
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += cb;
        }
        else
        {
            Trace(1,"Error: Unable to read %ld bytes from file.\n",cb);
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}

HRESULT CRiffParser::Skip(ULONG ulBytes)

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Make sure we don't scan beyond the end of the chunk.
        if (((long)ulBytes + m_pChunk->lRead) > m_pChunk->cksize)
        {
            ulBytes -= (ulBytes - (m_pChunk->cksize - m_pChunk->lRead));
        }
        LARGE_INTEGER li;
        li.HighPart = 0;
        li.LowPart = ulBytes;
        HRESULT hr = m_pStream->Seek( li, STREAM_SEEK_CUR, NULL );
        if (SUCCEEDED(hr))
        {
            m_pChunk->lRead += ulBytes;
        }
        return hr;
    }
    // This should never happen unless CRiffParser is used incorrectly, in which
    // case the assert will help debug. But, in the interest of making Prefix happy...
    return E_FAIL;
}


void CRiffParser::MarkPosition()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        LARGE_INTEGER li;
        ULARGE_INTEGER ul;
        li.HighPart = 0;
        li.LowPart = 0;
        m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        m_pChunk->liPosition.QuadPart = (LONGLONG) ul.QuadPart;
    }
}

HRESULT CRiffParser::SeekBack()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        // Move back to the start of the current chunk. Also, store the
        // absolute position because that will be useful later when we need to seek to the
        // end of this chunk.
        ULARGE_INTEGER ul;
        LARGE_INTEGER li;
        li.QuadPart = 0;
        li.QuadPart -= (m_pChunk->lRead + (2 * sizeof(DWORD)));
        HRESULT hr = m_pStream->Seek(li, STREAM_SEEK_CUR, &ul);
        // Now, save the absolute position for the end of this chunk.
        m_pChunk->liPosition.QuadPart = ul.QuadPart +
            RIFF_ALIGN(m_pChunk->cksize) + (2 * sizeof(DWORD));
        m_pChunk->lRead = 0;
        return hr;
    }
    return E_FAIL;
}

HRESULT CRiffParser::SeekForward()

{
    assert(m_pChunk);
    if (m_pChunk)
    {
        m_pChunk->lRead = RIFF_ALIGN(m_pChunk->cksize);
        return m_pStream->Seek(m_pChunk->liPosition, STREAM_SEEK_SET, NULL);
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\midifile.h ===
//
// midifile.h
// 
// Copyright (c) 1997-1998 Microsoft Corporation
//
// Note: 
//

#ifndef MIDIFILE_H
#define MIDIFILE_H

HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream, 
									IDirectMusicSegment* pSegment);
#endif // #ifndef MIDIFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\midifile.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
//
// midifile.cpp
//
// original author: Dave Miller
// original project: AudioActive
// modified by: Mark Burton
// project: DirectMusic
//

#include <windows.h>
#include <mmsystem.h>
#include <dsoundp.h>
#include "debug.h"
#define ASSERT assert
#include "Template.h"
#include "dmusici.h"
#include "dmperf.h"
#include "dmusicf.h"
#include "..\dmusic\dmcollec.h"
#include "alist.h"
#include "tlist.h"
#include "dmime.h"
#include "..\dmband\dmbndtrk.h"
#include "..\dmband\bandinst.h"

typedef struct _DMUS_IO_BANKSELECT_ITEM
{
    BYTE    byLSB;
    BYTE    byMSB;
    BYTE    byPad[2];
} DMUS_IO_BANKSELECT_ITEM;

#define EVENT_VOICE     1       // Performance event
#define EVENT_REALTIME  2       // qevent() must invoke interrupt
#define EVENT_ONTIME    3       // event should be handled on time

/*  MIDI status bytes ==================================================*/

#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define ET_NOTEOFF      ( MIDI_NOTEOFF >> 4 )  // 0x08
#define ET_NOTEON       ( MIDI_NOTEON >> 4 )   // 0x09
#define ET_PTOUCH       ( MIDI_PTOUCH >> 4 )   // 0x0A
#define ET_CCHANGE      ( MIDI_CCHANGE >> 4 )  // 0x0B
#define ET_PCHANGE      ( MIDI_PCHANGE >> 4 )  // 0x0C
#define ET_MTOUCH       ( MIDI_MTOUCH >> 4 )   // 0x0D
#define ET_PBEND        ( MIDI_PBEND >> 4 )    // 0x0E
#define ET_SYSX         ( MIDI_SYSX >> 4 )     // 0x0F
#define ET_PBCURVE      0x03
#define ET_CCCURVE      0x04
#define ET_MATCURVE     0x05
#define ET_PATCURVE     0x06
#define ET_TEMPOEVENT   0x01
#define ET_NOTDEFINED   0

#define NUM_MIDI_CHANNELS 16

struct FSEBlock;

/* FullSeqEvent is SeqEvent plus next pointers*/
typedef struct FullSeqEvent : DMUS_IO_SEQ_ITEM
{
    struct FullSeqEvent* pNext;
    struct FullSeqEvent* pTempNext; /* used in the compresseventlist routine */
    long pos;    /* used to keep track of the order of events in the file */

private:
    DWORD dwPosInBlock;
    static FSEBlock* sm_pBlockList;
public:
    static void CleanUp();
    void* operator new(size_t n);
    void operator delete(void* p);
} FullSeqEvent;

#define BITMAPSPERBLOCK 8
struct FSEBlock
{
    FSEBlock()
    {
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            m_dwBitMap[i] = 0;
        }
    };
    FSEBlock* m_pNext;
    DWORD m_dwBitMap[BITMAPSPERBLOCK];
    FullSeqEvent m_Event[BITMAPSPERBLOCK][32];
};

FSEBlock* FullSeqEvent::sm_pBlockList;

void FullSeqEvent::CleanUp()
{
    FSEBlock* pBlock;
    FSEBlock* pNext;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pNext)
    {
#ifdef DEBUG
        for(int i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0)
            {
                DebugBreak();
            }
        }
#endif
        pNext = pBlock->m_pNext;
        delete pBlock;
    }
    sm_pBlockList = NULL;
}

void* FullSeqEvent::operator new(size_t n)
{
    if(sm_pBlockList == NULL)
    {
        sm_pBlockList = new FSEBlock;
        if(sm_pBlockList == NULL)
        {
            return NULL;
        }
        sm_pBlockList->m_pNext = NULL;
        sm_pBlockList->m_dwBitMap[0] = 1;
        sm_pBlockList->m_Event[0][0].dwPosInBlock = 0;
        return &sm_pBlockList->m_Event[0][0];
    }

    FSEBlock* pBlock;
    int i;
    DWORD dw;

    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        for(i = 0 ; i < BITMAPSPERBLOCK ; ++i)
        {
            if(pBlock->m_dwBitMap[i] != 0xffff)
            {
                break;
            }
        }
        if(i < BITMAPSPERBLOCK)
        {
            break;
        }
    }
    if(pBlock == NULL)
    {
        pBlock = new FSEBlock;
        if(pBlock == NULL)
        {
            return NULL;
        }
        pBlock->m_pNext = sm_pBlockList;
        sm_pBlockList = pBlock;
        pBlock->m_dwBitMap[0] = 1;
        pBlock->m_Event[0][0].dwPosInBlock = 0;
        return &pBlock->m_Event[0][0];
    }

    for(dw = 0 ; (pBlock->m_dwBitMap[i] & (1 << dw)) != 0 ; ++dw);
    pBlock->m_dwBitMap[i] |= (1 << dw);
    pBlock->m_Event[i][dw].dwPosInBlock = (i << 6) | dw;
    return &pBlock->m_Event[i][dw];
}

void FullSeqEvent::operator delete(void* p)
{
    FSEBlock* pBlock;
    int i;
    DWORD dw;
    FullSeqEvent* pEvent = (FullSeqEvent*)p;

    dw = pEvent->dwPosInBlock & 0x1f;
    i = pEvent->dwPosInBlock >> 6;
    for(pBlock = sm_pBlockList ; pBlock != NULL ; pBlock = pBlock->m_pNext)
    {
        if(p == &pBlock->m_Event[i][dw])
        {
            pBlock->m_dwBitMap[i] &= ~(1 << dw);
            return;
        }
    }
}

TList<StampedGMGSXG> gMidiModeList;

// One for each MIDI channel 0-15    
DMUS_IO_BANKSELECT_ITEM gBankSelect[NUM_MIDI_CHANNELS];
DWORD gPatchTable[NUM_MIDI_CHANNELS];
long gPos;                                          // Keeps track of order of events in the file
DWORD gdwLastControllerTime[NUM_MIDI_CHANNELS];     // Holds the time of the last CC event.
DWORD gdwControlCollisionOffset[NUM_MIDI_CHANNELS]; // Holds the index of the last CC.
DWORD gdwLastPitchBendValue[NUM_MIDI_CHANNELS];     // Holds the value of the last pbend event.
long glLastSysexTime;

void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord);


void InsertMidiMode( TListItem<StampedGMGSXG>* pPair )
{
    TListItem<StampedGMGSXG>* pScan = gMidiModeList.GetHead();
    if( NULL == pScan )
    {
        gMidiModeList.AddHead(pPair);
    }
    else
    {
        if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
        {
            gMidiModeList.AddHead(pPair);
        }
        else
        {
            pScan = pScan->GetNext();
            while( pScan )
            {
                if( pPair->GetItemValue().mtTime < pScan->GetItemValue().mtTime )
                {
                    gMidiModeList.InsertBefore( pScan, pPair );
                    break;
                }
                pScan = pScan->GetNext();
            }
            if( NULL == pScan )
            {
                gMidiModeList.AddTail(pPair);
            }
        }
    }
}

HRESULT LoadCollection(IDirectMusicCollection** ppIDMCollection,
                       IDirectMusicLoader* pIDMLoader)
{
    // Any changes made to this function should also be made to CDirectMusicBand::LoadCollection
    // in dmband.dll

    assert(ppIDMCollection);
    assert(pIDMLoader);

    DMUS_OBJECTDESC desc;
    memset(&desc, 0, sizeof(desc));
    desc.dwSize = sizeof(desc);

    desc.guidClass = CLSID_DirectMusicCollection;
    desc.guidObject = GUID_DefaultGMCollection;
    desc.dwValidData |= (DMUS_OBJ_CLASS | DMUS_OBJ_OBJECT);
    
    HRESULT hr = pIDMLoader->GetObject(&desc,IID_IDirectMusicCollection, (void**)ppIDMCollection);

    return hr;
}

// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
    LARGE_INTEGER li;

    if( lSeekTo < 0 )
    {
        li.HighPart = -1;
    }
    else
    {
    li.HighPart = 0;
    }
    li.LowPart = lSeekTo;
    return pStream->Seek( li, dwOrigin, NULL );
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
    {
        unsigned char buf[4];
    DWORD dw;
    } u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 4, NULL ) )
    {
    return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

// this function gets a short that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMShort( LPSTREAM pStream, short& n )
{
    union uShort
    {
    unsigned char buf[2];
    short n;
    } u;
    unsigned char ch;

    if( S_OK != pStream->Read( u.buf, 2, NULL ) )
    {
    return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[1];
    u.buf[1] = ch;
#endif

    n = u.n;
    return TRUE;
}

static short snPPQN;
static IStream* gpTempoStream = NULL;
static IStream* gpSysExStream = NULL;
static IStream* gpTimeSigStream = NULL;
static DWORD gdwSizeTimeSigStream = 0;
static DWORD gdwSizeSysExStream = 0;
static DWORD gdwSizeTempoStream = 0;
static DMUS_IO_TIMESIGNATURE_ITEM gTimeSig; // holds the latest time sig
long    glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
    // this is needed because we only care about the time sigs on the first track to
    // contain them that we read
static IDirectMusicTrack* g_pChordTrack = NULL;
static DMUS_CHORD_PARAM g_Chord; // Holds the latest chord
static DMUS_CHORD_PARAM g_DefaultChord; // in case no chords are extracted from the track

static WORD GetVarLength( LPSTREAM pStream, DWORD& rfdwValue )
{
    BYTE b;
    WORD wBytes;

    if( S_OK != pStream->Read( &b, 1, NULL ) )
    {
        rfdwValue = 0;
        return 0;
    }
    wBytes = 1;
    rfdwValue = b & 0x7f;
    while( ( b & 0x80 ) != 0 )
    {
        if( S_OK != pStream->Read( &b, 1, NULL ) )
        {
            break;
        }
        ++wBytes;
        rfdwValue = ( rfdwValue << 7 ) + ( b & 0x7f );
    }
    return wBytes;
}

#ifdef _MAC
static DWORD ConvertTime( DWORD dwTime )
{
    wide d;
    long l;  // storage for the remainder

    if( snPPQN == DMUS_PPQ )  {
        return dwTime;
    }
    WideMultiply( dwTime, DMUS_PPQ, &d );
    return WideDivide( &d, snPPQN, &l );
}
#else
static DWORD ConvertTime( DWORD dwTime )
{
    __int64 d;

    if( snPPQN == DMUS_PPQ )
    {
        return dwTime;
    }
    d = dwTime;
    d *= DMUS_PPQ;
    d /= snPPQN;
    return (DWORD)d;
}
#endif

static FullSeqEvent* ScanForDuplicatePBends( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pEvent;
    FullSeqEvent* pNextEvent;
    MUSIC_TIME mtCurrentTime = 0x7FFFFFFF;  // We are scanning backwards in time, so start way in the future.
    WORD wDupeBits = 0;     // Keep a bit array of all channels that have active PBends at mtCurrentTime. 

    if( NULL == lstEvent ) return NULL;

    // Scan through the list of events. This list is in backwards order, with the first item read at the end
    // of the list. This makes it very easy to scan through and remove pitch bends that occur at the same time, since
    // we can remove the latter events (which occured earlier in the midi file.)
    for( pEvent = lstEvent ; pEvent ; pEvent = pNextEvent )
    {
        pNextEvent = pEvent->pNext;
        if( pNextEvent )
        {
            // If the time is not the same as the last, reset. 
            if (pNextEvent->mtTime != mtCurrentTime)
            {
                // Reset the time.
                mtCurrentTime = pNextEvent->mtTime;
                // No duplicate pbends at this time.
                wDupeBits = 0;
            }
            if ((pNextEvent->bStatus & 0xf0) == MIDI_PBEND)
            {
                DWORD dwChannel = pNextEvent->dwPChannel;
                if (wDupeBits & (1 << dwChannel))
                {
                    // There was a previous (therefore later in the file) pbend at this time. Delete this one.
                    pEvent->pNext = pNextEvent->pNext;
                    delete pNextEvent;
                    pNextEvent = pEvent;
                }
                else
                {
                    // This is the last instance of a pbend on this channel at this time, so hang on to it.
                    wDupeBits |= (1 << dwChannel);
                }
            }
        }
    }
    return lstEvent;
}


static FullSeqEvent* CompressEventList( FullSeqEvent* lstEvent )
{
    static FullSeqEvent* paNoteOnEvent[16][128];
    FullSeqEvent* pEvent;
    FullSeqEvent* pPrevEvent;
    FullSeqEvent* pNextEvent;
    FullSeqEvent* pHoldEvent;
    FullSeqEvent tempEvent;
    int nChannel;

    if( NULL == lstEvent ) return NULL;

    memset( paNoteOnEvent, 0, sizeof( paNoteOnEvent ) );
    pPrevEvent = NULL;

    // add an event to the beginning of the list as a place holder
    memset( &tempEvent, 0, sizeof(FullSeqEvent) );
    tempEvent.mtTime = -1;
    tempEvent.pNext = lstEvent;
    lstEvent = &tempEvent;
    // make sure that any events with the same time are sorted in order
    // they were read
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
        pNextEvent = pEvent->pNext;
        if( pNextEvent )
        {
            BOOL fSwap = TRUE;
            // bubble sort
            while( fSwap )
            {
                fSwap = FALSE;
                pPrevEvent = pEvent;
                pNextEvent = pEvent->pNext;
                while( pNextEvent->pNext && ( pNextEvent->mtTime == pNextEvent->pNext->mtTime ))
                {
                    if( pNextEvent->pNext->pos < pNextEvent->pos )
                    {
                        fSwap = TRUE;
                        pHoldEvent = pNextEvent->pNext;
                        pPrevEvent->pNext = pHoldEvent;
                        pNextEvent->pNext = pHoldEvent->pNext;
                        pHoldEvent->pNext = pNextEvent;
                        pPrevEvent = pHoldEvent;
                        continue;
                    }
                    pPrevEvent = pNextEvent;
                    pNextEvent = pNextEvent->pNext;
                }
            }
        }
    }
    // remove the first, temporary event, added above
    lstEvent = lstEvent->pNext;

    pPrevEvent = NULL;
    // combine note on and note offs
    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pNextEvent )
    {
        pEvent->pTempNext = NULL;
        pNextEvent = pEvent->pNext;
        //nChannel = pEvent->bStatus & 0xf;
        nChannel = pEvent->dwPChannel;
        if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            // add this event to the end of the list of events based
            // on the event's pitch. Keeping track of multiple events
            // of the same pitch allows us to have overlapping notes
            // of the same pitch, choosing that note on's and note off's
            // follow in the same order.
            if( NULL == paNoteOnEvent[nChannel][pEvent->bByte1] )
            {
                paNoteOnEvent[nChannel][pEvent->bByte1] = pEvent;
            }
            else
            {
                FullSeqEvent* pScan;
                for( pScan = paNoteOnEvent[nChannel][pEvent->bByte1];
                     pScan->pTempNext != NULL; pScan = pScan->pTempNext );
                pScan->pTempNext = pEvent;
            }
        }
        else if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEOFF )
        {
            if( paNoteOnEvent[nChannel][pEvent->bByte1] != NULL )
            {
                paNoteOnEvent[nChannel][pEvent->bByte1]->mtDuration =
                    pEvent->mtTime - paNoteOnEvent[nChannel][pEvent->bByte1]->mtTime;
                paNoteOnEvent[nChannel][pEvent->bByte1] =
                    paNoteOnEvent[nChannel][pEvent->bByte1]->pTempNext;
            }
            if( pPrevEvent == NULL )
            {
                lstEvent = pNextEvent;
            }
            else
            {
                pPrevEvent->pNext = pNextEvent;
            }
            delete pEvent;
            continue;
        }
        pPrevEvent = pEvent;
    }

    for( pEvent = lstEvent ; pEvent != NULL ; pEvent = pEvent->pNext )
    {
        pEvent->mtTime = pEvent->mtTime;
        if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            pEvent->mtDuration = pEvent->mtDuration;
            if( pEvent->mtDuration == 0 ) pEvent->mtDuration = 1;
        }
    }

    return lstEvent;
}

static int CompareEvents( FullSeqEvent* pEvent1, FullSeqEvent* pEvent2 )
{
    BYTE bEventType1 = static_cast<BYTE>( pEvent1->bStatus >> 4 );
    BYTE bEventType2 = static_cast<BYTE>( pEvent2->bStatus >> 4 );

    if( pEvent1->mtTime < pEvent2->mtTime )
    {
        return -1;
    }
    else if( pEvent1->mtTime > pEvent2->mtTime )
    {
        return 1;
    }
    else if( bEventType1 != ET_SYSX && bEventType2 != ET_SYSX )
    {
        BYTE bStatus1;
        BYTE bStatus2;

        bStatus1 = (BYTE)( pEvent1->bStatus & 0xf0 );
        bStatus2 = (BYTE)( pEvent2->bStatus & 0xf0 );
        if( bStatus1 == bStatus2 )
        {
            return 0;
        }
        else if( bStatus1 == MIDI_NOTEON )
        {
            return -1;
        }
        else if( bStatus2 == MIDI_NOTEON )
        {
            return 1;
        }
        else if( bStatus1 > bStatus2 )
        {
            return 1;
        }
        else if( bStatus1 < bStatus2 )
        {
            return -1;
        }
    }
    return 0;
}

static FullSeqEvent* MergeEvents( FullSeqEvent* lstLeftEvent, FullSeqEvent* lstRightEvent )
{
    FullSeqEvent  anchorEvent;
    FullSeqEvent* pEvent;

    anchorEvent.pNext = NULL;
    pEvent = &anchorEvent;

    do
    {
    if( CompareEvents( lstLeftEvent, lstRightEvent ) < 0 )
    {
        pEvent->pNext = lstLeftEvent;
        pEvent = lstLeftEvent;
        lstLeftEvent = lstLeftEvent->pNext;
        if( lstLeftEvent == NULL )
        {
        pEvent->pNext = lstRightEvent;
        }
    }
    else
    {
        pEvent->pNext = lstRightEvent;
        pEvent = lstRightEvent;
        lstRightEvent = lstRightEvent->pNext;
        if( lstRightEvent == NULL )
        {
        pEvent->pNext = lstLeftEvent;
        lstLeftEvent = NULL;
        }
    }
    } while( lstLeftEvent != NULL );

    return anchorEvent.pNext;
}

static FullSeqEvent* SortEventList( FullSeqEvent* lstEvent )
{
    FullSeqEvent* pMidEvent;
    FullSeqEvent* pRightEvent;

    if( lstEvent != NULL && lstEvent->pNext != NULL )
    {
    pMidEvent = lstEvent;
    pRightEvent = pMidEvent->pNext->pNext;
    if( pRightEvent != NULL )
    {
        pRightEvent = pRightEvent->pNext;
    }
    while( pRightEvent != NULL )
    {
        pMidEvent = pMidEvent->pNext;
        pRightEvent = pRightEvent->pNext;
        if( pRightEvent != NULL )
        {
        pRightEvent = pRightEvent->pNext;
        }
    }
    pRightEvent = pMidEvent->pNext;
    pMidEvent->pNext = NULL;
    return MergeEvents( SortEventList( lstEvent ),
                SortEventList( pRightEvent ) );
    }
    return lstEvent;
}

static DWORD ReadEvent( LPSTREAM pStream, DWORD dwTime, FullSeqEvent** plstEvent, DMUS_IO_PATCH_ITEM** pplstPatchEvent )
{
    static BYTE bRunningStatus;

    gPos++;
    dwTime = ConvertTime(dwTime);

    DWORD dwBytes;
    DWORD dwLen;
    FullSeqEvent* pEvent;
    DMUS_IO_PATCH_ITEM* pPatchEvent;
    DMUS_IO_SYSEX_ITEM* pSysEx;
    BYTE b;

    BYTE* pbSysExData = NULL;

    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
    {
        return 0;
    }

    if( b < 0x80 )
    {
        StreamSeek( pStream, -1, STREAM_SEEK_CUR );
        b = bRunningStatus;
        dwBytes = 0;
    }
    else
    {
        dwBytes = 1;
    }

    if( b < 0xf0 )
    {
        bRunningStatus = (BYTE)b;

        switch( b & 0xf0 )
        {
        case MIDI_CCHANGE:
        case MIDI_PTOUCH:
        case MIDI_PBEND:
        case MIDI_NOTEOFF:
        case MIDI_NOTEON:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;

            pEvent = new FullSeqEvent;
            if( pEvent == NULL )
            {
                return 0;
            }

            pEvent->mtTime = dwTime;
            pEvent->nOffset = 0;
            pEvent->pos = gPos;
            pEvent->mtDuration = 0;
            pEvent->bStatus = bRunningStatus & 0xf0;
            pEvent->dwPChannel = bRunningStatus & 0xf;
            pEvent->bByte1 = b;
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                delete pEvent;
                return dwBytes;
            }
            ++dwBytes;
            pEvent->bByte2 = b;

            if( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON &&
                pEvent->bByte2 == 0 )
            {
                pEvent->bStatus = (BYTE)( MIDI_NOTEOFF );
            }

            /*  If there are multiple controller events at the same time, seperate
                them by clock ticks. 
                gdwLastControllerTime holds the time of the last CC event.
                gdwControlCollisionOffset holds the number of colliding CCs.
            */

            if ((pEvent->bStatus & 0xf0) == MIDI_CCHANGE)
            {
                DWORD dwChannel = pEvent->dwPChannel;
                if (dwTime == gdwLastControllerTime[dwChannel])
                {
                    pEvent->mtTime += ++gdwControlCollisionOffset[dwChannel];
                }
                else
                {
                    gdwControlCollisionOffset[dwChannel] = 0;
                    gdwLastControllerTime[dwChannel] = dwTime;
                }
            }

            if(((pEvent->bStatus & 0xf0) == MIDI_CCHANGE) && (pEvent->bByte1 == 0 || pEvent->bByte1 == 0x20))
            {
                // We have a bank select or its LSB either of which are not added to event list
                if(pEvent->bByte1 == 0x20)
                {
                    gBankSelect[pEvent->dwPChannel].byLSB = pEvent->bByte2;
                }
                else // pEvent->bByte1 == 0
                {
                    gBankSelect[pEvent->dwPChannel].byMSB = pEvent->bByte2;
                }
                // We no longer need the event so we can free it
                delete pEvent;
            }
            else // Add to event list
            {
                pEvent->pNext = *plstEvent;
                *plstEvent = pEvent;
            }
            break;

        case MIDI_PCHANGE:
            if(FAILED(pStream->Read(&b, 1, NULL)))
            {
                return dwBytes;
            }
            
            ++dwBytes;

            pPatchEvent = new DMUS_IO_PATCH_ITEM;

            if(pPatchEvent == NULL)
            {
                return 0;
            }
            memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
            pPatchEvent->lTime = dwTime - 1;
            pPatchEvent->byStatus = bRunningStatus;
            pPatchEvent->byPChange = b;
            pPatchEvent->byMSB = gBankSelect[bRunningStatus & 0xF].byMSB;
            pPatchEvent->byLSB = gBankSelect[bRunningStatus & 0xF].byLSB;
            pPatchEvent->dwFlags |= DMUS_IO_INST_PATCH;

            if((pPatchEvent->byMSB != 0xFF) && (pPatchEvent->byLSB != 0xFF))
            {
                pPatchEvent->dwFlags |= DMUS_IO_INST_BANKSELECT;                        
            }

            gPatchTable[bRunningStatus & 0xF] = 1;

            pPatchEvent->pNext = *pplstPatchEvent;
            pPatchEvent->pIDMCollection = NULL;

            *pplstPatchEvent = pPatchEvent;

            break;

        case MIDI_MTOUCH:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;
            pEvent = new FullSeqEvent;
            if( pEvent == NULL )
            {
                return 0;
            }


            pEvent->mtTime = dwTime;
            pEvent->nOffset = 0;
            pEvent->pos = gPos;
            pEvent->mtDuration = 0;
            pEvent->bStatus = bRunningStatus & 0xf0;
            pEvent->dwPChannel = bRunningStatus & 0xf;
            pEvent->bByte1 = b;
            pEvent->pNext = *plstEvent;
            *plstEvent = pEvent;
            break;
        default:
            // this should NOT be possible - unknown midi note event type
            ASSERT(FALSE);
            break;
        }
    }
    else
    {
        switch( b )
        {
        case 0xf0:
            dwBytes += GetVarLength( pStream, dwLen );
            pSysEx = new DMUS_IO_SYSEX_ITEM;
            if( pSysEx != NULL )
            {
                pbSysExData = new BYTE[dwLen + 1];
                if( pbSysExData != NULL )
                {
                    MUSIC_TIME mt = dwTime;
                    if (mt == 0)
                    {
                        mt = glLastSysexTime++;
                        if (mt > 0) mt = 0;
                    }
                    pbSysExData[0] = 0xf0;
                    if( FAILED( pStream->Read( pbSysExData + 1, dwLen, NULL ) ) )
                    {
                        delete [] pbSysExData;
                        delete pSysEx;
                        return dwBytes;
                    }

                    if( pbSysExData[1] == 0x43 )
                    {
                        // check for XG files
                        BYTE abXG[] = { 0xF0, 0x43, 0x10, 0x4C, 0x00, 0x00, 0x7E, 0x00, 0xF7 };
                        int i;
                        for( i = 0; i < 8; i++ )
                        {
                            if( i == 2 )
                            {
                                if( ( pbSysExData[i] & 0xF0 ) != abXG[i] )
                                    break;
                            }
                            else
                            {
                                if( pbSysExData[i] != abXG[i] )
                                    break;
                            }
                        }
                        if( i == 8 ) // we have an XG!
                        {
                            TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                            if (!pPair) return dwBytes;
                            pPair->GetItemValue().mtTime = mt;
                            pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_XG;
                            InsertMidiMode(pPair);
                        }
                    }
                    else if( pbSysExData[1] == 0x41 )
                    {
                        // check for GS files
                        BYTE abGS[] = { 0xF0,0x41,0x00,0x42,0x12,0x40,0x00,0x7F,0x00,0x41,0xF7 };
                        int i;
                        for( i = 0; i < 10; i++ )
                        {
                            if( i != 2 )
                            {
                                if( pbSysExData[i] != abGS[i] )
                                    break;
                            }
                        }
                        if( i == 10 ) // we have a GS!
                        {
                            TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                            if (!pPair) return dwBytes;
                            pPair->GetItemValue().mtTime = mt;
                            pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GS;
                            InsertMidiMode(pPair);
                        }
                    }
                    else if (( pbSysExData[1] == 0x7E ) && (pbSysExData[3] == 0x09))
                    {
                        TListItem<StampedGMGSXG>* pPair = new TListItem<StampedGMGSXG>;
                        if (!pPair) return dwBytes;
                        pPair->GetItemValue().mtTime = mt;
                        pPair->GetItemValue().dwMidiMode = DMUS_MIDIMODEF_GM;
                        InsertMidiMode(pPair);
                    }
                    pSysEx->mtTime = mt;
                    pSysEx->dwPChannel = 0;
                    DWORD dwTempLen = dwLen + 1;
                    pSysEx->dwSysExLength = dwTempLen;
                    if( NULL == gpSysExStream )
                    {
                        // create a stream to hold sysex events
                        CreateStreamOnHGlobal( NULL, TRUE, &gpSysExStream );
                        if( gpSysExStream )
                        {
                            DWORD dwTemp;
                            // write the chunk header
                            dwTemp = DMUS_FOURCC_SYSEX_TRACK;
                            gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
                            // write the overall size. (Replace this later with the
                            // true overall size.)
                            dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                            // overall size (to be replaced later)
                            gpSysExStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        }
                    }
                    if( gpSysExStream )
                    {
                        gpSysExStream->Write( &pSysEx->mtTime, sizeof(MUSIC_TIME), NULL );
                        gpSysExStream->Write( &pSysEx->dwPChannel, sizeof(DWORD), NULL );
                        gpSysExStream->Write( &pSysEx->dwSysExLength, sizeof(DWORD), NULL );
                        gpSysExStream->Write( pbSysExData, dwTempLen, NULL );
                        gdwSizeSysExStream += (sizeof(long) + sizeof(DWORD) + dwTempLen);
                    }
                    delete [] pbSysExData;
                    delete pSysEx;
                }
                else
                {
                    StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
                }
            }
            else
            {
                StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
            }
            dwBytes += dwLen;
            break;
        case 0xf7:
            // ignore sysex f7 chunks
            dwBytes += GetVarLength( pStream, dwLen );
            StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
            dwBytes += dwLen;
            break;
        case 0xff:
            if( FAILED( pStream->Read( &b, 1, NULL ) ) )
            {
                return dwBytes;
            }
            ++dwBytes;
            dwBytes += GetVarLength( pStream, dwLen );
            if( b == 0x51 ) // tempo change
            {
                DWORD dw = 0;
                DMUS_IO_TEMPO_ITEM tempo;

                while( dwLen > 0 )
                {
                    if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                    {
                        return dwBytes;
                    }
                    ++dwBytes;
                    --dwLen;
                    dw <<= 8;
                    dw += b;
                }
                if (dw < 1) dw = 1;
                tempo.dblTempo = 60000000.0 / ((double)dw);
                tempo.lTime = dwTime;
                if( NULL == gpTempoStream )
                {
                    // create a stream to hold tempo events
                    CreateStreamOnHGlobal( NULL, TRUE, &gpTempoStream );
                    if( gpTempoStream )
                    {
                        DWORD dwTemp;
                        // write the chunk header
                        dwTemp = DMUS_FOURCC_TEMPO_TRACK;
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // write the overall size. (Replace this later with the
                        // true overall size.) Also write the size of the individual
                        // structure.
                        dwTemp = sizeof(DMUS_IO_TEMPO_ITEM);
                        // overall size (to be replaced later)
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // individual structure.
                        gpTempoStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    }
                }
                if( gpTempoStream )
                {
                    gpTempoStream->Write( &tempo, sizeof(DMUS_IO_TEMPO_ITEM), NULL );
                    gdwSizeTempoStream += sizeof(DMUS_IO_TEMPO_ITEM);
                }
            }
            else if( b == 0x58 && glTimeSig )
            {
                // glTimeSig will be set to 0 inside the main calling function
                // once we no longer care about time sigs.
                DMUS_IO_TIMESIGNATURE_ITEM timesig;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                // set glTimeSig to 2 to signal to the main function that we've
                // read a time sig on this track
                glTimeSig = 2;
                gTimeSig.lTime = timesig.lTime = dwTime;
                gTimeSig.bBeatsPerMeasure = timesig.bBeatsPerMeasure = b;
                ++dwBytes;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                gTimeSig.bBeat = timesig.bBeat = (BYTE)( 1 << b ); // 0 means 256th note
                gTimeSig.wGridsPerBeat = timesig.wGridsPerBeat = 4; // this is irrelavent for MIDI files
                
                if( NULL == gpTimeSigStream )
                {
                    CreateStreamOnHGlobal( NULL, TRUE, &gpTimeSigStream );
                    if( gpTimeSigStream )
                    {
                        DWORD dwTemp;
                        // write the chunk header
                        dwTemp = DMUS_FOURCC_TIMESIGNATURE_TRACK;
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // write the overall size. (Replace this later with the
                        // true overall size.) Also write the size of the individual
                        // structure.
                        dwTemp = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                        // overall size (to be replaced later)
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        // individual structure.
                        gpTimeSigStream->Write( &dwTemp, sizeof(DWORD), NULL );
                        gdwSizeTimeSigStream += sizeof(DWORD);
                    }
                }
                if( gpTimeSigStream )
                {
                    gpTimeSigStream->Write( &timesig, sizeof(DMUS_IO_TIMESIGNATURE_ITEM), NULL );
                    gdwSizeTimeSigStream += sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
                }
                ++dwBytes;
                StreamSeek( pStream, dwLen - 2, STREAM_SEEK_CUR );
                dwBytes += ( dwLen - 2 );
            }
            else if( b == 0x59 )
            {
                // Read sharps/flats and major/minor bytes
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                char cSharpsFlats = b;
                ++dwBytes;
                if( FAILED( pStream->Read( &b, 1, NULL ) ) )
                {
                    return dwBytes;
                }
                BYTE bMode = b;
                ++dwBytes;

                // Create a chord (with one subchord) from the key info
                CreateChordFromKey(cSharpsFlats, bMode, dwTime, g_Chord);

                // If the chord track is empty, create it.
                if (!g_pChordTrack)
                {
                    HRESULT hr = CoCreateInstance( 
                            CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC,
                            IID_IDirectMusicTrack,
                            (void**)&g_pChordTrack );
                    if (!SUCCEEDED(hr)) return dwBytes;

                    // If dwTime > 0, use SetParam to insert the default chord at time 0
                    if (dwTime > 0)
                    {
                        g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
                    }
                }

                // Use SetParam to insert the new chord into the chord track
                g_pChordTrack->SetParam(GUID_ChordParam, dwTime, &g_Chord);

            }
            else
            {
                StreamSeek( pStream, dwLen, STREAM_SEEK_CUR );
                dwBytes += dwLen;
            }
            break;
        default:
            break;
        }
    }
    return dwBytes;
}

static void AddOffsets(FullSeqEvent* lstEvent, IDirectMusicTrack* pTimeSigTrack)
{
    HRESULT hr;
    MUSIC_TIME mtNext = 0;
    DMUS_IO_TIMESIGNATURE_ITEM timesig;
    timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
    timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
    timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    timesig.lTime = 0;
    short nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;

    if (pTimeSigTrack)
    {
        hr = pTimeSigTrack->GetParam(GUID_TimeSignature, 0, &mtNext, (void*)&timesig);
        if (FAILED(hr))
        {
            mtNext = 0;
        }
        else
        {
            nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
        }
    }

    for( FullSeqEvent* pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
    {
        if ( ( pEvent->bStatus & 0xf0 ) == MIDI_NOTEON )
        {
            if (mtNext && pTimeSigTrack && mtNext < pEvent->mtTime)
            {
                hr = pTimeSigTrack->GetParam(GUID_TimeSignature, mtNext, &mtNext, (void*)&timesig);
                if (FAILED(hr))
                {
                    mtNext = 0;
                }
                else
                {
                    nClocksPerGrid = ((DMUS_PPQ * 4) / timesig.bBeat) / timesig.wGridsPerBeat;
                }
            }
            ASSERT(nClocksPerGrid);
            if( 0 == nClocksPerGrid ) nClocksPerGrid = 1; // this should never happen, but just in case.
            pEvent->nOffset = (short) ((pEvent->mtTime - timesig.lTime) % nClocksPerGrid);
            pEvent->mtTime -= pEvent->nOffset;
            if (pEvent->nOffset > (nClocksPerGrid / 2))
            {
                // make it a negative offset and bump the time a corresponding amount
                pEvent->nOffset -= nClocksPerGrid;
                pEvent->mtTime += nClocksPerGrid;
            }
        }
    }

}

/*

  @method HRESULT | IDirectMusicPerformance | CreateSegmentFromMIDIStream |
  Given a MIDI stream, creates a Segment that can be played via
  <im IDirectMusicPerformance.PlaySegment>.

  @parm LPSTREAM | pStream |
  [in] The MIDI stream. It should be set to the correct seek to begin reading.
  @parm IDirectMusicSegment* | pSegment |
  [out] A pointer to contain the created Segment.

  @rvalue DMUS_E_CANNOTREAD | There was an error attempting to read the MIDI file.
  @rvalue S_OK

*/
HRESULT CreateSegmentFromMIDIStream(LPSTREAM pStream,
                                    IDirectMusicSegment* pSegment)
{
    if(pSegment == NULL || pStream == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = DMUS_E_CANNOTREAD;
    DWORD dwID;
    DWORD dwCurTime;
    DWORD dwLength;
    DWORD dwSize;
    short nFormat;
    short nNumTracks;
    short nTracksRead;
     FullSeqEvent* lstEvent;
    DMUS_IO_PATCH_ITEM* lstPatchEvent;
    FullSeqEvent* lstTrackEvent;
    HRESULT hrGM = S_OK;


    EnterCriticalSection(&g_CritSec);
    gpTempoStream = NULL;
    gpSysExStream = NULL;
    gpTimeSigStream = NULL;
    gdwSizeTimeSigStream = 0;
    gdwSizeSysExStream = 0;
    gdwSizeTempoStream = 0;
    glTimeSig = 1; // flag to see if we should be paying attention to time sigs.
    // this is needed because we only care about the time sigs on the first track to
    // contain them that we read
    g_pChordTrack = NULL;

    lstEvent = NULL;
    lstPatchEvent = NULL;
    nNumTracks = nTracksRead = 0;
    dwLength = 0;
    gPos = 0;
    gMidiModeList.CleanUp();
    if (g_pChordTrack)
    {
        g_pChordTrack->Release();
        g_pChordTrack = NULL;
    }
    CreateChordFromKey(0, 0, 0, g_Chord);
    CreateChordFromKey(0, 0, 0, g_DefaultChord);

    memset(&gBankSelect, 0xFF, (sizeof(DMUS_IO_BANKSELECT_ITEM) * NUM_MIDI_CHANNELS));
    memset(&gPatchTable, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS));
    memset(&gTimeSig, 0, sizeof(DMUS_IO_TIMESIGNATURE_ITEM));
    memset(&gdwLastControllerTime, 0xFF, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    memset(&gdwControlCollisionOffset, 0, (sizeof(DWORD) * NUM_MIDI_CHANNELS)); 
    glLastSysexTime = -5;

    if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
        !GetMLong( pStream, dwSize ) )
    {
        Trace(1,"Error: Failure parsing MIDI file.\n");
        LeaveCriticalSection(&g_CritSec);
        return DMUS_E_CANNOTREAD;
    }
// check for RIFF MIDI files
    if( dwID == mmioFOURCC( 'R', 'I', 'F', 'F' ) )
    {
        StreamSeek( pStream, 12, STREAM_SEEK_CUR );
        if( ( S_OK != pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) ||
            !GetMLong( pStream, dwSize ) )
        {
            Trace(1,"Error: Failure parsing MIDI file.\n");
            LeaveCriticalSection(&g_CritSec);
            return DMUS_E_CANNOTREAD;
        }
    }
// check for normal MIDI files
    if( dwID != mmioFOURCC( 'M', 'T', 'h', 'd' ) )
    {
        LeaveCriticalSection(&g_CritSec);
        Trace(1,"Error: Failure parsing MIDI file - can't find a valid header.\n");
        return DMUS_E_CANNOTREAD;
    }

    GetMShort( pStream, nFormat );
    GetMShort( pStream, nNumTracks );
    GetMShort( pStream, snPPQN );
    if( dwSize > 6 )
    {
        StreamSeek( pStream, dwSize - 6, STREAM_SEEK_CUR );
    }
    pStream->Read( &dwID, sizeof( FOURCC ), NULL );
    while( dwID == mmioFOURCC( 'M', 'T', 'r', 'k' ) )
    {
        GetMLong( pStream, dwSize );
        dwCurTime = 0;
        lstTrackEvent = NULL;

        long lSize = (long)dwSize;
        while( lSize > 0 )
        {
            long lReturn;
            lSize -= GetVarLength( pStream, dwID );
            dwCurTime += dwID;
            if (lSize > 0)
            {
                lReturn = ReadEvent( pStream, dwCurTime, &lstTrackEvent, &lstPatchEvent );
                if( lReturn )
                {
                    lSize -= lReturn;
                }
                else
                {
                    Trace(1,"Error: Failure parsing MIDI file.\n");
                    hr = DMUS_E_CANNOTREAD;
                    goto END;
                }
            }
        }
        dwSize = lSize;
        if( glTimeSig > 1 )
        {
            // if glTimeSig is greater than 1, it means we've read some time sigs
            // from this track (it was set to 2 inside ReadEvent.) This means that
            // we no longer want ReadEvent to pay any attention to time sigs, so
            // we set this to 0.
            glTimeSig = 0;
        }
        if( dwCurTime > dwLength )
        {
            dwLength = dwCurTime;
        }
        lstTrackEvent = ScanForDuplicatePBends( lstTrackEvent );
        lstTrackEvent = SortEventList( lstTrackEvent );
        lstTrackEvent = CompressEventList( lstTrackEvent );
        lstEvent = List_Cat( lstEvent, lstTrackEvent );
        if( FAILED( pStream->Read( &dwID, sizeof( FOURCC ), NULL ) ) )
        {
            break;
        }
    }
    dwLength = ConvertTime(dwLength);

    lstEvent = SortEventList( lstEvent );

//    if( lstEvent ) Removed: this might be just a band, or sysex data, or whatever.
    {
        if(pSegment)
        {
            IPersistStream* pIPSTrack;
            IDirectMusicTrack*    pDMTrack;

            hr = S_OK;

            if (!g_pChordTrack)
            {
                hr = CoCreateInstance( 
                        CLSID_DirectMusicChordTrack, NULL, CLSCTX_INPROC,
                        IID_IDirectMusicTrack,
                        (void**)&g_pChordTrack );
                if (SUCCEEDED(hr))
                {
                    g_pChordTrack->SetParam(GUID_ChordParam, 0, &g_DefaultChord);
                }
            }
            if (SUCCEEDED(hr))
            {
                pSegment->InsertTrack( g_pChordTrack, 1 );
                g_pChordTrack->Release();
                g_pChordTrack = NULL;
            }

            // Note: We could be checking to see if there are actually tempo events,
            // sysex events, etc. to see if it's really necessary to create these
            // tracks...
            // Create a Tempo Track in which to store the tempo events
            if( gpTempoStream )
            {
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTempoTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    StreamSeek( gpTempoStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpTempoStream->Write( &gdwSizeTempoStream, sizeof(DWORD), NULL );
                    StreamSeek( gpTempoStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpTempoStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }

            // Add a patch event for each MIDI channel that does not have one
            DMUS_IO_PATCH_ITEM* pPatchEvent = NULL;
            for(DWORD i = 0; i < 16; i++)
            {
                if(gPatchTable[i] == 0)
                {
                    pPatchEvent = new DMUS_IO_PATCH_ITEM;

                    if(pPatchEvent == NULL)
                    {
                        continue;
                    }
                    
                    memset(pPatchEvent, 0, sizeof(DMUS_IO_PATCH_ITEM));
                    pPatchEvent->lTime = ConvertTime(0);
                    pPatchEvent->byStatus = 0xC0 + (BYTE)(i & 0xf);
                    pPatchEvent->dwFlags |= (DMUS_IO_INST_PATCH);
                    pPatchEvent->pIDMCollection = NULL;
                    pPatchEvent->fNotInFile = TRUE;

                    pPatchEvent->pNext = lstPatchEvent;
                    lstPatchEvent = pPatchEvent;
                }
            }

            if(lstPatchEvent)
            {
                // Create Band Track in which to store patch change events
                IDirectMusicBandTrk* pBandTrack;

                if(SUCCEEDED(CoCreateInstance(CLSID_DirectMusicBandTrack,
                                              NULL, 
                                              CLSCTX_INPROC, 
                                              IID_IDirectMusicBandTrk,
                                              (void**)&pBandTrack)))
                {
                    // Get the loader from stream so we can open a required collections
                    IDirectMusicGetLoader* pIDMGetLoader = NULL;
                    IDirectMusicLoader* pIDMLoader = NULL;
    
                    hr = pStream->QueryInterface(IID_IDirectMusicGetLoader, (void**)&pIDMGetLoader);
                    if( SUCCEEDED(hr) )
                    {
                        hr = pIDMGetLoader->GetLoader(&pIDMLoader);
                        pIDMGetLoader->Release();
                    }
                    // IStream needs a loader attached
                    assert(SUCCEEDED(hr));

                    // Populate the the Band Track with patch change events
                    for(DMUS_IO_PATCH_ITEM* pEvent = lstPatchEvent; pEvent; pEvent = lstPatchEvent)
                    {
                        // Remove instrument from head of list and give to band
                        DMUS_IO_PATCH_ITEM* temp = pEvent->pNext;
                        pEvent->pNext = NULL;
                        lstPatchEvent = temp;

                        // We will try to load the collection but if we can not we will continure
                        // and use the default GM on the card
                        if(pIDMLoader)
                        {
                            HRESULT hrTemp = LoadCollection(&pEvent->pIDMCollection, pIDMLoader);
                            if (FAILED(hrTemp))
                            {
                                hrGM = hrTemp;
                            }
                        }

                        hr = pBandTrack->AddBand(pEvent);

                        // Release reference to collection
                        if(pEvent->pIDMCollection)
                        {
                            (pEvent->pIDMCollection)->Release();
                            pEvent->pIDMCollection = NULL;
                        }
                        delete pEvent;

                        if(FAILED(hr))
                        {
                            break;                        
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
        
                        TListItem<StampedGMGSXG>* pPair = gMidiModeList.GetHead();
                        if( NULL == pPair )
                        {
                            // if we had nothing, generate a GM one so the band knows
                            // it was loaded from a midi file
                            // since the first band is set to play at -1,
                            // this is when the default midi mode must occur.
                            pBandTrack->SetGMGSXGMode(-1, DMUS_MIDIMODEF_GM);
                        }
                        for ( ; pPair; pPair = pPair->GetNext() )
                        {
                            StampedGMGSXG& rPair = pPair->GetItemValue();
                            pBandTrack->SetGMGSXGMode(rPair.mtTime, rPair.dwMidiMode);
                        }
                        gMidiModeList.CleanUp();

                        if(SUCCEEDED(pBandTrack->QueryInterface(IID_IDirectMusicTrack, 
                                                                (void**)&pDMTrack)))
                        {
                            pSegment->InsertTrack(pDMTrack, 1);
                            pDMTrack->Release();
                        }
                    }
                    
                    if(pBandTrack)
                    {
                        pBandTrack->Release();
                    }

                    if(pIDMLoader)
                    {
                        pIDMLoader->Release();
                    }
                }

            }

            if( gpTimeSigStream )
            {
                // Create a TimeSig Track to store the TimeSig events
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicTimeSigTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    // set the overall size to the correct size
                    StreamSeek( gpTimeSigStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpTimeSigStream->Write( &gdwSizeTimeSigStream, sizeof(DWORD), NULL );
                    // reset to beginning and persist to track.
                    StreamSeek( gpTimeSigStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpTimeSigStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        AddOffsets(lstEvent, pDMTrack);
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }
            else
            {
                AddOffsets(lstEvent, NULL);
            }

            lstEvent = SortEventList( lstEvent );

            // Create a Sequence Track in which to store the notes, curves,
            // and SysEx events.
            //
            if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicSeqTrack,
                NULL, CLSCTX_INPROC, IID_IPersistStream,
                (void**)&pIPSTrack )))
            {
                // Create a stream in which to place the events so we can
                // give it to the SeqTrack.Load.
                IStream* pEventStream;

                if( S_OK == CreateStreamOnHGlobal( NULL, TRUE, &pEventStream ) )
                {
                    // angusg: The implementation of memory IStream interface on
                    // CE can be inefficient if the stream memory isn't allocated
                    // before. It will call LocalRealloc on every IStream->Write
                    // for the amount that is written (in this case a small amount)
                    // this is incredible inefficient here as Realloc can be called
                    // thousands of times....
                    // The solution is to pre calculate the size of the stream and
                    // call ISteam->SetSize(), which calls LocalAlloc, to alloc the
                    // memory in one call.

                    // calculate the size of the stream storage
                    DWORD   dwStreamStorageSize;
                    FullSeqEvent* pEvent;

                    // add the size of the chunk id's written below
                    dwStreamStorageSize = 5 * sizeof(DWORD);
                    // now count how many events need to be stored in the stream
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        dwStreamStorageSize += sizeof(DMUS_IO_SEQ_ITEM);
                    }

                    ULARGE_INTEGER liSize;

                    liSize.QuadPart = dwStreamStorageSize;
                    // make the stream allocate the complete amount of memory
                    pEventStream->SetSize(liSize);

                    // Save the events into the stream
                    ULONG    cb, cbWritten;

                    // Save the chunk id
                    DWORD dwTemp = DMUS_FOURCC_SEQ_TRACK;
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Save the overall size. Count the number of events to determine.
                    dwSize = 0;
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        dwSize++;
                    }
                    dwSize *= sizeof(DMUS_IO_SEQ_ITEM);
                    // add 8 for the subchunk
                    dwSize += 8;
                    pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
                    // Save the subchunk id
                    dwTemp = DMUS_FOURCC_SEQ_LIST;
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Subtract the previously added 8
                    dwSize -= 8;
                    // Save the size of the subchunk
                    pEventStream->Write( &dwSize, sizeof(DWORD), NULL );
                    // Save the structure size.
                    dwTemp = sizeof(DMUS_IO_SEQ_ITEM);
                    pEventStream->Write( &dwTemp, sizeof(DWORD), NULL );
                    // Save the events.
                    cb = sizeof(DMUS_IO_SEQ_ITEM); // doesn't have the next pointers
                    for( pEvent = lstEvent; pEvent; pEvent = pEvent->pNext )
                    {
                        if( dwLength < (DWORD)(pEvent->mtTime + pEvent->mtDuration) )
                        {
                            dwLength = pEvent->mtTime + pEvent->mtDuration;
                        }
                        pEventStream->Write( pEvent, cb, &cbWritten );
                        if( cb != cbWritten ) // error!
                        {
                            pEventStream->Release();
                            pEventStream = NULL;
                            hr = DMUS_E_CANNOTREAD;
                            break;
                        }
                    }

                    if( pEventStream ) // may be NULL
                    {
                        StreamSeek( pEventStream, 0, STREAM_SEEK_SET );
                        pIPSTrack->Load( pEventStream );
                        pEventStream->Release();
                    }
                }

                if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                    (void**)&pDMTrack ) ) )
                {
                    pSegment->InsertTrack( pDMTrack, 1 );
                    pDMTrack->Release();
                }
                pIPSTrack->Release();
            }
            // set the length of the segment. Set it to the measure boundary
            // past the last note.
            DWORD dwResolvedLength = gTimeSig.lTime;
            if( 0 == gTimeSig.bBeat ) gTimeSig.bBeat = 4;
            if( 0 == gTimeSig.bBeatsPerMeasure ) gTimeSig.bBeatsPerMeasure = 4;
            if( 0 == gTimeSig.wGridsPerBeat ) gTimeSig.wGridsPerBeat = 4;
            while( dwResolvedLength < dwLength )
            {
                dwResolvedLength += (((DMUS_PPQ * 4) / gTimeSig.bBeat) * gTimeSig.bBeatsPerMeasure);
            }
            pSegment->SetLength( dwResolvedLength );

            if( gpSysExStream )
            {
                // Create a SysEx Track in which to store the SysEx events
                if( SUCCEEDED( CoCreateInstance( CLSID_DirectMusicSysExTrack,
                    NULL, CLSCTX_INPROC, IID_IPersistStream,
                    (void**)&pIPSTrack )))
                {
                    // write overall length
                    StreamSeek( gpSysExStream, sizeof(DWORD), STREAM_SEEK_SET );
                    gpSysExStream->Write( &gdwSizeSysExStream, sizeof(DWORD), NULL );
                    // seek to beginning and persist to track
                    StreamSeek( gpSysExStream, 0, STREAM_SEEK_SET );
                    pIPSTrack->Load( gpSysExStream );

                    if( SUCCEEDED( pIPSTrack->QueryInterface( IID_IDirectMusicTrack, 
                        (void**)&pDMTrack ) ) )
                    {
                        pSegment->InsertTrack( pDMTrack, 1 );
                        pDMTrack->Release();
                    }
                    pIPSTrack->Release();
                }
            }

        }
        else
        {
            hr = E_POINTER;
        }
    }
END:
    List_Free( lstEvent );
    List_Free( lstPatchEvent );

    FullSeqEvent::CleanUp();

    // release our hold on the streams
    RELEASE( gpTempoStream );
    RELEASE( gpSysExStream );
    RELEASE( gpTimeSigStream );
    gpTempoStream = NULL;
    gpSysExStream = NULL;
    gpTimeSigStream = NULL;
    gdwSizeTimeSigStream = 0;
    gdwSizeSysExStream = 0;
    gdwSizeTempoStream = 0;
    LeaveCriticalSection(&g_CritSec);

    if (SUCCEEDED(hrGM) || hr != S_OK )
    {
        return hr;
    }
    else
    {
        return DMUS_S_PARTIALLOAD;
    }
}

// Creates and returns (in rChord) a DMUS_CHORD_PARAM given the three input params.
// the new chord will have one subchord containing the root, third, fifth, and seventh
// of the key (as indicated by the sharps/flats and mode).  Scale will be either
// major or minor, depending on the mode (mode is 0 if major, 1 if minor).
void CreateChordFromKey(char cSharpsFlats, BYTE bMode, DWORD dwTime, DMUS_CHORD_PARAM& rChord)
{
    static DWORD dwMajorScale = 0xab5ab5;    // 1010 1011 0101 1010 1011 0101
    static DWORD dwMinorScale = 0x5ad5ad;    // 0101 1010 1101 0101 1010 1101
    static DWORD dwMajor7Chord = 0x891;        // 1000 1001 0001
    static DWORD dwMinor7Chord = 0x489;        // 0100 1000 1001
    BYTE bScaleRoot = 0;
    switch (cSharpsFlats)
    {
    case  0: bScaleRoot = bMode ?  9 :  0; break;
    case  1: bScaleRoot = bMode ?  4 :  7; break;
    case  2: bScaleRoot = bMode ? 11 :  2; break;
    case  3: bScaleRoot = bMode ?  6 :  9; break;
    case  4: bScaleRoot = bMode ?  1 :  4; break;
    case  5: bScaleRoot = bMode ?  8 : 11; break;
    case  6: bScaleRoot = bMode ?  3 :  6; break;
    case  7: bScaleRoot = bMode ? 10 :  1; break;
    case -1: bScaleRoot = bMode ?  2 :  5; break;
    case -2: bScaleRoot = bMode ?  7 : 10; break;
    case -3: bScaleRoot = bMode ?  0 :  3; break;
    case -4: bScaleRoot = bMode ?  5 :  8; break;
    case -5: bScaleRoot = bMode ? 10 :  1; break;
    case -6: bScaleRoot = bMode ?  3 :  6; break;
    case -7: bScaleRoot = bMode ?  8 : 11; break;
    }
    if (bMode)
    {
        wcscpy(rChord.wszName, L"m7");
    }
    else
    {
        wcscpy(rChord.wszName, L"M7");
    }
    DMUS_IO_TIMESIGNATURE_ITEM timesig;
    timesig.bBeat = gTimeSig.bBeat ? gTimeSig.bBeat : 4;
    timesig.bBeatsPerMeasure = gTimeSig.bBeatsPerMeasure ? gTimeSig.bBeatsPerMeasure : 4;
    timesig.wGridsPerBeat = gTimeSig.wGridsPerBeat ? gTimeSig.wGridsPerBeat : 4;
    DWORD dwAbsBeat = dwTime / ((DMUS_PPQ * 4) / timesig.bBeat);
    rChord.wMeasure = (WORD)(dwAbsBeat / timesig.bBeatsPerMeasure);
    rChord.bBeat = (BYTE)(dwAbsBeat % timesig.bBeatsPerMeasure);
    rChord.bSubChordCount = 1;
    rChord.SubChordList[0].dwChordPattern = bMode ? dwMinor7Chord : dwMajor7Chord;
    rChord.SubChordList[0].dwScalePattern = bMode ? dwMinorScale : dwMajorScale;
    rChord.SubChordList[0].dwInversionPoints = 0xffffff;    // inversions allowed everywhere
    rChord.SubChordList[0].dwLevels = 0xffffffff;            // supports all levels
    rChord.SubChordList[0].bChordRoot = bScaleRoot;
    rChord.SubChordList[0].bScaleRoot = bScaleRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\pchmap.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */

#ifndef _PCHMAP__
#define _PCHMAP__
#include "dmusici.h"
#include "..\dmstyle\tlist.h"

struct PCHMAP_ITEM
{
	MUSIC_TIME	mtNext;
	DWORD		dwPChannel;
	DWORD		dwPChMap;
	BOOL		fMute;
};

class CPChMap
{
public:
	CPChMap();
	~CPChMap();
	void Reset(void);
	void GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
				  IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh , BOOL fClockTime);
private:
	TList<PCHMAP_ITEM>	m_PChMapList;
};
#endif // _PCHMAP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\ntfylist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// NtfyList.h

#include "alist.h"
#include "dmusici.h"
#include "debug.h"

#ifndef __NTFYLIST_H_
#define __NTFYLIST_H_

class CNotificationItem : public AListItem
{
public:
	CNotificationItem* GetNext()
	{
		return (CNotificationItem*)AListItem::GetNext();
	};
public:
	GUID	guidNotificationType;
    BOOL    fFromPerformance;
};

class CNotificationList : public AList
{
public:
    CNotificationItem* GetHead() 
	{
		return (CNotificationItem*)AList::GetHead();
	};
    CNotificationItem* RemoveHead() 
	{
		return (CNotificationItem*)AList::RemoveHead();
	};
    CNotificationItem* GetItem(LONG lIndex) 
	{
		return (CNotificationItem*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CNotificationItem* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
};

#endif // __NTFYLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\mutx.h ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\mutx.cpp ===
// Copyright (c) 1998 Microsoft Corporation
/* No longer used */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\segtrtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

// This track type holds events that cause other segments to be cued at
// specific points during playback of a segment.

#pragma once

#include "trackhelp.h"
#include "tlist.h"
#include "smartref.h"

//////////////////////////////////////////////////////////////////////
// Types

// Items in list of events
struct TriggerInfo
{
	TriggerInfo() : lTriggerTime(0), lTimePhysical(0), dwPlayFlags(0), dwFlags(0), pIDMSegment(NULL) {}
	~TriggerInfo() {
		RELEASE(pIDMSegment);
	}

	HRESULT Clone(const TriggerInfo &o, MUSIC_TIME mtStart)
	{
		lTriggerTime = o.lTriggerTime - mtStart;
		lTimePhysical = o.lTimePhysical - mtStart;
		dwPlayFlags = o.dwPlayFlags;
		dwFlags = o.dwFlags;
		pIDMSegment = o.pIDMSegment;
		pIDMSegment->AddRef();
		return S_OK;
	}

	// from event header chunk <scrh>
	MUSIC_TIME lTriggerTime; // Logical time
	MUSIC_TIME lTimePhysical;
	DWORD dwPlayFlags;
	DWORD dwFlags;
	// from reference <DMRF>
	IDirectMusicSegment *pIDMSegment;
};

// State data.  This track needs to get the audio path that's currently playing so that it
// can use it when playing triggered segments.
struct CSegTriggerTrackState : public CStandardStateData<TriggerInfo>
{
	CSegTriggerTrackState() : pAudioPath(NULL) {};
	~CSegTriggerTrackState() { if (pAudioPath) pAudioPath->Release(); }
	IDirectMusicAudioPath *pAudioPath;
};

//////////////////////////////////////////////////////////////////////
// CSegTriggerTrack

class CSegTriggerTrack;
typedef CPlayingTrack<CSegTriggerTrack, TriggerInfo, CSegTriggerTrackState> CSegTriggerTrackBase;

class CSegTriggerTrack
  : public CSegTriggerTrackBase
{
public:
	// When the segment trigger track plays one of its items, it plays a segment.  If an invalidation occurs, that Play operation
	// can't be retracted.  Then the track is played again (with the FLUSH bit set).  This was causing it to trigger the segment
	// a second time.  To fix this, the last parameter to the CSegTriggerTrackBase is false, which instructs it not to call play
	// a second time when the FLUSH bit is set.
	CSegTriggerTrack(HRESULT *pHr) : CSegTriggerTrackBase(&g_cComponent, CLSID_DirectMusicSegmentTriggerTrack, true, false), m_dwFlags(NULL), m_dwRecursionCount(0) {}

	// Implement SetParam by calling SetParam in turn on all the child segments.  This is needed, for example so that downloading a segment with a segment trigger track will download all the triggered segments as well.
	STDMETHOD(IsParamSupported)(REFGUID rguid) { return S_OK; } // Once or more of our child segments could potentially support any type of parameter.
	STDMETHOD(SetParam)(REFGUID rguid, MUSIC_TIME mtTime, void *pData);

	STDMETHOD(InitPlay)(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags);

protected:
	HRESULT PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime);
	HRESULT LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader);

private:
	HRESULT LoadTrigger(SmartRef::RiffIter ri, IDirectMusicLoader *pIDMLoader);

	// Data
	DWORD m_dwFlags; // from track header (sgth chunk)
    BOOL  m_dwRecursionCount; // Used to keep track of recursive calls to self.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\segtrtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CSegTriggerTrack.
//

#include "dmime.h"
#include "segtrtrk.h"
#include "..\shared\Validate.h"
#include "dmperf.h"
#include "miscutil.h"

//////////////////////////////////////////////////////////////////////
// SetParam

STDMETHODIMP
CSegTriggerTrack::SetParam(REFGUID rguid, MUSIC_TIME mtTime, void *pData)
{
	HRESULT hr = S_OK;
    // Allow a certain amount of recursion. If it gets to 10, something is obviously broken.
    if (m_dwRecursionCount < 10)
    {
        m_dwRecursionCount++;
	    TListItem<TriggerInfo> *li = m_EventList.GetHead();
	    for (; li; li = li->GetNext())
	    {
		    TriggerInfo &rinfo = li->GetItemValue();
		    rinfo.pIDMSegment->SetParam(rguid, 0xFFFFFFFF, DMUS_SEG_ALLTRACKS, mtTime - rinfo.lTimePhysical, pData);
	    }
        m_dwRecursionCount--;
    }

	return hr;
}

STDMETHODIMP
CSegTriggerTrack::InitPlay(
		IDirectMusicSegmentState *pSegmentState,
		IDirectMusicPerformance *pPerformance,
		void **ppStateData,
		DWORD dwTrackID,
		DWORD dwFlags)
{
	// Call PlayingTrack base class, which sets up our state data.
	HRESULT hr = CSegTriggerTrackBase::InitPlay(pSegmentState, pPerformance, ppStateData, dwTrackID, dwFlags);
	if (SUCCEEDED(hr))
	{
		// Get the audiopath being used by our segment state and save it in our state data.
		assert(*ppStateData); // base class should have created state data
		assert(pSegmentState); // base class should have returned E_POINTER if it wasn't given a segment state

		CSegTriggerTrackState *pState = static_cast<CSegTriggerTrackState *>(*ppStateData);

		IDirectMusicSegmentState8 *pSegSt8 = NULL;
		hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
		if (SUCCEEDED(hr))
		{
			hr = pSegSt8->GetObjectInPath(
							0,							// pchannel doesn't apply
							DMUS_PATH_AUDIOPATH,		// get the audiopath
							0,							// buffer index doesn't apply
							CLSID_NULL,					// clsid doesn't apply
							0,							// there should be only one audiopath
							IID_IDirectMusicAudioPath,
							reinterpret_cast<void**>(&pState->pAudioPath));

        	pSegSt8->Release();

			// If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
			// pAudioPath stays NULL and we'll play our triggered segments on the general performance.
			if (hr == DMUS_E_NOT_FOUND)
				hr = S_OK;
		}
	}
	return hr;
}

//////////////////////////////////////////////////////////////////////
// Load

// Helper used by the Load functions when we expected to find something
// but a RiffIter becomes false.  In this case, if it has a success HR
// indicating there were no more items then we return DMUS_E_INVALID_SEGMENTTRIGGERTRACK
// because the stream didn't contain the data we expected.  If it has a
// failure hr, it was unable to read from the stream and we return its HR.
HRESULT LoadHrFailOK(const SmartRef::RiffIter &ri)
{
	HRESULT hr = ri.hr();
	return SUCCEEDED(hr) ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
};

HRESULT
CSegTriggerTrack::LoadRiff(SmartRef::RiffIter &ri, IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGTRACK_LIST))
	{
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: List 'segt' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
	}

	SmartRef::RiffIter riTrackForm = ri.Descend();
	if (!riTrackForm)
		return riTrackForm.hr();

	for ( ; riTrackForm; ++riTrackForm)
	{
		if (riTrackForm.type() == SmartRef::RiffIter::Chunk)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGTRACK_CHUNK)
			{
				DMUS_IO_SEGMENT_TRACK_HEADER ioItem;
				hr = SmartRef::RiffIterReadChunk(riTrackForm, &ioItem);
				if (FAILED(hr))
					return hr;

				m_dwFlags = ioItem.dwFlags;
			}
		}
		else if (riTrackForm.type() == SmartRef::RiffIter::List)
		{
			if (riTrackForm.id() == DMUS_FOURCC_SEGMENTS_LIST)
			{
				SmartRef::RiffIter riSegList = riTrackForm.Descend();
				while (riSegList && riSegList.Find(SmartRef::RiffIter::List, DMUS_FOURCC_SEGMENT_LIST))
				{
					hr = LoadTrigger(riSegList.Descend(), pIDMLoader);
					if (FAILED(hr))
						return hr;
					++riSegList;
				}
				hr = riSegList.hr();
				if (FAILED(hr))
					return hr;
			}
		}
	}
	return riTrackForm.hr();
}

//////////////////////////////////////////////////////////////////////
// other methods

HRESULT
CSegTriggerTrack::PlayItem(
		const TriggerInfo &item,
		statedata &state,
		IDirectMusicPerformance *pPerf,
		IDirectMusicSegmentState* pSegSt,
		DWORD dwVirtualID,
		MUSIC_TIME mtOffset,
		REFERENCE_TIME rtOffset,
		bool fClockTime)
{
	IDirectMusicPerformance8 *pPerf8 = NULL;
	HRESULT hr = pPerf->QueryInterface(IID_IDirectMusicPerformance8, reinterpret_cast<void**>(&pPerf8));
	if (FAILED(hr))
		return hr;

	hr = pPerf8->PlaySegmentEx(
					item.pIDMSegment,
					NULL,														// not a song
					NULL,														// no transition
					item.dwPlayFlags | (fClockTime ? DMUS_SEGF_REFTIME : 0),	// flags
					fClockTime
						? item.lTimePhysical * REF_PER_MIL + rtOffset
						: item.lTimePhysical + mtOffset,						// time
					NULL,														// ignore returned segment state
					NULL,														// no replacement
					state.pAudioPath											// audio path to use (may be NULL indicating defualt)
					);
	pPerf8->Release();
    if (FAILED(hr))
    {
        Trace(0,"Segment Trigger Track failed segment playback\n");
        hr = S_OK; // Avoid an assert.
    }
	return hr;
}

HRESULT
CSegTriggerTrack::LoadTrigger(
		SmartRef::RiffIter ri,
		IDirectMusicLoader *pIDMLoader)
{
	HRESULT hr = S_OK;

	if (!ri)
		return ri.hr();

	// Create an event
	TListItem<TriggerInfo> *pItem = new TListItem<TriggerInfo>;
	if (!pItem)
		return E_OUTOFMEMORY;
	TriggerInfo &rinfo = pItem->GetItemValue();

	// find the item header (we can't interpret the other chunks until we've found it)
	if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_SEGMENTITEM_CHUNK))
    {
        delete pItem;
#ifdef DBG
		if (SUCCEEDED(ri.hr()))
		{
			Trace(1, "Error: Unable to load segment trigger track: Chunk 'sgih' not found.\n");
		}
#endif
		return LoadHrFailOK(ri);
    }

	// read the header
	DMUS_IO_SEGMENT_ITEM_HEADER ioItem;
	hr = SmartRef::RiffIterReadChunk(ri, &ioItem);
	if (FAILED(hr))
    {
        delete pItem;
		return hr;
    }
	rinfo.lTriggerTime = ioItem.lTimeLogical;
	rinfo.lTimePhysical = ioItem.lTimePhysical;
	rinfo.dwPlayFlags = ioItem.dwPlayFlags;
	rinfo.dwFlags = ioItem.dwFlags;
	++ri;
	if (!ri)
	{
		// If there's nothing more then this is an empty trigger we should ignore because the user hasn't specified
		// the style or segment to play from.
		delete pItem;
		return ri.hr();
	}

	if (!(rinfo.dwFlags & DMUS_SEGMENTTRACKF_MOTIF))
	{
		// find the referenced segment
		if (!ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_REF_LIST))
		{
			// If there's no DMRF then we should ignore this trigger because the user hasn't specified a segment.
			delete pItem;
			return ri.hr();
        }

		hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicSegment, reinterpret_cast<void**>(&rinfo.pIDMSegment));
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}
	else
	{
		// find the segment from the referenced style and motif name
		SmartRef::ComPtr<IDirectMusicStyle> scomStyle;
		SmartRef::Buffer<WCHAR> wbufMotifName;
		for ( ; ri; ++ri)
		{
			if (ri.type() == SmartRef::RiffIter::List)
			{
				if (ri.id() == DMUS_FOURCC_REF_LIST)
				{
					hr = ri.LoadReference(pIDMLoader, IID_IDirectMusicStyle, reinterpret_cast<void**>(&scomStyle));
					if (FAILED(hr))
                    {
                        delete pItem;
						return hr;
                    }
				}
			}
			else if (ri.type() == SmartRef::RiffIter::Chunk)
			{
				if (ri.id() == DMUS_FOURCC_SEGMENTITEMNAME_CHUNK)
				{
					hr = ri.ReadText(&wbufMotifName);
					if (FAILED(hr))
                    {
                        delete pItem;
#ifdef DBG
						if (hr == E_FAIL)
						{
							Trace(1, "Error: Unable to load segment trigger track: Problem reading 'snam' chunk.\n");
						}
#endif
						return hr == E_FAIL ? DMUS_E_INVALID_SEGMENTTRIGGERTRACK : hr;
                    }
				}
			}
		}
		hr = ri.hr();
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }

		if (!(scomStyle && wbufMotifName))
		{
			// This happens if the track didn't contain a DMRF list or snam chunk.	We allow
			// this as a means of representing an empty trigger track item or where the
			// motif to play hasn't been specified.  When loading we'll simply ignore
			// this item and continue reading the track.
			delete pItem;
			return S_OK;
		}

		hr = scomStyle->GetMotif(wbufMotifName, &rinfo.pIDMSegment);
		if (hr == S_FALSE)
		{
			Trace(1, "Error: The segment trigger track couldn't load because the motif %S was not found in the style.\n", wbufMotifName);
			hr = DMUS_E_NOT_FOUND;
		}
		if (FAILED(hr))
        {
            delete pItem;
			return hr;
        }
	}

	m_EventList.AddHead(pItem);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\seqtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SeqTrack.h : Declaration of the CSeqTrack

#ifndef __SEQTRACK_H_
#define __SEQTRACK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\tlist.h"
#include "PChMap.h"

struct SeqStateData
{
	DWORD						dwPChannelsUsed; // number of PChannels
	// the following two arrays are allocated to the size of dwNumPChannels, which
	// must match the SeqTrack's m_dwPChannelsUsed. The arrays match one-for-one with
	// the parts inside the SeqTrack.
	TListItem<DMUS_IO_SEQ_ITEM>**	apCurrentSeq; // array of size dwNumPChannels
	TListItem<DMUS_IO_CURVE_ITEM>**	apCurrentCurve; // array of size dwNumPChannels
	DWORD						dwValidate;
	MUSIC_TIME					mtCurTimeSig; // time the current timesig started
	MUSIC_TIME					mtNextTimeSig; // time for the next timesig
	DWORD						dwMeasure; // starting measure # of the timesig
	DWORD						dwlnBeat; // length of a beat
	DWORD						dwlnMeasure; // length of a measure
	DWORD						dwlnGrid; // length of a grid
	DWORD						dwGroupBits; // the group bits of this track

	SeqStateData()
	{
		mtCurTimeSig = 0;
		mtNextTimeSig = 0;
		dwMeasure = 0;
		dwlnBeat = DMUS_PPQ;
		dwlnMeasure = DMUS_PPQ * 4;
		dwlnGrid = DMUS_PPQ / 4;
		apCurrentSeq = NULL;
		apCurrentCurve = NULL;
	}
	~SeqStateData()
	{
		if( apCurrentSeq )
		{
			delete [] apCurrentSeq;
		}
		if( apCurrentCurve )
		{
			delete [] apCurrentCurve;
		}
	}
};

// SEQ_PART represents all of the DMUS_PMSG's inside the SeqTrack for one PChannel
struct SEQ_PART
{
	SEQ_PART*			pNext;
	DWORD				dwPChannel;
	TList<DMUS_IO_SEQ_ITEM>	seqList;
	TList<DMUS_IO_CURVE_ITEM>	curveList;

	SEQ_PART() : pNext(NULL) {}; // always initialize pNext to NULL
};

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
class CSeqTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSeqTrack();
	CSeqTrack(
		const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSeqTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT STDMETHODCALLTYPE Seek( 
		IDirectMusicSegmentState*,
		IDirectMusicPerformance*,
		DWORD dwVirtualID,
		SeqStateData*,
		MUSIC_TIME mtTime,
		BOOL fGetPrevious,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
	void SendSeekItem( 
		IDirectMusicPerformance*,
		IDirectMusicGraph*,
		IDirectMusicSegmentState*,
		SeqStateData* pSD,
		DWORD dwVirtualID,
		MUSIC_TIME mtTime,
		MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
		TListItem<DMUS_IO_SEQ_ITEM>*,
		TListItem<DMUS_IO_CURVE_ITEM>*,
        BOOL fClockTime);
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	void Construct(void);
	HRESULT LoadCurve( IStream* pIStream, long lSize );
	HRESULT LoadSeq( IStream* pIStream, long lSize );
	void UpdateTimeSig(IDirectMusicSegmentState*, SeqStateData* pSD, MUSIC_TIME mt);
	TListItem<SEQ_PART>* FindPart( DWORD dwPChannel );
	void DeleteSeqPartList(void);
	void SetUpStateCurrentPointers(SeqStateData* pStateData);

// member variables
private:
	TList<SEQ_PART>			m_SeqPartList;
	TListItem<SEQ_PART>*	m_pSeqPartCache;	// used to time-optimize FindPart()
	DWORD					m_dwPChannelsUsed;
	DWORD*					m_aPChannels;
	long					m_cRef;
	DWORD					m_dwValidate; // used to validate state data
	CRITICAL_SECTION		m_CrSec;
    BOOL                    m_fCSInitialized;
	CPChMap					m_PChMap;
};

#endif //__SEQTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\seqtrack.cpp ===
//
// seqtrack.cpp
//
// Copyright (c) 1998-2001 Microsoft Corporation
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
#pragma warning(disable:4530)

// SeqTrack.cpp : Implementation of CSeqTrack
#include "dmime.h"
#include "dmperf.h"
#include "SeqTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT assert

// @doc EXTERNAL
#define MIDI_NOTEOFF    0x80
#define MIDI_NOTEON     0x90
#define MIDI_PTOUCH     0xA0
#define MIDI_CCHANGE    0xB0
#define MIDI_PCHANGE    0xC0
#define MIDI_MTOUCH     0xD0
#define MIDI_PBEND      0xE0
#define MIDI_SYSX       0xF0
#define MIDI_MTC        0xF1
#define MIDI_SONGPP     0xF2
#define MIDI_SONGS      0xF3
#define MIDI_EOX        0xF7
#define MIDI_CLOCK      0xF8
#define MIDI_START      0xFA
#define MIDI_CONTINUE   0xFB
#define MIDI_STOP       0xFC
#define MIDI_SENSE      0xFE
#define MIDI_CC_BS_MSB  0x00
#define MIDI_CC_BS_LSB  0x20

/////////////////////////////////////////////////////////////////////////////
// CSeqTrack
void CSeqTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_pSeqPartCache = NULL;
    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwValidate = 0;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
    m_cRef = 1;
}

CSeqTrack::CSeqTrack()
{
    Construct();
}

CSeqTrack::CSeqTrack(
        const CSeqTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    m_dwPChannelsUsed = rTrack.m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (m_aPChannels)
        {
            memcpy( m_aPChannels, rTrack.m_aPChannels, sizeof(DWORD) * m_dwPChannelsUsed );
        }
    }

    TListItem<SEQ_PART>* pPart = rTrack.m_SeqPartList.GetHead();
    for( ; pPart; pPart = pPart->GetNext() )
    {
        TListItem<SEQ_PART>* pNewPart = new TListItem<SEQ_PART>;
        if( pNewPart )
        {
            pNewPart->GetItemValue().dwPChannel = pPart->GetItemValue().dwPChannel;
            TListItem<DMUS_IO_SEQ_ITEM>* pScan = pPart->GetItemValue().seqList.GetHead();

            for(; pScan; pScan = pScan->GetNext())
            {
                DMUS_IO_SEQ_ITEM& rScan = pScan->GetItemValue();
                if( rScan.mtTime < mtStart )
                {
                    continue;
                }
                if (rScan.mtTime < mtEnd)
                {
                    TListItem<DMUS_IO_SEQ_ITEM>* pNew = new TListItem<DMUS_IO_SEQ_ITEM>;
                    if (pNew)
                    {
                        DMUS_IO_SEQ_ITEM& rNew = pNew->GetItemValue();
                        memcpy( &rNew, &rScan, sizeof(DMUS_IO_SEQ_ITEM) );
                        rNew.mtTime = rScan.mtTime - mtStart;
                        pNewPart->GetItemValue().seqList.AddHead(pNew); // AddTail can get expensive (n^2), so
                                                    // AddHead instead and Reverse later.
                    }
                }
                else break;
            }
            pNewPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier.

            TListItem<DMUS_IO_CURVE_ITEM>* pScanCurve = pPart->GetItemValue().curveList.GetHead();

            for(; pScanCurve; pScanCurve = pScanCurve->GetNext())
            {
                DMUS_IO_CURVE_ITEM& rScan = pScanCurve->GetItemValue();
                if( rScan.mtStart < mtStart )
                {
                    continue;
                }
                if (rScan.mtStart < mtEnd)
                {
                    TListItem<DMUS_IO_CURVE_ITEM>* pNew = new TListItem<DMUS_IO_CURVE_ITEM>;
                    if (pNew)
                    {
                        DMUS_IO_CURVE_ITEM& rNew = pNew->GetItemValue();
                        memcpy( &rNew, &rScan, sizeof(DMUS_IO_CURVE_ITEM) );
                        rNew.mtStart = rScan.mtStart - mtStart;
                        pNewPart->GetItemValue().curveList.AddHead(pNew); // AddTail can get expensive (n^2), so
                                                    // AddHead instead and Reverse later.
                    }
                }
                else break;
            }
            pNewPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier.
            m_SeqPartList.AddHead(pNewPart);
        }
        m_SeqPartList.Reverse();
    }
}

CSeqTrack::~CSeqTrack()
{
    if (m_fCSInitialized)
    {
        DeleteSeqPartList();                // This will be empty if critical section
                                            // never got initialized.
        DeleteCriticalSection(&m_CrSec);
    }

    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CSeqTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSeqTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
    if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sequence Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CSeqTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSeqTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicSeqTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSeqTrack::IsDirty()
{
    return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | LoadSeq |
  Call this with an IStream filled with SeqEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SeqEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SeqEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SeqTrack is released.
*/
HRESULT CSeqTrack::LoadSeq( IStream* pIStream, long lSize )
{
    HRESULT hr = S_OK;
    TListItem<SEQ_PART>* pPart;

    EnterCriticalSection(&m_CrSec);

    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_SEQ_ITEM seqEvent;
    DWORD dwSubSize;
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_SEQ_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_SEQ_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        if( dwSubSize == 0 )
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( 0 == dwRead )
    {
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize > 0 )
    {
        if( FAILED( pIStream->Read( &seqEvent, dwRead, NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        lSize -= dwRead;
        if( dwSeek )
        {
            if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
            {
                hr = DMUS_E_CANNOTSEEK;
                goto END;
            }
            lSize -= dwSeek;
        }
        pPart = FindPart(seqEvent.dwPChannel);
        if( pPart )
        {
            TListItem<DMUS_IO_SEQ_ITEM>* pEvent = new TListItem<DMUS_IO_SEQ_ITEM>(seqEvent);
            if( pEvent )
            {
                pPart->GetItemValue().seqList.AddHead(pEvent); // AddTail can get
                                                            // expensive (n pow 2) so
                                                            // AddHead instead and reverse later.
            }
        }
    }
END:
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        pPart->GetItemValue().seqList.Reverse(); // since we AddHead'd earlier
    }
    m_dwValidate++; // used to validate state data that's out there
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
  method HRESULT | LoadCurve
  Call this with an IStream filled with CurveEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of CurveEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only CurveEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK | Success.
There are also other error codes.
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the CurveTrack is released.
*/
HRESULT CSeqTrack::LoadCurve( IStream* pIStream, long lSize )
{
    HRESULT hr = S_OK;
    TListItem<SEQ_PART>* pPart;

    EnterCriticalSection(&m_CrSec);

    DWORD dwSubSize;
    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_CURVE_ITEM curveEvent;
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_CURVE_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_CURVE_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        if( dwSubSize == 0 )
        {
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( 0 == dwRead )
    {
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize > 0 )
    {
        curveEvent.wMergeIndex = 0; // Older format doesn't support this.
        if( FAILED( pIStream->Read( &curveEvent, dwRead, NULL )))
        {
            hr = DMUS_E_CANNOTREAD;
            break;
        }
        lSize -= dwRead;
        if( dwSeek )
        {
            pIStream->Seek( li, STREAM_SEEK_CUR, NULL );
            lSize -= dwSeek;
        }
        pPart = FindPart(curveEvent.dwPChannel);
        if( pPart )
        {
            TListItem<DMUS_IO_CURVE_ITEM>* pEvent = new TListItem<DMUS_IO_CURVE_ITEM>(curveEvent);
            if( pEvent )
            {
                pPart->GetItemValue().curveList.AddHead(pEvent); // AddTail can get
                                                            // expensive (n pow 2) so
                                                            // AddHead instead and reverse later.
            }
        }
    }
END:
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        pPart->GetItemValue().curveList.Reverse(); // since we AddHead'd earlier
    }
    m_dwValidate++; // used to validate state data that's out there
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CSeqTrack::Load( IStream* pIStream )
{
    V_INAME(CSeqTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    DeleteSeqPartList();
    LeaveCriticalSection(&m_CrSec);

    // read in the chunk id
    long lSize;
    DWORD dwChunk;
    if( FAILED( pIStream->Read( &dwChunk, sizeof(DWORD), NULL )))
    {
        Trace(1,"Error: Failure reading sequence track.\n");
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    if( dwChunk != DMUS_FOURCC_SEQ_TRACK )
    {
        Trace(1,"Error: Failure reading sequence track - bad data.\n");
        hr = DMUS_E_CHUNKNOTFOUND;
        goto END;
    }
    // read in the overall size
    if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
    {
        hr = DMUS_E_CANNOTREAD;
        goto END;
    }
    while( lSize )
    {
        DWORD dwSubChunk, dwSubSize;
        if( FAILED( pIStream->Read( &dwSubChunk, sizeof(DWORD), NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        lSize -= sizeof(DWORD);
        // read in the overall size
        if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
        {
            Trace(1,"Error: Failure reading sequence track.\n");
            hr = DMUS_E_CANNOTREAD;
            goto END;
        }
        if( (dwSubSize == 0) || (dwSubSize > (DWORD)lSize) )
        {
            Trace(1,"Error: Failure reading sequence track - bad data.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
            goto END;
        }
        lSize -= sizeof(DWORD);
        switch( dwSubChunk )
        {
        case DMUS_FOURCC_SEQ_LIST:
            if( FAILED( hr = LoadSeq( pIStream, dwSubSize )))
            {
                goto END;
            }
            break;
        case DMUS_FOURCC_CURVE_LIST:
            if( FAILED( hr = LoadCurve( pIStream, dwSubSize )))
            {
                goto END;
            }
            break;
        default:
            LARGE_INTEGER li;
            li.HighPart = 0;
            li.LowPart = dwSubSize;
            if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
            {
                hr = DMUS_E_CANNOTREAD;
                goto END;
            }
            break;
        }
        lSize -= dwSubSize;
    }
END:
    return hr;
}

HRESULT CSeqTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSeqTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::IsParamSupported(
    REFGUID rguidType)    // @parm The guid identifying the type of data to check.
{
    return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CSeqTrack::Init(
    IDirectMusicSegment *pSegment)    // @parm Pointer to the Segment to which this Track belongs.
{
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CSeqTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf,    // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,        // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);

    SeqStateData* pStateData;
    pStateData = new SeqStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *ppStateData = pStateData;
    SetUpStateCurrentPointers(pStateData);
    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CSeqTrack::EndPlay(
    void *pStateData)    // @parm The state data returned from <om .InitPlay>.
{
    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(SeqStateData));
        SeqStateData* pSD = (SeqStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

void CSeqTrack::SetUpStateCurrentPointers(SeqStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentSeq )
        {
            delete [] pStateData->apCurrentSeq;
            pStateData->apCurrentSeq = NULL;
        }
        if( pStateData->apCurrentCurve )
        {
            delete [] pStateData->apCurrentCurve;
            pStateData->apCurrentCurve = NULL;
        }
        pStateData->apCurrentSeq = new TListItem<DMUS_IO_SEQ_ITEM>* [m_dwPChannelsUsed];
        pStateData->apCurrentCurve = new TListItem<DMUS_IO_CURVE_ITEM>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentSeq )
        {
            memset( pStateData->apCurrentSeq, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * m_dwPChannelsUsed );
        }
        if( pStateData->apCurrentCurve )
        {
            memset( pStateData->apCurrentCurve, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

// DeleteSeqPartList() - delete all parts in m_SeqPartList, and associated events.
void CSeqTrack::DeleteSeqPartList(void)
{
    EnterCriticalSection(&m_CrSec);
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    m_aPChannels = NULL;
    m_pSeqPartCache = NULL;
    if( m_SeqPartList.GetHead() )
    {
        TListItem<SEQ_PART>* pItem;
        while( pItem = m_SeqPartList.RemoveHead() )
        {
            TListItem<DMUS_IO_SEQ_ITEM>* pEvent;
            while( pEvent = pItem->GetItemValue().seqList.RemoveHead() )
            {
                delete pEvent;
            }
            TListItem<DMUS_IO_CURVE_ITEM>* pCurve;
            while( pCurve = pItem->GetItemValue().curveList.RemoveHead() )
            {
                delete pCurve;
            }
            delete pItem;
        }
    }
    LeaveCriticalSection(&m_CrSec);
}

// FindPart() - return the SEQ_PART corresponding to dwPChannel, or create one.
TListItem<SEQ_PART>* CSeqTrack::FindPart( DWORD dwPChannel )
{
    TListItem<SEQ_PART>* pPart;

    if( m_pSeqPartCache && (m_pSeqPartCache->GetItemValue().dwPChannel == dwPChannel) )
    {
        return m_pSeqPartCache;
    }
    for( pPart = m_SeqPartList.GetHead(); pPart; pPart = pPart->GetNext() )
    {
        if( pPart->GetItemValue().dwPChannel == dwPChannel )
        {
            break;
        }
    }
    if( NULL == pPart )
    {
        pPart = new TListItem<SEQ_PART>;
        if( pPart )
        {
            pPart->GetItemValue().dwPChannel = dwPChannel;
            m_SeqPartList.AddHead( pPart );
        }
        m_dwPChannelsUsed++;

        DWORD* aPChannels = new DWORD[m_dwPChannelsUsed];
        if( aPChannels )
        {
            if( m_aPChannels )
            {
                memcpy( aPChannels, m_aPChannels, sizeof(DWORD) * (m_dwPChannelsUsed - 1) );
            }
            aPChannels[m_dwPChannelsUsed - 1] = dwPChannel;
        }
        if( m_aPChannels )
        {
            delete [] m_aPChannels;
        }
        m_aPChannels = aPChannels;
    }
    m_pSeqPartCache = pPart;
    return pPart;
}

void CSeqTrack::UpdateTimeSig(IDirectMusicSegmentState* pSegSt,
                                         SeqStateData* pSD,
                                         MUSIC_TIME mt)
{
    // get a new time sig if needed
    if( (mt >= pSD->mtNextTimeSig) || (mt < pSD->mtCurTimeSig) )
    {
        IDirectMusicSegment* pSeg;
        DMUS_TIMESIGNATURE timesig;
        MUSIC_TIME mtNext;
        HRESULT hr;
        if(SUCCEEDED(hr = pSegSt->GetSegment(&pSeg)))
        {
            DWORD dwGroup;
            if( SUCCEEDED(hr = pSeg->GetTrackGroup( this, &dwGroup )))
            {
                if(SUCCEEDED(hr = pSeg->GetParam( GUID_TimeSignature, dwGroup,
                    0, mt, &mtNext, (void*)&timesig )))
                {
                    timesig.mtTime += mt;
                    if( pSD->dwlnMeasure )
                    {
                        pSD->dwMeasure = (timesig.mtTime - pSD->mtCurTimeSig) / pSD->dwlnMeasure;
                    }
                    else
                    {
                        pSD->dwMeasure = 0;
                    }
                    pSD->mtCurTimeSig = timesig.mtTime;
                    if( mtNext == 0 ) mtNext = 0x7fffffff;
                    pSD->mtNextTimeSig = mtNext;
                    if( timesig.bBeat )
                    {
                        pSD->dwlnBeat = DMUS_PPQ * 4 / timesig.bBeat;
                    }
                    pSD->dwlnMeasure = pSD->dwlnBeat * timesig.bBeatsPerMeasure;
                    if( timesig.wGridsPerBeat )
                    {
                        pSD->dwlnGrid = pSD->dwlnBeat / timesig.wGridsPerBeat;
                    }
                }
            }
            pSeg->Release();
        }
        if( FAILED(hr) )
        {
            // couldn't get time sig, default to 4/4
            pSD->mtNextTimeSig = 0x7fffffff;
            pSD->dwlnBeat = DMUS_PPQ;
            pSD->dwlnMeasure = DMUS_PPQ * 4;
            pSD->dwlnGrid = DMUS_PPQ / 4;
            pSD->dwMeasure = 0;
            pSD->mtCurTimeSig = 0;
        }
    }
    // make absolutely sure there is no way these can be 0, since we divide
    // by them.
    if( 0 == pSD->dwlnGrid ) pSD->dwlnGrid = DMUS_PPQ / 4;
    if( 0 == pSD->dwlnBeat ) pSD->dwlnBeat = DMUS_PPQ;
    if( 0 == pSD->dwlnMeasure ) pSD->dwlnMeasure = DMUS_PPQ * 4;
}

STDMETHODIMP CSeqTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CSeqTrack::Play(
    void *pStateData,    // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart,    // @parm The start time to play.
    MUSIC_TIME mtEnd,    // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,        // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf,    // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,    // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID    // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(SeqStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT    hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode.
*/

HRESULT CSeqTrack::Play(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT    hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    DMUS_PMSG* pEvent = NULL;
    SeqStateData* pSD = (SeqStateData*)pStateData;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }

    if( pSD->dwValidate != m_dwValidate )
    {
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & DMUS_TRACKF_START )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, TRUE, mtOffset, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, mtStart, FALSE, mtOffset, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;
    TListItem<SEQ_PART>* pPart = m_SeqPartList.GetHead();
    for( dwIndex = 0; pPart && (dwIndex < m_dwPChannelsUsed); dwIndex++,pPart = pPart->GetNext() )
    {
        dwPChannel = pPart->GetItemValue().dwPChannel;
        if( pSD->apCurrentCurve )
        {
            for( ; pSD->apCurrentCurve[dwIndex];
                pSD->apCurrentCurve[dwIndex] = pSD->apCurrentCurve[dwIndex]->GetNext() )
            {
                DMUS_IO_CURVE_ITEM& rItem = pSD->apCurrentCurve[dwIndex]->GetItemValue();
                if( rItem.mtStart >= mtEnd )
                {
                    break;
                }
                m_PChMap.GetInfo( dwPChannel, rItem.mtStart, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, fClockTime );
                if( !fMute )
                {
                    DMUS_CURVE_PMSG* pCurve;
                    if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                        (DMUS_PMSG**)&pCurve )))
                    {
                        pEvent = (DMUS_PMSG*)pCurve;
                        if (fClockTime)
                        {
                            pCurve->wMeasure = 0;
                            pCurve->bBeat = 0;
                            pCurve->bGrid = 0;
                            pCurve->nOffset = rItem.nOffset;
                            pCurve->rtTime = ((rItem.mtStart + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                            pCurve->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME | DMUS_PMSGF_DX8;
                        }
                        else
                        {
                            UpdateTimeSig( pSegSt, pSD, rItem.mtStart);
                            long lTemp = (rItem.mtStart - pSD->mtCurTimeSig);
                            pCurve->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                            lTemp = lTemp % pSD->dwlnMeasure;
                            pCurve->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                            lTemp = lTemp % pSD->dwlnBeat;
                            pCurve->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                            //pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid);
                            pCurve->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            pCurve->mtTime = rItem.mtStart + mtOffset + rItem.nOffset;
                            // Set the DX8 flag to indicate the wMergeIndex and wParamType fields are valid.
                            pCurve->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_DX8;
                        }
                        pCurve->dwPChannel = dwMutePChannel;
                        pCurve->dwVirtualTrackID = dwVirtualID;
                        pCurve->dwType = DMUS_PMSGT_CURVE;
                        pCurve->mtDuration = rItem.mtDuration;
                        pCurve->mtResetDuration = rItem.mtResetDuration;
                        pCurve->nStartValue = rItem.nStartValue;
                        pCurve->nEndValue = rItem.nEndValue;
                        pCurve->nResetValue = rItem.nResetValue;
                        pCurve->bType = rItem.bType;
                        pCurve->bCurveShape = rItem.bCurveShape;
                        pCurve->bCCData = rItem.bCCData;
                        pCurve->bFlags = rItem.bFlags;
                        pCurve->wParamType = rItem.wParamType;
                        pCurve->wMergeIndex = rItem.wMergeIndex;
                        pCurve->dwGroupID = pSD->dwGroupBits;

                        if( pGraph )
                        {
                            pGraph->StampPMsg( pEvent );
                        }
                        if(FAILED(pPerf->SendPMsg( pEvent )))
                        {
                            pPerf->FreePMsg(pEvent);
                        }
                    }
                }
            }
        }
        if( pSD->apCurrentSeq )
        {
            for( ; pSD->apCurrentSeq[dwIndex];
                pSD->apCurrentSeq[dwIndex] = pSD->apCurrentSeq[dwIndex]->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rItem = pSD->apCurrentSeq[dwIndex]->GetItemValue();
                if( rItem.mtTime >= mtEnd )
                {
                    break;
                }
                m_PChMap.GetInfo( dwPChannel, rItem.mtTime, mtOffset, pSD->dwGroupBits,
                                  pPerf, &fMute, &dwMutePChannel, fClockTime );
                if( !fMute )
                {
                    if( (rItem.bStatus & 0xf0) == 0x90 )
                    {
                        // this is a note event
                        DMUS_NOTE_PMSG* pNote;
                        if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_NOTE_PMSG),
                            (DMUS_PMSG**)&pNote )))
                        {
                            pNote->bFlags = DMUS_NOTEF_NOTEON;
                            pNote->mtDuration = rItem.mtDuration;
                            pNote->bMidiValue = rItem.bByte1;
                            pNote->bVelocity = rItem.bByte2;
                            pNote->dwType = DMUS_PMSGT_NOTE;
                            pNote->bPlayModeFlags = DMUS_PLAYMODE_FIXED;
                            pNote->wMusicValue = pNote->bMidiValue;
                            pNote->bSubChordLevel = 0;  // SUBCHORD_BASS
                            if (fClockTime)
                            {
                                pNote->rtTime = ((rItem.mtTime + rItem.nOffset) * REF_PER_MIL) + rtOffset;
                                pNote->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                pNote->wMeasure = 0;
                                pNote->bBeat = 0;
                                pNote->bGrid = 0;
                                pNote->nOffset = rItem.nOffset;
                            }
                            else
                            {
                                pNote->mtTime = rItem.mtTime + mtOffset + rItem.nOffset;
                                UpdateTimeSig( pSegSt, pSD, rItem.mtTime );
                                pNote->dwFlags = DMUS_PMSGF_MUSICTIME;
                                long lTemp = (rItem.mtTime - pSD->mtCurTimeSig);
                                pNote->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                                lTemp = lTemp % pSD->dwlnMeasure;
                                pNote->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                                lTemp = lTemp % pSD->dwlnBeat;
                                pNote->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                                //pNote->nOffset = (short)(lTemp % pSD->dwlnGrid);
                                pNote->nOffset = (short)(lTemp % pSD->dwlnGrid) + rItem.nOffset;
                            }
                            pNote->bTimeRange = 0;
                            pNote->bDurRange = 0;
                            pNote->bVelRange = 0;
                            pNote->cTranspose = 0;
                            pEvent = (DMUS_PMSG*)pNote;
                        }
                    }
                    else
                    {
                        // it's a MIDI short that's not a note
                        DMUS_MIDI_PMSG* pMidi;
                        if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
                            (DMUS_PMSG**)&pMidi )))
                        {
                            pMidi->bStatus = rItem.bStatus & 0xf0;
                            pMidi->bByte1 = rItem.bByte1;
                            pMidi->bByte2 = rItem.bByte2;
                            pMidi->dwType = DMUS_PMSGT_MIDI;
                            if (fClockTime)
                            {
                                pMidi->rtTime = (rItem.mtTime * REF_PER_MIL) + rtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                            }
                            else
                            {
                                pMidi->mtTime = rItem.mtTime + mtOffset;
                                pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                            }
                            pEvent = (DMUS_PMSG*)pMidi;
                        }
                    }
                    if( pEvent )
                    {
                        pEvent->dwPChannel = dwMutePChannel;
                        pEvent->dwVirtualTrackID = dwVirtualID;
                        pEvent->dwGroupID = pSD->dwGroupBits;
                        if( pGraph )
                        {
                            pGraph->StampPMsg( pEvent );
                        }
                        if(FAILED(pPerf->SendPMsg( pEvent )))
                        {
                            pPerf->FreePMsg(pEvent);
                        }
                    }
                }
            }
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// SendSeekItem() - sends either the pSeq or pCurve, depending on which occurs
// latest. Sends the item at mtTime + mtOffset.
void CSeqTrack::SendSeekItem( IDirectMusicPerformance* pPerf,
                                        IDirectMusicGraph* pGraph,
                                        IDirectMusicSegmentState* pSegSt,
                                        SeqStateData* pSD,
                                        DWORD dwVirtualID,
                                        MUSIC_TIME mtTime,
                                        MUSIC_TIME mtOffset,
                                        REFERENCE_TIME rtOffset,
                                        TListItem<DMUS_IO_SEQ_ITEM>* pSeq,
                                        TListItem<DMUS_IO_CURVE_ITEM>* pCurve,
                                        BOOL fClockTime)
{
    DWORD dwMutePChannel;
    BOOL fMute;

    if( pSeq )
    {
        DMUS_IO_SEQ_ITEM& rSeq = pSeq->GetItemValue();
        if( pCurve )
        {
            DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
            if( rSeq.mtTime >= rCurve.mtStart + rCurve.mtDuration )
            {
                // the seq item happens after the curve item. Send the
                // seq item and clear the curve item so it doesn't go out.
                pCurve = NULL;
            }
        }
        // if pCurve is NULL or was set to NULL, send out the seq item
        if( NULL == pCurve )
        {
            m_PChMap.GetInfo( rSeq.dwPChannel, rSeq.mtTime, mtOffset, pSD->dwGroupBits,
                pPerf, &fMute, &dwMutePChannel, fClockTime );
            if( !fMute )
            {
                DMUS_MIDI_PMSG* pMidi;
                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_MIDI_PMSG),
                    (DMUS_PMSG**)&pMidi )))
                {
                    pMidi->bStatus = rSeq.bStatus & 0xf0;
                    pMidi->bByte1 = rSeq.bByte1;
                    pMidi->bByte2 = rSeq.bByte2;
                    pMidi->dwType = DMUS_PMSGT_MIDI;

                    ASSERT( mtTime > rSeq.mtTime ); // this is true for back-seeking
                    if (fClockTime)
                    {
                        pMidi->rtTime = (mtTime * REF_PER_MIL) + rtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pMidi->mtTime = mtTime + mtOffset;
                        pMidi->dwFlags |= DMUS_PMSGF_MUSICTIME;
                    }
                    pMidi->dwPChannel = dwMutePChannel;
                    pMidi->dwVirtualTrackID = dwVirtualID;
                    pMidi->dwGroupID = pSD->dwGroupBits;
                    if( pGraph )
                    {
                        pGraph->StampPMsg( (DMUS_PMSG*)pMidi );
                    }
                    if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pMidi )))
                    {
                        pPerf->FreePMsg((DMUS_PMSG*)pMidi);
                    }
                }
            }
        }
    }

    if( pCurve )
    {
        DMUS_IO_CURVE_ITEM& rCurve = pCurve->GetItemValue();
        m_PChMap.GetInfo( rCurve.dwPChannel, rCurve.mtStart, mtOffset, pSD->dwGroupBits,
            pPerf, &fMute, &dwMutePChannel, fClockTime );
        if( !fMute )
        {
            DMUS_CURVE_PMSG* pCurvePmsg;
            if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_CURVE_PMSG),
                (DMUS_PMSG**)&pCurvePmsg )))
            {
                if (fClockTime) // If clock time, don't fill in time signature info, it's useless.
                {
                    pCurvePmsg->wMeasure = 0;
                    pCurvePmsg->bBeat = 0;
                    pCurvePmsg->bGrid = 0;
                    pCurvePmsg->nOffset = 0;
                    pCurvePmsg->rtTime = ((mtTime + rCurve.nOffset) * REF_PER_MIL) + rtOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                }
                else
                {
                    UpdateTimeSig( pSegSt, pSD, rCurve.mtStart);
                    long lTemp = (rCurve.mtStart - pSD->mtCurTimeSig);
                    pCurvePmsg->wMeasure = (WORD)((lTemp / pSD->dwlnMeasure) + pSD->dwMeasure);
                    lTemp = lTemp % pSD->dwlnMeasure;
                    pCurvePmsg->bBeat = (BYTE)(lTemp / pSD->dwlnBeat);
                    lTemp = lTemp % pSD->dwlnBeat;
                    pCurvePmsg->bGrid = (BYTE)(lTemp / pSD->dwlnGrid);
                    pCurvePmsg->nOffset = (short)(lTemp % pSD->dwlnGrid) + rCurve.nOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_MUSICTIME;
                    ASSERT( mtTime > rCurve.mtStart );// this is true for back-seeking
                    // in any case, play curve at mtTime + mtOffset + pCurvePmsg->nOffset
                    pCurvePmsg->mtTime = mtTime + mtOffset + rCurve.nOffset;
                    pCurvePmsg->dwFlags = DMUS_PMSGF_MUSICTIME;
                }

                pCurvePmsg->dwPChannel = dwMutePChannel;
                pCurvePmsg->dwVirtualTrackID = dwVirtualID;
                pCurvePmsg->dwType = DMUS_PMSGT_CURVE;
                pCurvePmsg->bType = rCurve.bType;
                pCurvePmsg->bCCData = rCurve.bCCData;
                pCurvePmsg->bFlags = rCurve.bFlags;
                pCurvePmsg->dwGroupID = pSD->dwGroupBits;
                pCurvePmsg->nStartValue = rCurve.nStartValue;
                pCurvePmsg->nEndValue = rCurve.nEndValue;
                pCurvePmsg->nResetValue = rCurve.nResetValue;

                if( mtTime >= rCurve.mtStart + rCurve.mtDuration )
                {
                    // playing at a time past the curve's duration. Just play
                    // an instant curve at that time instead. Instant curves
                    // play at their endvalue. Duration is irrelavant.
                    pCurvePmsg->bCurveShape = DMUS_CURVES_INSTANT;
                    if( pCurvePmsg->bFlags & DMUS_CURVE_RESET )
                    {
                        if( mtTime >= rCurve.mtStart + rCurve.mtDuration +
                            rCurve.mtResetDuration + rCurve.nOffset )
                        {
                            // don't need the curve reset any more
                            pCurvePmsg->bFlags &= ~DMUS_CURVE_RESET;
                        }
                        else
                        {
                            // otherwise make sure the reset event happens at the same time
                            // it would have if we weren't seeking back.
                            pCurvePmsg->mtResetDuration = rCurve.mtStart + rCurve.mtDuration +
                                rCurve.mtResetDuration + rCurve.nOffset - mtTime;
                        }
                    }
                }
                else
                {
                    // playing at a time in the middle of a curve.
                    pCurvePmsg->bCurveShape = rCurve.bCurveShape;
                    if (fClockTime)
                    {
                        pCurvePmsg->mtOriginalStart = mtTime - (rCurve.mtStart + mtOffset + rCurve.nOffset);
                    }
                    else
                    {
                        pCurvePmsg->mtOriginalStart = rCurve.mtStart + mtOffset + rCurve.nOffset;
                    }
                    if( pCurvePmsg->bCurveShape != DMUS_CURVES_INSTANT )
                    {
                        pCurvePmsg->mtDuration = rCurve.mtStart + rCurve.mtDuration - mtTime;
                    }
                    pCurvePmsg->mtResetDuration = rCurve.mtResetDuration;
                }

                if( pGraph )
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pCurvePmsg );
                }
                if(FAILED(pPerf->SendPMsg( (DMUS_PMSG*)pCurve )))
                {
                    pPerf->FreePMsg((DMUS_PMSG*)pCurve);
                }
            }
        }
    }
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// also send control change, pitch bend, curves, etc. that are in the past so the
// state at mtTime is as if we played from the beginning of the track.
HRESULT CSeqTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    SeqStateData* pSD, MUSIC_TIME mtTime, BOOL fGetPrevious,
    MUSIC_TIME mtOffset, REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<SEQ_PART>* pPart;
    TListItem<DMUS_IO_SEQ_ITEM>* pSeqItem;
    TListItem<DMUS_IO_CURVE_ITEM>* pCurveItem;

    // in the case of mtTime == 0 and fGetPrevious (which means DMUS_SEGF_START was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious && ( mtTime == 0 ) )
    {
        pPart = m_SeqPartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pSeqItem = pPart->GetItemValue().seqList.GetHead();
                if( pSeqItem && pSD->apCurrentSeq )
                {
                    pSD->apCurrentSeq[dwIndex] = pSeqItem;
                }
                pCurveItem = pPart->GetItemValue().curveList.GetHead();
                if( pCurveItem && pSD->apCurrentCurve )
                {
                    pSD->apCurrentCurve[dwIndex] = pCurveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

#define CC_1    96
    // CC_1 is the limit of the CC#'s we pay attention to. CC#96 through #101
    // are registered and non-registered parameter #'s, and data increment and
    // decrement, which we are choosing to ignore.

    TListItem<DMUS_IO_SEQ_ITEM>*    apSeqItemCC[ CC_1 ];
    TListItem<DMUS_IO_CURVE_ITEM>*    apCurveItemCC[ CC_1 ];
    TListItem<DMUS_IO_SEQ_ITEM>*    pSeqItemMonoAT;
    TListItem<DMUS_IO_CURVE_ITEM>*    pCurveItemMonoAT;
    TListItem<DMUS_IO_SEQ_ITEM>*    pSeqItemPBend;
    TListItem<DMUS_IO_CURVE_ITEM>*    pCurveItemPBend;
    IDirectMusicGraph* pGraph;
    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    pPart = m_SeqPartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            memset(apSeqItemCC, 0, sizeof(TListItem<DMUS_IO_SEQ_ITEM>*) * CC_1);
            memset(apCurveItemCC, 0, sizeof(TListItem<DMUS_IO_CURVE_ITEM>*) * CC_1);
            pSeqItemMonoAT = NULL;
            pCurveItemMonoAT = NULL;
            pSeqItemPBend = NULL;
            pCurveItemPBend = NULL;

            // scan the seq event list in this part, storing any CC, MonoAT, and PBend
            // events we come across.
            for( pSeqItem = pPart->GetItemValue().seqList.GetHead(); pSeqItem; pSeqItem = pSeqItem->GetNext() )
            {
                DMUS_IO_SEQ_ITEM& rSeqItem = pSeqItem->GetItemValue();
                if( rSeqItem.mtTime >= mtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
                switch( rSeqItem.bStatus & 0xf0 )
                {
                case MIDI_CCHANGE:
                    // ignore Registered and Non-registered Parameters,
                    // Data increment, Data decrement, and Data entry MSB and LSB.
                    if( ( rSeqItem.bByte1 < CC_1 ) && ( rSeqItem.bByte1 != 6 ) &&
                        ( rSeqItem.bByte1 != 38 ) )
                    {
                        apSeqItemCC[ rSeqItem.bByte1 ] = pSeqItem;
                    }
                    break;
                case MIDI_MTOUCH:
                    pSeqItemMonoAT = pSeqItem;
                    break;
                case MIDI_PBEND:
                    pSeqItemPBend = pSeqItem;
                    break;
                default:
                    break;
                }
            }
            if( pSD->apCurrentSeq )
            {
                pSD->apCurrentSeq[dwIndex] = pSeqItem;
            }
            // scan the curve event list in this part, storing any CC, MonoAT, and PBend
            // events we come across
            for( pCurveItem = pPart->GetItemValue().curveList.GetHead(); pCurveItem; pCurveItem = pCurveItem->GetNext() )
            {
                DMUS_IO_CURVE_ITEM& rCurveItem = pCurveItem->GetItemValue();
                if( rCurveItem.mtStart >= mtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
                switch( rCurveItem.bType )
                {
                case DMUS_CURVET_CCCURVE:
                    if( ( rCurveItem.bCCData < CC_1 ) && ( rCurveItem.bCCData != 6 ) &&
                        ( rCurveItem.bCCData != 38 ) )
                    {
                        if( apCurveItemCC[ rCurveItem.bCCData ] )
                        {
                            DMUS_IO_CURVE_ITEM& rTemp = apCurveItemCC[ rCurveItem.bCCData ]->GetItemValue();
                            if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                                rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                            {
                                apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
                            }
                        }
                        else
                        {
                            apCurveItemCC[ rCurveItem.bCCData ] = pCurveItem;
                        }
                    }
                    break;
                case DMUS_CURVET_MATCURVE:
                    if( pCurveItemMonoAT )
                    {
                        DMUS_IO_CURVE_ITEM& rTemp = pCurveItemMonoAT->GetItemValue();
                        if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                            rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                        {
                            pCurveItemMonoAT = pCurveItem;
                        }
                    }
                    else
                    {
                        pCurveItemMonoAT = pCurveItem;
                    }
                    break;
                case DMUS_CURVET_PBCURVE:
                    if( pCurveItemPBend )
                    {
                        DMUS_IO_CURVE_ITEM& rTemp = pCurveItemPBend->GetItemValue();
                        if( rCurveItem.mtStart + rCurveItem.mtDuration + rCurveItem.nOffset >
                            rTemp.mtStart + rTemp.mtDuration + rTemp.nOffset )
                        {
                            pCurveItemPBend = pCurveItem;
                        }
                    }
                    else
                    {
                        pCurveItemPBend = pCurveItem;
                    }
                    break;
                default:
                    break;
                }
            }
            if( pSD->apCurrentCurve )
            {
                pSD->apCurrentCurve[dwIndex] = pCurveItem;
            }
            if( fGetPrevious )
            {
                DWORD dwCC;
                // create and send past events appropriately
                SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemPBend, pCurveItemPBend, fClockTime );
                SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, pSeqItemMonoAT, pCurveItemMonoAT, fClockTime );
                for( dwCC = 0; dwCC < CC_1; dwCC++ )
                {
                    SendSeekItem( pPerf, pGraph, pSegSt, pSD, dwVirtualID, mtTime, mtOffset, rtOffset, apSeqItemCC[dwCC], apCurveItemCC[dwCC], fClockTime );
                }
            }
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::GetParam(
    REFGUID rguidType,    // @parm The type of data to obtain.
    MUSIC_TIME mtTime,    // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CSeqTrack::SetParam(
    REFGUID rguidType,    // @parm The type of data to set.
    MUSIC_TIME mtTime,    // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CSeqTrack::Clone(
    MUSIC_TIME mtStart,    // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,    // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time is %ld.\n",mtStart);
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        Trace(1,"Error: Invalid clone parameters to Sequence Track, start time %ld is greater than end %ld.\n",mtStart,mtEnd);
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);
    CSeqTrack *pDM;

    try
    {
        pDM = new CSeqTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    return hr;
}


STDMETHODIMP CSeqTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSeqTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\pchmap.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
/* This is a class to manage tracking mutes for the SeqTrack and BandTrack. */
#include "PChMap.h"
#include "dmusicf.h"

CPChMap::CPChMap()
{
}

CPChMap::~CPChMap()
{
}

// Reset sets all item's mtNext time values to -1, so they are gotten again.
void CPChMap::Reset(void)
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rItem = pItem->GetItemValue();
		rItem.mtNext = -1;
		rItem.dwPChMap = rItem.dwPChannel;
        rItem.fMute = 0;
	}
}

// GetInfo calls the performance's GetData to get the current Mute Track information.
// Reset() will be called upon any invalidation or seek, which will set the
// internal times to -1 so this will be accurate in case of a new controlling segment.
// You must provide the pfMute and pdwNewPCh parameters to this function, or
// it will crash.
void CPChMap::GetInfo( DWORD dwPCh, MUSIC_TIME mtTime, MUSIC_TIME mtOffset, DWORD dwGroupBits,
					   IDirectMusicPerformance* pPerf, BOOL* pfMute, DWORD* pdwNewPCh, BOOL fClockTime )
{
	TListItem<PCHMAP_ITEM>* pItem;
	
	for( pItem = m_PChMapList.GetHead(); pItem; pItem = pItem->GetNext() )
	{
		PCHMAP_ITEM& rCheck = pItem->GetItemValue();
		if( rCheck.dwPChannel == dwPCh ) break;
	}
	if( NULL == pItem )
	{
		PCHMAP_ITEM item;
		item.mtNext = -1;
		item.dwPChannel = item.dwPChMap = dwPCh;
		item.fMute = FALSE;
		pItem = new TListItem<PCHMAP_ITEM>(item);
		if( NULL == pItem )
		{
			// error, out of memory.
			*pfMute = FALSE;
			*pdwNewPCh = dwPCh;
			return;
		}
		m_PChMapList.AddHead(pItem);
	}
	PCHMAP_ITEM& rItem = pItem->GetItemValue();
	if( mtTime >= rItem.mtNext )
	{
		DMUS_MUTE_PARAM muteParam;
		MUSIC_TIME mtNext;
		muteParam.dwPChannel = dwPCh;
        if (fClockTime)
        {
            MUSIC_TIME mtMusic;
            REFERENCE_TIME rtTime = (mtTime + mtOffset) * 10000;
            pPerf->ReferenceToMusicTime(rtTime,&mtMusic);
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtMusic, 
			    &mtNext, (void*)&muteParam )))
		    {
                REFERENCE_TIME rtNext;
                // Convert to absolute reference time.
                pPerf->MusicToReferenceTime(mtNext + mtMusic,&rtNext);
                rtNext -= rtTime;   // Subtract out to get the delta.
			    rItem.mtNext = (MUSIC_TIME)(rtNext / 10000);  // Convert to delta in milliseconds. BUGBUG What if there's a tempo change?
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }

        }
        else
        {
		    if( SUCCEEDED(pPerf->GetParam( GUID_MuteParam, dwGroupBits, 0, mtTime + mtOffset, 
			    &mtNext, (void*)&muteParam )))
		    {
			    rItem.mtNext = mtNext;
			    rItem.dwPChMap = muteParam.dwPChannelMap;
			    rItem.fMute = muteParam.fMute;
		    }
		    else
		    {
			    // no mute track, or no mute on this pchannel.
			    // keep the current mapping.
			    rItem.mtNext = 0x7fffffff;
		    }
        }
	}
	*pfMute = rItem.fMute;
	*pdwNewPCh = rItem.dwPChMap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\paramtrk.h ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

// This track holds curve information for automation (like automating sliders on a mixing board -- not OLE automation)
// of effects and tools in the audio path.

#pragma once

#include "trackhelp.h"
//#include "imediaobjectparams.h"
//#include "mediaobj.h" //  need to get this from public\sdk\inc
#include "medparam.h"
#include "dmusicf.h"

// {827F0437-9ED6-4107-8494-49976FF5B642}
DEFINE_GUID(IID_CParamControlTrack, 0x827f0437, 0x9ed6, 0x4107, 0x84, 0x94, 0x49, 0x97, 0x6f, 0xf5, 0xb6, 0x42);

class CParamControlTrack
  : public CBasicTrack
{
    // types for track data...

    struct ParamInfo
    {
        ParamInfo() : curves(NULL), curvesEnd(NULL), fAlreadyTracedPlaybackError(false) { Zero(&header); }
        ~ParamInfo() { delete[] curves; }

        DMUS_IO_PARAMCONTROLTRACK_PARAMHEADER header;
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curves; // pointer to first curve
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *curvesEnd; // pointer one past last curve
        bool fAlreadyTracedPlaybackError;
    };

    struct ObjectInfo
    {
        ObjectInfo() : fAlreadyTracedPlaybackError(false) { Zero(&header); }

        DMUS_IO_PARAMCONTROLTRACK_OBJECTHEADER header;
        TList<ParamInfo> listParams;
        bool fAlreadyTracedPlaybackError;
    };

    struct ParamState // the state data we need to keep track of for each parameter we're controlling
    {
        ParamState() : pCurrentCurve(NULL), fLast(false), rtStartPointOfLastCurve(0) {}

        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurrentCurve; // current seek pointer in the array of control points
        bool fLast; // true if the last envelope was sent successfully
        REFERENCE_TIME rtStartPointOfLastCurve; // time (in the object's time) of the start point of the last envelope we sent
        TList<REFERENCE_TIME> listStartTimes; // start times of all envelopes that have been sent 
    };

    struct StateData
    {
        StateData() : prgpIMediaParams(NULL), prgParam(NULL), fFlushInAbort(false) {}

        IMediaParams **prgpIMediaParams; // Array of size m_cObjects.
        ParamState *prgParam; // Array of size m_cParams.
        DWORD dwValidate;
        bool fFlushInAbort;
    };

public:
    CParamControlTrack(HRESULT *pHr) : m_dwValidate(0), m_cObjects(0), m_cParams(0), CBasicTrack(&g_cComponent, CLSID_DirectMusicParamControlTrack) {}

    STDMETHOD(QueryInterface)(const IID &iid, void **ppv);

    STDMETHOD(Init)(IDirectMusicSegment *pSegment);
    STDMETHOD(Load)(IStream* pIStream);
    STDMETHOD(InitPlay)(
        IDirectMusicSegmentState *pSegmentState,
        IDirectMusicPerformance *pPerformance,
        void **ppStateData,
        DWORD dwTrackID,
        DWORD dwFlags);
    STDMETHOD(EndPlay)(void *pStateData);
    STDMETHOD(Clone)(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
    virtual HRESULT PlayMusicOrClock(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        bool fClockTime);

    virtual HRESULT OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData);

private:
    HRESULT LoadObject(SmartRef::RiffIter ri);
    HRESULT LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams);
    HRESULT TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt);
    HRESULT PlayEnvelope(
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime);
    HRESULT PlayTruncatedEnvelope(
        MUSIC_TIME mtTruncStart,
        IMediaParams *pIMediaParams,
        MP_ENVELOPE_SEGMENT *pEnv,
        DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
        const ObjectInfo &obj,
        const ParamInfo &param,
        ParamState &paramstate,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        DWORD dwFlags);
        HRESULT InitStateData(
            StateData *pStateData,
            IDirectMusicSegmentState *pSegmentState);

    DWORD m_dwValidate; // Increment this counter in Load, causing the state data to synchonize with the new events
    TList<ObjectInfo> m_listObjects;
    int m_cObjects;
    int m_cParams;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\queue.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// queue.cpp
#include "debug.h"
#define ASSERT	assert
#include "dmime.h"
#include "dmperf.h"

CPMsgQueue::CPMsgQueue()

{
    m_pTop = NULL;
    m_pLastAccessed = NULL;
}

CPMsgQueue::~CPMsgQueue()

{
}

static PRIV_PMSG * sortevents( PRIV_PMSG * pEvents, long lLen )

{
    PRIV_PMSG * pLeft;
    PRIV_PMSG * pRight ;
    long        lLeft;
    long        lRight ;
    PRIV_PMSG * pTop ;

    if( lLen < 3 )
    {
        if( !pEvents )
            return( 0 ) ;
        if( lLen == 1 )
            return( pEvents ) ;
        pLeft  = pEvents ;
        pRight = pEvents->pNext ;
        if( !pRight )
            return( pLeft ) ;
        if( pLeft->rtTime > pRight->rtTime )
        {
            pLeft->pNext = NULL ;
            pRight->pNext = pLeft ;
            return( pRight ) ;
        }
        return( pLeft ) ;
    }

    lLeft = lLen >> 1 ;
    lRight = lLen - lLeft;
    pLeft = pEvents ;
    for (;lLeft > 1;pEvents = pEvents->pNext) lLeft--;
    pRight = sortevents( pEvents->pNext, lRight ) ;
    pEvents->pNext = NULL ;
    pLeft = sortevents( pLeft, lLen - lRight ) ;
    pTop = NULL ;

    for( ;  pLeft && pRight ;  )
    {
        if( pLeft->rtTime < pRight->rtTime )
        {
            if( !pTop )
                pTop = pLeft ;
            else
                pEvents->pNext = pLeft ;
            pEvents = pLeft ;
            pLeft   = pEvents->pNext ;
        }
        else
        {
            if( !pTop )
                pTop = pRight ;
            else
                pEvents->pNext = pRight ;
            pEvents = pRight ;
            pRight  = pEvents->pNext ;
        }
    }

    if( pLeft )
        pEvents->pNext = pLeft ;
    else
        pEvents->pNext = pRight ;

    return( pTop ) ;

}   

void CPMsgQueue::Sort() 

{
    m_pTop = sortevents(m_pTop, GetCount()) ;
    m_pLastAccessed = NULL;
}  

long CPMsgQueue::GetCount()

{
    long lCount = 0;
    PRIV_PMSG *pScan = GetHead();
    for (;pScan;pScan = pScan->pNext)
    {
        lCount++;
    }
    return lCount;
}

void CPMsgQueue::Enqueue(PRIV_PMSG *pItem)

{
    if (!pItem)
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a NULL pItem!\n");
        return;
    }
    // Ensure not already queued...
    if (pItem->dwPrivFlags & PRIV_FLAG_QUEUED)
    {
        TraceI(0,"ENQUEUE: Item thinks it is still in a queue!\n");
        return;
    }
	pItem->dwPrivFlags |= PRIV_FLAG_QUEUED;
    PRIV_PMSG *pScan; 
#ifdef DBG
    // Verify robustness of list. Check that the event is not already in the list
    // and that the time stamps are all in order.
    REFERENCE_TIME rtTime = 0;
    for (pScan = m_pTop;pScan;pScan = pScan->pNext)
    {
        if (pScan == pItem)
        {
            TraceI(0,"ENQUEUE: Item is already in the queue!\n"); 
            return;
        }
    	// this must queue events in time sorted order
        if (pScan->rtTime < rtTime)
        {
            TraceI(0,"ENQUEUE: Queue is not in time order!\n");
            pScan->rtTime = rtTime;
        }
        else if (pScan->rtTime > rtTime)
        {
            rtTime = pScan->rtTime;
        }
    }
#endif
    if ( !(pItem->dwFlags & DMUS_PMSGF_REFTIME) ) // sorting on reftime, so this must be valid 
    {
        TraceI(0, "ENQUEUE: Attempt to enqueue a pItem with a bogus RefTime!\n");
        return;
    }
    if (m_pLastAccessed && (m_pLastAccessed->rtTime <= pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    if ( pScan && ( pScan->rtTime <= pItem->rtTime ) )
	{
		for (;pScan->pNext; pScan = pScan->pNext )
		{
			if( pScan->pNext->rtTime > pItem->rtTime )
			{
				break;
			}
		}
		pItem->pNext = pScan->pNext;
		pScan->pNext = pItem;
    }
	else 
	{
		pItem->pNext = m_pTop;
		m_pTop = pItem;
	}
    m_pLastAccessed = pItem;
}

/*  Remove the oldest event before time rtTime, making sure that there is still
    at minimum one event prior to that time stamp. 
    This ensures that there is a sufficiently old event, but gets rid of old
    stale events. This is used by the timesig and tempomap lists.
*/

PRIV_PMSG *CPMsgQueue::FlushOldest(REFERENCE_TIME rtTime)

{
    PRIV_PMSG *pNext;
    if (m_pTop && (pNext = m_pTop->pNext))
    {
        if (pNext->rtTime < rtTime)
        {
            PRIV_PMSG *pDelete = m_pTop;
            if (m_pLastAccessed == m_pTop)
            {
                m_pLastAccessed = pNext;
            }
            m_pTop = pNext;
			pDelete->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
			pDelete->pNext = NULL;
            return pDelete;
        }
    }
    return NULL;
}

PRIV_PMSG *CPMsgQueue::Dequeue()

{
    PRIV_PMSG *pItem = m_pTop;

    if (pItem != NULL)
	{
        m_pTop = pItem->pNext;
		pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
        pItem->pNext = NULL;
        if (m_pLastAccessed == pItem)
        {
            m_pLastAccessed = m_pTop;
        }
    }

    return pItem;
}

PRIV_PMSG *CPMsgQueue::Dequeue(PRIV_PMSG *pItem)

{
    ASSERT(pItem);

    if (pItem == m_pTop)
    {
        return Dequeue();
    }
    PRIV_PMSG *pScan;
    PRIV_PMSG *pNext;
    if (m_pLastAccessed && 
        (m_pLastAccessed->rtTime < pItem->rtTime))
    {
        pScan = m_pLastAccessed;
    }
    else
    {
        pScan = m_pTop;
    }
    for (;pScan;pScan = pNext)
    {
        pNext = pScan->pNext;
        if (pNext == pItem)
        {
            pScan->pNext = pItem->pNext;
            pItem->pNext = NULL;
            pItem->dwPrivFlags &= ~PRIV_FLAG_QUEUED;
            if (m_pLastAccessed == pItem)
            {
                m_pLastAccessed = pScan;
            }
            return pItem;
        }
    }
    if (m_pLastAccessed)
    {
        // This happens every now and then as a result of a curve setting rtTime to 0
        // in the middle of FlushEventQueue. 
        // This should be fixed, but this patch will work for now.
        m_pLastAccessed = NULL;
        return Dequeue(pItem);
    }
    return NULL;
}

// queue Segment nodes in time order. pItem must be in the same
// time base as all items in ppList (RefTime or Music Time.)

void CSegStateList::Insert(CSegState* pItem)

{
    CSegState *pScan = GetHead();
    CSegState *pNext;
    pItem->SetNext(NULL);
    if (pScan)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < pScan->m_rtGivenStart )
			{
                AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_rtGivenStart > pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_rtGivenStart < pNext->m_rtGivenStart )
					{
						break;
					}
					pScan = pNext;
				}
				if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == pScan)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < pScan->m_mtResolvedStart )
			{
				AddHead(pItem);
			}
			else
			{
				while( pNext = pScan->GetNext() )
				{
					ASSERT( !( pScan->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == pScan)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 pScan->m_mtResolvedStart > pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						pScan->SetNext(NULL);
						break;
					}
					if( pItem->m_mtResolvedStart < pNext->m_mtResolvedStart )
					{
						break;
					}
					pScan = pNext;
				}
                if (pItem != pScan)
				{
					pItem->SetNext(pScan->GetNext());
					pScan->SetNext(pItem);
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		m_pHead = pItem;
	}
}

/*


void enqueue(CSegState **ppList, CSegState *pItem)
{
    CSegState *li = *ppList;

    if (li)
	{
		if( pItem->m_dwPlaySegFlags & DMUS_SEGF_REFTIME )
		{
			ASSERT( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
			// Avoid putting circularities in the list
			if (pItem == *ppList)
			{
				TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_rtGivenStart < li->m_rtGivenStart )
			{
				pItem->pNext = li;
				*ppList = pItem;
			}
			else
			{
				while( li->pNext )
				{
					ASSERT( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME );
					// Am I trying to insert something that's already in the list?
					if (pItem == li)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( ( li->pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 li->m_rtGivenStart > li->pNext->m_rtGivenStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT RT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						li->pNext = NULL;
						break;
					}
					if( pItem->m_rtGivenStart < li->pNext->m_rtGivenStart )
					{
						break;
					}
					li = li->pNext;
				}
				if (pItem != li)
				{
					pItem->pNext = li->pNext;
					li->pNext = pItem;
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT RT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
		else
		{
			ASSERT( !( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
			// Avoid putting circularities in the list
			if (pItem == *ppList)
			{
				TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN AT THE HEAD OF LIST\n");
			}
			else if( pItem->m_mtResolvedStart < li->m_mtResolvedStart )
			{
				pItem->pNext = li;
				*ppList = pItem;
			}
			else
			{
				while( li->pNext )
				{
					ASSERT( !( li->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) );
					// Am I trying to insert something that's already in the list?
					if (pItem == li)
					{
						break;
					}
					// Check for the queue getting corrupted (happens on multiproc machines at 400mhz)
					if ( !( li->pNext->m_dwPlaySegFlags & DMUS_SEGF_REFTIME ) && 
						 li->m_mtResolvedStart > li->pNext->m_mtResolvedStart )
					{
						TraceI(0, "ENQUEUE (SEGMENT MT): LOOP CONDITION VIOLATED\n");
						// get rid of the potential circularity in the list.  Note that this
						// (or actually the creation of the circularity) could cause memory leaks.
						li->pNext = NULL;
						break;
					}
					if( pItem->m_mtResolvedStart < li->pNext->m_mtResolvedStart )
					{
						break;
					}
					li = li->pNext;
				}
				if (pItem != li)
				{
					pItem->pNext = li->pNext;
					li->pNext = pItem;
				}
				else
				{
					TraceI(0, "ENQUEUE (SEGMENT MT): NODE IS ALREADY IN LIST\n");
				}
			}
		}
    }
	else
	{
		*ppList = pItem;
	}
}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\paramtrk.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Declaration of CParamControlTrack.
//

#include "dmime.h"
#include "ParamTrk.h"
#include "..\shared\Validate.h"
#include "miscutil.h"
#include "limits.h"
#include "math.h"


STDMETHODIMP 
CParamControlTrack::QueryInterface(const IID &iid, void **ppv)
{
	V_INAME(CParamControlTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

	if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
		*ppv = static_cast<IDirectMusicTrack8*>(this);
	else if (iid == IID_IPersistStream)
		*ppv = static_cast<IPersistStream*>(this);
	else if (iid == IID_IPersist)
		*ppv = static_cast<IPersist*>(this);
    else if (iid == IID_CParamControlTrack)
    {
        *ppv = static_cast<CParamControlTrack*>(this);
    }
	else
	{
		*ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
		return E_NOINTERFACE;
	}
	
	reinterpret_cast<IUnknown*>(this)->AddRef();
	return S_OK;
}

STDMETHODIMP
CParamControlTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Load(IStream* pIStream)
{
    V_INAME(CPlayingTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    // Increment counter so the next play will update state data with the new list.
    ++m_dwValidate;
    // Clear the objects/params/curves in case we're being reloaded.
    m_listObjects.CleanUp();
    m_cObjects = 0;
    m_cParams = 0;

    SmartRef::RiffIter ri(pIStream);
    if (!ri)
        return ri.hr();

    // find <prmt>
    hr = ri.FindRequired(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_TRACK_LIST, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: List 'prmt' not found.\n");
        }
#endif
        return hr;
    }
    SmartRef::RiffIter riTrack = ri.Descend();

    // for each <prol>
    while (riTrack && riTrack.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_LIST))
    {
        hr = this->LoadObject(riTrack.Descend());
        if (FAILED(hr))
            return hr;
        ++riTrack;
    }
    hr = riTrack.hr();

    return hr;
}

STDMETHODIMP
CParamControlTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,
    IDirectMusicPerformance *pPerformance,
    void **ppStateData,
    DWORD dwTrackID,
    DWORD dwFlags)
{
    V_INAME(CParamControlTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    SmartRef::CritSec CS(&m_CriticalSection);

    // Set up state data
    StateData *pStateData = new StateData;
    if (!pStateData)
        return E_OUTOFMEMORY;

    HRESULT hr = InitStateData(pStateData, pSegmentState);
    if (FAILED(hr))
    {
        delete pStateData;
    }
    else
    {
        pStateData->dwValidate = m_dwValidate;
        *ppStateData = pStateData;
    }

    return hr;
}

STDMETHODIMP
CParamControlTrack::EndPlay(void *pStateData)
{
    V_INAME(CParamControlTrack::EndPlay);
    V_BUFPTR_WRITE(pStateData, sizeof(StateData));

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (!pSD->fFlushInAbort)
    {
        // For each object, flush all curves on each parameter up to the start time of the last one we sent.
        //    (This allows the DMO being controlled to free up memory associated with any previous curves
        //     while still keeping the last one around so that the next thing played picks up that parameter
        //     value how it was left.)
        // Then release the object's params interface.
        int iObj = 0;
        for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
                pObject && iObj < m_cObjects;
                pObject = pObject->GetNext(), ++iObj)
        {
            IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
            if (pIMediaParams)
            {
                ObjectInfo &obj = pObject->GetItemValue();
                int iParam = 0;
                for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                        pParam && iParam < m_cParams;
                        pParam = pParam->GetNext(), ++iParam)
                {
                    ParamInfo &param = pParam->GetItemValue();
                    ParamState &paramstate = pSD->prgParam[iParam];
                    if (paramstate.fLast)
                    {
                        HRESULT hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                        if (FAILED(hrFlush))
                        {
                            assert(false);
                            TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                        }
                    }
                }
            }
            SafeRelease(pIMediaParams);
        }
    }
    delete[] pSD->prgpIMediaParams;
    delete[] pSD->prgParam;
    delete pSD;

    return S_OK;
}

HRESULT CParamControlTrack::OnSegmentEnd(REFERENCE_TIME rtEnd, void *pStateData)
{
    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    // For each object, flush all curves on each parameter up to the start time of the last one we sent
    // (if that started before segment end) or flush everything up to the last one to start before
    // segment end, and flush everything after segment end (if the start time was after segment end).
    //    (This allows the DMO being controlled to free up memory associated with any previous curves
    //     while still keeping the last one around so that the next thing played picks up that parameter
    //     value how it was left.)
    // Then release the object's params interface.
    int iObj = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObj < m_cObjects;
            pObject = pObject->GetNext(), ++iObj)
    {
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObj];
        if (pIMediaParams)
        {
            ObjectInfo &obj = pObject->GetItemValue();
            int iParam = 0;
            for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                    pParam && iParam < m_cParams;
                    pParam = pParam->GetNext(), ++iParam)
            {
                ParamInfo &param = pParam->GetItemValue();
                ParamState &paramstate = pSD->prgParam[iParam];
                if (paramstate.fLast)
                {
                    HRESULT hrFlush = S_OK;
                    if (paramstate.rtStartPointOfLastCurve < rtEnd)
                    {
                        hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, paramstate.rtStartPointOfLastCurve);
                    }
                    else
                    {
                        // first, look for the largest start time less than rtEnd and
                        // flush up to there.  The loop assumes the list is ordered largest to smallest.
                        TListItem<REFERENCE_TIME>* pStartTime = paramstate.listStartTimes.GetHead();
                        for (; pStartTime; pStartTime = pStartTime->GetNext())
                        {
                            if (pStartTime->GetItemValue() < rtEnd)
                            {
                                hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, _I64_MIN, pStartTime->GetItemValue());
                                break;
                            }
                        }
                        // Then, flush from rtEnd on.
                        if (SUCCEEDED(hrFlush))
                        {
                            hrFlush = pIMediaParams->FlushEnvelope(param.header.dwIndex, rtEnd, _I64_MAX);
                        }
                    }
                    if (FAILED(hrFlush))
                    {
                        assert(false);
                        TraceI(1, "Unable to flush envelope information from an audio path object in parameter control track, HRESULT 0x%08x.\n", hrFlush);
                    }
                }
            }
        }
        SafeRelease(pIMediaParams);
        pSD->prgpIMediaParams[iObj] = NULL;
    }

    pSD->fFlushInAbort = true;

    return S_OK;
}

STDMETHODIMP
CParamControlTrack::Clone(MUSIC_TIME mtStart, MUSIC_TIME mtEnd, IDirectMusicTrack** ppTrack)
{
    //  Test more thoroughly when we have multiple working params/objects.

    V_INAME(CParamControlTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    SmartRef::CritSec CS(&m_CriticalSection);

    HRESULT hr = S_OK;

    SmartRef::ComPtr<CParamControlTrack> scomTrack = new CParamControlTrack(&hr);
    if (FAILED(hr))
        return hr;
    if (!scomTrack)
        return E_OUTOFMEMORY;
    scomTrack->AddRef();

    // Copy each object
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext())
    {
        ObjectInfo &obj = pObject->GetItemValue();
        TListItem<ObjectInfo> *pNewObject = new TListItem<ObjectInfo>;
        if (!pNewObject)
            return E_OUTOFMEMORY;
        ObjectInfo &newobj = pNewObject->GetItemValue();
        newobj.header = obj.header;

        // Copy each parameter
        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam;
                pParam = pParam->GetNext())
        {
            ParamInfo &param = pParam->GetItemValue();
            TListItem<ParamInfo> *pNewParam = new TListItem<ParamInfo>;
            if (!pNewParam)
                return E_OUTOFMEMORY;
            ParamInfo &newparam = pNewParam->GetItemValue();
            newparam.header = param.header;

            // Copy the curves from mtStart to mtEnd
            // These should include curves that overlap the start and end, though this
            // leave some issues we still need to work out (what happens with overlapping curves?)
            // So, first find the first curve whose end time is at or after mtStart...
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveStart = param.curves;
                    (pCurveStart < param.curvesEnd) && (pCurveStart->mtEndTime < mtStart);
                    ++pCurveStart)
            {}
            // Then, find the curve whose start time is after mtEnd.
            for (DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pCurveEnd = pCurveStart;
                    (pCurveEnd < param.curvesEnd) && (pCurveEnd->mtStartTime < mtEnd);
                    ++pCurveEnd)
            {}
            int cCurves = (int)(pCurveEnd - pCurveStart);
            newparam.curves = new DMUS_IO_PARAMCONTROLTRACK_CURVEINFO[cCurves];
            if (!newparam.curves)
                return E_OUTOFMEMORY;
            memcpy(newparam.curves, pCurveStart, cCurves * sizeof(DMUS_IO_PARAMCONTROLTRACK_CURVEINFO));
            newparam.curvesEnd = newparam.curves + cCurves;
            // Now, scan through the new curve array and adjust the times by subtracting mtStart from everything.
            for (pCurveStart = newparam.curves; pCurveStart < newparam.curvesEnd; pCurveStart++)
            {
                pCurveStart->mtStartTime -= mtStart;
                pCurveStart->mtEndTime -= mtStart;
            }

            newobj.listParams.AddHead(pNewParam);
        }

        newobj.listParams.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different parameters in the exact same order just in case.
        scomTrack->m_listObjects.AddHead(pNewObject);
    }
    scomTrack->m_listObjects.Reverse(); // Technically, the order shouldn't matter.  But this ensures that the cloned track will send curves to different objects in the exact same order just in case.
    ++scomTrack->m_dwValidate;

    scomTrack->m_cObjects = m_cObjects;
    scomTrack->m_cParams = m_cParams;

    *ppTrack = scomTrack.disown();
    return hr;
}

HRESULT
CParamControlTrack::PlayMusicOrClock(
    void *pStateData,
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    bool fClockTime)
{
    V_INAME(CParamControlTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(StateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
        return S_OK;

    SmartRef::CritSec CS(&m_CriticalSection);

    StateData *pSD = static_cast<StateData *>(pStateData);

    if (m_dwValidate != pSD->dwValidate)
    {
        HRESULT hr = InitStateData(pSD, pSegSt);
        if (FAILED(hr))
        {
            return hr;
        }
    }

    // envelope structure we'll fill for sending each envelope segment.
    MP_ENVELOPE_SEGMENT envCurve;
    Zero(&envCurve);
    MP_ENVELOPE_SEGMENT *const penvCurve = &envCurve;

    bool fMoreCurves = false; // set to true by any parameter that has more curves to play

    // for each parameter...
    int iParam = 0;
    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject && iObject < m_cObjects;
            pObject = pObject->GetNext(), ++iObject)
    {
        ObjectInfo &obj = pObject->GetItemValue();
        IMediaParams *pIMediaParams = pSD->prgpIMediaParams[iObject];

        bool fObjClockTime = !!(obj.header.guidTimeFormat == GUID_TIME_REFERENCE);
        if (!fObjClockTime && obj.header.guidTimeFormat != GUID_TIME_MUSIC)
        {
            // track can only handle music and clock time
            assert(false);
            // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
            TraceI(
                obj.fAlreadyTracedPlaybackError ? 3 : 1,
                "Parameter control track unable to control object -- unknown time format (must be GUID_TIME_MUSIC or GUID_TIME_REFERENCE).\n");
            obj.fAlreadyTracedPlaybackError = true;
            continue;
        }

        for (TListItem<ParamInfo> *pParam = obj.listParams.GetHead();
                pParam && iParam < m_cParams;
                pParam = pParam->GetNext(), ++iParam)
        {
            ParamInfo &param = pParam->GetItemValue();
            ParamState &paramstate = pSD->prgParam[iParam];

            DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *&pCurrentCurve = paramstate.pCurrentCurve;

            // We're going to seek through the event list to find the proper next control curve for each parameter if
            // the track's data has been reloaded or if playback has made a jump to a different position in the track.
            if (m_dwValidate != pSD->dwValidate || dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_LOOP | DMUS_TRACKF_FLUSH | DMUS_TRACKF_START))
            {
                assert(m_dwValidate != pSD->dwValidate || dwFlags & DMUS_TRACKF_SEEK); // by contract SEEK should be set whenever the other dwFlags are

                // find first curve that begins at or after the start time we're currently playing
                for (pCurrentCurve = param.curves; pCurrentCurve < param.curvesEnd && pCurrentCurve->mtStartTime < mtStart; ++pCurrentCurve)
                {}

                if (pIMediaParams && pCurrentCurve > param.curves)
                {
                    // check the previous curve to see if we ended up in the middle of it
                    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPrevCurve = pCurrentCurve - 1;
                    // Send a curve chopped off at the start time we're currently playing.
                    // We can't send the whole curve because it would take effect too early.
                    HRESULT hrEnv = this->PlayTruncatedEnvelope(mtStart, pIMediaParams, penvCurve, pPrevCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime, dwFlags);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            // Send curves until the next curve is after mtEnd
            for ( ; pCurrentCurve < param.curvesEnd; ++pCurrentCurve )
            {
                if (pCurrentCurve->mtStartTime < mtStart) // this can happen if DMUS_TRACKF_PLAY_OFF was set and the seek pointer remains at events from the past
                    continue;
                if (pCurrentCurve->mtStartTime >= mtEnd)
                    break;

                // send this curve
                if (pIMediaParams)
                {
                    HRESULT hrEnv = this->PlayEnvelope(pIMediaParams, penvCurve, pCurrentCurve, obj, param, paramstate, mtOffset, rtOffset, pPerf, fClockTime, fObjClockTime);
                    if (FAILED(hrEnv))
                    {
                        // Can't fail from Play.  Just assert and print trace information.
                        assert(false);
                        // Only log this once at warning level one.  Rest go to warning level three to avoid tons of identical trace messages during playback).
                        TraceI(
                            param.fAlreadyTracedPlaybackError ? 3 : 1,
                            "Unable to send envelope information to an audio path object in parameter control track, HRESULT 0x%08x.\n", hrEnv);
                        param.fAlreadyTracedPlaybackError = true;
                    }
                }
            }

            if (pCurrentCurve < param.curvesEnd)
                fMoreCurves = true;
        }
        assert(!pParam); // we should have gotten all the way through this param list
    }
    assert(!pObject && iParam == m_cParams && iObject == m_cObjects); // we should have gotten all the way through the object list and done the expected number of objects and parameters

    pSD->dwValidate = m_dwValidate; // if we weren't in sync with new track data before, we are now
    return fMoreCurves ? S_OK : DMUS_S_END;
}

HRESULT CParamControlTrack::LoadObject(SmartRef::RiffIter ri)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ObjectInfo> > spItem = new TListItem<ObjectInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ObjectInfo &ritem = spItem->GetItemValue();

    // find <proh>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_OBJECT_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'proh' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;
    if (!(ritem.header.guidTimeFormat == GUID_TIME_MUSIC || ritem.header.guidTimeFormat == GUID_TIME_REFERENCE))
    {
        Trace(1, "Error: Unable to load parameter control track: guidTimeFormat in chunk 'proh' must be either GUID_TIME_MUSIC or GUID_TIME_REFERENCE.\n");
        return DMUS_E_INVALID_PARAMCONTROLTRACK;
    }

    // for each <prpl>
    while (ri && ri.Find(SmartRef::RiffIter::List, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_LIST))
    {
        hr = this->LoadParam(ri.Descend(), ritem.listParams);
        if (FAILED(hr))
            return hr;
        ++ri;
    }
    hr = ri.hr();

    if (SUCCEEDED(hr))
    {
        m_listObjects.AddHead(spItem.disown());
        ++m_cObjects;
    }
    return hr;
}

HRESULT CParamControlTrack::LoadParam(SmartRef::RiffIter ri, TList<ParamInfo> &listParams)
{
    if (!ri)
        return ri.hr();

    HRESULT hr = S_OK;

    SmartRef::Ptr<TListItem<ParamInfo> > spItem = new TListItem<ParamInfo>;
    if (!spItem)
        return E_OUTOFMEMORY;
    ParamInfo &ritem = spItem->GetItemValue();

    // find <prph>
    hr = ri.FindRequired(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_PARAM_CHUNK, DMUS_E_INVALID_PARAMCONTROLTRACK);
    if (FAILED(hr))
    {
#ifdef DBG
        if (hr == DMUS_E_INVALID_PARAMCONTROLTRACK)
        {
            Trace(1, "Error: Unable to load parameter control track: Chunk 'prph' not found.\n");
        }
#endif
        return hr;
    }

    hr = SmartRef::RiffIterReadChunk(ri, &ritem.header);
    if (FAILED(hr))
        return hr;

    // find <prcc>
    if (!ri.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_PARAMCONTROLTRACK_CURVES_CHUNK))
    {
        // It is OK if we read to the end without finding the chunk--we succeed without finding any curves.
        // Or it could be a failure because there was a problem reading from the stream.
        // The RiffIter's hr method reflects this.
        return ri.hr();
    }

    // read the array of control curves
    int cRecords;
    hr = SmartRef::RiffIterReadArrayChunk(ri, &ritem.curves, &cRecords);
    if (FAILED(hr))
        return hr;
    ritem.curvesEnd = ritem.curves + cRecords;

    listParams.AddHead(spItem.disown());
    ++m_cParams;
    return hr;
}

HRESULT CParamControlTrack::TrackToObjectTime(
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        IDirectMusicPerformance* pPerf,
        bool fTrkClockTime,
        bool fObjClockTime,
        MUSIC_TIME mt,
        REFERENCE_TIME *rt)
{
    HRESULT hr = S_OK;

    // set the time (reference time variable is used to hold either music or reference time in different contexts)
    REFERENCE_TIME rtEnv = mt;

    // add the correct offset and if necessary convert from millisecond time 
    rtEnv = fTrkClockTime
                ? rtEnv * gc_RefPerMil + rtOffset
                : rtEnv = rtEnv + mtOffset;

    if (fTrkClockTime != fObjClockTime)
    {
        // need to convert between out track's time format and the audio object's time format
        if (fObjClockTime)
        {
            MUSIC_TIME mtEnv = static_cast<MUSIC_TIME>(rtEnv);
            hr = pPerf->MusicToReferenceTime(mtEnv, &rtEnv);
            if (FAILED(hr))
                return hr;
        }
        else
        {
            MUSIC_TIME mtEnv = 0;
            hr = pPerf->ReferenceToMusicTime(rtEnv, &mtEnv);
            rtEnv = mtEnv;
            if (FAILED(hr))
                return hr;
        }
    }

    *rt = rtEnv;
    return hr;
}

HRESULT
CParamControlTrack::PlayEnvelope(
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime)
{
    HRESULT hr = S_OK;

    // set the curve type and flags
    pEnv->iCurve = static_cast<MP_CURVE_TYPE>(pPt->dwCurveType);
    pEnv->flags = pPt->dwFlags;

    pEnv->valEnd = pPt->fltEndValue;
    pEnv->valStart = pPt->fltStartValue;

    // set the time (used to hold either music or reference time in different contexts)

    REFERENCE_TIME &rtEnvStart = pEnv->rtStart;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtStartTime, &rtEnvStart);
    if (FAILED(hr))
        return hr;

    REFERENCE_TIME &rtEnvEnd = pEnv->rtEnd;
    hr = this->TrackToObjectTime(mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime, pPt->mtEndTime, &rtEnvEnd);
    if (FAILED(hr))
        return hr;

    hr = pIMediaParams->AddEnvelope(param.header.dwIndex, 1, pEnv);
    if (SUCCEEDED(hr))
    {
        paramstate.rtStartPointOfLastCurve = rtEnvStart;
        TListItem<REFERENCE_TIME>* pStartTime = new TListItem<REFERENCE_TIME>;
        if (pStartTime)
        {
            pStartTime->GetItemValue() = rtEnvStart;
            // Adding to the head maintains a largest-to-smallest ordering.
            paramstate.listStartTimes.AddHead(pStartTime);
        }
        paramstate.fLast = true;
    }

    return hr;
}

HRESULT
CParamControlTrack::PlayTruncatedEnvelope(
    MUSIC_TIME mtTruncStart,
    IMediaParams *pIMediaParams,
    MP_ENVELOPE_SEGMENT *pEnv,
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO *pPt,
    const ObjectInfo &obj,
    const ParamInfo &param,
    ParamState &paramstate,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    IDirectMusicPerformance* pPerf,
    bool fTrkClockTime,
    bool fObjClockTime,
    DWORD dwFlags)
{
    // Copy info from the curve
    DMUS_IO_PARAMCONTROLTRACK_CURVEINFO curveinfo = *pPt;
    // Cut the start to the designated time
    curveinfo.mtStartTime = mtTruncStart;
    bool fSkip = false;

    if (mtTruncStart >= curveinfo.mtEndTime)
    {
        // Curve happened in the past.  Send a jump curve right at the current (truncate) time picking up with
        // that value.
        // if we're looping and we passed the end of this curve, just skip it.
        if ( (dwFlags & DMUS_TRACKF_LOOP) )
        {
            fSkip = true;
        }
        else
        {
            curveinfo.mtEndTime = mtTruncStart;
            curveinfo.dwCurveType = MP_CURVE_JUMP;
        }
    }
    else if (pPt->dwCurveType != MP_CURVE_JUMP)
    {
        // Find the point at that time and pick up with a linear curve from there.
        // (For the nonlinear curves, there's no way to pick them up part-way along.)
        curveinfo.dwCurveType = MP_CURVE_LINEAR;

        MUSIC_TIME mtTimeChange = pPt->mtEndTime - pPt->mtStartTime;
        MUSIC_TIME mtTimeIntermediate = mtTruncStart - pPt->mtStartTime;

        float fltScalingX = static_cast<float>(mtTimeIntermediate) / mtTimeChange; // horizontal distance along curve between 0 and 1
        float fltScalingY; // height of curve at that point between 0 and 1 based on curve function
        switch (pPt->dwCurveType)
        {
        case MP_CURVE_SQUARE:
            fltScalingY = fltScalingX * fltScalingX;
            break;
        case MP_CURVE_INVSQUARE:
            fltScalingY = (float) sqrt(fltScalingX);
            break;
        case MP_CURVE_SINE:
            //  Maybe we should have a lookup table here?
            fltScalingY = (float) (sin(fltScalingX * 3.1415926535 - (3.1415926535/2)) + 1) / 2;
            break;
        case MP_CURVE_LINEAR:
        default:
            fltScalingY = fltScalingX;
        }

        // Apply that scaling to the range of the actual points
        curveinfo.fltStartValue = (pPt->fltEndValue - pPt->fltStartValue) * fltScalingY + pPt->fltStartValue;
    }

    if (fSkip) return S_OK;

    return this->PlayEnvelope(pIMediaParams, pEnv, &curveinfo, obj, param, paramstate, mtOffset, rtOffset, pPerf, fTrkClockTime, fObjClockTime);
}

HRESULT CParamControlTrack::InitStateData(StateData *pStateData,
                                          IDirectMusicSegmentState *pSegmentState)
{
    if (pStateData->prgpIMediaParams)
    {
        delete [] pStateData->prgpIMediaParams;
        pStateData->prgpIMediaParams = NULL;
    }
    if (pStateData->prgParam)
    {
        delete [] pStateData->prgParam;
        pStateData->prgParam = NULL;
    }

    pStateData->prgpIMediaParams = new IMediaParams *[m_cObjects];
    if (!pStateData->prgpIMediaParams)
    {
        return E_OUTOFMEMORY;
    }
    pStateData->prgParam = new ParamState[m_cParams];
    if (!pStateData->prgParam)
    {
        delete [] pStateData->prgpIMediaParams;
        return E_OUTOFMEMORY;
    }

    // Get the IMediaParams interface for each object
    SmartRef::ComPtr<IDirectMusicSegmentState8> scomSegSt8;
    HRESULT hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&scomSegSt8));
    if (FAILED(hr))
    {      
        delete [] pStateData->prgParam;
        delete [] pStateData->prgpIMediaParams;
        return hr;
    }

    int iObject = 0;
    for (TListItem<ObjectInfo> *pObject = m_listObjects.GetHead();
            pObject;
            pObject = pObject->GetNext(), ++iObject)
    {
        IMediaParams *pIMediaParams = NULL;
        ObjectInfo &rinfo = pObject->GetItemValue();
        HRESULT hrObject = scomSegSt8->GetObjectInPath(
                                rinfo.header.dwPChannel,
                                rinfo.header.dwStage,
                                rinfo.header.dwBuffer,
                                rinfo.header.guidObject,
                                rinfo.header.dwIndex,
                                IID_IMediaParams,
                                reinterpret_cast<void**>(&pIMediaParams));
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            TraceI(1, "Parameter control track was unable to find audio path object, HRESULT 0x%08x.\n", hrObject);
        }
        else
        {
            hrObject = pIMediaParams->SetTimeFormat(rinfo.header.guidTimeFormat, rinfo.header.guidTimeFormat == GUID_TIME_MUSIC ? 768 : 0);
        }
        if (FAILED(hrObject))
        {
            // Can't fail from InitPlay (and this is called from there).
            // Just print trace information.
            Trace(1, "Unable to set time format of object in parameter control track, HRESULT 0x%08x.\n", hrObject);
        }
        if (FAILED(hrObject))
        {
            SafeRelease(pIMediaParams);
        }
        pStateData->prgpIMediaParams[iObject] = pIMediaParams;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\sources.inc ===
!IF 0

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Jim Geist (JimGe) 29-Aug-97

NOTE:   Commented description of this file is in \nt\oak\bin\sources.tpl

!ENDIF

!include ..\..\dmusic.inc

MAJORCOMP=windows
MINORCOMP=directx

TARGETNAME=dmime

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF


TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLDEF=..\dmime.def
DLLENTRY=_DllMainCRTStartup
USE_MAPSYM=1
USE_MSVCRT=1
USE_STL=1
USE_IOSTREAM=1

!if !$(FREEBUILD)

!if "$(BuildMode)" == "internal"
C_DEFINES = $(C_DEFINES) -DDEBUG=1
!else
C_DEFINES = $(C_DEFINES) -DRDEBUG=1
!endif

!endif

C_DEFINES= $(C_DEFINES) -D_WIN32 -DINC_OLE2

INCLUDES=$(INCLUDES);   \
    ..\..\shared

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib		\
           $(SDK_LIB_PATH)\winmm.lib        \
	   $(SDK_LIB_PATH)\advapi32.lib		\
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(SDK_LIB_PATH)\ole32.lib        \
           $(SDK_LIB_PATH)\user32.lib       \
           $(SDK_LIB_PATH)\dsound.lib       \
           $(SDK_LIB_PATH)\dmoguids.lib


SOURCES=..\alist.cpp           \
..\debug.cpp           \
..\dmgraph.cpp         \
..\dmhall.cpp          \
..\dmperf.cpp          \
..\dmprfdll.cpp        \
..\dmsegobj.cpp        \
..\dmsstobj.cpp        \
..\midifile.cpp        \
..\mutx.cpp            \
..\oledll.cpp          \
..\queue.cpp           \
..\seqtrack.cpp        \
..\sysextrk.cpp        \
..\tempotrk.cpp        \
..\tsigtrk.cpp         \
..\dmstrm.cpp		   \
..\curvetrk.cpp        \
..\pchmap.cpp          \
..\dmime.rc            \
..\opnew.cpp           \
..\audpath.cpp         \
..\lyrictrk.cpp        \
..\marktrk.cpp         \
..\paramtrk.cpp        \
..\segtrtrk.cpp        \
..\smartref.cpp        \
..\song.cpp            \
..\trackhelp.cpp       \
..\wavtrack.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\sysextrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// SysExTrk.h : Declaration of the CSysExTrk

#ifndef __SYSEXTRK_H_
#define __SYSEXTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

// FullSysexEvent is DMUS_IO_SYSEX_ITEM plus data pointer
struct FullSysexEvent : DMUS_IO_SYSEX_ITEM
{
	BYTE* pbSysExData;
};

class SysExListItem : public AListItem
{
public:
	SysExListItem()
	{
		m_pItem = NULL;
	};

	HRESULT SetItem( FullSysexEvent item )
	{
		if( m_pItem )
		{
			delete [] m_pItem->pbSysExData;
		}
		else
		{
			m_pItem = new FullSysexEvent;
		}
		if( m_pItem )
		{
			m_pItem->mtTime = item.mtTime;
			m_pItem->dwSysExLength = item.dwSysExLength;
			m_pItem->pbSysExData = item.pbSysExData;
			return S_OK;
		}
		else
		{
			return E_OUTOFMEMORY;
		}
	};

	~SysExListItem()
	{
		if( m_pItem )
		{
			if( m_pItem->pbSysExData )
			{
				delete [] m_pItem->pbSysExData;
			}
			delete m_pItem;
		}
	};

	SysExListItem* GetNext()
	{
		return (SysExListItem*)AListItem::GetNext();
	};
public:
	FullSysexEvent* m_pItem;
};

class SysExList : public AList
{
public:
	~SysExList()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

	void DeleteAll()
	{
		SysExListItem* pItem;
		while( pItem = (SysExListItem*)AList::RemoveHead() )
		{
			delete pItem;
		}
	};

    SysExListItem* GetHead() 
	{
		return (SysExListItem*)AList::GetHead();
	};
};

struct SysExStateData
{
	SysExListItem*				pCurrentSysEx;
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	DWORD						dwValidate;
	MUSIC_TIME					mtPrevEnd;

	SysExStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CSysExTrk
class CSysExTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CSysExTrack();
	CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CSysExTrack();

// ISysExTrk
public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

protected:
	HRESULT Seek(void *pStateData,MUSIC_TIME mtTime);
    HRESULT Play(void *pStateData,MUSIC_TIME mtStart,MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,REFERENCE_TIME rtOffset,DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,BOOL fClockTime);
	void Construct(void);

// private member variables
protected:
	SysExList	m_SysExEventList;
	long	m_cRef;
	DWORD	m_dwValidate;
	CRITICAL_SECTION m_CrSec;
    BOOL    m_fCSInitialized;
};

#endif //__SYSEXTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\sysextrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// SysExTrk.cpp : Implementation of CSysExTrk
#include "dmime.h"
#include "SysExTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "dmperf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert

/////////////////////////////////////////////////////////////////////////////
// CSysExTrack
void CSysExTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
	m_dwValidate = 0;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CSysExTrack::CSysExTrack()
{
	Construct();
}

CSysExTrack::CSysExTrack(
		CSysExTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
	SysExListItem* pScan = rTrack.m_SysExEventList.GetHead();

	for(; pScan; pScan = pScan->GetNext())
	{
		FullSysexEvent* pItem = pScan->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		else if( pItem->mtTime < mtStart )
		{
			continue;
		}
		else if (pItem->mtTime < mtEnd)
		{
			SysExListItem* pNew = new SysExListItem;
			if (pNew)
			{
				FullSysexEvent item;
				item.mtTime = pItem->mtTime - mtStart;
				item.dwSysExLength = pItem->dwSysExLength;
				if (item.dwSysExLength && (item.pbSysExData = new BYTE[item.dwSysExLength]))
                {
					memcpy( item.pbSysExData, pItem->pbSysExData, item.dwSysExLength );
					pNew->SetItem(item);
					m_SysExEventList.AddTail(pNew);
				}
                else
                {
                    delete pNew;
                }
			}
		}
		else break;
	}
}

CSysExTrack::~CSysExTrack()
{
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }

	InterlockedDecrement(&g_cComponent);
}

// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSysExTrack>
//
// parm const IID & | iid | Interface to query for
// parm void ** | ppv | The requested interface will be returned here
//
// rdesc Returns one of the following:
//
// flag S_OK | If the interface is supported and was returned
// flag E_NOINTERFACE | If the object does not support the given interface.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP CSysExTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CSysExTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Sysex Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// method:(EXTERNAL) HRESULT | IDirectMusicSysExTrack | Release | Standard Release implementation for <i IDirectMusicSysExTrack>
//
// rdesc Returns the new reference count for this object.
//
// mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CSysExTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSysExTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CSysExTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicSysExTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSysExTrack::IsDirty()
{
	return S_FALSE;
}

/*

  method HRESULT | ISeqTrack | Load |
  Call this with an IStream filled with SysExEvents, sorted in time order.
  parm IStream* | pIStream |
  A stream of SysExEvents, sorted in time order. The seek pointer should point
  to the first event. The stream should contain only SysExEvents and nothing more.
  rvalue E_POINTER | If pIStream == NULL or invalid.
  rvalue S_OK
  comm The <p pIStream> will be AddRef'd inside this function and held
  until the SysExTrack is released.
*/
HRESULT CSysExTrack::Load( IStream* pIStream )
{
	V_INAME(CSysExTrack::Load);
	V_INTERFACE(pIStream);

	EnterCriticalSection(&m_CrSec);
	HRESULT hr = S_OK;

	m_dwValidate++;
	if( m_SysExEventList.GetHead() )
	{
		m_SysExEventList.DeleteAll();
	}

	// copy contents of the stream into the list.
	//DMUS_IO_SYSEX_ITEM sysexEvent;
	FullSysexEvent sysexEvent;
	// read in the chunk id
	DWORD dwChunk;
	long lSize;
	pIStream->Read( &dwChunk, sizeof(DWORD), NULL);
	if( dwChunk != DMUS_FOURCC_SYSEX_TRACK )
	{
        Trace(1,"Error: Invalid data in sysex track.\n");
        LeaveCriticalSection(&m_CrSec);
		return DMUS_E_CHUNKNOTFOUND;
	}
	// read in the overall size
	if( FAILED( pIStream->Read( &lSize, sizeof(long), NULL )))
	{
        Trace(1,"Error: Unable to read sysex track.\n");
		LeaveCriticalSection(&m_CrSec);
		return DMUS_E_CANNOTREAD;
	}

	DMUS_IO_SYSEX_ITEM SysexItem;
	BYTE* pbSysExData;
	while( lSize > 0 )
	{
		if( FAILED( pIStream->Read( &SysexItem, sizeof(DMUS_IO_SYSEX_ITEM), NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			break;
		}
		lSize -= sizeof(DMUS_IO_SYSEX_ITEM);
		pbSysExData = new BYTE[SysexItem.dwSysExLength];
		if( NULL == pbSysExData )
		{
			hr = E_OUTOFMEMORY;
			break;
		}
		if( FAILED( pIStream->Read( pbSysExData, SysexItem.dwSysExLength, NULL )))
		{
            Trace(1,"Error: Unable to read sysex track.\n");
			hr = DMUS_E_CANNOTREAD;
			break;
		}
		lSize -= SysexItem.dwSysExLength;
		sysexEvent.mtTime = SysexItem.mtTime;
		sysexEvent.dwPChannel = SysexItem.dwPChannel;
		sysexEvent.dwSysExLength = SysexItem.dwSysExLength;
		sysexEvent.pbSysExData = pbSysExData;
		SysExListItem* pNew = new SysExListItem;
		if (pNew)
		{
			if( FAILED( pNew->SetItem(sysexEvent)))
			{
				delete [] pbSysExData;
				hr = E_OUTOFMEMORY;
				break;
			}
			m_SysExEventList.AddTail(pNew);
		}
		else
		{
			delete [] pbSysExData;
			hr = E_OUTOFMEMORY;
			break;
		}
	}
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CSysExTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CSysExTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CSysExTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	return E_NOTIMPL;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a Segment, it's Init() routine is called
by that Segment.

parm IDirectMusicSegment* | pSegment |
[in] Pointer to the Segment to which this Track belongs.

rvalue S_OK
*/
HRESULT CSysExTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CSysExTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

	SysExStateData* pStateData;
	pStateData = new SysExStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
	pStateData->dwVirtualTrackID = dwTrackID;
	pStateData->pPerformance = pPerformance; // weak reference, no addref.
	pStateData->pSegState = pSegmentState; // weak reference, no addref.
	pStateData->pCurrentSysEx = m_SysExEventList.GetHead();
	pStateData->dwValidate = m_dwValidate;
	return S_OK;
}

HRESULT CSysExTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(IDirectMusicTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(SysExStateData));
		SysExStateData* pSD = (SysExStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
	V_INAME(IDirectMusicTrack::PlayEx);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
	    hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
	    hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

/*

  method HRESULT | CSysExTrack | Play |
  Play method.
  rvalue S_FALSE | If there has been no stream loaded into the Track.
  rvalue S_OK
*/
HRESULT CSysExTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(SysExStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CrSec);
	HRESULT	hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
	LeaveCriticalSection(&m_CrSec);
	return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode. 
*/

HRESULT CSysExTrack::Play( 
    void *pStateData,	
    MUSIC_TIME mtStart,	
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
	DWORD dwFlags,		
	IDirectMusicPerformance* pPerf,	
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
	    return S_OK;
    }
	IDirectMusicGraph* pGraph = NULL;
	DMUS_SYSEX_PMSG* pSysEx;
	SysExStateData* pSD = (SysExStateData*)pStateData;
	HRESULT	hr = S_OK;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	// if pSD->pCurrentSysEx is NULL, and we're in a normal Play call (dwFlags is 0)
	// this means that we either have no events, or we got to the end of the event
	// list previously. So, it's safe to just return.
	if( (pSD->pCurrentSysEx == NULL) && (dwFlags == 0) )
	{
		return S_FALSE;
	}

	if( pSD->dwValidate != m_dwValidate )
	{
		pSD->dwValidate = m_dwValidate;
		pSD->pCurrentSysEx = NULL;
	}
	if( NULL == m_SysExEventList.GetHead() )
	{
		return DMUS_S_END;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->mtPrevEnd != mtStart ))
	{
		Seek( pStateData, mtStart );
	}
	else if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	pSD->mtPrevEnd = mtEnd;

	if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
		if( NULL == pItem )
		{
			continue;
		}
		if( pItem->mtTime >= mtEnd )
		{
			// this time is in the future. Return now to retain the same
			// seek pointers for next time.
			hr = S_OK;
			break;
		}
		if( (pItem->mtTime < mtStart) && !fSeek )
		{
			break;
		}
		// allocate a DMUS_SYSEX_PMSG of the approriate size and read 
		// the sysex data into it
		if( SUCCEEDED( hr = pSD->pPerformance->AllocPMsg( 
			sizeof(DMUS_SYSEX_PMSG) + pItem->dwSysExLength, (DMUS_PMSG**)&pSysEx ) ) )
		{
			memcpy( pSysEx->abData, pItem->pbSysExData, pItem->dwSysExLength );
            if (fClockTime)
            {
                pSysEx->rtTime = (pItem->mtTime  * REF_PER_MIL) + rtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;

            }
            else
            {
			    pSysEx->mtTime = pItem->mtTime + mtOffset;
                pSysEx->dwFlags = DMUS_PMSGF_MUSICTIME;
            }
			pSysEx->dwLen = pItem->dwSysExLength;
			pSysEx->dwPChannel = 0;
			pSysEx->dwVirtualTrackID = pSD->dwVirtualTrackID;
			pSysEx->dwType = DMUS_PMSGT_SYSEX;
			pSysEx->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pSysEx );
			}
			if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pSysEx )))
			{
				pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pSysEx );
			}
		}
        else
        {
            hr = DMUS_S_END;
            break;
        }
	}
	if( pGraph )
	{
		pGraph->Release();
	}
	return hr;
}

HRESULT CSysExTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime)
{
	SysExStateData* pSD = (SysExStateData*)pStateData;

	if( NULL == m_SysExEventList.GetHead() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->pCurrentSysEx )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	FullSysexEvent* pItem = pSD->pCurrentSysEx->m_pItem;
	if( pItem->mtTime >= mtTime )
	{
		pSD->pCurrentSysEx = m_SysExEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	for( ; pSD->pCurrentSysEx; pSD->pCurrentSysEx = pSD->pCurrentSysEx->GetNext() )
	{
		pItem = pSD->pCurrentSysEx->m_pItem;
		if( pItem->mtTime >= mtTime )
		{
			break;
		}
	}
	return S_OK;
}

STDMETHODIMP CSysExTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CSysExTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) || (mtStart > mtEnd))
	{
        Trace(1,"Error: Unable to clone sysex track, invalid start parameter.\n",mtStart);
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);

    CSysExTrack *pDM;
    
    try
    {
        pDM = new CSysExTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}


STDMETHODIMP CSysExTrack::Compose(
		IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}

STDMETHODIMP CSysExTrack::Join(
		IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) 
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\song.cpp ===
//
// Copyright (c) 1998-2001 Microsoft Corporation
// song.cpp : Implementation of CSong
//

#include "dmime.h"
#include "song.h"
#include "..\shared\validp.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "debug.h"

CTrack::CTrack()
{
    m_pTrack = NULL;
    m_pTrack8 = NULL;
    m_pTrackState = NULL;
    m_bDone = FALSE;
    m_dwPriority = 0;
    m_dwPosition = 0;
    m_dwFlags = DMUS_TRACKCONFIG_DEFAULT;
    m_dwInternalFlags = 0;
    m_dwGroupBits = 0xFFFFFFFF;
    m_dwVirtualID = 0;
    m_guidClassID = GUID_NULL;
}

CTrack::~CTrack()
{
    assert( !( m_pTrackState && !m_pTrack ) ); // if we have state but no track, something's wrong
    if( m_pTrack )
    {
        if( m_pTrackState )
        {
            m_pTrack->EndPlay( m_pTrackState ); // allow the track to delete its state data
        }
        m_pTrack->Release();
    }
    if ( m_pTrack8 )
    {
        m_pTrack8->Release();
    }
}

HRESULT CTrackList::CreateCopyWithBlankState(CTrackList* pTrackList)
{
    if( pTrackList )
    {
        CTrack* pTrack;
        CTrack* pCopy;
        pTrackList->Clear();
        pTrack = (CTrack*)m_pHead;
        while( pTrack )
        {
            pCopy = new CTrack;
            if( pCopy )
            {
                // copy the IDirectMusicTrack pointer, but leave
                // the track state blank.
                *pCopy = *pTrack;
                pCopy->SetNext(NULL);
                pCopy->m_pTrackState = NULL;
                assert( pCopy->m_pTrack );
                pCopy->m_pTrack->AddRef();
                if (pCopy->m_pTrack8)
                {
                    pCopy->m_pTrack8->AddRef();
                }
                pTrackList->Cat( pCopy );
            }
            else
            {
                assert(FALSE); // out of memory
                return E_OUTOFMEMORY;
            }
            pTrack = pTrack->GetNext();
        }
    }
    else
    {
        assert(FALSE); // out of memory
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

CVirtualSegment::CVirtualSegment()
{
    m_wszName[0] = 0;
    m_pSourceSegment = NULL;
    m_pPlaySegment = NULL;
    m_pGraph = NULL;
    m_dwFlags = 0;
    m_dwID = 0;
    m_dwNextPlayID = DMUS_SONG_NOSEG;
    m_dwNextPlayFlags = 0;
    m_mtTime = 0;
    m_dwTransitionCount = 0;
    m_pTransitions = NULL;
    m_SegHeader.rtLength = 0;
    m_SegHeader.dwFlags = 0;
    m_SegHeader.dwRepeats = 0;      /* Number of repeats. By default, 0. */
    m_SegHeader.mtLength = 0xC00;   /* Length, in music time. */
    m_SegHeader.mtPlayStart = 0;    /* Start of playback. By default, 0. */
    m_SegHeader.mtLoopStart = 0;    /* Start of looping portion. By default, 0. */
    m_SegHeader.mtLoopEnd = 0;      /* End of loop. Must be greater than dwPlayStart. By default equal to length. */
    m_SegHeader.dwResolution = 0;   /* Default resolution. */
}

CVirtualSegment::~CVirtualSegment()
{
    if (m_pSourceSegment)
    {
        m_pSourceSegment->Release();
    }
    if (m_pPlaySegment)
    {
        m_pPlaySegment->Release();
    }
    if (m_pGraph)
    {
        m_pGraph->Release();
    }
    if (m_pTransitions)
    {
        delete [] m_pTransitions;
    }
    m_TrackList.Clear();
}

CTrack * CVirtualSegment::GetTrackByParam( CTrack * pCTrack,
    REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex)
{
    // If the caller was already part way through the list, it passes the current
    // track. Otherwise, NULL to indicate start at the top.
    if (pCTrack)
    {
        pCTrack = pCTrack->GetNext();
    }
    else
    {
        pCTrack = m_TrackList.GetHead();
    }
    while( pCTrack )
    {
        ASSERT(pCTrack->m_pTrack);
        if( (pCTrack->m_dwGroupBits & dwGroupBits ) &&
            (pCTrack->m_dwFlags & DMUS_TRACKCONFIG_CONTROL_ENABLED))
        {
            if( (GUID_NULL == rguidType) || (pCTrack->m_pTrack->IsParamSupported( rguidType ) == S_OK ))
            {
                if( 0 == dwIndex )
                {
                    return pCTrack;
                }
                dwIndex--;
            }
        }
        pCTrack = pCTrack->GetNext();
    }
    return NULL;
}

void CVirtualSegmentList::Clear()
{
    CVirtualSegment *pVirtualSegment;
    while (pVirtualSegment = RemoveHead())
    {
        delete pVirtualSegment;
    }
}

CSongSegment::CSongSegment()
{
    m_pSegment = NULL;
    m_dwLoadID = 0;
}

CSongSegment::~CSongSegment()
{
    if (m_pSegment)
    {
        m_pSegment->Release();
    }
}

HRESULT CSongSegmentList::AddSegment(CSegment *pSegment, DWORD dwLoadID)
{
    CSongSegment *pSeg = new CSongSegment;
    if (pSeg)
    {
        pSeg->m_dwLoadID = dwLoadID;
        pSeg->m_pSegment = pSegment;
        pSegment->AddRef();
        AddTail(pSeg);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CSongSegmentList::Clear()
{
    CSongSegment *pSongSegment;
    while (pSongSegment = RemoveHead())
    {
        delete pSongSegment;
    }
}


CSong::CSong()
{
    InitializeCriticalSection(&m_CriticalSection);
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_pAudioPathConfig = NULL;
    m_fPartialLoad = FALSE;
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
    memset(&m_guidObject,0,sizeof(m_guidObject));
    memset(&m_ftDate, 0,sizeof(m_ftDate));
    memset(&m_vVersion, 0,sizeof(m_vVersion));
    m_pUnkDispatch = NULL;
    InterlockedIncrement(&g_cComponent);
    m_fZombie = false;
    TraceI(2, "Song %lx created\n", this );
}

CSong::~CSong()
{
    Clear();

    if (m_pUnkDispatch)
    {
        m_pUnkDispatch->Release(); // free IDispatch implementation we may have borrowed
    }
    DeleteCriticalSection(&m_CriticalSection);
    InterlockedDecrement(&g_cComponent);
    TraceI(2, "Song %lx destroyed\n", this );
}


void CSong::Clear()
{
    if (m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
        m_pAudioPathConfig = NULL;
    }
    m_GraphList.Clear();
    m_PlayList.Clear();
    m_SegmentList.Clear();
    m_VirtualSegmentList.Clear();
    m_dwStartSegID = DMUS_SONG_NOSEG;
    m_fPartialLoad = FALSE;
    m_dwFlags = 0;
    m_dwValidData = DMUS_OBJ_CLASS; // upon creation, only this data is valid
}

STDMETHODIMP_(void) CSong::Zombie()
{
    Clear();
    m_fZombie = true;
}

STDMETHODIMP CSong::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CSong::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicSong)
    {
        *ppv = static_cast<IDirectMusicSong*>(this);
    }
    else if (iid == IID_CSong)
    {
        *ppv = static_cast<CSong*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if(iid == IID_IDirectMusicObject)
    {
        *ppv = static_cast<IDirectMusicObject*>(this);
    }
    else if (iid == IID_IDirectMusicObjectP)
    {
        *ppv = static_cast<IDirectMusicObjectP*>(this);
    }
    else if(iid == IID_IDispatch)
    {
        // A helper scripting object implements IDispatch, which we expose via COM aggregation.
        if (!m_pUnkDispatch)
        {
            // Create the helper object
            ::CoCreateInstance(
                CLSID_AutDirectMusicSong,
                static_cast<IDirectMusicSong*>(this),
                CLSCTX_INPROC_SERVER,
                IID_IUnknown,
                reinterpret_cast<void**>(&m_pUnkDispatch));
        }
        if (m_pUnkDispatch)
        {
            return m_pUnkDispatch->QueryInterface(IID_IDispatch, ppv);
        }
    }

    if (*ppv == NULL)
    {
        Trace(4,"Warning: Request to query unknown interface on Song object\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CSong::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CSong::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        m_cRef = 100; // artificial reference count to prevent reentrency due to COM aggregation
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CSong::Compose( )
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Compose after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    // Go through the seg ref list and create master composition tracks for each composing track.
    TList<ComposingTrack> MasterTrackList;
    CVirtualSegment* pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (; pVirtualSegment; pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (!pVirtualSegment->m_pPlaySegment)
        {
            Trace(1,"Error: Corrupt song, one or more virtual segments do not resolve to real segments. Unable to compose.\n");
            hr = E_POINTER;
            break;
        }
        CSegment *pSegment = pVirtualSegment->m_pPlaySegment;
        CTrack* pTrack = pSegment->m_TrackList.GetHead();
        for (; pTrack; pTrack = pTrack->GetNext())
        {
            if (pTrack->m_dwFlags & DMUS_TRACKCONFIG_COMPOSING)
            {
                DWORD dwTrackGroup = pTrack->m_dwGroupBits;
                // filter out any group bits already covered by other master tracks of same type
                TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
                for (; pMaster; pMaster = pMaster->GetNext())
                {
                    ComposingTrack& rMaster = pMaster->GetItemValue();
                    if (rMaster.GetTrackID() == pTrack->m_guidClassID)
                    {
                        DWORD dwMaster = rMaster.GetTrackGroup();
                        if (dwMaster == dwTrackGroup)
                        {
                            // Exact match: put the track here.
                            hr = rMaster.AddTrack(pVirtualSegment, pTrack);
                            dwTrackGroup = 0;
                            break;
                        }
                        DWORD dwIntersection = dwMaster & dwTrackGroup;
                        if (dwIntersection)
                        {
                            dwTrackGroup |= ~dwIntersection;
                        }
                    }
                }
                // If we've still got any group bits left, add a new composing track
                if (dwTrackGroup)
                {
                    TListItem<ComposingTrack>* pTrackItem = new TListItem<ComposingTrack>;
                    if (!pTrackItem)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        ComposingTrack& rTrack = pTrackItem->GetItemValue();
                        rTrack.SetTrackGroup(dwTrackGroup);
                        rTrack.SetTrackID(pTrack->m_guidClassID);
                        rTrack.SetPriority(pTrack->m_dwPriority);
                        // Add tracks in priority order (higher priority first)
                        pMaster = MasterTrackList.GetHead();
                        TListItem<ComposingTrack>* pPrevious = NULL;
                        for (; pMaster; pMaster = pMaster->GetNext())
                        {
                            ComposingTrack& rMaster = pMaster->GetItemValue();
                            if (pTrack->m_dwPriority > rMaster.GetPriority()) break;
                            pPrevious = pMaster;
                        }
                        if (!pPrevious) // this has higher priority than anything in the list
                        {
                            MasterTrackList.AddHead(pTrackItem);
                        }
                        else // lower priority than pPrevious, higher than pMaster
                        {
                            pTrackItem->SetNext(pMaster);
                            pPrevious->SetNext(pTrackItem);
                        }
                        hr = pTrackItem->GetItemValue().AddTrack(pVirtualSegment, pTrack);
                    }
                }
            }
            if (FAILED(hr)) break;
        }
        if (FAILED(hr)) break;
    }

    // Call compose on each master composition track
    if (SUCCEEDED(hr))
    {
        TListItem<ComposingTrack>* pMaster = MasterTrackList.GetHead();
        if (pMaster)
        {
            for (; pMaster; pMaster = pMaster->GetNext())
            {
                hr = pMaster->GetItemValue().Compose(this);
            }
        }
        else hr = S_FALSE;
    }

    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::Download(IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicSong::Download);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Download after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Download(pAudioPath)))
        {
            // count partial successes, so that S_FALSE will be returned if we have, e.g.,
            // one partial success followed by one failure
            dwSuccess++;
        }
        if (hr != S_OK)
        {
            // keep track of partial successes so that they always percolate up
            hrFail = hr;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (hrFail != S_OK && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully downloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}

STDMETHODIMP CSong::Unload(IUnknown *pAudioPath)
{
    V_INAME(IDirectMusicSong::Unload);
    V_INTERFACE(pAudioPath);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Unload after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    DWORD dwSuccess = 0;
    HRESULT hr = S_OK;
    HRESULT hrFail = S_OK;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (SUCCEEDED(hr = pSegment->Unload(pAudioPath)))
        {
            dwSuccess++;
        }
        else
        {
            hrFail = hr;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if (FAILED(hrFail) && dwSuccess)
    {
        Trace(1,"Warning: Only %ld of the total %ld segments successfully unloaded.\n",
            dwSuccess,m_PlayList.GetCount());
        hr = S_FALSE;
    }
    return hr;
}


/*STDMETHODIMP CSong::Clone(IDirectMusicSong **ppSong)

{
    V_INAME(IDirectMusicSong::Clone);
    V_PTRPTR_WRITE_OPT(ppSong);
    HRESULT hr = E_OUTOFMEMORY;
    CSong *pSong = new CSong();
    if (*ppSong)
    {
        *ppSong = pSong;
        EnterCriticalSection(&m_CriticalSection);
        CSegment *pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            IDirectMusicSegment *pISeg;
            hr = pSegment->Clone(0,pSegment->m_mtLength,&pISeg);
            if (SUCCEEDED(hr))
            {
                CSegment *pCopy = (CSegment *) pISeg;
                pSong->m_PlayList.AddTail(pCopy);
                pCopy->m_pSong = pSong;
            }
        }
        pSong->m_dwValidData = m_dwValidData;
        pSong->m_guidObject = m_guidObject;
        pSong->m_ftDate = m_ftDate;
        pSong->m_vVersion = m_vVersion;
        wcscpy(pSong->m_wszName,m_wszName);
        wcscpy(pSong->m_wszCategory,m_wszCategory);
        wcscpy(pSong->m_wszFileName,m_wszFileName);
        pSong->m_dwVersion = m_dwVersion;
        pSong->m_dwFlags = m_dwFlags;
        pSong->m_pAudioPathConfig = m_pAudioPathConfig;
        if (m_pAudioPathConfig)
            m_pAudioPathConfig->AddRef();
        LeaveCriticalSection(&m_CriticalSection);
    }
    return hr;
}
*/

STDMETHODIMP CSong::GetParam( REFGUID rguidType,
                        DWORD dwGroupBits,
                        DWORD dwIndex,
                        MUSIC_TIME mtTime,
                        MUSIC_TIME* pmtNext,
                        void* pParam)
{
    V_INAME(IDirectMusiCSong::GetParam);
    V_REFGUID(rguidType);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetParam after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = DMUS_E_TRACK_NOT_FOUND;
/*    BOOL fMultipleTry = FALSE;
    if (dwIndex == DMUS_SEG_ANYTRACK)
    {
        dwIndex = 0;
        fMultipleTry = TRUE;
    }*/
    EnterCriticalSection(&m_CriticalSection);
    /*CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_mtStart <= mtTime &&
            mtTime < pSegment->m_mtStart + pSegment->m_mtLength)
        {
            hr = pSegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pSegment->m_mtStart, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }*/
    CVirtualSegment *pVirtualSegment = m_VirtualSegmentList.GetHead();
    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime &&
            pVirtualSegment->m_pPlaySegment &&
            mtTime < pVirtualSegment->m_mtTime + pVirtualSegment->m_pPlaySegment->m_mtLength)
        {
            hr = pVirtualSegment->m_pPlaySegment->GetParam(rguidType, dwGroupBits, dwIndex, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam);
            if (SUCCEEDED(hr)) break;
        }
    }
/*    for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
    {
        if (pVirtualSegment->m_mtTime <= mtTime)
        {
            CTrack* pCTrack;
            pCTrack = pVirtualSegment->GetTrackByParam(NULL, rguidType,dwGroupBits, dwIndex);
            while (pCTrack)
            {
                if (pCTrack->m_pTrack8)
                {
                    REFERENCE_TIME rtNext, *prtNext;
                    // We need to store the next time in a 64 bit pointer. But, don't
                    // make 'em fill it in unless the caller requested it.
                    if (pmtNext)
                    {
                        prtNext = &rtNext;
                    }
                    else
                    {
                        prtNext = NULL;
                    }
                    hr = pCTrack->m_pTrack8->GetParamEx( rguidType, mtTime - pVirtualSegment->m_mtTime, prtNext, pParam,
                        NULL, 0 );
                    if (pmtNext)
                    {
                        *pmtNext = (MUSIC_TIME) rtNext;
                    }
                }
                else
                {
                    hr = pCTrack->m_pTrack->GetParam( rguidType, mtTime - pVirtualSegment->m_mtTime, pmtNext, pParam );
/ *                 if( pmtNext && (( *pmtNext == 0 ) || (*pmtNext > (m_mtLength - mtTime))))
                    {
                        *pmtNext = m_mtLength - mtTime;
                    }* /
                }
                // If nothing was found and dwIndex was DMUS_SEG_ANYTRACK, try again...
                if (fMultipleTry && (hr == DMUS_E_NOT_FOUND))
                {
                    pCTrack = pVirtualSegment->GetTrackByParam(pCTrack, rguidType,dwGroupBits, dwIndex);
                }
                else
                {
                    pCTrack = NULL;
                }
            }
        }
    }*/
    if (FAILED(hr) && pmtNext)
    {
        // return the time of the first segment after mtTime (or 0 if there is no such segment)
        pVirtualSegment = m_VirtualSegmentList.GetHead();
        for (;pVirtualSegment;pVirtualSegment = pVirtualSegment->GetNext())
        {
            if (pVirtualSegment->m_mtTime > mtTime)
            {
                *pmtNext = pVirtualSegment->m_mtTime;
                break;
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSong::Instantiate()
{
    V_INAME(IDirectMusicSong::Instantiate);
    EnterCriticalSection(&m_CriticalSection);
    CVirtualSegment *pRef = m_VirtualSegmentList.GetHead();
    m_PlayList.Clear();
    for (;pRef;pRef = pRef->GetNext())
    {
        // the constructor below does an AddRef.
        CSegment *pSegment = new CSegment(&pRef->m_SegHeader,pRef->m_pSourceSegment);
        if (pSegment)
        {
            if (pRef->m_wszName[0])
            {
                wcscpy(pSegment->m_wszName,pRef->m_wszName);
                pSegment->m_dwValidData |= DMUS_OBJ_NAME;
            }
            CTrack *pTrack;
            for (pTrack = pRef->m_TrackList.GetHead();pTrack;pTrack = pTrack->GetNext())
            {
                CTrack *pCopy = new CTrack;
                if( pCopy )
                {
                    *pCopy = *pTrack;
                    pCopy->SetNext(NULL);
                    pCopy->m_pTrackState = NULL;
                    pCopy->m_pTrack->AddRef();
                    if (pCopy->m_pTrack8)
                    {
                        pCopy->m_pTrack8->AddRef();
                    }
                    // The tracks were in backwards order. This puts them back in order, and ahead of the segment tracks.
                    pSegment->m_TrackList.AddHead( pCopy );
                }
            }
            pSegment->m_pSong = this;
            pSegment->m_dwPlayID = pRef->m_dwID;
//Trace(0,"Intantiating PlaySegment %ls with ID %ld.\n",pRef->m_wszName,pRef->m_dwID);
            pSegment->m_dwNextPlayFlags = pRef->m_dwNextPlayFlags;
            pSegment->m_dwNextPlayID = pRef->m_dwNextPlayID;
            m_PlayList.AddTail(pSegment);
            if (pRef->m_pPlaySegment) pRef->m_pPlaySegment->Release();
            pRef->m_pPlaySegment = pSegment;
            pRef->m_pPlaySegment->AddRef();
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return S_OK;
}

HRESULT CSong::EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment)
{
    V_INAME(IDirectMusicSong::EnumSegment);
    V_PTRPTR_WRITE (ppSegment);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::EnumSegment after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment && dwIndex;pSegment = pSegment->GetNext()) dwIndex--;
    if (pSegment)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
        pSegment->AddRef();
        hr = S_OK;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

HRESULT CSong::GetPlaySegment( DWORD dwIndex,CSegment **ppSegment)
{
    HRESULT hr = S_FALSE;
    EnterCriticalSection(&m_CriticalSection);
    CSegment *pSegment = m_PlayList.GetHead();
    for (;pSegment;pSegment = pSegment->GetNext())
    {
        if (pSegment->m_dwPlayID == dwIndex)
        {
            *ppSegment = pSegment;
            pSegment->AddRef();
            hr = S_OK;
            break;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

STDMETHODIMP CSong::GetSegment(WCHAR *wszName, IDirectMusicSegment **ppSegment)
{
    V_INAME(IDirectMusicSong::GetSegment);
    V_PTRPTR_WRITE(ppSegment);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetSegment after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = S_FALSE;
    CSegment *pSegment;
    if (wszName)
    {
        V_BUFPTR_READ(wszName,2);
        EnterCriticalSection(&m_CriticalSection);
        pSegment = m_PlayList.GetHead();
        for (;pSegment;pSegment = pSegment->GetNext())
        {
            if (_wcsicmp(pSegment->m_wszName, wszName) == 0)
            {
                pSegment->AddRef();
                hr = S_OK;
                break;
            }
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    else
    {
        hr = GetPlaySegment( m_dwStartSegID,&pSegment);
    }
    if (hr == S_OK)
    {
        *ppSegment = static_cast<IDirectMusicSegment*>(pSegment);
    }
    else
    {
#ifdef DBG
        if (wszName)
        {
            Trace(1,"Error: Unable to find segment %ls in song.\n",wszName);
        }
        else
        {
            Trace(1,"Error: Unable to find starting segment in the song.\n");
        }
#endif
    }
    return hr;
}

STDMETHODIMP CSong::GetAudioPathConfig(IUnknown ** ppAudioPathConfig)
{
    V_INAME(IDirectMusicSegment::GetAudioPathConfig);
    V_PTRPTR_WRITE(ppAudioPathConfig);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetAudioPathConfig after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr;
    EnterCriticalSection(&m_CriticalSection);
    if (m_pAudioPathConfig)
    {
        hr = m_pAudioPathConfig->QueryInterface(IID_IUnknown,(void **)ppAudioPathConfig);
    }
    else
    {
        Trace(2,"Warning: No embedded audiopath configuration in the song.\n");
        hr = DMUS_E_NO_AUDIOPATH_CONFIG;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CSong::GetClassID( CLSID* pClassID )
{
    V_INAME(CSong::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetClassID after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    *pClassID = CLSID_DirectMusicSong;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CSong::IsDirty()
{
    return E_NOTIMPL;
}

HRESULT CSong::Load( IStream* pIStream )
{
    V_INAME(CSong::Load);
    V_INTERFACE(pIStream);

    // Song format temporarily turned off for DX8 release.
    return E_NOTIMPL;
    /*
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::Load after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    // Create RIFF parser.
    CRiffParser Parser(pIStream);

    RIFFIO ckMain;
    HRESULT hr = S_OK;
    // First, clear the song in case it is being read into a second time.
    Clear();

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr))
    {
        if (ckMain.fccType == DMUS_FOURCC_SONG_FORM)
        {
            EnterCriticalSection(&m_CriticalSection);
            RIFFIO ckNext;
            RIFFIO ckChild;
            IDirectMusicContainer *pContainer = NULL; // For handling embedded container with linked objects.
            Parser.EnterList(&ckNext);
            while(Parser.NextChunk(&hr))
            {
                switch(ckNext.ckid)
                {
                    case DMUS_FOURCC_SONG_CHUNK:
                        DMUS_IO_SONG_HEADER ioSongHdr;
                        ioSongHdr.dwFlags = 0;
                        hr = Parser.Read(&ioSongHdr, sizeof(DMUS_IO_SONG_HEADER));
                        if(SUCCEEDED(hr))
                        {
                            m_dwFlags = ioSongHdr.dwFlags;
                            m_dwStartSegID = ioSongHdr.dwStartSegID;
                        }
                        break;

                    case DMUS_FOURCC_GUID_CHUNK:
                        if( ckNext.cksize == sizeof(GUID) )
                        {
                            hr = Parser.Read(&m_guidObject, sizeof(GUID));
                            if( SUCCEEDED(hr) )
                            {
                                m_dwValidData |= DMUS_OBJ_OBJECT;
                            }
                        }
                        break;

                    case DMUS_FOURCC_VERSION_CHUNK:
                        hr = Parser.Read( &m_vVersion, sizeof(DMUS_VERSION) );
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_VERSION;
                        }
                        break;

                    case DMUS_FOURCC_CATEGORY_CHUNK:
                        hr = Parser.Read( m_wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
                        if( SUCCEEDED(hr) )
                        {
                            m_dwValidData |= DMUS_OBJ_CATEGORY;
                        }
                        break;

                    case DMUS_FOURCC_DATE_CHUNK:
                        if( sizeof(FILETIME) == ckNext.cksize )
                        {
                            hr = Parser.Read( &m_ftDate, sizeof(FILETIME) );
                            if( SUCCEEDED(hr) )
                            {
                                m_dwValidData |= DMUS_OBJ_DATE;
                            }
                        }
                        break;

                    case FOURCC_LIST:
                    case FOURCC_RIFF:
                        switch(ckNext.fccType)
                        {
                            case DMUS_FOURCC_UNFO_LIST:
                                Parser.EnterList(&ckChild);
                                while(Parser.NextChunk(&hr))
                                {
                                    switch( ckChild.ckid )
                                    {
                                        case DMUS_FOURCC_UNAM_CHUNK:
                                        {
                                            hr = Parser.Read(&m_wszName, sizeof(m_wszName));
                                            if(SUCCEEDED(hr) )
                                            {
                                                m_dwValidData |= DMUS_OBJ_NAME;
                                            }
                                            break;
                                        }
                                        default:
                                            break;
                                    }
                                }
                                Parser.LeaveList();
                                break;
                            case DMUS_FOURCC_CONTAINER_FORM:
                                // An embedded container RIFF chunk which includes a bunch
                                // of objects referenced by the song. This should precede the
                                // segments and gets loaded prior to them. Loading this
                                // causes all of its objects to get SetObject'd in the loader,
                                // so they later get pulled in as requested by the tracks in the segments.
                                // After the tracks are loaded, the loader references are
                                // released by a call to release the IDirectMusicContainer.
                                {
                                    DMUS_OBJECTDESC Desc;
                                    IDirectMusicLoader *pLoader;
                                    IDirectMusicGetLoader *pGetLoader;
                                    HRESULT hr = pIStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
                                    if (SUCCEEDED(hr))
                                    {
                                        if (SUCCEEDED(pGetLoader->GetLoader(&pLoader)))
                                        {
                                            // Move back stream's current position
                                            Parser.SeekBack();
                                            Desc.dwSize = sizeof(Desc);
                                            Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                                            Desc.guidClass = CLSID_DirectMusicContainer;
                                            Desc.pStream = pIStream;
                                            pLoader->GetObject(&Desc,IID_IDirectMusicContainer,(void **) &pContainer);
                                            if (pContainer)
                                            {
                                                // Don't cache the container object! We want it and the
                                                // objects it references to go away when the segment is done loading.
                                                IDirectMusicObject *pObject = NULL;
                                                pContainer->QueryInterface(IID_IDirectMusicObject,(void **)&pObject);
                                                if (pObject)
                                                {
                                                    pLoader->ReleaseObject(pObject);
                                                    pObject->Release();
                                                }
                                            }
                                            // Now, seek to the end of this chunk.
                                            Parser.SeekForward();
                                            pLoader->Release();
                                        }
                                        pGetLoader->Release();
                                    }
                                }
                                break;
                            case DMUS_FOURCC_SONGSEGMENTS_LIST:
                                hr = LoadSegmentList(&Parser); //pIStream, pIDirectMusicStream, ckNext);
                                break;
                            case DMUS_FOURCC_SEGREFS_LIST:
                                hr = LoadVirtualSegmentList(&Parser);
                                break;
                            case DMUS_FOURCC_AUDIOPATH_FORM:
                                // Move back to start of this chunk.
                                Parser.SeekBack();
                                hr = LoadAudioPath(pIStream);
                                // Now, seek to the end of this chunk.
                                Parser.SeekForward();
                                break;
                            default:
                                break;
                        }
                        break;

                    default:
                        break;

                }
            }
            Parser.LeaveList();
            LeaveCriticalSection(&m_CriticalSection);

            if (pContainer)
            {
                pContainer->Release();
            }

            if( SUCCEEDED(hr) )
            {
                if( m_fPartialLoad & PARTIALLOAD_E_FAIL )
                {
                    if( m_fPartialLoad & PARTIALLOAD_S_OK )
                    {
                        Trace(1,"Error: Song load was incomplete, some components failed loading.\n");
                        hr = DMUS_S_PARTIALLOAD;
                    }
                    else
                    {
                        Trace(1,"Error: Song load failed because all components failed loading.\n");
                        hr = DMUS_E_ALL_TRACKS_FAILED;
                    }
                }
            }
        }
        else
        {
            // Couldn't find the chunk header for a song.
            // But, maybe this is actually a segment, in which case see if
            // the segment object will load it.
            CSegment *pSegment = new CSegment;
            if (pSegment)
            {
                pSegment->AddRef(); // Segment::Load (and possibly others) may need the refcount
                // Force the version so audiopath functionality will be supported.
                pSegment->m_dwVersion = 8;
                Parser.SeekBack();
                hr = pSegment->Load(pIStream);
                if (SUCCEEDED(hr))
                {
                    DMUS_OBJECTDESC Desc;
                    Desc.dwSize = sizeof (Desc);
                    pSegment->GetDescriptor(&Desc);
                    Desc.guidClass = CLSID_DirectMusicSong;
                    SetDescriptor(&Desc);
                    // AddSegment addref's by one.
                    m_SegmentList.AddSegment(pSegment,0);
                    pSegment->GetAudioPathConfig((IUnknown **) &m_pAudioPathConfig);
                    m_dwStartSegID = 0; // Points to this segment.
                    CVirtualSegment *pVirtual = new CVirtualSegment;
                    if (pVirtual)
                    {
                        pVirtual->m_pSourceSegment = pSegment;
                        pSegment->AddRef();
                        pVirtual->m_SegHeader.dwRepeats = pSegment->m_dwRepeats;
                        pVirtual->m_SegHeader.dwResolution = pSegment->m_dwResolution;
                        pVirtual->m_SegHeader.mtLength = pSegment->m_mtLength;
                        pVirtual->m_SegHeader.mtLoopEnd = pSegment->m_mtLoopEnd;
                        pVirtual->m_SegHeader.mtLoopStart = pSegment->m_mtLoopStart;
                        pVirtual->m_SegHeader.mtPlayStart = pSegment->m_mtStart;
                        pVirtual->m_SegHeader.rtLength = pSegment->m_rtLength;
                        pVirtual->m_SegHeader.dwFlags = pSegment->m_dwSegFlags;
                        if (pSegment->m_dwValidData & DMUS_OBJ_NAME)
                        {
                            wcscpy(pVirtual->m_wszName,pSegment->m_wszName);
                        }
                        m_VirtualSegmentList.AddHead(pVirtual);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    pSegment->Release(); // release the initial AddRef
                }
                if (FAILED(hr))
                {
                    delete pSegment;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    // If there are no virtual segments, clear the song and fail the load
    if ( !m_VirtualSegmentList.GetHead() )
    {
        Clear();
        hr = DMUS_E_NOT_INIT;
    }
    if (SUCCEEDED(hr)) Instantiate();
    return hr;*/
}

HRESULT CSong::LoadAudioPath(IStream *pStream)
{
    assert(pStream);

    CAudioPathConfig *pPath = new CAudioPathConfig;
    if (pPath == NULL) {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPath->Load(pStream);

    EnterCriticalSection(&m_CriticalSection);
    if(m_pAudioPathConfig)
    {
        m_pAudioPathConfig->Release();
    }
    m_pAudioPathConfig = pPath;
    LeaveCriticalSection(&m_CriticalSection);

    return hr;
}

HRESULT CSong::LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser)
{

    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pParser->GetStream()->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    RIFFIO ckNext;

    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pParser->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE));
                if(SUCCEEDED(hr))
                {
                    if (ioDMRef.guidClassID != CLSID_DirectMusicSegment)
                    {
                        Trace(1,"Error: Invalid segment reference in song.\n");
                        hr = DMUS_E_CANNOTREAD;
                    }
                    else
                    {
                        desc.guidClass = ioDMRef.guidClassID;
                        desc.dwValidData |= ioDMRef.dwValidData;
                        desc.dwValidData |= DMUS_OBJ_CLASS;
                    }
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pParser->Read(&(desc.guidObject), sizeof(GUID));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = pParser->Read(desc.wszName, sizeof(desc.wszName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                hr = pParser->Read(desc.wszFileName, sizeof(desc.wszFileName));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = pParser->Read(desc.wszCategory, sizeof(desc.wszCategory));
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            default:
                break;
        }
    }
    pParser->LeaveList();

    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_CSegment, (void**)ppSegment);
        // Once we get the object, we need to ensure that the same object is never
        // connected up to any other songs (or this one, too.)
        // So, we ensure that the loader doesn't keep it around.
        if (SUCCEEDED(hr))
        {
            IDirectMusicObject *pObject;
            if (SUCCEEDED((*ppSegment)->QueryInterface(IID_IDirectMusicObject,(void **)&pObject)))
            {
                pLoader->ReleaseObject(pObject);
                pObject->Release();
            }
            // If the segment has a next pointer, it still must be in another song. This
            // should never happen, but being paranoid...
            if ((*ppSegment)->GetNext())
            {
                *ppSegment = NULL;
                hr = E_FAIL;
                TraceI(0,"Error: Attempt to load song segment that is already referenced by another song. \n");
            }
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT CSong::LoadSegmentList(CRiffParser *pParser)
{
    assert(pParser);

    RIFFIO ckNext, ckChild;
    DWORD dwSegmentCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_LIST:
            if (ckNext.fccType == DMUS_FOURCC_SONGSEGMENT_LIST)
            {
                pParser->EnterList(&ckChild);
                while (pParser->NextChunk(&hr))
                {
                    switch(ckChild.ckid)
                    {
                    case FOURCC_RIFF:
                    case FOURCC_LIST:
                        if ((ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM) ||
                            (ckChild.fccType == DMUS_FOURCC_REF_LIST))
                        {
                            CSegment *pSegment = NULL;
                            if (ckChild.fccType == DMUS_FOURCC_SEGMENT_FORM)
                            {
                                pSegment = new CSegment;
                                if (pSegment)
                                {
                                    pSegment->AddRef(); // Segment::Load may need a refcount
                                    // Force the version so audiopath functionality will be supported.
                                    pSegment->m_dwVersion = 8;
                                    // Move back to start of this chunk.
                                    pParser->SeekBack();
                                    hr = pSegment->Load(pParser->GetStream());
                                    pParser->SeekForward();
                                }
                                else
                                {
                                    return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                // This will increment the refcount for the segment
                                hr = LoadReferencedSegment( &pSegment, pParser );
                            }
                            if (SUCCEEDED(hr))
                            {
                                // This increments the refcount.
                                m_SegmentList.AddSegment(pSegment,dwSegmentCount);
                            }
                            pSegment->Release(); // Release the extra AddRef
                            dwSegmentCount++;
                            if(SUCCEEDED(hr) && hr != DMUS_S_PARTIALLOAD)
                            {
                                m_fPartialLoad |= PARTIALLOAD_S_OK;
                            }
                            else
                            {
                                m_fPartialLoad |= PARTIALLOAD_E_FAIL;
                                hr = S_OK;
                            }

                        }
                        break;
                    }
                }
                pParser->LeaveList();
            }

        default:
            break;

        }
    }
    pParser->LeaveList();

    return hr;
}

HRESULT CSong::LoadGraphList(CRiffParser *pParser)
{
    RIFFIO ckNext;
    DWORD dwGraphCount = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
                switch(ckNext.fccType)
                {
                    CGraph *pGraph;
                    case DMUS_FOURCC_TOOLGRAPH_FORM :
                        // Move back to start of this chunk.
                        pParser->SeekBack();
                        pGraph = new CGraph;
                        if (pGraph)
                        {
                            hr = pGraph->Load(pParser->GetStream());
                            dwGraphCount++;
                            if (SUCCEEDED(hr))
                            {
                                m_GraphList.AddTail(pGraph);
                                pGraph->m_dwLoadID = dwGraphCount;
                            }
                            if(SUCCEEDED(hr) && hr != DMUS_S_PARTIALLOAD)
                            {
                                m_fPartialLoad |= PARTIALLOAD_S_OK;
                            }
                            else
                            {
                                m_fPartialLoad |= PARTIALLOAD_E_FAIL;
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        pParser->SeekForward();
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
                                    DMUS_IO_TRANSITION_DEF *pTransDef)
{
    HRESULT hr = DMUS_E_NOT_FOUND;
//    if (pSource) Trace(0,"Transitioning from %ls ",pSource->m_wszName);
//    if (pDestination) Trace(0,"to %ls",pDestination->m_wszName);
//    Trace(0,"\n");
    EnterCriticalSection(&m_CriticalSection);
    // Default values for other fields, in case we don't find a match.
    pTransDef->dwPlayFlags = 0;
    pTransDef->dwTransitionID = DMUS_SONG_NOSEG;
    pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
    CVirtualSegment *pVSource = NULL;
    // If there is a source segment, look to see if it's in this song
    // and pull the matchin virtual segment.
    if (pSource)
    {
        pVSource = m_VirtualSegmentList.GetHead();
        for (;pVSource;pVSource = pVSource->GetNext())
        {
            if (pVSource->m_pPlaySegment == pSource)
            {
//                Trace(0,"Found match for source segment %ls in song\n",pSource->m_wszName);
                break;
            }
        }
    }
    CVirtualSegment *pVDestination = NULL;
    // If there is a destination segment, look to see if it's in this song
    // and pull the matching virtual segment.
    if (pDestination)
    {
        pVDestination = m_VirtualSegmentList.GetHead();
        for (;pVDestination;pVDestination = pVDestination->GetNext())
        {
            if (pVDestination->m_pPlaySegment == pDestination)
            {
//                Trace(0,"Found match for destination segment %ls in song\n",pDestination->m_wszName);
                break;
            }
        }
    }

    if (pVSource)
    {
        if (pVDestination)
        {
            pTransDef->dwSegmentID = pVDestination->m_dwID;
        }
        else
        {
            // If there is no destination, mark this to transition to nothing.
            pTransDef->dwSegmentID = DMUS_SONG_NOSEG;
        }
        if (pVSource->m_dwTransitionCount)
        {
            ASSERT(pVSource->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement.
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVSource->m_dwTransitionCount; dwIndex++)
            {
                if (pVSource->m_pTransitions[dwIndex].dwSegmentID == pTransDef->dwSegmentID)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
                else if ((pVSource->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_ANYSEG) && !dwMatchCount)
                {
                    // Mark the segment and flags, but don't break because we might still have the matched segment in the list.
                    pTransDef->dwPlayFlags = pVSource->m_pTransitions[dwIndex].dwPlayFlags;
                    pTransDef->dwTransitionID = pVSource->m_pTransitions[dwIndex].dwTransitionID;
//Trace(0,"Found default transition from %lx with Transition %lx, flags %lx\n",pVSource->m_pTransitions[dwIndex].dwSegmentID,
//    pVSource->m_pTransitions[dwIndex].dwTransitionID,pVSource->m_pTransitions[dwIndex].dwPlayFlags);
                    hr = S_OK;
                    break;
                }
            }
        }
    }
    else if (pVDestination)
    {
        // This is the special case where there is no source segment, perhaps because we are starting
        // playback or we are starting from a different song. In this case, look for a transition in the destination
        // segment for the special case of DMUS_SONG_NOFROMSEG. Typically, this represents a transition
        // segment that is an intro.
        if (pVDestination->m_dwTransitionCount)
        {
            ASSERT(pVDestination->m_pTransitions);
            DWORD dwIndex;
            DWORD dwMatchCount = 0;
            // First, find out how many transitions match the requirement.
            // We'll randomly select from the matching ones.
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    dwMatchCount++;
                }
            }
            DWORD dwChoice;
            if (dwMatchCount)
            {
                dwChoice = rand() % dwMatchCount;
            }
            for (dwIndex = 0; dwIndex < pVDestination->m_dwTransitionCount; dwIndex++)
            {
                if (pVDestination->m_pTransitions[dwIndex].dwSegmentID == DMUS_SONG_NOFROMSEG)
                {
                    if (!dwChoice)
                    {
//Trace(0,"Chose transition from NONE with Transition %lx, flags %lx\n",
//    pVDestination->m_pTransitions[dwIndex].dwTransitionID,pVDestination->m_pTransitions[dwIndex].dwPlayFlags);
                        pTransDef->dwPlayFlags = pVDestination->m_pTransitions[dwIndex].dwPlayFlags;
                        pTransDef->dwTransitionID = pVDestination->m_pTransitions[dwIndex].dwTransitionID;
                        hr = S_OK;
                        break;
                    }
                    dwChoice--;
                }
            }
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
#ifdef DBG
    if (hr == DMUS_E_NOT_FOUND)
    {
        Trace(2,"Warning: No transition segment was found in song.\n");
    }
#endif
    return hr;
}


void CSong::GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID)
{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                pSongSegment->m_pSegment->AddRef();
                *ppSegment = pSongSegment->m_pSegment;
                return;
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
}

void CSong::GetGraph(CGraph **ppGraph,DWORD dwGraphID)
{
    CGraph *pGraph = m_GraphList.GetHead();
    while (pGraph)
    {
        if (pGraph->m_dwLoadID == dwGraphID)
        {
            pGraph->AddRef();
            *ppGraph = pGraph;
            return;
        }
        pGraph = pGraph->GetNext();
    }
}

BOOL CSong::GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID)
{
    CSongSegment *pSongSegment = m_SegmentList.GetHead();
    while (pSongSegment)
    {
        if (pSongSegment->m_dwLoadID == dwSegmentID)
        {
            if (pSongSegment->m_pSegment)
            {
                return (pSongSegment->m_pSegment->GetTrack(guidClassID,dwGroupBits,dwIndex,ppTrack) == S_OK);
            }
        }
        pSongSegment = pSongSegment->GetNext();
    }
    return FALSE;
}


HRESULT CSong::LoadVirtualSegmentList(CRiffParser *pParser)
{
    RIFFIO ckNext;
    RIFFIO ckChild;
    RIFFIO ckUNFO;
    DWORD dwSegmentCount = 0;
    CVirtualSegment *pVirtualSegment;
    MUSIC_TIME mtTime = 0;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_RIFF:
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    case DMUS_FOURCC_SEGREF_LIST:
                        pVirtualSegment = new CVirtualSegment;
                        if (pVirtualSegment)
                        {
                            BOOL fGotHeader = FALSE;
                            BOOL fGotSegmentHeader = FALSE;
                            pVirtualSegment->m_mtTime = mtTime; // Give the start time, an accumulation of all preceding segments.
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case FOURCC_RIFF:
                                    case FOURCC_LIST:
                                        switch(ckChild.fccType)
                                        {
                                        case DMUS_FOURCC_TRACKREFS_LIST:
                                            hr = LoadTrackRefList(pParser, pVirtualSegment);
                                            break;
                                        case DMUS_FOURCC_UNFO_LIST:
                                            pParser->EnterList(&ckUNFO);
                                            while(pParser->NextChunk(&hr))
                                            {
                                                switch( ckUNFO.ckid )
                                                {
                                                    case DMUS_FOURCC_UNAM_CHUNK:
                                                    {
                                                        hr = pParser->Read(pVirtualSegment->m_wszName, sizeof(pVirtualSegment->m_wszName));
                                                        break;
                                                    }
                                                    default:
                                                        break;
                                                }
                                            }
                                            pParser->LeaveList();
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGREF_CHUNK:
                                    {
                                        DMUS_IO_SEGREF_HEADER ioVirtualSegment;
                                        hr = pParser->Read(&ioVirtualSegment,sizeof(ioVirtualSegment));
                                        if(SUCCEEDED(hr) )
                                        {
                                            pVirtualSegment->m_dwFlags = ioVirtualSegment.dwFlags;
                                            pVirtualSegment->m_dwID = ioVirtualSegment.dwID;
                                            pVirtualSegment->m_dwNextPlayID = ioVirtualSegment.dwNextPlayID;
                                            if (ioVirtualSegment.dwSegmentID != DMUS_SONG_NOSEG)
                                            {
                                                GetSourceSegment(&pVirtualSegment->m_pSourceSegment,ioVirtualSegment.dwSegmentID);
                                            }
                                            if (ioVirtualSegment.dwToolGraphID != DMUS_SONG_NOSEG)
                                            {
                                                GetGraph(&pVirtualSegment->m_pGraph,ioVirtualSegment.dwToolGraphID);
                                            }
                                            fGotHeader = TRUE;
                                        }
                                        break;
                                    }
                                    case DMUS_FOURCC_SEGTRANS_CHUNK:
                                        {
                                            DWORD dwTransCount;
                                            dwTransCount = ckChild.cksize / sizeof(DMUS_IO_TRANSITION_DEF);
                                            if (dwTransCount > 0)
                                            {
                                                pVirtualSegment->m_pTransitions = new DMUS_IO_TRANSITION_DEF[dwTransCount];
                                                if (pVirtualSegment->m_pTransitions)
                                                {
                                                    pVirtualSegment->m_dwTransitionCount = dwTransCount;
                                                    hr = pParser->Read(pVirtualSegment->m_pTransitions,sizeof(DMUS_IO_TRANSITION_DEF)*dwTransCount);
                                                }
                                                else
                                                {
                                                    return E_OUTOFMEMORY;
                                                }
                                            }
                                        }
                                        break;
                                    case DMUS_FOURCC_SEGMENT_CHUNK:
                                        fGotSegmentHeader = TRUE;
                                        hr = pParser->Read(&pVirtualSegment->m_SegHeader, sizeof(DMUS_IO_SEGMENT_HEADER));
                                        mtTime += (pVirtualSegment->m_SegHeader.dwRepeats * (pVirtualSegment->m_SegHeader.mtLoopEnd - pVirtualSegment->m_SegHeader.mtLoopStart)) +
                                            pVirtualSegment->m_SegHeader.mtLength - pVirtualSegment->m_SegHeader.mtPlayStart;
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotSegmentHeader)
                            {
//Trace(0,"Adding VSegment %ls with ID %ld to song.\n",pVirtualSegment->m_wszName,pVirtualSegment->m_dwID);
                                m_VirtualSegmentList.AddTail(pVirtualSegment);
                            }
                            else
                            {
                                delete pVirtualSegment;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;
                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

struct ClassGuidCounts
{
    GUID guidClass;
    DWORD dwCount;
};

HRESULT CSong::LoadTrackRefList(CRiffParser *pParser,CVirtualSegment *pVirtualSegment)
{
    RIFFIO ckNext;
    RIFFIO ckChild;

    HRESULT hr = S_OK;
    TList<ClassGuidCounts> GuidCountList;
    pParser->EnterList(&ckNext);
    while(pParser->NextChunk(&hr))
    {
        switch(ckNext.ckid)
        {
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                    CTrack *pTrack;
                    case DMUS_FOURCC_TRACKREF_LIST :
                        pTrack = new CTrack;
                        if (pTrack)
                        {
                            TListItem<ClassGuidCounts>* pCountItem = NULL;
                            DMUS_IO_TRACKREF_HEADER ioTrackRef;
                            DMUS_IO_TRACK_HEADER ioTrackHdr;
                            DMUS_IO_TRACK_EXTRAS_HEADER ioTrackExtrasHdr;
                            ioTrackExtrasHdr.dwPriority = 0;
                            ioTrackExtrasHdr.dwFlags = DMUS_TRACKCONFIG_DEFAULT;
                            ioTrackHdr.dwPosition = 0;
                            BOOL fGotHeader = FALSE;
                            BOOL fGotRef = FALSE;
                            pParser->EnterList(&ckChild);
                            while(pParser->NextChunk(&hr))
                            {
                                switch( ckChild.ckid )
                                {
                                    case DMUS_FOURCC_TRACKREF_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackRef, sizeof(ioTrackRef));
                                        fGotRef = SUCCEEDED(hr);
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackHdr, sizeof(ioTrackHdr));
                                        fGotHeader = SUCCEEDED(hr);
                                        pTrack->m_guidClassID = ioTrackHdr.guidClassID;
                                        pTrack->m_dwGroupBits = ioTrackHdr.dwGroup;
                                        pTrack->m_dwPosition = ioTrackHdr.dwPosition;
                                        break;
                                    }
                                    case DMUS_FOURCC_TRACK_EXTRAS_CHUNK:
                                    {
                                        hr = pParser->Read(&ioTrackExtrasHdr, sizeof(ioTrackExtrasHdr));
                                        pTrack->m_dwPriority = ioTrackExtrasHdr.dwPriority;
                                        pTrack->m_dwFlags = ioTrackExtrasHdr.dwFlags;
                                        break;

                                    }
                                    default:
                                        break;
                                }
                            }
                            pParser->LeaveList();
                            if (fGotHeader && fGotRef)
                            {
                                if (ioTrackRef.dwSegmentID != DMUS_SONG_NOSEG)
                                {
                                    DWORD dwID = 0;
                                    for (pCountItem = GuidCountList.GetHead(); pCountItem; pCountItem = pCountItem->GetNext())
                                    {
                                        if (pCountItem->GetItemValue().guidClass == pTrack->m_guidClassID)
                                        {
                                            break;
                                        }
                                    }
                                    if (pCountItem)
                                    {
                                        dwID = pCountItem->GetItemValue().dwCount;
                                    }
                                    fGotHeader = GetSegmentTrack(&pTrack->m_pTrack,ioTrackRef.dwSegmentID,pTrack->m_dwGroupBits,dwID,pTrack->m_guidClassID);
                                }
                            }
                            if (fGotHeader && pTrack->m_pTrack)
                            {
                                pTrack->m_pTrack->QueryInterface(IID_IDirectMusicTrack8,(void **) &pTrack->m_pTrack8);
                                // Add the track based on position.
                                CTrack* pScan = pVirtualSegment->m_TrackList.GetHead();
                                CTrack* pPrevTrack = NULL;
                                for (; pScan; pScan = pScan->GetNext())
                                {
                                    if (pTrack->Less(pScan))
                                    {
                                        break;
                                    }
                                    pPrevTrack = pScan;
                                }
                                if (pPrevTrack)
                                {
                                    pPrevTrack->SetNext(pTrack);
                                    pTrack->SetNext(pScan);
                                }
                                else
                                {
                                    pVirtualSegment->m_TrackList.AddHead( pTrack );
                                }
                                if (pCountItem)
                                {
                                    pCountItem->GetItemValue().dwCount++;
                                }
                                else
                                {
                                    TListItem<ClassGuidCounts>* pNew = new TListItem<ClassGuidCounts>;
                                    if (pNew)
                                    {
                                        pNew->GetItemValue().dwCount = 1;
                                        pNew->GetItemValue().guidClass = pTrack->m_guidClassID;
                                        GuidCountList.AddHead(pNew);
                                    }
                                    else return E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                delete pTrack;
                            }
                            break;
                        }
                        else
                        {
                            return E_OUTOFMEMORY;
                        }
                        break;

                    default:
                        break;
                }
                break;

            default:
                break;

        }
    }
    pParser->LeaveList();
    return hr;
}

HRESULT CSong::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CSong::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CSong::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::GetDescriptor);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::GetDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicSong;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CSong::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CSong::SetDescriptor);
    V_STRUCTPTR_READ(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::SetDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }
        m_dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            Trace(2,"Warning: Song::SetDescriptor was not able to handle all passed fields, dwValidData bits %lx.\n",pDesc->dwValidData & (~dw));
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CSong::ParseDescriptor(LPSTREAM pIStream, LPDMUS_OBJECTDESC pDesc)
{
    V_INAME(CSong::ParseDescriptor);
    V_INTERFACE(pIStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicSong::ParseDescriptor after the song has been garbage collected. "
                    "It is invalid to continue using a song after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }

    CRiffParser Parser(pIStream);
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_SONG_FORM))
    {
        pDesc->dwValidData = DMUS_OBJ_CLASS;
        pDesc->guidClass = CLSID_DirectMusicSong;
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
                break;
            case DMUS_FOURCC_VERSION_CHUNK:
                hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
                if( SUCCEEDED(hr) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                if( SUCCEEDED(hr))
                {
                    pDesc->dwValidData |= DMUS_OBJ_DATE;
                }
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
                    {
                        switch( ckUNFO.ckid )
                        {
                        case DMUS_FOURCC_UNAM_CHUNK:
                        {
                            hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            if(SUCCEEDED(hr) )
                            {
                                pDesc->dwValidData |= DMUS_OBJ_NAME;
                            }
                            break;
                        }
                        default:
                            break;
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;

            default:
                break;

            }
        }
        Parser.LeaveList();
    }
    else
    {
        // Couldn't find the chunk header for a song.
        // But, maybe this is actually a segment, in which case see if
        // the segment object will parse it.
        CSegment *pSegment = new CSegment;
        if (pSegment)
        {
            pSegment->AddRef(); // just to be safe...
            // Force the version so audiopath functionality will be supported.
            pSegment->m_dwVersion = 8;
            Parser.SeekBack();
            hr = pSegment->ParseDescriptor(pIStream,pDesc);
            pDesc->guidClass = CLSID_DirectMusicSong;
            // Done with the segment, say bye bye.
            delete pSegment;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

ComposingTrack::ComposingTrack() : m_dwTrackGroup(0), m_dwPriority(0)
{
    memset((void*) &m_guidClassID, 0, sizeof(m_guidClassID));
}

ComposingTrack::~ComposingTrack()
{
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (rComponent.pVirtualSegment && rComponent.pVirtualSegment->m_pPlaySegment)
        {
            rComponent.pVirtualSegment->m_pPlaySegment->Release();
        }
        if (rComponent.pComposingTrack && rComponent.pComposingTrack->m_pTrack8)
        {
            rComponent.pComposingTrack->m_pTrack8->Release();
        }
    }
}

HRESULT ComposingTrack::AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack)
{
    HRESULT hr = S_OK;
    if (!pVirtualSegment || !pVirtualSegment->m_pPlaySegment || !pTrack || !pTrack->m_pTrack8)
    {
        Trace(1,"Error: Unable to compose song because of a required segment or track is missing.\n");
        return E_INVALIDARG;
    }
    TListItem<CompositionComponent>* pComponent = new TListItem<CompositionComponent>;
    if (!pComponent)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pVirtualSegment->m_pPlaySegment->AddRef();
        pTrack->m_pTrack8->AddRef();
        CompositionComponent& rComponent = pComponent->GetItemValue();
        rComponent.pVirtualSegment = pVirtualSegment;
        rComponent.pComposingTrack = pTrack;
        rComponent.mtTime = pVirtualSegment->m_mtTime;
        m_Components.AddHead(pComponent);
    }
    return hr;
}

BOOL Less(CompositionComponent& Comp1, CompositionComponent& Comp2)
{
    return Comp1.mtTime < Comp2.mtTime;
}

// Compose does the joining, composing, successive splitting, and adding to segments
HRESULT ComposingTrack::Compose(IDirectMusicSong* pSong)
{
    HRESULT hr = S_OK;
    IDirectMusicTrack8* pMasterTrack = NULL;
    IDirectMusicTrack8* pComposedTrack = NULL;
    m_Components.MergeSort(Less);
    // Join the tracks together according to the ordering of their associated segments.
    TListItem<CompositionComponent>* pComponent = m_Components.GetHead();
    for (; pComponent; pComponent = pComponent->GetNext())
    {
        CompositionComponent& rComponent = pComponent->GetItemValue();
        if (!pMasterTrack)
        {
            //MUSIC_TIME mtEnd = 0;
            //if (pComponent->GetNext())
            //{
            //  mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
            //}
            //else
            //{
            //  rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtEnd);
            //}
            //hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, mtEnd, (IDirectMusicTrack**)&pMasterTrack);
            hr = rComponent.pComposingTrack->m_pTrack8->Clone(0, 0, (IDirectMusicTrack**)&pMasterTrack);
        }
        //else
        if (SUCCEEDED(hr))
        {
            hr = pMasterTrack->Join(rComponent.pComposingTrack->m_pTrack8, rComponent.mtTime, pSong, m_dwTrackGroup, NULL);
        }
        if (FAILED(hr)) break;
    }

    // Call Compose on the joined track.
    if (SUCCEEDED(hr))
    {
        hr = pMasterTrack->Compose(pSong, m_dwTrackGroup, (IDirectMusicTrack**)&pComposedTrack);
    }

    // Split the composed result according to the original segments.
    if (SUCCEEDED(hr))
    {
        MUSIC_TIME mtStart = 0;
        MUSIC_TIME mtEnd = 0;
        pComponent = m_Components.GetHead();
        for (; pComponent; pComponent = pComponent->GetNext())
        {
            CompositionComponent& rComponent = pComponent->GetItemValue();
            mtStart = rComponent.mtTime;
            // only split off a composed track if the original segment contained a composing track
            IDirectMusicTrack* pOldTrack = NULL;
            IPersistStream* pPersist = NULL;
            GUID guidClassId;
            memset(&guidClassId, 0, sizeof(guidClassId));
            if (SUCCEEDED(pMasterTrack->QueryInterface(IID_IPersistStream, (void**)&pPersist)) &&
                SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) )  )
            {
                pPersist->Release();
                pOldTrack->Release();
                if (pComponent->GetNext())
                {
                    mtEnd = pComponent->GetNext()->GetItemValue().mtTime;
                }
                else
                {
                    MUSIC_TIME mtLength = 0;
                    rComponent.pVirtualSegment->m_pPlaySegment->GetLength(&mtLength);
                    mtEnd = mtStart + mtLength;
                }
                IDirectMusicTrack8* pComposedFragment = NULL;
                hr = pComposedTrack->Clone(mtStart, mtEnd, (IDirectMusicTrack**)&pComposedFragment);
                if (SUCCEEDED(hr))
                {
                    // Remove any tracks of this type (in the same group) from the segment.
                    pOldTrack = NULL;
                    pPersist = NULL;
                    memset(&guidClassId, 0, sizeof(guidClassId));
                    if (SUCCEEDED(pComposedFragment->QueryInterface(IID_IPersistStream, (void**)&pPersist)) )
                    {
                        if (SUCCEEDED(pPersist->GetClassID(&guidClassId)) &&
                            SUCCEEDED( rComponent.pVirtualSegment->m_pPlaySegment->GetTrack( guidClassId, m_dwTrackGroup, 0, &pOldTrack ) ) )
                        {
                            rComponent.pVirtualSegment->m_pPlaySegment->RemoveTrack( pOldTrack );
                            pOldTrack->Release();
                        }
                        pPersist->Release();
                    }
                    hr = rComponent.pVirtualSegment->m_pPlaySegment->InsertTrack(pComposedFragment, m_dwTrackGroup);
                    pComposedFragment->Release(); // release from the Clone
                }

                if (FAILED(hr)) break;
            }
            else // the QI to pPersist might have succeeded, so clean it up
            {
                if (pPersist) pPersist->Release();
            }
        }
        if (pComposedTrack) pComposedTrack->Release();
    }

    if (pMasterTrack) pMasterTrack->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\smartref.cpp ===
// Copyright (c) 1999 Microsoft Corporation. All rights reserved.
//
// Simple helper classes that use the "resource acquisition is initialization" technique.
// In English, this means they acquire a reference to a resource and the resource is automatically
//    released in the destructor.
//

#include "smartref.h"
using namespace SmartRef;
#include <xutility>
#include "miscutil.h"
#include "dmusicf.h"

//////////////////////////////////////////////////////////////////////
// AString

AString::AString(const char *psz, UINT cch)
{
    assert(psz);
    m_psz = new char[cch + 1];
    if (m_psz)
    {
        strncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }
}

AString &
AString::operator =(const char *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        m_psz = new char[strlen(psz) + 1];
        if (m_psz)
            strcpy(m_psz, psz);
    }

    return *this;
}

AString &AString::Assign(const char *psz, UINT cch)
{
    assert(psz);
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    m_psz = new char[cch + 1];
    if (m_psz)
    {
        strncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }

    return *this;
}

AString &
AString::AssignFromW(const WCHAR *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        int cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, NULL, 0, NULL, NULL);
        if (cch)
        {
            m_psz = new char[cch];
            if (m_psz)
            {
                cch = WideCharToMultiByte(CP_ACP, 0, psz, -1, m_psz, cch, NULL, NULL);
                if (!cch)
                {
                    assert(false);
                    delete[] m_psz;
                    m_psz = NULL;
                }
            }
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////
// WString

WString &
WString::operator =(const WCHAR *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        m_psz = new WCHAR[wcslen(psz) + 1];
        if (m_psz)
            wcscpy(m_psz, psz);
    }

    return *this;
}

WString &WString::Assign(const WCHAR *psz, UINT cch)
{
    assert(psz);
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    m_psz = new WCHAR[cch + 1];
    if (m_psz)
    {
        wcsncpy(m_psz, psz, cch);
        m_psz[cch] = L'\0';
    }

    return *this;
}

WString &
WString::AssignFromA(const char *psz)
{
    if (m_psz)
    {
        delete[] m_psz;
        m_psz = NULL;
    }

    if (psz)
    {
        int cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
        if (cch)
        {
            m_psz = new WCHAR[cch];
            if (m_psz)
            {
                cch = MultiByteToWideChar(CP_ACP, 0, psz, -1, m_psz, cch);
                if (!cch)
                {
                    assert(false);
                    delete[] m_psz;
                    m_psz = NULL;
                }
            }
        }
    }

    return *this;
}

//////////////////////////////////////////////////////////////////////
// RiffIter

RiffIter::RiffIter(IStream *pStream)
  : m_hr(S_OK),
    m_pIStream(pStream),
    m_pIDMStream(NULL),
    m_fParent(false)
{
    m_pIStream->AddRef();

    ZeroMemory(&m_ckParent, sizeof(m_ckParent));
    ZeroMemory(&m_ckChild, sizeof(m_ckChild));

    m_hr = ::AllocDirectMusicStream(m_pIStream, &m_pIDMStream);
    if (FAILED(m_hr))
        return;

    m_hr = m_pIDMStream->Descend(&m_ckChild, NULL, 0);
}

RiffIter::~RiffIter()
{
    if (!m_fParent)
    {
        SafeRelease(m_pIStream);
        SafeRelease(m_pIDMStream);
    }
}

RiffIter
&RiffIter::operator ++()
{
    if (validate())
        return *this;

    m_hr = m_pIDMStream->Ascend(&m_ckChild, 0);
    if (FAILED(m_hr))
        return *this;

    m_ckChild.ckid = 0;
    m_ckChild.fccType = 0;
    m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);
    return *this;
}

RiffIter
&RiffIter::Find(RiffType t, FOURCC idFind)
{
    if (validate())
        return *this;

    while (*this && (type() != t || id() != idFind))
        ++*this;

    return *this;
}

HRESULT
RiffIter::ReadChunk(
        void *pv,
        UINT cb)
{
    if (type() != Chunk)
    {
        assert(false);
        return DMUS_E_CANNOTREAD;
    }

    ZeroMemory(pv, cb);
    DWORD cbRead = 0;
    DWORD cbSize = std::_cpp_min<DWORD>(cb, m_ckChild.cksize);
    HRESULT hr = m_pIStream->Read(pv, cbSize, &cbRead);
    if (FAILED(hr) || cbRead != cbSize)
    {
        Trace(1, "Error: Unable to read file.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    return hr;
}

HRESULT
RiffIter::ReadArrayChunk(
    DWORD cbSize,
    void **ppv,
    int *pcRecords)
{
    // zero the out params
    *ppv = NULL;
    *pcRecords = 0;

    // get the size of the chunk and its records

    UINT cbChunk = size();
    if (cbChunk < sizeof(DWORD))
    {
        assert(false);
        return E_FAIL;
    }

    DWORD cbChunkRecord = 0;
    HRESULT hr = RiffIterReadChunk(*this, &cbChunkRecord);
    if (FAILED(hr))
        return hr;
    cbChunk -= sizeof(DWORD);

    if (cbChunk % cbChunkRecord != 0)
    {
        // array is not divisible by size of records!
        assert(false);
        return E_FAIL;
    }

    UINT cRecords = cbChunk / cbChunkRecord;

    // Get the whole rest of the chunk
    PtrArray<char> sprgChunk = new char[cbChunk];
    if (!sprgChunk)
        return E_OUTOFMEMORY;
    hr = ReadChunk(sprgChunk, cbChunk);
    if (FAILED(hr))
        return hr;

    // Return the chunk and its info.

    if (cbChunkRecord == cbSize)
    {
        // Great!  Return the chunk as is.
        *ppv = sprgChunk.disown();
    }
    else
    {
        // make an array of the requested size
        char *pArray = new char[cbSize * cRecords];
        if (!pArray)
            return E_OUTOFMEMORY;
        ZeroMemory(pArray, cbSize * cRecords);

        // copy each record
        char *pRec = sprgChunk; // iterate reading each record of the chunk
        char *pEnd = pRec + cbChunkRecord * cRecords; // stop before this (nonexistant) record
        char *pOut = pArray; // iterate writing into the array
        while (pRec < pEnd)
        {
            memcpy(pOut, pRec, std::_cpp_min<DWORD>(cbChunkRecord, cbSize));
            pRec += cbChunkRecord;
            pOut += cbSize;
        }
        *ppv = pArray;
    }

    *pcRecords = cRecords;
    return hr;
}

HRESULT RiffIter::FindAndGetEmbeddedObject(
        RiffType t,
        FOURCC idFind,
        HRESULT hrOnNotFound,
        IDirectMusicLoader *pLoader,
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    if (validate() || !pLoader || !ppv)
    {
        assert(false);
        return E_FAIL;
    }

    *ppv = NULL;
    MMCKINFO ckLast;
    ZeroMemory(&ckLast, sizeof(ckLast));

    while (*this && (type() != t || id() != idFind))
    {
        ckLast = m_ckChild;
        ++*this;
    }

    if (!*this)
        return hrOnNotFound;

    // Ascend in such a way that the stream can be used to find this chunk.
    m_hr = m_pIDMStream->Ascend(&ckLast, 0);
    if (FAILED(m_hr))
        return m_hr;

    // Call GetObject using the stream
    DMUS_OBJECTDESC desc;
    ZeroAndSize(&desc);
    desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
    desc.guidClass = rclsid;
    desc.pStream = m_pIStream;
    HRESULT hrLoad = pLoader->GetObject(&desc, riid, ppv);

    // Descend again to leave the stream at the next chunk
    m_ckChild.ckid = 0;
    m_ckChild.fccType = 0;
    m_hr = m_pIDMStream->Descend(&m_ckChild, m_fParent ? &m_ckParent : NULL, 0);

    HRESULT hrDescend = this->hr();
    if (FAILED(hrDescend))
    {
        // Give precedence to reporting failure in the stream even though getting the
        // object succeeded before the failure.
        if (*ppv)
        {
            IUnknown *punk = static_cast<IUnknown *>(*ppv);
            if (punk)
                punk->Release();
            *ppv = NULL;
        }
        return hrDescend;
    }
    else
    {
        return hrLoad;
    }
}

HRESULT
RiffIter::ReadReference(DMUS_OBJECTDESC *pDESC)
{
    HRESULT hr = S_OK;

    assert(this->type() == List && this->id() == DMUS_FOURCC_REF_LIST);

    ZeroAndSize(pDESC);

    for (RiffIter ri = this->Descend(); ri; ++ri)
    {
        switch (ri.id())
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = SmartRef::RiffIterReadChunk(ri, &ioDMRef);
                if (SUCCEEDED(hr))
                {
                    pDESC->guidClass = ioDMRef.guidClassID;
                    pDESC->dwValidData |= ioDMRef.dwValidData;
                    pDESC->dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->guidObject);
                if (SUCCEEDED(hr))
                    pDESC->dwValidData |=  DMUS_OBJ_OBJECT;
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->ftDate);
                if (SUCCEEDED(hr))
                    pDESC->dwValidData |=  DMUS_OBJ_DATE;
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszName);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszName[DMUS_MAX_NAME - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_NAME;
                }
                break;
            
            case DMUS_FOURCC_FILE_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszFileName);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                hr = SmartRef::RiffIterReadChunk(ri, &pDESC->wszCategory);
                if (SUCCEEDED(hr))
                {
                    pDESC->wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    pDESC->dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = SmartRef::RiffIterReadChunk(ri, &ioDMObjVer);
                if (SUCCEEDED(hr))
                {
                    pDESC->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    pDESC->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    pDESC->dwValidData |= DMUS_OBJ_VERSION;
                }
                else
                {
                    hr = E_FAIL;
                }
                break;

            default:
                break;
        }
    }
    return hr;
}

HRESULT RiffIter::LoadObjectInfo(ObjectInfo *pObjInfo, RiffType rtypeStop, FOURCC ridStop)
{
    assert(pObjInfo);
    pObjInfo->Clear();

    HRESULT hr = S_OK;

    if (!(*this))
        return this->hr();

    for ( ; *this; ++(*this))
    {
        RiffType rtype = type();
        FOURCC fcc = id();
        if (rtype == rtypeStop && fcc == ridStop)
            return S_OK;

        if (rtype == SmartRef::RiffIter::Chunk)
        {
            if (fcc == DMUS_FOURCC_GUID_CHUNK)
                hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->guid);
            else if (fcc == DMUS_FOURCC_VERSION_CHUNK)
                hr = SmartRef::RiffIterReadChunk(*this, &pObjInfo->vVersion);
        }
        else if (rtype == SmartRef::RiffIter::List)
        {
            if (fcc == DMUS_FOURCC_UNFO_LIST)
            {
                RiffIter riUnfo = this->Descend();
                if (!riUnfo)
                    return riUnfo.hr();
                if (riUnfo.Find(SmartRef::RiffIter::Chunk, DMUS_FOURCC_UNAM_CHUNK))
                {
                    hr = riUnfo.ReadTextTrunc(pObjInfo->wszName, DMUS_MAX_NAME);
                    if (FAILED(hr))
                        return hr;
                }
            }
        }

        if (FAILED(hr))
            return hr;
    }
    
    Trace(1, "Error: Unable to read file.\n");
    return E_FAIL;
}

HRESULT RiffIter::ReadText(WCHAR **ppwsz)
{
    DWORD dwSize = this->size();
    if (dwSize % 2 != 0)
    {
        assert(false);
        return E_FAIL;
    }
    *ppwsz = new WCHAR[dwSize / 2];
    if (!*ppwsz)
        return E_OUTOFMEMORY;
    HRESULT hr = this->ReadChunk(*ppwsz, dwSize);
    return hr;
}

HRESULT RiffIter::ReadTextTrunc(WCHAR *pwsz, UINT cbBufSize)
{
    DWORD dwSize = this->size();
    if (dwSize % 2 != 0)
    {
        assert(false);
        return E_FAIL;
    }
    HRESULT hr = this->ReadChunk(pwsz, std::_MIN<DWORD>(dwSize, (cbBufSize - 1) * 2));
    pwsz[cbBufSize - 1] = L'\0';
    return hr;
}

RiffIter::RiffIter(const RiffIter &other, MMCKINFO ckParent)
  : m_hr(S_OK),
    m_pIStream(other.m_pIStream),
    m_pIDMStream(other.m_pIDMStream),
    m_fParent(true),
    m_ckParent(ckParent)
{
    other.validate();
    ZeroMemory(&m_ckChild, sizeof(m_ckChild));

    m_hr = m_pIDMStream->Descend(&m_ckChild, &m_ckParent, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\tempotrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// TempoTrk.cpp : Implementation of CTempoTrack
#include "dmime.h"
#include "TempoTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "dmperf.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT  assert

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack

void CTempoTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_cRef = 1;
    m_dwValidate = 0;
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
}

CTempoTrack::CTempoTrack()
{
    Construct();
    m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTempoTrack::CTempoTrack(
        const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    m_fActive = rTrack.m_fActive;
    m_fStateSetBySetParam = rTrack.m_fStateSetBySetParam;
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = rTrack.m_TempoEventList.GetHead();
    //1////////////////////////////////////////
    TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
    //1////////////////////////////////////////
    for(; pScan; pScan = pScan->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
        //2////////////////////////////////////////
        if (rScan.lTime < mtStart)
        {
            pPrevious = pScan;
        }
        //2////////////////////////////////////////
        else if (rScan.lTime < mtEnd)
        {
            //3////////////////////////////////////////
            if (rScan.lTime == mtStart)
            {
                pPrevious = NULL;
            }
            //3////////////////////////////////////////
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (pNew)
            {
                DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
                memcpy( &rNew, &rScan, sizeof(DMUS_IO_TEMPO_ITEM) );
                rNew.lTime = rScan.lTime - mtStart;
                m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
            }
        }
        else break;
    }
    m_TempoEventList.Reverse(); // for above AddHead.
    //4////////////////////////////////////////
    if (pPrevious)
    {
        DMUS_IO_TEMPO_ITEM& rPrevious = pPrevious->GetItemValue();
        TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
        if (pNew)
        {
            DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
            memcpy( &rNew, &rPrevious, sizeof(DMUS_IO_TEMPO_ITEM) );
            rNew.lTime = 0;
            m_TempoEventList.AddHead(pNew);
        }
    }
    //4////////////////////////////////////////
}

CTempoTrack::~CTempoTrack()
{
    if (m_fCSInitialized)
    {
        DeleteCriticalSection(&m_CrSec);
    }
    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTempoTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTempoTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CTempoTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    } else
    if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    } else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Tempo Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTempoTrack | Release | Standard Release implementation for <i IDirectMusicTempoTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTempoTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTempoTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CTempoTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID); 
    *pClassID = CLSID_DirectMusicTempoTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTempoTrack::IsDirty()
{
    return S_FALSE;
}

/*

  @method HRESULT | ITempoTrack | Load |
  Call this with an IStream filled with DMUS_IO_TEMPO_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TEMPO_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain Tempo events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TempoTrack is released.
*/
HRESULT CTempoTrack::Load( IStream* pIStream )
{
    V_INAME(CTempoTrack::Load);
    V_INTERFACE(pIStream);
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    if( m_TempoEventList.GetHead() )
    {
        TListItem<DMUS_IO_TEMPO_ITEM>* pItem;
        while( pItem = m_TempoEventList.RemoveHead() )
        {
            delete pItem;
        }
    }

    // copy contents of the stream into the list.
    LARGE_INTEGER li;
    DMUS_IO_TEMPO_ITEM tempoEvent;
    // read in the chunk id
    DWORD dwChunk, dwSubSize;
    long lSize;
    pIStream->Read( &dwChunk, sizeof(DWORD), NULL );
    if( dwChunk != DMUS_FOURCC_TEMPO_TRACK )
    {
        Trace(1,"Error: Invalid data in tempo track.\n");
        LeaveCriticalSection(&m_CrSec);
        return DMUS_E_CHUNKNOTFOUND;
    }
    // read in the overall size
    pIStream->Read( &lSize, sizeof(long), NULL );
    // read in the size of the data structures
    if( FAILED( pIStream->Read( &dwSubSize, sizeof(DWORD), NULL )))
    {
        // Check to make sure our reads are succeeding (we can safely
        // assume the previous reads worked if we got this far.)
        Trace(1,"Error: Unable to read tempo track.\n");
        LeaveCriticalSection(&m_CrSec);
        return DMUS_E_CANNOTREAD;
    }
    lSize -= sizeof(DWORD);

    DWORD dwRead, dwSeek;
    if( dwSubSize > sizeof(DMUS_IO_TEMPO_ITEM) )
    {
        dwRead = sizeof(DMUS_IO_TEMPO_ITEM);
        dwSeek = dwSubSize - dwRead;
        li.HighPart = 0;
        li.LowPart = dwSeek;
    }
    else
    {
        dwRead = dwSubSize;
        dwSeek = 0;
    }
    if( dwRead )
    {
        while( lSize > 0 )
        {
            if( FAILED( pIStream->Read( &tempoEvent, dwRead, NULL )))
            {
                Trace(1,"Error: Failure reading tempo track.\n");
                hr = DMUS_E_CANNOTREAD;
                break;
            }
            lSize -= dwRead;
            if( dwSeek )
            {
                if( FAILED( pIStream->Seek( li, STREAM_SEEK_CUR, NULL )))
                {
                    Trace(1,"Error: Failure reading tempo track.\n");
                    hr = DMUS_E_CANNOTSEEK;
                    break;
                }                                             
                lSize -= dwSeek;
            }
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = 
                new TListItem<DMUS_IO_TEMPO_ITEM>(tempoEvent);
            if (pNew)
            {
                m_TempoEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
            }
        }
        m_TempoEventList.Reverse();
    }
    else
    {
        Trace(1,"Error: Failure reading tempo track.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CTempoTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
HRESULT STDMETHODCALLTYPE CTempoTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
    V_INAME(IDirectMusicTrack::IsParamSupported);
    V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
        if( m_fActive )
        {
            if( rguid == GUID_DisableTempo ) return S_OK;
            if( rguid == GUID_TempoParam ) return S_OK;
            if( rguid == GUID_PrivateTempoParam ) return S_OK;
            if( rguid == GUID_EnableTempo ) return DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( rguid == GUID_EnableTempo ) return S_OK;
            if( rguid == GUID_DisableTempo ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_PrivateTempoParam ) return DMUS_E_TYPE_DISABLED;
            if( rguid == GUID_TempoParam ) return DMUS_E_TYPE_DISABLED;
        }
    }
    else
    {
        if(( rguid == GUID_DisableTempo ) ||
            ( rguid == GUID_TempoParam ) ||
            ( rguid == GUID_PrivateTempoParam ) ||
            ( rguid == GUID_EnableTempo )) return S_OK;
    }

    return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTempoTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
    return S_OK;
}

HRESULT CTempoTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerformance);

    TempoStateData* pStateData;
    pStateData = new TempoStateData;
    if( NULL == pStateData )
        return E_OUTOFMEMORY;
    *ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->fActive = m_fActive;
    }
    else
    {
        pStateData->fActive = ((dwFlags & DMUS_SEGF_CONTROL) ||
            !(dwFlags & DMUS_SEGF_SECONDARY));
    }
    pStateData->dwVirtualTrackID = dwTrackID;
    pStateData->pPerformance = pPerformance; // weak reference, no addref.
    pStateData->pSegState = pSegmentState; // weak reference, no addref.
    pStateData->pCurrentTempo = m_TempoEventList.GetHead();
    pStateData->dwValidate = m_dwValidate;
    return S_OK;
}

HRESULT CTempoTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(TempoStateData));
        TempoStateData* pSD = (TempoStateData*)pStateData;
        delete pSD;
    }
    return S_OK;
}

STDMETHODIMP CTempoTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) 
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times. Then, just use same MUSIC_TIME
        // variables.
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else
    {
        hr = Play(pStateData,(MUSIC_TIME)rtStart,(MUSIC_TIME)rtEnd,
            (MUSIC_TIME)rtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

STDMETHODIMP CTempoTrack::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    DWORD dwFlags,  
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,   
    DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(TempoStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT hr = Play(pStateData,mtStart,mtEnd,mtOffset,0,dwFlags,pPerf,pSegSt,dwVirtualID,FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::Play( 
    void *pStateData,   
    MUSIC_TIME mtStart, 
    MUSIC_TIME mtEnd,
    MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,      
    IDirectMusicPerformance* pPerf, 
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = DMUS_S_END;
    IDirectMusicGraph* pGraph = NULL;
    TempoStateData* pSD = (TempoStateData*)pStateData;
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

    // if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
    // send out any negative time events. So, we'll set mtStart to -768.
    if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
    {
        mtStart = -768;
    }

    // if pSD->pCurrentTempo is NULL, and we're in a normal Play call (dwFlags is 0)
    // this means that we either have no events, or we got to the end of the event
    // list previously. So, it's safe to just return.
    if( (pSD->pCurrentTempo == NULL) && (dwFlags == 0) )
    {
        return S_FALSE;
    }

    if( pSD->dwValidate != m_dwValidate )
    {
        pSD->dwValidate = m_dwValidate;
        pSD->pCurrentTempo = NULL;
    }
    if (!pSD->pCurrentTempo)
    {
        pSD->pCurrentTempo = m_TempoEventList.GetHead();
    }
    if (!pSD->pCurrentTempo)
    {
        return DMUS_S_END;
    }
    // if the previous end time isn't the same as the current start time,
    // we need to seek to the right position.
    if( fSeek || ( pSD->mtPrevEnd != mtStart ))
    {
        TempoStateData tempData;
        BOOL fFlag = TRUE;
        tempData = *pSD; // put this in so we can use Seek in other functions such as GetParam
        if( !fSeek && (dwFlags & DMUS_TRACKF_DIRTY ))
        {
            fFlag = FALSE;
        }
        Seek( &tempData, mtStart, fFlag );
        *pSD = tempData;
    }
    pSD->mtPrevEnd = mtEnd;

    if( FAILED( pSD->pSegState->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    for (; pSD->pCurrentTempo; pSD->pCurrentTempo = pSD->pCurrentTempo->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pSD->pCurrentTempo->GetItemValue();
        if( rTempoEvent.lTime >= mtEnd )
        {
            // this time is in the future. Return now to retain the same
            // seek pointers for next time.
            hr = S_OK;
            break;
        }
        if( rTempoEvent.lTime < mtStart )
        {
            if( dwFlags & DMUS_TRACKF_FLUSH )
            {
                // this time is in the past, and this call to Play is in response to an
                // invalidate. We don't want to replay stuff before the start time.
                continue;
            }
            else if( !( dwFlags & DMUS_TRACKF_START) && !(dwFlags & DMUS_TRACKF_SEEK) )
            {
                // we really only want to play events earlier than mtStart on account
                // of a START or SEEK (that isn't a FLUSH.)
                continue;
            }
        }
        if( pSD->fActive )
        {
            DMUS_TEMPO_PMSG* pTempo;
            if( SUCCEEDED( pSD->pPerformance->AllocPMsg( sizeof(DMUS_TEMPO_PMSG),
                (DMUS_PMSG**)&pTempo )))
            {
                if( rTempoEvent.lTime < mtStart )
                {
                    // this only happens in the case where we've puposefully seeked
                    // and need to time stamp this event with the start time
                    if (fClockTime)
                    {
                        pTempo->rtTime = (mtStart * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pTempo->mtTime = mtStart + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
                }
                else
                {
                    if (fClockTime)
                    {
                        pTempo->rtTime = (rTempoEvent.lTime  * REF_PER_MIL) + rtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                    }
                    else
                    {
                        pTempo->mtTime = rTempoEvent.lTime + mtOffset;
                        pTempo->dwFlags = DMUS_PMSGF_MUSICTIME;
                    }
                }
                pTempo->dblTempo = rTempoEvent.dblTempo;
                pTempo->dwVirtualTrackID = pSD->dwVirtualTrackID;
                pTempo->dwType = DMUS_PMSGT_TEMPO;
                pTempo->dwGroupID = 0xffffffff;
                if( pGraph )
                {
                    pGraph->StampPMsg( (DMUS_PMSG*)pTempo );
                }
                if(FAILED(pSD->pPerformance->SendPMsg( (DMUS_PMSG*)pTempo )))
                {
                    pSD->pPerformance->FreePMsg( (DMUS_PMSG*)pTempo );
                }
            }
        }
    }
    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// if fGetPrevious is TRUE, seek to the event prior to mtTime. Otherwise, seek to
// the event on or after mtTime
HRESULT CTempoTrack::Seek( 
    /* [in] */ TempoStateData *pSD,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pSD->pCurrentTempo;
    if (!pScan)
    {
        pScan = m_TempoEventList.GetHead();
    }
    if (!pScan)
    {
        return S_FALSE;
    }
    // if the event's time is on or past mtTime, we need to go to the beginning
    if (pScan->GetItemValue().lTime >= mtTime)
    {
        pScan = m_TempoEventList.GetHead();
    }
    pSD->pCurrentTempo = pScan;
    for (; pScan; pScan = pScan->GetNext())
    {
        if (pScan->GetItemValue().lTime >= mtTime)
        {
            if (!fGetPrevious)
            {
                pSD->pCurrentTempo = pScan;
            }
            break;
        }
        pSD->pCurrentTempo = pScan;
    }
    return S_OK;
}

STDMETHODIMP CTempoTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) 
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType,(MUSIC_TIME) (rtTime / REF_PER_MIL), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * REF_PER_MIL;
        }
    }
    else
    {
        hr = GetParam(rguidType,(MUSIC_TIME) rtTime, &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CTempoTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags) 
{    
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= REF_PER_MIL;
    }
    return SetParam(rguidType, (MUSIC_TIME) rtTime , pParam);
}


HRESULT CTempoTrack::GetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    MUSIC_TIME* pmtNext,
    void *pData)
{
    V_INAME(IDirectMusicTrack::GetParam);
    V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
    V_REFGUID(rguid);

    HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    if( NULL == pData )
    {
        return E_POINTER;
    }
    if( rguid == GUID_PrivateTempoParam )
    {
        DMUS_TEMPO_PARAM TempoData;
        PrivateTempo* pPrivateTempoData = (PrivateTempo*)pData;
        hr = GetParam(GUID_TempoParam, mtTime, pmtNext, (void*)&TempoData);
        if (hr == S_OK)
        {
            pPrivateTempoData->dblTempo = TempoData.dblTempo;
            pPrivateTempoData->mtTime = 0; // must be set by the caller
            pPrivateTempoData->mtDelta = TempoData.mtTime;
            pPrivateTempoData->fLast = (pmtNext && !*pmtNext);
        }
        else if (hr == DMUS_E_NOT_FOUND) // the tempo track was empty
        {
            pPrivateTempoData->fLast = true;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if( !m_fActive )
        {
            return DMUS_E_TYPE_DISABLED;
        }
        DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
        TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
        TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = pScan;
        if (!pScan)
        {
            return DMUS_E_NOT_FOUND;
        }
        for (; pScan; pScan = pScan->GetNext())
        {
            if (pScan->GetItemValue().lTime > mtTime)
            {
                break;
            }
            pPrevious = pScan;
        }
        DMUS_IO_TEMPO_ITEM& rTempoEvent = pPrevious->GetItemValue();
        pTempoData->dblTempo = rTempoEvent.dblTempo;
        pTempoData->mtTime = rTempoEvent.lTime - mtTime;
        if (pmtNext)
        {
            *pmtNext = 0;
        }
        if (pScan)
        {
            DMUS_IO_TEMPO_ITEM& rNextTempoEvent = pScan->GetItemValue();
            if (pmtNext)
            {
                *pmtNext = rNextTempoEvent.lTime - mtTime;
            }
        }
        hr = S_OK;
    }
    return hr;
}

// Q: if all tracks are time-stamped, why do we need mtTime?
HRESULT CTempoTrack::SetParam( 
    REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
    V_INAME(IDirectMusicTrack::SetParam);
    V_REFGUID(rguid);

    EnterCriticalSection(&m_CrSec);

    HRESULT hr = DMUS_E_SET_UNSUPPORTED;

    if( rguid == GUID_DisableTempo )
    {
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_EnableTempo )
    {
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
            hr = S_OK;
        }
    }
    else if( rguid == GUID_TempoParam )
    {
        if (!m_fActive)
        {   // Oops, app intentionally disabled tempo.
            hr = DMUS_E_TYPE_DISABLED;
        }
        else
        {
            if( NULL == pData )
            {
                LeaveCriticalSection(&m_CrSec);
                return E_POINTER;
            }
            DMUS_TEMPO_PARAM* pTempoData = (DMUS_TEMPO_PARAM*)pData;
            TListItem<DMUS_IO_TEMPO_ITEM>* pScan = m_TempoEventList.GetHead();
            TListItem<DMUS_IO_TEMPO_ITEM>* pPrevious = NULL;
            for (; pScan; pScan = pScan->GetNext())
            {
                if (pScan->GetItemValue().lTime >= mtTime)
                {
                    break;
                }
                pPrevious = pScan;
            }
            // Make a new DMUS_IO_TEMPO_ITEM and insert it after pPrevious
            TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
            if (!pNew)
            {
                LeaveCriticalSection(&m_CrSec);
                return E_OUTOFMEMORY;
            }
            DMUS_IO_TEMPO_ITEM& rTempoEvent = pNew->GetItemValue();
            rTempoEvent.dblTempo = pTempoData->dblTempo;
            /*
            // I believe the fix for 204160 was supposed to change this line to what 
            // follows the comment.  RSW
            rTempoEvent.lTime = pTempoData->mtTime;
            */
            rTempoEvent.lTime = mtTime;
            if (pPrevious)
            {
                pNew->SetNext(pScan);
                pPrevious->SetNext(pNew);
            }
            else
            {
                m_TempoEventList.AddHead(pNew);
            }
            if (pScan && pScan->GetItemValue().lTime == mtTime)
            {
                // remove it
                pNew->SetNext(pScan->GetNext());
                pScan->SetNext(NULL);
                delete pScan;
            }
            m_dwValidate++;
            hr = S_OK;
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::AddNotificationType(
    /* [in] */  REFGUID rguidNotification)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::RemoveNotificationType(
    /* [in] */  REFGUID rguidNotification)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CTempoTrack::Clone(
    MUSIC_TIME mtStart,
    MUSIC_TIME mtEnd,
    IDirectMusicTrack** ppTrack)
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if(mtStart < 0 )
    {
        return E_INVALIDARG;
    }
    if(mtStart > mtEnd)
    {
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);

    CTempoTrack *pDM;
    
    try
    {
        pDM = new CTempoTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }


    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

    return hr;
}

STDMETHODIMP CTempoTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CTempoTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    V_INAME(IDirectMusicTrack::Join);
    V_INTERFACE(pNewTrack);
    V_INTERFACE_OPT(pContext);
    V_PTRPTR_WRITE_OPT(ppResultTrack);

    HRESULT hr = S_OK;
    EnterCriticalSection(&m_CrSec);

    if (ppResultTrack)
    {
        hr = Clone(0, mtJoin, ppResultTrack);
        if (SUCCEEDED(hr))
        {
            hr = ((CTempoTrack*)*ppResultTrack)->JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
        }
    }
    else
    {
        hr = JoinInternal(pNewTrack, mtJoin, dwTrackGroup);
    }

    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CTempoTrack::JoinInternal(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        DWORD dwTrackGroup)
{
    HRESULT hr = S_OK;
    CTempoTrack* pOtherTrack = (CTempoTrack*)pNewTrack;
    TListItem<DMUS_IO_TEMPO_ITEM>* pScan = pOtherTrack->m_TempoEventList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        DMUS_IO_TEMPO_ITEM& rScan = pScan->GetItemValue();
        TListItem<DMUS_IO_TEMPO_ITEM>* pNew = new TListItem<DMUS_IO_TEMPO_ITEM>;
        if (pNew)
        {
            DMUS_IO_TEMPO_ITEM& rNew = pNew->GetItemValue();
            rNew.lTime = rScan.lTime + mtJoin;
            rNew.dblTempo = rScan.dblTempo;
            m_TempoEventList.AddTail(pNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\song.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// DMSegObj.h : Declaration of the CSegment

#ifndef __DIRECTMUSICSONGOBJECT_H_
#define __DIRECTMUSICSONGOBJECT_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmime.h"
#include "TrkList.h"
#include "dmgraph.h"
#include "dmsegobj.h"
#include "tlist.h"
#include "..\shared\dmusicp.h"

class CVirtualSegment : public AListItem
{
friend class CSong;
friend class ComposingTrack;
public:
    CVirtualSegment();
    ~CVirtualSegment();
    CVirtualSegment* GetNext() { return (CVirtualSegment*)AListItem::GetNext();}
    CTrack * GetTrackByParam( CTrack * pCTrack,
        REFGUID rguidType,DWORD dwGroupBits,DWORD dwIndex);
private:
    CTrackList              m_TrackList;        // List of tracks that this segment uses.
    CSegment *              m_pSourceSegment;   // Segment that is used as basis for this segment.
    CSegment *              m_pPlaySegment;     // Resulting segment that will be played.
    CGraph *                m_pGraph;           // Optional tool graph.
    DWORD                   m_dwFlags;          // Various control flags.
    DWORD                   m_dwID;             // Unique ID.
    DWORD                   m_dwNextPlayID;     // ID of next segment, to chain segments into a song.
    DWORD                   m_dwNextPlayFlags;  // DMUS_SEGF flags for playing next segment, when chaining a song.
    DMUS_IO_SEGMENT_HEADER  m_SegHeader;        // Segment header, used to define the segment that it creates, or change the one it references.
    MUSIC_TIME              m_mtTime;           // Start time of this segment.
    DWORD                   m_dwTransitionCount;// How many transitions are defined. 
    DMUS_IO_TRANSITION_DEF *m_pTransitions;     // Array of transitions from other segments.
	WCHAR	                m_wszName[DMUS_MAX_NAME];// Name of generated segment.
};

class CVirtualSegmentList : public AList
{
public:
    void Clear();
    void AddHead(CVirtualSegment* pVirtualSegment) { AList::AddHead((AListItem*)pVirtualSegment);}
    void Insert(CVirtualSegment* pVirtualSegment);
    CVirtualSegment* GetHead(){return (CVirtualSegment*)AList::GetHead();}
    CVirtualSegment* GetItem(LONG lIndex){return (CVirtualSegment*)AList::GetItem(lIndex);}
    CVirtualSegment* RemoveHead()  { return (CVirtualSegment *)AList::RemoveHead();};
    void Remove(CVirtualSegment* pVirtualSegment){AList::Remove((AListItem*)pVirtualSegment);}
    void AddTail(CVirtualSegment* pVirtualSegment){AList::AddTail((AListItem*)pVirtualSegment);}
    CVirtualSegment* GetTail(){ return (CVirtualSegment*)AList::GetTail();}
};

class CSongSegment : public AListItem
{
public:
    CSongSegment();
    ~CSongSegment();
    CSongSegment* GetNext() { return (CSongSegment*)AListItem::GetNext();}
    CSegment *              m_pSegment;   
    DWORD                   m_dwLoadID;
};

class CSongSegmentList : public AList
{
public:
    HRESULT AddSegment(CSegment *pSegment, DWORD dwLoadID);
    void Clear();
    void AddHead(CSongSegment* pSongSegment) { AList::AddHead((AListItem*)pSongSegment);}
    void Insert(CSongSegment* pSongSegment);
    CSongSegment* GetHead(){return (CSongSegment*)AList::GetHead();}
    CSongSegment* GetItem(LONG lIndex){return (CSongSegment*)AList::GetItem(lIndex);}
    CSongSegment* RemoveHead()  { return (CSongSegment *)AList::RemoveHead();};
    void Remove(CSongSegment* pSongSegment){AList::Remove((AListItem*)pSongSegment);}
    void AddTail(CSongSegment* pSongSegment){AList::AddTail((AListItem*)pSongSegment);}
    CSongSegment* GetTail(){ return (CSongSegment*)AList::GetTail();}
};


class CSong;

DEFINE_GUID(IID_CSong,0xb06c0c22, 0xd3c7, 0x11d3, 0x9b, 0xd1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


/////////////////////////////////////////////////////////////////////////////
// CSong
class CSong : 
	public IDirectMusicSong,
	public IPersistStream,
	public IDirectMusicObject,
    public IDirectMusicObjectP
{
public:
	CSong();
	~CSong();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
// IDirectMusicSong
    STDMETHODIMP Compose( );
    STDMETHODIMP GetParam( REFGUID rguidType, 
                            DWORD dwGroupBits, 
                            DWORD dwIndex, 
                            MUSIC_TIME mtTime, 
                            MUSIC_TIME* pmtNext, 
                            void* pParam) ;
    STDMETHODIMP GetSegment( WCHAR *wszName,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP EnumSegment( DWORD dwIndex,IDirectMusicSegment **ppSegment) ;
    STDMETHODIMP GetAudioPathConfig(IUnknown ** ppAudioPathConfig);
    STDMETHODIMP Download(IUnknown *pAudioPath);
    STDMETHODIMP Unload(IUnknown *pAudioPath);

// IPersist 
    STDMETHODIMP GetClassID( CLSID* pClsId );

// IPersistStream 
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

// IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

// IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

public:
    HRESULT GetTransitionSegment(CSegment *pSource, CSegment *pDestination,
        DMUS_IO_TRANSITION_DEF *pTransDef);
    HRESULT GetPlaySegment( DWORD dwIndex,CSegment **ppSegment) ;
private:
    void                Clear();
    HRESULT				Instantiate() ;
    HRESULT             LoadReferencedSegment(CSegment **ppSegment, CRiffParser *pParser);
    HRESULT             LoadSegmentList(CRiffParser *pParser);
    HRESULT             LoadGraphList(CRiffParser *pParser);
    HRESULT             LoadVirtualSegmentList(CRiffParser *pParser);
    HRESULT             LoadTrackRefList(CRiffParser *pParser, CVirtualSegment *pVirtualSegment);
    HRESULT             LoadAudioPath(IStream *pStream);

    void GetGraph(CGraph **ppGraph,DWORD dwGraphID);
    void GetSourceSegment(CSegment **ppSegment,DWORD dwSegmentID);
    BOOL GetSegmentTrack(IDirectMusicTrack **ppTrack,DWORD dwSegmentID,DWORD dwGroupBits,DWORD dwIndex,REFGUID guidClassID);
    CAudioPathConfig*   m_pAudioPathConfig;     // Optional audio path loaded from file. 
    CGraphList          m_GraphList;            // List of graphs for use by segments in the song.
    CSongSegmentList    m_SegmentList;          // List of source segments.
    CSegmentList        m_PlayList;             // List of composed segments.
    CVirtualSegmentList m_VirtualSegmentList;   // List of segment references. This is what is used to compose the finished song.         
    CRITICAL_SECTION    m_CriticalSection;      
	DWORD	            m_fPartialLoad;
    DWORD               m_dwFlags;
    DWORD               m_dwStartSegID;         // ID of first segment, in play list, that should play.
	long                m_cRef;
// IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                       /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                 /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */
    DWORD               m_dwVersion;        // Which version of the interfaces is the app requesting?
    IUnknown *          m_pUnkDispatch;     // holds the controlling unknown of the scripting object that implements IDispatch

    bool                m_fZombie;
};


struct CompositionComponent
{
	CVirtualSegment*	pVirtualSegment;			// composing track came from here
	CTrack*		pComposingTrack;	// used for composition
	MUSIC_TIME	mtTime;
};

class ComposingTrack
{
public:
	ComposingTrack();
	~ComposingTrack();
	DWORD GetTrackGroup() { return m_dwTrackGroup; }
	GUID GetTrackID() { return m_guidClassID; }
	DWORD GetPriority() { return m_dwPriority; }
	void SetPriority(DWORD dwPriority) { m_dwPriority = dwPriority; }
	void SetTrackGroup(DWORD dwTrackGroup) { m_dwTrackGroup = dwTrackGroup; }
	void SetTrackID(GUID& rguidClassID) { m_guidClassID = rguidClassID; }
	HRESULT AddTrack(CVirtualSegment* pVirtualSegment, CTrack* pTrack);
	HRESULT Compose(IDirectMusicSong* pSong);
private:
	GUID						m_guidClassID;		// composing track's class id
	DWORD						m_dwTrackGroup;		// track will be composed from these groups
    DWORD						m_dwPriority;		// Track priority, to order the composition process.
	TList<CompositionComponent>	m_Components;		// list of components making up the master
};

#endif //__DIRECTMUSICSONGOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\template.h ===
// Copyright (c) 1998 Microsoft Corporation
// templates.h

#ifndef __TEMPLATES_H__
#define __TEMPLATES_H__

#include <windows.h>

template< class T > T* List_Cat( T* p1, T* p2 )
{
    T* pScan;

    if( p1 == NULL )
    {
        return p2;
    }
    for( pScan = p1 ; pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
    pScan->pNext = p2;
    return p1;
}

template< class T > DWORD List_Len( T* p )
{
    DWORD dw;

    for( dw = 0 ; p != NULL ; p = (T*)p->pNext )
    {
         ++dw;
    }

    return dw;
}

template< class T > BOOL inlist( T* lst, T* p )
{
    if( p == NULL )
    {
        return TRUE;
    }

    for( ; lst != NULL ; lst = (T*)lst->pNext )
    {
        if( p == lst )
        {
            return TRUE;
        }
    }

    return FALSE;
}

template< class T > T* List_Index( T* lst, DWORD dwIndex )
{
    T* pScan;

    for( pScan = lst ; dwIndex > 0 && pScan != NULL && pScan->pNext != NULL ; --dwIndex, pScan = (T*)pScan->pNext );

    return pScan;
}

template< class T > T* List_Insert( T* lst, T* p, DWORD dwIndex )
{
    T* pPrev;

    if( lst == NULL || dwIndex == 0 )
    {
        p->pNext = lst;
        lst = p;
    }
    else
    {
        pPrev = List_Index( lst, dwIndex - 1 );
        p->pNext = pPrev->pNext;
        pPrev->pNext = p;
    }

    return lst;
}

template< class T > T* List_Remove( T* lst, T* p )
{
    if( lst != NULL )
    {
        if( lst == p )
        {
            lst = (T*)lst->pNext;
            p->pNext = NULL;
        }
        else
        {
            T* pScan;

            for( pScan = lst ; pScan->pNext != p && pScan->pNext != NULL ; pScan = (T*)pScan->pNext );
            if( pScan->pNext != NULL )
            {
                pScan->pNext = pScan->pNext->pNext;
                p->pNext = NULL;
            }
        }
    }

    return lst;
}

template< class T > long List_Position( T* lst, T* p )
{
    long lPos;

    lPos = 0;
    while( lst != NULL && lst != p )
    {
        lst = lst->pNext;
        ++lPos;
    }
    if( lst == NULL )
    {
        return -1;
    }

    return lPos;
}

template< class T > T* List_Clone( T* lst )
{
    T* pPrev;
    T* lstClone;
    T* pCopy;

    lstClone = NULL;
    pPrev = NULL;

    for( ; lst ; lst = (T*)lst->pNext )
    {
        pCopy = new T;
        if( pCopy != NULL )
        {
            memcpy( pCopy, lst, sizeof( T ) );
            pCopy->pNext = NULL;
            if( pPrev != NULL )
            {
                pPrev->pNext = pCopy;
            }
            else
            {
                lstClone = pCopy;
            }
            pPrev = pCopy;
        }
    }

    return lstClone;
}

template< class T > void List_Free( T* lst )
{
    T* pNext;

    for( ; lst != NULL ; lst = pNext )
    {
        pNext = (T*)lst->pNext;
        delete lst;
    }
}

template< class T > T* Clone( T* p )
{
    T* pCopy;

    pCopy = new T;
    if( pCopy != NULL )
    {
        memcpy( pCopy, p, sizeof( T ) );
        pCopy->pNext = NULL;
    }

    return pCopy;
}

#endif // __TEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\alist.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// alist.cpp
//
#include "alist.h"

LONG AListItem::GetCount(void) const
{
    LONG l;
    const AListItem *li;

    for(l=0,li=this; li!=NULL ; li=li->m_pNext,++l);
    return l;
}

AListItem* AListItem::Cat(AListItem *pItem)
{
    AListItem *li;

    if(this==NULL)
        return pItem;
    for(li=this ; li->m_pNext!=NULL ; li=li->m_pNext);
    li->m_pNext=pItem;
    return this;
}

AListItem* AListItem::Remove(AListItem *pItem)
{
    AListItem *li,*prev;

    //treat remove(NULL) same as item not found in list
   if (pItem==NULL) 
   return this;

    if(pItem==this)
    {
        li = m_pNext;
        m_pNext = NULL;
        return li;
    }
    prev=NULL;
    for(li=this; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    if(li==NULL)     // item not found in list
        return this;

//  here it is guaranteed that prev is non-NULL since we checked for
//  that condition at the very beginning

    prev->SetNext(li->m_pNext);
    li->SetNext(NULL);

    // SetNext on pItem to NULL
    pItem->SetNext(NULL);

    return this;
}

AListItem* AListItem::GetPrev(AListItem *pItem) const
{
    const AListItem *li,*prev;

    prev=NULL;
    for(li=this ; li!=NULL && li!=pItem ; li=li->m_pNext)
        prev=li;
    return (AListItem*)prev;
}

AListItem * AListItem::GetItem(LONG index)

{
	AListItem *scan;
	for (scan = this; scan!=NULL && index; scan = scan->m_pNext) 
	{
		index--;
	}
	return (scan);
}

void AList::InsertBefore(AListItem *pItem,AListItem *pInsert)

{
	AListItem *prev = GetPrev(pItem);
	pInsert->SetNext(pItem);
	if (prev) prev->SetNext(pInsert);
	else m_pHead = pInsert;
}

void AList::AddTail(AListItem *pItem)
{
    if (m_pHead == NULL)
    {
        AddHead(pItem);
    }
    else
    {
        m_pHead = m_pHead->AddTail(pItem);
    }
}

void AList::Reverse()

{
    AList Temp;
    AListItem *pItem;
    while (pItem = RemoveHead())
    {
        Temp.AddHead(pItem);
    }
    m_pHead = Temp.GetHead();
}

BOOL AList::IsMember(AListItem *pItem)

{
    AListItem *pScan = GetHead();
    for (;pScan;pScan = pScan->GetNext())
    {
        if (pItem == pScan) return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\trklist.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//////////////////////////////////////////////////////////////////////
// TrkList.h

#include "alist.h"
#include "dmusici.h"
#include "debug.h"
#define ASSERT	assert

#ifndef __TRACKLIST_H_
#define __TRACKLIST_H_

#define TRACKINTERNAL_START_PADDED 0x1
#define TRACKINTERNAL_END_PADDED 0x2

class CSegment;

class CTrack : public AListItem
{
public:
	CTrack();
	~CTrack();
	CTrack* GetNext()
	{
		return (CTrack*)AListItem::GetNext();
	};
    bool Less(CTrack* pCTrack)
    {
        // Give the sysex track priority over any other track at the same position,
        // and the band track priority over any track but the sysex track. 
        return
            ( m_dwPosition < pCTrack->m_dwPosition ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicSysExTrack) ||
              (m_dwPosition == pCTrack->m_dwPosition && 
               m_guidClassID == CLSID_DirectMusicBandTrack &&
               pCTrack->m_guidClassID != CLSID_DirectMusicSysExTrack) );
    }
public:
    CLSID               m_guidClassID;  // Class ID of track.
	IDirectMusicTrack*	m_pTrack;       // Standard track interface.
    IDirectMusicTrack8* m_pTrack8;      // Extra DX8 functions.
    void*				m_pTrackState; // state pointer returned by IDirectMusicTrack::InitPerformance
	BOOL				m_bDone;
	DWORD				m_dwVirtualID; // only valid inside segment states
	DWORD				m_dwGroupBits;
    DWORD               m_dwPriority;  // Track priority, to order the composition process.
    DWORD               m_dwPosition;  // Track position, to determine the Play order.
    DWORD               m_dwFlags;     // DMUS_TRACKCONFIG_ flags. 
    DWORD               m_dwInternalFlags;     // TRACKINTERNAL_ flags. 
};

class CTrackList : public AList
{
public:
    CTrack* GetHead() 
	{
		return (CTrack*)AList::GetHead();
	};
    CTrack* RemoveHead() 
	{
		return (CTrack*)AList::RemoveHead();
	};
    CTrack* GetItem(LONG lIndex) 
	{
		return (CTrack*) AList::GetItem(lIndex);
	};
	void Clear(void)
	{
		CTrack* pTrack;
		while( pTrack = RemoveHead() )
		{
			delete pTrack;
		}
	}
	HRESULT CreateCopyWithBlankState(CTrackList* pTrackList);
};

#endif // __TRACKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\trackhelp.cpp ===
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//
// Base classes that implement aspects of a standard DirectMusic track.
// Implementations for CBasicTrack.
//

#include "trackhelp.h"
#include "validate.h"

//////////////////////////////////////////////////////////////////////
// Creation

CBasicTrack::CBasicTrack(long *plModuleLockCounter, const CLSID &rclsid)
  : m_cRef(0),
    m_plModuleLockCounter(plModuleLockCounter),
    m_rclsid(rclsid)
{
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    InterlockedIncrement(plModuleLockCounter);
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP 
CBasicTrack::QueryInterface(const IID &iid, void **ppv)
{
    V_INAME(CBasicTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

    if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
        *ppv = static_cast<IDirectMusicTrack8*>(this);
    else if (iid == IID_IPersistStream)
        *ppv = static_cast<IPersistStream*>(this);
    else if (iid == IID_IPersist)
        *ppv = static_cast<IPersist*>(this);
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Track\n");
        return E_NOINTERFACE;
    }
    
    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CBasicTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CBasicTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        DeleteCriticalSection(&m_CriticalSection);
        delete this;
        return 0;
    }

    return m_cRef;
}

//////////////////////////////////////////////////////////////////////
// IUnknown

STDMETHODIMP
CBasicTrack::GetClassID(CLSID* pClassID)
{
    V_INAME(CBasicTrack::GetClassID);
    V_PTR_WRITE(pClassID, sizeof(pClassID));
    *pClassID = m_rclsid;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack

STDMETHODIMP
CBasicTrack::Init(IDirectMusicSegment *pSegment)
{
    V_INAME(CBasicTrack::Init);
    V_INTERFACE(pSegment);
    return S_OK;
}

STDMETHODIMP
CBasicTrack::Play(
        void *pStateData,
        MUSIC_TIME mtStart,
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID)
{
    return this->PlayMusicOrClock(
                    pStateData,
                    mtStart,
                    mtEnd,
                    mtOffset,
                    0,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    false);
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack8

STDMETHODIMP CBasicTrack::PlayEx(
        void* pStateData,
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtEnd,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,
        IDirectMusicPerformance* pPerf,
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID)
{
    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        // Convert all reference times to millisecond times and then just use them as if this were MUSIC_TIME.
        return this->PlayMusicOrClock(
                    pStateData,
                    static_cast<MUSIC_TIME>(rtStart / gc_RefPerMil),
                    static_cast<MUSIC_TIME>(rtEnd / gc_RefPerMil),
                    static_cast<MUSIC_TIME>(rtOffset / gc_RefPerMil),
                    rtOffset,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    true);
    }
    else
    {
        return this->PlayMusicOrClock(
                    pStateData,
                    static_cast<MUSIC_TIME>(rtStart),
                    static_cast<MUSIC_TIME>(rtEnd),
                    static_cast<MUSIC_TIME>(rtOffset),
                    0,
                    dwFlags,
                    pPerf,
                    pSegSt,
                    dwVirtualID,
                    false);
    }
}

STDMETHODIMP CBasicTrack::GetParamEx(
        REFGUID rguidType,
        REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtNext,
        void* pParam,
        void * pStateData,
        DWORD dwFlags)
{
    HRESULT hr;
    MUSIC_TIME mtNext;
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime / gc_RefPerMil), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext * gc_RefPerMil;
        }
    }
    else
    {
        hr = GetParam(rguidType, static_cast<MUSIC_TIME>(rtTime), &mtNext, pParam);
        if (prtNext)
        {
            *prtNext = mtNext;
        }
    }
    return hr;
}

STDMETHODIMP CBasicTrack::SetParamEx(
        REFGUID rguidType,
        REFERENCE_TIME rtTime,
        void* pParam, void * pStateData, DWORD dwFlags) 
{
    if (dwFlags & DMUS_TRACK_PARAMF_CLOCK)
    {
        rtTime /= gc_RefPerMil;
    }
    return SetParam(rguidType, static_cast<MUSIC_TIME>(rtTime ), pParam);
}

STDMETHODIMP CBasicTrack::Compose(
        IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CBasicTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) 
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\wavtrack.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// WavTrack.h : Declaration of the CWavTrack

#ifndef __WAVTRACK_H_
#define __WAVTRACK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "dmstrm.h"
#include "tlist.h"
#include "PChMap.h"
#include "..\shared\dmusiccp.h"
#include "dsoundp.h"  // For IDirectSoundWave

interface IPrivateWaveTrack : IUnknown
{
    virtual HRESULT STDMETHODCALLTYPE SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex)=0;
    virtual HRESULT STDMETHODCALLTYPE ClearVariations(IDirectMusicSegmentState* pSegState)=0;
    virtual HRESULT STDMETHODCALLTYPE AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)=0;
    virtual HRESULT STDMETHODCALLTYPE DownloadWave(
        IDirectSoundWave* pWave,   // wave to download
        IUnknown* pUnk,            // performance or audio path
        REFGUID rguidVersion)=0;   // version of downloaded wave
    virtual HRESULT STDMETHODCALLTYPE UnloadWave(
        IDirectSoundWave* pWave,   // wave to unload
        IUnknown* pUnk)=0;         // performance or audio path
    virtual HRESULT STDMETHODCALLTYPE RefreshWave(
        IDirectSoundWave* pWave,   // wave to refresh
        IUnknown* pUnk,            // performance or audio path
        DWORD dwPChannel,          // new PChannel for the wave
        REFGUID rguidVersion)=0;  // version of refreshed wave
    virtual HRESULT STDMETHODCALLTYPE FlushAllWaves()=0;
    virtual HRESULT STDMETHODCALLTYPE OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)=0;
};

DEFINE_GUID(IID_IPrivateWaveTrack, 0x492abe2a, 0x38c8, 0x48a3, 0x8f, 0x3c, 0x1e, 0x13, 0xba, 0x1, 0x78, 0x4e);

const int MAX_WAVE_VARIATION_LOCKS = 255;  // max number of variation lock ids

struct TaggedWave
{
    IDirectSoundWave*               m_pWave;
    GUID                            m_guidVersion;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    long                            m_lRefCount;
    IDirectMusicPortP*              m_pPort;
    IDirectMusicPerformance*        m_pPerformance;

    TaggedWave() : m_pWave(NULL), m_pDownloadedWave(NULL), m_lRefCount(0),
        m_pPort(NULL), m_pPerformance(NULL), m_guidVersion(GUID_NULL)
    {
    }

    ~TaggedWave()
    {
        if (m_pWave) m_pWave->Release();
        if (m_pPort) m_pPort->Release();
        if (m_pPerformance) m_pPerformance->Release();
        if (m_pDownloadedWave) m_pDownloadedWave->Release();
    }
};

struct WaveItem
{
    WaveItem() : m_rtTimePhysical(0), m_lVolume(0), m_lPitch(0), m_dwVariations(0),
        m_rtStartOffset(0), m_rtDuration(0), m_mtTimeLogical(0), m_dwFlags(0),
        m_pWave(NULL), m_dwLoopStart(0), m_dwLoopEnd(0), m_dwVoiceIndex(0xffffffff),
        m_pDownloadedWave(NULL), m_fIsStreaming(FALSE), m_fUseNoPreRoll(FALSE)
    {
    }

    ~WaveItem()
    {
        CleanUp();
    }

    HRESULT Load( IDMStream* pIRiffStream, MMCKINFO* pckParent );
    HRESULT LoadReference(IStream *pStream, IDMStream *pIRiffStream, MMCKINFO& ckParent);
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave, 
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwPChannel, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        DWORD dwOldPChannel, 
        DWORD dwNewPChannel,
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    static HRESULT PChannelInfo(
        IDirectMusicPerformance* pPerformance,
        IDirectMusicAudioPath* pAudioPath,
        DWORD dwPChannel,
        IDirectMusicPort** ppPort,
        DWORD* pdwGroup,
        DWORD* pdwMChannel);

    void CleanUp();
    HRESULT Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime, REFERENCE_TIME* prtLength);

    REFERENCE_TIME                  m_rtTimePhysical;
    long                            m_lVolume;
    long                            m_lPitch;
    DWORD                           m_dwVariations; // variations this wave item responds to
    REFERENCE_TIME                  m_rtStartOffset;
    REFERENCE_TIME                  m_rtDuration;
    MUSIC_TIME                      m_mtTimeLogical;
    DWORD                           m_dwFlags;
    IDirectSoundWave*               m_pWave;
    IDirectSoundDownloadedWaveP*    m_pDownloadedWave;
    BOOL                            m_fIsStreaming;
    BOOL                            m_fUseNoPreRoll;
    DWORD                           m_dwLoopStart;
    DWORD                           m_dwLoopEnd;
    DWORD                           m_dwVoiceIndex; // unique (to the track) index for state data's vaoice array

    static TList<TaggedWave>        st_WaveList;
    static CRITICAL_SECTION         st_WaveListCritSect;
};

struct WavePart
{
    WavePart() : m_dwPChannel(0), m_lVolume(0), m_dwLockToPart(0), 
        m_dwPChannelFlags(0), m_dwVariations(0), m_dwIndex(0)
    {
    }

    ~WavePart()
    {
        CleanUp();
    }

    HRESULT Load( IDMStream* pIRiffStream, MMCKINFO* pckParent );
    HRESULT CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    HRESULT Download(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        REFGUID rguidVersion);
    HRESULT Unload(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave);
    HRESULT Refresh(IDirectMusicPerformance* pPerformance, 
        IDirectMusicAudioPath* pPath, 
        IDirectSoundWave* pWave,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    HRESULT Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);

    DWORD               m_dwPChannel;
    DWORD               m_dwIndex; // Index to distinguish different parts on the same PChannel
    DWORD               m_lVolume;
    DWORD               m_dwVariations;    // variations enabled for this part
    DWORD               m_dwLockToPart;    // all parts with this ID are locked (0 means no locking)
    DWORD               m_dwPChannelFlags; // lowest-order nibble holds DMUS_VARIATIONT_TYPES value
    TList<WaveItem>     m_WaveItemList;
};

struct WaveDLOnPlay
{
    WaveDLOnPlay() : m_pWaveDL(NULL), m_pPort(NULL), m_pVoice(NULL) {}
    ~WaveDLOnPlay()
    {
        if (m_pPort)
        {
            if (m_pWaveDL)
            {
                m_pPort->UnloadWave(m_pWaveDL);
            }
            m_pWaveDL = NULL;
            m_pPort->Release();
            m_pPort = NULL;
        }
        if (m_pVoice)
        {
            m_pVoice->Release();
            m_pVoice = NULL;
        }
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    IDirectMusicPortP*             m_pPort;
    IDirectMusicVoiceP*            m_pVoice;
};

struct WaveStateData
{
    DWORD                       dwPChannelsUsed; // number of PChannels
    // the following array is allocated to the size of dwNumPChannels, which
    // must match the Wave Track's m_dwPChannelsUsed. The array matches one-for-one with
    // the parts inside the Wave Track.
    TListItem<WaveItem>**       apCurrentWave; // array of size dwNumPChannels
    DWORD                       dwValidate;
    DWORD                       dwGroupBits; // the group bits of this track
    DWORD*                      pdwVariations;      // array of variations (1 per part)
    DWORD*                      pdwRemoveVariations;    // array of variations already played (1 per part)
    DWORD                       adwVariationGroups[MAX_WAVE_VARIATION_LOCKS];
    REFERENCE_TIME              rtNextVariation; // time of next variation
    DWORD                       m_dwVariation;   // selected variations to audition
    DWORD                       m_dwPart;        // PChannel of part for auditioning variations
    DWORD                       m_dwIndex;       // Index of part for auditioning variations
    DWORD                       m_dwLockID;      // For locking to the part being auditioned
    BOOL                        m_fAudition;     // Am I auditioning variations?
    IDirectMusicPerformance*    m_pPerformance;
    IDirectMusicVoiceP**        m_apVoice;      // array of voices (one per wave item in track)
    DWORD                       m_dwVoices;     // number of voices in m_apVoice
    bool                        m_fLoop;        // set after the wave loops
    IDirectMusicAudioPath*      m_pAudioPath;   // audio path in effect for this track state
    TList<WaveDLOnPlay>         m_WaveDLList;   // waves downloaded while the track was playing

    WaveStateData() : dwPChannelsUsed(0), apCurrentWave(NULL), dwGroupBits(0),
        pdwVariations(NULL), pdwRemoveVariations(NULL), rtNextVariation(0),
        m_dwVariation(0), m_dwPart(0), m_dwIndex(0), m_dwLockID(0), m_fAudition(FALSE),
        m_pPerformance(NULL), m_apVoice(NULL), m_dwVoices(0), m_fLoop(false), m_pAudioPath(NULL)
    {
        for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
        {
            adwVariationGroups[i] = 0;
        }
    }

    ~WaveStateData()
    {
        if( apCurrentWave )
        {
            delete [] apCurrentWave;
        }
        if( pdwVariations )
        {
            delete [] pdwVariations;
        }
        if( pdwRemoveVariations )
        {
            delete [] pdwRemoveVariations;
        }
        if (m_apVoice)
        {
            for (DWORD dw = 0; dw < m_dwVoices; dw++)
            {
                if (m_apVoice[dw])
                {
                    m_apVoice[dw]->Release();
                }
            }
            delete [] m_apVoice;
        }
        if( m_pAudioPath )
        {
            m_pAudioPath->Release();
        }
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }

    HRESULT InitVariationInfo(DWORD dwVariations, DWORD dwPart, DWORD dwIndex, DWORD dwLockID, BOOL fAudition)
    {
        HRESULT hr = S_OK;
        m_dwVariation = dwVariations;
        m_dwPart = dwPart;
        m_dwIndex = dwIndex;
        m_dwLockID = dwLockID;
        m_fAudition = fAudition;
        return hr;
    }

    DWORD Variations(WavePart& rPart, int nPartIndex)
    {
        if (m_dwLockID && rPart.m_dwLockToPart == m_dwLockID)
        {
            TraceI(4, "Variations for locked part\n");
            return m_dwVariation;
        }
        else if ( m_fAudition &&
                  (rPart.m_dwPChannel == m_dwPart) &&
                  (rPart.m_dwIndex == m_dwIndex) )
        {
            TraceI(4, "Variations for current part\n");
            return m_dwVariation;
        }
        else
        {
            TraceI(4, "Variations for a different part\n");
            return pdwVariations[nPartIndex];
        }
    }

};

struct StatePair
{
    StatePair() : m_pSegState(NULL), m_pStateData(NULL) {}
    StatePair(const StatePair& rPair)
    {
        m_pSegState = rPair.m_pSegState;
        m_pStateData = rPair.m_pStateData;
    }
    StatePair(IDirectMusicSegmentState* pSegState, WaveStateData* pStateData)
    {
        m_pSegState = pSegState;
        m_pStateData = pStateData;
    }
    StatePair& operator= (const StatePair& rPair)
    {
        if (this != &rPair)
        {
            m_pSegState = rPair.m_pSegState;
            m_pStateData = rPair.m_pStateData;
        }
        return *this;
    }
    ~StatePair()
    {
    }
    IDirectMusicSegmentState*   m_pSegState;
    WaveStateData*          m_pStateData;
};

struct WavePair
{
    WavePair() : m_pWaveDL(NULL), m_pStateData(NULL) {}
    ~WavePair()
    {
        if (m_pWaveDL) m_pWaveDL->Release();
    }

    IDirectSoundDownloadedWaveP*   m_pWaveDL;
    WaveStateData*                 m_pStateData;
};

/////////////////////////////////////////////////////////////////////////////
// CWavTrack
class CWavTrack : 
    public IPersistStream,
    public IDirectMusicTrack8,
    public IPrivateWaveTrack
{
public:
    CWavTrack();
    CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
    ~CWavTrack();

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 methods
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack) ;
// IPersist methods
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream methods
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
//  IPrivateWaveTrack methods
    STDMETHODIMP SetVariation(
        IDirectMusicSegmentState* pSegState,
        DWORD dwVariationFlags,
        DWORD dwPChannel,
        DWORD dwIndex);
    STDMETHODIMP ClearVariations(IDirectMusicSegmentState* pSegState);
    STDMETHODIMP AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength);
    STDMETHODIMP DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion);
    STDMETHODIMP UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk);
    STDMETHODIMP RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion);
    STDMETHODIMP FlushAllWaves();
    STDMETHODIMP OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData);
    // misc
    static HRESULT UnloadAllWaves(IDirectMusicPerformance* pPerformance);

protected:
    void Construct(void);
    HRESULT Play(
        void *pStateData,   
        REFERENCE_TIME rtStart, 
        REFERENCE_TIME rtEnd,
      //  MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        DWORD dwFlags,      
        IDirectMusicPerformance* pPerf, 
        IDirectMusicSegmentState* pSegSt,
        DWORD dwVirtualID,
        BOOL fClockTime);
    void InsertByAscendingPChannel( TListItem<WavePart>* pPart );
    HRESULT CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd );
    void CleanUp();
    void CleanUpTempParts();
    void MovePartsToTemp();
    IDirectSoundDownloadedWaveP* FindDownload(TListItem<WaveItem>* pItem);
    void SetUpStateCurrentPointers(WaveStateData* pStateData);
    HRESULT STDMETHODCALLTYPE Seek( 
        IDirectMusicSegmentState*,
        IDirectMusicPerformance*,
        DWORD dwVirtualID,
        WaveStateData*,
        REFERENCE_TIME rtTime,
        BOOL fGetPrevious,
//      MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
        BOOL fClockTime);
    HRESULT SyncVariations(IDirectMusicPerformance* pPerf, 
        WaveStateData* pSD, 
        REFERENCE_TIME rtStart,
        REFERENCE_TIME rtOffset,  
        BOOL fClockTime);
    HRESULT ComputeVariations(WaveStateData* pSD);
    HRESULT ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD);
    WaveStateData* FindState(IDirectMusicSegmentState* pSegState);
    HRESULT InitTrack(DWORD dwPChannels);
    HRESULT GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice);
    void RemoveDownloads(WaveStateData* pStateData);

    static void FlushWaves();

// member variables
private:
    long                m_cRef;
    CRITICAL_SECTION    m_CrSec;
    BOOL                m_fCSInitialized;

    long                m_lVolume;
    DWORD               m_dwTrackFlags; // Only current flag is DMUS_WAVETRACKF_SYNC_VAR
    DWORD               m_dwPChannelsUsed;
    DWORD*              m_aPChannels;
    TList<WavePart>     m_WavePartList;
    TList<WavePart>     m_TempWavePartList; // keep this around when reloading the track
    DWORD               m_dwValidate; // used to validate state data
    CPChMap             m_PChMap;

    DWORD               m_dwVariation;   // selected variations to audition
    DWORD               m_dwPart;        // PChannel of part for auditioning variations
    DWORD               m_dwIndex;       // Index of part for auditioning variations
    DWORD               m_dwLockID;      // For locking to the part being auditioned
    BOOL                m_fAudition;     // Am I auditioning variations?
    BOOL                m_fAutoDownload;
    BOOL                m_fLockAutoDownload; // if true, this flag indicates that we've specifically
                                // commanded the band to autodownload. Otherwise,
                                // it gets its preference from the performance via
                                // GetGlobalParam.
    DWORD*              m_pdwVariations;        // Track's array of variations (1 per part)
    DWORD*              m_pdwRemoveVariations;  // Track's array of variations already played (1 per part)
    DWORD               m_dwWaveItems;          // Total number of wave items in the track

    TList<StatePair>    m_StateList;            // The track's state information
    TList<WavePair>     m_WaveList;             // Information about waves downloaded to the track

    static long         st_RefCount;            // global count of # of instantiated wave tracks
};

#endif //__WAVTRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\tsigtrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TSigTrk.h : Declaration of the CTimeSigTrack

#ifndef __TSIGTRK_H_
#define __TSIGTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "alist.h"

class CRiffParser;

class CTimeSigItem : public AListItem
{
public:
    CTimeSigItem();
    CTimeSigItem* GetNext(){ return (CTimeSigItem*)AListItem::GetNext(); };
    DMUS_IO_TIMESIGNATURE_ITEM  m_TimeSig;
};

   
class CTimeSigList : public AList
{
public:
    CTimeSigItem* GetHead() {return (CTimeSigItem*)AList::GetHead();};
    CTimeSigItem* RemoveHead() {return (CTimeSigItem*)AList::RemoveHead();};
    CTimeSigItem* GetItem(LONG lIndex) { return (CTimeSigItem*) AList::GetItem(lIndex);};
};

class CTimeSigStateData
{
public:
    CTimeSigStateData()
	{
		m_mtPrevEnd = 0;
		m_bBeat = 4;
		m_bBeatsPerMeasure = 4;
		m_mtTimeSig = 0;
        m_fActive = TRUE;
		/* don't need these since they are always initialized
		m_pPerformance = NULL;
		m_pSegState = NULL;
		m_dwVirtualTrackID = 0;
		*/
	}
    CTimeSigItem *	            m_pCurrentTSig;
	IDirectMusicPerformance*	m_pPerformance;
	IDirectMusicSegmentState*	m_pSegState;
	DWORD						m_dwVirtualTrackID;
	DWORD						m_dwValidate; // used to validate state data
	MUSIC_TIME					m_mtPrevEnd;
	MUSIC_TIME					m_mtTimeSig; // previous time sig time
    BOOL                        m_fActive;
    BYTE						m_bBeat; // previous beat
	BYTE						m_bBeatsPerMeasure; // previous beats per measure
};

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack
class CTimeSigTrack : 
	public IPersistStream,
	public IDirectMusicTrack
{
public:
	CTimeSigTrack();
	CTimeSigTrack(CTimeSigTrack *pTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTimeSigTrack();

// member variables
protected:
	CTimeSigList	    m_TSigEventList;
	long		        m_cRef;
	DWORD		        m_dwValidate; // used to validate state data.
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL		        m_fNotificationMeasureBeat;
	BOOL		        m_fActive;              // Track is active for generating time signatures
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);

// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
	HRESULT STDMETHODCALLTYPE Seek( void *pStateData,MUSIC_TIME mtTime,BOOL fGetPrevious);
	void Construct(void);
    void Clear();
    HRESULT LoadTimeSigList( CRiffParser *pParser, long lChunkSize );
protected:
	MUSIC_TIME NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
			CTimeSigStateData* pSD, MUSIC_TIME mtOffset );
};

#endif //__TSIGTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\wavtrack.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)

// WavTrack.cpp : Implementation of CWavTrack
#include "dmime.h"
#include "dmperf.h"
#include "WavTrack.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\Validate.h"
#include "debug.h"
#include "..\dswave\dswave.h"
#include "dmsegobj.h"
#define ASSERT  assert
#include <math.h>

// @doc EXTERNAL

TList<TaggedWave> WaveItem::st_WaveList;
CRITICAL_SECTION WaveItem::st_WaveListCritSect;
long CWavTrack::st_RefCount = 0;

BOOL PhysicalLess(WaveItem& WI1, WaveItem& WI2)
{
    return WI1.m_rtTimePhysical < WI2.m_rtTimePhysical;
}

BOOL LogicalLess(WaveItem& WI1, WaveItem& WI2)
{
    return WI1.m_mtTimeLogical < WI2.m_mtTimeLogical;
}

/////////////////////////////////////////////////////////////////////////////
// CWavTrack

void CWavTrack::FlushWaves()
{
    UnloadAllWaves(NULL);
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    while (!WaveItem::st_WaveList.IsEmpty())
    {
        TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.RemoveHead();
        delete pScan;
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
}

HRESULT CWavTrack::UnloadAllWaves(IDirectMusicPerformance* pPerformance)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&WaveItem::st_WaveListCritSect);
    TListItem<TaggedWave>* pScan = WaveItem::st_WaveList.GetHead();
    TListItem<TaggedWave>* pNext = NULL;
    for (; pScan; pScan = pNext)
    {
        pNext = pScan->GetNext();
        TaggedWave& rScan = pScan->GetItemValue();
        if (!pPerformance || rScan.m_pPerformance == pPerformance)
        {
            if (rScan.m_pPort)
            {
                if (rScan.m_pDownloadedWave)
                {
                    Trace(1, "Error: Wave was downloaded but never unloaded.\n");
                    rScan.m_pPort->UnloadWave(rScan.m_pDownloadedWave);
                    rScan.m_pDownloadedWave = NULL;
                }
                rScan.m_pPort->Release();
                rScan.m_pPort = NULL;
            }
            if (rScan.m_pPerformance)
            {
                rScan.m_pPerformance->Release();
                rScan.m_pPerformance = NULL;
            }
            if (rScan.m_pWave)
            {
                rScan.m_pWave->Release();
                rScan.m_pWave = NULL;
            }
            WaveItem::st_WaveList.Remove(pScan);
            delete pScan;
        }
    }
    LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
    return hr;
}

// This SHOULD NOT be called except from a constructor.
void CWavTrack::Construct()
{
    InterlockedIncrement(&g_cComponent);

    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;

    m_dwPChannelsUsed = 0;
    m_aPChannels = NULL;
    m_dwTrackFlags = 0;
    m_dwValidate = 0;
    m_cRef = 1;
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    m_fAutoDownload = FALSE;
    m_fLockAutoDownload = FALSE;
    st_RefCount++;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    m_dwWaveItems = 0;
}

void CWavTrack::CleanUp()
{
    m_dwPChannelsUsed = 0;
    if (m_aPChannels) delete [] m_aPChannels;
    if (m_pdwVariations) delete [] m_pdwVariations;
    if (m_pdwRemoveVariations) delete [] m_pdwRemoveVariations;
    m_aPChannels = NULL;
    m_pdwVariations = NULL;
    m_pdwRemoveVariations = NULL;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WavePartList.CleanUp();
    RemoveDownloads(NULL);
}

void CWavTrack::CleanUpTempParts()
{
    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_TempWavePartList.CleanUp();
}

void CWavTrack::MovePartsToTemp()
{
    CleanUpTempParts();
    TListItem<WavePart>* pScan = m_WavePartList.RemoveHead();
    for (; pScan; pScan = m_WavePartList.RemoveHead() )
    {
        m_TempWavePartList.AddHead(pScan);
    }
}

// NULL for non-streaming waves.
// For streaming waves, return the DownLoadedWave that's associated with the same wave
// with the same start offset (and remove it from the Item list so it's not returned again).
IDirectSoundDownloadedWaveP* CWavTrack::FindDownload(TListItem<WaveItem>* pItem)
{
    if (!pItem || !pItem->GetItemValue().m_pWave || !pItem->GetItemValue().m_fIsStreaming)
    {
        return NULL;
    }

    WaveItem& rWaveItem = pItem->GetItemValue();

    TListItem<WavePart>* pScan = m_TempWavePartList.GetHead();
    for (; pScan ; pScan = pScan->GetNext())
    {
        TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
        TListItem<WaveItem>* pNext = NULL;
        for (; pItemScan; pItemScan = pNext)
        {
            pNext = pItemScan->GetNext();
            WaveItem& rTempItem = pItemScan->GetItemValue();
            if (rTempItem.m_fIsStreaming &&
                rWaveItem.m_pWave == rTempItem.m_pWave &&
                rWaveItem.m_rtStartOffset == rTempItem.m_rtStartOffset)
            {
                IDirectSoundDownloadedWaveP* pReturn = rTempItem.m_pDownloadedWave;
                if (rTempItem.m_pWave)
                {
                    rTempItem.m_pWave->Release();
                    rTempItem.m_pWave = NULL;
                }
                rTempItem.m_pDownloadedWave = NULL;
                pScan->GetItemValue().m_WaveItemList.Remove(pItemScan);
                delete pItemScan;
                return pReturn;
            }
        }
    }
    return NULL;
}

HRESULT CWavTrack::GetDownload(
        IDirectSoundDownloadedWaveP* pWaveDL,
        WaveStateData* pStateData,
        IDirectMusicPortP* pPortP,
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtStartOffset,
        WaveItem& rItem,
        DWORD dwMChannel,
        DWORD dwGroup,
        IDirectMusicVoiceP **ppVoice)
{
    HRESULT hr = S_OK;
    TListItem<WaveDLOnPlay>* pNew = NULL;
    if (!pWaveDL || !pStateData) return E_POINTER;

    IDirectSoundDownloadedWaveP* pNewWaveDL = NULL;
    if (rItem.m_fIsStreaming)
    {
        bool fPair = false;
        TListItem<WavePair>* pPair = m_WaveList.GetHead();
        for (; pPair; pPair = pPair->GetNext())
        {
            if (pWaveDL == pPair->GetItemValue().m_pWaveDL)
            {
                if (!pNewWaveDL)
                {
                    // download a new one (to be returned), and put it in the state data's list.
                    if (FAILED(hr = pPortP->DownloadWave( pWave, &pNewWaveDL, rtStartOffset )))
                    {
                        return hr;
                    }
                    pNew = new TListItem<WaveDLOnPlay>;
                    if (!pNew)
                    {
                        pPortP->UnloadWave(pNewWaveDL);
                        return E_OUTOFMEMORY;
                    }
                    pNew->GetItemValue().m_pWaveDL = pNewWaveDL;
                    pNew->GetItemValue().m_pPort = pPortP;
                    pPortP->AddRef();
                    pStateData->m_WaveDLList.AddHead(pNew);
                }
                if (pStateData == pPair->GetItemValue().m_pStateData)
                {
                    fPair = true;
                    break;
                }
            }
        }
        if (!fPair)
        {
            // create one and add it to m_WaveList
            pPair = new TListItem<WavePair>;
            if (!pPair)
            {
                return E_OUTOFMEMORY;
            }
            pPair->GetItemValue().m_pStateData = pStateData;
            pPair->GetItemValue().m_pWaveDL = pWaveDL;
            pWaveDL->AddRef();
            m_WaveList.AddHead(pPair);
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!pNewWaveDL) pNewWaveDL = pWaveDL;
        hr = pPortP->AllocVoice(pNewWaveDL,
            dwMChannel, dwGroup, rtStartOffset,
            rItem.m_dwLoopStart, rItem.m_dwLoopEnd,
            ppVoice);
        if (SUCCEEDED(hr))
        {
            if (pNew)
            {
                pNew->GetItemValue().m_pVoice = *ppVoice;
            }
            else
            {
                if (pStateData->m_apVoice[rItem.m_dwVoiceIndex])
                {
                    pStateData->m_apVoice[rItem.m_dwVoiceIndex]->Release();
                }
                pStateData->m_apVoice[rItem.m_dwVoiceIndex] = *ppVoice;
            }
        }
    }
    return hr;
}

void CWavTrack::RemoveDownloads(WaveStateData* pStateData)
{
    TListItem<WavePair>* pPair = m_WaveList.GetHead();
    TListItem<WavePair>* pNextPair = NULL;
    for (; pPair; pPair = pNextPair)
    {
        pNextPair = pPair->GetNext();
        if (!pStateData || pPair->GetItemValue().m_pStateData == pStateData)
        {
            m_WaveList.Remove(pPair);
            delete pPair;
        }
    }

    if (pStateData)
    {
        TListItem<WaveDLOnPlay>* pWDLOnPlay = NULL;
        while (!pStateData->m_WaveDLList.IsEmpty())
        {
            pWDLOnPlay = pStateData->m_WaveDLList.RemoveHead();
            delete pWDLOnPlay;
        }
    }
}

CWavTrack::CWavTrack()
{
    Construct();
}

CWavTrack::CWavTrack(const CWavTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
    Construct();
    CopyParts(rTrack.m_WavePartList, mtStart, mtEnd);
    m_lVolume = rTrack.m_lVolume;
    m_dwTrackFlags = rTrack.m_dwTrackFlags;
}

HRESULT CWavTrack::InitTrack(DWORD dwPChannels)
{
    HRESULT hr = S_OK;

    m_dwPChannelsUsed = dwPChannels;
    m_dwWaveItems = 0;
    if( m_dwPChannelsUsed )
    {
        m_aPChannels = new DWORD[m_dwPChannelsUsed];
        if (!m_aPChannels) hr = E_OUTOFMEMORY;
        else if (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL)
        {
            m_pdwVariations = new DWORD[m_dwPChannelsUsed];
            m_pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
            if (!m_pdwVariations || !m_pdwRemoveVariations) hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pScan = m_WavePartList.GetHead();
            for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
            {
                m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
                if (m_pdwVariations) m_pdwVariations[dw] = 0;
                if (m_pdwRemoveVariations) m_pdwRemoveVariations[dw] = 0;
                TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
                for (; pItemScan; pItemScan = pItemScan->GetNext())
                {
                    pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                    m_dwWaveItems++;
                }
            }
        }
        else CleanUp();
    }
    return hr;
}

CWavTrack::~CWavTrack()
{
    if (m_fCSInitialized)
    {
        CleanUpTempParts();
        CleanUp();
        st_RefCount--;
        if (st_RefCount <= 0)
        {
            // if there's still something in the wave list, it means there are waves that
            // haven't been unloaded; but at this point we've gotten rid of all wave tracks,
            // so unload and release everything now.
            UnloadAllWaves(NULL);
            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
            WaveItem::st_WaveList.CleanUp();
            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);
        }
        DeleteCriticalSection(&m_CrSec);
    }

    InterlockedDecrement(&g_cComponent);
}

// @method:(INTERNAL) HRESULT | IDirectMusicTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
// @flag E_POINTER | <p ppv> is NULL or invalid.
//
STDMETHODIMP CWavTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
    V_INAME(CWavTrack::QueryInterface);
    V_PTRPTR_WRITE(ppv);
    V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack || iid == IID_IDirectMusicTrack8)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    }
    else if (iid == IID_IPersistStream)
    {
        *ppv = static_cast<IPersistStream*>(this);
    }
    else if (iid == IID_IPrivateWaveTrack)
    {
        *ppv = static_cast<IPrivateWaveTrack*>(this);
    }
    else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Wave Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | AddRef | Standard AddRef implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(INTERNAL) HRESULT | IDirectMusicTrack | Release | Standard Release implementation for <i IDirectMusicSeqTrack>
//
// @rdesc Returns the new reference count for this object.
//
STDMETHODIMP_(ULONG) CWavTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CWavTrack::GetClassID( CLSID* pClassID )
{
    V_INAME(CSeqTrack::GetClassID);
    V_PTR_WRITE(pClassID, CLSID);
    *pClassID = CLSID_DirectMusicWaveTrack;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CWavTrack::IsDirty()
{
    return S_FALSE;
}

HRESULT CWavTrack::Load( IStream* pIStream )
{
    V_INAME(CWavTrack::Load);
    V_INTERFACE(pIStream);

    DWORD dwSize;
    DWORD dwByteCount;

    // Verify that the stream pointer is non-null
    if( pIStream == NULL )
    {
        Trace(1,"Error: Null stream passed to wave track.\n");
        return E_POINTER;
    }

    IDMStream* pIRiffStream;
    HRESULT hr = E_FAIL;

    // Try and allocate a RIFF stream
    if( FAILED( hr = AllocDirectMusicStream( pIStream, &pIRiffStream ) ) )
    {
        return hr;
    }

    // Variables used when loading the Wave track
    MMCKINFO ckTrack;
    MMCKINFO ckList;

    EnterCriticalSection(&m_CrSec);
    m_dwValidate++; // used to validate state data that's out there
    MovePartsToTemp();
    CleanUp();

    // Interate through every chunk in the stream
    while( pIRiffStream->Descend( &ckTrack, NULL, 0 ) == S_OK )
    {
        switch( ckTrack.ckid )
        {
            case FOURCC_LIST:
                switch( ckTrack.fccType )
                {
                    case DMUS_FOURCC_WAVETRACK_LIST:
                        while( pIRiffStream->Descend( &ckList, &ckTrack, 0 ) == S_OK )
                        {
                            switch( ckList.ckid )
                            {
                                case DMUS_FOURCC_WAVETRACK_CHUNK:
                                {
                                    DMUS_IO_WAVE_TRACK_HEADER iTrackHeader;

                                    // Read in the item's header structure
                                    dwSize = min( sizeof( DMUS_IO_WAVE_TRACK_HEADER ), ckList.cksize );
                                    hr = pIStream->Read( &iTrackHeader, dwSize, &dwByteCount );

                                    // Handle any I/O error by returning a failure code
                                    if( FAILED( hr ) ||  dwByteCount != dwSize )
                                    {
                                        if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                                        goto ON_ERROR;
                                    }

                                    m_lVolume = iTrackHeader.lVolume;
                                    m_dwTrackFlags = iTrackHeader.dwFlags;
                                    break;
                                }

                                case FOURCC_LIST:
                                    switch( ckList.fccType )
                                    {
                                        case DMUS_FOURCC_WAVEPART_LIST:
                                        {
                                            TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
                                            if( !pNewPart )
                                            {
                                                hr = E_OUTOFMEMORY;
                                                goto ON_ERROR;
                                            }
                                            hr = pNewPart->GetItemValue().Load( pIRiffStream, &ckList );
                                            if( FAILED ( hr ) )
                                            {
                                                delete pNewPart;
                                                goto ON_ERROR;
                                            }
                                            InsertByAscendingPChannel( pNewPart );
                                            break;
                                        }
                                    }
                                    break;
                            }

                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;
                }
                break;
        }

        pIRiffStream->Ascend( &ckTrack, 0 );
    }
    hr = InitTrack(m_WavePartList.GetCount());
    if (SUCCEEDED(hr))
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (; pScan ; pScan = pScan->GetNext())
        {
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_pDownloadedWave = FindDownload(pItemScan);
            }
        }
    }
    else CleanUp();

ON_ERROR:
    CleanUpTempParts();
    LeaveCriticalSection(&m_CrSec);
    pIRiffStream->Release();
    return hr;
}

HRESULT CWavTrack::CopyParts( const TList<WavePart>& rParts, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WavePart>* pScan = rParts.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        TListItem<WavePart>* pNew = new TListItem<WavePart>;
        if (pNew)
        {
            WavePart& rNew = pNew->GetItemValue();
            rNew.m_dwLockToPart = rScan.m_dwLockToPart;
            rNew.m_dwPChannel = rScan.m_dwPChannel;
            rNew.m_dwIndex = rScan.m_dwIndex;
            rNew.m_dwPChannelFlags = rScan.m_dwPChannelFlags;
            rNew.m_lVolume = rScan.m_lVolume;
            rNew.m_dwVariations = rScan.m_dwVariations;
            if (SUCCEEDED(hr = rNew.CopyItems(rScan.m_WaveItemList, mtStart, mtEnd)))
            {
                m_WavePartList.AddHead(pNew);
            }
            else
            {
                delete pNew;
                break;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WavePartList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

void CWavTrack::InsertByAscendingPChannel( TListItem<WavePart>* pPart )
{
    if (pPart)
    {
        DWORD dwPChannel = pPart->GetItemValue().m_dwPChannel;
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        TListItem<WavePart>* pPrevious = NULL;
        for (; pScan; pScan = pScan->GetNext())
        {
            if (dwPChannel < pScan->GetItemValue().m_dwPChannel)
            {
                break;
            }
            pPrevious = pScan;
        }
        if (pPrevious)
        {
            pPart->SetNext(pScan);
            pPrevious->SetNext(pPart);
        }
        else
        {
            m_WavePartList.AddHead(pPart);
        }
    }
}

HRESULT CWavTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

// IDirectMusicTrack
/*
@method HRESULT | IDirectMusicTrack | IsParamSupported |
Check to see if the Track supports data types in <om .GetParam> and <om .SetParam>.

@rvalue S_OK | It does support the type of data.
@rvalue S_FALSE | It does not support the type of data.
@rvalue E_NOTIMPL | (Or any other failure code) It does not support the type of data.

@comm Note that it is valid for a Track to return different results for the same
guid depending on its current state.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::IsParamSupported(
    REFGUID rguidType)  // @parm The guid identifying the type of data to check.
{
    if(rguidType == GUID_Download ||
       rguidType == GUID_DownloadToAudioPath ||
       rguidType == GUID_UnloadFromAudioPath ||
       rguidType == GUID_Enable_Auto_Download ||
       rguidType == GUID_Disable_Auto_Download ||
       rguidType == GUID_Unload )
    {
        return S_OK;
    }
    else
    {
        return DMUS_E_TYPE_UNSUPPORTED;
    }
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
/*
@method HRESULT | IDirectMusicTrack | Init |
When a track is first added to a <i IDirectMusicSegment>, this method is called
by that Segment.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pSegment> is NULL or invalid.

@comm If the Track plays messages, it should call <om IDirectMusicSegment.SetPChannelsUsed>.
*/
HRESULT CWavTrack::Init(
    IDirectMusicSegment *pSegment)  // @parm Pointer to the Segment to which this Track belongs.
{
    EnterCriticalSection(&m_CrSec);
    if( m_dwPChannelsUsed && m_aPChannels )
    {
        pSegment->SetPChannelsUsed( m_dwPChannelsUsed, m_aPChannels );
    }
    CSegment* pCSegment = NULL;
    bool fSortLogical = false;
    if (SUCCEEDED(pSegment->QueryInterface(IID_CSegment, (void**)&pCSegment)))
    {
        DWORD dwGroupBits = 0;
        if (FAILED(pSegment->GetTrackGroup( this, &dwGroupBits )))
        {
            dwGroupBits = 0xffffffff;
        }
        DWORD dwConfig = 0;
        if (SUCCEEDED(pCSegment->GetTrackConfig(CLSID_DirectMusicWaveTrack, dwGroupBits, 0, &dwConfig)))
        {
            if ( !(dwConfig & DMUS_TRACKCONFIG_PLAY_CLOCKTIME) )
            {
                fSortLogical = true;
            }
        }
        pCSegment->Release();
    }
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext())
    {
        if (fSortLogical)
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(LogicalLess);
        }
        else
        {
            pScan->GetItemValue().m_WaveItemList.MergeSort(PhysicalLess);
        }
    }
    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

/*
@method HRESULT | IDirectMusicTrack | InitPlay |
This method is called when a Segment is ready to start playing. The <p ppStateData> field
may return a pointer to a structure of state data, which is sent into <om .Play> and
<om .EndPlay>, and allows the Track to keep track of variables on a <i SegmentState> by
<i SegmentState> basis.

@rvalue S_OK | Success. This is the only valid return value from this method.
@rvalue E_POINTER | <p pSegmentState>, <p pPerf>, or <p ppStateData> is NULL or
invalid.

@comm Note that it is unneccessary for the Track to store the <p pSegmentState>, <p pPerf>,
or <p dwTrackID> parameters, since they are also sent into <om .Play>.
*/
HRESULT CWavTrack::InitPlay(
    IDirectMusicSegmentState *pSegmentState,    // @parm The calling <i IDirectMusicSegmentState> pointer.
    IDirectMusicPerformance *pPerf, // @parm The calling <i IDirectMusicPerformance> pointer.
    void **ppStateData,     // @parm This method can return state data information here.
    DWORD dwTrackID,        // @parm The virtual track ID assigned to this Track instance.
    DWORD dwFlags)          // @parm Same flags that were set with the call
            // to PlaySegment. These are passed all the way down to the tracks, who may want to know
            // if the track was played as a primary, controlling, or secondary segment.
{
    V_INAME(IDirectMusicTrack::InitPlay);
    V_PTRPTR_WRITE(ppStateData);
    V_INTERFACE(pSegmentState);
    V_INTERFACE(pPerf);
    HRESULT hr = E_OUTOFMEMORY;
    IDirectMusicSegmentState8 *pSegSt8 = NULL;

    EnterCriticalSection(&m_CrSec);
    WaveStateData* pStateData = new WaveStateData;
    if( NULL == pStateData )
    {
        goto ON_END;
    }

    // Get the audiopath being used by our segment state and save it in our state data.
    hr = pSegmentState->QueryInterface(IID_IDirectMusicSegmentState8, reinterpret_cast<void**>(&pSegSt8));
    if (SUCCEEDED(hr))
    {
        hr = pSegSt8->GetObjectInPath(
                        0,                          // pchannel doesn't apply
                        DMUS_PATH_AUDIOPATH,        // get the audiopath
                        0,                          // buffer index doesn't apply
                        CLSID_NULL,                 // clsid doesn't apply
                        0,                          // there should be only one audiopath
                        IID_IDirectMusicAudioPath,
                        reinterpret_cast<void**>(&pStateData->m_pAudioPath));

        // If this doesn't find an audiopath that's OK.  If we're not playing on an audiopath then
        // pAudioPath stays NULL and we'll play our triggered segments on the general performance.
        if (hr == DMUS_E_NOT_FOUND)
            hr = S_OK;

        pSegSt8->Release();
    }

    pStateData->m_pPerformance = pPerf;
    {
        *ppStateData = pStateData;
        StatePair SP(pSegmentState, pStateData);
        TListItem<StatePair>* pPair = new TListItem<StatePair>(SP);
        if (!pPair)
        {
            goto ON_END;
        }
        m_StateList.AddHead(pPair);
    }
    SetUpStateCurrentPointers(pStateData);

    // Set up arrays for variations
    if (m_dwPChannelsUsed)
    {
        pStateData->pdwVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwVariations)
        {
            goto ON_END;
        }
        pStateData->pdwRemoveVariations = new DWORD[m_dwPChannelsUsed];
        if (!pStateData->pdwRemoveVariations)
        {
            goto ON_END;
        }
        for (DWORD dw = 0; dw < m_dwPChannelsUsed; dw++)
        {
            if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
                 m_pdwVariations &&
                 m_pdwRemoveVariations )
            {
                pStateData->pdwVariations[dw] = m_pdwVariations[dw];
                pStateData->pdwRemoveVariations[dw] = m_pdwRemoveVariations[dw];
            }
            else
            {
                pStateData->pdwVariations[dw] = 0;
                pStateData->pdwRemoveVariations[dw] = 0;
            }
        }
    }

    // need to know the group this track is in, for the mute track GetParam
    IDirectMusicSegment* pSegment;
    if( SUCCEEDED( pSegmentState->GetSegment(&pSegment)))
    {
        pSegment->GetTrackGroup( this, &pStateData->dwGroupBits );
        pSegment->Release();
    }

    // for auditioning variations...
    pStateData->InitVariationInfo(m_dwVariation, m_dwPart, m_dwIndex, m_dwLockID, m_fAudition);
    hr = S_OK;

    BOOL fGlobal; // if the performance has been set with an autodownload preference,
                // use that. otherwise, assume autodownloading is off, unless it has
                // been locked (i.e. specified on the band track.)
    if( SUCCEEDED( pPerf->GetGlobalParam( GUID_PerfAutoDownload, &fGlobal, sizeof(BOOL) )))
    {
        if( !m_fLockAutoDownload )
        {
            // it might seem like we can just assign m_fAutoDownload = fGlobal,
            // but that's bitten markburt before, so I'm being paranoid today.
            if( fGlobal )
            {
                m_fAutoDownload = TRUE;
            }
            else
            {
                m_fAutoDownload = FALSE;
            }
        }
    }
    else if( !m_fLockAutoDownload )
    {
        m_fAutoDownload = FALSE;
    }
    // Call SetParam to download all waves used by the track
    // This is the auto-download feature that can be turned off with a call to SetParam
    if(m_fAutoDownload)
    {
        hr = SetParam(GUID_Download, 0, (void *)pPerf);
        if (FAILED(hr)) goto ON_END;
    }

    ///////////////// pre-allocate voices for all waves in the track ////////////////
    pStateData->m_dwVoices = m_dwWaveItems;
    pStateData->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
    if (!pStateData->m_apVoice)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
        {
            pStateData->m_apVoice[dw] = NULL;
        }
        Seek( pSegmentState, pPerf, dwTrackID, pStateData, 0, TRUE, 0, FALSE );
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        DWORD dwPChannel = 0;
        for( DWORD dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            long lPartVolume = 0;
            if( pPart )
            {
                WavePart& rPart = pPart->GetItemValue();
                dwPChannel = rPart.m_dwPChannel;
                lPartVolume = rPart.m_lVolume;
            }
            if( pStateData->apCurrentWave )
            {
                for( ; pStateData->apCurrentWave[dwIndex];
                    pStateData->apCurrentWave[dwIndex] = pStateData->apCurrentWave[dwIndex]->GetNext() )
                {
                    WaveItem& rItem = pStateData->apCurrentWave[dwIndex]->GetItemValue();
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    hr = rItem.PChannelInfo(pPerf, pStateData->m_pAudioPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave &&
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                if (rItem.m_dwVoiceIndex == 0xffffffff)
                                {
                                    hr = DMUS_E_NOT_INIT;
                                    TraceI(0, "Voice index not initialized!\n");
                                }
                                else if(!rItem.m_fIsStreaming || (rItem.m_fIsStreaming && rItem.m_fUseNoPreRoll == FALSE))
                                {
                                    IDirectMusicVoiceP *pVoice = NULL;
                                    hr = GetDownload(
                                        rDLWave.m_pDownloadedWave,
                                        pStateData,
                                        pPortP,
                                        rDLWave.m_pWave,
                                        rtStartOffset,
                                        rItem,
                                        dwMChannel, dwGroup,
                                        &pVoice);
                                }
                            }
                            else
                            {
                                hr = DMUS_E_NOT_INIT;
                                Trace(1, "Error: Attempt to play wave that has not been downloaded.\n");

                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                            // Release the private interface
                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
            if( pPart )
            {
                pPart = pPart->GetNext();
            }
        }
    }

ON_END:
    if (FAILED(hr) && pStateData)
    {
        delete pStateData;
        pStateData = NULL;
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*
@method HRESULT | IDirectMusicTrack | EndPlay |
This method is called when the <i IDirectMusicSegmentState> object that originally called
<om .InitPlay> is destroyed.

@rvalue S_OK | Success.
@rvalue E_POINTER | <p pStateData> is invalid.
@comm The return code isn't used, but S_OK is preferred.
*/
HRESULT CWavTrack::EndPlay(
    void *pStateData)   // @parm The state data returned from <om .InitPlay>.
{
    EnterCriticalSection(&m_CrSec);

    ASSERT( pStateData );
    if( pStateData )
    {
        V_INAME(IDirectMusicTrack::EndPlay);
        V_BUFPTR_WRITE(pStateData, sizeof(WaveStateData));
        WaveStateData* pSD = (WaveStateData*)pStateData;
        RemoveDownloads(pSD);
        if(m_fAutoDownload)
        {
            SetParam(GUID_Unload, 0, (void *)pSD->m_pPerformance);
        }
        for (TListItem<StatePair>* pScan = m_StateList.GetHead(); pScan; pScan = pScan->GetNext())
        {
            StatePair& rPair = pScan->GetItemValue();
            if (pSD == rPair.m_pStateData)
            {
                rPair.m_pSegState = NULL;
                rPair.m_pStateData = NULL;
                break;
            }
        }
        delete pSD;
    }

    LeaveCriticalSection(&m_CrSec);
    return S_OK;
}

void CWavTrack::SetUpStateCurrentPointers(WaveStateData* pStateData)
{
    ASSERT(pStateData);
    pStateData->dwPChannelsUsed = m_dwPChannelsUsed;
    if( m_dwPChannelsUsed )
    {
        if( pStateData->apCurrentWave )
        {
            delete [] pStateData->apCurrentWave;
            pStateData->apCurrentWave = NULL;
        }
        pStateData->apCurrentWave = new TListItem<WaveItem>* [m_dwPChannelsUsed];
        if( pStateData->apCurrentWave )
        {
            memset( pStateData->apCurrentWave, 0, sizeof(TListItem<WavePart>*) * m_dwPChannelsUsed );
        }
    }
    pStateData->dwValidate = m_dwValidate;
}

REFERENCE_TIME ConvertOffset(REFERENCE_TIME rtOffset, long lPitch)
{
    if (lPitch)
    {
        double dblPitch = (double) lPitch;
        double dblStart = (double) rtOffset;
        dblStart *= pow(2, (dblPitch / 1200.0));
        rtOffset = (REFERENCE_TIME) dblStart;
    }
    return rtOffset;
}

STDMETHODIMP CWavTrack::PlayEx(void* pStateData,REFERENCE_TIME rtStart,
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf,
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID)
{
    V_INAME(IDirectMusicTrack::PlayEx);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    HRESULT hr;
    EnterCriticalSection(&m_CrSec);
    BOOL fClock = (dwFlags & DMUS_TRACKF_CLOCK) ? TRUE : FALSE;
/*    if (dwFlags & DMUS_TRACKF_CLOCK)
    {
        hr = Play(pStateData,(MUSIC_TIME)(rtStart / REF_PER_MIL),(MUSIC_TIME)(rtEnd / REF_PER_MIL),
            (MUSIC_TIME)(rtOffset / REF_PER_MIL),rtOffset,dwFlags,pPerf,pSegSt,dwVirtualID,TRUE);
    }
    else*/
    {
        hr = Play(pStateData, rtStart, rtEnd, rtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, fClock);
    }
    LeaveCriticalSection(&m_CrSec);
    return hr;
}
/*
@enum DMUS_TRACKF_FLAGS | Sent in <om IDirectMusicTrack.Play>'s dwFlags parameter.
@emem DMUS_TRACKF_SEEK | Play was called on account of seeking, meaning that mtStart is
not necessarily the same as the previous Play call's mtEnd.
@emem DMUS_TRACKF_LOOP | Play was called on account of a loop, e.g. repeat.
@emem DMUS_TRACKF_START | This is the first call to Play. DMUS_TRACKF_SEEK may also be set if the
Track is not playing from the beginning.
@emem DMUS_TRACKF_FLUSH | The call to Play is on account of a flush or invalidate, that
requires the Track to replay something it played previously. In this case, DMUS_TRACKF_SEEK
will be set as well.

  @method HRESULT | IDirectMusicTrack | Play |
  Play method.
  @rvalue DMUS_DMUS_S_END | The Track is done playing.
  @rvalue S_OK | Success.
  @rvalue E_POINTER | <p pStateData>, <p pPerf>, or <p pSegSt> is NULL or invalid.
*/
STDMETHODIMP CWavTrack::Play(
    void *pStateData,   // @parm State data pointer, from <om .InitPlay>.
    MUSIC_TIME mtStart, // @parm The start time to play.
    MUSIC_TIME mtEnd,   // @parm The end time to play.
    MUSIC_TIME mtOffset,// @parm The offset to add to all messages sent to
                        // <om IDirectMusicPerformance.SendPMsg>.
    DWORD dwFlags,      // @parm Flags that indicate the state of this call.
                        // See <t DMUS_TRACKF_FLAGS>. If dwFlags == 0, this is a
                        // normal Play call continuing playback from the previous
                        // Play call.
    IDirectMusicPerformance* pPerf, // @parm The <i IDirectMusicPerformance>, used to
                        // call <om IDirectMusicPerformance.AllocPMsg>,
                        // <om IDirectMusicPerformance.SendPMsg>, etc.
    IDirectMusicSegmentState* pSegSt,   // @parm The <i IDirectMusicSegmentState> this
                        // track belongs to. QueryInterface() can be called on this to
                        // obtain the SegmentState's <i IDirectMusicGraph> in order to
                        // call <om IDirectMusicGraph.StampPMsg>, for instance.
    DWORD dwVirtualID   // @parm This track's virtual track id, which must be set
                        // on any <t DMUS_PMSG>'s m_dwVirtualTrackID member that
                        // will be queued to <om IDirectMusicPerformance.SendPMsg>.
    )
{
    V_INAME(IDirectMusicTrack::Play);
    V_BUFPTR_WRITE( pStateData, sizeof(WaveStateData));
    V_INTERFACE(pPerf);
    V_INTERFACE(pSegSt);

    EnterCriticalSection(&m_CrSec);
    HRESULT hr = Play(pStateData, mtStart, mtEnd, mtOffset, dwFlags, pPerf, pSegSt, dwVirtualID, FALSE);
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

/*  The Play method handles both music time and clock time versions, as determined by
    fClockTime. If running in clock time, rtOffset is used to identify the start time
    of the segment. Otherwise, mtOffset. The mtStart and mtEnd parameters are in MUSIC_TIME units
    or milliseconds, depending on which mode.
*/

// BUGBUG go through all the times and make sure music time/reference time stuff
// all makes sense

HRESULT CWavTrack::Play(
    void *pStateData,
    REFERENCE_TIME rtStart,
    REFERENCE_TIME rtEnd,
    //MUSIC_TIME mtOffset,
    REFERENCE_TIME rtOffset,
    DWORD dwFlags,
    IDirectMusicPerformance* pPerf,
    IDirectMusicSegmentState* pSegSt,
    DWORD dwVirtualID,
    BOOL fClockTime)
{
    if (dwFlags & DMUS_TRACKF_PLAY_OFF)
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    IDirectMusicGraph* pGraph = NULL;
    WaveStateData* pSD = (WaveStateData*)pStateData;
    if ( dwFlags & DMUS_TRACKF_LOOP )
    {
        REFERENCE_TIME rtPerfStart = rtStart + rtOffset;
        MUSIC_TIME mtPerfStart = 0;
        if (fClockTime)
        {
            pPerf->ReferenceToMusicTime(rtPerfStart, &mtPerfStart);
        }
        else
        {
            mtPerfStart = (MUSIC_TIME)rtPerfStart;
        }
        CPerformance* pCPerf = NULL;
        if (SUCCEEDED(pPerf->QueryInterface(IID_CPerformance, (void**)&pCPerf)))
        {
            pCPerf->FlushVirtualTrack(dwVirtualID, mtPerfStart, FALSE);
            pCPerf->Release();
        }
        pSD->m_fLoop = true;
    }
    BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;
    if ( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
    {
        pSD->rtNextVariation = 0;
    }

    // if we're sync'ing variations to the pattern track, get the current variations
    if ( (m_dwTrackFlags & DMUS_WAVETRACKF_SYNC_VAR) &&
         (!pSD->rtNextVariation || (rtStart <= pSD->rtNextVariation && rtEnd > pSD->rtNextVariation)) )
    {
        hr = SyncVariations(pPerf, pSD, rtStart, rtOffset, fClockTime);
    }
    else if (dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP))
    {
        hr = ComputeVariations(pSD);
    }

    if( dwFlags & (DMUS_TRACKF_SEEK | DMUS_TRACKF_FLUSH | DMUS_TRACKF_DIRTY |
        DMUS_TRACKF_LOOP) )
    {
        // need to reset the PChannel Map in case of any of these flags.
        m_PChMap.Reset();
    }
    if( pSD->dwValidate != m_dwValidate )
    {
        if (pSD->m_apVoice)
        {
            for (DWORD dw = 0; dw < pSD->m_dwVoices; dw++)
			{
				if (pSD->m_apVoice[dw])
				{
					pSD->m_apVoice[dw]->Release();
				}
            }
            delete [] pSD->m_apVoice;
        }
        pSD->m_apVoice = new IDirectMusicVoiceP*[m_dwWaveItems];
        if (!pSD->m_apVoice)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            for (DWORD dw = 0; dw < m_dwWaveItems; dw++)
            {
                pSD->m_apVoice[dw] = NULL;
            }
        }
        pSD->m_dwVoices = m_dwWaveItems;
        SetUpStateCurrentPointers(pSD);
        fSeek = TRUE;
    }

    if( fSeek )
    {
        if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, TRUE, rtOffset, fClockTime );
        }
        else
        {
            Seek( pSegSt, pPerf, dwVirtualID, pSD, rtStart, FALSE, rtOffset, fClockTime );
        }
    }

    if( FAILED( pSegSt->QueryInterface( IID_IDirectMusicGraph,
        (void**)&pGraph )))
    {
        pGraph = NULL;
    }

    DWORD dwIndex;
    DWORD dwPChannel;
    DWORD dwMutePChannel;
    BOOL fMute;

    TListItem<WavePart>* pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        long lPartVolume = 0;
        if( pPart )
        {
            WavePart& rPart = pPart->GetItemValue();
            dwPChannel = rPart.m_dwPChannel;
            lPartVolume = rPart.m_lVolume;
        }
        if( pSD->apCurrentWave )
        {
            for( ; pSD->apCurrentWave[dwIndex];
                pSD->apCurrentWave[dwIndex] = pSD->apCurrentWave[dwIndex]->GetNext() )
            {
                DWORD dwItemVariations = 0;
                WaveItem& rItem = pSD->apCurrentWave[dwIndex]->GetItemValue();
                REFERENCE_TIME rtTime = fClockTime ? rItem.m_rtTimePhysical : rItem.m_mtTimeLogical;
                if( rtTime >= rtEnd )
                {
                    break;
                }
                if (pPart)
                {
                    dwItemVariations = pSD->Variations(pPart->GetItemValue(), dwIndex) & rItem.m_dwVariations;
                }
                MUSIC_TIME mtTime = 0;
                MUSIC_TIME mtOffset = 0;
                if (fClockTime)
                {
                    MUSIC_TIME mtPerfTime = 0;
                    pPerf->ReferenceToMusicTime(rtOffset, &mtOffset);
                    pPerf->ReferenceToMusicTime(rItem.m_rtTimePhysical + rtOffset, &mtPerfTime);
                    mtTime = mtPerfTime - mtOffset;
                }
                else
                {
                    mtTime = rItem.m_mtTimeLogical;
                    mtOffset = (MUSIC_TIME)rtOffset;
                }
                m_PChMap.GetInfo( dwPChannel, mtTime, mtOffset, pSD->dwGroupBits,
                    pPerf, &fMute, &dwMutePChannel, FALSE );
                if( !fMute && dwItemVariations )
                {
                    DWORD dwGroup = 0;
                    DWORD dwMChannel = 0;
                    IDirectMusicPort* pPort = NULL;
                    hr = rItem.PChannelInfo(pPerf, pSD->m_pAudioPath, dwMutePChannel, &pPort, &dwGroup, &dwMChannel);
                    if (SUCCEEDED(hr) && pPort)
                    {
                        IDirectMusicPortP* pPortP = NULL;
                        hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP);
                        if (SUCCEEDED(hr))
                        {
                            EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                            TListItem<TaggedWave>* pDLWave = rItem.st_WaveList.GetHead();
                            for (; pDLWave; pDLWave = pDLWave->GetNext())
                            {
                                TaggedWave& rDLWave = pDLWave->GetItemValue();
                                if (rDLWave.m_pWave == rItem.m_pWave &&
                                    rDLWave.m_pPerformance == pPerf &&
                                    rDLWave.m_pPort == pPortP &&
                                    ( !rItem.m_fIsStreaming ||
                                      rDLWave.m_pDownloadedWave == rItem.m_pDownloadedWave ) )
                                {
                                    break;
                                }
                            }
                            if (pDLWave)
                            {
                                REFERENCE_TIME rtDurationMs = 0;
                                REFERENCE_TIME rtStartOffset = rItem.m_rtStartOffset;
                                REFERENCE_TIME rtDuration = rItem.m_rtDuration;
                                DMUS_WAVE_PMSG* pWave;
                                if( SUCCEEDED( pPerf->AllocPMsg( sizeof(DMUS_WAVE_PMSG),
                                    (DMUS_PMSG**)&pWave )))
                                {
                                    pWave->dwType = DMUS_PMSGT_WAVE;
                                    pWave->dwPChannel = dwMutePChannel;
                                    pWave->dwVirtualTrackID = dwVirtualID;
                                    pWave->dwGroupID = pSD->dwGroupBits;
                                    if (fClockTime)
                                    {
                                        REFERENCE_TIME rtPlay = rItem.m_rtTimePhysical;
                                        rtDuration -= ConvertOffset(rtStartOffset, -rItem.m_lPitch);
                                        if (rtPlay < rtStart)
                                        {
                                            REFERENCE_TIME rtPlayOffset = ConvertOffset(rtStart - rtPlay, rItem.m_lPitch);
                                            rtStartOffset += rtPlayOffset;
                                            rtDuration -= (rtStart - rtPlay);
                                            rtPlay = rtStart;
                                        }
                                        pWave->rtTime = rtPlay + rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_LOCKTOREFTIME;
                                        pWave->lOffset = 0;
                                        rtDurationMs = rtDuration / REF_PER_MIL;
                                    }
                                    else
                                    {
                                        REFERENCE_TIME rtPlay = 0;
                                        MUSIC_TIME mtPlay = (MUSIC_TIME)rItem.m_rtTimePhysical;
                                        pPerf->MusicToReferenceTime(mtPlay + (MUSIC_TIME)rtOffset, &rtPlay);
                                        MUSIC_TIME mtRealPlay = 0;
                                        pPerf->ReferenceToMusicTime(rtPlay + rtStartOffset, &mtRealPlay);
                                        if (mtRealPlay > rtOffset + mtPlay)
                                        {
                                            rtDuration -= ConvertOffset(mtRealPlay - (rtOffset + mtPlay), -rItem.m_lPitch);

                                        }
                                        if (mtPlay < (MUSIC_TIME) rtStart)
                                        {
                                            // Calculate distance from wave start to segment start, but begin
                                            // the calculation at segment start to avoid strangeness
                                            // when attempting to do conversions at times earlier than
                                            // segment start.
                                            REFERENCE_TIME rtRefStartPlus = 0;
                                            REFERENCE_TIME rtRefPlayPlus = 0;
                                            MUSIC_TIME mtNewDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rtStart + (MUSIC_TIME)rtOffset, &rtRefStartPlus);
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + mtPlay + (MUSIC_TIME)rtOffset, &rtRefPlayPlus);
                                            rtStartOffset += ConvertOffset((rtRefStartPlus - rtRefPlayPlus), rItem.m_lPitch);
                                            mtPlay = (MUSIC_TIME) rtStart;
                                            REFERENCE_TIME rtRealDuration = 0;
                                            pPerf->MusicToReferenceTime((MUSIC_TIME)rtStart + (MUSIC_TIME)rItem.m_rtDuration + (MUSIC_TIME)rtOffset, &rtRealDuration);
                                            pPerf->ReferenceToMusicTime(rtRealDuration - (ConvertOffset(rItem.m_rtStartOffset, -rItem.m_lPitch) + (rtRefStartPlus - rtRefPlayPlus)), &mtNewDuration);
                                            rtDuration = (REFERENCE_TIME)mtNewDuration - (rtStart + rtOffset);
                                        }
                                        pWave->mtTime = mtPlay + (MUSIC_TIME)rtOffset;
                                        pWave->dwFlags = DMUS_PMSGF_MUSICTIME;
                                        pWave->lOffset = (MUSIC_TIME)rItem.m_rtTimePhysical - rItem.m_mtTimeLogical;
                                        REFERENCE_TIME rtZero = 0;
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)rtOffset + mtPlay, &rtZero);
                                        pPerf->MusicToReferenceTime((MUSIC_TIME)(rtDuration + rtOffset) + mtPlay, &rtDurationMs);
                                        rtDurationMs -= rtZero;
                                        rtDurationMs /= REF_PER_MIL;
                                    }
                                    // If we're either past the end of the wave, or we're within
                                    // 150 ms of the end of a looping wave (and we've just started
                                    // playback), don't play the wave.
                                    if ( rtDurationMs <= 0 ||
                                         (rItem.m_dwLoopEnd && (dwFlags & DMUS_TRACKF_START) && rtDurationMs < 150) )
                                    {
                                        pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                    }
                                    else
                                    {
                                        pWave->rtStartOffset = rtStartOffset;
                                        pWave->rtDuration = rtDuration;
                                        pWave->lVolume = rItem.m_lVolume + lPartVolume + m_lVolume;
                                        pWave->lPitch = rItem.m_lPitch;
                                        pWave->bFlags = (BYTE)(rItem.m_dwFlags & 0xff);
                                        IDirectMusicVoiceP *pVoice = NULL;
                                        if (rItem.m_dwVoiceIndex == 0xffffffff)
                                        {
                                            hr = DMUS_E_NOT_INIT;
                                            TraceI(0, "Voice index not initialized!\n");
                                        }
                                        else
                                        {
                                            if ( pSD->m_fLoop ||
                                                 !pSD->m_apVoice[rItem.m_dwVoiceIndex] ||
                                                 rtStartOffset != rItem.m_rtStartOffset ||
                                                 dwMutePChannel != dwPChannel)
                                            {
                                                hr = GetDownload(
                                                    pDLWave->GetItemValue().m_pDownloadedWave,
                                                    pSD,
                                                    pPortP,
                                                    pDLWave->GetItemValue().m_pWave,
                                                    pWave->rtStartOffset,
                                                    rItem,
                                                    dwMChannel, dwGroup,
                                                    &pVoice);
                                            }
                                            else
                                            {
                                                pVoice = pSD->m_apVoice[rItem.m_dwVoiceIndex];
                                            }
                                        }
                                        if (SUCCEEDED(hr))
                                        {
                                            pWave->punkUser = (IUnknown*)pVoice;
                                            pVoice->AddRef();
                                            if( pGraph )
                                            {
                                                pGraph->StampPMsg( (DMUS_PMSG*)pWave );
                                            }
                                            hr = pPerf->SendPMsg( (DMUS_PMSG*)pWave );
                                        }
                                        if(FAILED(hr))
                                        {
                                            pPerf->FreePMsg((DMUS_PMSG*)pWave);
                                        }
                                    }
                                }
                            }
                            LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                            pPortP->Release();
                        }
                        pPort->Release();
                    }
                    else if (SUCCEEDED(hr) && !pPort)
                    {
                        Trace(1, "Error: the performance was unable to find a port for voice allocation.\n");
                        hr = DMUS_E_NOT_FOUND;
                    }
                }
            }
        }
        if( pPart )
        {
            pPart = pPart->GetNext();
        }
    }

    if( pGraph )
    {
        pGraph->Release();
    }
    return hr;
}

// Seek() - set all pSD's pointers to the correct location. If fGetPrevious is set,
// it's legal to start in the middle of a wave.
HRESULT CWavTrack::Seek( IDirectMusicSegmentState* pSegSt,
    IDirectMusicPerformance* pPerf, DWORD dwVirtualID,
    WaveStateData* pSD, REFERENCE_TIME rtTime, BOOL fGetPrevious,
    REFERENCE_TIME rtOffset, BOOL fClockTime)
{
    DWORD dwIndex;
    TListItem<WavePart>* pPart;
    TListItem<WaveItem>* pWaveItem;

    // in the case of fGetPrevious (which means DMUS_SEGF_START/LOOP was
    // set in Play() ) we want to reset all lists to the beginning regardless of time.
    if( fGetPrevious )//&& ( rtTime == 0 ) )
    {
        pPart = m_WavePartList.GetHead();
        for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
        {
            if( pPart )
            {
                pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead();
                if( pWaveItem && pSD->apCurrentWave )
                {
                    pSD->apCurrentWave[dwIndex] = pWaveItem;
                }
                pPart = pPart->GetNext();
            }
            else
            {
                break;
            }
        }
        return S_OK;
    }

    pPart = m_WavePartList.GetHead();
    for( dwIndex = 0; dwIndex < m_dwPChannelsUsed; dwIndex++ )
    {
        if( pPart )
        {
            // scan the wave event list in this part.
            for( pWaveItem = pPart->GetItemValue().m_WaveItemList.GetHead(); pWaveItem; pWaveItem = pWaveItem->GetNext() )
            {
                WaveItem& rWaveItem = pWaveItem->GetItemValue();
                REFERENCE_TIME rtWaveTime = fClockTime ? rWaveItem.m_rtTimePhysical : rWaveItem.m_mtTimeLogical;
                if( rtWaveTime >= rtTime )
                {
                    break;
                }
                if( !fGetPrevious )
                {
                    // if we don't care about previous events, just continue
                    continue;
                }
            }
            if( pSD->apCurrentWave )
            {
                pSD->apCurrentWave[dwIndex] = pWaveItem;
            }
            pPart = pPart->GetNext();
        }
    }

    return S_OK;
}

/*
  @method HRESULT | IDirectMusicTrack | GetParam |
  Retrieves data from a Track.

  @rvalue S_OK | Got the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::GetParam(
    REFGUID rguidType,  // @parm The type of data to obtain.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to obtain the data.
    MUSIC_TIME* pmtNext,// @parm Returns the Track time until which the data is valid. <p pmtNext>
                        // may be NULL. If this returns a value of 0, it means that this
                        // data will either be always valid, or it is unknown when it will
                        // become invalid.
    void *pData)        // @parm The struture in which to return the data. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | SetParam |
  Sets data on a Track.

  @rvalue S_OK | Set the data ok.
  @rvalue E_NOTIMPL | Not implemented.
*/
STDMETHODIMP CWavTrack::SetParam(
    REFGUID rguidType,  // @parm The type of data to set.
    MUSIC_TIME mtTime,  // @parm The time, in Track time, to set the data.
    void *pData)        // @parm The struture containing the data to set. Each
                        // <p pGuidType> identifies a particular structure of a
                        // particular size. It is important that this field contain
                        // the correct structure of the correct size. Otherwise,
                        // fatal results can occur.
{
    return SetParamEx(rguidType, mtTime, pData, NULL, 0);
}

STDMETHODIMP CWavTrack::GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,
                                      void* pParam, void * pStateData, DWORD dwFlags)
{
    V_INAME(CBandTrk::SetParamEx);
    V_REFGUID(rguidType);

    HRESULT hr = S_OK;

    if((pParam == NULL) &&
       (rguidType != GUID_Enable_Auto_Download) &&
       (rguidType != GUID_Disable_Auto_Download))
    {
        return E_POINTER;
    }

    EnterCriticalSection(&m_CrSec);

    if(rguidType == GUID_Download)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, NULL, NULL, GUID_NULL)) )
            {
                hrFail = hr;
            }
            else
            {
                dwSuccess++;
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
    }
    else if(rguidType == GUID_DownloadToAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        HRESULT hrFail = S_OK;
        DWORD dwSuccess = 0;

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                if ( FAILED(hr = pPart->GetItemValue().Download(pPerf, pPath, NULL, GUID_NULL)) )
                {
                    hrFail = hr;
                }
                else
                {
                    dwSuccess++;
                }
            }
        }
        // If we had a failure, return it if we had no successes.
        // Else return S_FALSE for partial success.
        if (FAILED(hrFail) && dwSuccess)
        {
            Trace(1,"Error: Wavetrack download was only partially successful. Some sounds will not play.\n");
            hr = S_FALSE;
        }
#ifdef DBG
        if (FAILED(hr))
        {
            Trace(1, "Error: Wavetrack failed download.\n");
        }
#endif
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Unload)
    {
        IDirectMusicPerformance* pPerf = (IDirectMusicPerformance*)pParam;
        V_INTERFACE(pPerf);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            pPart->GetItemValue().Unload(pPerf, NULL, NULL);
        }
    }
    else if(rguidType == GUID_UnloadFromAudioPath)
    {
        IUnknown* pUnknown = (IUnknown*)pParam;
        V_INTERFACE(pUnknown);

        IDirectMusicAudioPath* pPath = NULL;
        IDirectMusicPerformance *pPerf = NULL;
        hr = pUnknown->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
        if (SUCCEEDED(hr))
        {
            hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        else
        {
            hr = pUnknown->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
        }
        if (SUCCEEDED(hr))
        {
            TListItem<WavePart>* pPart = m_WavePartList.GetHead();
            for(; pPart; pPart = pPart->GetNext())
            {
                pPart->GetItemValue().Unload(pPerf, pPath, NULL);
            }
        }
        if (pPath) pPath->Release();
        if (pPerf) pPerf->Release();
    }
    else if(rguidType == GUID_Enable_Auto_Download)
    {
        m_fAutoDownload = TRUE;
        m_fLockAutoDownload = TRUE;
    }
    else if(rguidType == GUID_Disable_Auto_Download)
    {
        m_fAutoDownload = FALSE;
        m_fLockAutoDownload = TRUE;
    }
    else
    {
        hr = DMUS_E_TYPE_UNSUPPORTED;
    }

    LeaveCriticalSection(&m_CrSec);

    return hr;
}

/*
  @method HRESULT | IDirectMusicTrack | AddNotificationType |
  Similar to and called from <om IDirectMusicSegment.AddNotificationType>. This
  gives the track a chance to respond to notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::AddNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to add.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | RemoveNotificationType |
  Similar to and called from <om IDirectMusicSegment.RemoveNotificationType>. This
  gives the track a chance to remove notifications.

  @rvalue E_NOTIMPL | The track doesn't support notifications.
  @rvalue S_OK | Success.
  @rvalue S_FALSE | The track doesn't support the requested notification type.
*/
HRESULT STDMETHODCALLTYPE CWavTrack::RemoveNotificationType(
     REFGUID rguidNotification) // @parm The notification guid to remove.
{
    return E_NOTIMPL;
}

/*
  @method HRESULT | IDirectMusicTrack | Clone |
  Creates a copy of the Track.

  @rvalue S_OK | Success.
  @rvalue E_OUTOFMEMORY | Out of memory.
  @rvalue E_POINTER | <p ppTrack> is NULL or invalid.

  @xref <om IDirectMusicSegment.Clone>
*/
HRESULT STDMETHODCALLTYPE CWavTrack::Clone(
    MUSIC_TIME mtStart, // @parm The start of the part to clone. It should be 0 or greater,
                        // and less than the length of the Track.
    MUSIC_TIME mtEnd,   // @parm The end of the part to clone. It should be greater than
                        // <p mtStart> and less than the length of the Track.
    IDirectMusicTrack** ppTrack)    // @parm Returns the cloned Track.
{
    V_INAME(IDirectMusicTrack::Clone);
    V_PTRPTR_WRITE(ppTrack);

    HRESULT hr = S_OK;

    if((mtStart < 0 )||(mtStart > mtEnd))
    {
        Trace(1,"Error: Wave track clone failed because of invalid start or end time.\n");
        return E_INVALIDARG;
    }

    EnterCriticalSection(&m_CrSec);
    CWavTrack *pDM;

    try
    {
        pDM = new CWavTrack(*this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

    if (pDM == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pDM->InitTrack(m_dwPChannelsUsed);
        if (SUCCEEDED(hr))
        {
            hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
        }
        pDM->Release();
    }

    LeaveCriticalSection(&m_CrSec);
    return hr;
}


STDMETHODIMP CWavTrack::Compose(
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

STDMETHODIMP CWavTrack::Join(
        IDirectMusicTrack* pNewTrack,
        MUSIC_TIME mtJoin,
        IUnknown* pContext,
        DWORD dwTrackGroup,
        IDirectMusicTrack** ppResultTrack)
{
    return E_NOTIMPL;
}

HRESULT CWavTrack::ComputeVariations(WaveStateData* pSD)
{
    if (!pSD)
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // First, initialize the array of variation groups.
    for (int i = 0; i < MAX_WAVE_VARIATION_LOCKS; i++)
    {
        pSD->adwVariationGroups[i] = 0;
    }
    // Now, compute the variations for each part.
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (i = 0; pScan && i < (int)m_dwPChannelsUsed; pScan = pScan->GetNext(), i++)
    {
        hr = ComputeVariation(i, pScan->GetItemValue(), pSD);
        if (FAILED(hr))
        {
            break;
        }
    }
    return hr;
}

HRESULT CWavTrack::SyncVariations(IDirectMusicPerformance* pPerf,
                                  WaveStateData* pSD,
                                  REFERENCE_TIME rtStart,
                                  REFERENCE_TIME rtOffset,
                                  BOOL fClockTime)
{
    if (!pSD)
    {
        Trace(1,"Error: Unable to play wave track - not initialized.\n");
        return DMUS_E_NOT_INIT;
    }
    HRESULT hr = S_OK;
    // Get the current variations
    DMUS_VARIATIONS_PARAM Variations;
    memset(&Variations, 0, sizeof(Variations));
    // Call GetParam for variations to sync to
    MUSIC_TIME mtNow = 0;
    MUSIC_TIME mtNext = 0;
    REFERENCE_TIME rtNext = 0;
    if (fClockTime)
    {
        pPerf->ReferenceToMusicTime(pSD->rtNextVariation + rtOffset, &mtNow);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr) &&
            SUCCEEDED(pPerf->MusicToReferenceTime(mtNext + mtNow, &rtNext)) )
        {
            pSD->rtNextVariation += rtNext;
        }
    }
    else
    {
        mtNow = (MUSIC_TIME) (pSD->rtNextVariation + rtOffset);
        hr = pPerf->GetParam(GUID_Variations, 0xffffffff, DMUS_SEG_ANYTRACK, mtNow, &mtNext, (void*) &Variations);
        if (SUCCEEDED(hr))
        {
            pSD->rtNextVariation += mtNext;
        }
    }
    if (SUCCEEDED(hr))
    {
        // Initialize the array of variation groups.
        for (int nGroup = 0; nGroup < MAX_WAVE_VARIATION_LOCKS; nGroup++)
        {
            pSD->adwVariationGroups[nGroup] = 0;
        }
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dwPart = 0; pScan && dwPart < m_dwPChannelsUsed; pScan = pScan->GetNext(), dwPart++)
        {
            WavePart& rPart = pScan->GetItemValue();
            for (DWORD dwSyncPart = 0; dwSyncPart < Variations.dwPChannelsUsed; dwSyncPart++)
            {
                if (rPart.m_dwPChannel == Variations.padwPChannels[dwSyncPart])
                {
                    pSD->pdwVariations[dwPart] = Variations.padwVariations[dwSyncPart];
                    break;
                }
            }
            if (dwSyncPart == Variations.dwPChannelsUsed) // no part to sync to
            {
                hr = ComputeVariation((int)dwPart, rPart, pSD);
                if (FAILED(hr))
                {
                    break;
                }
            }
        }
    }
    else
    {
        return ComputeVariations(pSD);
    }
    return hr;
}

HRESULT CWavTrack::ComputeVariation(int nPart, WavePart& rWavePart, WaveStateData* pSD)
{
    BYTE bLockID = (BYTE)rWavePart.m_dwLockToPart;
    if (bLockID && pSD->adwVariationGroups[bLockID - 1] != 0)
    {
        pSD->pdwVariations[nPart] = pSD->adwVariationGroups[bLockID - 1];
    }
    else if (!rWavePart.m_dwVariations)
    {
        // No variations; clear the flags for this part.
        pSD->pdwVariations[nPart] = 0;
        pSD->pdwRemoveVariations[nPart] = 0;
    }
    else
    {
        // First, collect all matches.
        DWORD dwMatches = rWavePart.m_dwVariations;
        int nMatchCount = 0;
        for (int n = 0; n < 32; n++)
        {
            if (dwMatches & (1 << n)) nMatchCount++;
        }
        // Now, select a variation based on the part's variation mode.
        BYTE bMode = (BYTE)(rWavePart.m_dwPChannelFlags & 0xf);
        DWORD dwTemp = dwMatches;
        if ( bMode == DMUS_VARIATIONT_RANDOM_ROW )
        {
            dwTemp &= ~pSD->pdwRemoveVariations[nPart];
            if (!dwTemp)
            {
                // start counting all over, but don't repeat this one
                pSD->pdwRemoveVariations[nPart] = 0;
                dwTemp = dwMatches;
                bMode = DMUS_VARIATIONT_NO_REPEAT;
            }
        }
        if ( bMode == DMUS_VARIATIONT_NO_REPEAT && pSD->pdwVariations[nPart] != 0 )
        {
            dwTemp &= ~pSD->pdwVariations[nPart];
        }
        if (dwTemp != dwMatches)
        {
            if (dwTemp) // otherwise, keep what we had
            {
                for (int i = 0; i < 32; i++)
                {
                    if ( ((1 << i) & dwMatches) && !((1 << i) & dwTemp) )
                    {
                        nMatchCount--;
                    }
                }
                dwMatches = dwTemp;
            }
        }
        int nV = 0;
        switch (bMode)
        {
        case DMUS_VARIATIONT_RANDOM_ROW:
        case DMUS_VARIATIONT_NO_REPEAT:
        case DMUS_VARIATIONT_RANDOM:
            {
                short nChoice = (short) (rand() % nMatchCount);
                short nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nChoice == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
                if (bMode == DMUS_VARIATIONT_RANDOM_ROW)
                {
                    pSD->pdwRemoveVariations[nPart] |= pSD->pdwVariations[nPart];
                }
                TraceI(3, "New variation: %d\n", nV);
                break;
            }
        case DMUS_VARIATIONT_RANDOM_START:
            // Choose an initial value
            if (pSD->pdwVariations[nPart] == 0)
            {
                int nStart = 0;
                nStart = (BYTE) (rand() % nMatchCount);
                int nCount = 0;
                for (nV = 0; nV < 32; nV++)
                {
                    if ((1 << nV) & dwMatches)
                    {
                        if (nStart == nCount)
                            break;
                        nCount++;
                    }
                }
                pSD->pdwVariations[nPart] = 1 << nV;
            }
            // Now, go directly to the sequential case (no break)
        case DMUS_VARIATIONT_SEQUENTIAL:
            {
                if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                else
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                while (!(pSD->pdwVariations[nPart] & dwMatches))
                {
                    pSD->pdwVariations[nPart] <<= 1;
                    if (!pSD->pdwVariations[nPart]) pSD->pdwVariations[nPart] = 1;
                }
                TraceI(3, "New variation: %d\n", pSD->pdwVariations[nPart]);
                break;
            }
        }
        // If this is a locked variation, it's the first in its group, so record it.
        if (bLockID)
        {
            pSD->adwVariationGroups[bLockID - 1] = pSD->pdwVariations[nPart];
        }
        if ( (m_dwTrackFlags & DMUS_WAVETRACKF_PERSIST_CONTROL) &&
             m_pdwVariations &&
             m_pdwRemoveVariations )
        {
            m_pdwVariations[nPart] = pSD->pdwVariations[nPart];
            m_pdwRemoveVariations[nPart] = pSD->pdwRemoveVariations[nPart];
        }
    }
    return S_OK;
}

// Sets the variations to be played for a part.  All other parts use the MOAW
// to determine which variation plays.
HRESULT CWavTrack::SetVariation(
            IDirectMusicSegmentState* pSegState, DWORD dwVariationFlags, DWORD dwPart, DWORD dwIndex)
{
    WaveStateData* pState = NULL;
    EnterCriticalSection( &m_CrSec );
    m_dwVariation = dwVariationFlags;
    m_dwPart = dwPart;
    m_dwIndex = dwIndex;
    m_fAudition = TRUE;
    TListItem<WavePart>* pScan = m_WavePartList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WavePart& rScan = pScan->GetItemValue();
        if (rScan.m_dwPChannel == dwPart && rScan.m_dwIndex == dwIndex)
        {
            m_dwLockID = rScan.m_dwLockToPart;
        }
    }
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(dwVariationFlags, dwPart, dwIndex, m_dwLockID, m_fAudition);
    }
    LeaveCriticalSection( &m_CrSec );

    return S_OK;
}

// Clears the variations to be played for a part, so that all parts use the MOAW.
HRESULT CWavTrack::ClearVariations(IDirectMusicSegmentState* pSegState)
{
    WaveStateData* pState = NULL;
    EnterCriticalSection( &m_CrSec );
    m_dwVariation = 0;
    m_dwPart = 0;
    m_dwIndex = 0;
    m_dwLockID = 0;
    m_fAudition = FALSE;
    pState = FindState(pSegState);
    if (pState)
    {
        pState->InitVariationInfo(0, 0, 0, 0, m_fAudition);
    }
    LeaveCriticalSection( &m_CrSec );

    return S_OK;
}

WaveStateData* CWavTrack::FindState(IDirectMusicSegmentState* pSegState)
{
    TListItem<StatePair>* pPair = m_StateList.GetHead();
    for (; pPair; pPair = pPair->GetNext())
    {
        if (pPair->GetItemValue().m_pSegState == pSegState)
        {
            return pPair->GetItemValue().m_pStateData;
        }
    }
    return NULL;
}

// Adds a wave at mtTime to part dwIndex on PChannel dwPChannel
// If there was already a wave there, the two will co-exist
HRESULT CWavTrack::AddWave(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    EnterCriticalSection(&m_CrSec);
    HRESULT hr = S_OK;
    m_lVolume = 0;
    m_dwTrackFlags = 0;
    TListItem<WavePart>* pNewPart = new TListItem<WavePart>;
    if( !pNewPart )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewPart->GetItemValue().Add(pWave, rtTime, dwPChannel, dwIndex, prtLength);
    if( FAILED ( hr ) )
    {
        delete pNewPart;
        goto ON_ERROR;
    }
    InsertByAscendingPChannel( pNewPart );
    m_dwWaveItems = 0;
    m_dwPChannelsUsed = m_WavePartList.GetCount();
    if (m_aPChannels)
    {
        delete [] m_aPChannels;
        m_aPChannels = NULL;
    }
    m_aPChannels = new DWORD[m_dwPChannelsUsed];
    if (m_aPChannels)
    {
        TListItem<WavePart>* pScan = m_WavePartList.GetHead();
        for (DWORD dw = 0; pScan && dw < m_dwPChannelsUsed; pScan = pScan->GetNext(), dw++)
        {
            m_aPChannels[dw] = pScan->GetItemValue().m_dwPChannel;
            TListItem<WaveItem>* pItemScan = pScan->GetItemValue().m_WaveItemList.GetHead();
            for (; pItemScan; pItemScan = pItemScan->GetNext())
            {
                pItemScan->GetItemValue().m_dwVoiceIndex = m_dwWaveItems;
                m_dwWaveItems++;
            }
        }
    }
    else
    {
        CleanUp();
        hr = E_OUTOFMEMORY;
    }
ON_ERROR:
    LeaveCriticalSection(&m_CrSec);
    return hr;
}

HRESULT CWavTrack::DownloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::DownloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);
    V_REFGUID(rguidVersion);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, download is only partial.
            if (pPart->GetItemValue().Download(pPerf, pPath, pWave, rguidVersion) != S_OK)
            {
                Trace(1,"Error: Wave download was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::UnloadWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk)
{
    V_INAME(CWavTrack::UnloadWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, unload is only partial.
            if (pPart->GetItemValue().Unload(pPerf, pPath, pWave) != S_OK)
            {
                Trace(1,"Error: Wavetrack unload was only partially successful.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::RefreshWave(
        IDirectSoundWave* pWave,
        IUnknown* pUnk,
        DWORD dwPChannel,
        REFGUID rguidVersion)
{
    V_INAME(CWavTrack::RefreshWave);
    V_INTERFACE_OPT(pWave);
    V_INTERFACE(pUnk);

    IDirectMusicAudioPath* pPath = NULL;
    IDirectMusicPerformance *pPerf = NULL;
    HRESULT hr = pUnk->QueryInterface(IID_IDirectMusicAudioPath,(void **)&pPath);
    if (SUCCEEDED(hr))
    {
        hr = pPath->GetObjectInPath(0,DMUS_PATH_PERFORMANCE,0,CLSID_DirectMusicPerformance,0,IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    else
    {
        hr = pUnk->QueryInterface(IID_IDirectMusicPerformance,(void **)&pPerf);
    }
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&m_CrSec);
        TListItem<WavePart>* pPart = m_WavePartList.GetHead();
        for(; pPart; pPart = pPart->GetNext())
        {
            // If not S_OK, refresh is only partial.
            if (pPart->GetItemValue().Refresh(pPerf, pPath, pWave, dwPChannel, rguidVersion) != S_OK)
            {
                Trace(1,"Error: Wavetrack refresh was only partially successful. Some sounds will not play.\n");
                hr = S_FALSE;
            }
        }
        LeaveCriticalSection(&m_CrSec);
    }
    if (pPath) pPath->Release();
    if (pPerf) pPerf->Release();
    return hr;
}

HRESULT CWavTrack::FlushAllWaves()
{
    FlushWaves();
    return S_OK;
}

HRESULT CWavTrack::OnVoiceEnd(IDirectMusicVoiceP *pVoice, void *pStateData)
{
    HRESULT hr = S_OK;
    if( pStateData && pVoice )
    {
        EnterCriticalSection(&m_CrSec);

        WaveStateData* pSD = (WaveStateData*)pStateData;
        TListItem<WaveDLOnPlay>* pWDLOnPlay = pSD->m_WaveDLList.GetHead();
        TListItem<WaveDLOnPlay>* pWDLNext = NULL;
        for (; pWDLOnPlay; pWDLOnPlay = pWDLNext)
        {
            pWDLNext = pWDLOnPlay->GetNext();
            if (pWDLOnPlay->GetItemValue().m_pVoice == pVoice)
            {
                pSD->m_WaveDLList.Remove(pWDLOnPlay);
                delete pWDLOnPlay;
                break;
            }
        }

        LeaveCriticalSection(&m_CrSec);
    }
    else
    {
        hr = E_POINTER;
    }
    return hr;
}

////////////////////////////////////////////////////////////////////
// WavePart

HRESULT WavePart::Load( IDMStream* pIRiffStream, MMCKINFO* pckParent )
{
    MMCKINFO        ck;
    MMCKINFO        ckList;
    DWORD           dwByteCount;
    DWORD           dwSize;
    HRESULT         hr = E_FAIL;

    // LoadPChannel does not expect to be called twice on the same object!

    if( pIRiffStream == NULL ||  pckParent == NULL )
    {
        ASSERT( 0 );
        return DMUS_E_CANNOTREAD;
    }

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    // Load the PChannel
    while( pIRiffStream->Descend( &ck, pckParent, 0 ) == S_OK )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_WAVEPART_CHUNK:
            {
                DMUS_IO_WAVE_PART_HEADER iPartHeader;
                memset(&iPartHeader, 0, sizeof(iPartHeader));

                // Read in the item's header structure
                dwSize = min( sizeof( DMUS_IO_WAVE_PART_HEADER ), ck.cksize );
                hr = pIStream->Read( &iPartHeader, dwSize, &dwByteCount );

                // Handle any I/O error by returning a failure code
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1,"Error: Unable to read wave track - bad file.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_ERROR;
                }

                m_dwPChannel = iPartHeader.dwPChannel;
                m_dwIndex = iPartHeader.dwIndex;

                m_lVolume = iPartHeader.lVolume;
                m_dwLockToPart = iPartHeader.dwLockToPart;
                m_dwPChannelFlags = iPartHeader.dwFlags;
                m_dwVariations = iPartHeader.dwVariations;
                break;
            }

            case FOURCC_LIST:
                switch( ck.fccType )
                {
                    case DMUS_FOURCC_WAVEITEM_LIST:
                        while( pIRiffStream->Descend( &ckList, &ck, 0 ) == S_OK )
                        {
                            switch( ckList.ckid )
                            {
                                case FOURCC_LIST:
                                    switch( ckList.fccType )
                                    {
                                        case DMUS_FOURCC_WAVE_LIST:
                                        {
                                            TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
                                            if( pNewItem == NULL )
                                            {
                                                hr = E_OUTOFMEMORY;
                                                goto ON_ERROR;
                                            }
                                            hr = pNewItem->GetItemValue().Load( pIRiffStream, &ckList );
                                            if( FAILED ( hr ) )
                                            {
                                                delete pNewItem;
                                                goto ON_ERROR;
                                            }
                                            m_WaveItemList.AddHead( pNewItem );
                                            //InsertByAscendingTime( pNewItem );
                                            break;
                                        }
                                    }
                            }

                            pIRiffStream->Ascend( &ckList, 0 );
                        }
                        break;
                }
                break;
        }

        // Ascend out of the chunk
        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}

void WavePart::CleanUp()
{
    TListItem<WaveItem>* pScan = m_WaveItemList.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        pScan->GetItemValue().CleanUp();
    }
    m_WaveItemList.CleanUp();
}

HRESULT WavePart::CopyItems( const TList<WaveItem>& rItems, MUSIC_TIME mtStart, MUSIC_TIME mtEnd )
{
    HRESULT hr = S_OK;
    CleanUp();
    TListItem<WaveItem>* pScan = rItems.GetHead();
    for (; pScan; pScan = pScan->GetNext() )
    {
        WaveItem& rScan = pScan->GetItemValue();
        if (mtStart <= (MUSIC_TIME) rScan.m_rtTimePhysical &&
            (!mtEnd || (MUSIC_TIME) rScan.m_rtTimePhysical < mtEnd) )
        {
            TListItem<WaveItem>* pNew = new TListItem<WaveItem>;
            if (pNew)
            {
                WaveItem& rNew = pNew->GetItemValue();
                rNew.m_rtTimePhysical = rScan.m_rtTimePhysical - mtStart;
                rNew.m_lVolume = rScan.m_lVolume;
                rNew.m_lPitch = rScan.m_lPitch;
                rNew.m_dwVariations = rScan.m_dwVariations;
                rNew.m_rtStartOffset = rScan.m_rtStartOffset;
                rNew.m_rtDuration = rScan.m_rtDuration;
                rNew.m_mtTimeLogical = rScan.m_mtTimeLogical;
                rNew.m_dwFlags = rScan.m_dwFlags;
                rNew.m_pWave = rScan.m_pWave;
                rNew.m_dwLoopStart = rScan.m_dwLoopStart;
                rNew.m_dwLoopEnd = rScan.m_dwLoopEnd;
                rNew.m_fIsStreaming = rScan.m_fIsStreaming;
                if (rNew.m_pWave)
                {
                    rNew.m_pWave->AddRef();
                }
                if (SUCCEEDED(hr))
                {
                    m_WaveItemList.AddHead(pNew);
                }
                else
                {
                    delete pNew;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        m_WaveItemList.Reverse();
    }
    else
    {
        CleanUp();
    }
    return hr;
}

HRESULT WavePart::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Download(pPerformance, pPath, m_dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep downloading)
        }
    }
    return hr;
}

HRESULT WavePart::Unload(IDirectMusicPerformance* pPerformance, IDirectMusicAudioPath* pPath, IDirectSoundWave* pWave)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Unload(pPerformance, pPath, m_dwPChannel, pWave);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep unloading)
        }
    }
    return hr;
}

HRESULT WavePart::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          IDirectSoundWave* pWave,
                          DWORD dwPChannel,
                          REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    TListItem<WaveItem>* pItem = m_WaveItemList.GetHead();
    for(; pItem; pItem = pItem->GetNext())
    {
        HRESULT hrItem = pItem->GetItemValue().Refresh(pPerformance, pPath, m_dwPChannel, dwPChannel, pWave, rguidVersion);
        if (hrItem != S_OK)
        {
            hr = hrItem; // if any attempt failed, return the failure (but keep refreshing)
        }
    }
    return hr;
}

HRESULT WavePart::Add(
        IDirectSoundWave* pWave,
        REFERENCE_TIME rtTime,
        DWORD dwPChannel,
        DWORD dwIndex,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    m_dwPChannel = dwPChannel;
    m_dwIndex = dwIndex;

    m_lVolume = 0;
    m_dwLockToPart = 0;
    m_dwPChannelFlags = 0;
    m_dwVariations = 0xffffffff;

    TListItem<WaveItem>* pNewItem = new TListItem<WaveItem>;
    if( pNewItem == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto ON_ERROR;
    }
    hr = pNewItem->GetItemValue().Add( pWave, rtTime, prtLength );
    if( FAILED ( hr ) )
    {
        delete pNewItem;
        goto ON_ERROR;
    }
    m_WaveItemList.AddHead( pNewItem );
ON_ERROR:
    return hr;
}

////////////////////////////////////////////////////////////////////
// WaveItem

HRESULT WaveItem::Load( IDMStream* pIRiffStream, MMCKINFO* pckParent )
{
    MMCKINFO        ck;
    DWORD           dwByteCount;
    DWORD           dwSize;
    HRESULT         hr = E_FAIL;

    // LoadListItem does not expect to be called twice on the same object
    // Code assumes item consists of initial values
    ASSERT( m_rtTimePhysical == 0 );

    if( pIRiffStream == NULL ||  pckParent == NULL )
    {
        ASSERT( 0 );
        return DMUS_E_CANNOTREAD;
    }

    IStream* pIStream = pIRiffStream->GetStream();
    ASSERT( pIStream != NULL );

    // Load the track item
    while( pIRiffStream->Descend( &ck, pckParent, 0 ) == S_OK )
    {
        switch( ck.ckid )
        {
            case DMUS_FOURCC_WAVEITEM_CHUNK:
            {
                DMUS_IO_WAVE_ITEM_HEADER iItemHeader;

                // Read in the item's header structure
                dwSize = min( sizeof( DMUS_IO_WAVE_ITEM_HEADER ), ck.cksize );
                hr = pIStream->Read( &iItemHeader, dwSize, &dwByteCount );

                // Handle any I/O error by returning a failure code
                if( FAILED( hr ) ||  dwByteCount != dwSize )
                {
                    Trace(1,"Error: Unable to read wave track - bad file.\n");
                    if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
                    goto ON_ERROR;
                }

                m_lVolume = iItemHeader.lVolume;
                m_lPitch = iItemHeader.lPitch;
                m_dwVariations = iItemHeader.dwVariations;
                m_rtTimePhysical = iItemHeader.rtTime;
                m_rtStartOffset = iItemHeader.rtStartOffset;
                m_rtDuration = iItemHeader.rtDuration;
                m_mtTimeLogical = iItemHeader.mtLogicalTime;
                m_dwFlags = iItemHeader.dwFlags;
                m_dwLoopStart = iItemHeader.dwLoopStart;
                m_dwLoopEnd = iItemHeader.dwLoopEnd;
                if (m_dwLoopEnd) m_dwLoopEnd++; // fix for bug 38505
                break;
            }

            case FOURCC_LIST:
                if( ck.fccType == DMUS_FOURCC_REF_LIST )
                {
                    hr = LoadReference( pIStream, pIRiffStream, ck );
                }
                break;
        }

        // Ascend out of the chunk
        pIRiffStream->Ascend( &ck, 0 );
    }

ON_ERROR:
    RELEASE( pIStream );
    return hr;
}

HRESULT WaveItem::LoadReference(IStream *pStream,
                                         IDMStream *pIRiffStream,
                                         MMCKINFO& ckParent)
{
    if (!pStream || !pIRiffStream) return E_INVALIDARG;

    IDirectSoundWave* pWave;
    IDirectMusicLoader* pLoader = NULL;
    IDirectMusicGetLoader *pIGetLoader;
    HRESULT hr = pStream->QueryInterface( IID_IDirectMusicGetLoader,(void **) &pIGetLoader );
    if (FAILED(hr)) return hr;
    hr = pIGetLoader->GetLoader(&pLoader);
    pIGetLoader->Release();
    if (FAILED(hr)) return hr;

    DMUS_OBJECTDESC desc;
    ZeroMemory(&desc, sizeof(desc));

    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;

    while( pIRiffStream->Descend( &ckNext, &ckParent, 0 ) == S_OK )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.guidClass = ioDMRef.guidClassID;
                    desc.dwValidData |= ioDMRef.dwValidData;
                    desc.dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(desc.guidObject), sizeof(GUID), NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(desc.ftDate), sizeof(FILETIME), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.dwValidData |=  DMUS_OBJ_DATE;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(desc.wszName), ckNext.cksize);
                hr = pStream->Read(desc.wszName, dwSize, NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.wszName[DMUS_MAX_NAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(desc.wszFileName), ckNext.cksize);
                hr = pStream->Read(desc.wszFileName, dwSize, NULL);
                if(SUCCEEDED(hr))
                {
                    desc.wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(desc.wszCategory), ckNext.cksize);
                hr = pStream->Read(desc.wszCategory, dwSize, NULL);
                if(SUCCEEDED(hr) )
                {
                    desc.wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    desc.dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), NULL);
                if(SUCCEEDED(hr))
                {
                    desc.vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    desc.vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    desc.dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            default:
                break;
        }

        if(SUCCEEDED(hr) && pIRiffStream->Ascend(&ckNext, 0) == S_OK)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
    }

    if (!(desc.dwValidData &  DMUS_OBJ_NAME) &&
        !(desc.dwValidData &  DMUS_OBJ_FILENAME) &&
        !(desc.dwValidData &  DMUS_OBJ_OBJECT) )
    {
        Trace(1,"Error: Wave track is unable to reference a wave because it doesn't have any valid reference information.\n");
        hr = DMUS_E_CANNOTREAD;
    }
    if(SUCCEEDED(hr))
    {
        desc.dwSize = sizeof(DMUS_OBJECTDESC);
        hr = pLoader->GetObject(&desc, IID_IDirectSoundWave, (void**)&pWave);
        if (SUCCEEDED(hr))
        {
            if (m_pWave) m_pWave->Release();
            m_pWave = pWave; // no need to AddRef; GetObject did that
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
    }

    if (pLoader)
    {
        pLoader->Release();
    }
    return hr;
}

HRESULT WaveItem::Download(IDirectMusicPerformance* pPerformance,
                           IDirectMusicAudioPath* pPath,
                           DWORD dwPChannel,
                           IDirectSoundWave* pWave,
                           REFGUID rguidVersion)
{
    HRESULT hr = S_OK;
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if ( rDLWave.m_pWave == m_pWave &&
                         rDLWave.m_pPerformance == pPerformance &&
                         rDLWave.m_pPort == pPortP &&
                         ( !m_fIsStreaming ||
                           rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        break;
                    }
                }
                // only download the wave if:
                // 1) it hasn't already been downloaded to the port, or
                // 2) its version doesn't match the currently downloaded version.
                if (!pDLWave)
                {
                    pDLWave = new TListItem<TaggedWave>;
                    if (!pDLWave)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        TaggedWave& rDLWave = pDLWave->GetItemValue();
                        hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                        if (SUCCEEDED(hr))
                        {
                            rDLWave.m_pPort = pPortP;
                            rDLWave.m_pPort->AddRef();
                            rDLWave.m_pPerformance = pPerformance;
                            rDLWave.m_pPerformance->AddRef();
                            rDLWave.m_pWave = m_pWave;
                            rDLWave.m_pWave->AddRef();
                            rDLWave.m_lRefCount = 1;
                            rDLWave.m_guidVersion = rguidVersion;
                            st_WaveList.AddHead(pDLWave);
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                            }
                            if(m_fIsStreaming)
                            {
                                m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                                m_pDownloadedWave->AddRef();
                            }
                        }
                        else
                        {
                            delete pDLWave;
                        }
                    }
                }
                else if (rguidVersion != pDLWave->GetItemValue().m_guidVersion)
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pDownloadedWave)
                    {
                        pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                        rDLWave.m_pDownloadedWave = NULL;
                    }
                    if (rDLWave.m_pPort)
                    {
                        rDLWave.m_pPort->Release();
                        rDLWave.m_pPort = NULL;
                    }
                    if (rDLWave.m_pPerformance)
                    {
                        rDLWave.m_pPerformance->Release();
                        rDLWave.m_pPerformance = NULL;
                    }
                    hr = pPortP->DownloadWave( m_pWave, &(rDLWave.m_pDownloadedWave), m_rtStartOffset );
                    if (SUCCEEDED(hr))
                    {
                        rDLWave.m_pPort = pPortP;
                        rDLWave.m_pPort->AddRef();
                        rDLWave.m_pPerformance = pPerformance;
                        rDLWave.m_pPerformance->AddRef();
                        rDLWave.m_lRefCount = 1;
                        rDLWave.m_guidVersion = rguidVersion;
                        if (m_pDownloadedWave)
                        {
                            m_pDownloadedWave->Release();
                        }

                        if(m_fIsStreaming)
                        {
                            m_pDownloadedWave = rDLWave.m_pDownloadedWave;
                            m_pDownloadedWave->AddRef();
                        }
                    }
                    else
                    {
                        if (rDLWave.m_pWave)
                        {
                            rDLWave.m_pWave->Release();
                            rDLWave.m_pWave = NULL;
                        }
                        st_WaveList.Remove(pDLWave);
                        delete pDLWave;
                    }
                }
                else // keep track of this, but return S_FALSE (indicates wave wasn't downloaded)
                {
                    pDLWave->GetItemValue().m_lRefCount++;
                    hr = S_FALSE;
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for download.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }
    else
    {
        Trace(1,"Error: Wavetrack download failed, initialization error.\n");
        hr = DMUS_E_NOT_INIT;
    }

    return hr;
}

HRESULT WaveItem::Unload(IDirectMusicPerformance* pPerformance,
                         IDirectMusicAudioPath* pPath,
                         DWORD dwPChannel,
                         IDirectSoundWave* pWave)
{
    IDirectMusicPort* pPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    if (m_pWave && (!pWave || pWave == m_pWave))
    {
        hr = PChannelInfo(pPerformance, pPath, dwPChannel, &pPort, &dwGroup, &dwMChannel);
        if (SUCCEEDED(hr) && pPort)
        {
            IDirectMusicPortP* pPortP = NULL;
            if (SUCCEEDED(hr = pPort->QueryInterface(IID_IDirectMusicPortP, (void**) &pPortP)))
            {
                EnterCriticalSection(&WaveItem::st_WaveListCritSect);
                TListItem<TaggedWave>* pDLWave = st_WaveList.GetHead();
                for (; pDLWave; pDLWave = pDLWave->GetNext())
                {
                    TaggedWave& rDLWave = pDLWave->GetItemValue();
                    if (rDLWave.m_pWave == m_pWave &&
                        rDLWave.m_pPerformance == pPerformance &&
                        rDLWave.m_pPort == pPortP &&
                        ( !m_fIsStreaming ||
                          rDLWave.m_pDownloadedWave == m_pDownloadedWave ) )
                    {
                        rDLWave.m_lRefCount--;
                        if (rDLWave.m_lRefCount <= 0)
                        {
                            if (rDLWave.m_pWave)
                            {
                                rDLWave.m_pWave->Release();
                                rDLWave.m_pWave = NULL;
                            }
                            if (rDLWave.m_pPort)
                            {
                                rDLWave.m_pPort->Release();
                                rDLWave.m_pPort = NULL;
                            }
                            if (rDLWave.m_pPerformance)
                            {
                                rDLWave.m_pPerformance->Release();
                                rDLWave.m_pPerformance = NULL;
                            }
                            if (rDLWave.m_pDownloadedWave)
                            {
                                pPortP->UnloadWave(rDLWave.m_pDownloadedWave);
                                rDLWave.m_pDownloadedWave = NULL;
                            }
                            if (m_pDownloadedWave)
                            {
                                m_pDownloadedWave->Release();
                                m_pDownloadedWave = NULL;
                            }
                            st_WaveList.Remove(pDLWave);
                            delete pDLWave;
                        }
                        else
                        {
                            hr = S_FALSE; // indicates wave wasn't actually unloaded
                        }
                        break;
                    }
                }
                LeaveCriticalSection(&WaveItem::st_WaveListCritSect);

                pPortP->Release();
            }
            pPort->Release();
        }
        else if (SUCCEEDED(hr) && !pPort)
        {
            Trace(1, "Error: the performance was unable to find a port for unload.\n");
            hr = DMUS_E_NOT_FOUND;
        }
    }

    return hr;
}

HRESULT WaveItem::Refresh(IDirectMusicPerformance* pPerformance,
                          IDirectMusicAudioPath* pPath,
                          DWORD dwOldPChannel,
                          DWORD dwNewPChannel,
                          IDirectSoundWave* pWave,
                          REFGUID rguidVersion)
{
    IDirectMusicPort* pOldPort = NULL;
    IDirectMusicPort* pNewPort = NULL;
    DWORD dwGroup = 0;
    DWORD dwMChannel = 0;
    HRESULT hr = S_OK;
    hr = PChannelInfo(pPerformance, pPath, dwOldPChannel, &pOldPort, &dwGroup, &dwMChannel);
    if (SUCCEEDED(hr))
    {
        hr = PChannelInfo(pPerformance, pPath, dwNewPChannel, &pNewPort, &dwGroup, &dwMChannel);
    }
    if (SUCCEEDED(hr))
    {
        // if the old port and new port are different, unload the wave from the old port
        // and download to the new one.
        if (pOldPort != pNewPort)
        {
            Unload(pPerformance, pPath, dwOldPChannel, pWave);
            hr = Download(pPerformance, pPath, dwNewPChannel, pWave, rguidVersion);
        }
    }
    if (pOldPort) pOldPort->Release();
    if (pNewPort) pNewPort->Release();
    return hr;
}

HRESULT WaveItem::PChannelInfo(
    IDirectMusicPerformance* pPerformance,
    IDirectMusicAudioPath* pAudioPath,
    DWORD dwPChannel,
    IDirectMusicPort** ppPort,
    DWORD* pdwGroup,
    DWORD* pdwMChannel)
{
    HRESULT hr = S_OK;
    DWORD dwConvertedPChannel = dwPChannel;
    if (pAudioPath)
    {
        hr = pAudioPath->ConvertPChannel(dwPChannel, &dwConvertedPChannel);
    }
    if (SUCCEEDED(hr))
    {
        hr = pPerformance->PChannelInfo(dwConvertedPChannel, ppPort, pdwGroup, pdwMChannel);
    }
    return hr;
}

void WaveItem::CleanUp()
{
    if (m_pWave)
    {
        m_pWave->Release();
        m_pWave = NULL;
    }
    if (m_pDownloadedWave)
    {
        m_pDownloadedWave->Release();
        m_pDownloadedWave = NULL;
    }
}

HRESULT WaveItem::Add(IDirectSoundWave* pWave, REFERENCE_TIME rtTime,
        REFERENCE_TIME* prtLength)
{
    HRESULT hr = S_OK;
    IPrivateWave* pPrivWave = NULL;
    *prtLength = 0; // in case GetLength fails...
    REFERENCE_TIME rtLength = 0;
    m_rtDuration = 0;
    if (SUCCEEDED(hr = pWave->QueryInterface(IID_IPrivateWave, (void**)&pPrivWave)))
    {
        if (SUCCEEDED(hr = pPrivWave->GetLength(&rtLength)))
        {
            // Assumes the track is clock time
            m_rtDuration = rtLength * REF_PER_MIL;
            *prtLength = rtLength; // NOTE: length in milliseconds; duration in Ref time
        }
        pPrivWave->Release();
    }
    if (SUCCEEDED(hr))
    {
        m_lVolume = 0;
        m_lPitch = 0;
        m_dwVariations = 0xffffffff;
        m_rtTimePhysical = rtTime;
        m_rtStartOffset = 0;
        m_mtTimeLogical = 0;
        m_dwFlags = 0;
        m_dwLoopStart = 0;
        m_dwLoopEnd = 0;
        if (m_pWave)
        {
            m_pWave->Release();
            m_pWave = NULL;
        }
        m_pWave = pWave;
        if (m_pWave)
        {
            m_pWave->AddRef();
            REFERENCE_TIME rtReadAhead = 0;
            DWORD dwFlags = 0;
            m_pWave->GetStreamingParms(&dwFlags, &rtReadAhead);
            m_fIsStreaming = dwFlags & DMUS_WAVEF_STREAMING ? TRUE : FALSE;
            m_fUseNoPreRoll = dwFlags & DMUS_WAVEF_NOPREROLL ? TRUE : FALSE;
        }
        if (m_pDownloadedWave)
        {
            m_pDownloadedWave->Release();
        }
        m_pDownloadedWave = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\tsigtrk.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
// TimeSigTrk.cpp : Implementation of CTimeSigTrack

#include "dmime.h"
#include "TSigTrk.h"
#include "dmusici.h"
#include "dmusicf.h"
#include "debug.h"
#include "..\shared\dmstrm.h"
#include "..\shared\Validate.h"
#include "debug.h"
#define ASSERT	assert

CTimeSigItem::CTimeSigItem()

{ 
    m_TimeSig.lTime = 0;
    m_TimeSig.bBeatsPerMeasure = 0; 
    m_TimeSig.bBeat = 0;
    m_TimeSig.wGridsPerBeat = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CTimeSigTrack

void CTimeSigTrack::Construct()
{
	InterlockedIncrement(&g_cComponent);

	m_cRef = 1;
    m_fCSInitialized = FALSE;
	InitializeCriticalSection(&m_CrSec);
    m_fCSInitialized = TRUE;
	m_dwValidate = 0;
	m_fNotificationMeasureBeat = FALSE;
}

CTimeSigTrack::CTimeSigTrack()
{
	Construct();
	m_fActive = TRUE;
    m_fStateSetBySetParam = FALSE;
}

CTimeSigTrack::CTimeSigTrack(
		CTimeSigTrack *pSourceTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd)
{
	Construct();
	m_fActive = pSourceTrack->m_fActive;
    m_fStateSetBySetParam = pSourceTrack->m_fStateSetBySetParam;
    // Clone the time signature list.
	CTimeSigItem* pScan = pSourceTrack->m_TSigEventList.GetHead();
	CTimeSigItem* pPrevious = NULL;
	for(; pScan; pScan = pScan->GetNext())
	{
		if (pScan->m_TimeSig.lTime < mtStart)
		{
			pPrevious = pScan;
		}
		else if (pScan->m_TimeSig.lTime < mtEnd)
		{
			if (pScan->m_TimeSig.lTime == mtStart)
			{
				pPrevious = NULL;
			}
			CTimeSigItem* pNew = new CTimeSigItem;
			if (pNew)
			{
				pNew->m_TimeSig = pScan->m_TimeSig;
				pNew->m_TimeSig.lTime = pScan->m_TimeSig.lTime - mtStart;
				m_TSigEventList.AddHead(pNew); // instead of AddTail, which is n^2. We reverse below.
			}
		}
		else break;
	}
	m_TSigEventList.Reverse(); // Now, put list in order.
    // Then, install the time signature that precedes the clone.
	if (pPrevious)
	{
		CTimeSigItem* pNew = new CTimeSigItem;
		if (pNew)
		{
			pNew->m_TimeSig = pPrevious->m_TimeSig;
			pNew->m_TimeSig.lTime = 0;
			m_TSigEventList.AddHead(pNew);
		}
	}
}

void CTimeSigTrack::Clear()

{
    CTimeSigItem* pItem;
	while( pItem = m_TSigEventList.RemoveHead() )
	{
		delete pItem;
	}
}

CTimeSigTrack::~CTimeSigTrack()
{
    Clear();
    if (m_fCSInitialized)
    {
	    DeleteCriticalSection(&m_CrSec);
    }
	InterlockedDecrement(&g_cComponent);
}

// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | QueryInterface | Standard QueryInterface implementation for <i IDirectMusicTimeSigTrack>
//
// @parm const IID & | iid | Interface to query for
// @parm void ** | ppv | The requested interface will be returned here
//
// @rdesc Returns one of the following:
//
// @flag S_OK | If the interface is supported and was returned
// @flag E_NOINTERFACE | If the object does not support the given interface.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP CTimeSigTrack::QueryInterface(
    const IID &iid,   // @parm Interface to query for
    void **ppv)       // @parm The requested interface will be returned here
{
	V_INAME(CTimeSigTrack::QueryInterface);
	V_PTRPTR_WRITE(ppv);
	V_REFGUID(iid);

   if (iid == IID_IUnknown || iid == IID_IDirectMusicTrack)
    {
        *ppv = static_cast<IDirectMusicTrack*>(this);
    } else
	if (iid == IID_IPersistStream)
	{
        *ppv = static_cast<IPersistStream*>(this);
	} else
    {
        *ppv = NULL;
        Trace(4,"Warning: Request to query unknown interface on Time Signature Track\n");
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | AddRef | Standard AddRef implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


// @method:(EXTERNAL) HRESULT | IDirectMusicTimeSigTrack | Release | Standard Release implementation for <i IDirectMusicTimeSigTrack>
//
// @rdesc Returns the new reference count for this object.
//
// @mfunc:(INTERNAL)
//
//
STDMETHODIMP_(ULONG) CTimeSigTrack::Release()
{
    if (!InterlockedDecrement(&m_cRef))
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CTimeSigTrack::GetClassID( CLSID* pClassID )
{
	V_INAME(CTimeSigTrack::GetClassID);
	V_PTR_WRITE(pClassID, CLSID); 
	*pClassID = CLSID_DirectMusicTimeSigTrack;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CTimeSigTrack::IsDirty()
{
	return S_FALSE;
}

/*

  @method HRESULT | ITimeSigTrack | Load |
  Call this with an IStream filled with DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order.
  @parm IStream* | pIStream |
  A stream of DMUS_IO_TIMESIGNATURE_ITEM's, sorted in time order. The seek pointer should be
  set to the first event. The stream should only contain TimeSig events and
  nothing more.
  @rvalue E_INVALIDARG | If pIStream == NULL
  @rvalue S_OK
  @comm The <p pIStream> will be AddRef'd inside this function and held
  until the TimeSigTrack is released.
*/

HRESULT CTimeSigTrack::Load( IStream* pIStream )
{
	V_INAME(CTimeSigTrack::Load);
	V_INTERFACE(pIStream);

    CRiffParser Parser(pIStream);
	EnterCriticalSection(&m_CrSec);
	m_dwValidate++; // used to validate state data that's out there
    RIFFIO ckMain;

    HRESULT hr = S_OK;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr))
    { 
 		if (ckMain.ckid == DMUS_FOURCC_TIMESIG_CHUNK)
        {
            hr = LoadTimeSigList(&Parser,ckMain.cksize);
        }
        else if ((ckMain.ckid == FOURCC_LIST) && 
            (ckMain.fccType == DMUS_FOURCC_TIMESIGTRACK_LIST))
        {
            Clear();
	        RIFFIO ckNext;    // Descends into the children chunks.
            Parser.EnterList(&ckNext);
            while (Parser.NextChunk(&hr))
            {
		        switch(ckNext.ckid)
		        {
                case DMUS_FOURCC_TIMESIG_CHUNK :
                    hr = LoadTimeSigList(&Parser,ckNext.cksize);
                    break;
                }    
            }
            Parser.LeaveList();
        }
        else
        {
            Trace(1,"Error: Failure reading bad data in time signature track.\n");
            hr = DMUS_E_CHUNKNOTFOUND;
        }
    }

	LeaveCriticalSection(&m_CrSec);
	return hr;
}


HRESULT CTimeSigTrack::LoadTimeSigList( CRiffParser *pParser, long lChunkSize )
{
	HRESULT hr;

	// copy contents of the stream into the list.
	DWORD dwSubSize;
	// read in the size of the data structures
	hr = pParser->Read( &dwSubSize, sizeof(DWORD));
    if (SUCCEEDED(hr))
    {
	    lChunkSize -= sizeof(DWORD);

	    DWORD dwRead, dwSeek;
	    if( dwSubSize > sizeof(DMUS_IO_TIMESIGNATURE_ITEM) )
	    {
		    dwRead = sizeof(DMUS_IO_TIMESIGNATURE_ITEM);
		    dwSeek = dwSubSize - dwRead;
	    }
	    else
	    {
		    dwRead = dwSubSize;
		    dwSeek = 0;
	    }
	    if( 0 == dwRead )
	    {
            Trace(1,"Error: Failure reading time signature track.\n");
		    hr = DMUS_E_CANNOTREAD;
	    }
        else
        {
	        while( lChunkSize > 0 )
	        {
                CTimeSigItem *pNew = new CTimeSigItem;
                if (pNew)
                {
		            if( FAILED( pParser->Read( &pNew->m_TimeSig, dwRead )))
		            {
                        delete pNew;
			            hr = DMUS_E_CANNOTREAD;
			            break;
		            }
				    // make sure this time sig is OK
				    if (!pNew->m_TimeSig.bBeatsPerMeasure)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeatsPerMeasure\n");
					    pNew->m_TimeSig.bBeatsPerMeasure = 4;
				    }
				    if (!pNew->m_TimeSig.bBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.bBeat\n");
					    pNew->m_TimeSig.bBeat = 4;
				    }
				    if (!pNew->m_TimeSig.wGridsPerBeat)
				    {
					    Trace(1, "Warning: invalid content: DMUS_IO_TIMESIGNATURE_ITEM.wGridsPerBeat\n");
					    pNew->m_TimeSig.wGridsPerBeat = 4;
				    }
                    m_TSigEventList.AddHead(pNew); 
		            lChunkSize -= dwRead;
		            if( dwSeek )
		            {
			            if( FAILED( pParser->Skip(dwSeek)))
			            {
				            hr = DMUS_E_CANNOTSEEK;
				            break;
			            }
			            lChunkSize -= dwSeek;
		            }
		        }
	        }
            m_TSigEventList.Reverse();
            // If there is no time signature at the start, make a copy of the 
            // first time signature and stick it there. This resolves a bug in 6.1 
            // where notification messages and GetParam() were inconsistent
            // in their behavior under this circumstance. This ensures they behave
            // the same.
            CTimeSigItem *pTop = m_TSigEventList.GetHead();
            if (pTop && (pTop->m_TimeSig.lTime > 0))
            {
                CTimeSigItem *pCopy = new CTimeSigItem;
                if (pCopy)
                {
                    *pCopy = *pTop;
                    pCopy->m_TimeSig.lTime = 0;
                    m_TSigEventList.AddHead(pCopy);
                }                
            }
        }
    }
	return hr;
}

HRESULT CTimeSigTrack::Save( IStream* pIStream, BOOL fClearDirty )
{
	return E_NOTIMPL;
}

HRESULT CTimeSigTrack::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
	return E_NOTIMPL;
}

// IDirectMusicTrack

HRESULT STDMETHODCALLTYPE CTimeSigTrack::IsParamSupported( 
    /* [in] */ REFGUID rguid)
{
	V_INAME(CTimeSigTrack::IsParamSupported);
	V_REFGUID(rguid);

    if (m_fStateSetBySetParam)
    {
	    if( m_fActive )
	    {
		    if( rguid == GUID_DisableTimeSig ) return S_OK;
		    if( rguid == GUID_TimeSignature ) return S_OK;
		    if( rguid == GUID_EnableTimeSig ) return DMUS_E_TYPE_DISABLED;
	    }
	    else
	    {
		    if( rguid == GUID_EnableTimeSig ) return S_OK;
		    if( rguid == GUID_DisableTimeSig ) return DMUS_E_TYPE_DISABLED;
		    if( rguid == GUID_TimeSignature ) return DMUS_E_TYPE_DISABLED;
	    }
    }
    else
    {
		if(( rguid == GUID_DisableTimeSig ) ||
		    ( rguid == GUID_TimeSignature ) ||
		    ( rguid == GUID_EnableTimeSig )) return S_OK;
    }
	return DMUS_E_TYPE_UNSUPPORTED;
}

//////////////////////////////////////////////////////////////////////
// IDirectMusicTrack::Init
HRESULT CTimeSigTrack::Init( 
    /* [in] */ IDirectMusicSegment *pSegment)
{
	return S_OK;
}

HRESULT CTimeSigTrack::InitPlay( 
    /* [in] */ IDirectMusicSegmentState *pSegmentState,
    /* [in] */ IDirectMusicPerformance *pPerformance,
    /* [out] */ void **ppStateData,
    /* [in] */ DWORD dwTrackID,
    /* [in] */ DWORD dwFlags)
{
	V_INAME(IDirectMusicTrack::InitPlay);
	V_PTRPTR_WRITE(ppStateData);
	V_INTERFACE(pSegmentState);
	V_INTERFACE(pPerformance);

    EnterCriticalSection(&m_CrSec);
	CTimeSigStateData* pStateData;
	pStateData = new CTimeSigStateData;
	if( NULL == pStateData )
		return E_OUTOFMEMORY;
	*ppStateData = pStateData;
    if (m_fStateSetBySetParam)
    {
        pStateData->m_fActive = m_fActive;
    }
    else
    {
        pStateData->m_fActive = !(dwFlags & (DMUS_SEGF_CONTROL | DMUS_SEGF_SECONDARY));
    }
	pStateData->m_dwVirtualTrackID = dwTrackID;
	pStateData->m_pPerformance = pPerformance; // weak reference, no addref.
	pStateData->m_pSegState = pSegmentState; // weak reference, no addref.
	pStateData->m_pCurrentTSig = m_TSigEventList.GetHead();
	pStateData->m_dwValidate = m_dwValidate;
    LeaveCriticalSection(&m_CrSec);
	return S_OK;
}

HRESULT CTimeSigTrack::EndPlay( 
    /* [in] */ void *pStateData)
{
	ASSERT( pStateData );
	if( pStateData )
	{
		V_INAME(CTimeSigTrack::EndPlay);
		V_BUFPTR_WRITE(pStateData, sizeof(CTimeSigStateData));
		CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
		delete pSD;
	}
	return S_OK;
}

HRESULT CTimeSigTrack::Play( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtStart,
    /* [in] */ MUSIC_TIME mtEnd,
    /* [in] */ MUSIC_TIME mtOffset,
	DWORD dwFlags,
	IDirectMusicPerformance* pPerf,
	IDirectMusicSegmentState* pSegSt,
	DWORD dwVirtualID
	)
{
	V_INAME(IDirectMusicTrack::Play);
	V_BUFPTR_WRITE( pStateData, sizeof(CTimeSigStateData));
	V_INTERFACE(pPerf);
	V_INTERFACE(pSegSt);

	EnterCriticalSection(&m_CrSec);
	HRESULT hr = S_OK;
	IDirectMusicGraph* pGraph = NULL;
	DMUS_TIMESIG_PMSG* pTimeSig;
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;
	MUSIC_TIME mtNotification = mtStart;
	BOOL fSeek = (dwFlags & DMUS_TRACKF_SEEK) ? TRUE : FALSE;

	// if mtStart is 0 and dwFlags contains DMUS_TRACKF_START, we want to be sure to
	// send out any negative time events. So, we'll set mtStart to -768.
	if( (mtStart == 0) && ( dwFlags & DMUS_TRACKF_START ))
	{
		mtStart = -768;
	}

	if( pSD->m_dwValidate != m_dwValidate )
	{
		pSD->m_dwValidate = m_dwValidate;
		pSD->m_pCurrentTSig = NULL;
	}
	// if the previous end time isn't the same as the current start time,
	// we need to seek to the right position.
	if( fSeek || ( pSD->m_mtPrevEnd != mtStart ))
	{
		if( dwFlags & (DMUS_TRACKF_START | DMUS_TRACKF_LOOP) )
		{
			Seek( pStateData, mtStart, TRUE );
		}
		else
		{
			Seek( pStateData, mtStart, FALSE );
		}
	}
	pSD->m_mtPrevEnd = mtEnd;

	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}

	if( FAILED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
		(void**)&pGraph )))
	{
		pGraph = NULL;
	}

	for( ; pSD->m_pCurrentTSig; pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext() )
	{
		DMUS_IO_TIMESIGNATURE_ITEM *pItem = &pSD->m_pCurrentTSig->m_TimeSig;
		if( pItem->lTime >= mtEnd )
		{
			break;
		}
		if( (pItem->lTime < mtStart) && !fSeek )
		{
			break;
		}
		if( pSD->m_fActive && !(dwFlags & DMUS_TRACKF_PLAY_OFF) && SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_TIMESIG_PMSG),
			(DMUS_PMSG**)&pTimeSig )))
		{
			if( pItem->lTime < mtStart )
			{
				// this only happens in the case where we've puposefully seeked
				// and need to time stamp this event with the start time
				pTimeSig->mtTime = mtStart + mtOffset;
			}
			else
			{
				pTimeSig->mtTime = pItem->lTime + mtOffset;
			}
			pTimeSig->bBeatsPerMeasure = pItem->bBeatsPerMeasure;
			pTimeSig->bBeat = pItem->bBeat;
			pTimeSig->wGridsPerBeat = pItem->wGridsPerBeat;
			pTimeSig->dwFlags |= DMUS_PMSGF_MUSICTIME;
			pTimeSig->dwVirtualTrackID = pSD->m_dwVirtualTrackID;
			pTimeSig->dwType = DMUS_PMSGT_TIMESIG;
			pTimeSig->dwGroupID = 0xffffffff;

			if( pGraph )
			{
				pGraph->StampPMsg( (DMUS_PMSG*)pTimeSig );
			}
			TraceI(3, "TimeSigtrk: TimeSig event\n");
			if(FAILED(pSD->m_pPerformance->SendPMsg( (DMUS_PMSG*)pTimeSig )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pTimeSig );
			}
		}
		if( pSD->m_fActive && m_fNotificationMeasureBeat && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
		{
			// create beat and measure notifications for up to this time
            if (mtNotification < pItem->lTime)
            {
			    mtNotification = NotificationMeasureBeat( mtNotification, pItem->lTime, pSD, mtOffset );
            }
        }
		// set the state data to the new beat and beats per measure, and time
		pSD->m_bBeat = pItem->bBeat;
		pSD->m_bBeatsPerMeasure = pItem->bBeatsPerMeasure;
		pSD->m_mtTimeSig = pItem->lTime;
	}
	if( pSD->m_fActive && m_fNotificationMeasureBeat && ( mtNotification < mtEnd ) 
        && !(dwFlags & DMUS_TRACKF_NOTIFY_OFF))
	{
		NotificationMeasureBeat( mtNotification, mtEnd, pSD, mtOffset );
	}
	if( pGraph )
	{
		pGraph->Release();
	}

	LeaveCriticalSection(&m_CrSec);
	return hr;
}

// seeks to the time sig. just before mtTime.
HRESULT CTimeSigTrack::Seek( 
    /* [in] */ void *pStateData,
    /* [in] */ MUSIC_TIME mtTime, BOOL fGetPrevious)
{
	CTimeSigStateData* pSD = (CTimeSigStateData*)pStateData;

	if( m_TSigEventList.IsEmpty() )
	{
		return S_FALSE;
	}
	if( NULL == pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// if the current event's time is on or past mtTime, we need to rewind to the beginning
	if( pSD->m_pCurrentTSig->m_TimeSig.lTime >= mtTime )
	{
		pSD->m_pCurrentTSig = m_TSigEventList.GetHead();
	}
	// now start seeking until we find an event with time on or past mtTime
	CTimeSigItem*	pTSig;
	for( pTSig = pSD->m_pCurrentTSig; pTSig ; pTSig = pTSig->GetNext() )
	{
		if( pTSig->m_TimeSig.lTime >= mtTime )
		{
			break;
		}
		pSD->m_pCurrentTSig = pTSig;
	}
	if( !fGetPrevious && pSD->m_pCurrentTSig )
	{
		pSD->m_pCurrentTSig = pSD->m_pCurrentTSig->GetNext();
	}
	return S_OK;
}

HRESULT CTimeSigTrack::GetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
	MUSIC_TIME* pmtNext,
    void *pData)
{
	V_INAME(CTimeSigTrack::GetParam);
	V_PTR_WRITE_OPT(pmtNext,MUSIC_TIME);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_GET_UNSUPPORTED;
    EnterCriticalSection(&m_CrSec);
	if( NULL == pData )
	{
		hr = E_POINTER;
	}
	else if( GUID_TimeSignature == rguid )
	{
		if( !m_fActive )
		{
			hr = DMUS_E_TYPE_DISABLED;
		}
        else
        {
            DMUS_TIMESIGNATURE* pTSigData = (DMUS_TIMESIGNATURE*)pData;
		    CTimeSigItem* pScan = m_TSigEventList.GetHead();
		    CTimeSigItem* pPrevious = pScan;
		    if (pScan)
		    {
		        for (; pScan; pScan = pScan->GetNext())
		        {
			        if (pScan->m_TimeSig.lTime > mtTime)
			        {
				        break;
			        }
			        pPrevious = pScan;
		        }
		        pTSigData->mtTime = pPrevious->m_TimeSig.lTime - mtTime;
		        pTSigData->bBeatsPerMeasure = pPrevious->m_TimeSig.bBeatsPerMeasure;
		        pTSigData->bBeat = pPrevious->m_TimeSig.bBeat;
		        pTSigData->wGridsPerBeat = pPrevious->m_TimeSig.wGridsPerBeat;
		        if (pmtNext)
		        {
			        *pmtNext = 0;
		        }
		        if (pScan)
		        {
			        if (pmtNext)
			        {
				        *pmtNext = pScan->m_TimeSig.lTime - mtTime;
			        }
		        }
		        hr = S_OK;
            }
            else
            {
                hr = DMUS_E_NOT_FOUND;
		    }
        }
	}
    LeaveCriticalSection(&m_CrSec);
	return hr;
}

HRESULT CTimeSigTrack::SetParam( 
	REFGUID rguid,
    MUSIC_TIME mtTime,
    void *pData)
{
	V_INAME(CTimeSigTrack::SetParam);
	V_REFGUID(rguid);

	HRESULT hr = DMUS_E_SET_UNSUPPORTED;

	if( rguid == GUID_EnableTimeSig )
	{
        if (m_fStateSetBySetParam && m_fActive)
        {       // Already been enabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = TRUE;
		    hr = S_OK;
        }
	}
	else if( rguid == GUID_DisableTimeSig )
	{
        if (m_fStateSetBySetParam && !m_fActive)
        {       // Already been disabled.
            hr = DMUS_E_TYPE_DISABLED;
        }
		else
        {
            m_fStateSetBySetParam = TRUE;
            m_fActive = FALSE;
		    hr = S_OK;
        }
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::AddNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::AddNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = TRUE;
		hr = S_OK;
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::RemoveNotificationType(
	/* [in] */  REFGUID rguidNotification)
{
	V_INAME(IDirectMusicTrack::RemoveNotificationType);
	V_REFGUID(rguidNotification);

	HRESULT hr = S_FALSE;

	if( rguidNotification == GUID_NOTIFICATION_MEASUREANDBEAT )
	{
		m_fNotificationMeasureBeat = FALSE;
		hr = S_OK;
	}
	return hr;
}

// send measure and beat notifications
MUSIC_TIME CTimeSigTrack::NotificationMeasureBeat( MUSIC_TIME mtStart, MUSIC_TIME mtEnd,
	CTimeSigStateData* pSD, MUSIC_TIME mtOffset )
{
	DMUS_NOTIFICATION_PMSG* pEvent = NULL;
	MUSIC_TIME mtTime;
	DWORD dwMeasure;
	BYTE bCurrentBeat;

	if( pSD->m_mtTimeSig >= mtEnd )
		return mtStart;

	if( pSD->m_mtTimeSig > mtStart )
	{
		mtStart = pSD->m_mtTimeSig;
	}

	// now actually generate the beat events.
	// Generate events that are on beat boundaries, from mtStart to mtEnd
	long lQuantize = ( DMUS_PPQ * 4 ) / pSD->m_bBeat;

	mtTime = mtStart - pSD->m_mtTimeSig;
	if( mtTime ) // 0 stays 0
	{
		// quantize to next boundary
		mtTime = ((( mtTime - 1 ) / lQuantize ) + 1 ) * lQuantize;
	}
	mtStart += mtTime - ( mtStart - pSD->m_mtTimeSig );
	
	bCurrentBeat = (BYTE)(( ( mtStart - pSD->m_mtTimeSig ) / lQuantize ) % pSD->m_bBeatsPerMeasure);
	dwMeasure = mtStart / (pSD->m_bBeatsPerMeasure * lQuantize );
	while( mtStart < mtEnd )
	{
		if( SUCCEEDED( pSD->m_pPerformance->AllocPMsg( sizeof(DMUS_NOTIFICATION_PMSG), 
			(DMUS_PMSG**)&pEvent )))
		{
			pEvent->dwType = DMUS_PMSGT_NOTIFICATION;
			pEvent->mtTime = mtStart + mtOffset;
			pEvent->dwFlags = DMUS_PMSGF_MUSICTIME | DMUS_PMSGF_TOOL_ATTIME;
            pEvent->dwPChannel = 0;
			pSD->m_pSegState->QueryInterface(IID_IUnknown, (void**)&pEvent->punkUser);

			pEvent->dwNotificationOption = DMUS_NOTIFICATION_MEASUREBEAT;
			pEvent->dwField1 = bCurrentBeat;
			pEvent->dwField2 = dwMeasure;
			pEvent->guidNotificationType = GUID_NOTIFICATION_MEASUREANDBEAT;
			pEvent->dwGroupID = 0xffffffff;

			IDirectMusicGraph* pGraph;
			if( SUCCEEDED( pSD->m_pSegState->QueryInterface( IID_IDirectMusicGraph,
				(void**)&pGraph )))
			{
				pGraph->StampPMsg((DMUS_PMSG*) pEvent );
				pGraph->Release();
			}
			if(FAILED(pSD->m_pPerformance->SendPMsg((DMUS_PMSG*) pEvent )))
			{
				pSD->m_pPerformance->FreePMsg( (DMUS_PMSG*)pEvent );
			}
		}
		bCurrentBeat++;
		if( bCurrentBeat >= pSD->m_bBeatsPerMeasure )
		{
			bCurrentBeat = 0;
			dwMeasure += 1;
		}
		mtStart += lQuantize;
	}
	return mtEnd;
}

HRESULT STDMETHODCALLTYPE CTimeSigTrack::Clone(
	MUSIC_TIME mtStart,
	MUSIC_TIME mtEnd,
	IDirectMusicTrack** ppTrack)
{
	V_INAME(IDirectMusicTrack::Clone);
	V_PTRPTR_WRITE(ppTrack);

	HRESULT hr = S_OK;

	if((mtStart < 0 ) ||(mtStart > mtEnd))
	{
        Trace(1,"Error: Clone failed on time signature track because of invalid start or end time.\n");
		return E_INVALIDARG;
	}

	EnterCriticalSection(&m_CrSec);
    CTimeSigTrack *pDM;
    
    try
    {
        pDM = new CTimeSigTrack(this, mtStart, mtEnd);
    }
    catch( ... )
    {
        pDM = NULL;
    }

	LeaveCriticalSection(&m_CrSec);
    if (pDM == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pDM->QueryInterface(IID_IDirectMusicTrack, (void**)ppTrack);
    pDM->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\debug.h ===
//
// debug.h
// 
// Copyright (c) 1997-1999 Microsoft Corporation. All rights reserved.
//
// Note:
//

#ifndef DEBUG_H
#define DEBUG_H

#include <windows.h>

#define DM_DEBUG_CRITICAL		1	// Used to include critical messages
#define DM_DEBUG_NON_CRITICAL	2	// Used to include level 1 plus important non-critical messages
#define DM_DEBUG_STATUS			3	// Used to include level 1 and level 2 plus status\state messages
#define DM_DEBUG_FUNC_FLOW		4	// Used to include level 1, level 2 and level 3 plus function flow messages
#define DM_DEBUG_ALL			5	// Used to include all debug messages

// Default to no debug output compiled
//
#define Trace
#define TraceI
#define assert(exp) ((void)0)

#ifdef DBG

// Checked build: include at least external debug spew
//
extern void DebugInit(void);
extern void DebugTrace(int iDebugLevel, LPSTR pstrFormat, ...);
extern void DebugAssert(LPSTR szExp, LPSTR szFile, ULONG ulLine);

# undef Trace
# define Trace DebugTrace

# undef assert
# define assert(exp) (void)( (exp) || (DebugAssert(#exp, __FILE__, __LINE__), 0) )

// If internal build flag set, include everything
//
# ifdef DMUSIC_INTERNAL
#  undef TraceI
#  define TraceI DebugTrace
# endif

#endif  // #ifdef DBG

#endif  // #ifndef DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmime\tempotrk.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// TempoTrk.h : Declaration of the CTempoTrack

#ifndef __TEMPOTRK_H_
#define __TEMPOTRK_H_

#include "dmusici.h"
#include "dmusicf.h"
#include "..\dmstyle\tlist.h"

struct PrivateTempo
{
    double      dblTempo;
    MUSIC_TIME  mtTime;
    MUSIC_TIME  mtDelta;
    bool        fLast;

    PrivateTempo() : dblTempo(120.), mtTime(0), mtDelta(0), fLast(false) {}
};

DEFINE_GUID(GUID_PrivateTempoParam, 0xe8dbd832, 0xbcf0, 0x4c8c, 0xa0, 0x75, 0xa3, 0xf1, 0x5e, 0x67, 0xfd, 0x63);

struct TempoStateData
{
	IDirectMusicPerformance*	pPerformance;
	IDirectMusicSegmentState*	pSegState;
	DWORD						dwVirtualTrackID;
	MUSIC_TIME					mtPrevEnd;
	TListItem<DMUS_IO_TEMPO_ITEM>*		pCurrentTempo;
	DWORD						dwValidate;
    BOOL                        fActive;

	TempoStateData()
	{
		mtPrevEnd = 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CTempoTrack
class CTempoTrack : 
	public IPersistStream,
	public IDirectMusicTrack8
{
public:
	CTempoTrack();
	CTempoTrack(
		const CTempoTrack& rTrack, MUSIC_TIME mtStart, MUSIC_TIME mtEnd);
	~CTempoTrack();

// member variables
protected:
	TList<DMUS_IO_TEMPO_ITEM>	m_TempoEventList;
	long				m_cRef;
	DWORD				m_dwValidate; // used to validate state data
	CRITICAL_SECTION	m_CrSec;
    BOOL                m_fCSInitialized;
	BOOL				m_fActive; // if FALSE, disable output and param support
    BOOL                m_fStateSetBySetParam;  // If TRUE, active flag was set by GUID. Don't override. 

public:
// IUnknown
    STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDirectMusicTrack methods
    STDMETHODIMP IsParamSupported(REFGUID rguid);
    STDMETHODIMP Init(IDirectMusicSegment *pSegment);
    STDMETHODIMP InitPlay(IDirectMusicSegmentState *pSegmentState,
                IDirectMusicPerformance *pPerformance,
                void **ppStateData,
                DWORD dwTrackID,
                DWORD dwFlags);
    STDMETHODIMP EndPlay(void *pStateData);
    STDMETHODIMP Play(void *pStateData,MUSIC_TIME mtStart,
                MUSIC_TIME mtEnd,MUSIC_TIME mtOffset,
		        DWORD dwFlags,IDirectMusicPerformance* pPerf,
		        IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID);
    STDMETHODIMP GetParam(REFGUID rguid,MUSIC_TIME mtTime,MUSIC_TIME* pmtNext,void *pData);
    STDMETHODIMP SetParam(REFGUID rguid,MUSIC_TIME mtTime,void *pData);
    STDMETHODIMP AddNotificationType(REFGUID rguidNotification);
    STDMETHODIMP RemoveNotificationType(REFGUID rguidNotification);
    STDMETHODIMP Clone(MUSIC_TIME mtStart,MUSIC_TIME mtEnd,IDirectMusicTrack** ppTrack);
// IDirectMusicTrack8 
    STDMETHODIMP PlayEx(void* pStateData,REFERENCE_TIME rtStart, 
                REFERENCE_TIME rtEnd,REFERENCE_TIME rtOffset,
                DWORD dwFlags,IDirectMusicPerformance* pPerf, 
                IDirectMusicSegmentState* pSegSt,DWORD dwVirtualID) ; 
    STDMETHODIMP GetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime, 
                REFERENCE_TIME* prtNext,void* pParam,void * pStateData, DWORD dwFlags) ; 
    STDMETHODIMP SetParamEx(REFGUID rguidType,REFERENCE_TIME rtTime,void* pParam, void * pStateData, DWORD dwFlags) ;
    STDMETHODIMP Compose(IUnknown* pContext, 
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
    STDMETHODIMP Join(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		IUnknown* pContext,
		DWORD dwTrackGroup,
		IDirectMusicTrack** ppResultTrack) ;
// IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
// IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );
protected:
    HRESULT Play(
        void *pStateData,	
        MUSIC_TIME mtStart,	
        MUSIC_TIME mtEnd,
        MUSIC_TIME mtOffset,
        REFERENCE_TIME rtOffset,
	    DWORD dwFlags,		
	    IDirectMusicPerformance* pPerf,	
	    IDirectMusicSegmentState* pSegSt,
	    DWORD dwVirtualID,
        BOOL fClockTime);
	HRESULT Seek(TempoStateData *pSD,MUSIC_TIME mtTime,BOOL fGetPrevious );
	void Construct(void);
	HRESULT JoinInternal(IDirectMusicTrack* pNewTrack,
		MUSIC_TIME mtJoin,
		DWORD dwTrackGroup);
};

#endif //__TEMPOTRK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\guids.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
#include <objbase.h>
#include "initguid.h"
#include "dmusicc.h" 
#include "dmusici.h"
#include "loader.h"
#include "dmscriptautguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\container.cpp ===
//
// Container.cpp: Implementation of CContainer
//
// Copyright (c) 1999-2001 Microsoft Corporation
//

#include "dmusicc.h" 
#include "dmusici.h" 
#include "dmusicf.h" 
#include "validate.h"
#include "container.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "smartref.h"
#include "miscutil.h"
#ifdef UNDER_CE
#include "dragon.h"
#endif

extern long g_cComponent;

CContainerItem::CContainerItem(bool fEmbedded)

{
    m_Desc.dwSize = sizeof(m_Desc);
    m_Desc.dwValidData = 0;
    m_dwFlags = 0;
    m_pObject = NULL;
    m_fEmbedded = fEmbedded;
    m_pwszAlias = NULL;
}

CContainerItem::~CContainerItem()

{
    if (m_pObject)
    {
        m_pObject->Release();
    }
    if (m_Desc.dwValidData & DMUS_OBJ_STREAM)
    {
        SafeRelease(m_Desc.pStream);
    }
    delete m_pwszAlias;
}

CContainer::CContainer()
{
    m_cRef = 1;
    m_dwFlags = 0;
    m_dwPartialLoad = 0;
    m_dwValidData = 0;
    m_pStream = NULL;
    m_fZombie = false;
}

CContainer::~CContainer()
{
    Clear();
    if (m_pStream)
    {
        m_pStream->Release();
    }
}

void CContainer::Clear()
{
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicGetLoader *pGetLoader = NULL;
    if (m_pStream)
    {
        m_pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
        if (pGetLoader)
        {
            pGetLoader->GetLoader(&pLoader);
            pGetLoader->Release();
        }
    }
    CContainerItem *pItem = m_ItemList.GetHead();
    CContainerItem *pNext;
    for (;pItem;pItem = pNext)
    {
        pNext = pItem->GetNext();
        if (pItem->m_pObject)
        {
            if (pLoader && !(pItem->m_dwFlags & DMUS_CONTAINED_OBJF_KEEP))
            {
                pLoader->ReleaseObject(pItem->m_pObject);
            }
            pItem->m_pObject->Release();
            pItem->m_pObject = NULL;
        }
        delete pItem;
    }
    if (pLoader)
    {
        pLoader->Release();
    }
}

STDMETHODIMP_(void) CContainer::Zombie()
{
    Clear();
    if (m_pStream)
    {
        m_pStream->Release();
        m_pStream = NULL;
    }
    m_fZombie = true;
}

STDMETHODIMP_(ULONG) CContainer::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CContainer::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

STDMETHODIMP CContainer::QueryInterface( const IID &riid, void **ppvObj )
{
    if (riid == IID_IUnknown || riid == IID_IDirectMusicContainer) {
        *ppvObj = static_cast<IDirectMusicContainer*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicObject)
    {
        *ppvObj = static_cast<IDirectMusicObject*>(this);
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IDirectMusicObjectP)
    {
        *ppvObj = static_cast<IDirectMusicObjectP*>(this);
    }
    else if (riid == IID_IPersistStream) 
    {
        *ppvObj = static_cast<IPersistStream*>(this);
        AddRef();
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

HRESULT CContainer::EnumObject(REFGUID rguidClass,
                               DWORD dwIndex,
                               LPDMUS_OBJECTDESC pDesc,
                               WCHAR *pwszAlias)
{
    V_INAME(CContainer::EnumObject);
    V_PTR_WRITE_OPT(pDesc, LPDMUS_OBJECTDESC);
    V_BUFPTR_WRITE_OPT(pwszAlias, MAX_PATH);
    V_REFGUID(rguidClass);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::EnumObject after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    CContainerItem *pItem = m_ItemList.GetHead();
    DWORD dwCounter = 0;
    HRESULT hr = S_FALSE;
    for (;pItem;pItem = pItem->GetNext())
    {
        if ((rguidClass == GUID_DirectMusicAllTypes) || 
            (rguidClass == pItem->m_Desc.guidClass))
        {
            if (dwCounter == dwIndex)
            {
                hr = S_OK;
                if (pDesc)
                {
                    DWORD dwCopySize = min(pDesc->dwSize,pItem->m_Desc.dwSize);
                    memcpy(pDesc,&pItem->m_Desc,dwCopySize);
                    if (pDesc->dwValidData & DMUS_OBJ_STREAM && pDesc->pStream)
                        pDesc->pStream->AddRef();
                }
                if (pwszAlias)
                {
                    hr = wcsTruncatedCopy(pwszAlias, pItem->m_pwszAlias ? pItem->m_pwszAlias : L"", MAX_PATH);
                }
                break;
            }
            dwCounter++;
        }
    }
    return hr;
}

HRESULT CContainer::Load(IStream* pStream, IDirectMusicLoader *pLoader)

{
    IRIFFStream *pRiffStream = NULL;
    HRESULT hr = AllocRIFFStream(pStream, &pRiffStream);
    if(FAILED(hr))
    {
        return hr;
    }

    MMCKINFO ckMain;

    ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;
    hr = pRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF);

    if(FAILED(hr))
    {
        pRiffStream->Release();
        return hr;
    }

    m_dwPartialLoad = FALSE;

    MMCKINFO ckNext;
    MMCKINFO ckUNFO;
    DWORD cbRead;
    DWORD cbSize;
    DMUS_IO_CONTAINER_HEADER ioHeader;
    
    ckNext.ckid = 0;
    ckNext.fccType = 0;

    hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
    while(SUCCEEDED(hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_CONTAINER_CHUNK :
            cbSize = min( sizeof(DMUS_IO_CONTAINER_HEADER), ckNext.cksize );
            hr = pStream->Read(&ioHeader, cbSize, &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwFlags = ioHeader.dwFlags;
            }
            break;
        case DMUS_FOURCC_GUID_CHUNK:
            cbSize = sizeof(GUID);
            if( ckNext.cksize == cbSize )
            {
                hr = pStream->Read( &m_guidObject, cbSize, &cbRead );
                if( SUCCEEDED(hr) && (cbRead == cbSize) )
                {
                    m_dwValidData |= DMUS_OBJ_OBJECT;
                }
            }
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pStream->Read(&m_vVersion, sizeof(DMUS_IO_VERSION), &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwValidData |= DMUS_OBJ_VERSION;
            }
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
        {
            cbSize = min(sizeof(m_wszCategory), ckNext.cksize);
            hr = pStream->Read(m_wszCategory, cbSize, &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwValidData |=  DMUS_OBJ_CATEGORY;
            }
        }
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pStream->Read(&(m_ftDate), sizeof(FILETIME), &cbRead);
            if(SUCCEEDED(hr))
            {
                m_dwValidData |=  DMUS_OBJ_DATE;
            }
            break;
        case FOURCC_LIST:
        case FOURCC_RIFF:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    while( pRiffStream->Descend( &ckUNFO, &ckNext, 0 ) == S_OK )
                    {
                        switch( ckUNFO.ckid )
                        {
                            case DMUS_FOURCC_UNAM_CHUNK:
                            {
                                cbSize = min(sizeof(m_wszName), ckUNFO.cksize);
                                hr = pStream->Read(&m_wszName, cbSize, &cbRead);
                                if(SUCCEEDED(hr))
                                {
                                    m_dwValidData |= DMUS_OBJ_NAME;
                                }
                                break;
                            }
                            default:
                                break;
                        }
                        pRiffStream->Ascend( &ckUNFO, 0 );
                    }
                    break;
                case DMUS_FOURCC_CONTAINED_OBJECTS_LIST :
                    hr = LoadObjects(pStream, pRiffStream, ckNext, pLoader);
                    break;
            }
            break;
        }
    
        if(SUCCEEDED(hr))
        {
            hr = pRiffStream->Ascend(&ckNext, 0);
        }

        if(SUCCEEDED(hr))
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
            hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
        }
    }

    // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
    // was reached before the desired chunk was found. In the usage 
    // above we will also get this error if we have finished parsing the file. 
    // So we need to set hr to S_OK since we are done
    hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;

    if (SUCCEEDED(hr))
    {
        // Ascend completely out of the container.
        hr = pRiffStream->Ascend(&ckMain, 0);
        if (!(m_dwFlags & DMUS_CONTAINER_NOLOADS))
        {
            for (CContainerItem *pItem = m_ItemList.GetHead();pItem;pItem = pItem->GetNext())
            {
                if (FAILED(pLoader->GetObject(&pItem->m_Desc,
                    IID_IDirectMusicObject,
                    (void **)&pItem->m_pObject)))
                {
                    hr = DMUS_S_PARTIALLOAD;
                }
            }
        }

        if (m_pStream)
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        m_pStream->AddRef();
    }

    if(pRiffStream)
    {
        pRiffStream->Release();
    }
    
    return hr;
}

HRESULT CContainer::LoadObjects(IStream *pStream, 
                                IRIFFStream *pRiffStream, 
                                MMCKINFO ckParent,
                                IDirectMusicLoader *pLoader)

{
    MMCKINFO ckNext;

    ckNext.ckid = 0;
    ckNext.fccType = 0;
    
    HRESULT hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
    
    while(SUCCEEDED(hr))
    {
        switch(ckNext.ckid)
        {
        case FOURCC_RIFF:
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
            case DMUS_FOURCC_CONTAINED_OBJECT_LIST :
                hr = LoadObject(pStream, pRiffStream, ckNext, pLoader);
                break;
            }
            break;
        }
    
        if(SUCCEEDED(hr))
        {
            hr = pRiffStream->Ascend(&ckNext, 0);
        }

        if(SUCCEEDED(hr))
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
            hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
        }
    }

    // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
    // was reached before the desired chunk was found. In the usage 
    // above we will also get this error if we have finished parsing the file. 
    // So we need to set hr to S_OK since we are done
    hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;
    return hr;
}

HRESULT CContainer::LoadObject(IStream* pStream, 
                              IRIFFStream *pRiffStream, 
                              MMCKINFO ckParent,
                              IDirectMusicLoader *pLoader)
{
    MMCKINFO ckNext, ckLast;

    ckNext.ckid = 0;
    ckNext.fccType = 0;

    DWORD cbRead;
    DWORD cbSize;
    
    DMUS_IO_CONTAINED_OBJECT_HEADER ioHeader;

    HRESULT hr = pRiffStream->Descend(&ckNext, &ckParent, 0);

    SmartRef::Buffer<WCHAR> wbufAlias;
    if(SUCCEEDED(hr))
    {
        if(ckNext.ckid == DMUS_FOURCC_CONTAINED_ALIAS_CHUNK)
        {
            if(ckNext.cksize % 2 != 0)
            {
                assert(false); // should be WCHARs -- two byte pairs
            }
            else
            {
                wbufAlias.Alloc(ckNext.cksize / 2);
                if (!wbufAlias)
                    return E_OUTOFMEMORY;
                hr = pStream->Read(wbufAlias, ckNext.cksize, &cbRead);
                if (FAILED(hr))
                    return hr;
            }

            pRiffStream->Ascend(&ckNext, 0);
            hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
        }
    }

    if(SUCCEEDED(hr))
    {        
        if(ckNext.ckid != DMUS_FOURCC_CONTAINED_OBJECT_CHUNK)
        {    
            Trace(1,"Invalid object in Container - cobh is not first chunk.\n");
            return DMUS_E_INVALID_CONTAINER_OBJECT;
        }    
        
        cbSize = sizeof(DMUS_IO_CONTAINED_OBJECT_HEADER);
            
        hr = pStream->Read(&ioHeader, cbSize, &cbRead);
        
        if(FAILED(hr))
        {
            return hr;
        }
                
        if(ioHeader.ckid == 0 && ioHeader.fccType == NULL)
        {
            Trace(1,"Invalid object header in Container.\n");
            return DMUS_E_INVALID_CONTAINER_OBJECT;
        }
        // Move to start of next chunk.
        pRiffStream->Ascend(&ckNext, 0);
        ckLast = ckNext;    // Memorize this position.

        hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
        
        while(SUCCEEDED(hr))
        {
            if((((ckNext.ckid == FOURCC_LIST) || (ckNext.ckid == FOURCC_RIFF))
                && ckNext.fccType == ioHeader.fccType) ||
                (ckNext.ckid == ioHeader.ckid))
            {
                // Okay, this is the chunk we are looking for.
                // Seek back to start of chunk.
                bool fEmbedded = !(ckNext.ckid == FOURCC_LIST && ckNext.fccType == DMUS_FOURCC_REF_LIST);
                CContainerItem *pItem = new CContainerItem(fEmbedded);
                if (!pItem)
                    hr = E_OUTOFMEMORY;
                else
                {
                    if (fEmbedded)
                    {
                        // This is an embedded object.  Ascend to the position where from which it will be loaded.
                        pRiffStream->Ascend(&ckLast, 0);
                        pItem->m_Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_STREAM;
                        pItem->m_Desc.guidClass = ioHeader.guidClassID;
                        pItem->m_Desc.pStream = pStream;
                        pStream->AddRef();
                    }
                    else
                    {
                        // This is a reference chunk.  Read the object descriptor.
                        hr = this->ReadReference(pStream, pRiffStream, ckNext, &pItem->m_Desc);
                    }

                    if (SUCCEEDED(hr))
                    {
                        // We will call SetObject on items in the container here.  The items are loaded later.
                        // This ensures that out-of-order references between objects can be retrieved as the objects
                        // load themselves.
                        pLoader->SetObject(&pItem->m_Desc);
                        if (pItem->m_Desc.dwValidData & DMUS_OBJ_STREAM)
                        {
                            // The loader has the stream now so we don't need it any more.
                            pItem->m_Desc.dwValidData &= ~DMUS_OBJ_STREAM;
                            SafeRelease(pItem->m_Desc.pStream);
                        }

                        pItem->m_pwszAlias = wbufAlias.disown();
                        m_ItemList.AddTail(pItem);
                    }
                    else
                        delete pItem;
                }
            }

            if(SUCCEEDED(hr))
            {
                pRiffStream->Ascend(&ckNext, 0);
                ckLast = ckNext;
                {
                    ckNext.ckid = 0;
                    ckNext.fccType = 0;
                    hr = pRiffStream->Descend(&ckNext, &ckParent, 0);
                }
            }
        }

        // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
        // was reached before the desired chunk was found. In the usage 
        // above we will also get this error if we have finished parsing the file. 
        // So we need to set hr to S_OK since we are done
        hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;
    }
    return hr;
}

HRESULT
CContainer::ReadReference(IStream* pStream, 
                          IRIFFStream *pRiffStream, 
                          MMCKINFO ckParent,
                          DMUS_OBJECTDESC *pDesc)
{
    // I can't believe I'm writing this function!  It's copied right out of WaveItem::LoadReference and modified to work here.
    // This really aught to be shared code, but the other components all use different stream reader thingies than IRIFFStream
    // so that won't work.

    if (!pStream || !pRiffStream || !pDesc)
    {
        assert(false);
        return E_INVALIDARG;
    }

    ZeroAndSize(pDesc);

    DWORD cbRead;

    MMCKINFO ckNext;
    ckNext.ckid = 0;
    ckNext.fccType = 0;
    DWORD dwSize = 0;

    HRESULT hr = S_OK;
    while( pRiffStream->Descend( &ckNext, &ckParent, 0 ) == S_OK )
    {
        switch(ckNext.ckid)
        {
            case  DMUS_FOURCC_REF_CHUNK:
                DMUS_IO_REFERENCE ioDMRef;
                hr = pStream->Read(&ioDMRef, sizeof(DMUS_IO_REFERENCE), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->guidClass = ioDMRef.guidClassID;
                    pDesc->dwValidData |= ioDMRef.dwValidData;
                    pDesc->dwValidData |= DMUS_OBJ_CLASS;
                }
                break;

            case DMUS_FOURCC_GUID_CHUNK:
                hr = pStream->Read(&(pDesc->guidObject), sizeof(GUID), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->dwValidData |=  DMUS_OBJ_OBJECT;
                }
                break;

            case DMUS_FOURCC_DATE_CHUNK:
                hr = pStream->Read(&(pDesc->ftDate), sizeof(FILETIME), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->dwValidData |=  DMUS_OBJ_DATE;
                }
                break;

            case DMUS_FOURCC_NAME_CHUNK:
                dwSize = min(sizeof(pDesc->wszName), ckNext.cksize);
                hr = pStream->Read(pDesc->wszName, dwSize, &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->wszName[DMUS_MAX_NAME - 1] = L'\0';
                    pDesc->dwValidData |=  DMUS_OBJ_NAME;
                }
                break;

            case DMUS_FOURCC_FILE_CHUNK:
                dwSize = min(sizeof(pDesc->wszFileName), ckNext.cksize);
                hr = pStream->Read(pDesc->wszFileName, dwSize, &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->wszFileName[DMUS_MAX_FILENAME - 1] = L'\0';
                    pDesc->dwValidData |=  DMUS_OBJ_FILENAME;
                }
                break;

            case DMUS_FOURCC_CATEGORY_CHUNK:
                dwSize = min(sizeof(pDesc->wszCategory), ckNext.cksize);
                hr = pStream->Read(pDesc->wszCategory, dwSize, &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = L'\0';
                    pDesc->dwValidData |=  DMUS_OBJ_CATEGORY;
                }
                break;

            case DMUS_FOURCC_VERSION_CHUNK:
                DMUS_IO_VERSION ioDMObjVer;
                hr = pStream->Read(&ioDMObjVer, sizeof(DMUS_IO_VERSION), &cbRead);
                if(SUCCEEDED(hr))
                {
                    pDesc->vVersion.dwVersionMS = ioDMObjVer.dwVersionMS;
                    pDesc->vVersion.dwVersionLS = ioDMObjVer.dwVersionLS;
                    pDesc->dwValidData |= DMUS_OBJ_VERSION;
                }
                break;

            default:
                break;
        }

        if(SUCCEEDED(hr) && pRiffStream->Ascend(&ckNext, 0) == S_OK)
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
        }
        else if (SUCCEEDED(hr)) hr = DMUS_E_CANNOTREAD;
    }

    if (!(pDesc->dwValidData &  DMUS_OBJ_NAME) && 
        !(pDesc->dwValidData &  DMUS_OBJ_FILENAME) &&
        !(pDesc->dwValidData &  DMUS_OBJ_OBJECT) )
    {
        Trace(1,"Error: Incomplete object reference in Container - DMRF must specify an object name, filename, or GUID.\n");
        hr = DMUS_E_INVALID_CONTAINER_OBJECT;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist

HRESULT CContainer::GetClassID( CLSID* pClassID )
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::GetClassID after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    if (pClassID)
    {
        *pClassID = CLSID_DirectMusicContainer;
        return S_OK;
    }
    return E_POINTER;
}

/////////////////////////////////////////////////////////////////////////////
// IPersistStream functions

HRESULT CContainer::IsDirty()
{
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::IsDirty after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    return S_FALSE;
}

HRESULT CContainer::Load( IStream* pStream )
{
    V_INAME(IPersistStream::Load);
    V_INTERFACE(pStream);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::Load after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    IDirectMusicLoader *pLoader = NULL;
    IDirectMusicGetLoader *pGetLoader = NULL;
    if (pStream)
    {
        pStream->QueryInterface(IID_IDirectMusicGetLoader,(void **) &pGetLoader);
        if (pGetLoader)
        {
            pGetLoader->GetLoader(&pLoader);
            pGetLoader->Release();
        }
    }
    if (pLoader)
    {
        HRESULT hr = Load(pStream, pLoader);
        pLoader->Release();
        return hr;
    }
    Trace(1, "Error: unable to load container from a stream because it doesn't support the IDirectMusicGetLoader interface.\n");
    return DMUS_E_UNSUPPORTED_STREAM;
}


HRESULT CContainer::Save( IStream* pIStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetSizeMax( ULARGE_INTEGER FAR* pcbSize )
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// IDirectMusicObject

STDMETHODIMP CContainer::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CContainer::GetDescriptor);
    V_PTR_WRITE(pDesc, DMUS_OBJECTDESC); 

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::GetDescriptor after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    memset( pDesc, 0, sizeof(DMUS_OBJECTDESC));
    pDesc->dwSize = sizeof(DMUS_OBJECTDESC);
    pDesc->guidClass = CLSID_DirectMusicContainer;
    pDesc->guidObject = m_guidObject;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    memcpy( pDesc->wszName, m_wszName, sizeof(m_wszName) );
    memcpy( pDesc->wszCategory, m_wszCategory, sizeof(m_wszCategory) );
    memcpy( pDesc->wszFileName, m_wszFileName, sizeof(m_wszFileName) );
    pDesc->dwValidData = ( m_dwValidData | DMUS_OBJ_CLASS );

    return S_OK;
}

STDMETHODIMP CContainer::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    // Argument validation
    V_INAME(CContainer::SetDescriptor);
    V_PTR_READ(pDesc, DMUS_OBJECTDESC); 
    
    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::SetDescriptor after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    HRESULT hr = S_OK;
    DWORD dw = 0;

    if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
    {
        m_guidObject = pDesc->guidObject;
        dw |= DMUS_OBJ_OBJECT;
    }
    if( pDesc->dwValidData & DMUS_OBJ_NAME )
    {
        memcpy( m_wszName, pDesc->wszName, sizeof(WCHAR)*DMUS_MAX_NAME );
        dw |= DMUS_OBJ_NAME;
    }
    if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
    {
        memcpy( m_wszCategory, pDesc->wszCategory, sizeof(WCHAR)*DMUS_MAX_CATEGORY );
        dw |= DMUS_OBJ_CATEGORY;
    }
    if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
        ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
    {
        memcpy( m_wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
        dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
    }
    if( pDesc->dwValidData & DMUS_OBJ_VERSION )
    {
        m_vVersion = pDesc->vVersion;
        dw |= DMUS_OBJ_VERSION;
    }
    if( pDesc->dwValidData & DMUS_OBJ_DATE )
    {
        m_ftDate = pDesc->ftDate;
        dw |= DMUS_OBJ_DATE;
    }
    m_dwValidData |= dw;
    if( pDesc->dwValidData & (~dw) )
    {
        hr = S_FALSE; // there were extra fields we didn't parse;
        pDesc->dwValidData = dw;
    }

    return hr;
}

STDMETHODIMP CContainer::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc) 
{
    V_INAME(CContainer::ParseDescriptor);
    V_INTERFACE(pStream);
    V_STRUCTPTR_WRITE(pDesc, DMUS_OBJECTDESC);

    if (m_fZombie)
    {
        Trace(1, "Error: Call of IDirectMusicContainer::ParseDescriptor after the container has been garbage collected. "
                    "It is invalid to continue using a container after releasing it from the loader (ReleaseObject/ReleaseObjectByUnknown) "
                    "and then calling CollectGarbage or Release on the loader.");
        return DMUS_S_GARBAGE_COLLECTED;
    }
    
    IRIFFStream *pRiffStream = NULL;
    HRESULT hr = AllocRIFFStream(pStream, &pRiffStream);
    if (FAILED(hr))
        return hr;

    MMCKINFO ckMain;

    ckMain.fccType = DMUS_FOURCC_CONTAINER_FORM;
    hr = pRiffStream->Descend(&ckMain, NULL, MMIO_FINDRIFF);

    if(FAILED(hr))
    {
        pRiffStream->Release();
        return hr;
    }

    pDesc->dwValidData = DMUS_OBJ_CLASS;
    pDesc->guidClass = CLSID_DirectMusicContainer;

    MMCKINFO ckNext;
    MMCKINFO ckUNFO;
    DWORD cbRead;
    DWORD cbSize;
    
    ckNext.ckid = 0;
    ckNext.fccType = 0;

    hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
    while(SUCCEEDED(hr))
    {
        switch(ckNext.ckid)
        {
        case DMUS_FOURCC_GUID_CHUNK:
            cbSize = sizeof(GUID);
            if( ckNext.cksize == cbSize )
            {
                hr = pStream->Read( &pDesc->guidObject, cbSize, &cbRead );
                if( SUCCEEDED(hr) && (cbRead == cbSize) )
                {
                    pDesc->dwValidData |= DMUS_OBJ_OBJECT;
                }
            }
            break;
        case DMUS_FOURCC_VERSION_CHUNK:
            hr = pStream->Read(&pDesc->vVersion, sizeof(DMUS_IO_VERSION), &cbRead);
            if(SUCCEEDED(hr))
            {
                pDesc->dwValidData |= DMUS_OBJ_VERSION;
            }
            break;
        case DMUS_FOURCC_CATEGORY_CHUNK:
        {
            cbSize = min(sizeof(pDesc->wszCategory), ckNext.cksize);
            hr = pStream->Read(pDesc->wszCategory, cbSize, &cbRead);
            if(SUCCEEDED(hr))
            {
                pDesc->dwValidData |=  DMUS_OBJ_CATEGORY;
            }
        }
            break;
        case DMUS_FOURCC_DATE_CHUNK:
            hr = pStream->Read(&(pDesc->ftDate), sizeof(FILETIME), &cbRead);
            if(SUCCEEDED(hr))
            {
                pDesc->dwValidData |=  DMUS_OBJ_DATE;
            }
            break;
        case FOURCC_LIST:
            switch(ckNext.fccType)
            {
                case DMUS_FOURCC_UNFO_LIST:
                    while( pRiffStream->Descend( &ckUNFO, &ckNext, 0 ) == S_OK )
                    {
                        switch( ckUNFO.ckid )
                        {
                            case DMUS_FOURCC_UNAM_CHUNK:
                            {
                                cbSize = min(sizeof(pDesc->wszName), ckUNFO.cksize);
                                hr = pStream->Read(&pDesc->wszName, cbSize, &cbRead);
                                if(SUCCEEDED(hr))
                                {
                                    pDesc->dwValidData |= DMUS_OBJ_NAME;
                                }
                                break;
                            }
                            default:
                                break;
                        }
                        pRiffStream->Ascend( &ckUNFO, 0 );
                    }
                    break;
            }
            break;
        }
    
        if(SUCCEEDED(hr))
        {
            hr = pRiffStream->Ascend(&ckNext, 0);
        }

        if(SUCCEEDED(hr))
        {
            ckNext.ckid = 0;
            ckNext.fccType = 0;
            hr = pRiffStream->Descend(&ckNext, &ckMain, 0);
        }
    }

    // DMUS_E_DESCEND_CHUNK_FAIL is returned when the end of the file 
    // was reached before the desired chunk was found. In the usage 
    // above we will also get this error if we have finished parsing the file. 
    // So we need to set hr to S_OK since we are done
    hr = (hr == DMUS_E_DESCEND_CHUNK_FAIL) ? S_OK : hr;

    if(pRiffStream)
    {
        pRiffStream->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\ima.h ===
// Copyright (c) 1998 Microsoft Corporation
// IMA.h : Declaration of private interface for IMA legacy mode.
//
//

#ifndef __IMA_H_
#define __IMA_H_

#include <windows.h>

#define COM_NO_WINDOWS_H
#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif


#undef  INTERFACE
#define INTERFACE  IDirectMusicIMA
DECLARE_INTERFACE_(IDirectMusicIMA, IUnknown)
{
	/* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

	/* IDirectMusicIMA */
	STDMETHOD(LegacyCaching)		(THIS_ BOOL fEnable) PURE;
};

DEFINE_GUID(IID_IDirectMusicIMA,0xd2ac28b3, 0xb39b, 0x11d1, 0x87, 0x4, 0x0, 0x60, 0x8, 0x93, 0xb1, 0xbd);

#ifdef __cplusplus
}; /* extern "C" */
#endif

#endif /* #ifndef __IMA_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\debug.cpp ===
//
// Debug.CPP
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
// @doc INTERNAL
//
// @module Debug | Debug services for DMusic.DLL
//

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

#ifdef DBG

#define MODULE "DMLOADER"

// @globalv Section in WIN.INI for all debug settings
const char szDebugSection[] = "debug";

// @globalv Key in WIN.INI for our debug level. All messages with
// a level of this number or lower will be displayed.
const char szDebugKey[] = MODULE;

// @globalv Key in WIN.INI [debug] section which determines if assert calls
// DebugBreak or not
//
const char szAssertBreak[] = "AssertBreak";

// @globalv Prefix for all debug outputs
//
const char szDebugPrefix[] = MODULE ": ";

// @globalv The current debug level. 
static int giDebugLevel;

// @globalv Do asserts break?
static BOOL gfAssertBreak;

// @func Sets the debug level from WIN.INI
// 
void DebugInit(
    void)
{
    giDebugLevel = GetProfileInt(szDebugSection, szDebugKey, 0);
    gfAssertBreak = GetProfileInt(szDebugSection, szAssertBreak, 0);


    // Nepotism at its finest
    DebugTrace(-1, "Debug level is %d\n", giDebugLevel);
}

// @func Send a debug trace out.
//
// @comm Any message with a level less than or equal to the current debug
// level will be displayed using the OutputDebugString API. This means either
// the IDE Debug window if the app is running in that context or WDEB if
// it's running.
//
static BOOL fNeedPrefix = TRUE;
void DebugTrace(
    int iDebugLevel,        // @parm The debug level of this message
    LPSTR pstrFormat,       // @parm A printf style format string
    ...)                    // @parm | ... | Variable paramters based on <p pstrFormat>
{
    char sz[512];
    

    if (iDebugLevel != -1 && iDebugLevel > giDebugLevel)
    {
        return;
    }

    va_list va;

    va_start(va, pstrFormat);
    vsprintf(sz, pstrFormat, va);
    va_end(va);

    if (fNeedPrefix)
    {
        OutputDebugString(szDebugPrefix);
    }
    
    OutputDebugString(sz);

    // Let them construct multiple piece trace outs w/o
    // prefixing each one
    //
    fNeedPrefix = FALSE;
    for (;*pstrFormat && !fNeedPrefix; ++pstrFormat)
    {
        if (*pstrFormat == '\n')
        {
            fNeedPrefix = TRUE;
        }
    }
}

void DebugAssert(
    LPSTR szExp, 
    LPSTR szFile, 
    ULONG ulLine)
{
    DebugTrace(0, "ASSERT: \"%s\" %s@%lu\n", szExp, szFile, ulLine);
    if (gfAssertBreak)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\oledll.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
//
//
#ifndef _OLEDLL_
#define _OLEDLL_

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID);

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID);

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue);
				 
HRESULT CLSIDToStr(const CLSID &clsid,
				   TCHAR *szStr,
				   int cbStr);

HRESULT StrToCLSID(TCHAR *szStr,
				   CLSID &clsid,
				   int cbStr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\oledll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// oledll.cpp
//
// Handle standard stuff for OLE server DLL
//
#include <objbase.h>
#include "debug.h"
#include <iostream.h>

#include "oledll.h"

#ifdef UNICODE
#ifndef UNDER_CE
#error DirectMusic Win NT/9x must be compiled without UNICODE
#endif
#endif

static const TCHAR g_szCLSID[]           = TEXT("CLSID");
static const TCHAR g_szCLSIDSlash[]      = TEXT("CLSID\\");
static const TCHAR g_szInProc32[]        = TEXT("InProcServer32");
static const TCHAR g_szProgIDKey[]       = TEXT("ProgID");
static const TCHAR g_szVerIndProgIDKey[] = TEXT("VersionIndependentProgID");
static const TCHAR g_szCurVer[]          = TEXT("CurVer"); 
static const TCHAR g_szThreadingModel[]	= TEXT("ThreadingModel");
static const TCHAR g_szBoth[]		    = TEXT("Both");

static const int CLSID_STRING_SIZE = 39;

static LONG RegSetDefValue(LPCTSTR pstrKey, LPCTSTR pstrSubkey, LPCTSTR pstrValueName, LPCTSTR pstrValue);
static void RegRemoveSubtree(HKEY hk, LPCTSTR pstrChild);

STDAPI
RegisterServer(HMODULE hModule,
               const CLSID &clsid,
               const TCHAR *szFriendlyName,
               const TCHAR *szVerIndProgID,
               const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    LONG lr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    TCHAR szModule[512];
    lr = ::GetModuleFileName(hModule, szModule, sizeof(szModule));
    assert(lr);

    lr = 0;

    lr |= RegSetDefValue(szClsKey, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szClsKey, g_szInProc32, NULL, szModule);
	lr |= RegSetDefValue(szClsKey, g_szInProc32, g_szThreadingModel, g_szBoth);
    lr |= RegSetDefValue(szClsKey, g_szProgIDKey, NULL, szProgID);
    lr |= RegSetDefValue(szClsKey, g_szVerIndProgIDKey, NULL, szVerIndProgID);

    lr |= RegSetDefValue(szVerIndProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szVerIndProgID, g_szCLSID, NULL, szCLSID);
    lr |= RegSetDefValue(szVerIndProgID, g_szCurVer, NULL, szProgID);
    
	lr |= RegSetDefValue(szProgID, NULL, NULL, szFriendlyName);
    lr |= RegSetDefValue(szProgID, g_szCLSID, NULL, szCLSID);

#if 0 
    if (lr) {
        UnregisterServer(clsid,
                         szFriendlyName,
                         szVerIndProgID,
                         szProgID);
        // ???
        //
        return S_OK;
    }
#endif

    return S_OK;
}

STDAPI
UnregisterServer(const CLSID &clsid,
                 const TCHAR *szFriendlyName,
                 const TCHAR *szVerIndProgID,
                 const TCHAR *szProgID)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return hr;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);

    RegRemoveSubtree(HKEY_CLASSES_ROOT, szClsKey);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szVerIndProgID);
    RegRemoveSubtree(HKEY_CLASSES_ROOT, szProgID);

    return S_OK;
}

BOOL
GetCLSIDRegValue(const CLSID &clsid,
				 const TCHAR *szKey,
				 LPVOID pValue,
				 LPDWORD pcbValue)
{
    TCHAR szCLSID[CLSID_STRING_SIZE];
    HRESULT hr;
    HKEY hk;
	DWORD dw;

    hr = CLSIDToStr(clsid, szCLSID, sizeof(szCLSID));
    if (!SUCCEEDED(hr)) {
        return FALSE;
    }

    TCHAR szClsKey[256];
    lstrcpy(szClsKey, g_szCLSIDSlash);
    lstrcat(szClsKey, szCLSID);
	lstrcat(szClsKey, TEXT("\\"));
    if (szKey)
    {
	    lstrcat(szClsKey, szKey);
    }

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT,
					 szClsKey,
					 0,
					 KEY_READ,
					 &hk)) {
		return FALSE;
	}

	if (RegQueryValueEx(hk,
						NULL,
						NULL,
						&dw,
						(LPBYTE)pValue,
						pcbValue)) {
		RegCloseKey(hk);
		return FALSE;
	}

	RegCloseKey(hk);
	
	return TRUE;
}

HRESULT
CLSIDToStr(const CLSID &clsid,
           TCHAR *szStr,
           int cbStr)
{
    // XXX What to return here?
    //
    assert(cbStr >= CLSID_STRING_SIZE);
    
	LPOLESTR wszCLSID = NULL;
	HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
    if (!SUCCEEDED(hr)) {
        return hr;
    }

#ifdef UNICODE
    lstrcpy(szStr, wszCLSID);
#else
	// Covert from wide characters to non-wide.
	wcstombs(szStr, wszCLSID, cbStr);
#endif

	// Free memory.
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

HRESULT
StrToCLSID(TCHAR *szStr,
		   CLSID &clsid,
		   int cbStr)
{
#ifdef UNICODE
    return CLSIDFromString(szStr, &clsid);
#else    
	WCHAR wsz[512];
    if (cbStr > 512)
    {
        cbStr = 512;
    }

	mbstowcs(wsz, szStr, cbStr);

	return CLSIDFromString(wsz, &clsid);
#endif
}
   

static LONG
RegSetDefValue(LPCTSTR pstrKey,
               LPCTSTR pstrSubkey,
			   LPCTSTR pstrValueName,
               LPCTSTR pstrValue)
{
    HKEY hk;
    LONG lr;
    TCHAR sz[1024];
    LPCTSTR pstr;

    if (!pstrSubkey) {
        pstr = pstrKey;
    } else {
        lstrcpy(sz, pstrKey);
        lstrcat(sz, TEXT("\\"));
        lstrcat(sz, pstrSubkey);
        pstr = sz;
    }

    lr = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                        pstr,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hk,
                        NULL);
    if (lr) {
        return lr;
    }

    lr = RegSetValueEx(hk,
                       pstrValueName,
                       0,
                       REG_SZ,
                       (CONST BYTE*)pstrValue,
                       1+lstrlen(pstrValue));
    RegCloseKey(hk);

    return lr;
}

static void
RegRemoveSubtree(HKEY hk,
                 LPCTSTR pstrChild)
{
    LONG lResult;
    HKEY hkChild;

    lResult = RegOpenKeyEx(hk,
                           pstrChild,
                           0,
                           KEY_ALL_ACCESS,
                           &hkChild);
    if (lResult) {
        return;
    }

#ifndef UNDER_CE    // CE doesn't support RegEnumKey()
    TCHAR szSubkey[256];

    // NOTE: Unlike regular enumeration, we always grab the 0th item
    // and delete it.
    //
    while (!RegEnumKey(hkChild, 0, szSubkey, sizeof(szSubkey))) {
        RegRemoveSubtree(hkChild, szSubkey);
    }
#endif    

    RegCloseKey(hkChild);
    RegDeleteKey(hk, pstrChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\opnew.cpp ===
// Copyright (c) 1999 Microsoft Corporation
// OpNew.cpp
//
// Override operator new[] so that we ignore the new_handler mechanism.
//
//
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#include "Debug.h"

LPVOID __cdecl operator new(size_t cbBuffer)
{
    LPVOID p;

    p = malloc(cbBuffer ? cbBuffer : 1);
    return p;
}

void __cdecl operator delete(LPVOID p)
{
    free(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\container.h ===
// Copyright (c) 1999 Microsoft Corporation
// container.h : Declaration of the CContainer

#ifndef __CONTAINER_H_
#define __CONTAINER_H_
#include "alist.h"
#include "riff.h"
#include "..\shared\dmusicp.h"

class CContainer;
class CContainerItem : public AListItem
{
public:
                        CContainerItem(bool fEmbedded);
                        ~CContainerItem();
    CContainerItem *    GetNext() {return(CContainerItem *)AListItem::GetNext();};
    IDirectMusicObject *m_pObject;
    DWORD               m_dwFlags;
    DMUS_OBJECTDESC     m_Desc;     // Stored description of object.
    bool                m_fEmbedded; // This is an embedded (as opposed to referenced) object.
    WCHAR *             m_pwszAlias;
};

class CContainerItemList : public AList
{
public:
    CContainerItem *	GetHead() {return (CContainerItem *)AList::GetHead();};
    CContainerItem *	RemoveHead() {return (CContainerItem *)AList::RemoveHead();};
    void                AddTail(CContainerItem * pItem) { AList::AddTail((AListItem *)pItem);};
};

class CContainer : 
    public IDirectMusicContainer,
    public IDirectMusicObject,
    public IPersistStream,
    public IDirectMusicObjectP
{
public:
    CContainer::CContainer();
    CContainer::~CContainer();
    // IUnknown
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicContainer
    STDMETHODIMP EnumObject(REFGUID rguidClass,
        DWORD dwIndex,
        LPDMUS_OBJECTDESC pDesc,
        WCHAR *pwszAlias);

    // IDirectMusicObject 
	STDMETHODIMP GetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP SetDescriptor(LPDMUS_OBJECTDESC pDesc);
	STDMETHODIMP ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

    // IPersist functions
    STDMETHODIMP GetClassID( CLSID* pClsId );
    // IPersistStream functions
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load( IStream* pIStream );
    STDMETHODIMP Save( IStream* pIStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER FAR* pcbSize );

    // IDirectMusicObjectP
	STDMETHOD_(void, Zombie)();

private:
    void    Clear();    // Remove all object references.
    HRESULT Load(IStream* pStream, IDirectMusicLoader *pLoader);
    HRESULT LoadObjects(IStream *pStream, 
                        IRIFFStream *pRiffStream, 
                        MMCKINFO ckParent,
                        IDirectMusicLoader *pLoader);
    HRESULT LoadObject(IStream* pStream, 
                      IRIFFStream *pRiffStream, 
                      MMCKINFO ckParent,
                      IDirectMusicLoader *pLoader);
    HRESULT ReadReference(IStream* pStream, 
                          IRIFFStream *pRiffStream, 
                          MMCKINFO ckParent,
                          DMUS_OBJECTDESC *pDesc);

    IStream *           m_pStream;  // Pointer to stream this was loaded from.
                                    // This also provides access to the loader, indirectly.
    CContainerItemList  m_ItemList; // List of objects that were loaded by container. 
    long                m_cRef;     // COM reference counter.
    DWORD               m_dwFlags;  // Flags loaded from file.
    DWORD               m_dwPartialLoad; // Used to keep track of partial load.
    // IDirectMusicObject variables
	DWORD	            m_dwValidData;
	GUID	            m_guidObject;
	FILETIME	        m_ftDate;                           /* Last edited date of object. */
	DMUS_VERSION	    m_vVersion;                         /* Version. */
	WCHAR	            m_wszName[DMUS_MAX_NAME];			/* Name of object.       */
	WCHAR	            m_wszCategory[DMUS_MAX_CATEGORY];	/* Category for object */
	WCHAR               m_wszFileName[DMUS_MAX_FILENAME];	/* File path. */

    bool                m_fZombie;
};

#endif //__CONTAINER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\dll.cpp ===
// Copyright (c) 1998-1999 Microsoft Corporation
// loader dll.cpp
//
// Dll entry points and CLoaderFactory, CContainerFactory implementation
//

// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// 4530: C++ exception handler used, but unwind semantics are not enabled. Specify -GX
//
// We disable this because we use exceptions and do *not* specify -GX (USE_NATIVE_EH in
// sources).
//
// The one place we use exceptions is around construction of objects that call 
// InitializeCriticalSection. We guarantee that it is safe to use in this case with
// the restriction given by not using -GX (automatic objects in the call chain between
// throw and handler are not destructed). Turning on -GX buys us nothing but +10% to code
// size because of the unwind code.
//
// Any other use of exceptions must follow these restrictions or -GX must be turned on.
//
// READ THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
#pragma warning(disable:4530)
#include <objbase.h>
#include "debug.h"

#include "oledll.h"
#include "debug.h" 
#include "dmusicc.h"
#include "dmusici.h" 
#include "loader.h"
#include "container.h"

#ifndef UNDER_CE
#include <regstr.h>
#endif

// Globals
//

// Version information for our class
//
TCHAR g_szFriendlyName[]        = TEXT("DirectMusicLoader");
TCHAR g_szVerIndProgID[]        = TEXT("Microsoft.DirectMusicLoader");
TCHAR g_szProgID[]              = TEXT("Microsoft.DirectMusicLoader.1");
TCHAR g_szContFriendlyName[]    = TEXT("DirectMusicContainer");
TCHAR g_szContVerIndProgID[]    = TEXT("Microsoft.DirectMusicContainer");
TCHAR g_szContProgID[]          = TEXT("Microsoft.DirectMusicContainer.1");

// Dll's hModule
//
HMODULE g_hModule = NULL; 

#ifndef UNDER_CE
// Track whether running on Unicode machine.

BOOL g_fIsUnicode = FALSE;
#endif

// Count of active components and class factory server locks
//
long g_cComponent = 0;
long g_cLock = 0;




// CLoaderFactory::QueryInterface
//
HRESULT __stdcall
CLoaderFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CLoaderFactory::CLoaderFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CLoaderFactory::~CLoaderFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CLoaderFactory::AddRef
//
ULONG __stdcall
CLoaderFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CLoaderFactory::Release
//
ULONG __stdcall
CLoaderFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CLoaderFactory::CreateInstance
//
//
HRESULT __stdcall
CLoaderFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CLoader *pLoader;
    
    try
    {
        pLoader = new CLoader;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pLoader == NULL) {
        return E_OUTOFMEMORY;
    }

    // Do initialiazation
    //
    hr = pLoader->Init();
    if (!SUCCEEDED(hr)) {
        delete pLoader;
        return hr;
    }

    hr = pLoader->QueryInterface(iid, ppv);
    pLoader->Release();
    
    return hr;
}

// CLoaderFactory::LockServer
//
HRESULT __stdcall
CLoaderFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// CContainerFactory::QueryInterface
//
HRESULT __stdcall
CContainerFactory::QueryInterface(const IID &iid,
                                    void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_IClassFactory) {
        *ppv = static_cast<IClassFactory*>(this);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

CContainerFactory::CContainerFactory()

{
	m_cRef = 1;
	InterlockedIncrement(&g_cLock);
}

CContainerFactory::~CContainerFactory()

{
	InterlockedDecrement(&g_cLock);
}

// CContainerFactory::AddRef
//
ULONG __stdcall
CContainerFactory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

// CContainerFactory::Release
//
ULONG __stdcall
CContainerFactory::Release()
{
    if (!InterlockedDecrement(&m_cRef)) {
        delete this;
        return 0;
    }

    return m_cRef;
}

// CContainerFactory::CreateInstance
//
//
HRESULT __stdcall
CContainerFactory::CreateInstance(IUnknown* pUnknownOuter,
                                    const IID& iid,
                                    void** ppv)
{
    HRESULT hr;

    if (pUnknownOuter) {
         return CLASS_E_NOAGGREGATION;
    }

    CContainer *pContainer;
    
    try
    {
        pContainer = new CContainer;
    }
    catch( ... )
    {
        return E_OUTOFMEMORY;
    }

    if (pContainer == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pContainer->QueryInterface(iid, ppv);
    pContainer->Release();
    
    return hr;
}

// CContainerFactory::LockServer
//
HRESULT __stdcall
CContainerFactory::LockServer(BOOL bLock)
{
    if (bLock) {
        InterlockedIncrement(&g_cLock);
    } else {
        InterlockedDecrement(&g_cLock);
    }

    return S_OK;
}

// Standard calls needed to be an inproc server
//
STDAPI  DllCanUnloadNow()
{
    if (g_cComponent || g_cLock) {
        return S_FALSE;
    }

    return S_OK;
}

STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
        IUnknown* pIUnknown = NULL;

        if(clsid == CLSID_DirectMusicLoader)
        {
            pIUnknown = static_cast<IUnknown*> (new CLoaderFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }
        else if(clsid == CLSID_DirectMusicContainer)
        {
            pIUnknown = static_cast<IUnknown*> (new CContainerFactory);
            if(!pIUnknown) 
            {
                    return E_OUTOFMEMORY;
            }
        }

        else
        {
			return CLASS_E_CLASSNOTAVAILABLE;
		}

        HRESULT hr = pIUnknown->QueryInterface(iid, ppv);
        pIUnknown->Release();

    return hr;
}

STDAPI DllUnregisterServer()
{
    UnregisterServer(CLSID_DirectMusicLoader,
                     g_szFriendlyName,
                     g_szVerIndProgID,
                     g_szProgID);
    UnregisterServer(CLSID_DirectMusicContainer,
                     g_szContFriendlyName,
                     g_szContVerIndProgID,
                     g_szContProgID);
    return S_OK;
}

STDAPI DllRegisterServer()
{
    RegisterServer(g_hModule,
                   CLSID_DirectMusicLoader,
                   g_szFriendlyName,
                   g_szVerIndProgID,
                   g_szProgID);
    RegisterServer(g_hModule,
                   CLSID_DirectMusicContainer,
                   g_szContFriendlyName,
                   g_szContVerIndProgID,
                   g_szContProgID);
    return S_OK; 
}

extern void DebugInit();

// Standard Win32 DllMain
//

#ifdef DBG
static char* aszReasons[] =
{
    "DLL_PROCESS_DETACH",
    "DLL_PROCESS_ATTACH",
    "DLL_THREAD_ATTACH",
    "DLL_THREAD_DETACH"
};
const DWORD nReasons = (sizeof(aszReasons) / sizeof(char*));
#endif

BOOL APIENTRY DllMain(HINSTANCE hModule,
                      DWORD dwReason,
                      void *lpReserved)
{
    static int nReferenceCount = 0;

#ifdef DBG
    if (dwReason < nReasons)
    {
        DebugTrace(0, "DllMain: %s\n", (LPSTR)aszReasons[dwReason]);
    }
    else
    {
        DebugTrace(0, "DllMain: Unknown dwReason <%u>\n", dwReason);
    }
#endif
    if (dwReason == DLL_PROCESS_ATTACH) {
        if (++nReferenceCount == 1)
        { 
            g_hModule = (HMODULE)hModule;
#ifndef UNDER_CE
            OSVERSIONINFO osvi;

            DisableThreadLibraryCalls(hModule);
            osvi.dwOSVersionInfoSize = sizeof(osvi);
            GetVersionEx(&osvi);
            g_fIsUnicode = 
				(osvi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS);
#endif
#ifdef DBG
			DebugInit();
#endif
		}
    }
#ifdef DBG
    else if(dwReason == DLL_PROCESS_DETACH) {
        if (--nReferenceCount == 0)
        {
            TraceI(-1, "Unloading DMLoader : g_cLock = %d, g_cComponent = %d", g_cLock, g_cComponent);

            // Assert if we still have some objects hanging around
            assert(g_cComponent == 0);
            assert(g_cLock == 0);
        }
    }
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\loader.cpp ===
//
// Loader.cpp : Implementation of CLoader
//
// Copyright (c) 1997-2001 Microsoft Corporation
//
// @doc EXTERNAL
//

#include "dmusicc.h" 
#include "dmusici.h" 
#include "validate.h"
#include "loader.h"
#include "debug.h"
#include "riff.h"
#include "dmscriptautguids.h"
#include "miscutil.h"
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif

extern long g_cComponent;

/////////////////////////////////////////////////////////////////////////////
// CLoader

static HRESULT GetRegStringW( HKEY hKey, WCHAR* lpSubKey, WCHAR* lpValueName, WCHAR* lpwzString )
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;

    lpwzString[0] = L'\0';
    lResult = RegOpenKeyExW( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
    if( lResult == ERROR_SUCCESS )
    {
        dwCbData = MAX_PATH * sizeof(WCHAR);
        lResult = RegQueryValueExW( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)lpwzString, &dwCbData );
        if( lResult != ERROR_SUCCESS )
        {
            lpwzString[0] = L'\0';
        }
        else
        {
#ifndef UNDER_CE        
            if( dwType == REG_EXPAND_SZ )
            {
                WCHAR wzTemp[MAX_PATH];
                if( ExpandEnvironmentStringsW( lpwzString, wzTemp, MAX_PATH ) )
                {
                    wcscpy(lpwzString, wzTemp);
                }
                else
                {
                    lpwzString[0] = L'\0';
                }
            }
            else
#endif
            if( dwType != REG_SZ )
            {
                lpwzString[0] = L'\0';
            }
        }
        RegCloseKey( hKeyOpen );
    }
    return lResult;
}

#ifndef UNDER_CE

static HRESULT GetRegStringA( HKEY hKey, LPCSTR lpSubKey, LPSTR lpValueName, LPSTR lpszString )
{
    HKEY  hKeyOpen;
    DWORD dwType;
    DWORD dwCbData;
    LONG  lResult;

    lpszString[0] = '\0';
    lResult = RegOpenKeyEx( hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hKeyOpen );
    if( lResult == ERROR_SUCCESS )
    {
        dwCbData = MAX_PATH;
        lResult = RegQueryValueExA( hKeyOpen, lpValueName, NULL, &dwType, (LPBYTE)lpszString, &dwCbData );
        if( lResult != ERROR_SUCCESS )
        {
            lpszString[0] = '\0';
        }
        else
        {
            if( dwType == REG_EXPAND_SZ )
            {
                char szTemp[MAX_PATH];
                if( ExpandEnvironmentStringsA( lpszString, szTemp, MAX_PATH ) )
                {
                    strcpy(lpszString, szTemp);
                }
                else
                {
                    lpszString[0] = '\0';
                }
            }
            else if( dwType != REG_SZ )
            {
                lpszString[0] = '\0';
            }
        }
        RegCloseKey( hKeyOpen );
    }
    return lResult;
}
#endif

HRESULT CLoader::Init()

{
#ifndef UNDER_CE
    char szGMFile[MAX_PATH];
#endif    
    WCHAR wzGMFile[MAX_PATH];
    // First, get the GM path from the registry, if it exists.
    HRESULT hr;
#ifndef UNDER_CE    
    if( g_fIsUnicode )
#endif
    {
        hr = GetRegStringW( HKEY_LOCAL_MACHINE,
              L"Software\\Microsoft\\DirectMusic",
              L"GMFilePath",
              wzGMFile );
    }
#ifndef UNDER_CE
    else
    {
        hr = GetRegStringA( HKEY_LOCAL_MACHINE,
              "Software\\Microsoft\\DirectMusic",
              "GMFilePath",
              szGMFile );
        mbstowcs(wzGMFile,szGMFile,MAX_PATH);
    }
#endif    
    if (hr == S_OK)
    {
        DMUS_OBJECTDESC DESC;                    // Descriptor to use to find it.
        memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
        DESC.dwSize = sizeof (DMUS_OBJECTDESC);
        DESC.guidClass = CLSID_DirectMusicCollection;  
        wcscpy(DESC.wszFileName,wzGMFile);
        DESC.guidObject = GUID_DefaultGMCollection;
        DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | 
            DMUS_OBJ_FULLPATH | DMUS_OBJ_OBJECT;
        SetObject(&DESC);
    }
    // prepare root node for garbage collection
    assert(!m_pApplicationObject); // this would fail if Init were called twice, which it shouldn't be
    m_pApplicationObject = new CObject(NULL);
    if (!m_pApplicationObject)
        return E_OUTOFMEMORY;
    hr = m_pApplicationObject->GC_Collectable();
    if (FAILED(hr))
    {
        delete m_pApplicationObject;
        m_pApplicationObject = NULL;
        return hr;
    }
    m_pLoadedObjectContext = m_pApplicationObject;

    return S_OK;
}


CLoader::CLoader()
  : m_pLoadedObjectContext(NULL),
    m_pApplicationObject(NULL)
{
    m_fCSInitialized = FALSE;

    InterlockedIncrement(&g_cComponent);
    InitializeCriticalSection(&m_CriticalSection);
    m_fCSInitialized = TRUE;

    m_fPathValid = FALSE;
    m_fKeepObjects = TRUE;
    m_cRef = 1;
    m_cPRef = 0;
    m_fIMA = FALSE;
}

CLoader::~CLoader()

{
    if (m_fCSInitialized)
    {
        // If critical section never initialized, never got a chance
        // to put anything in this list
        //
        while (!m_ClassList.IsEmpty())
        {
            CClass *pClass = m_ClassList.RemoveHead();
            delete pClass;
        }

        while (!m_ReleasedObjectList.IsEmpty())
        {
            CObject *pObject = m_ReleasedObjectList.RemoveHead();
            delete pObject;
        }

        DeleteCriticalSection(&m_CriticalSection);
    }

    delete m_pApplicationObject;

    InterlockedDecrement(&g_cComponent);
}

// CLoader::QueryInterface
//
STDMETHODIMP
CLoader::QueryInterface(const IID &iid,
                                   void **ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IDirectMusicLoader || iid == IID_IDirectMusicLoader8) {
        *ppv = static_cast<IDirectMusicLoader8*>(this);
    }
    else if(iid == IID_IDirectMusicLoader8P)
    {
        *ppv = static_cast<IDirectMusicLoader8P*>(this);
    }
    else if(iid == IID_IDirectMusicIMA)
    {
        *ppv = static_cast<IDirectMusicIMA*>(this);
    }

    if (*ppv == NULL)
        return E_NOINTERFACE;

    reinterpret_cast<IUnknown*>(this)->AddRef();
    return S_OK;
}


// CLoader::AddRef
//
STDMETHODIMP_(ULONG)
CLoader::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CLoader::AddRefP()
{
    return InterlockedIncrement(&m_cPRef);
}

// CLoader::Release
//
STDMETHODIMP_(ULONG)
CLoader::Release()
{
    if (!InterlockedDecrement(&m_cRef)) 
    {
        // Ref count of zero indicates that no objects are currently using the loader except for streams.
        // Streams support the GetLoader method and hence we can't delete the loader yet.  These streams
        //    hold private references (AddRefP/ReleaseP).
        // Since no objects other than those streams are currently being used, we'll clear our cache.
        //    This will release any of the Loader's refs on the streams and (assuming nobody else is
        //    holding the streams) bring the private ref count down to zero so we can delete ourself.

        InterlockedIncrement(&m_cRef);        // Keep streams from deleting loader.
        ClearCacheInternal(GUID_DirectMusicAllTypes, true);
        CollectGarbage();
        if (!InterlockedDecrement(&m_cRef))
        {
            if (!m_cPRef)
            {
                delete this;
                return 0;
            }
        }
    }
    return m_cRef;
}

ULONG CLoader::ReleaseP()
{
    if (!InterlockedDecrement(&m_cPRef)) 
    {
        if (!m_cRef)
        {
            delete this;
            return 0;
        }
    }
    return m_cPRef;
}

HRESULT CLoader::GetClass(CDescriptor *pDesc, CClass **ppClass, BOOL fCreate)

/*    Scan the class list and find the matching class. 
    If the class can not be found AND fCreate is TRUE,
    create a new class.
*/

{
    *ppClass = NULL;
    if ((pDesc->m_dwValidData & DMUS_OBJ_CLASS) == 0) // We must have a valid class id.
    {
        Trace(1, "The class id field is required and missing in the DMUS_OBJECTDESC.\n");
        return DMUS_E_LOADER_NOCLASSID;
    }
    CClass *pClass = m_ClassList.GetHead();
    for (;pClass != NULL;pClass = pClass->GetNext())
    {
        if (pClass->m_ClassDesc.m_guidClass == pDesc->m_guidClass)
        {
            *ppClass = pClass;
            break;
        }
    }
    if (*ppClass == NULL)
    {
        if (fCreate)
        {
            pClass = new CClass(this, pDesc);
            if (pClass)
            {
                m_ClassList.AddHead(pClass);
                *ppClass = pClass;
            }
            else
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
#ifdef DBG
            WCHAR *polestrClsid = NULL;
            if (S_OK != ProgIDFromCLSID(pDesc->m_guidClass, &polestrClsid))
            {
                StringFromCLSID(pDesc->m_guidClass, &polestrClsid);
            }
            if (polestrClsid)
                Trace(1, "There are no objects of type %S in the loader.\n", polestrClsid);
            CoTaskMemFree(polestrClsid);
#endif
            return DMUS_E_LOADER_OBJECTNOTFOUND;
        }
    }
    return S_OK;
}

#ifdef DBG
const int GC_Report_DebugLevel = 4;

void GC_Report(CLoader *pThis)
{
    struct LocalFunc
    {
        static void ReportObject(CObject *pObject, bool fReportGC, CObject *pApplicationObject)
        {
            if (!(pObject->m_dwScanBits & SCAN_GC) == !fReportGC)
            {
                DMUS_OBJECTDESC desc;
                ZeroMemory(&desc, sizeof(desc));
                pObject->m_ObjectDesc.Get(&desc);
                DebugTrace(GC_Report_DebugLevel, "   *%08X %S [%S]\n", pObject, desc.wszName, desc.wszFileName);
                if (!(desc.dwValidData & DMUS_OBJ_LOADED))
                {
                    DebugTrace(GC_Report_DebugLevel, "     Not loaded.\n");
                }

                if (fReportGC)
                {
                    // check if object is referenced by the app
                    for (UINT i = 0; i < pApplicationObject->m_pvecReferences->size(); ++i)
                    {
                        if (pObject == (*pApplicationObject->m_pvecReferences)[i])
                        {
                            DebugTrace(GC_Report_DebugLevel, "     In use by application.\n");
                        }
                    }

                    // output the object's references
                    assert(pObject->m_pvecReferences);
                    for (i = 0; i < pObject->m_pvecReferences->size(); ++i)
                    {
                        CObject *pObjectRef = (*pObject->m_pvecReferences)[i];
                        DMUS_OBJECTDESC descRef;
                        ZeroMemory(&descRef, sizeof(descRef));
                        pObjectRef->m_ObjectDesc.Get(&descRef);
                        DebugTrace(GC_Report_DebugLevel, "     -%08X %S (%S)\n", pObjectRef, descRef.wszName, descRef.wszFileName);
                    }
                }
            }
        }
    };

    SmartRef::CritSec CS(&pThis->m_CriticalSection);

    DebugTrace(GC_Report_DebugLevel, "Cached non-GC contents of DirectMusic Loader:\n");

    // Do two passes.  One to report non-GC items, one to report GC items.
    for (int fReportGC = 0; fReportGC < 2; ++fReportGC)
    {
        for (CClass *pClass = pThis->m_ClassList.GetHead(); pClass != NULL; pClass = pClass->GetNext())
        {
            for (CObject *pObject = pClass->m_ObjectList.GetHead(); pObject; pObject = pObject->GetNext())
            {
                LocalFunc::ReportObject(pObject, !!fReportGC, pThis->m_pApplicationObject);
            }
        }

        DebugTrace(GC_Report_DebugLevel, !fReportGC ? "Cached garbage-collected contents:\n" : "Contents released from the cache that aren't yet garbage or haven't been collected:\n");
    }

    for (CObject *pObject = pThis->m_ReleasedObjectList.GetHead(); pObject; pObject = pObject->GetNext())
    {
        assert(pObject->m_dwScanBits & SCAN_GC);
        LocalFunc::ReportObject(pObject, true, pThis->m_pApplicationObject);
    }

    DebugTrace(GC_Report_DebugLevel, "End of cache report.\n\n");
}
#endif

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | GetObject | Retrieves 
the specified object, potentially by loading it from a file.

@rdesc Returns one of the following

@flag S_OK | Success.
@flag E_OUTOFMEMORY | Insufficient memory to create the object.
@flag E_POINTER | Bad pointer. 
@flag E_INVALIDARG | The size of the passed <p pDESC> was too small.
@flag E_NOINTERFACE | The requested object does not support the requested interface.
@flag REGDB_E_CLASSNOTREG | Object class is not registered.
@flag DMUS_E_LOADER_NOCLASSID | No class id in <t DMUS_OBJECTDESC>.
@flag DMUS_E_LOADER_FAILEDOPEN | File open failed - either file doesn't exist or is locked.
@flag DMUS_E_LOADER_FORMATNOTSUPPORTED | Search data type is not supported.
@flag DMUS_E_LOADER_FAILEDCREATE | Unable to find or create object.
For example, DMUS_OBJ_URL will return this error in the initial
release of DirectMusic's loader.

@comm This is the heart of the DirectMusicLoader system. Typically, you
can use <om IDirectMusicLoader::GetObject> as a quick way to load
objects from disk. To do so, create a <t DMUS_OBJECTDESC> structure and
fill all appropriate fields. Usually, the file path will suffice,
though you can also request an object by name or GUID. 

<om IDirectMusicLoader::GetObject> compares its internal
database with the object described by <t DMUS_OBJECTDESC>. If it can
find it, it loads the object and returns a pointer to the 
requested interface of the requested object (all
DirectMusic compatible objects must implement an <i IDirectMusicObject>
interface as well as an <i IPersistStream> interface for loading
from a stream.)

<om IDirectMusicLoader::GetObject> prioritizes its search as follows:
1. DMUS_OBJ_OBJECT, 
2. DMUS_OBJ_FILENAME AND DMUS_OBJ_FULLPATH,
3. DMUS_OBJ_NAME AND DMUS_OBJ_CATEGORY,
4. DMUS_OBJ_NAME,
5. DMUS_OBJ_FILENAME

In other words, the highest priority goes to a unique GUID, followed by
the full file path name, followed by internal name plus category,
followed by internal name, followed by local file name.

@ex The following example uses <om IDirectMusicLoader::GetObject> to
load a DirectMusic style from a file on disk: |

    void myLoadStyle(
        IDirectMusicStyle **ppIStyle)        // Style that we wish to load.
    {
        IDirectMusicLoader *pILoader;        // Loader interface.

        // Typically, you should create the loader once, and use it
        // for the duration of the application. This reduces overhead and
        // takes advantage of the loader's ablilty to cache objects.
        // However, for purposes of this example, we create it dynamically
        // and throw it away once the style is loaded.

        CoCreateInstance(
            CLSID_DirectMusicLoader,NULL, 
            CLSCTX_INPROC_SERVER,
            IID_IDirectMusicLoader,
            (void **) &pILoader);

        if (pILoader)
        {
            DMUS_OBJECTDESC Desc;           // Descriptor.

            // Start by initializing Desc with the file name and GUID
            // for style object.

            wcscpy(Desc.wszFileName,L"c:\\mymusic\\funky\\polka.sty");
            Desc.guidClass = CLSID_DirectMusicStyle;   // Style class.
            Desc.dwSize = sizeof (DMUS_OBJECTDESC);
            Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH;

            pILoader->GetObject(&Desc, IID_IDirectMusicStyle, (void**) ppIStyle);
            pILoader->Release();
        }
    }

    // At this point, the style is loaded is returned in ppIStyle.

@xref <i IDirectMusicLoader>, <i IDirectMusicObject>, <t DMUS_OBJECTDESC>
*/

STDMETHODIMP CLoader::LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
                                            WCHAR *pwzFilePath, 
                                            void ** ppObject)

{
    V_INAME(IDirectMusicLoader8::LoadObjectFromFile);
    V_BUFPTR_READ(pwzFilePath,2);

    HRESULT hr;
    DMUS_OBJECTDESC DESC;
    DESC.dwSize = sizeof (DESC);
    DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH;
    wcscpy(DESC.wszFileName,pwzFilePath);
    DESC.guidClass = rguidClassID;  
    hr = GetObject(&DESC, iidInterfaceID, ppObject);
    if (FAILED(hr))
    {
        DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
        hr = GetObject(&DESC, iidInterfaceID, ppObject);
    }
    return hr;
}


STDMETHODIMP CLoader::GetObject(
    LPDMUS_OBJECTDESC pDESC,    // @parm Description of the requested object in <t DMUS_OBJECTDESC> structure.
    REFIID riid, //@parm The interface to return in <p ppv>
    LPVOID FAR *ppv)    // @parm Receives the interface on success.

{
    HRESULT hr = S_OK;
    HRESULT hrLoad = S_OK;
    CDescriptor Desc;

    V_INAME(IDirectMusicLoader::GetObject);
//    V_STRUCTPTR_READ(pDESC,DMUS_OLDOBJECTDESC); 
    V_PTRPTR_WRITE(ppv);

    IStream *pStream = pDESC->dwValidData & DMUS_OBJ_STREAM ? pDESC->pStream : NULL;
    if (pStream)
    {
        V_INTERFACE(pStream);
    }

    // if pDESC has DMUS_OBJ_FULLPATH set, set DMUS_OBJ_FILENAME as well.
    if( pDESC->dwValidData & DMUS_OBJ_FULLPATH )
    {
        pDESC->dwValidData |= DMUS_OBJ_FILENAME;
    }
    IDirectMusicObject* pDMObj;
    EnterCriticalSection(&m_CriticalSection);
    CClass *pClass;
    CObject *pObject = NULL;

    if (pStream)
    {
        // The loader will save a cloned stream so that it doesn't interfere with
        // the application reading from the stream.
        // Don't worry -- then we'll restore the original stream pointer.
        hr = pStream->Clone(&pDESC->pStream);
        if(FAILED(hr))
        {
            return E_OUTOFMEMORY;
        }
    }
    
    Desc.Set(pDESC);
    if (pStream)
    {
        // Restore the stream in the descriptor we were passed.
        pDESC->pStream->Release(); // release matching call to Clone (ref is now held in descriptor)
        pDESC->pStream = pStream;
    }

    hr = GetClass(&Desc,&pClass, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pClass->GetObject(&Desc,&pObject);
        if (SUCCEEDED(hr))
        {
            bool fKeep = !!pClass->m_fKeepObjects;
            bool fGC = fKeep && m_pLoadedObjectContext && m_pLoadedObjectContext->m_dwScanBits & SCAN_GC;

            if (pObject->m_pIDMObject) // Already loaded!
            {
                pObject->m_pIDMObject->AddRef();
                pDMObj = pObject->m_pIDMObject;
                hr = S_OK;
            }
            else
            {
                CObject *pPrevContext;
                if (fGC)
                {
                    // Save a pointer to the current object that will be used to track that it is
                    // the source object if nested calls to GetObject occur while it is loaded.
                    pPrevContext = m_pLoadedObjectContext;
                    m_pLoadedObjectContext = pObject;

                    // Set this object as garbage-collectable.
                    if (pObject->m_ObjectDesc.m_guidObject != GUID_DefaultGMCollection) // don't cache GM DLS set
                        hr = pObject->GC_Collectable();
                }
                if (SUCCEEDED(hr))
                    hrLoad = hr = pObject->Load();
                if (fGC)
                {
                    // Restore the context that was used to load this object.
                    m_pLoadedObjectContext = pPrevContext;
                }

#ifdef DBG
                if (FAILED(hrLoad) || m_pLoadedObjectContext == m_pApplicationObject)
                {
                    DebugTraceLoadFailure(pObject, hrLoad);
                }
#endif

                if (SUCCEEDED(hr))
                {
                    pDMObj = pObject->m_pIDMObject;
                    if (fKeep)
                    {
                        pObject->m_pIDMObject->AddRef();
                    }
                    else
                    {
                        pObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
                        pObject->m_pIDMObject = NULL;
                    }
                }
            }

            if (SUCCEEDED(hr) && fGC)
            {
                assert(m_pLoadedObjectContext);
                hr = m_pLoadedObjectContext->GC_AddReference(pObject);
            }

            if (FAILED(hr))
            {
                // This happens if either GC_AddReference or Load fails.
                pClass->RemoveObject(pObject);
                pObject = NULL;
                if (Desc.m_dwValidData & DMUS_OBJ_URL)
                {
                    Trace(1, "Error: Attempt to load an object via DMUS_OBJ_URL failed because the DirectMusic Loader doesn't currently support loading objects by URL.");
                    hr = DMUS_E_LOADER_FORMATNOTSUPPORTED;
                }
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }
    }
    LeaveCriticalSection(&m_CriticalSection);
    if( SUCCEEDED(hr) )
    {
        hr = pDMObj->QueryInterface( riid, ppv );
        pDMObj->Release();
    }
    if( E_FAIL == hr )
    {
        hr = DMUS_E_LOADER_FAILEDCREATE;
    }

#ifdef DBG
    // After each top-level call to GetObject, report to debug output the contents of the cache.
    if (m_pLoadedObjectContext == m_pApplicationObject)
        GC_Report(this);
#endif

    if( SUCCEEDED(hr) )
    {
        return hrLoad;
    }
    else
    {
        return hr;
    }
}

STDMETHODIMP CLoader::SetObject(
    LPDMUS_OBJECTDESC pDESC)

{
    HRESULT hr = S_OK;
    HRESULT hrLoad = S_OK;
    CDescriptor Desc;

    V_INAME(IDirectMusicLoader::SetObject);
    V_STRUCTPTR_READ(pDESC,DMUS_OLDOBJECTDESC);

    IStream *pStream = NULL;
    if (pDESC->dwValidData & DMUS_OBJ_STREAM)
    {
        // Save the stream we were passed and verify it is a valid interface.
        pStream = pDESC->pStream;
        V_INTERFACE(pStream);

        // The loader will save a cloned stream so that the caller can contine
        // using the passed stream without intefering with the loader.
        // Don't worry -- we'll restore the original stream pointer before returning.
        hr = pStream->Clone(&pDESC->pStream);
        if (FAILED(hr))
            return hr;
    }

    // if pDESC has DMUS_OBJ_FULLPATH set, set DMUS_OBJ_FILENAME as well.
    if( pDESC->dwValidData & DMUS_OBJ_FULLPATH )
    {
        pDESC->dwValidData |= DMUS_OBJ_FILENAME;
    }
    EnterCriticalSection(&m_CriticalSection);
    CClass *pClass;
    Desc.Set(pDESC);
    hr = GetClass(&Desc,&pClass, TRUE);
    if (SUCCEEDED(hr))
    {
        CObject *pObject;
        hr = pClass->GetObject(&Desc,&pObject);
        if (SUCCEEDED(hr))
        {
            if (Desc.m_dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM))
            {
                pObject->m_ObjectDesc.m_dwValidData &= 
                    ~(DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM);
            }
            // Merge in any new things we've added
            pObject->m_ObjectDesc.Merge(&Desc);
            if (pObject->m_ObjectDesc.m_dwValidData & 
                (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM))
            {
                // If we can actually load this, have it give us its internal data.
                hr = pObject->Parse();
            }
            // Return the data.
            pObject->m_ObjectDesc.Get(pDESC);
        }
    }

    if (pStream)
    {
        // Restore the stream information in the descriptor we were passed.

        // Get will have cleared the stream bit (ordinarily we don't want to be returning these streams out of the loader).
        pDESC->dwValidData |= DMUS_OBJ_STREAM;
        // The stream pointer was changed to the cloned stream.
        pDESC->pStream->Release(); // release matching call to Clone (ref is now held in merged descriptor)
        pDESC->pStream = pStream;
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | SetSearchDirectory | 
Sets a search path for finding object files. The search path can be set for
one object file type, or, alternatively, all files.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | The search directory was already set to the requested path.
@flag E_POINTER | Bad pointer passed in <p pszPath>.
@flag DMUS_E_LOADER_BADPATH | Path is invalid.
@flag E_OUTOFMEMORY | Running low on memory, unable to complete task.

@comm Once a search path is set, the loader does not need a full path
every time it is given an object to load by file name. 
However, the loader does not automatically becomes
aware of all files of the requested type within the search 
directory. After calling <om IDirectMusicLoader::SetSearchDirectory>,
call <om IDirectMusicLoader::ScanDirectory> to scan the
directory for all 
files of the requested class and compile a list of them. 
Once this is done, you can easily find
files within the directory by object name, or GUID, as well as 
file name.

@ex The following example sets the search path for style files, then
loads a style by file name. Although this seems a little redundant 
(it's simpler to just use the full path name), 
objects that indirectly reference other objects can
find them by file name without knowing the full path: |

    // The first function calls SetSearchDirectory to set the path.
    // All subsequant calls to load objects in the application
    // no longer need to know the full path.

    HRESULT mySetLoaderPath (
        IDirectMusicLoader *pILoader)    // Loader interface, previously created.
    {
        return pILoader->SetSearchDirectory(CLSID_DirectMusicStyle,
            L"c:\\mymusic\\funky",FALSE);
    }

    //    Later, the application wants to load a style by 
    //    local file name.


    HRESULT myLoadStyleFromPath (
        IDirectMusicStyle **ppIStyle,    // Style to load.
        IDirectMusicLoader *pILoader)    // Loader.
    {
        HRESULT hr;

        DMUS_OBJECTDESC Desc;           // Descriptor.

        // Start by initializing Desc with the local file name for the object.

        wcscpy(Desc.wszName,L"Polka");    // Name is wide char format.
        wcscpy(Desc.wszFileName,L"polka.sty");    // Use file name without full path.
        Desc.guidClass = CLSID_DirectMusicStyle;   // Style class.
        Desc.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FILENAME;
        Desc.dwSize = sizeof (DMUS_OBJECTDESC);

        hr = pILoader->GetObject(&Desc, IID_IDirectMusicStyle, (void**) ppIStyle);
        return hr;
    }

@xref <i IDirectMusicLoader>, <i IDirectMusicObject>,
<om IDirectMusicLoader::GetObject>,
<om IDirectMusicLoader::ScanDirectory>,
<om IDirectMusicLoader::EnumObject>
*/
STDMETHODIMP CLoader::SetSearchDirectory(
    REFCLSID rguidClass,    // @parm Class id identifies which clas of objects this pertains to.
                    // Optionally, GUID_DirectMusicAllTypes specifies all classes. 
    WCHAR *pwzPath, // @parm File path for directory. Must be a valid directory and
                    // must be less than MAX_PATH in length.
    BOOL fClear)    // @parm If TRUE, clears all information about objects
                    // prior to setting directory. 
                    // This helps avoid accessing objects from the
                    // previous directory that may have the same name.
                    // However, this will not remove cached objects.
                                        
{


    V_INAME(IDirectMusicLoader::SetSearchDirectory);
    if (pwzPath)
    {
        V_BUFPTR_READ(pwzPath,2);
    }

    HRESULT hr = DMUS_E_LOADER_BADPATH;
    WCHAR wzMaxPath[MAX_PATH];

    if (pwzPath == NULL)
    {
        return E_POINTER;
    }
    wcscpy( wzMaxPath, pwzPath );
    if( wzMaxPath[wcslen( wzMaxPath ) - 1] != '\\' )
    {
        wcscat( wzMaxPath, L"\\" );
    }
    DWORD dwAttrib;
    if (g_fIsUnicode)
    {
        dwAttrib= GetFileAttributesW(wzMaxPath); 
    }
    else
    {
        char szPath[MAX_PATH];
        wcstombs( szPath, wzMaxPath, MAX_PATH );
        dwAttrib= GetFileAttributesA(szPath); 
    }
    if ((dwAttrib != 0xFFFFFFFF) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        EnterCriticalSection(&m_CriticalSection);
        if (rguidClass == GUID_DirectMusicAllTypes)
        {
            CClass *pClass = m_ClassList.GetHead();
            hr = S_OK;
            for (;pClass != NULL;pClass = pClass->GetNext())
            {
                if( S_FALSE == pClass->SetSearchDirectory(wzMaxPath,fClear))
                {
                    hr = S_FALSE;
                }
            }
            wcsncpy(m_wzPath,wzMaxPath,DMUS_MAX_FILENAME);
            m_fPathValid = TRUE;
        }
        else
        {
            CClass *pClass;
            CDescriptor Desc;
            Desc.m_guidClass = rguidClass;
            Desc.m_dwValidData = DMUS_OBJ_CLASS;
            hr = GetClass(&Desc,&pClass,TRUE);
            if (SUCCEEDED(hr))
            {
                hr = pClass->SetSearchDirectory(wzMaxPath,fClear);
            }
        }
        LeaveCriticalSection(&m_CriticalSection);
    }

#ifdef DBG
    if (hr == DMUS_E_LOADER_BADPATH)
    {
        Trace(1, "Error: SetSearchDirectory failed because '%S' is not a valid directory.\n", pwzPath);
    }
#endif

    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ScanDirectory | 
Searches a directory on disk for all files of a requested
class type and file extension. Once a directory has been scanned, all
files of the requested type become available for viewing with 
<om IDirectMusicLoader::EnumObject>.

Prior to calling <om IDirectMusicLoader::ScanDirectory>,
<om IDirectMusicLoader::SetSearchDirectory> must be called
first to set the location to search. 

Once a search path has been scanned, the loader automatically becomes
aware of all files within the search directory, and can easily find
files within that directory by object name, file name, or GUID.

Optionally, the scanned information can be stored in a 
cache file, defined by <p pszCacheFileName>. Once it has been
so stored, subsequant calls to <om IDirectMusicLoader::ScanDirectory>
are much quicker, because only files that have changed
are scanned (the cache file stores the file size and date for
each object, so it can identify if a file has changed.)

@comm If the file type has more than one extension, 
just call   
<om IDirectMusicLoader::ScanDirectory> multiple
times, once for each file extension.
  
<om IDirectMusicLoader::ScanDirectory> doesn't know
how to parse a particular object class's file and read 
the name, guid, and other information that retieves to idenity
files by. Instead, it lets the <i IDirectMusicObject> do the work, 
by calling the 
<om IDirectMusicObject::ParseDescriptor> method 
for the requested object type.


@rdesc Returns one of the following

@flag S_OK | Success.
@flag S_FALSE | Scanned, but no files.
@flag E_POINTER | Bad pointer passed in <p pszFileExtension> or <p pszCacheFileName>.
@flag DMUS_E_NOT_FOUND | Path is invalid.
@flag E_OUTOFMEMORY | Running low on memory, unable to complete task.
@flag REGDB_E_CLASSNOTREG | Object class is not registered, can't read files.

@ex The following example sets the search path for style files, scans the directory,
then uses the EnumObject call to display all available style files: |

    // First, scan the directory for all style files.

    void myScanDirectory(
        IDirectMusicLoader *pILoader)    // Loader.

    {
        HRESULT hr = pILoader->SetSearchDirectory(
            CLSID_DirectMusicStyle,L"c:\\mymusic\\wassup",TRUE);
        if (SUCCEEDED(hr))
        {
            hr = pILoader->ScanDirectory(
                CLSID_DirectMusicStyle,L"sty",L"stylecache");
            if (hr == S_OK)    // Only if files were found...
            {
                DWORD dwIndex;
                DMUS_OBJECTDESC Desc;
                Desc.dwSize = sizeof(DMUS_OBJECTDESC);
                for (dwIndex = 0; ;dwIndex++)
                {
                    if (S_OK ==(pILoader->EnumObject(CLSID_DirectMusicStyle,
                                               dwIndex,&Desc)))
                    {
                        TRACE("Name: %S, Category: %S, Path: %S\n",
                            Desc.wszName,Desc.wszCategory,Desc.wszFileName);
                    }
                    else break;
                }
            }
        }
    }


@xref <i IDirectMusicLoader>, <i IDirectMusicObject>,
<om IDirectMusicLoader::GetObject>,
<om IDirectMusicLoader::EnumObject>, <om IDirectMusicLoader::SetSearchDirectory>
*/

STDMETHODIMP CLoader::ScanDirectory(
    REFCLSID rguidClass,    // @parm Class id identifies which class of objects this pertains to.
    WCHAR *pszFileExtension,// @parm File extension for type of file to look for. 
                            // For example, L"sty" for style files. L"*" will look in all
                            // files. L"" or NULL will look for files without an
                            // extension.
    WCHAR *pszCacheFileName    // @parm Optional storage file to store and retrieve
                            // cached file information. This file is created by 
                            // the first call to <om IDirectMusicLoader::ScanDirectory>
                            // and used by subsequant calls. NULL if cache file
                            // not desired.
)

{

    V_INAME(IDirectMusicLoader::ScanDirectory);
    if (pszFileExtension)
    {
        V_BUFPTR_READ(pszFileExtension,2);
    }
    if (pszCacheFileName)
    {
        V_BUFPTR_READ(pszCacheFileName,2);
    }

    HRESULT hr = S_OK;
    //    First, mark all currently stored objects prior to scanning.
    CClass *pClass = m_ClassList.GetHead();
    for (;pClass != NULL;pClass = pClass->GetNext())
    {    
        pClass->PreScan();
    }
    if (pszCacheFileName != NULL)
    {
        LoadCacheFile(pszCacheFileName);
    }
    if (rguidClass == GUID_DirectMusicAllTypes)
    {
        Trace(1, "Error: ScanDirectory requires the clsid of a specific type of object to scan for. GUID_DirectMusicAllTypes is not valid.\n");
        return REGDB_E_CLASSNOTREG;
    }
    else
    {
        CDescriptor Desc;
        Desc.m_guidClass = rguidClass;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        EnterCriticalSection(&m_CriticalSection);
        GetClass(&Desc,&pClass,TRUE);
        if (pClass)
        {
            if( pszFileExtension )
            {
                hr = pClass->SearchDirectory(pszFileExtension);
            }
            else
            {
                hr = pClass->SearchDirectory(L"");
            }
//            if( hr == E_FAIL ) hr = DMUS_E_NOT_FOUND;
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    if (pszCacheFileName != NULL)
    {
        SaveCacheFile(pszCacheFileName);
    }    
    return hr;
}

HRESULT CLoader::FindObject(CDescriptor *pDesc, CClass **ppClass, CObject ** ppObject)

// Scan through the classes and objects to find the object. 

{
    assert(pDesc);
    HRESULT hr = GetClass(pDesc,ppClass,FALSE);
    if (SUCCEEDED(hr))
    {
        hr = (*ppClass)->FindObject(pDesc,ppObject);
#ifdef DBG
        if (hr == DMUS_E_LOADER_OBJECTNOTFOUND)
        {
            DMUS_OBJECTDESC desc;
            ZeroAndSize(&desc);
            pDesc->Get(&desc);
            Trace(1, "Error: The following object could not be found in the loader: ");
            DebugTraceObject(&desc);
        }
#endif
    }
    return hr;
}

// Find the object in the cache.  S_FALSE if not loaded.  Error if not found.
HRESULT CLoader::FindObject(IDirectMusicObject *pIDMObject, CObject ** ppObject)

{
    // Potential optimization:
    //    The linear search to find the object could be eliminated by using
    // an efficient lookup structure such as a hash table.

    assert(pIDMObject && ppObject);

    HRESULT hr = S_OK;

    DMUS_OBJECTDESC DESC;
    ZeroMemory( &DESC, sizeof(DMUS_OBJECTDESC) );
    DESC.dwValidData = 0;
    DESC.dwSize = sizeof (DMUS_OBJECTDESC);

    hr = pIDMObject->GetDescriptor(&DESC);
    if (FAILED(hr))
        return hr;

    CDescriptor Desc;
    Desc.Set(&DESC);
    SmartRef::CritSec CS(&m_CriticalSection);
    CClass *pClass;
    CObject *pCObject;
    hr = FindObject(&Desc,&pClass,&pCObject);
    if (FAILED(hr))
        return hr;

    assert(pCObject);
    if (pCObject->m_pIDMObject == pIDMObject)
    {
        *ppObject = pCObject;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | CacheObject | 
Tells the loader to keep a reference to the object. This guarantees
that the object will not be loaded twice.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | Object already cached.
@flag E_POINTER | Bad pointer passed in <p pIObject>.
@flag DMUS_E_LOADER_OBJECTNOTFOUND | Object was not found.

@comm If you have an object that will be accessed in multiple places
throughout the life of your program, letting the loader cache the object
can significantly speed performance. 

Alternatively, tell the loader to automatically cache all objects of
a particular type with a call to 
<om IDirectMusicLoader::EnableCache>.

Remove the reference later with a call to 
<om IDirectMusicLoader::ReleaseObject> or 
<om IDirectMusicLoader::ClearCache>.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::ReleaseObject>,
<om IDirectMusicLoader::ClearCache>
*/
STDMETHODIMP CLoader::CacheObject(
    IDirectMusicObject * pObject)    // @parm Object to cache.

{
    HRESULT hr;
    DMUS_OBJECTDESC DESC;
    ZeroMemory( &DESC, sizeof(DMUS_OBJECTDESC) );
    DESC.dwSize = sizeof (DMUS_OBJECTDESC);

    V_INAME(IDirectMusicLoader::CacheObject);
    V_INTERFACE(pObject);

    if (pObject == NULL)
    {
        return E_POINTER;
    }
    DESC.dwValidData = 0;
    hr = pObject->GetDescriptor(&DESC);
    if (SUCCEEDED(hr))
    {
        CDescriptor Desc;
        Desc.Set(&DESC);
        CClass *pClass;
        CObject *pCObject;
        ::EnterCriticalSection(&m_CriticalSection);
        hr = FindObject(&Desc,&pClass,&pCObject);
        if (SUCCEEDED(hr))
        {
            if (pCObject->m_pIDMObject && (pCObject->m_pIDMObject != pObject))
            {
                pCObject->m_pIDMObject->Release();
                pCObject->m_pIDMObject = NULL;
            }
            if (pCObject->m_pIDMObject != pObject)
            {
                pCObject->m_pIDMObject = pObject;
                pCObject->m_ObjectDesc.m_dwValidData |= DMUS_OBJ_LOADED;
                pObject->AddRef();
            }
            else
            {
                hr = S_FALSE;
            }
        }
        ::LeaveCriticalSection(&m_CriticalSection);
    }
/*    if( E_FAIL == hr ) // Should never happen...
    {
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    }*/
    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ReleaseObject | 
Tells the loader to release its reference to the object. 

@rdesc Returns one of the following

@flag S_OK | Success
@flag E_POINTER | Bad pointer passed in <p pIObject>.
@flag DMUS_E_LOADER_OBJECTNOTFOUND | Object was not found or was already released.

@comm <om IDirectMusicLoader::ReleaseObject> is the reciprocal
of <om IDirectMusicLoader::CacheObject>.

Objects can be cached explicitly via 
<om IDirectMusicLoader::CacheObject>,
or automatically via <om IDirectMusicLoader::EnableCache>.

To tell the loader to flush all objects of
a particular type, call
<om IDirectMusicLoader::ClearCache>.
 
@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ClearCache>
*/
STDMETHODIMP CLoader::ReleaseObject(
    IDirectMusicObject * pObject)    // @parm Object to release.

{

    V_INAME(IDirectMusicLoader::ReleaseObject);
    V_INTERFACE(pObject);

    HRESULT hr = S_OK;
    CObject *pCObject = NULL;
    SmartRef::CritSec CS(&m_CriticalSection);

    hr = FindObject(pObject, &pCObject);
    // Removed the following because it causes a regression from DX7, even though it is the better return.
//    if (hr == S_FALSE)
//        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    if (hr == S_OK)
    {
        if (pCObject->m_dwScanBits & SCAN_GC)
        {
            // Other objects may have references to this one so we need to keep this object around
            // and track its references.  We'll hold onto the DMObject pointer too because we may
            // later need to Zombie the object in order to break a cyclic reference.

            // We'll place an unloaded object with a duplicate descriptor in the cache to match the
            // non-GC behavior and then move the original object into a list of released objects that
            // will eventually be reclaimed by CollectGarbage.

            // Potential optimization:
            //   Here we re-iterate to remove from the list when we just iterated during FindObject.
            // Returning more info from FindObject, expanding it into this function, or using some
            // other technique would make this operation twice as fast.

            hr = pCObject->GC_RemoveAndDuplicateInParentList();
            if (FAILED(hr))
                return hr;

            GC_UpdateForReleasedObject(pCObject);
        }
        else
        {
            pCObject->m_pIDMObject->Release();
            pCObject->m_pIDMObject = NULL;
            pCObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
        }
    }

    return hr;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | ClearCache | 
Tells the loader to release all references to a particular type
of object.  

@rdesc Returns just

@flag S_OK | Always succeeds

@comm <om IDirectMusicLoader::ClearCache> clears all objects
that are currently being held. However, if caching is enabled
via <om IDirectMusicLoader::EnableCache>, this does not
turn off caching so future file loads will continue to be cached.

Use <om IDirectMusicLoader::ReleaseObject> to release a specific
object.

Call <om IDirectMusicLoader::EnableCache> to turn off automatic
caching.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::EnableCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>
*/
STDMETHODIMP CLoader::ClearCache(
    REFCLSID rguidClass)    // @parm Class id identifies which class of objects to clear.
                    // Optionally, GUID_DirectMusicAllTypes specifies all types. 

{
    return ClearCacheInternal(rguidClass, false);
}

HRESULT CLoader::ClearCacheInternal(
    REFCLSID rguidClass,
    bool fClearStreams)

{
    SmartRef::CritSec CS(&m_CriticalSection);

    HRESULT hr = S_OK;
    CClass *pClass;
    if (rguidClass == GUID_DirectMusicAllTypes)
    {
        pClass = m_ClassList.GetHead();
        for (;pClass != NULL;pClass = pClass->GetNext())
        {
            hr = pClass->ClearCache(fClearStreams);
            if (FAILED(hr))
                return hr;
        }        
    }
    else
    {
        CDescriptor Desc;
        Desc.m_guidClass = rguidClass;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        GetClass(&Desc,&pClass,FALSE);
        if (pClass)
        {
            hr = pClass->ClearCache(fClearStreams);
            if (FAILED(hr))
                return hr;
        }
    }
    return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | EnableCache | 
Tells the loader to enable or disable automatic caching of
objects it loads. By default, caching is enabled for all
object classes. 

Once caching is enabled with a call to 
<om IDirectMusicLoader::EnableCache>, the loader keeps a reference to
all objects it loads subsequently,
either directly or indirectly (via a referenced load, for example, a
Section Segment that references a Style).

<om IDirectMusicLoader::EnableCache> can also be used to disable
caching by setting <p fEnable> to FALSE. Before disabling caching, think
twice. Caching is used extensively in the file loading process to 
resolve links to objects. If an object is not found in the cache, it
has to be reloaded, even if it already exists. For example, two segments
could reference the same style. When the first segment loads, it calls the
loader to get the style, which in turn creates a style, loads it from disk,
stores a pointer to the style in the cache, and returns it to the segment.
When the second segment loader, it asks for the style and the loader immediately
returns it, so both segments point to the same style. If caching is disabled, 
the second segment's request for the style results in a duplicate style
loaded from the file. This is very inefficient.

Another example: <i IDirectMusicBand> counts on the loader to keep the 
GM DLS collection cached. Every time it comes across a general MIDI instrument,
it gets the GM DLS collection from the loader by requesting it with 
GUID_DefaultGMCollection. If caching for CLSID_DirectMusicCollection is
disabled, every patch change in a general MIDI file will result in a
seperate copy of the entire GM collection being created! Not good!

However, with judicious use of <om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>, and <om IDirectMusicLoader::EnableCache>,
you can have the objects you don't need released, while others stick around 
in the cache.
 
To clear the cache without disabling caching, call 
<om IDirectMusicLoader::ClearCache>.

@ex The following example disables caching for just segment objects, so they
don't stay in memory after the application releases them. Yet, other objects
that should be shared, like styles, personalities and DLS collections, continue
to be cached. |

    void myPrepareLoader(IDirectMusicLoader *pILoader)
    
    {
        pILoader->EnableCache(GUID_DirectMusicAllTypes, TRUE);
        pILoader->EnableCache(CLSID_DirectMusicSegment, FALSE);
    }
        
@rdesc Returns just

@flag S_OK | Success.
@flag S_FALSE | The cache was already in the requested state.

@xref <i IDirectMusicLoader>, <om IDirectMusicLoader::ClearCache>,
<om IDirectMusicLoader::CacheObject>,
<om IDirectMusicLoader::ReleaseObject>
*/
STDMETHODIMP CLoader::EnableCache(
    REFCLSID rguidClass,    // @parm Class id identifies which class of objects to cache.
                    // Optionally, GUID_DirectMusicAllTypes specifies all types. 
    BOOL fEnable)    // @parm TRUE to enable caching, FALSE to clear and disable.

{
    CClass *pClass;
    HRESULT hr = S_OK;
    if (rguidClass == GUID_DirectMusicAllTypes)
    {
        pClass = m_ClassList.GetHead();
        for (;pClass != NULL;pClass = pClass->GetNext())
        {
            if( S_FALSE == pClass->EnableCache(fEnable))
            {
                hr = S_FALSE;
            }
        }
        m_fKeepObjects = fEnable;
    }
    else
    {
        CDescriptor Desc;
        Desc.m_guidClass = rguidClass;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        GetClass(&Desc,&pClass,TRUE);
        if (pClass)
        {
            if( S_FALSE == pClass->EnableCache(fEnable))
            {
                hr = S_FALSE;
            }
        }
    }
    return hr;
}
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicLoader | EnumObject | 
Enumerate through all available objects of the requested type. 

@rdesc Returns one of the following

@flag S_OK | Found object at request index.
@flag S_FALSE | Reached end of list.

@ex Use <om IDirectMusicLoader::EnumObject> to walk through all styles
that are already referenced by the loader. These might have been prepared
with a call to <om IDirectMusicLoader::ScanDirectory> or loaded
individually. |

    void myDisplayStyles(
        IDirectMusicLoader *pILoader)

    {
        DWORD dwIndex;
        DMUS_OBJECTDESC Desc;
        Desc.dwSize = sizeof(DMUS_OBJECTDESC);
        for (dwIndex = 0; ;dwIndex++)
        {
            if (S_OK ==(pILoader->EnumObject(CLSID_DirectMusicStyle,
                                       dwIndex,&Desc)))
            {
                TRACE("Name: %S, Category: %S, Path: %S\n",
                    Desc.wszName,Desc.wszCategory,Desc.wszFileName);
            }
            else break;
        }
    }

@xref <i IDirectMusicLoader>, <t DMUS_OBJECTDESC>

*/
STDMETHODIMP CLoader::EnumObject(
    REFCLSID rguidClass,            // @parm Class ID for class of objects to view. 
    DWORD dwIndex,            // @parm Index into list. Typically, starts with 0 and increments.
    LPDMUS_OBJECTDESC pDESC)    // @parm <t DMUS_OBJECTDESC> structure to be filled with data about object.
                                       
{
    HRESULT hr;
    CClass *pClass;
    CDescriptor Desc;

    V_INAME(IDirectMusicLoader::EnumObject);
    V_STRUCTPTR_WRITE(pDESC,DMUS_OLDOBJECTDESC);

    Desc.m_guidClass = rguidClass;
    Desc.m_dwValidData = DMUS_OBJ_CLASS;
    EnterCriticalSection(&m_CriticalSection);
    hr = GetClass(&Desc,&pClass,TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pClass->EnumerateObjects(dwIndex, &Desc);
        Desc.Get(pDESC);
    }
    LeaveCriticalSection(&m_CriticalSection);
    return hr;
}

void
CLoader::GC_Mark(CObject *pObject)
{
    // mark pObject and everything it references
    GC_TraverseHelper(pObject, NULL, true);
}

bool
CLoader::GC_HasCycle(CObject *pObject)
{
    // see if pObject has a cyclical reference
    bool fFound = GC_TraverseHelper(pObject, pObject, true);
    // the search left marks while traversing, so clear them
    GC_TraverseHelper(pObject, pObject, false);
    return fFound;
}

// Function used to recursively traverse references.
// pObject:            Root to start the search from.
// pObjectToFind:    Stop marking and return true if a reference to this object is encountered.
//                    (Can be the same as pObject without being considered a match unless pObject has a reference to itself.)
// fMark:            If true, objects are marked as they are visited.  If false, the opposite occurs, clearing marks.
bool
CLoader::GC_TraverseHelper(CObject *pObject, CObject *pObjectToFind, bool fMark)
{
    // Potential optimization:
    //    This could be written using an explicit stack instead of recursion and
    // it might be significantly faster.  If this were done then this algorithm should
    // also be changed to use a fixed-size stack.  If the stack is exhausted, the
    // object would be marked as unexamined and these unexamined objects would be
    // marked in later passes.  However, since that's getting unnecessarily complex
    // we'll stick with recursion unless it proves to be a problem.

    if (!pObject || !(pObject->m_dwScanBits & SCAN_GC) || !pObject->m_pvecReferences)
    {
        Trace(1, "Error: Unexpected error encountered during garbage collection.\n");
        return false;
    }
    if (!!(pObject->m_dwScanBits & SCAN_GC_MARK) == fMark)
        return false; // already done

    if (fMark)
        pObject->m_dwScanBits |= SCAN_GC_MARK;
    else
        pObject->m_dwScanBits &= ~SCAN_GC_MARK;

    SmartRef::Vector<CObject*> &vecRefs = *pObject->m_pvecReferences;
    const UINT iEnd = vecRefs.size();

    // While we iterate over the references, we're going to write them back into the
    // vector, compacting away any NULL slots created by GC_RemoveReference.
    UINT iWrite = 0;

    for (UINT i = 0; i < iEnd; ++i)
    {
        CObject *pObjectRef = vecRefs[i];

        if (pObjectRef)
        {
            if (pObjectRef == pObjectToFind)
                return true;

            if (GC_TraverseHelper(pObjectRef, pObjectToFind, fMark))
                return true;

            if (!pObjectToFind)
            {
                // Compact empty slots only when just marking.  (Doing so while searching for an object could
                // return before the compacting loop is complete, leaving the vector in an inconsistent state.)
                vecRefs[iWrite++] = pObjectRef;
            }
        }
    }
    if (!pObjectToFind)
        vecRefs.Shrink(iWrite);
    return false;
}

STDMETHODIMP_(void)
CLoader::CollectGarbage()
{
    SmartRef::CritSec CS(&m_CriticalSection);

    if (m_pApplicationObject)
    {
#ifdef DBG
        DebugTrace(GC_Report_DebugLevel, "DirectMusic loader CollectGarbage...\n");
#endif

        GC_Mark(m_pApplicationObject);

        // sweep through everything looking for unmarked GC objects
        m_ReleasedObjectList.GC_Sweep(TRUE);
        for (CClass *pClass = m_ClassList.GetHead(); pClass != NULL; pClass = pClass->GetNext())
            pClass->GC_Sweep();
        m_ReleasedObjectList.GC_Sweep();

        // clear the application's mark for next time (the other marks are all cleared by sweep)
        m_pApplicationObject->m_dwScanBits &= ~SCAN_GC_MARK;

#ifdef DBG
        DebugTrace(GC_Report_DebugLevel, "End of garbage collection.\n\n");
#endif
    }

#ifdef DBG
    GC_Report(this);
#endif
}

STDMETHODIMP
CLoader::ReleaseObjectByUnknown(IUnknown *pObject)
{
    V_INAME(CLoader::ReleaseObjectByUnknown);
    V_INTERFACE(pObject);

    IDirectMusicObject *pIDMObject = NULL;
    HRESULT hr = pObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pIDMObject));
    if (FAILED(hr))
        return hr;

    hr = ReleaseObject(pIDMObject);
    pIDMObject->Release();
    return hr;
}

STDMETHODIMP
CLoader::GetDynamicallyReferencedObject(
    IDirectMusicObject *pSourceObject,
    LPDMUS_OBJECTDESC pDesc,
    REFIID riid,
    LPVOID FAR *ppv)
{
    V_INAME(CLoader::GetDynamicallyReferencedObject);
    V_INTERFACE(pSourceObject);

    CObject *pCSourceObject = NULL;

    SmartRef::CritSec CS(&m_CriticalSection);
    HRESULT hr = FindObject(pSourceObject, &pCSourceObject);
    if (FAILED(hr))
        return hr;
    if (!pCSourceObject)
    {
        assert(false);
        return DMUS_E_LOADER_OBJECTNOTFOUND;
    }

    CObject *pPrevContext = m_pLoadedObjectContext;
    m_pLoadedObjectContext = pCSourceObject;
    hr = this->GetObject(pDesc, riid, ppv);
    m_pLoadedObjectContext = pPrevContext;

#ifdef DBG
    GC_Report(this);
#endif

    return hr;
}

STDMETHODIMP
CLoader::ReportDynamicallyReferencedObject(
    IDirectMusicObject *pSourceObject,
    IUnknown *pReferencedObject)
{
    V_INAME(CLoader::GetDynamicallyReferencedObject);
    V_INTERFACE(pSourceObject);
    V_INTERFACE(pReferencedObject);

    CObject *pCSourceObject = NULL;

    SmartRef::CritSec CS(&m_CriticalSection);
    HRESULT hr = FindObject(pSourceObject, &pCSourceObject);
    if (hr == S_FALSE)
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    if (FAILED(hr))
        return hr;
    assert(pCSourceObject);

    IDirectMusicObject *pReferencedIDMObject = NULL;
    hr = pReferencedObject->QueryInterface(IID_IDirectMusicObject, reinterpret_cast<void**>(&pReferencedIDMObject));
    if (FAILED(hr))
    {
        if (hr == E_NOINTERFACE)
            hr = S_OK; // If the referenced object isn't a DirectMusic object then that's OK and we don't need to track it.
        return hr;
    }

    CObject *pCDestObject = NULL;
    hr = FindObject(pReferencedIDMObject, &pCDestObject);
    if (hr == S_FALSE)
        hr = DMUS_E_LOADER_OBJECTNOTFOUND;
    if (FAILED(hr))
        return hr;
    assert(pCDestObject);

    hr = pCSourceObject->GC_AddReference(pCDestObject);

#ifdef DBG
    GC_Report(this);
#endif

    return hr;
}

HRESULT CLoader::GetPath(WCHAR *pwzPath)

{
    if (m_fPathValid)
    {
        wcsncpy(pwzPath,m_wzPath,DMUS_MAX_FILENAME);
        return S_OK;
    }
    wcsncpy(pwzPath,L"",DMUS_MAX_FILENAME);
    return S_FALSE;
}

// Used by ReleaseObject and CClass::ClearCache in removing objects from the cache.
// The object must have already been removed from its list in the main cache.
// This method adds it to the released object list and removes it from the list of
// objects in use by the application.
void CLoader::GC_UpdateForReleasedObject(CObject *pObject)
{
    assert(!pObject->GetNext());

    m_ReleasedObjectList.AddHead(pObject);
    assert(m_pApplicationObject);
    m_pApplicationObject->GC_RemoveReference(pObject);

    if (!(pObject->m_ObjectDesc.m_guidClass == CLSID_DirectMusicScript) && !GC_HasCycle(pObject))
    {
        // Although we need to keep the record around (CObject), we know that this object
        // can't be involved in any cycles and therefore we can release it.
        // (If a cycle is possible we'd need to hold a ref on the object so we could break the
        //  reference by calling Zombie during CollectGarbage.)

        // bugbug: The hard-coded check for CLSID_IDirectMusicScript will need to be extended
        // if we publicly expose methods like IDirectMusicLoader8P::GetDynamicallyReferencedObject
        // so that objects other than scripts could dynamically load objects.
        //    Alternatively, we could assume all objects could be cyclical and always hold onto
        // them.  We would have done it this way, except that legacy applications won't ever call
        // CollectGarbage and that would cause them to leak everything they loaded even after calling
        // ReleaseObject.  That could be a better way (if we could detect legacy apps that don't
        // call CollectGarbage) because it would avoid calling GC_HasCycle every time
        // through ReleaseObject, which is (worst case) order N where N is the number of objects
        // in the loader.  In practice, this worst case only happens if all the objects are
        // arranged in one big cycle.

        pObject->m_pIDMObject->Release();
        pObject->m_pIDMObject = NULL;
    }
}

HRESULT CLoader::LoadCacheFile(WCHAR *pwzCacheFileName)

{
    HRESULT hr = S_OK;
    return hr;
}
#define FOURCC_LIST_CLASSLIST    mmioFOURCC('c','l','s','l')
#define FOURCC_CLASSHEADER        mmioFOURCC('c','l','s','h')
#define FOURCC_LIST_OBJLIST        mmioFOURCC('o','b','j','l')
#define FOURCC_OBJHEADER        mmioFOURCC('o','b','j','h')

HRESULT CLoader::SaveCacheFile(WCHAR *pwzCacheFileName)

{
    HRESULT hr = E_OUTOFMEMORY;
    MMCKINFO ckMain;

    ZeroMemory(&ckMain, sizeof(MMCKINFO));

    CFileStream *pStream = new CFileStream ( this );
    if (pStream)
    {
        hr = pStream->Open(pwzCacheFileName,GENERIC_WRITE);
        if (SUCCEEDED(hr))
        {
            IRIFFStream *pRiff;
            hr = AllocRIFFStream(pStream, &pRiff );
            if (SUCCEEDED(hr))
            {
                ckMain.fccType = FOURCC_RIFF_CACHE;
                if( pRiff->CreateChunk( &ckMain, MMIO_CREATERIFF ) == S_OK)
                {
                    MMCKINFO ckList;
                    
                    ZeroMemory(&ckList, sizeof(MMCKINFO));

                    ckList.fccType = FOURCC_LIST_CLASSLIST;
                    if( pRiff->CreateChunk(&ckList, MMIO_CREATELIST) == S_OK )
                    {
                        CClass *pClass = m_ClassList.GetHead();
                        for (;pClass != NULL;pClass = pClass->GetNext())
                        {
                            hr = pClass->SaveToCache(pRiff);
                            if (FAILED(hr))
                            {
                                Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
                                pRiff->Release();
                                pStream->Release();
                                return hr;
                            }
                        }
                        if( pRiff->Ascend( &ckList, 0 ) != S_OK )
                        {
                            Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
                            hr = DMUS_E_CANNOTSEEK;
                        }
                    }
                    if( pRiff->Ascend( &ckMain, 0 ) != S_OK )
                    {
                        Trace(1, "Error: ScanDirectory encountered a seek error attempting to write to cache file %S.\n", pwzCacheFileName);
                        hr = DMUS_E_CANNOTSEEK;
                    }
                }
                pRiff->Release();
            }
        }
        pStream->Release();
    }

    return hr;
}


    // IDirectMusicIMA
STDMETHODIMP CLoader::LegacyCaching( BOOL fEnable)

{
    m_fIMA = fEnable;
    if (fEnable)
    {
        ScanDirectory(CLSID_DirectMusicStyle,L"sty",L"imafiles");
        ScanDirectory(CLSID_DirectMusicChordMap,L"per",L"imafiles");
    }
    else
    {
        CClass *pClass;
        CDescriptor Desc;
        Desc.m_guidClass = CLSID_DirectMusicStyle;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        EnterCriticalSection(&m_CriticalSection);
        GetClass(&Desc,&pClass,FALSE);
        if (pClass)    
        {
            pClass->ClearObjects(TRUE,L"sty");
        }
        LeaveCriticalSection(&m_CriticalSection);
        Desc.m_guidClass = CLSID_DirectMusicChordMap;
        Desc.m_dwValidData = DMUS_OBJ_CLASS;
        EnterCriticalSection(&m_CriticalSection);
        GetClass(&Desc,&pClass,FALSE);
        if (pClass)    
        {
            pClass->ClearObjects(TRUE,L"per");
        }
        LeaveCriticalSection(&m_CriticalSection);
    }
    return S_OK;
}

#ifdef DBG
void CLoader::DebugTraceObject(DMUS_OBJECTDESC *pDesc)
{
    WCHAR *polestrType = NULL;
    if (pDesc->dwValidData & DMUS_OBJ_CLASS)
    {
        if (S_OK != ProgIDFromCLSID(pDesc->guidClass, &polestrType))
        {
            StringFromCLSID(pDesc->guidClass, &polestrType);
        }
    }
    WCHAR *polestrGUID = NULL;
    if (pDesc->dwValidData & DMUS_OBJ_OBJECT)
    {
        StringFromCLSID(pDesc->guidObject, &polestrGUID);
    }
    Trace(1,
            "   [file %S, name %S, type %S, guid %S]\n",
            (pDesc->dwValidData & DMUS_OBJ_FILENAME) ? pDesc->wszFileName : L"??",
            (pDesc->dwValidData & DMUS_OBJ_NAME) ? pDesc->wszName : L"??",
            polestrType ? polestrType : L"??",
            polestrGUID ? polestrGUID : L"??");
    CoTaskMemFree(polestrType);
    CoTaskMemFree(polestrGUID);
}

void CLoader::DebugTraceLoadFailure(CObject *pObject, HRESULT hrLoad)
{
    if (!pObject)
    {
        assert(false);
        return;
    }

    if (m_pLoadedObjectContext == m_pApplicationObject)
    {
        // This is the object loaded by the application.  Print the warning if anything failed to load.

        UINT iSize = m_vecdescDebugTraceLoadFailure.size();
        if (iSize > 0)
        {
            DMUS_OBJECTDESC desc;
            Zero(&desc);
            pObject->m_ObjectDesc.Get(&desc);

            Trace(1, "Load failure. While attempting to load the object\n");
            DebugTraceObject(&desc);
            Trace(1, "the following referenced objects could not be loaded:\n");
            for (UINT i = 0; i < iSize; ++i)
            {
                DebugTraceObject(&m_vecdescDebugTraceLoadFailure[i]);
            }

            m_vecdescDebugTraceLoadFailure.Shrink(0);
        }
    }
    else
    {
        // This is a referenced sub-object.  Save the desciptor of the failed object in the next slot.

        UINT uiNewPos = m_vecdescDebugTraceLoadFailure.size();
        if (m_vecdescDebugTraceLoadFailure.AccessTo(uiNewPos))
        {
            DMUS_OBJECTDESC *pdesc = &m_vecdescDebugTraceLoadFailure[uiNewPos];
            Zero(pdesc);
            pObject->m_ObjectDesc.Get(pdesc);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\loader.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
// Loader.h : Declaration of CLoader
//
// @doc EXTERNAL
//

#ifndef __CDMLOADER_H_
#define __CDMLOADER_H_
#include <windows.h>
#define COM_NO_WINDOWS_H
#include <objbase.h>
#include "dmusici.h"
#include "Alist.h"
#include "riff.h"
#include "ima.h"
#include <mmreg.h>
#include <stdio.h>
#include "smartref.h"
#include "..\shared\dmusicp.h"

class CLoader;
class CClass;

#define FOURCC_RIFF_CACHE		mmioFOURCC('D','M','L','C')
#define FOURCC_LIST_CLASSLIST	mmioFOURCC('c','l','s','l')
#define FOURCC_CLASSHEADER		mmioFOURCC('c','l','s','h')
#define FOURCC_LIST_OBJLIST		mmioFOURCC('o','b','j','l')
#define FOURCC_OBJHEADER		mmioFOURCC('o','b','j','h')

// We need an older sized object descriptor for parameter validation. 

typedef struct _DMUS_OLDOBJECTDESC
{
    DWORD          dwSize;                 /* Size of this structure. */
    DWORD          dwValidData;            /* Flags indicating which fields below are valid. */
    GUID           guidObject;             /* Unique ID for this object. */
    GUID           guidClass;              /* GUID for the class of object. */
    FILETIME       ftDate;                 /* Last edited date of object. */
    DMUS_VERSION   vVersion;               /* Version. */
    WCHAR          wszName[DMUS_MAX_NAME]; /* Name of object. */
    WCHAR          wszCategory[DMUS_MAX_CATEGORY]; /* Category for object (optional). */
    WCHAR          wszFileName[DMUS_MAX_FILENAME]; /* File path. */
    LONGLONG       llMemLength;            /* Size of Memory data. */
    LPBYTE         pbMemData;              /* Memory pointer for data. */
} DMUS_OLDOBJECTDESC;


class CDescriptor
{
public:
					CDescriptor();
					~CDescriptor();

	void			Get(LPDMUS_OBJECTDESC pDesc);
	void			Set(LPDMUS_OBJECTDESC pDesc);
	void			Merge(CDescriptor * pDesc);
	void			ClearName();
	void			SetName(WCHAR *pwzName);
	void			ClearCategory();
	void			SetCategory(WCHAR *pwzCategory);
	void			ClearFileName();
	HRESULT			SetFileName(WCHAR *pwzFileName);
	void     		SetIStream(IStream *pIStream);
    void            ClearIStream();
	void			Copy(CDescriptor *pDesc);
	BOOL			IsExtension(WCHAR *pwzExtension);
public:
	LONGLONG		m_llMemLength;			// Memory size.
	DWORD			m_dwValidData;			// Flags indicating which of above is valid.
	GUID			m_guidObject;			// Unique ID for this object.
	GUID			m_guidClass;			// GUID for the class of object.
	FILETIME		m_ftDate;				// File date of object.
	DMUS_VERSION	m_vVersion;				// Version, as set by authoring tool.
	WCHAR *			m_pwzName;				// Name of object.	
	WCHAR *			m_pwzCategory;			// Category for object (optional).
	WCHAR *			m_pwzFileName;			// File path.
	DWORD			m_dwFileSize;			// Size of file.
	BYTE *			m_pbMemData;			// Pointer to memory.
    IStream *       m_pIStream;             // Pointer to IStream object.
    LARGE_INTEGER   m_liStartPosition;      // Position in stream to start at.   
    CRITICAL_SECTION	m_CriticalSection;	// Critical section for the descriptor's stream.
    BOOL                m_fCSInitialized;
};

#define     SCAN_CACHE		1			// Was found in cache file.
#define     SCAN_PRIOR		2			// Was in list prior to scanning.
#define     SCAN_PARSED		4			// Was parsed in the directory.
#define     SCAN_SEARCH		8			// Type of object we are searching for.
const DWORD SCAN_GC =		1 << 12;	// Object was cached while garbage collection was enabled.
const DWORD SCAN_GC_MARK =	1 << 13;	// Bit set during marking phase of CollectGarbage.  Objects that remain unmarked are garbage.
										// Also used to detect cycles.


class CObject : public AListItem
{
public:
									CObject(CClass *pClass);
									CObject(CClass *pClass, CDescriptor *pDesc);
									~CObject();
    CObject *						GetNext() {return(CObject *)AListItem::GetNext();};
	HRESULT							Load();
	HRESULT							Parse();
	HRESULT							ParseFromFile();
	HRESULT							ParseFromMemory();
	HRESULT							ParseFromStream();
	HRESULT							GC_Collectable();
	HRESULT							GC_AddReference(CObject *pObject);
	HRESULT							GC_RemoveReference(CObject *pObject);
	HRESULT							GC_RemoveAndDuplicateInParentList();

	CDescriptor						m_ObjectDesc;
	IDirectMusicObject *			m_pIDMObject;
	DWORD							m_dwScanBits;
	SmartRef::Vector<CObject*> *	m_pvecReferences;
private:
	CClass *				m_pClass;
};

class CObjectList : public AList
{
public:
    CObject *	GetHead() {return (CObject *)AList::GetHead();};
    CObject *	RemoveHead() {return (CObject *)AList::RemoveHead();};
	void		GC_Sweep(BOOL bOnlyScripts = FALSE);
};


class CClass : public AListItem
{
public:
						CClass( CLoader *pLoader );
						CClass( CLoader *pLoader, CDescriptor *pDesc );
						~CClass();
	void				ClearObjects(BOOL fKeepCache,WCHAR *pwzExtension);
	void				RemoveObject(CObject* pRemoveObject);
    CClass *			GetNext() {return(CClass *)AListItem::GetNext();};
	HRESULT				GetPath(WCHAR *pwzPath);	// Finds path.
	HRESULT             FindObject(CDescriptor *pDesc,CObject **ppObject, CObject *NotThis = NULL);
	HRESULT				EnumerateObjects(
							DWORD dwIndex, 
							CDescriptor *pDesc) ;
	HRESULT				SetSearchDirectory(WCHAR *pwzPath,BOOL fClear);
	HRESULT				SearchDirectory(WCHAR *pwzFileExtension);
	HRESULT				EnableCache(BOOL fEnable);
	HRESULT				ClearCache(bool fClearStreams); // fClearStreams also clears the IStream members of all descriptors. It is used when shutting down the loader in Release.
	HRESULT				SaveToCache(IRIFFStream *pRiff);
	HRESULT				GetObject(CDescriptor *pDesc, CObject ** ppObject);
	void				PreScan();
	void				GC_Replace(CObject *pObject, CObject *pObjectReplacement);
	void				GC_Sweep() { m_ObjectList.GC_Sweep(); }

	CDescriptor			m_ClassDesc;
	CLoader *			m_pLoader;
	BOOL				m_fKeepObjects;		// Hang onto objects after loading them.

	friend void GC_Report(CLoader *);
private:
	CObjectList			m_ObjectList;
	DWORD				m_dwLastIndex;		// For tracking enumeration.
	CObject *			m_pLastObject;		// Last object enumerated.
	BOOL				m_fDirSearched;		// Directory has been searched for files.
};

class CClassList : public AList
{
public:
    CClass *	GetHead() {return (CClass *)AList::GetHead();};
    CClass *	RemoveHead() {return (CClass *)AList::RemoveHead();};
};


class CLoader : public IDirectMusicLoader8, public IDirectMusicLoader8P, public IDirectMusicIMA
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

	// IDirectMusicLoader
	virtual STDMETHODIMP GetObject(LPDMUS_OBJECTDESC pDesc, REFIID, LPVOID FAR *) ;
	virtual STDMETHODIMP SetObject(LPDMUS_OBJECTDESC pDesc) ;
    virtual STDMETHODIMP SetSearchDirectory(REFGUID rguidClass, WCHAR *pwzPath, BOOL fClear) ;
	virtual STDMETHODIMP ScanDirectory(REFGUID rguidClass, WCHAR *pwzFileExtension, WCHAR *pwzScanFileName) ;
	virtual STDMETHODIMP CacheObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ReleaseObject(IDirectMusicObject * pObject) ;
	virtual STDMETHODIMP ClearCache(REFGUID rguidClass) ;
	virtual STDMETHODIMP EnableCache(REFGUID rguidClass, BOOL fEnable) ;
	virtual STDMETHODIMP EnumObject(REFGUID rguidClass, DWORD dwIndex, LPDMUS_OBJECTDESC pDesc) ;

	// IDirectMusicLoader8
	virtual STDMETHODIMP_(void) CollectGarbage() ;
	virtual STDMETHODIMP ReleaseObjectByUnknown(IUnknown *pObject) ;
	virtual STDMETHODIMP GetDynamicallyReferencedObject(IDirectMusicObject *pSourceObject,
														LPDMUS_OBJECTDESC pDesc,
														REFIID riid,
														LPVOID FAR *ppv) ;
	virtual STDMETHODIMP ReportDynamicallyReferencedObject(IDirectMusicObject *pSourceObject,
														   IUnknown *pReferencedObject);
    virtual STDMETHODIMP LoadObjectFromFile(REFGUID rguidClassID, 
                                            REFIID iidInterfaceID, 
                                            WCHAR *pwzFilePath, 
                                            void ** ppObject) ;
	virtual ULONG STDMETHODCALLTYPE AddRefP();			// Private AddRef, for streams and scripts.
	virtual ULONG STDMETHODCALLTYPE ReleaseP();			// Private Release, for streams and scripts.

	// IDirectMusicIMA
	virtual STDMETHODIMP LegacyCaching( BOOL fEnable) ;

	CLoader();
	~CLoader();
	HRESULT				Init();
	HRESULT				GetPath(WCHAR *pwzPath);	// Finds path.
	void				GC_UpdateForReleasedObject(CObject *pObject); // Used by ReleaseObject and CClass::ClearCache in removing objects from the cache.
	BOOL				m_fIMA;				// Support IMA parsing of ini files, etc.
	BOOL				m_fKeepObjects;		// Hang on to objects after loading them.

	friend void GC_Report(CLoader *);

private:
	HRESULT				LoadCacheFile(WCHAR *pwzCacheFileName);
	HRESULT				SaveCacheFile(WCHAR *pwzCacheFileName);
	HRESULT				GetClass(CDescriptor *pDesc, CClass **ppClass, BOOL fCreate);
	HRESULT 			ClearCacheInternal(REFGUID rguidClass, bool fClearStreams); // fClearStreams also clears the IStream members of all descriptors. It is used when shutting down the loader in Release.
	HRESULT             FindObject(CDescriptor *pDesc, CClass **ppClass, CObject ** ppObject);
	HRESULT				FindObject(IDirectMusicObject *pIDMObject, CObject ** ppObject);

	void				GC_Mark(CObject *pObject);
	bool				GC_HasCycle(CObject *pObject);
	// Recursive function used to implement GC_Mark and GC_HasCycle
	bool				GC_TraverseHelper(CObject *pObject, CObject *pObjectToFind, bool fMark);

	CClassList			m_ClassList;		// Each type has its own list.
	WCHAR				m_wzPath[DMUS_MAX_FILENAME];	// Search directory.
	BOOL				m_fPathValid;		// Search dir is valid.
	long				m_cRef;
	long				m_cPRef;			// Private reference count.
    CRITICAL_SECTION	m_CriticalSection;	// Critical section to manage lists.
    BOOL                m_fCSInitialized;

	CObject *			m_pApplicationObject; // Object used to track references to objects in use by the application.
	CObject *			m_pLoadedObjectContext; // Used to determine which object called GetObject.  Initially m_pApplicationContext, but set and restored as a cascade of GetObject calls occurs between components.
	CObjectList			m_ReleasedObjectList; // Holds objects that are released, but may still be referenced by other objects.

	// Debug-only functions used by GetObject to report load failures.
	// Frequently some file will fail to load because it depends on some other file
	// that is missing and this will print out trace statements helping the user
	// understand what's missing.
#ifdef DBG
	void DebugTraceLoadFailure(CObject *pObject, HRESULT hrLoad);
	static void DebugTraceObject(DMUS_OBJECTDESC *pDesc);
	SmartRef::Vector<DMUS_OBJECTDESC> m_vecdescDebugTraceLoadFailure; // accumulates the failed sub-items
#endif
};

/*
@interface IDirectMusicGetLoader | 
If a stream supports the loader, it must provide an
<i IDirectMusicGetLoader> interface so any object that is
parsing the stream can use it to access the loader when
it needs to load another object that is referenced by the
file.

@base public | IUnknown

@meth HRESULT | GetLoader | Returns the loader.
@xref <i IDirectMusicLoader>
*/


class CFileStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CFileStream( CLoader *pLoader );
						~CFileStream();
	HRESULT				Open( WCHAR *lpFileName, DWORD dwDesiredAccess );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    WCHAR           m_wszFileName[DMUS_MAX_FILENAME]; // Save name for cloning.
#ifdef UNDER_CE
    HANDLE          m_hFile;
#else
	FILE*			m_pFile;		// file pointer
#endif
	CLoader *		m_pLoader;
};

class CMemStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CMemStream( CLoader *pLoader );
                        CMemStream( CLoader *pLoader,
                            LONGLONG llLength,
                            LONGLONG llPosition,
                            BYTE *pbData);
						~CMemStream();
	HRESULT				Open( BYTE *pbData, LONGLONG llLength );
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
	BYTE*			m_pbData;		// memory pointer
	LONGLONG		m_llLength;
	LONGLONG		m_llPosition;	// Current file position.
	CLoader *		m_pLoader;
};


class CStream : public IStream, public IDirectMusicGetLoader
{
public:
    // IUnknown
    //
    virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    /* IStream methods */
    virtual STDMETHODIMP Read( void* pv, ULONG cb, ULONG* pcbRead );
    virtual STDMETHODIMP Write( const void* pv, ULONG cb, ULONG* pcbWritten );
	virtual STDMETHODIMP Seek( LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition );
    virtual STDMETHODIMP SetSize( ULARGE_INTEGER /*libNewSize*/ );
    virtual STDMETHODIMP CopyTo( IStream* /*pstm */, ULARGE_INTEGER /*cb*/,
                         ULARGE_INTEGER* /*pcbRead*/,
                         ULARGE_INTEGER* /*pcbWritten*/ );
    virtual STDMETHODIMP Commit( DWORD /*grfCommitFlags*/ );
    virtual STDMETHODIMP Revert();
    virtual STDMETHODIMP LockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                             DWORD /*dwLockType*/ );
    virtual STDMETHODIMP UnlockRegion( ULARGE_INTEGER /*libOffset*/, ULARGE_INTEGER /*cb*/,
                               DWORD /*dwLockType*/);
    virtual STDMETHODIMP Stat( STATSTG* /*pstatstg*/, DWORD /*grfStatFlag*/ );
    virtual STDMETHODIMP Clone( IStream** /*ppstm*/ );

	/* IDirectMusicGetLoader */
	virtual STDMETHODIMP GetLoader(IDirectMusicLoader ** ppLoader);

						CStream( CLoader *pLoader );
                        CStream( CLoader *pLoader, IStream *pStream );
						~CStream();
	HRESULT				Open(IStream *pIStream,LARGE_INTEGER liStartPosition);
	HRESULT				Close();

private:
    LONG            m_cRef;         // object reference count
    IStream *       m_pIStream;
	CLoader *		m_pLoader;
};

// Class factory
// 
class CLoaderFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CLoaderFactory();

	// Destructor
	~CLoaderFactory(); 

private:
	long m_cRef;
};

class CContainerFactory : public IClassFactory
{
public:
	// IUnknown
    //
	virtual STDMETHODIMP QueryInterface(const IID &iid, void **ppv);
	virtual STDMETHODIMP_(ULONG) AddRef();
	virtual STDMETHODIMP_(ULONG) Release();

	// Interface IClassFactory
    //
	virtual STDMETHODIMP CreateInstance(IUnknown* pUnknownOuter, const IID& iid, void** ppv);
	virtual STDMETHODIMP LockServer(BOOL bLock); 

	// Constructor
    //
	CContainerFactory();

	// Destructor
	~CContainerFactory(); 

private:
	long m_cRef;
};


/*
@interface IDirectMusicObject | 
All DirectMusic objects support the <i IDirectMusicObject> 
interface in order to
work with the DirectMusic loader. In addition to 
providing a standard generic interface that the loader can
communicate with, this provides a generic mechanism that
allows an application to query an object for information 
about it, including Name, Guid, file path, version info, 
and more.

If you are writing a DirectMusic compatible object, you
must support <i IDirectMusicObject>, along with <i IPersistStream>, 
which is used in
tandem with <i IDirectMusicObject> to load the object.

@base public | IUnknown

@meth HRESULT | GetDescriptor | Get the object's internal description, in <t DMUS_OBJECTDESC> format.
@meth HRESULT | SetDescriptor | Set the object's internal description, in <t DMUS_OBJECTDESC> format.
@meth HRESULT | ParseDescriptor | Parse into the supplied stream and find information about the file to store in <t DMUS_OBJECTDESC> format.

@xref  <t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/
#ifdef ONLYAUTODOCS
/* 
@method:(EXTERNAL) HRESULT | IDirectMusicObject | GetDescriptor | 
Get the object's internal description. 

This method takes a <t DMUS_OBJECTDESC> structure and fills in everything
it knows about itself. Depending on the implementation of the object and
how it was loaded from a file, some or all of the standard 
parameters will be filled by <om IDirectMusicObject::GetDescriptor>.
Be sure to check the flags in <e DMUS_OBJECTDESC.dwValidData> to understand
which fields are valid.

@rdesc Returns one of the following

@flag S_OK | Success

@ex The following example uses <om IDirectMusicObject::GetDescriptor> to
read the name from a DirectMusic style: |

	IDirectMusicStyle *pStyle;		// Style that was previously loaded.

	if (pStyle)
	{
		IDirectMusicObject *pIObject;  
		DMUS_OBJECTDESC Desc;              // Descriptor.

		if (SUCCEEDED(QueryInterface(IID_IDirectMusicObject,(void **) &pIObject); 
		{
			if (SUCCEEDED(pIObject->GetDescriptor(&Desc))
			{
				if (Desc.dwValidData & DMUS_OBJ_NAME)
				{
					TRACE("Style name is %S\n",Desc.wszName);
				}
			}
			pIObject->Release();
		}
	}

@xref <i IDirectMusicObject>, <om IDirectMusicObject::SetDescriptor>,
<om IDirectMusicObject::ParseDescriptor>,<t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/

HRESULT CDMStyle::GetDescriptor(
	LPDMUS_OBJECTDESC pDesc)	// @parm Descriptor to be filled with data about object.
{
	return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicObject | SetDescriptor | 
Set some or all fields of the object's internal description. 

This method takes a <t DMUS_OBJECTDESC> structure and copies the
fields that are enabled with by a flag in 
<e DMUS_OBJECTDESC.dwValidData>. 

Fields that are not copied keep their previous values. For example,
an object may already have its name and GUID stored internally. 
A call to its <om IDirectMusicObject::SetDescriptor> method with
a new name and file path (DMUS_OBJ_NAME and DMUS_OBJ_FILENAME)
would replace the name, give it a file name, and leave the
GUID alone.

This is primarily used by the loader when creating an object. 
However, it can be used by an application to rename an object.

If the object is unable to set one or more fields, it sets the
fields that it does support, clears the flags in <e DMUS_OBJECTDESC.dwValidData>
that it does not support, and returns S_FALSE. 

If nothing else, an object should support DMUS_OBJ_NAME and DMUS_OBJ_OBJECT.

@rdesc Returns one of the following

@flag S_OK | Success
@flag S_FALSE | Was unable to set some parameters. The <p pDesc>'s dwValidData
field will contain only those flags that were successfully set.

@xref <i IDirectMusicObject>, <om IDirectMusicObject::GetDescriptor>,
<om IDirectMusicObject::ParseDescriptor>,<t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/

HRESULT CDMStyle::SetDescriptor(
	LPDMUS_OBJECTDESC pDesc)	// @parm Descriptor with data about object.
{
	return S_OK;
}

/* 
@method:(EXTERNAL) HRESULT | IDirectMusicObject | ParseDescriptor | 
Given a file stream, <om IDirectMusicObject::ParseDescriptor> scans the 
file for data which it can store in the <t DMUS_OBJECTDESC> structure.
These include object name, GUID, version info, etc. All fields that
are supplied are marked with the appropriate bit flags in
<e DMUS_OBJECTDESC.dwValidData>.

This is primarily used by the loader when scanning a directory for
objects, and should not be of use to an application. However, if you
implement an object type in DirectMusic, you should support this.

@rdesc Returns one of the following

@flag S_OK | Success
@flag DMUS_E_INVALIDFILE | Not a valid file

@xref <i IDirectMusicObject>, <om IDirectMusicObject::SetDescriptor>,
<om IDirectMusicObject::GetDescriptor>,<t DMUS_OBJECTDESC>, <i IDirectMusicLoader>
*/

HRESULT CDMStyle::ParseDescriptor(
	LPSTREAM pStream,		// @parm Stream source for file.
	LPDMUS_OBJECTDESC pDesc)	// @parm Descriptor to fill with data about file.
{

	return S_OK;
}

#endif // ONLYAUTODOCS

#endif //__CDMLOADER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\riff.h ===
// Copyright (c) 1998-1999 Microsoft Corporation
//
// riff.h
//

#include <objbase.h>

#ifndef __RIFF__
#define __RIFF__
#include <windows.h>
#include <mmsystem.h>
#define FixBytes(a1,a2)

// {0D5057E1-8889-11CF-B9DA-00AA00C08146}
DEFINE_GUID( IID_IRIFFStream, 0xd5057e1, 0x8889, 0x11cf, 0xb9, 0xda, 0x0, 0xaa, 0x0, 0xc0, 0x81, 0x46 );
#undef INTERFACE
#define INTERFACE IRIFFStream
DECLARE_INTERFACE_(IRIFFStream, IUnknown)
{
    // IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    // IMKRIFFStream members
    STDMETHOD(Descend)(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags) PURE;
    STDMETHOD(Ascend)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(CreateChunk)(LPMMCKINFO lpck, UINT wFlags) PURE;
    STDMETHOD(SetStream)(LPSTREAM pStream) PURE;
    STDMETHOD_(LPSTREAM, GetStream)() PURE;
};



struct CRIFFStream : IRIFFStream
{
///// object state
    ULONG       m_cRef;         // object reference count
    IStream*    m_pStream;      // stream to operate on

///// construction and destruction
    CRIFFStream(IStream* pStream)
    {
        m_cRef = 1;
		// replaced a call to SetStream with the following to avoid releasing an
		// unallocated stream
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
    }
    ~CRIFFStream()
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
    }

///// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj)
    {
        if( IsEqualIID( riid, IID_IUnknown ) ||
            IsEqualIID( riid, IID_IRIFFStream ) )
        {
            *ppvObj = (IRIFFStream*)this;
            AddRef();
            return NOERROR;
        }
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if( --m_cRef == 0L )
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

// IAARIFFStream methods
    STDMETHODIMP Descend(LPMMCKINFO lpck, LPMMCKINFO lpckParent, UINT wFlags);
    STDMETHODIMP Ascend(LPMMCKINFO lpck, UINT /*wFlags*/);
    STDMETHODIMP CreateChunk(LPMMCKINFO lpck, UINT wFlags);
    STDMETHOD(SetStream)(LPSTREAM pStream)
    {
        if( m_pStream != NULL )
        {
            m_pStream->Release();
        }
        m_pStream = pStream;
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return S_OK;
    }
    STDMETHOD_(LPSTREAM, GetStream)()
    {
        if( m_pStream != NULL )
        {
            m_pStream->AddRef();
        }
        return m_pStream;
    }
};
/*
// seeks to a 32-bit position in a stream.
HRESULT __inline StreamSeek( LPSTREAM pStream, long lSeekTo, DWORD dwOrigin )
{
	LARGE_INTEGER li;

	if( lSeekTo < 0 )
	{
		li.HighPart = -1;
	}
	else
	{
        li.HighPart = 0;
	}
	li.LowPart = lSeekTo;
	return pStream->Seek( li, dwOrigin, NULL );
}

// returns the current 32-bit position in a stream.
DWORD __inline StreamTell( LPSTREAM pStream )
{
	LARGE_INTEGER li;
    ULARGE_INTEGER ul;
#ifdef DBG
    HRESULT hr;
#endif

    li.HighPart = 0;
    li.LowPart = 0;
#ifdef DBG
    hr = pStream->Seek( li, STREAM_SEEK_CUR, &ul );
    if( FAILED( hr ) )
#else
    if( FAILED( pStream->Seek( li, STREAM_SEEK_CUR, &ul ) ) )
#endif
    {
        return 0;
    }
    return ul.LowPart;
}

// this function gets a long that is formatted the correct way
// i.e. the motorola way as opposed to the intel way
BOOL __inline GetMLong( LPSTREAM pStream, DWORD& dw )
{
    union uLong
	{
		unsigned char buf[4];
        DWORD dw;
	} u;
    unsigned char ch;

    if( FAILED( pStream->Read( u.buf, 4, NULL ) ) )
    {
        return FALSE;
    }

#ifndef _MAC
    // swap bytes
    ch = u.buf[0];
    u.buf[0] = u.buf[3];
    u.buf[3] = ch;

    ch = u.buf[1];
    u.buf[1] = u.buf[2];
    u.buf[2] = ch;
#endif

    dw = u.dw;
    return TRUE;
}

BOOL __inline IsGUIDZero( REFGUID guid )
{
    GUID g;

    memset( &g, 0, sizeof( g ) );
    return IsEqualGUID( g, guid );
}

// misc function prototypes

STDAPI AllocFileStream( LPCSTR szFileName, DWORD dwDesiredAccess, IStream **ppstream );
*/
STDAPI AllocRIFFStream( IStream* pStream, IRIFFStream** ppRiff );

#endif  // __RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dmusic\dmloader\object.cpp ===
// Copyright (c) 1998-2001 Microsoft Corporation
// Object.cpp : Implementations of CObject and CClass

#include "dmusici.h"
#include "loader.h"
#include "debug.h"
#include "miscutil.h"
#include <strsafe.h>
#ifdef UNDER_CE
#include "dragon.h"
#else
extern BOOL g_fIsUnicode;
#endif

CDescriptor::CDescriptor()

{
    m_fCSInitialized = FALSE;
    InitializeCriticalSection(&m_CriticalSection);
    // Note: on pre-Blackcomb OS's, this call can raise an exception; if it
    // ever pops in stress, we can add an exception handler and retry loop.
    m_fCSInitialized = TRUE;

    m_llMemLength = 0;
    m_pbMemData = NULL;         // Null pointer to memory.
    m_dwValidData = 0;          // Flags indicating which of above is valid.
    m_guidObject = GUID_NULL;           // Unique ID for this object.
    m_guidClass = GUID_NULL;            // GUID for the class of object.
    ZeroMemory( &m_ftDate, sizeof(FILETIME) );              // File date of object.
    ZeroMemory( &m_vVersion, sizeof(DMUS_VERSION) );                // Version, as set by authoring tool.
    m_pwzName = NULL;               // Name of object.  
    m_pwzCategory = NULL;           // Category for object (optional).
    m_pwzFileName = NULL;           // File path.
    m_dwFileSize = 0;           // Size of file.
    m_pIStream = NULL;
    m_liStartPosition.QuadPart = 0;
}

CDescriptor::~CDescriptor()

{
    if (m_fCSInitialized)
    {
        // If critical section never initialized, never got a chance
        // to do any other initializations
        //
        if (m_pwzFileName) delete[] m_pwzFileName;
        if (m_pwzCategory) delete[] m_pwzCategory;
        if (m_pwzName) delete[] m_pwzName;
        if (m_pIStream) m_pIStream->Release();
        DeleteCriticalSection(&m_CriticalSection);
    }
}

void CDescriptor::ClearName()

{
    if (m_pwzName) delete[] m_pwzName;
    m_pwzName = NULL;
    m_dwValidData &= ~DMUS_OBJ_NAME;
}

void CDescriptor::SetName(WCHAR *pwzName)

{
    if(pwzName == NULL)
    {
        return;
    }

    HRESULT hr = S_OK;
    
    WCHAR wszName[DMUS_MAX_NAME] = L"";

    ClearName();
    hr = StringCchCopyW(wszName, DMUS_MAX_NAME, pwzName);
    
    if(SUCCEEDED(hr))
    {
        size_t cLen = wcslen(wszName);
        m_pwzName = new WCHAR[cLen + 1];
        if(m_pwzName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        
        if(SUCCEEDED(hr))
        {
            wcsncpy(m_pwzName, wszName, cLen + 1);
        }
    }
    
    if(SUCCEEDED(hr))
    {
        m_dwValidData |= DMUS_OBJ_NAME;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_NAME;
    }
}

void CDescriptor::ClearCategory()

{
    if (m_pwzCategory) delete[] m_pwzCategory;
    m_pwzCategory = NULL;
    m_dwValidData &= ~DMUS_OBJ_CATEGORY;
}

void CDescriptor::SetCategory(WCHAR* pwzCategory)

{
    if(pwzCategory == NULL)
    {
        return;
    }

    HRESULT hr = S_OK;
    WCHAR wszCategory[DMUS_MAX_CATEGORY] = L"";

    ClearCategory();
    hr = StringCchCopyW(wszCategory, DMUS_MAX_CATEGORY, pwzCategory); 

    if(SUCCEEDED(hr))
    {
        size_t cLen = wcslen(wszCategory);
        m_pwzCategory = new WCHAR[cLen + 1];

        if(m_pwzCategory == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        
        if(SUCCEEDED(hr))
        {
            wcsncpy(m_pwzCategory, wszCategory, cLen + 1);
        }
    }

    if(SUCCEEDED(hr))
    {
        m_dwValidData |= DMUS_OBJ_CATEGORY;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_CATEGORY;
    }
}

void CDescriptor::ClearFileName()

{
    if (m_pwzFileName) delete[] m_pwzFileName;
    m_pwzFileName = NULL;
    m_dwValidData &= ~DMUS_OBJ_FILENAME;
}

// return S_FALSE if the filename is already set to this
HRESULT CDescriptor::SetFileName(WCHAR *pwzFileName)

{
    if(pwzFileName == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = E_FAIL;
    WCHAR wszFileName[DMUS_MAX_FILENAME] = L"";

    // Make a safe copy of the passed string
    hr = StringCchCopyW(wszFileName, DMUS_MAX_FILENAME, pwzFileName);
    if(FAILED(hr))
    {
        return E_INVALIDARG;
    }

    // We return without touching the valid data flags if we fail here
    if( m_pwzFileName )
    {
        if( !_wcsicmp( m_pwzFileName, wszFileName ))
        {
            return S_FALSE;
        }
    }

    // This is actually unnecessary since we're returning on failure above
    // But then that code might change. So to keep it absolutely clear... 
    if(SUCCEEDED(hr))
    {
        ClearFileName();

        size_t cLen = wcslen(wszFileName);
        m_pwzFileName = new WCHAR[cLen + 1];
        if (m_pwzFileName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            hr = StringCchCopyW(m_pwzFileName, cLen + 1, wszFileName);
        }
    }

    if(SUCCEEDED(hr))
    {
        m_dwValidData |= DMUS_OBJ_FILENAME;
    }
    else
    {
        m_dwValidData &= ~DMUS_OBJ_FILENAME;
    }

    return hr;
}

void CDescriptor::ClearIStream()

{
    EnterCriticalSection(&m_CriticalSection);
    if (m_pIStream)
    {
        m_pIStream->Release();
    }
    m_pIStream      = NULL;
    m_liStartPosition.QuadPart = 0;
    m_dwValidData  &= ~DMUS_OBJ_STREAM;
    LeaveCriticalSection(&m_CriticalSection);
}

void CDescriptor::SetIStream(IStream *pIStream)

{
    EnterCriticalSection(&m_CriticalSection);
    ClearIStream();

    m_pIStream = pIStream;

    if (m_pIStream)
    {
        ULARGE_INTEGER  libNewPosition;
        m_liStartPosition.QuadPart = 0;
        m_pIStream->Seek( m_liStartPosition, STREAM_SEEK_CUR, &libNewPosition );
        m_liStartPosition.QuadPart = libNewPosition.QuadPart;
        m_pIStream->AddRef();
        m_dwValidData |= DMUS_OBJ_STREAM;
    }
    LeaveCriticalSection(&m_CriticalSection);
}

BOOL CDescriptor::IsExtension(WCHAR *pwzExtension)

{
    if (pwzExtension && m_pwzFileName)
    {
        DWORD dwX;
        DWORD dwLen = wcslen(m_pwzFileName);
        for (dwX = 0; dwX < dwLen; dwX++)
        {
            if (m_pwzFileName[dwX] == L'.') break;
        }
        dwX++;
        if (dwX < dwLen)
        {
            return !_wcsicmp(pwzExtension,&m_pwzFileName[dwX]);
        }
    }
    return FALSE;
}

void CDescriptor::Get(LPDMUS_OBJECTDESC pDesc)

{
    if(pDesc == NULL)
    {
        return;
    }

    // Don't return the IStream insterface. Once set, this becomes private to the loader.
    pDesc->dwValidData = m_dwValidData & ~DMUS_OBJ_STREAM;

    pDesc->guidObject = m_guidObject;
    pDesc->guidClass = m_guidClass;
    pDesc->ftDate = m_ftDate;
    pDesc->vVersion = m_vVersion;
    pDesc->llMemLength = m_llMemLength;
    pDesc->pbMemData = m_pbMemData;
    if (m_pwzName) 
    {
        wcsncpy( pDesc->wszName, m_pwzName, DMUS_MAX_NAME ); 
    }
    if (m_pwzCategory)
    {
        wcsncpy( pDesc->wszCategory,m_pwzCategory, DMUS_MAX_CATEGORY ); 
    }
    if (m_pwzFileName)
    {
        wcsncpy( pDesc->wszFileName, m_pwzFileName, DMUS_MAX_FILENAME);
    }
}

void CDescriptor::Set(LPDMUS_OBJECTDESC pDesc)

{
    m_dwValidData = pDesc->dwValidData;
    m_guidObject = pDesc->guidObject;
    m_guidClass = pDesc->guidClass;
    m_ftDate = pDesc->ftDate;
    m_vVersion = pDesc->vVersion;
    m_llMemLength = pDesc->llMemLength;
    m_pbMemData = pDesc->pbMemData;
    ClearName();
    if (pDesc->dwValidData & DMUS_OBJ_NAME)
    {
        pDesc->wszName[DMUS_MAX_NAME - 1] = 0;  // Force string length, in case of error.
        SetName(pDesc->wszName);
    }
    ClearCategory();
    if (pDesc->dwValidData & DMUS_OBJ_CATEGORY)
    {
        pDesc->wszCategory[DMUS_MAX_CATEGORY - 1] = 0;  // Force string length, in case of error.
        SetCategory(pDesc->wszCategory);
    }
    ClearFileName();
    if (pDesc->dwValidData & DMUS_OBJ_FILENAME)
    {
        pDesc->wszFileName[DMUS_MAX_FILENAME - 1] = 0;  // Force string length, in case of error.
        SetFileName(pDesc->wszFileName);
    }
    ClearIStream();
    if (pDesc->dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pDesc->pStream);
    }
}

void CDescriptor::Copy(CDescriptor *pDesc)

{
    m_dwValidData = pDesc->m_dwValidData;
    m_guidObject = pDesc->m_guidObject;
    m_guidClass = pDesc->m_guidClass;
    m_ftDate = pDesc->m_ftDate;
    m_vVersion = pDesc->m_vVersion;
    m_llMemLength = pDesc->m_llMemLength;
    m_pbMemData = pDesc->m_pbMemData;
    ClearName();
    if (pDesc->m_dwValidData & DMUS_OBJ_NAME)
    {
        SetName(pDesc->m_pwzName);
    }
    ClearCategory();
    if (pDesc->m_dwValidData & DMUS_OBJ_CATEGORY)
    {
        SetCategory(pDesc->m_pwzCategory);
    }
    ClearFileName();
    if (pDesc->m_dwValidData & DMUS_OBJ_FILENAME)
    {
        SetFileName(pDesc->m_pwzFileName);
    }
    ClearIStream();
    if (pDesc->m_dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pDesc->m_pIStream);
    }
}

void CDescriptor::Merge(CDescriptor *pSource)

{
    if (pSource->m_dwValidData & DMUS_OBJ_OBJECT)
    {
        m_dwValidData |= DMUS_OBJ_OBJECT;
        m_guidObject = pSource->m_guidObject;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_CLASS)
    {
        m_dwValidData |= DMUS_OBJ_CLASS;
        m_guidClass = pSource->m_guidClass;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_NAME)
    {
        m_dwValidData |= DMUS_OBJ_NAME;
        SetName(pSource->m_pwzName);
    }
    if (pSource->m_dwValidData & DMUS_OBJ_CATEGORY)
    {
        m_dwValidData |= DMUS_OBJ_CATEGORY;
        SetCategory(pSource->m_pwzCategory);
    }
    if (pSource->m_dwValidData & DMUS_OBJ_VERSION)
    {
        m_dwValidData |= DMUS_OBJ_VERSION;
        m_vVersion = pSource->m_vVersion;
    }
    if (pSource->m_dwValidData & DMUS_OBJ_DATE)
    {
        m_dwValidData |= DMUS_OBJ_DATE;
        m_ftDate = pSource->m_ftDate; 
    }
    if (pSource->m_dwValidData & DMUS_OBJ_FILENAME)
    {
        if (!(m_dwValidData & DMUS_OBJ_FILENAME))
        {
            if (SUCCEEDED(SetFileName(pSource->m_pwzFileName)))
            {
                m_dwValidData |= (pSource->m_dwValidData & 
                    (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH | DMUS_OBJ_URL));
            }
        }
    }
    if (pSource->m_dwValidData & DMUS_OBJ_MEMORY)
    {
        m_pbMemData = pSource->m_pbMemData;
        m_llMemLength = pSource->m_llMemLength;
        if (m_llMemLength && m_pbMemData)
        {
            m_dwValidData |= DMUS_OBJ_MEMORY;
        }
        else
        {
            m_dwValidData &= ~DMUS_OBJ_MEMORY;
        }
    }
    if (pSource->m_dwValidData & DMUS_OBJ_STREAM)
    {
        SetIStream(pSource->m_pIStream);
    }
}

CObject::CObject(CClass *pClass)

{
    m_dwScanBits = 0;
    m_pClass = pClass;
    m_pIDMObject = NULL;
    m_pvecReferences = NULL;
}

CObject::CObject(CClass *pClass, CDescriptor *pDesc)

{
    m_dwScanBits = 0;
    m_pClass = pClass;
    m_pIDMObject = NULL;
    m_ObjectDesc.Copy(pDesc);
    m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;
    if (!(m_ObjectDesc.m_dwValidData & DMUS_OBJ_CLASS))
    {
        m_ObjectDesc.m_guidClass = pClass->m_ClassDesc.m_guidClass;
        m_ObjectDesc.m_dwValidData |= 
            (pClass->m_ClassDesc.m_dwValidData & DMUS_OBJ_CLASS);
    }
    m_pvecReferences = NULL;
}


CObject::~CObject()

{
    if (m_pIDMObject)
    {
        m_pIDMObject->Release();
        m_pIDMObject = NULL;
    }
    delete m_pvecReferences;
}

HRESULT CObject::Parse()

{
    if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        return ParseFromFile();
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
    {
        return ParseFromMemory();
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
    {
        return ParseFromStream();
    }
    assert(false);
    return E_FAIL;
}

HRESULT CObject::ParseFromFile()

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        WCHAR wzFullPath[DMUS_MAX_FILENAME];
        ZeroMemory( wzFullPath, sizeof(WCHAR) * DMUS_MAX_FILENAME );
        CFileStream *pStream = new CFileStream ( m_pClass->m_pLoader );
        if (pStream)
        {
            if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH)
            {
                wcsncpy(wzFullPath, m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME);
            }
            else
            {
                m_pClass->GetPath(wzFullPath);
                wcsncat(wzFullPath, m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME - wcslen(wzFullPath) - 1);
            }
            hr = pStream->Open(wzFullPath,GENERIC_READ);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC DESC;
                memset((void *)&DESC,0,sizeof(DESC));
                DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,&DESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(&DESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


HRESULT CObject::ParseFromMemory()

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CMemStream *pStream = new CMemStream ( m_pClass->m_pLoader );
        if (pStream)
        {
            hr = pStream->Open(m_ObjectDesc.m_pbMemData,m_ObjectDesc.m_llMemLength);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC DESC;
                memset((void *)&DESC,0,sizeof(DESC));
                DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,&DESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(&DESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


HRESULT CObject::ParseFromStream()

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ObjectDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CStream *pStream = new CStream ( m_pClass->m_pLoader );
        if (pStream)
        {
            hr = pStream->Open(m_ObjectDesc.m_pIStream,
                m_ObjectDesc.m_liStartPosition);
            if (SUCCEEDED(hr))
            {
                DMUS_OBJECTDESC DESC;
                memset((void *)&DESC,0,sizeof(DESC));
                DESC.dwSize = sizeof (DMUS_OBJECTDESC);
                hr = pIObject->ParseDescriptor(pStream,&DESC);
                if (SUCCEEDED(hr))
                {
                    CDescriptor ParseDesc;
                    ParseDesc.Set(&DESC);
                    m_ObjectDesc.Merge(&ParseDesc);
                }
            }
            pStream->Release();
        }
        pIObject->Release();
    }
    return hr;
}


// Record that this object can be garbage collected and prepare to store its references.
// Must be called before any of CObject's other routines.
HRESULT CObject::GC_Collectable()

{
    m_dwScanBits |= SCAN_GC;
    assert(!m_pvecReferences);

    m_pvecReferences = new SmartRef::Vector<CObject*>;
    if (!m_pvecReferences)
        return E_OUTOFMEMORY;
    return S_OK;
}

HRESULT CObject::GC_AddReference(CObject *pObject)

{
    if(pObject == NULL)
    {
        return E_POINTER;
    }

    assert(m_dwScanBits & SCAN_GC && m_pvecReferences);

    // don't track references to objects that aren't garbage collected
    if (!(pObject->m_dwScanBits & SCAN_GC))
        return S_OK;

    UINT uiPosNext = m_pvecReferences->size();
    for (UINT i = 0; i < uiPosNext; ++i)
    {
        if ((*m_pvecReferences)[i] == pObject)
            return S_OK;
    }

    if (!m_pvecReferences->AccessTo(uiPosNext))
        return E_OUTOFMEMORY;
    (*m_pvecReferences)[uiPosNext] = pObject;
    return S_OK;
}

HRESULT CObject::GC_RemoveReference(CObject *pObject)

{
    assert(m_dwScanBits & SCAN_GC && m_pvecReferences);

    SmartRef::Vector<CObject*> &vecRefs = *m_pvecReferences;
    UINT iEnd = vecRefs.size();
    for (UINT i = 0; i < iEnd; ++i)
    {
        if (vecRefs[i] == pObject)
        {
            // Remove by clearing the pointer.
            // The open slot will be compacted during garbage collection (GC_Mark).
            vecRefs[i] = NULL;
            return S_OK;
        }
    }
    return S_FALSE;
}

// Helper method used to implement ReleaseObject.
HRESULT CObject::GC_RemoveAndDuplicateInParentList()
{
    CObject* pObjectToFind = NULL;
    HRESULT hr = m_pClass->FindObject(&m_ObjectDesc, &pObjectToFind, this);
    if (SUCCEEDED(hr) && pObjectToFind)
    {
        m_pClass->GC_Replace(this, NULL);
    }
    else
    {
        CObject *pObjectUnloaded = new CObject(m_pClass, &m_ObjectDesc);
        if (!pObjectUnloaded)
        {
            return E_OUTOFMEMORY;
        }

        m_pClass->GC_Replace(this, pObjectUnloaded);
    }
    return S_OK;
}

HRESULT CObject::Load()

{
    // See if we have one of the fields we need to load
    if (!(m_ObjectDesc.m_dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_MEMORY | DMUS_OBJ_STREAM)))
    {
        Trace(1, "Error: GetObject failed because the requested object was not already cached and the supplied desciptor did not specify a source to load the object from (DMUS_OBJ_FILENAME, DMUS_OBJ_MEMORY, or DMUS_OBJ_STREAM).");
        return DMUS_E_LOADER_NOFILENAME;
    }

    // Create the object
    SmartRef::ComPtr<IDirectMusicObject> scomIObject = NULL;
    HRESULT hr = CoCreateInstance(m_ObjectDesc.m_guidClass, NULL, CLSCTX_INPROC_SERVER, IID_IDirectMusicObject, reinterpret_cast<void**>(&scomIObject));
    if (FAILED(hr))
        return hr;

    // Create the stream the object will load from
    SmartRef::ComPtr<IStream> scomIStream;
    if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        WCHAR wzFullPath[DMUS_MAX_FILENAME];
        ZeroMemory( wzFullPath, sizeof(WCHAR) * DMUS_MAX_FILENAME );
        CFileStream *pStream = new CFileStream ( m_pClass->m_pLoader );
        if (!pStream)
            return E_OUTOFMEMORY;
        scomIStream = pStream;

        if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH)
        {
            wcsncpy(wzFullPath, m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME);
        }
        else
        {
            m_pClass->GetPath(wzFullPath);
            wcsncat(wzFullPath,m_ObjectDesc.m_pwzFileName, DMUS_MAX_FILENAME - wcslen(wzFullPath) - 1);
        }
        hr = pStream->Open(wzFullPath,GENERIC_READ);
        if (FAILED(hr))
            return hr;
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
    {
        CMemStream *pStream = new CMemStream ( m_pClass->m_pLoader );
        if (!pStream)
            return E_OUTOFMEMORY;
        scomIStream = pStream;
        hr = pStream->Open(m_ObjectDesc.m_pbMemData, m_ObjectDesc.m_llMemLength);
        if (FAILED(hr))
            return hr;
    }
    else if (m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
    {
        CStream *pStream = new CStream ( m_pClass->m_pLoader );
        if (!pStream)
            return E_OUTOFMEMORY;
        scomIStream = pStream;
        hr = pStream->Open(m_ObjectDesc.m_pIStream, m_ObjectDesc.m_liStartPosition);
        if (FAILED(hr))
            return hr;
    }

    // Load the object
    IPersistStream* pIPS = NULL;
    hr = scomIObject->QueryInterface( IID_IPersistStream, (void**)&pIPS );
    if (FAILED(hr))
        return hr;
    // Save the new object.  Needs to be done before loading because of circular references.  While this object
    // loads it could get other objects and those other objects could need to get this object.
    SafeRelease(m_pIDMObject);
    m_pIDMObject = scomIObject.disown();
    hr = pIPS->Load( scomIStream );
    pIPS->Release();
    if (FAILED(hr))
    {
        // Clear the object we set above.
        SafeRelease(m_pIDMObject);
        return hr;
    }

    // Merge in descriptor information from the object
    CDescriptor Desc;
    DMUS_OBJECTDESC DESC;
    memset((void *)&DESC,0,sizeof(DESC));
    DESC.dwSize = sizeof (DMUS_OBJECTDESC);
    m_pIDMObject->GetDescriptor(&DESC);
    Desc.Set(&DESC);
    m_ObjectDesc.Merge(&Desc);
    m_ObjectDesc.m_dwValidData |= DMUS_OBJ_LOADED;
    m_ObjectDesc.Get(&DESC);
    m_pIDMObject->SetDescriptor(&DESC);
    return hr;
}

// Collect everything that is unmarked.
void CObjectList::GC_Sweep(BOOL bOnlyScripts)

{
    // sweep through looking for unmarked GC objects
    CObject *pObjectPrev = NULL;
    CObject *pObjectNext = NULL;
    for (CObject *pObject = this->GetHead(); pObject; pObject = pObjectNext)
    {
        // get the next item now since we could be messing with the list
        pObjectNext = pObject->GetNext();

        bool fRemoved = false;
        if(bOnlyScripts && pObject->m_ObjectDesc.m_guidClass != CLSID_DirectMusicScript)
        {
            pObjectPrev = pObject;
            continue;
        }


        if (pObject->m_dwScanBits & SCAN_GC)
        {
            if (!(pObject->m_dwScanBits & SCAN_GC_MARK))
            {
                // the object is unused

                // Zombie it to break any cyclic references
                IDirectMusicObject *pIDMO = pObject->m_pIDMObject;
                if (pIDMO)
                {
                    IDirectMusicObjectP *pIDMO8 = NULL;
                    HRESULT hr = pIDMO->QueryInterface(IID_IDirectMusicObjectP, reinterpret_cast<void**>(&pIDMO8));
                    if (SUCCEEDED(hr))
                    {
                        pIDMO8->Zombie();
                        pIDMO8->Release();
                    }

#ifdef DBG
                    DebugTrace(4, SUCCEEDED(hr) ? "   *%08X Zombied\n" : "   *%08X no IDirectMusicObjectP interface\n", pObject);
#endif
                }

                // remove it from the list
                if (pObjectPrev)
                    pObjectPrev->Remove(pObject);
                else
                    this->RemoveHead();
                delete pObject;
                fRemoved = true;
            }
            else
            {
                // clear mark for next time
                pObject->m_dwScanBits &= ~SCAN_GC_MARK;
            }
        }

        if (!fRemoved)
            pObjectPrev = pObject;
    }
}

CClass::CClass(CLoader *pLoader)

{
    assert(pLoader);
    m_fDirSearched = FALSE;
    m_pLoader = pLoader;
    m_fKeepObjects = pLoader->m_fKeepObjects;
    m_dwLastIndex = NULL;
    m_pLastObject = NULL;
}

CClass::CClass(CLoader *pLoader, CDescriptor *pDesc)

{
    assert(pLoader);
    assert(pDesc);

    m_fDirSearched = FALSE;
    m_pLoader = pLoader;
    m_fKeepObjects = pLoader->m_fKeepObjects;
    m_dwLastIndex = NULL;
    m_pLastObject = NULL;

    // Set up this class's descritor with just the class id.
    m_ClassDesc.m_guidClass = pDesc->m_guidClass;
    m_ClassDesc.m_dwValidData = DMUS_OBJ_CLASS;
}


CClass::~CClass()

{
    ClearObjects(FALSE,NULL);
}

void CClass::ClearObjects(BOOL fKeepCache, WCHAR *pwzExtension)

//  Clear objects from the class list, optionally keep 
//  cached objects or objects that are not of the requested extension.

{
    m_fDirSearched = FALSE;
    CObjectList KeepList;   // Use to store objects to keep.
    while (!m_ObjectList.IsEmpty())
    {
        CObject *pObject = m_ObjectList.RemoveHead();
        DMUS_OBJECTDESC DESC;
        pObject->m_ObjectDesc.Get(&DESC);
        // If the keepCache flag is set, we want to hang on to the object
        // if it is GM.dls, an object that's currently cached, or
        // an object with a different extension from what we are looking for.
        if (fKeepCache && 
            ((DESC.guidObject == GUID_DefaultGMCollection)
#ifdef DRAGON
            || (DESC.guidObject == GUID_DefaultGMDrums)
#endif
            || pObject->m_pIDMObject 
            || !pObject->m_ObjectDesc.IsExtension(pwzExtension)))
        {
            KeepList.AddHead(pObject);
        }
        else
        {
            delete pObject;
        }
    }
    //  Now put cached objects back in list.
    while (!KeepList.IsEmpty())
    {
        CObject *pObject = KeepList.RemoveHead();
        m_ObjectList.AddHead(pObject);
    }
    m_pLastObject = NULL;
}


HRESULT CClass::FindObject(CDescriptor *pDesc,CObject ** ppObject, CObject *pNotThis)

{
    if(pDesc == NULL)
    {
        return E_POINTER;
    }

    DWORD dwSearchBy = pDesc->m_dwValidData;
    CObject *pObject = NULL;

    if (dwSearchBy & DMUS_OBJ_OBJECT)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_OBJECT)
            {
                if (pObject->m_ObjectDesc.m_guidObject == pDesc->m_guidObject)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_MEMORY)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_MEMORY)
            {
                if (pObject->m_ObjectDesc.m_pbMemData == pDesc->m_pbMemData)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_STREAM)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_STREAM)
            {
                if (pObject->m_ObjectDesc.m_pIStream == pDesc->m_pIStream)
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if ((dwSearchBy & DMUS_OBJ_FILENAME) && (dwSearchBy & DMUS_OBJ_FULLPATH))
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if ((pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME) &&
                (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH))
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzFileName,  pDesc->m_pwzFileName))
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if ((dwSearchBy & DMUS_OBJ_NAME) && (dwSearchBy & DMUS_OBJ_CATEGORY))
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if ((pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_NAME) &&
                (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_CATEGORY))
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzCategory,pDesc->m_pwzCategory))
                {
                    if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzName, pDesc->m_pwzName))
                    {
                        *ppObject = pObject;
                        return S_OK;
                    }
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_NAME)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_NAME)
            {
                if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzName, pDesc->m_pwzName))
                {
                    *ppObject = pObject;
                    return S_OK;
                }
            }
        }
    }
    if (dwSearchBy & DMUS_OBJ_FILENAME)
    {
        pObject = m_ObjectList.GetHead();
        for (;pObject != NULL; pObject = pObject->GetNext())
        {
            if (pObject == pNotThis) continue;
            if (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FILENAME)
            {
                if ((dwSearchBy & DMUS_OBJ_FULLPATH) == (pObject->m_ObjectDesc.m_dwValidData & DMUS_OBJ_FULLPATH))
                {
                    if (!_wcsicmp(pObject->m_ObjectDesc.m_pwzFileName, pDesc->m_pwzFileName))
                    {
                        *ppObject = pObject;
                        return S_OK;
                    }
                }
                else
                {
                    WCHAR *pC1 = pObject->m_ObjectDesc.m_pwzFileName;
                    WCHAR *pC2 = pDesc->m_pwzFileName;
                    if (dwSearchBy & DMUS_OBJ_FULLPATH)
                    {
                        pC1 = wcsrchr(pObject->m_ObjectDesc.m_pwzFileName, L'\\');
                    }
                    else
                    {
                        pC2 = wcsrchr(pDesc->m_pwzFileName, '\\');
                    }
                    if (pC1 && pC2)
                    {
                        if (!_wcsicmp(pC1,pC2))
                        {
                            *ppObject = pObject;
                            return S_OK;
                        }
                    }
                }
            }
        }
    }

    *ppObject = NULL;
    return DMUS_E_LOADER_OBJECTNOTFOUND;
}

HRESULT CClass::EnumerateObjects(DWORD dwIndex,CDescriptor *pDesc)

{
    if(pDesc == NULL)
    {
        return E_POINTER;
    }

    if (m_fDirSearched == FALSE)
    {
//      SearchDirectory();
    }
    if ((dwIndex < m_dwLastIndex) || (m_pLastObject == NULL))
    {
        m_dwLastIndex = 0;
        m_pLastObject = m_ObjectList.GetHead();
    }
    while (m_dwLastIndex < dwIndex)
    {
        if (!m_pLastObject) break;
        m_dwLastIndex++;
        m_pLastObject = m_pLastObject->GetNext();
    }
    if (m_pLastObject)
    {
        pDesc->Copy(&m_pLastObject->m_ObjectDesc);
        return S_OK;
    }
    return S_FALSE;
}

HRESULT CClass::GetPath(WCHAR* pwzPath)

{
    if(pwzPath == NULL)
    {
        return E_POINTER;
    }

    if (m_ClassDesc.m_dwValidData & DMUS_OBJ_FILENAME)
    {
        wcsncpy(pwzPath, m_ClassDesc.m_pwzFileName, DMUS_MAX_FILENAME);
        return S_OK;
    }
    else 
    {
        return m_pLoader->GetPath(pwzPath);
    }
}

// returns S_FALSE if the search directory is already set to this.
HRESULT CClass::SetSearchDirectory(WCHAR * pwzPath,BOOL fClear)

{
    if(pwzPath == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr;

    hr = m_ClassDesc.SetFileName(pwzPath);
    if (SUCCEEDED(hr))
    {
        m_ClassDesc.m_dwValidData |= DMUS_OBJ_FULLPATH;
    }
    if (fClear)
    {
        CObjectList KeepList;   // Use to store objects to keep.
        while (!m_ObjectList.IsEmpty())
        {
            CObject *pObject = m_ObjectList.RemoveHead();
            if (pObject->m_pIDMObject)
            {
                KeepList.AddHead(pObject);
            }
            else
            {
                // check for the special case of the default gm collection.
                // don't clear that one out.
                DMUS_OBJECTDESC DESC;
                pObject->m_ObjectDesc.Get(&DESC);
                if( DESC.guidObject == GUID_DefaultGMCollection )
                {
                    KeepList.AddHead(pObject);
                }
                else
                {
                    delete pObject;
                }
            }
        }
        //  Now put cached objects back in list.
        while (!KeepList.IsEmpty())
        {
            CObject *pObject = KeepList.RemoveHead();
            m_ObjectList.AddHead(pObject);
        }
        m_pLastObject = NULL;
    }
    return hr;
}

HRESULT CClass::GetObject(CDescriptor *pDesc, CObject ** ppObject)

{
    if(pDesc == NULL)
    {
        return E_POINTER;
    }
    
    HRESULT hr = FindObject(pDesc,ppObject);
    if (SUCCEEDED(hr)) // Okay, found object in list.
    {
        return hr;
    }
    *ppObject = new CObject (this, pDesc);
    if (*ppObject)
    {
        m_ObjectList.AddHead(*ppObject);
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

void CClass::RemoveObject(CObject* pRemoveObject)
//  Remove an object from the class list
{
    CObjectList KeepList;   // Use to store objects to keep.
    while (!m_ObjectList.IsEmpty())
    {
        CObject *pObject = m_ObjectList.RemoveHead();
        if( pObject == pRemoveObject )
        {
            delete pObject;
            // we can assume no duplicates, and we should avoid comparing the deleted
            // object to the remainder of the list
            break;
        }
        else
        {
            KeepList.AddHead(pObject);
        }
    }
    //  Now put cached objects back in list.
    while (!KeepList.IsEmpty())
    {
        CObject *pObject = KeepList.RemoveHead();
        m_ObjectList.AddHead(pObject);
    }
    m_pLastObject = NULL;
}

HRESULT CClass::ClearCache(bool fClearStreams)

{
    CObject *pObject = m_ObjectList.GetHead();
    CObject *pObjectPrev = NULL; // remember the previous object -- needed to quickly remove the current object from the list
    CObject *pObjectNext = NULL; // remember the next object -- needed because the current object may be removed from the list
    for (;pObject;pObject = pObjectNext)
    {
        if (fClearStreams)
            pObject->m_ObjectDesc.ClearIStream();
        pObjectNext = pObject->GetNext();
        if (pObject->m_pIDMObject)
        {
            if (pObject->m_dwScanBits & SCAN_GC)
            {
                // Other objects may have references to this one so we need to keep this object around
                // and track its references.  We'll hold onto the DMObject pointer too because we may
                // later need to Zombie the object in order to break a cyclic reference.

                // We'll place an unloaded object with a duplicate descriptor in the cache to match the
                // non-GC behavior and then move the original object into a list of released objects that
                // will eventually be reclaimed by CollectGarbage.

                CObject *pObjectUnloaded = new CObject(this, &pObject->m_ObjectDesc);
                if (!pObjectUnloaded)
                {
                    return E_OUTOFMEMORY;
                }

                if (!pObjectPrev)
                    m_ObjectList.Remove(pObject);
                else
                    pObjectPrev->Remove(pObject);
                m_ObjectList.AddHead(pObjectUnloaded);
                m_pLoader->GC_UpdateForReleasedObject(pObject);
            }
            else
            {
                pObject->m_pIDMObject->Release();
                pObject->m_pIDMObject = NULL;
                pObject->m_ObjectDesc.m_dwValidData &= ~DMUS_OBJ_LOADED;

                pObjectPrev = pObject;
            }
        }
    }

    return S_OK;
}

// return S_FALSE if the cache is already enabled according to fEnable,
// indicating it's already been done.
HRESULT CClass::EnableCache(BOOL fEnable)

{
    HRESULT hr = S_FALSE;
    if (!fEnable)
    {
        ClearCache(false);
    }
    if( m_fKeepObjects != fEnable )
    {
        hr = S_OK;
        m_fKeepObjects = fEnable;
    }
    return hr;
}

typedef struct ioClass
{
    GUID    guidClass;
} ioClass;


HRESULT CClass::SaveToCache(IRIFFStream *pRiff)

{
    if(pRiff == NULL)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;
    IStream* pIStream = NULL;
    MMCKINFO ck;
    WORD wStructSize = 0;
    DWORD dwBytesWritten = 0;
//  DWORD dwBufferSize;
    ioClass oClass;

    ZeroMemory(&ck, sizeof(MMCKINFO));

    pIStream = pRiff->GetStream();
    if( pIStream == NULL )
    {
        // I don't think anybody should actually be calling this function
        // if they don't have a stream.  Currently, this is only called by
        // SaveToCache file.  It definitely has a stream when it calls
        // AllocRIFFStream and the stream should still be there when
        // we arrive here.
        assert(false);

        return DMUS_E_LOADER_NOFILENAME;
    }

    // Write class chunk header
    ck.ckid = FOURCC_CLASSHEADER;
    if( pRiff->CreateChunk( &ck, 0 ) == S_OK )
    {
        wStructSize = sizeof(ioClass);
        hr = pIStream->Write( &wStructSize, sizeof(wStructSize), &dwBytesWritten );
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(wStructSize) )
        {
            pIStream->Release();
            return DMUS_E_CANNOTWRITE;
        }
        // Prepare ioClass structure
    //  memset( &oClass, 0, sizeof(ioClass) );
        memcpy( &oClass.guidClass, &m_ClassDesc.m_guidClass, sizeof(GUID) );

        // Write Class header data
        hr = pIStream->Write( &oClass, sizeof(oClass), &dwBytesWritten);
        if( FAILED( hr ) ||  dwBytesWritten != sizeof(oClass) )
        {
            hr = DMUS_E_CANNOTWRITE;
        }
        else
        {
            if( pRiff->Ascend( &ck, 0 ) != S_OK )
            {
                hr = DMUS_E_CANNOTSEEK;
            }
        }

    }
    else
    {
        hr = DMUS_E_CANNOTSEEK;
    }
    pIStream->Release();
    return hr;
}

void CClass::PreScan()

/*  Prior to scanning a directory, mark all currently loaded objects
    so they won't be confused with objects loaded in the scan or
    referenced by the cache file.
*/

{
    CObject *pObject = m_ObjectList.GetHead();
    for (;pObject != NULL; pObject = pObject->GetNext())
    {
        // clear the lower fields and set SCAN_PRIOR
        pObject->m_dwScanBits &= ~(SCAN_CACHE | SCAN_PARSED | SCAN_SEARCH);
        pObject->m_dwScanBits |= SCAN_PRIOR;
    }
}

// Helper method used to implement RemoveAndDuplicateInParentList.
void CClass::GC_Replace(CObject *pObject, CObject *pObjectReplacement)

{
    m_ObjectList.Remove(pObject);
    if (pObjectReplacement)
    {
        m_ObjectList.AddHead(pObjectReplacement);
    }
}

HRESULT CClass::SearchDirectory(WCHAR *pwzExtension)

{
    HRESULT hr;
    IDirectMusicObject *pIObject;
    hr = CoCreateInstance(m_ClassDesc.m_guidClass,
        NULL,CLSCTX_INPROC_SERVER,IID_IDirectMusicObject,
        (void **) &pIObject);
    if (SUCCEEDED(hr))
    {
        CFileStream *pStream = new CFileStream ( m_pLoader );
        if (pStream)
        {
            // We need the double the MAX_PATH size since we'll be catenating strings of MAX_PATH
            const int nBufferSize = 2 * MAX_PATH;
            WCHAR wzPath[nBufferSize];
            memset(wzPath, 0, sizeof(WCHAR) * nBufferSize);
            hr = GetPath(wzPath);
            if (SUCCEEDED(hr))
            {
                hr = S_FALSE;
                CObjectList TempList;
#ifndef UNDER_CE
                char szPath[nBufferSize];
                WIN32_FIND_DATAA fileinfoA;
#endif      
                WIN32_FIND_DATAW fileinfoW;
                HANDLE  hFindFile;
                CObject * pObject;
                
                // GetPath copies at most MAX_PATH number of chars to wzPath
                // This means that we have enough space to do a cat safely
                WCHAR wszWildCard[3] = L"*.";
                wcsncat(wzPath, wszWildCard, wcslen(wszWildCard));
                if (pwzExtension)
                {
                    // Make sure there's enough space left in wzPath to cat pwzExtension
                    size_t cPathLen = wcslen(wzPath);
                    size_t cExtLen = wcslen(pwzExtension);

                    // Do we have enough space to write the extension + the NULL char?
                    if((nBufferSize - cPathLen - 1) > cExtLen)
                    {
                        wcsncat(wzPath, pwzExtension, nBufferSize - wcslen(pwzExtension) - 1);
                    }
                }
#ifndef UNDER_CE
                if (g_fIsUnicode)
#endif
                {
                    hFindFile = FindFirstFileW( wzPath, &fileinfoW );
                }
#ifndef UNDER_CE
                else
                {
                    wcstombs( szPath, wzPath, nBufferSize );
                    hFindFile = FindFirstFileA( szPath, &fileinfoA );
                }
#endif          
                if( hFindFile == INVALID_HANDLE_VALUE )
                {
                    pStream->Release();
                    pIObject->Release();
                    return S_FALSE;
                }
                ClearObjects(TRUE, pwzExtension); // Clear everything but the objects currently loaded.
                for (;;)
                {
                    BOOL fGoParse = FALSE;
                    CDescriptor Desc;
                    GetPath(wzPath);
#ifndef UNDER_CE
                    if (g_fIsUnicode)
#endif
                    {
                        Desc.m_ftDate = fileinfoW.ftLastWriteTime;
                        wcsncat(wzPath, fileinfoW.cFileName, DMUS_MAX_FILENAME);
                    }
#ifndef UNDER_CE
                    else
                    {
                        Desc.m_ftDate = fileinfoA.ftLastWriteTime;
                