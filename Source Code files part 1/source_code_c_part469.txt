out			1


/* -------- Globals -------- */
#ifdef ZONECLI_DLL

#define gExitFuncList				(pGlobals->m_gExitFuncList)
#define gPeriodicFuncList			(pGlobals->m_gPeriodicFuncList)
#define gPeriodicTimer				(pGlobals->m_gPeriodicTimer)

#else

static ZLList				gExitFuncList;
static ZLList				gPeriodicFuncList;
static ZTimer				gPeriodicTimer;

#endif


extern ZError InitializeStockObjects(void);
extern void DeleteStockObjects(void);

/* -------- Internal Routines -------- */
static ZBool ExitListEnumFunc(ZLListItem listItem, void* objectType,
		void* objectData, void* userData);
static ZBool PeriodicListEnumFunc(ZLListItem listItem, void* objectType,
		void* objectData, void* userData);
static void PeriodicTimerFunc(ZTimer timer, void* userData);
static ZError InitializeGlobalObjects(void);
static void DeleteGlobalObjects(void);


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

/*
	Called by the system lib to initialize the common library. If it returns
	an error, then the system lib terminates the program.
*/
ZError ZCommonLibInit(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZError		err = zErrNone;
	
	
	/* Create exit func linked list object. */
	if ((gExitFuncList = ZLListNew(NULL)) == NULL)
		return (zErrOutOfMemory);
		
	/* Create periodic func linked list object. */
	if ((gPeriodicFuncList = ZLListNew(NULL)) == NULL)
		return (zErrOutOfMemory);
	
	/* Create periodic func timer. */
	if ((gPeriodicTimer = ZTimerNew()) == NULL)
		return (zErrOutOfMemory);
	if ((err = ZTimerInit(gPeriodicTimer, zPeriodicTimeout, PeriodicTimerFunc, NULL)) != zErrNone)
		return (err);
	
	/* Initialize the global objects. */
	if ((err = InitializeGlobalObjects()) != zErrNone)
		return (err);
	
	return (err);
}


/*
	Called by the system lib just before quitting to clean up the common library.
*/
void ZCommonLibExit(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	/* Stop the periodic timer first. */
	ZTimerDelete(gPeriodicTimer);
	gPeriodicTimer = NULL;
	
	/* Iterate through all exit functions. */
	ZLListEnumerate(gExitFuncList, ExitListEnumFunc, zLListAnyType, NULL, zLListFindForward);
	
	/* Delete exit func linked list object. */
	ZLListDelete(gExitFuncList);
	gExitFuncList = NULL;
	
	/* Delete periodic func linked list object. */
	ZLListDelete(gPeriodicFuncList);
	gPeriodicFuncList = NULL;
	
	/* Delete the global objects. */
	DeleteGlobalObjects();
}


/*
	Installs an exit function to be called by ZCommonLibExit(). It allows
	common lib modules to easily clean themselves up.
*/
void ZCommonLibInstallExitFunc(ZCommonLibExitFunc exitFunc, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif


	ZLListAdd(gExitFuncList, NULL, exitFunc, userData, zLListAddLast);
}


/*
	Removes an installed exit function.
*/
void ZCommonLibRemoveExitFunc(ZCommonLibExitFunc exitFunc)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif


	ZLListRemoveType(gExitFuncList, exitFunc);
}


/*
	Installs a periodic function to be called at regular intervals. This
	simply makes it easier for common lib modules to do periodic processing
	without the need to implement one of their own.
*/
void ZCommonLibInstallPeriodicFunc(ZCommonLibPeriodicFunc periodicFunc,
	void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	ZLListAdd(gPeriodicFuncList, NULL, periodicFunc, userData, zLListAddLast);
}


/*
	Removes an installed periodic function.
*/
void ZCommonLibRemovePeriodicFunc(ZCommonLibPeriodicFunc periodicFunc)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	ZLListRemoveType(gPeriodicFuncList, periodicFunc);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static ZBool ExitListEnumFunc(ZLListItem listItem, void* objectType,
		void* objectData, void* userData)
{
	ZCommonLibExitFunc		func = (ZCommonLibExitFunc) objectType;
	
	
	func(objectData);
	
	return (FALSE);
}


static ZBool PeriodicListEnumFunc(ZLListItem listItem, void* objectType,
		void* objectData, void* userData)
{
	ZCommonLibPeriodicFunc	func = (ZCommonLibPeriodicFunc) objectType;
	
	
	func(objectData);
	
	return (FALSE);
}


static void PeriodicTimerFunc(ZTimer timer, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	/* Iterate through all periodic functions. */
	ZLListEnumerate(gPeriodicFuncList, PeriodicListEnumFunc, zLListAnyType, NULL, zLListFindForward);
}


static ZError InitializeGlobalObjects(void)
{
	ZError			err = zErrNone;
	

#ifndef ZONECLI_DLL
	err = InitializeStockObjects();
#endif
	
	return (zErrNone);
}


static void DeleteGlobalObjects(void)
{
#ifndef ZONECLI_DLL
	DeleteStockObjects();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcredits.cpp ===
/*******************************************************************************

	ZCredits.c
	
		Zone(tm) credits module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Monday, October 9, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
    1       10/13/96    HI      Fixed compiler warnings.
	0		10/09/95	HI		Created.
	 
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zone.h"
#include "zonemem.h"


#define I(n)							((Credit) (n))

/*
#define zCreditFileName					"zone.zrs"

#define zWindowTitle					_T("Internet Gaming Zone")

#define zCreditTimeout					300


enum
{
	zResCreditImageZone = 0,
	zResCreditImageLogoSmall
};


typedef struct
{
	ZWindow				window;
	ZImage				image;
	ZTimer				timer;
	ZCreditEndFunc		endFunc;
} CreditType, *Credit;


//-------- Globals -------- 

// -------- Internal Routines --------
static ZBool CreditWindowFunc(ZWindow window, ZMessage* message);
static void CreditTimerFunc(ZTimer timer, void* userData);
*/

/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

/*
	Displays Zone's credit box. If timeout is TRUE, then the dialog box times out
	in few seconds. If the user clicks in the window, then the credit box is
	closed.
*/
void ZDisplayZoneCredit(ZBool timeout, ZCreditEndFunc endFunc)
{
// PCWTODO: I'm not going to bother localizing this. Who really cares?
#if 0 

	ZError				err = zErrNone;
	Credit				pThis;
	ZRect				rect;
	ZResource			resFile;
	
	
	if ((pThis = ZMalloc(sizeof(CreditType))) != NULL)
	{
		/* Get the main image. */
		if ((resFile = ZResourceNew()) != NULL)
		{
			if (ZResourceInit(resFile, ZGetCommonDataFileName(zCreditFileName)) == zErrNone)
				pThis->image = ZResourceGetImage(resFile, zResCreditImageZone);
			ZResourceDelete(resFile);
		}
		
		if (pThis->image != NULL)
		{
			/* Create window. */
			ZSetRect(&rect, 0, 0, ZImageGetWidth(pThis->image), ZImageGetHeight(pThis->image));
			if ((pThis->window = ZWindowNew()) == NULL)
				err = zErrOutOfMemory;
			if (ZWindowInit(pThis->window, &rect, zWindowDialogType, NULL, zWindowTitle,
					TRUE, FALSE, TRUE, CreditWindowFunc, zWantAllMessages, pThis) != zErrNone)
				err = zErrOutOfMemory;
			
			/* Make window modal. */
			ZWindowModal(pThis->window);
			
			/* Create timer if timeout set. */
			if (timeout)
			{
				pThis->timer = ZTimerNew();
				ZTimerInit(pThis->timer, zCreditTimeout, CreditTimerFunc, pThis);
			}
			else
			{
				pThis->timer = NULL;
			}
			
			pThis->endFunc = endFunc;
		}
		else
		{
			ZFree(pThis);
			err = zErrOutOfMemory;
		}
	}
	else
	{
		err = zErrOutOfMemory;
	}
	
	/* If an error occured and we have an endFunc, call it. */
	if (err != zErrNone)
		if (endFunc != NULL)
			endFunc();
#endif
}


ZImage ZGetZoneLogo(int16 logoType)
{
#if 0 
	ZImage				image = NULL;
	ZResource			resFile;
	
	
	/* Get the logo image. */
	if ((resFile = ZResourceNew()) != NULL)
	{
		if (ZResourceInit(resFile, ZGetCommonDataFileName(zCreditFileName)) == zErrNone)
			image = ZResourceGetImage(resFile, zResCreditImageLogoSmall);
		ZResourceDelete(resFile);
	}
	
	return (image);
#endif
    return NULL;
}



/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/

#if 0
static ZBool CreditWindowFunc(ZWindow window, ZMessage* message)
{
	Credit				this = I(message->userData);
	ZBool				msgHandled;
	ZRect				rect;
	ZCreditEndFunc		endFunc;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowChar:
		case zMessageWindowButtonDown:
			/* Hide the window and send a close window message. */
			ZWindowNonModal(pThis->window);
			ZWindowHide(pThis->window);
			ZPostMessage(pThis->window, CreditWindowFunc, zMessageWindowClose, NULL, NULL,
					0, NULL, 0, message->userData);
			msgHandled = TRUE;
			break;
		case zMessageWindowDraw:
			ZWindowGetRect(window, &rect);
			ZRectOffset(&rect, (int16) -rect.left, (int16) -rect.top);
			ZBeginDrawing(window);
			ZImageDraw(pThis->image, window, &rect, NULL, zDrawCopy);
			ZEndDrawing(window);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			ZRemoveMessage(pThis, zMessageAllTypes, TRUE);
			endFunc = pThis->endFunc;
			if (pThis->image != NULL)
				ZImageDelete(pThis->image);
			if (pThis->timer != NULL)
				ZTimerDelete(pThis->timer);
			ZWindowDelete(pThis->window);
			ZFree(pThis);

			/* Call the endFunc. */
			if (endFunc != NULL)
				endFunc();
				
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void CreditTimerFunc(ZTimer timer, void* userData)
{
	Credit				pThis = I(userData);
	
	
	ZTimerSetTimeout(timer, 0);
	
	ZWindowNonModal(pThis->window);
	ZWindowHide(pThis->window);
	ZPostMessage(pThis->window, CreditWindowFunc, zMessageWindowClose, NULL, NULL,
			0, NULL, 0, pThis);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcheck.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZCheckBox.cpp

#include "zui.h"
#include "zonecli.h"

class ZCheckBoxI : public ZObjectHeader {
public:
	ZCheckBoxFunc checkBoxFunc;
	HWND hWnd;
	void *userData;
	WNDPROC defaultWndProc;
};

////////////////////////////////////////////////////////////////////////
// ZCheckBox

ZCheckBox ZLIBPUBLIC ZCheckBoxNew(void)
{
	ZCheckBoxI* pCheckBox = new ZCheckBoxI;
	pCheckBox->nType = zTypeCheckBox;
	return (ZCheckBox)pCheckBox;
}

LRESULT CALLBACK MyCheckBoxWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE ) {
			SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}
	} // switch
	default:
		break;
	}
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)MyGetProp32(hWnd,_T("pWindow"));

	return CallWindowProc((ZONECLICALLWNDPROC)pCheckBox->defaultWndProc,hWnd,msg,wParam,lParam);
}

ZError ZLIBPUBLIC ZCheckBoxInit(ZCheckBox checkBox, ZWindow parentWindow,
		ZRect* checkBoxRect, TCHAR* title, ZBool checked, ZBool visible, ZBool enabled,
		ZCheckBoxFunc checkBoxProc, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	pCheckBox->checkBoxFunc = checkBoxProc;
	pCheckBox->userData = userData;			


	{
		DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_TABSTOP;
		if (visible) dwStyle |= WS_VISIBLE;
		if (!enabled) dwStyle |= WS_DISABLED;
		dwStyle |=  BS_CHECKBOX;
		pCheckBox->hWnd = CreateWindow(_T("BUTTON"), title, dwStyle,
			checkBoxRect->left,checkBoxRect->top,checkBoxRect->right-checkBoxRect->left,
			checkBoxRect->bottom - checkBoxRect->top, 
			ZWindowWinGetWnd(parentWindow), (HMENU)ZWindowWinGetNextControlID(parentWindow),
			g_hInstanceLocal, pCheckBox);

		if (!pCheckBox->hWnd) return zErrWindowSystemGeneric;
	 	// checkBoxs can't use the extra data, they will use the set prop feature
		MySetProp32(pCheckBox->hWnd,_T("pWindow"),(void*)pCheckBox);

		pCheckBox->defaultWndProc = (WNDPROC)SetWindowLong(pCheckBox->hWnd,GWL_WNDPROC,(LONG)MyCheckBoxWndProc);

		// set the check if required
		if (checked) {
			ZCheckBoxCheck(checkBox);
		}
	}
	return zErrNone;
}

void    ZLIBPUBLIC ZCheckBoxDelete(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	if (pCheckBox->hWnd) {
		SetWindowLong(pCheckBox->hWnd,GWL_WNDPROC,(LONG)pCheckBox->defaultWndProc);
		MyRemoveProp32(pCheckBox->hWnd,_T("pWindow"));
		DestroyWindow(pCheckBox->hWnd);
	}
	delete pCheckBox;
}

void    ZLIBPUBLIC ZCheckBoxGetRect(ZCheckBox checkBox, ZRect *checkBoxRect)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	RECT rect;
	GetClientRect(pCheckBox->hWnd,&rect);
	WRectToZRect(checkBoxRect,&rect);
}

ZError  ZLIBPUBLIC ZCheckBoxSetRect(ZCheckBox checkBox, ZRect *checkBoxRect)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	BOOL bOk = SetWindowPos(pCheckBox->hWnd, NULL,checkBoxRect->left,
		checkBoxRect->top, checkBoxRect->right - checkBoxRect->left,
		checkBoxRect->bottom - checkBoxRect->top,
		SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZCheckBoxMove(ZCheckBox checkBox, int16 left, int16 top)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	BOOL bOk = SetWindowPos(pCheckBox->hWnd, NULL,left,top,
		0,0,SWP_NOSIZE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZCheckBoxSize(ZCheckBox checkBox, int16 width, int16 height)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;

	BOOL bOk = SetWindowPos(pCheckBox->hWnd, NULL,0,0,
		width,height,SWP_NOMOVE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZBool ZLIBPUBLIC ZCheckBoxIsVisible(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	return IsWindowVisible(pCheckBox->hWnd);
}

ZError  ZLIBPUBLIC ZCheckBoxShow(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	ShowWindow(pCheckBox->hWnd, SW_SHOWNORMAL);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZCheckBoxHide(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	ShowWindow(pCheckBox->hWnd, SW_HIDE);
	return zErrNone;
}

ZBool ZLIBPUBLIC ZCheckBoxIsEnabled(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	return IsWindowEnabled(pCheckBox->hWnd);
}

ZError  ZLIBPUBLIC ZCheckBoxEnable(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	EnableWindow(pCheckBox->hWnd, TRUE);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZCheckBoxDisable(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	EnableWindow(pCheckBox->hWnd, FALSE);
	return zErrNone;
}

void    ZLIBPUBLIC ZCheckBoxGetTitle(ZCheckBox checkBox, TCHAR *title, uint16 len)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	GetWindowText(pCheckBox->hWnd,title,len);
}

ZError  ZLIBPUBLIC ZCheckBoxSetTitle(ZCheckBox checkBox, TCHAR *title)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	SetWindowText(pCheckBox->hWnd, title);
	return zErrNone;
}

LRESULT ZCheckBoxDispatchProc(ZCheckBox checkBox, WORD wNotifyCode)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	ZBool state;

	switch (wNotifyCode) {
	case BN_CLICKED:
		state = !(SendMessage(pCheckBox->hWnd, BM_GETCHECK,0,0));
		SendMessage(pCheckBox->hWnd, BM_SETCHECK, state, 0);
		pCheckBox->checkBoxFunc(pCheckBox,	state, pCheckBox->userData);
	}
	return 0L;
}

ZBool ZCheckBoxIsChecked(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	ZBool rval = (ZBool)SendMessage(pCheckBox->hWnd, BM_GETCHECK, 0, 0);

	return rval;
}

ZError ZCheckBoxCheck(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	SendMessage(pCheckBox->hWnd, BM_SETCHECK, 1, 0);
	return zErrNone;
}

ZError ZCheckBoxUnCheck(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;
	SendMessage(pCheckBox->hWnd, BM_SETCHECK, 0, 0);
	return zErrNone;
}

ZCheckBoxFunc ZLIBPUBLIC ZCheckBoxGetFunc(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;

	return pCheckBox->checkBoxFunc;
}	
	
void ZLIBPUBLIC ZCheckBoxSetFunc(ZCheckBox checkBox, ZCheckBoxFunc checkBoxFunc)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;

	pCheckBox->checkBoxFunc = checkBoxFunc;
}	

void* ZLIBPUBLIC ZCheckBoxGetUserData(ZCheckBox checkBox)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;

	return pCheckBox->userData;
}	
	
void ZLIBPUBLIC ZCheckBoxSetUserData(ZCheckBox checkBox, void* userData)
{
	ZCheckBoxI* pCheckBox = (ZCheckBoxI*)checkBox;

	pCheckBox->userData = userData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zdraw.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZDraw.cpp

#include "zui.h"
#include "zonecli.h"
//#define DEBUG_OFFSCREEN 1

extern "C" ZBool ZLIBPUBLIC ZIsButtonDown(void);

//////////////////////////////////////////////////////////////////////////
//  ZWindow Drawing Operations

HDC ZGrafPortGetWinDC(ZGrafPort grafPort)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	return pWindow->hDC;
}
// >> Draws the outlines of the rectangle with the current pen attributes
void ZLIBPUBLIC ZBeginDrawing(ZGrafPort grafPort)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	// in windows, ignore cliprect, windows will set it appropriately???
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	if (!pWindow->nDrawingCallCount) {

		// is this an Offscreen type or an Widnow type?
		if (pWindow->nType == zTypeOffscreenPort) {
#ifndef DEBUG_OFFSCREEN
			pWindow->hDC = CreateCompatibleDC(NULL);
			//Prefix warning:  If CreateCompatibleDC fails, we are screwed.
			if( pWindow->hDC != NULL )
			{
				pWindow->hBitmapSave = (HBITMAP)SelectObject(pWindow->hDC,pWindow->hBitmap);
				SetWindowOrgEx(pWindow->hDC,pWindow->portRect.left, pWindow->portRect.top,NULL);
			}
#else
			int width = pWindow->portRect.right - pWindow->portRect.left;
			int height = pWindow->portRect.bottom - pWindow->portRect.top;
			pWindow->hDC = GetDC(pWindow->hWnd);
			SetWindowOrgEx(pWindow->hDC,pWindow->portRect.left, pWindow->portRect.top,NULL);
#endif			
		} else {
			// better be a window type...
			// was this a paint dc?
			ASSERT(pWindow->nType == zTypeWindow);
			HDC hPaintDC = ZWindowWinGetPaintDC((ZWindow)pWindow);
			if (hPaintDC) {
				// begin/endpaint will handle get and release
				pWindow->hDC = hPaintDC;
			} else {

				pWindow->hDC = GetDC(ZWindowWinGetWnd((ZWindow)grafPort));

				// this is a non-WM_PAINT message draw, we must set the clip
				// rectangle to clip our children.
				HWND hWndParent = ZWindowWinGetWnd((ZWindow)grafPort);
				HWND hWnd = GetWindow(hWndParent,GW_CHILD);
				while (hWnd) {
					if (IsWindowVisible(hWnd)) {
						RECT rect;
						GetWindowRect(hWnd,&rect);
						ScreenToClient(hWndParent, (LPPOINT)&rect.left);
						ScreenToClient(hWndParent, (LPPOINT)&rect.right);
						ExcludeClipRect(pWindow->hDC,rect.left,rect.top,rect.right,rect.bottom);
					}
					hWnd = GetWindow(hWnd, GW_HWNDNEXT);
				}

				// Check the clip box. If it is NULLREGION, then set it
				// to the window.
				RECT r;
				if (GetClipBox(pWindow->hDC, &r) == NULLREGION)
				{
					GetClientRect(ZWindowWinGetWnd((ZWindow)grafPort), &r);
					HRGN hRgn = CreateRectRgn(r.left, r.top, r.right, r.bottom);
					SelectClipRgn(pWindow->hDC, hRgn);
					DeleteObject(hRgn);
				}
			}
		}
		pWindow->nDrawMode = R2_COPYPEN;

		// setup default draw mode
		SetROP2(pWindow->hDC,pWindow->nDrawMode);

		// create default drawing objects
		pWindow->hPenForeColor = (HPEN)CreatePen(PS_INSIDEFRAME,1,RGB(0x00,0x00,0x00));
		pWindow->hPenBackColor = (HPEN)CreatePen(PS_INSIDEFRAME,1,RGB(0xff,0xff,0xff));
		pWindow->hBrushForeColor = (HBRUSH)CreateSolidBrush(RGB(0x00,0x00,0x00));
		pWindow->hBrushBackColor = (HBRUSH)CreateSolidBrush(RGB(0xff,0xff,0xff));
		pWindow->nForeColor = 0x000000;
		pWindow->nBackColor = 0xffffff;
		ZSetColor(&pWindow->colorForeColor,0,0,0);
		ZSetColor(&pWindow->colorBackColor,0xff,0xff,0xff);

		// save current dc drawing objects
		pWindow->hPenSave = (HPEN)SelectObject(pWindow->hDC,pWindow->hPenForeColor);
		pWindow->hBrushSave = (HBRUSH)SelectObject(pWindow->hDC,pWindow->hBrushForeColor);

		// we have not selected a font, when we first do, we will set this
		pWindow->hFontSave = NULL;

		// set default pen width and style, in case they don't call SetPen
		// but do change the pen  color
		pWindow->penStyle = PS_INSIDEFRAME;
		pWindow->penWidth = 1;

		// see that we use the correct palette
        HPALETTE hPal = ZShellZoneShell()->GetPalette();
		if (hPal) 
        {
			pWindow->hPalSave = SelectPalette(pWindow->hDC, hPal,FALSE);
			if (RealizePalette(pWindow->hDC))
				InvalidateRect(ZWindowWinGetWnd((ZWindow)grafPort), NULL, TRUE);
		} else {
			pWindow->hPalSave = NULL;
		}

	}

	pWindow->nDrawingCallCount++;
}

void ZGetClipRect(ZGrafPort grafPort, ZRect* clipRect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	RECT rect;
	GetClipBox(pWindow->hDC,&rect);

	WRectToZRect(clipRect,&rect);
}

void ZSetClipRect(ZGrafPort grafPort, ZRect* clipRect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	RECT rect;

	//Prefix Warning: Don't dereference possibly NULL pointers.
	if( pWindow == NULL || clipRect == NULL )
	{
		return;
	}
	// clip rect must be specified in device coordinates
	ZRectToWRect(&rect,clipRect);
	LPtoDP(pWindow->hDC,(POINT*)&rect,2);
	HRGN hRgn = CreateRectRgn(rect.left,rect.top,rect.right,rect.bottom);
	//Prefix Error, if the CreateRectRgn fails, the DeleteObject below will fail.
	if( hRgn == NULL )
	{
		return;
	}
//	ExtSelectClipRgn(pWindow->hDC,hRgn,RGN_COPY); // - does not work with win32s?
	SelectClipRgn(pWindow->hDC,NULL);
	SelectClipRgn(pWindow->hDC,hRgn);
	DeleteObject(hRgn);
}

void ZLIBPUBLIC ZLine(ZGrafPort grafPort, int16 dx, int16 dy)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	pWindow->penX += dx;
	pWindow->penY += dy;
	SetROP2(pWindow->hDC,R2_COPYPEN);
	LineTo(pWindow->hDC,pWindow->penX, pWindow->penY);
}

void ZLIBPUBLIC ZLineTo(ZGrafPort grafPort, int16 x, int16 y)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	pWindow->penX = x;
	pWindow->penY = y;
	SetROP2(pWindow->hDC,R2_COPYPEN);
	LineTo(pWindow->hDC,pWindow->penX, pWindow->penY);
}
void ZLIBPUBLIC ZMove(ZGrafPort grafPort, int16 dx, int16 dy)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	pWindow->penX += dx;
	pWindow->penY += dy;
	MoveToEx(pWindow->hDC,pWindow->penX, pWindow->penY,NULL);
}

void ZLIBPUBLIC ZMoveTo(ZGrafPort grafPort, int16 x, int16 y)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	pWindow->penX = x;
	pWindow->penY = y;
	MoveToEx(pWindow->hDC,pWindow->penX, pWindow->penY,NULL);
}


void ZLIBPUBLIC ZEndDrawing(ZGrafPort grafPort)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	//Prefix Warning: Don't dereference a possibly NULL pointer.
    if( pWindow != NULL )
    {
    	
		pWindow->nDrawingCallCount--;
		if (!pWindow->nDrawingCallCount) {

			// restore original drawing objects
			SelectObject(pWindow->hDC,pWindow->hPenSave);
			SelectObject(pWindow->hDC,pWindow->hBrushSave);

			// free the objects created
			DeleteObject(pWindow->hPenForeColor);
			DeleteObject(pWindow->hPenBackColor);
			DeleteObject(pWindow->hBrushForeColor);
			DeleteObject(pWindow->hBrushBackColor);

			// if we have ever set a font, then restore default one
			if (pWindow->hFontSave) SelectObject(pWindow->hDC,pWindow->hFontSave);
			// restore original palette
			if (pWindow->hPalSave)
			{
	//HI			SelectPalette(pWindow->hDC,pWindow->hPalSave,TRUE);
	//HI			RealizePalette(pWindow->hDC);
			}

			if (pWindow->nType == zTypeOffscreenPort) {
#ifndef DEBUG_OFFSCREEN
				pWindow->hBitmap = (HBITMAP)SelectObject(pWindow->hDC,pWindow->hBitmapSave);
				DeleteDC(pWindow->hDC);
#else
				ReleaseDC(pWindow->hWnd,pWindow->hDC);
#endif
		
			} else {
				// if this is a hPaintDC then don't release it
				// the begin/end paint will handle that
				if (!ZWindowWinGetPaintDC((ZWindow)grafPort)) {
					ReleaseDC(ZWindowWinGetWnd((ZWindow)grafPort),pWindow->hDC);
				}
			}
		}
    }
}

void ZCopyImage(ZGrafPort srcPort, ZGrafPort dstPort, ZRect* srcRect,
		ZRect* dstRect, ZImage mask, uint16 copyMode)
	/*
		Copies a portion of the source of image from the srcPort into
		the destination port. srcRect is in local coordinates of srcPort and
		dstRect is in local coordinates of dstPort. You can specify a
		mask from an image to be used for masking out on the destination.
		
		This routine automatically sets up the drawing ports so the user
		does not have to call ZBeginDrawing() and ZEndDrawing().
	*/
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	ZGraphicsObjectHeader* pWindowSrc = (ZGraphicsObjectHeader*)srcPort;
	ZGraphicsObjectHeader* pWindowDst = (ZGraphicsObjectHeader*)dstPort;
	static DWORD ropCodes[] = {SRCCOPY, SRCPAINT, SRCINVERT, NOTSRCCOPY, MERGEPAINT, 0x00990066 };

	DWORD ropCode = ropCodes[copyMode]; // map the ZModes to the windows mode...

	ZBeginDrawing(srcPort);
	ZBeginDrawing(dstPort);

	HDC hDCSrc = pWindowSrc->hDC;
	HDC hDCDst = pWindowDst->hDC;

	HBITMAP hBitmapMask = NULL;
	if (mask) hBitmapMask = ZImageGetMask(mask);

	if (mask && hBitmapMask) {
		int width = dstRect->right - dstRect->left;
		int height = dstRect->bottom - dstRect->top;

	    HDC hDCTemp0 = CreateCompatibleDC(hDCDst);
	    HDC hDCTemp1 = CreateCompatibleDC(hDCDst);
	    HDC hDCMask = CreateCompatibleDC(hDCDst);
		//Prefix warning: If CreateCompatibleDC fails, SelectOjbect will dereference NULL pointer
		if( hDCTemp0 == NULL ||
			hDCTemp1 == NULL ||
			hDCMask == NULL )
		{
			ZEndDrawing(dstPort);
			ZEndDrawing(srcPort);
			return;
		}

	    HBITMAP hbmImageAndNotMask = CreateCompatibleBitmap(hDCDst, width, height);
	    HBITMAP hbmBackgroundAndMask = CreateCompatibleBitmap(hDCDst,width, height);
        HBITMAP hbmCompatibleMask = CreateCompatibleBitmap(hDCDst, width, height);

	    HBITMAP bmOld0 = (HBITMAP) SelectObject(hDCTemp0, hBitmapMask);
	    HBITMAP bmOld1 = (HBITMAP) SelectObject(hDCTemp1, hbmImageAndNotMask);
	    HBITMAP bmOldMask = (HBITMAP) SelectObject(hDCMask, hbmCompatibleMask);

        HPALETTE hZonePal = ZShellZoneShell()->GetPalette();
	    SelectPalette(hDCTemp0, hZonePal, FALSE);
	    SelectPalette(hDCTemp1, hZonePal, FALSE);

        // if the hBitmapMask is in an RGB mde and the display is in a palette mode, sometimes BitBlt doesn't map
        // black to black, who knows why.  it's been giving me 0x040404, index 0x0a, which screws up the whole masking.
        // make up a crazy palette so that doesn't happen
        static const DWORD sc_buff[] = { 0x01000300,
            0x00000000, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
            0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x00ffffff };
        static const LOGPALETTE *sc_pLogPalette = (LOGPALETTE *) sc_buff;

        HPALETTE hDumbPal = CreatePalette(sc_pLogPalette);

	    SelectPalette(hDCMask, hDumbPal ? hDumbPal : hZonePal, FALSE);
        BitBlt(hDCMask, 0, 0, width, height, hDCTemp0, 0, 0, SRCCOPY);

        if(hDumbPal)
        {
	        SelectPalette(hDCMask, hZonePal, FALSE);
            DeleteObject(hDumbPal);
        }
		

	    BitBlt(hDCTemp1, 0, 0, width, height, hDCMask, 0, 0, SRCCOPY); // copy Mask
	    BitBlt(hDCTemp1, 0, 0, width, height, hDCSrc, srcRect->left, srcRect->top, SRCERASE); // and with not mask (code: SDna)

	    SelectObject(hDCTemp1, hbmBackgroundAndMask);
	    BitBlt(hDCTemp1, 0, 0, width, height, hDCDst, dstRect->left, dstRect->top, SRCCOPY); // copy background
	    BitBlt(hDCTemp1, 0, 0, width, height, hDCMask, 0, 0, SRCAND); // and with mask

	    // or the two together
	    SelectObject(hDCTemp0, hbmImageAndNotMask);
	    BitBlt(hDCTemp1, 0, 0, width, height, hDCTemp0, 0, 0, SRCPAINT); // and with mask

	    // copy the result to the grafport...

	    BitBlt(hDCDst, dstRect->left, dstRect->top, width, height, hDCTemp1, 0, 0, SRCCOPY);

	    SelectObject(hDCTemp0,bmOld0);
	    SelectObject(hDCTemp1,bmOld1);
	    SelectObject(hDCMask,bmOldMask);

	    DeleteObject(hbmImageAndNotMask);
	    DeleteObject(hbmBackgroundAndMask);
	    DeleteObject(hbmCompatibleMask);

	    DeleteDC(hDCTemp0);
	    DeleteDC(hDCTemp1);
        DeleteDC(hDCMask);
	} else {
		// no mask to worry about 

		// do blit
        /*
		BOOL result = StretchBlt(hDCDst,dstRect->left,dstRect->top, dstRect->right - dstRect->left, dstRect->bottom - dstRect->top,
				hDCSrc, srcRect->left, srcRect->top, ZRectWidth(srcRect), ZRectHeight(srcRect), ropCode);
        */
		BitBlt(hDCDst,dstRect->left,dstRect->top, dstRect->right - dstRect->left, dstRect->bottom - dstRect->top,
				hDCSrc, srcRect->left, srcRect->top, ropCode);
	}

	ZEndDrawing(dstPort);
	ZEndDrawing(srcPort);
}


//////////////////////////////////////////////////////////////////////////////////////////////
// Rectangle Stuff

void ZLIBPUBLIC ZRectDraw(ZGrafPort grafPort, ZRect *rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	// draw the rectangle with a NULL brush to keep inside empty
	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, ::GetStockObject(NULL_BRUSH));
	SetROP2(pWindow->hDC,R2_COPYPEN);
	Rectangle(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hBrush);
}

// >> Erases the contents of the rectangle to the current background color.
void ZLIBPUBLIC ZRectErase(ZGrafPort grafPort, ZRect *rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	// erase the rectangle with the background
	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, pWindow->hBrushBackColor);
	HPEN hPen = (HPEN)SelectObject(pWindow->hDC, pWindow->hPenBackColor);
	SetROP2(pWindow->hDC,R2_COPYPEN);
	Rectangle(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hBrush);
	SelectObject(pWindow->hDC,hPen);
}

void ZLIBPUBLIC ZRectPaint(ZGrafPort grafPort, ZRect *rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_COPYPEN);
	Rectangle(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
}

void ZLIBPUBLIC ZRectInvert(ZGrafPort grafPort, ZRect* rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_XORPEN);
	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, GetStockObject(WHITE_BRUSH));
	Rectangle(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hBrush);
}

void ZRectFill(ZGrafPort grafPort, ZRect* rect, ZBrush brush)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	// draw the rectangle with a NULL brush to keep inside empty
	RECT rectw;
	ZRectToWRect(&rectw,rect);
	FillRect(pWindow->hDC,&rectw,ZBrushGetHBrush(brush));
}

//////////////////////////////////////////////////////////////////////////////////////////////
// RoundRect Stuff

void ZLIBPUBLIC ZRoundRectDraw(ZGrafPort grafPort, ZRect *rect, uint16 radius)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, ::GetStockObject(NULL_BRUSH));
	SetROP2(pWindow->hDC,R2_COPYPEN);
	RoundRect(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom, radius/2, radius/2);
	SelectObject(pWindow->hDC,hBrush);
}

// >> Erases the contents of the rectangle to the current background color.
void ZLIBPUBLIC ZRoundRectErase(ZGrafPort grafPort, ZRect *rect, uint16 radius)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, pWindow->hBrushBackColor);
	HPEN hPen = (HPEN)SelectObject(pWindow->hDC, pWindow->hPenBackColor);
	SetROP2(pWindow->hDC,R2_COPYPEN);
	RoundRect(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom, radius/2, radius/2);
	SelectObject(pWindow->hDC,hBrush);
	SelectObject(pWindow->hDC,hPen);
}

void ZLIBPUBLIC ZRoundRectPaint(ZGrafPort grafPort, ZRect *rect, uint16 radius)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_COPYPEN);
	RoundRect(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom,radius/2, radius/2);
}

void ZLIBPUBLIC ZRoundRectInvert(ZGrafPort grafPort, ZRect* rect, uint16 radius)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_XORPEN);
	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, GetStockObject(WHITE_BRUSH));
	RoundRect(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom,radius/2,radius/2);
	SelectObject(pWindow->hDC,hBrush);
}

void ZRoundRectFill(ZGrafPort grafPort, ZRect* rect, uint16 radius, ZBrush brush)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	HBRUSH hBrush;
	HPEN hPen;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_COPYPEN);
	hBrush = (HBRUSH)SelectObject(pWindow->hDC,ZBrushGetHBrush(brush));
	hPen = (HPEN)SelectObject(pWindow->hDC,(HPEN)GetStockObject(NULL_PEN));
	RoundRect(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom,radius/2,radius/2);
	SelectObject(pWindow->hDC,hPen);
	SelectObject(pWindow->hDC,hBrush);
}


//////////////////////////////////////////////////////////////////////////////////////////////
// Oval Stuff

void ZLIBPUBLIC ZOvalDraw(ZGrafPort grafPort, ZRect *rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, ::GetStockObject(NULL_BRUSH));
	SetROP2(pWindow->hDC,R2_COPYPEN);
	Ellipse(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hBrush);
}

// >> Erases the contents of the rectangle to the current background color.
void ZLIBPUBLIC ZOvalErase(ZGrafPort grafPort, ZRect *rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, pWindow->hBrushBackColor);
	HPEN hPen = (HPEN)SelectObject(pWindow->hDC, pWindow->hPenBackColor);
	SetROP2(pWindow->hDC,R2_COPYPEN);
	Ellipse(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hBrush);
	SelectObject(pWindow->hDC,hPen);
}

void ZLIBPUBLIC ZOvalPaint(ZGrafPort grafPort, ZRect *rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_COPYPEN);
	Ellipse(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
}

void ZLIBPUBLIC ZOvalInvert(ZGrafPort grafPort, ZRect* rect)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_XORPEN);
	HBRUSH hBrush = (HBRUSH)SelectObject(pWindow->hDC, GetStockObject(WHITE_BRUSH));
	Ellipse(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hBrush);
}

void ZOvalFill(ZGrafPort grafPort, ZRect* rect, ZBrush brush)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	HBRUSH hBrush;
	HPEN hPen;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	SetROP2(pWindow->hDC,R2_COPYPEN);
	hBrush = (HBRUSH)SelectObject(pWindow->hDC,ZBrushGetHBrush(brush));
	hPen = (HPEN)SelectObject(pWindow->hDC,(HPEN)GetStockObject(NULL_PEN));
	Ellipse(pWindow->hDC,rect->left,rect->top,rect->right,rect->bottom);
	SelectObject(pWindow->hDC,hPen);
	SelectObject(pWindow->hDC,hBrush);
}


////////////////////////////////////////////////////////////////////////////////
// Color Stuff

ZError ZLIBPUBLIC ZSetForeColor(ZGrafPort grafPort, ZColor *color)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	pWindow->colorForeColor = *color;
	pWindow->nForeColor = PALETTERGB(color->red, color->green, color->blue);

	// free the current fore pen and brush
	// they were selected into the dc, unselect them
	SelectObject(pWindow->hDC,GetStockObject(NULL_BRUSH));
	SelectObject(pWindow->hDC,GetStockObject(NULL_PEN));
	DeleteObject(pWindow->hPenForeColor);
	DeleteObject(pWindow->hBrushForeColor);

	pWindow->hPenForeColor = CreatePen(pWindow->penStyle,pWindow->penWidth,pWindow->nForeColor);
	pWindow->hBrushForeColor = CreateSolidBrush(pWindow->nForeColor);
	
	// select the new drawing stuff into the dc
	SelectObject(pWindow->hDC,pWindow->hPenForeColor);
	SelectObject(pWindow->hDC,pWindow->hBrushForeColor);

	// set the current text fore color
	SetTextColor(pWindow->hDC, pWindow->nForeColor);

	return zErrNone;
}

void ZLIBPUBLIC ZGetForeColor(ZGrafPort grafPort, ZColor *color)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	*color = pWindow->colorForeColor;
}

ZError ZLIBPUBLIC ZSetBackColor(ZGrafPort grafPort, ZColor *color)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	pWindow->colorBackColor = *color;
	pWindow->nBackColor = PALETTERGB(color->red, color->green, color->blue);

	// free the current back pen and brush
	DeleteObject(pWindow->hPenBackColor);
	DeleteObject(pWindow->hBrushBackColor);

	// create the new one...
	pWindow->hPenBackColor = CreatePen(PS_INSIDEFRAME,1,pWindow->nBackColor);
	pWindow->hBrushBackColor = CreateSolidBrush(pWindow->nBackColor);

	// set the text back color
	SetBkColor(pWindow->hDC,pWindow->nBackColor);

	return zErrNone;
}

void ZLIBPUBLIC ZGetBackColor(ZGrafPort grafPort, ZColor *color)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	*color = pWindow->colorBackColor;
}

void ZSetPenWidth(ZGrafPort grafPort, int16 penWidth)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// set the grafport styles and the new forecolor
	pWindow->penStyle = PS_INSIDEFRAME;
	pWindow->penWidth = penWidth;

	// free the current fore pen and brush
	// they were selected into the dc, unselect them
	SelectObject(pWindow->hDC,GetStockObject(NULL_PEN));

	DeleteObject(pWindow->hPenForeColor);
	DeleteObject(pWindow->hPenBackColor);

	pWindow->hPenForeColor = CreatePen(pWindow->penStyle,pWindow->penWidth,pWindow->nForeColor);
	pWindow->hPenBackColor = CreatePen(PS_INSIDEFRAME,1,pWindow->nBackColor);
	
	// select the new drawing stuff into the dc
	SelectObject(pWindow->hDC,pWindow->hPenForeColor);
}

void ZSetDrawMode(ZGrafPort grafPort, int16 drawMode)
	/*
		Draw mode affects all pen drawing (lines and rectangles) and
		text drawings.
	*/
{
	static int fnDrawCodes[] = {R2_COPYPEN, R2_MERGEPEN, R2_XORPEN, R2_NOTCOPYPEN, R2_NOTMERGEPEN, R2_NOTXORPEN };
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	ASSERT(drawMode<6);

	SetROP2(pWindow->hDC,fnDrawCodes[drawMode]);
}


////////////////////////////////////////////////////////////////////////////
// Other Stuff

void ZLIBPUBLIC ZSetFont(ZGrafPort grafPort, ZFont font)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;

	// must have called ZBeginDrawing
	ASSERT(pWindow->nDrawingCallCount);

	HFONT hFont = ZFontWinGetFont(font);
	// always keep the last font set selected in the DC.

	// if we have never set a font in this dc, save the default font
	// to restore later
	if (!pWindow->hFontSave) {
		pWindow->hFontSave = (HFONT)SelectObject(pWindow->hDC,hFont);
	} else {
		SelectObject(pWindow->hDC,hFont);
	}
}

void ZLIBPUBLIC ZDrawText(ZGrafPort grafPort, ZRect* rect, uint32 justify,
	TCHAR* text)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	uint32 mode;

    ZBool fRTL = ZIsLayoutRTL();
	// desired font always selected

	if (justify & zTextJustifyWrap) {
		mode = DT_VCENTER | DT_WORDBREAK;
	} else {
		mode = DT_VCENTER | DT_SINGLELINE;
	}

    // TODO: Do this switch or use the DT_RTLREADING mode?
	switch ((justify & ~zTextJustifyWrap)) {
	case zTextJustifyLeft:
        mode |= ( fRTL ? DT_RIGHT : DT_LEFT );
		break;
	case zTextJustifyRight:
        mode |= ( fRTL ? DT_LEFT : DT_RIGHT );
		break;
	case zTextJustifyCenter:
		mode |= DT_CENTER;
		break;
	}

	RECT wrect;
	ZRectToWRect(&wrect,rect);

	SetBkMode(pWindow->hDC,TRANSPARENT); // always see through
	DrawText(pWindow->hDC,text,lstrlen(text),&wrect,mode);
}

void ZLIBPUBLIC ZSetCursor(ZGrafPort grafPort, ZCursor cursor)
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	//TRACE0("ZSetCursor Not supported yet\n");
}

int16 ZLIBPUBLIC ZTextWidth(ZGrafPort grafPort, TCHAR* text)
	/*
		Returns the width of the text in pixels if drawn in grafPort using ZDrawText().
	*/
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	SIZE size;
	ZBeginDrawing(grafPort);
	GetTextExtentPoint(pWindow->hDC,text,lstrlen(text),&size);
	ZEndDrawing(grafPort);
	return (int16)size.cx;
}

int16 ZLIBPUBLIC ZTextHeight(ZGrafPort grafPort, TCHAR* text)
	/*
		Returns the height of the text in pixels if drawn in grafPort using ZDrawText().
	*/
{
	ZGraphicsObjectHeader* pWindow = (ZGraphicsObjectHeader*)grafPort;
	SIZE size;
	ZBeginDrawing(grafPort);
	GetTextExtentPoint(pWindow->hDC,text,lstrlen(text),&size);
	ZEndDrawing(grafPort);
	return (int16)size.cy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zcliroom.cpp ===
/*******************************************************************************

	ZCliRoom.c
	
		Generic client room module.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, July 15, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	37		05/15/98	leonp	Added ZCRoomGetRoomOptions()
	36		05/15/97	HI		Do not pass zLobbyRoomName to ZRoomWindowInit
								anymore.
	35		03/28/97	HI		Solve re-entrancy problem while deleting
								games.
	34		03/25/97	HI		Stop all timers in HandleDisconnectMessage().
	33		03/13/97	HI		Added check for room inited before handling
								window messages. Fix reentracy problems.
	32		03/07/97	HI		Reduced the width of info box so that the
								room fits in the screen.
	31		03/06/97	HI		Modified call to ZInfoInit().
	30		03/04/97	HI		Added disconnect msg support.
								Do not draw host name in player info box.
								Fixed name scroll bar range setting.
	29		03/03/97	HI		Fix page increments on the name scroll bar.
	28		02/23/97	HI		Fix player synch problem after being removed.
								Was not clearing blocked messages.
	27		02/16/97	HI		Some more crap.
	26		02/11/97	RJK		Added user data to main window structure (zLobbyRoomName)
	25		02/05/97	HI		Changed friendColor.
	24		02/04/97	HI		Removed room help button and window.
								Refixed the scroll bars to system default width.
	24		02/03/97	HI		Fixed up the name list a bit more.
	23		02/03/97	HI		Changed friends color.
	22		02/02/97	HI		Narrow the scroll bars to a fixed width of 12
								for fitting the control within the IE window.
	21		01/30/97	HI		Check for existence of gTables before destroying
								objects within the tables in RoomExit().
	20		01/29/97	HI		Modified DrawTable() for new room graphics --
								don't paint background.
	19		01/22/97	HI		Set playerOnSize and kibitzingOnSize to 0 when
								memory allocatio fails.
	18		01/15/97	HI		Fixed vote flag clearing problem in
								HandleTableStatusMessage().
	17		01/02/97	HI		Create windows hidden and then bring to front
								so that they are always on top.
	16		12/27/96	HI		Rearrange the tables, info, and names sections.
	15		12/18/96	HI		Cleaned up RoomExit().
    14      12/16/96    HI      Changed ZMemCpy() to memcpy().
	13		12/12/96	HI		Remove MSVCRT.DLL dependency.
	12		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
	11		11/15/96	HI		Modified ZClienRoomInit() parameters.
	10		11/13/96	HI		Added ZCRoomPromptExit().
	9		11/11/96	HI		Created zcliroom.h.
								Conditionalized changes for ZONECLI_DLL.
	8		11/9/96		JWS		Getting user name from connection layer
	7		10/31/96	HI		Added error handling code.
	6		10/31/96	HI		Disabled credits and lib version from the help
								window.
	5		10/27/96	CHB		Added ZCRoomAddBlockedMessage
	4		10/26/96	CHB		Added ZCRoomDeleteBlockedMessages
	3		10/23/96	HI		Changed serverAddr parameter of ZClientRoomInit()
								and others to char* from int32.
    2       10/13/96    HI      Fixed compiler warnings.
	1		05/01/96	HI		Added support zRoomSeatActionDenied.
	0		07/15/95	HI		Created.
	 
*******************************************************************************/

#pragma warning(disable:4761)

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define _ZMEMORY_ // prevent it's inclusion since this is .cpp and zonemem.h gets included
#include "zoneint.h"
#include "zroom.h"
//#include "zserver.h"
//#include "zgame.h"
#include "zcliroom.h"
#include "zonecli.h"
#include "zoneclires.h"
#include "zui.h"
#include "zservcon.h"
//#include "zutils.h"
#include "commonmsg.h"
#include "EventQueue.h"
#include "ZoneEvent.h"
#include "zcliroomimp.h"
#include <malloc.h>
#include "zoneresource.h"
#include "protocol.h"


#define zPlayerNotAvail				0
#define zInvalSeat					(-1)

#define zArrayAllocSize				4

/* -------- Globals -------- */
#ifdef ZONECLI_DLL

#define gConnection					(pGlobals->m_gConnection)
#define gServerPort                 (pGlobals->m_gServerPort)
#define gExiting                    (pGlobals->m_gExiting)
#define gRoomWindow                 (pGlobals->m_gRoomWindow)
#define gTableScrollBar				(pGlobals->m_gTableScrollBar)
#define gUserID						(pGlobals->m_gUserID)
#define gGroupID					(pGlobals->m_gGroupID)
#define gUserName					(pGlobals->m_gUserName)
#define gGameOptions				(pGlobals->m_gGameOptions)
#define gNumTables					(pGlobals->m_gNumTables)
#define gTables						(pGlobals->m_gTables)
#define gNumPlayers					(pGlobals->m_gNumPlayers)
#define gFirstTableIndex			(pGlobals->m_gFirstTableIndex)
#define gNumTablesDisplayed			(pGlobals->m_gNumTablesDisplayed)
#define gNamesScrollBar				(pGlobals->m_gNamesScrollBar)
#define gFirstNameIndex				(pGlobals->m_gFirstNameIndex)
#define gRoomInited					(pGlobals->m_gRoomInited)
#define gTableOffscreen				(pGlobals->m_gTableOffscreen)
#define gJoinKibitzTable			(pGlobals->m_gJoinKibitzTable)
#define gJoinKibitzSeat				(pGlobals->m_gJoinKibitzSeat)
#define gTableImage					(pGlobals->m_gTableImage)
#define gGameIdleImage				(pGlobals->m_gGameIdleImage)
#define gGamingImage				(pGlobals->m_gGamingImage)
#define gStartButtonUpImage			(pGlobals->m_gStartButtonUpImage)
#define gStartButtonDownImage		(pGlobals->m_gStartButtonDownImage)
#define gPendingImage				(pGlobals->m_gPendingImage)
#define gVoteImage					(pGlobals->m_gVoteImage)
#define gEmptySeatImage				(pGlobals->m_gEmptySeatImage)
#define gComputerPlayerImage		(pGlobals->m_gComputerPlayerImage)
#define gHumanPlayerImage			(pGlobals->m_gHumanPlayerImage)
#define gTableRect					(pGlobals->m_gTableRect)
#define gTableNumRect				(pGlobals->m_gTableNumRect)
#define gStartRect					(pGlobals->m_gStartRect)
#define gGameMarkerRect				(pGlobals->m_gGameMarkerRect)
#define gEmptySeatRect				(pGlobals->m_gEmptySeatRect)
#define gComputerPlayerRect			(pGlobals->m_gComputerPlayerRect)
#define gHumanPlayerRect			(pGlobals->m_gHumanPlayerRect)
#define gVoteRects					(pGlobals->m_gVoteRects)
#define gNameRects					(pGlobals->m_gNameRects)
#define gRects						(pGlobals->m_gRects)
#define gNameCellRects				(pGlobals->m_gNameCellRects)
#define gGameName					(pGlobals->m_gGameName)
#define gNumPlayersPerTable			(pGlobals->m_gNumPlayersPerTable)
#define gConnectionInfo				(pGlobals->m_gConnectionInfo)
#define gTableWidth					(pGlobals->m_gTableWidth)
#define gTableHeight				(pGlobals->m_gTableHeight)
#define gNumTablesAcross			(pGlobals->m_gNumTablesAcross)
#define gNumTablesDown				(pGlobals->m_gNumTablesDown)
#define gBackgroundColor			(pGlobals->m_gBackgroundColor)
#define gRoomInfoStrIndex			(pGlobals->m_gRoomInfoStrIndex)
#define gTimer						(pGlobals->m_gTimer)
#define gInfoBarButtonMargin		(pGlobals->m_gInfoBarButtonMargin)
#define gRoomHelpWindow				(pGlobals->m_gRoomHelpWindow)
#define gRoomHelpButton				(pGlobals->m_gRoomHelpButton)
#define gLeaveRoomPrompted			(pGlobals->m_gLeaveRoomPrompted)
#define gPingTimer					(pGlobals->m_gPingTimer)
#define gPingServer					(pGlobals->m_gPingServer)
#define gPingLastSentTime			(pGlobals->m_gPingLastSentTime)
#define gPingLastTripTime			(pGlobals->m_gPingLastTripTime)
#define gPingCurTripTime			(pGlobals->m_gPingCurTripTime)
#define gPingInterval				(pGlobals->m_gPingInterval)
#define gPingMinInterval			(pGlobals->m_gPingMinInterval)
#define gPingBadCount				(pGlobals->m_gPingBadCount)
#define gShowPlayerInfo				(pGlobals->m_gShowPlayerInfo)
#define gShowPlayerInfoWindow		(pGlobals->m_gShowPlayerInfoWindow)
#define gLightImages				(pGlobals->m_gLightImages)
#define gFriends					(pGlobals->m_gFriends)
#define gGetObjectFunc				(pGlobals->m_gGetObjectFunc)
#define gDeleteObjectsFunc			(pGlobals->m_gDeleteObjectsFunc)
#define gGetHelpTextFunc			(pGlobals->m_gGetHelpTextFunc)
#define gCustomItemFunc				(pGlobals->m_gCustomItemFunc)

#define gpCurrentTip				(pGlobals->m_gpCurrentTip)
#define gdwTipDisplayMask			(pGlobals->m_gdwTipDisplayMask)
#define gpTipFinding				(pGlobals->m_gpTipFinding)
#define gpTipStarting				(pGlobals->m_gpTipStarting)
#define gpTipWaiting				(pGlobals->m_gpTipWaiting)

#define gGameShell                  (pGlobals->m_gGameShell)

#else

static ZSConnection     gConnection;
static uint16           gServerPort;
static BOOL             gExiting;
static ZWindow          gRoomWindow;
static ZScrollBar		gTableScrollBar;
static uint32			gUserID;
static uint32			gGroupID;
static TCHAR		    gUserName[zUserNameLen + 1];
static uint32			gGameOptions;
static uint16			gNumTables;
static TableInfo*		gTables;
static uint16			gNumPlayers;
static int16			gFirstTableIndex;
static uint16			gNumTablesDisplayed;
static ZScrollBar		gNamesScrollBar;
static uint16			gFirstNameIndex;
static ZBool			gRoomInited;
static ZOffscreenPort	gTableOffscreen;
static int16			gJoinKibitzTable;
static int16			gJoinKibitzSeat;
static ZImage			gTableImage;
static ZImage			gGameIdleImage;
static ZImage			gGamingImage;
static ZImage			gStartButtonUpImage;
static ZImage			gStartButtonDownImage;
static ZImage			gPendingImage;
static ZImage			gVoteImage[zMaxNumPlayersPerTable];
static ZImage			gEmptySeatImage[zMaxNumPlayersPerTable];
static ZImage			gComputerPlayerImage[zMaxNumPlayersPerTable];
static ZImage			gHumanPlayerImage[zMaxNumPlayersPerTable];
static ZRect			gTableRect;
static ZRect			gTableNumRect;
static ZRect			gStartRect;
static ZRect			gGameMarkerRect;
static ZRect			gEmptySeatRect[zMaxNumPlayersPerTable];
static ZRect			gComputerPlayerRect[zMaxNumPlayersPerTable];
static ZRect			gHumanPlayerRect[zMaxNumPlayersPerTable];
static ZRect			gVoteRects[zMaxNumPlayersPerTable];
static ZRect			gNameRects[zMaxNumPlayersPerTable];
static ZRect			gRects[] =	{
										{0, 0, 0, 75},	/* Window */
										{0, 0, 0, 27},	/* Info */
										{0, 27, 0, 27},	/* Tables */
										{0, 27, 0, 75}	/* Names */
									};
static ZRect			gNameCellRects[zNumNamesDown][zNumNamesAcross]
									=	{
											/* These rects are local to the names section rectangle. */
											{
												{0, 1, 101, 16},
												{102, 1, 203, 16},
												{204, 1, 305, 16},
												{306, 1, 407, 16},
												{408, 1, 512, 16}
											},
											{
												{0, 17, 101, 32},
												{102, 17, 203, 32},
												{204, 17, 305, 32},
												{306, 17, 407, 32},
												{408, 17, 512, 32}
											},
											{
												{0, 33, 101, 48},
												{102, 33, 203, 48},
												{204, 33, 305, 48},
												{306, 33, 407, 48},
												{408, 33, 512, 48}
											}
										};
static TCHAR			gGameName[zVillageGameNameLen + zVillageGameNameLen + 2];
static int16			gNumPlayersPerTable;
static ZInfo			gConnectionInfo;
static ZClientRoomGetObjectFunc			gGetObjectFunc;
static ZClientRoomDeleteObjectsFunc		gDeleteObjectsFunc;
static ZClientRoomGetHelpTextFunc		gGetHelpTextFunc;
static ZClientRoomCustomItemFunc		gCustomItemFunc = NULL;
static int16			gTableWidth;
static int16			gTableHeight;
static int16			gNumTablesAcross;
static int16			gNumTablesDown;
static ZColor			gBackgroundColor;
static int16			gRoomInfoStrIndex;
static ZTimer			gTimer;
static int16			gInfoBarButtonMargin;
static ZHelpWindow		gRoomHelpWindow;
static ZHelpButton		gRoomHelpButton;
static ZBool			gLeaveRoomPrompted;

static ZTimer			gPingTimer;
static ZBool			gPingServer;
static uint32			gPingLastSentTime;
static uint32			gPingLastTripTime;
static uint32			gPingCurTripTime;
static uint32			gPingInterval;
static uint32			gPingMinInterval;
static int16			gPingBadCount;

static PlayerInfo		gShowPlayerInfo;
static ZWindow			gShowPlayerInfoWindow;

static ZImage			gLightImages[zNumLightImages];

static ZHashTable		gFriends;

static IGameShell*      gGameShell;
#endif


/* -------- Routine Prototypes -------- */
static int16 IsPlayerOnTable(uint32 playerID, int16 tableID);
static int16 GetTableFromGameID(ZSGame gameID);
static ZBool IsHumanPlayerInSeat(int16 table, int16 seat);
static void SendSeatAction(int16 table, int16 seat, int16 action);
static void InitAllTables(void);
static void LeaveTable(int16 table);
static PlayerInfo CreatePlayer(ZRoomUserInfo* userInfo);

static void BlockMessage(int16 table, uint32 messageType, void* message,
					int32 messageLen);
static void UnblockMessages(int16 table);
static void ClearMessages(int16 table);
static void BlockedMessageDeleteFunc(void* type, void* pData);

static ZBool Room4GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);

static ZBool Room2GetObjectFunc(int16 objectType, int16 modifier, ZImage* image, ZRect* rect);
static ZBool IsPlayerInGame(void);

/*******************************************************************************
	EXPORTED ROUTINES TO GAME CLIENT
*******************************************************************************/
uint32 ZCRoomGetRoomOptions(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

 return gGameOptions;
}

uint32 ZCRoomGetSeatUserId(int16 table,int16 seat)
{

#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	if ((seat < zMaxNumPlayersPerTable ) && (table < gNumTables))
	{
		return gTables[table].players[seat];
	}
	else
	{
		return 0L;
	};
};


ZError		ZClientRoomInit(TCHAR* serverAddr, uint16 serverPort,
					TCHAR* gameName, int16 numPlayersPerTable, int16 tableAreaWidth,
					int16 tableAreaHeight, int16 numTablesAcross, int16 numTablesDown,
					ZClientRoomGetObjectFunc getObjectFunc,
					ZClientRoomDeleteObjectsFunc deleteObjectsFunc,
					ZClientRoomCustomItemFunc pfCustomItemFunc)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZError				err = zErrNone;
	ZUserID				userID = -1;  // ??

    gExiting = FALSE;

    gRoomWindow = NULL;

	/* Validate the parameters. */
	if (gameName == NULL || numPlayersPerTable <= 0 ||
			tableAreaWidth <= 0 || tableAreaHeight <= 0 || getObjectFunc == NULL)
		return (zErrBadParameter);
	
	gRoomInited = FALSE;

    gConnection = NULL;

	/* Save all parameters. */
	gUserID = userID;
	lstrcpy(gGameName, gameName);
	gNumPlayersPerTable = numPlayersPerTable;
	gTableWidth = tableAreaWidth;
	gTableHeight = tableAreaHeight;
	gGetObjectFunc = getObjectFunc;
	gDeleteObjectsFunc = deleteObjectsFunc;
	gGetHelpTextFunc = NULL;  //  getHelpTextFunc;
	gCustomItemFunc = pfCustomItemFunc;
	gNumTablesAcross = numTablesAcross;
	gNumTablesDown = numTablesDown;
	
	/* Create main window. */
	gRoomWindow = NULL;

	gNumTables = 0;
	gTables = NULL;
	gFirstTableIndex = 0;
	gNumTablesDisplayed = gNumTablesAcross * gNumTablesDown;
	gFirstNameIndex = 0;
	gNumPlayers = 0;
	gRoomInfoStrIndex = 0;

    return (err);
}


void		ZCRoomExit(void)
{
    RoomExit();
}


void ZCRoomSendMessage(int16 table, uint32 messageType, void* message, int32 messageLen)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    HRESULT hr = gGameShell->SendGameMessage(table, messageType, message, messageLen);
    if(FAILED(hr))
        gGameShell->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
}


void		ZCRoomGameTerminated(int16 table)
{
    // millennium does not support
    ASSERT(FALSE);
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
    gGameShell->GameCannotContinue(gTables[table].game);
}


void ZCRoomGetPlayerInfo(ZUserID playerID, ZPlayerInfo playerInfo)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZLListItem				listItem;
	PlayerInfo				player;
	
	
	if (playerID == zTheUser)
		playerID = gUserID;

    playerInfo->playerID = playerID;
    playerInfo->groupID = zUserGroupID;
    playerInfo->hostAddr = 0;
    playerInfo->hostName[0] = (TCHAR) '\0';
    playerInfo->userName[0] = (TCHAR) '\0';

    gGameShell->GetUserName(playerID, playerInfo->userName, NUMELEMENTS(playerInfo->userName));
}


void ZCRoomBlockMessages(int16 table, int16 filter, int32 filterType)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif


	gTables[table].blockingMessages = TRUE;
	gTables[table].blockMethod = filter;
	gTables[table].blockException = filterType;
}


void ZCRoomUnblockMessages(int16 table)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	gTables[table].blockingMessages = FALSE;
	UnblockMessages(table);
}


int16 ZCRoomGetNumBlockedMessages(int16 table)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	return ((int16) ZLListCount(gTables[table].blockedMessages, zLListAnyType));
}

void ZCRoomDeleteBlockedMessages(int16 table)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif


	ClearMessages(table);
}

void ZCRoomAddBlockedMessage(int16 table, uint32 messageType, void* message, int32 messageLen)
{
	BlockMessage( table, messageType, message, messageLen);
}


ZBool ZCRoomPromptExit(void)
{
	return FALSE;
}


/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/
void RoomExit(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16				i, j;
	ZCGame				game;
	
    gExiting = TRUE;

	/* Close all game windows. */
	if (gTables)
	{
		for (i = 0; i < gNumTables; i++)
		{
			if (gTables[i].startButton != NULL)
				ZPictButtonDelete(gTables[i].startButton);
			gTables[i].startButton = NULL;
			if (gTables[i].blockedMessages != NULL)
				ZLListDelete(gTables[i].blockedMessages);
			gTables[i].blockedMessages = NULL;
			game = gTables[i].game;				// Solves re-entrancy problem.
			gTables[i].game = NULL;
			//Prefix Warning: Function pointer could be NULL
			if (game != NULL && ZCGameDelete != NULL )
			{
				ZCGameDelete(game);
			}
			
			for (j = 0; j < gNumPlayersPerTable; j++)
			{
				if (gTables[i].kibitzers[j] != NULL)
					ZLListDelete(gTables[i].kibitzers[j]);
				gTables[i].kibitzers[j] = NULL;
			}
		}

		if (gTables != NULL)
			ZFree(gTables);
		gTables = NULL;
	}
	
	/* Call the client to delete room objects. */
	if (gDeleteObjectsFunc)
		gDeleteObjectsFunc();
}


void HandleAccessedMessage()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	gUserID = 0;
    gGroupID = 0;
    gNumTables = 1;
	gGameOptions = 0;
	
	/* Allocate tables. */
    gTables = (TableInfo *) ZCalloc(sizeof(TableInfo), gNumTables);
    ZASSERT(gTables);
    // PCWTODO: Is this okay to keep around?
    if ( !gTables )
        gGameShell->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
    else
        InitAllTables();

}


void HandleGameMessage(ZRoomMsgGameMessage* msg)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16					table;
	ZBool					handled;
	
	
	if(!msg->gameID)   // out-of-band in a sense method for game-specific but not table-specific messages to get around
	{
		if( ZCGameProcessMessage != NULL )
		{
			ZCGameProcessMessage(NULL, msg->messageType, (void *)((BYTE *)msg + sizeof(ZRoomMsgGameMessage)), msg->messageLen);
		}
		return;
	}

	table = 0;//GetTableFromGameID((ZSGame) msg->gameID);
	if (table != zInvalTable)
		if (gTables[table].game != NULL)
		{
			/* Are we blocking messages on this table? */
			if (gTables[table].blockingMessages)
			{
				handled = FALSE;
				
				/* Filter message? */
				if (gTables[table].blockMethod == zRoomFilterAllMessages ||
						(gTables[table].blockMethod == zRoomFilterThisMessage &&
						(uint32) gTables[table].blockException == msg->messageType))
				{
					//Prefix Warning: Function pointer could be NULL
					if( ZCGameProcessMessage != NULL )
					{
						handled = ZCGameProcessMessage(gTables[table].game, msg->messageType,
							(void*) ((BYTE*) msg + sizeof(ZRoomMsgGameMessage)), msg->messageLen);
					}
				}
				
				if (handled == FALSE)
					BlockMessage(table, msg->messageType,
							(void*) ((BYTE*) msg + sizeof(ZRoomMsgGameMessage)), msg->messageLen);
			}
			else
			{
				//Prefix Warning: Function pointer could be NULL
				if( ZCGameProcessMessage != NULL )
				{
					ZCGameProcessMessage(gTables[table].game, msg->messageType,
							(void*) ((BYTE*) msg + sizeof(ZRoomMsgGameMessage)), msg->messageLen);
				}
			}
		}
}


static int16 IsPlayerOnTable(uint32 playerID, int16 tableID)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16			i;
	
	
	for (i = 0; i < gNumPlayersPerTable; i++)
		if (gTables[tableID].players[i] == playerID)
			return (i);
			
	return (zInvalSeat);
}


IGameGame* StartNewGame(int16 tableID, ZSGame gameID, ZUserID userID, int16 seat, int16 playerType)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16					i;
    IGameGame*              pIGG = NULL;
    
    gUserID = userID;
	if(gTables[tableID].tableState != zRoomTableStateIdle)
	    return NULL;

	/*
		Clear out the kibitzer list.
			
		Should not be necessary but don't really know what is causing the leftover
		kibitzers.
	*/
	for (i = 0; i < gNumPlayersPerTable; i++)
		ZLListRemoveType(gTables[tableID].kibitzers[i], zLListAnyType);

	gTables[tableID].gameID = gameID;

	pIGG = ZCGameNew(gUserID, tableID, seat, playerType, NULL);
    if(pIGG && playerType != zGamePlayerKibitzer)
        ZPromptOnExit(TRUE);

	if(pIGG == NULL)
	{
		/* Failed to create a new game. Leave table. */
		LeaveTable(tableID);
	}
	else
	{
        gTables[tableID].game = pIGG->GetGame();
		gTables[tableID].tableState = zRoomTableStateGaming;
	}

	return pIGG;
}


static int16 GetTableFromGameID(ZSGame gameID)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16			i;
	
	
	for (i = 0; i < gNumTables; i++)
		if (gTables[i].gameID == gameID)
			return (i);
	
	return (zInvalTable);
}


static void SendSeatAction(int16 table, int16 seat, int16 action)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
    ZRoomMsgSeatRequest     msgRoomSeat;

    ZeroMemory( &msgRoomSeat, sizeof(msgRoomSeat) );
	
	msgRoomSeat.userID = gUserID;
	msgRoomSeat.table = table;
	msgRoomSeat.seat = seat;
	msgRoomSeat.action = action;
    if (gConnection)
    {
        ZSConnectionSend(gConnection, zRoomMsgSeatRequest, (BYTE*) &msgRoomSeat, sizeof(msgRoomSeat), zProtocolSigLobby);
    }
}


static void InitAllTables(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16			i, j;
	
	
	for (i = 0; i < gNumTables; i++)
	{
		gTables[i].gameID = 0;
		gTables[i].game = NULL;
		gTables[i].seatReq = zInvalSeat;
		gTables[i].kibitzing = zInvalSeat;
		gTables[i].tableState = zRoomTableStateIdle;
		gTables[i].blockingMessages = FALSE;
		gTables[i].blockedMessages = ZLListNew(BlockedMessageDeleteFunc);
		gTables[i].blockException = 0;
		gTables[i].blockMethod = 0;
		
//        if (!(gGameOptions & zGameOptionsKibitzerAllowed))
			gTables[i].tableOptions = zRoomTableOptionNoKibitzing;
//        if (!(gGameOptions & zGameOptionsJoiningAllowed))
			gTables[i].tableOptions |= zRoomTableOptionNoJoining;
		
		for (j = 0; j < gNumPlayersPerTable; j++)
		{
			gTables[i].players[j] = zPlayerNotAvail;
			gTables[i].votes[j] = FALSE;
			gTables[i].kibitzers[j] = ZLListNew(NULL);
		}
	}
}


static void LeaveTable(int16 table)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	int16			seat;
	
	
	if ((seat = IsPlayerOnTable(gUserID, table)) != zInvalSeat)
	{
		gTables[table].seatReq = zInvalSeat;
			
		/* Request to leave table. */
		SendSeatAction(table, seat, zRoomSeatActionLeaveTable);

		gTables[table].votes[seat] = FALSE;
		gTables[table].players[seat] = zPlayerNotAvail;
	}
	
	/* Delete current game. */
	DeleteGameOnTable(table);
}


void DeleteGameOnTable(int16 table)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	ZCGame				game;


	game = gTables[table].game;			// Solve re-entrancy problem.
	gTables[table].game = NULL;
	gTables[table].gameID = 0;

	ClearMessages(table);
	gTables[table].blockingMessages = FALSE;

    // because we don't get table status messages from server, set the table to idle here
    gTables[table].tableState = zRoomTableStateIdle;

	//Prefix Warning: Function pointer could be NULL
	if (game != NULL && ZCGameDelete != NULL)
	{
		ZCGameDelete(game);
	}
}



/*******************************************************************************
	MESSAGE BLOCKING ROUTINES
*******************************************************************************/
static void BlockMessage(int16 table, uint32 messageType, void* message,
					int32 messageLen)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	BlockedMessage		msg;

	
	msg = (BlockedMessage) ZCalloc(1, sizeof(BlockedMessageType));
	if (msg != NULL)
	{
		msg->msgType = messageType;
		msg->msgLen = messageLen;
		msg->fProcessed = FALSE;

		if (messageLen == 0 || message == NULL)
		{
			msg->msg = NULL;
		}
		else
		{
			if ((msg->msg = (void*) ZMalloc(messageLen)) == NULL)
                gGameShell->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
			else
				memcpy(msg->msg, message, messageLen);
		}
		ZLListAdd(gTables[table].blockedMessages, NULL, zLListNoType, (void*) msg,
				zLListAddLast);
	}
	else
	{
        gGameShell->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
	}
}


static void UnblockMessages(int16 table)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZLListItem			listItem;
	BlockedMessage		message;
	
	
	listItem = ZLListGetFirst(gTables[table].blockedMessages, zLListAnyType);
	while (listItem != NULL && gTables[table].blockingMessages == FALSE)
	{
		message = (BlockedMessage) ZLListGetData(listItem, NULL);
		if (message != NULL && !message->fProcessed)
		{
			message->fProcessed = TRUE;
			if( ZCGameProcessMessage != NULL )
			{
				ZCGameProcessMessage(gTables[table].game, message->msgType, message->msg,
						message->msgLen);
			}
			ZLListRemove(gTables[table].blockedMessages, listItem);
			listItem = ZLListGetFirst(gTables[table].blockedMessages, zLListAnyType);
		}
		else
			listItem = ZLListGetNext(gTables[table].blockedMessages, listItem, zLListAnyType);
	}
}


static void ClearMessages(int16 table)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    ZLListItem item, next;
    BlockedMessage message;

    // only remove unprocessed items - the rest are about to be deleted (in processing)
    item = ZLListGetFirst(gTables[table].blockedMessages, zLListAnyType);
	while(item != NULL)
	{
		next = ZLListGetNext(gTables[table].blockedMessages, item, zLListAnyType);
        message = (BlockedMessage) ZLListGetData(item, NULL);
        if(message && !message->fProcessed)
		    ZLListRemove(gTables[table].blockedMessages, item);
		item = next;
    }
}


static void BlockedMessageDeleteFunc(void* type, void* pData)
{
    BlockedMessage pMessage = (BlockedMessage) pData;

	if (pMessage != NULL)
	{
		if (pMessage->msg != NULL)
			ZFree(pMessage->msg);
		ZFree(pMessage);
	}
}


/*******************************************************************************
	4 PLAYER ROOM ROUTINES
*******************************************************************************/

ZError		ZClient4PlayerRoom(TCHAR* serverAddr, uint16 serverPort,
					TCHAR* gameName, ZClientRoomGetObjectFunc getObjectFunc,
					ZClientRoomDeleteObjectsFunc deleteObjectsFunc,
					ZClientRoomCustomItemFunc pfCustomItemFunc)
{
	return zErrNone;
}


/*******************************************************************************
	2 PLAYER ROOM ROUTINES
*******************************************************************************/

ZError		ZClient2PlayerRoom(TCHAR* serverAddr, uint16 serverPort,
					TCHAR* gameName, ZClientRoomGetObjectFunc getObjectFunc,
					ZClientRoomDeleteObjectsFunc deleteObjectsFunc,
					ZClientRoomCustomItemFunc pfCustomItemFunc)
{
	return zErrNone;
}


/*******************************************************************************
	Little Helpers for Getting Shell Objects
*******************************************************************************/

IGameShell *ZShellGameShell()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell;
}

IZoneShell *ZShellZoneShell()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetZoneShell();
}

IResourceManager *ZShellResourceManager()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetResourceManager();
}

ILobbyDataStore *ZShellLobbyDataStore()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetLobbyDataStore();
}

ITimerManager *ZShellTimerManager()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetTimerManager();
}

IDataStoreManager *ZShellDataStoreManager()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetDataStoreManager();
}

IDataStore *ZShellDataStoreConfig()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetDataStoreConfig();
}

IDataStore *ZShellDataStoreUI()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetDataStoreUI();
}

IDataStore *ZShellDataStorePreferences()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    return gGameShell->GetDataStorePreferences();
}

HRESULT ZShellCreateGraphicalAccessibility(IGraphicalAccessibility **ppIGA)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

    if(!ppIGA)
        return E_INVALIDARG;

    *ppIGA = NULL;
    HRESULT hr = gGameShell->GetZoneShell()->CreateService(SRVID_GraphicalAccessibility, IID_IGraphicalAccessibility, (void**) ppIGA, ZONE_NOGROUP);
    if(FAILED(hr))
        return hr;

    // this may be a bad idea.  may be nicer to kill it ourselves.  for now will do though.
	hr = gGameShell->GetZoneShell()->Attach(SRVID_GraphicalAccessibility, *ppIGA);
    if(FAILED(hr))
    {
        (*ppIGA)->Release();
        *ppIGA = NULL;
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zdtext.cpp ===
/*******************************************************************************

	ZDText.c
	
		Zone(tm) text displaying module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, July 22, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	6		02/15/97	HI		Modified to use ZMessageBox().
	5		01/02/97	HI		Use Windows' MessageBox().
	4		01/02/97	HI		Create windows hidden and then show to bring to
								front.
	3		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
    2       10/13/96    HI      Fixed compiler warnings.
	1		09/11/96	HI		Bring the window to the front after creating it.
	0		07/22/95	HI		Created.
	 
*******************************************************************************/


#pragma warning (disable:4761)


#include "zonecli.h"
#include "zui.h"


/* -------- Globals -------- */


/* -------- Internal Routines -------- */


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/


// null Millennium implementation - all uses are bogus in the Millennium context, plus it crashes
// in ZMessageBox which creates a thread that tries to access pGlobals in TLS
void ZDisplayText(TCHAR* text, ZRect* rect, ZWindow parentWindow)
{
#ifdef ZONECLI_DLL
//	ZMessageBox(parentWindow, ZClientName(), text);
#else
//	if (parentWindow != NULL)
//		MessageBox(ZWindowWinGetWnd(parentWindow), text, ZClientName(), MB_OK);
//	else
//		MessageBox(ZWindowWinGetOCXWnd(), text, ZClientName(), MB_OK);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zedit.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZEdit.cpp
#include "zui.h"
#include "zonecli.h"

class ZEditTextI : public ZObjectHeader {
public:
	ZEditTextFunc editTextFunc;
	BOOL locked;
	ZFont font;
	HWND hWnd;
	void* userData;
	WNDPROC defaultWndProc;
};

//////////////////////////////////////////////////////////////////////////
// ZEditText

// ZEditText supports only vertical scroll bars(?). All text are horizontally
// contained within the edit text box. The text is scrollable vertically.
ZEditText      ZLIBPUBLIC ZEditTextNew(void)
{
    ZEditTextI* pEditText = (ZEditTextI*)ZMalloc(sizeof(ZEditTextI));
	pEditText->nType = zTypeEditText;
	pEditText->font = NULL;
	return (ZEditText)pEditText;
}

LRESULT CALLBACK MyEditTextWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ZEditTextI* pEditText = (ZEditTextI*)MyGetProp32(hWnd,_T("pWindow"));

    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
        // PCWTODO: Need to call convert message?
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE ) {
            SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}

		// if the edit text is read-only, don't call the routine.
		// do they want any callbacks?
		if (!pEditText->locked && pEditText->editTextFunc) {
			BOOL ok = pEditText->editTextFunc(pEditText,c,pEditText->userData);
			if (ok) {
				// toss away the character if they say so...
				return 0L;
			}
		}

	} // switch
	default:
		break;
	}

	return CallWindowProc((ZONECLICALLWNDPROC)pEditText->defaultWndProc,hWnd,msg,wParam,lParam);
}

ZError ZEditTextInit(ZEditText editText, ZWindow parentWindow,
		ZRect* editTextRect, TCHAR* text, ZFont textFont, ZBool scrollBar,
		ZBool locked, ZBool wrap, ZBool drawFrame, ZEditTextFunc editTextFunc,
		void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	pEditText->editTextFunc = editTextFunc;
	pEditText->userData = userData;

	{
		DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP;
		if (scrollBar) dwStyle |= WS_VSCROLL;
		else dwStyle |= 0;
		if (wrap) {
			dwStyle |= ES_MULTILINE;
		} else {
			/* well, if not scrollbar, just scroll horizontally */
			dwStyle |= ES_AUTOHSCROLL;
		}

		if (drawFrame) {
			dwStyle |= WS_BORDER;
		}

		pEditText->hWnd = CreateWindow(_T("EDIT"), text, dwStyle,
			editTextRect->left,editTextRect->top,editTextRect->right-editTextRect->left,
			editTextRect->bottom - editTextRect->top, 
			ZWindowWinGetWnd(parentWindow), (HMENU)ZWindowWinGetNextControlID(parentWindow),
			g_hInstanceLocal, NULL);
		if (!pEditText->hWnd) return zErrWindowSystemGeneric;

		MySetProp32(pEditText->hWnd,_T("pWindow"),(void*)pEditText);

		pEditText->defaultWndProc = (WNDPROC)SetWindowLong(pEditText->hWnd,GWL_WNDPROC,(LONG)MyEditTextWndProc);

		if (textFont) {
			// copy and set the font...
			pEditText->font = ZFontCopyFont(textFont);
		
			SendMessage(pEditText->hWnd,WM_SETFONT,(WPARAM)ZFontWinGetFont(pEditText->font),0);
		}

		// set any text in the window
		if (text) {
			SetWindowText(pEditText->hWnd,text);
		}		
		pEditText->locked = locked;
		SendMessage(pEditText->hWnd,EM_SETREADONLY,pEditText->locked,0L);
	}
	return zErrNone;
}


void    ZLIBPUBLIC ZEditTextDelete(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	if (pEditText->font) {
		ZFontDelete(pEditText->font);
	}

	if (pEditText->hWnd) {
		SetWindowLong(pEditText->hWnd,GWL_WNDPROC,(LONG)pEditText->defaultWndProc);
		MyRemoveProp32(pEditText->hWnd,_T("pWindow"));
		DestroyWindow(pEditText->hWnd);
	}

    ZFree(pEditText);
}

void    ZLIBPUBLIC ZEditTextGetRect(ZEditText editText, ZRect *editTextRect)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	RECT rect;
	GetClientRect(pEditText->hWnd,&rect);
	WRectToZRect(editTextRect,&rect);
}

void  ZLIBPUBLIC ZEditTextSetRect(ZEditText editText, ZRect *editTextRect)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	BOOL bOk = SetWindowPos(pEditText->hWnd, NULL,editTextRect->left,
		editTextRect->top, editTextRect->right - editTextRect->left,
		editTextRect->bottom - editTextRect->top,
		SWP_NOZORDER);
}

void  ZLIBPUBLIC ZEditTextMove(ZEditText editText, int16 left, int16 top)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	BOOL bOk = SetWindowPos(pEditText->hWnd, NULL,left,top,
		0,0,SWP_NOSIZE|SWP_NOZORDER);
}

void  ZLIBPUBLIC ZEditTextSize(ZEditText editText, int16 width, int16 height)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	BOOL bOk = SetWindowPos(pEditText->hWnd, NULL,0,0,
		width,height,SWP_NOMOVE|SWP_NOZORDER);
}
ZBool ZLIBPUBLIC ZEditTextIsLocked(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	return pEditText->locked;
}
void ZLIBPUBLIC ZEditTextLock(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	pEditText->locked = TRUE;
	SendMessage(pEditText->hWnd,EM_SETREADONLY,pEditText->locked,0L);
}
void ZLIBPUBLIC ZEditTextUnlock(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	pEditText->locked = FALSE;
	SendMessage(pEditText->hWnd,EM_SETREADONLY,pEditText->locked,0L);
}
uint32 ZLIBPUBLIC ZEditTextGetLength(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	return SendMessage(pEditText->hWnd,WM_GETTEXTLENGTH,0,0L);
}
TCHAR* ZLIBPUBLIC ZEditTextGetText(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	int len = ZEditTextGetLength(editText)+1;
	TCHAR *szBuffer = (TCHAR*)ZMalloc(len*sizeof(TCHAR));
	GetWindowText(pEditText->hWnd,szBuffer,len);
	return szBuffer;
}

ZError ZLIBPUBLIC ZEditTextSetText(ZEditText editText, TCHAR* text)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	SetWindowText(pEditText->hWnd,text);
	return zErrNone;
}

void ZLIBPUBLIC ZEditTextAddChar(ZEditText editText, char newChar)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	TCHAR szTemp[2];
	szTemp[0] = newChar;
	szTemp[1] = 0;
	// place text at current caret spot in edit box....
//	SendMessage(pEditText->hWnd,EM_SETSEL,(WPARAM)(INT)32767,(LPARAM)(INT)32767);
	SendMessage(pEditText->hWnd,EM_REPLACESEL,0,(LPARAM)(LPCTSTR)szTemp);
}
void ZLIBPUBLIC ZEditTextAddText(ZEditText editText, TCHAR* text)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
//	char* szTemp = new char[len+1];
//	ZMemCpy(szTemp,text,len);
//	szTemp[len] = 0;
	// place text at end of output edit box....
	SendMessage(pEditText->hWnd,EM_SETSEL,(WPARAM)(INT)-1,(LPARAM)(INT)-1);
	SendMessage(pEditText->hWnd,EM_REPLACESEL,0,(LPARAM)(LPCTSTR)text);
//	SendMessage(pEditText->hWnd,EM_REPLACESEL,0,(LPARAM)(LPCSTR)szTemp);
//	delete []szTemp;
}
void ZLIBPUBLIC ZEditTextClear(ZEditText editText)
{

	ZEditTextI* pEditText = (ZEditTextI*)editText;
	SetWindowText(pEditText->hWnd,_T(""));
}

uint32 ZLIBPUBLIC ZEditTextGetInsertionLocation(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	DWORD dwStart;
	DWORD dwEnd;
	SendMessage(pEditText->hWnd,EM_GETSEL,(WPARAM)&dwStart, (WPARAM)&dwEnd);
	return dwEnd;
}
uint32 ZLIBPUBLIC ZEditTextGetSelectionLength(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	DWORD dwStart = 0;
	DWORD dwEnd = 0;
	SendMessage(pEditText->hWnd,EM_GETSEL,(WPARAM)&dwStart, (WPARAM)&dwEnd);
	return dwEnd - dwStart;
}
TCHAR* ZLIBPUBLIC ZEditTextGetSelectionText(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	TCHAR *szText = ZEditTextGetText(editText);
	DWORD dwStart = 0;
	DWORD dwEnd = 0;
	SendMessage(pEditText->hWnd,EM_GETSEL,(WPARAM)&dwStart, (WPARAM)&dwEnd);
	int len = dwEnd-dwStart+1;
	TCHAR* szBuffer = (TCHAR*)ZMalloc(len*sizeof(TCHAR));
	lstrcpyn(szBuffer,szText, len);
	szText[dwEnd-dwStart] = 0;

	ZFree(szText);
	return szBuffer;
}

void ZLIBPUBLIC ZEditTextGetSelection(ZEditText editText, uint32* start, uint32* end)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	DWORD dwStart = 0;
	DWORD dwEnd = 0;
	SendMessage(pEditText->hWnd,EM_GETSEL,(WPARAM)&dwStart, (WPARAM)&dwEnd);
	*start = dwStart;
	*end = dwEnd;
}

void ZLIBPUBLIC ZEditTextSetSelection(ZEditText editText, uint32 start, uint32 end)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	SendMessage(pEditText->hWnd,EM_SETSEL,(WPARAM)start, (WPARAM)end);
	SetFocus(pEditText->hWnd);
}

void ZLIBPUBLIC ZEditTextReplaceSelection(ZEditText editText, TCHAR* text, uint32 len)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	SendMessage(pEditText->hWnd,EM_REPLACESEL,0,(LPARAM)text);
}

void ZLIBPUBLIC ZEditTextClearSelection(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	SendMessage(pEditText->hWnd,EM_REPLACESEL,0,(LPARAM)_T(""));
}

LRESULT ZEditTextDispatchProc(ZEditText editText, WORD wNotifyCode)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;
	// do they want any callbacks?
//	if (pEditText->editTextFunc) {
//	}
	return 0L;
}

ZEditTextFunc ZLIBPUBLIC ZEditTextGetFunc(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	return pEditText->editTextFunc;
}	
	
void ZLIBPUBLIC ZEditTextSetFunc(ZEditText editText, ZEditTextFunc editTextFunc)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	pEditText->editTextFunc = editTextFunc;
}	

void* ZLIBPUBLIC ZEditTextGetUserData(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	return pEditText->userData;
}	
	
void ZLIBPUBLIC ZEditTextSetUserData(ZEditText editText, void* userData)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	pEditText->userData = userData;
}

void ZLIBPUBLIC ZEditTextSetInputFocus(ZEditText editText)
{
	ZEditTextI* pEditText = (ZEditTextI*)editText;

	SetFocus(pEditText->hWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zfile.cpp ===
/*******************************************************************************

	ZFile.c
	
		File operation routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Tuesday, May 23, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
    2       10/13/96    HI      Fixed compiler warnings.
	1		09/05/96	HI		Added file integrity check to ZGetFileVersion().
	0		05/23/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>

#include "zone.h"
#include "zoneint.h"
#include "zonemem.h"

                         
/* -------- Internal Routines -------- */
static void* GetObjectFromFile(TCHAR* fileName, uint32 objectType);


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/


ZVersion ZGetFileVersion(TCHAR* fileName)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	ZVersion			version = 0;
	int32				len;


	/* Open file. */
	if ((fd = fopen(fileName, "rb")) == NULL)
		goto Error;

	/* Read file header. */
	if (fread(&header, 1, sizeof(header), fd) != sizeof(header))
		goto Error;
	
	ZFileHeaderEndian(&header);
	
	/* Get the file size. */
	fseek(fd, 0, SEEK_END);
	len = ftell(fd);

	fclose(fd);
	
	/* Check file integrity by checking the file size. */
	if ((uint32) len >= header.fileDataSize + sizeof(header))
		version = header.version;
	else
		version = 0;

Error:
	
	return (version);
}

ZImageDescriptor* ZGetImageDescriptorFromFile(TCHAR* fileName)
{
	return ((ZImageDescriptor*) GetObjectFromFile(fileName, zFileSignatureImage));
}


ZAnimationDescriptor* ZGetAnimationDescriptorFromFile(TCHAR* fileName)
{
	return ((ZAnimationDescriptor*) GetObjectFromFile(fileName, zFileSignatureAnimation));
}


ZSoundDescriptor* ZGetSoundDescriptorFromFile(TCHAR* fileName)
{
	return ((ZSoundDescriptor*) GetObjectFromFile(fileName, zFileSignatureSound));
}


ZImage ZCreateImageFromFile(TCHAR* fileName)
{
	return (ZCreateImageFromFileOffset(fileName, -1));
}


ZAnimation ZCreateAnimationFromFile(TCHAR* fileName)
{
	return (ZCreateAnimationFromFileOffset(fileName, -1));
}


ZSound ZCreateSoundFromFile(TCHAR* fileName)
{
	return (ZCreateSoundFromFileOffset(fileName, -1));
}


ZImage ZCreateImageFromFileOffset(TCHAR* fileName, int32 fileOffset)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	BYTE*				data = NULL;
	uint32				size;
	ZImage				image = NULL;


	/* Open file. */
	if ((fd = fopen(fileName, "rb")) == NULL)
		goto Error;
	
	if (fileOffset == -1)
	{
		/* Read file header. */
		if (fread(&header, 1, sizeof(header), fd) != sizeof(header))
			goto Error;
		
		/* Check file signature. */
		ZFileHeaderEndian(&header);
		if (header.signature != zFileSignatureImage)
			goto Error;
	}
	else
	{
		if (fseek(fd, fileOffset, SEEK_SET) != 0)
			goto Error;
	}
	
	/* Read the object size value. */
	if (fread(&size, 1, sizeof(size), fd) != sizeof(size))
		goto Error;
	ZEnd32(&size);
	
	/* Reset file mark. */
	if (fseek(fd, -(int32)sizeof(size), SEEK_CUR) != 0)
		goto Error;
	
	/* Allocate buffer and read data. */
	data = (BYTE*)ZMalloc(size);
	if (data == NULL)
		goto Error;
	if (fread(data, 1, size, fd) != size)
		goto Error;
	
	/* Close file. */
	fclose(fd);
	fd = NULL;
	
	/* Create object. */
	image = ZImageNew();
	if (image == NULL)
		goto Error;
	ZImageDescriptorEndian((ZImageDescriptor*)data, TRUE, zEndianFromStandard);
	if (ZImageInit(image, (ZImageDescriptor*) data, NULL) != zErrNone)
		goto Error;
	
	ZFree(data);
	data = NULL;
	
	goto Exit;

Error:
	if (fd != NULL)
		fclose(fd);
	if (data != NULL)
		ZFree(data);
	if (image != NULL)
		ZImageDelete(image);
	image = NULL;

Exit:
	
	return(image);
}


ZAnimation ZCreateAnimationFromFileOffset(TCHAR* fileName, int32 fileOffset)
{
	return (ZAnimationCreateFromFile(fileName, fileOffset));
}


ZSound ZCreateSoundFromFileOffset(TCHAR* fileName, int32 fileOffset)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	BYTE*				data = NULL;
	uint32				size;
	ZSound				sound = NULL;


	/* Open file. */
	if ((fd = fopen(fileName, "rb")) == NULL)
		goto Error;
	
	if (fileOffset == -1)
	{
		/* Read file header. */
		if (fread(&header, 1, sizeof(header), fd) != sizeof(header))
			goto Error;
		
		/* Check file signature. */
		ZFileHeaderEndian(&header);
		if (header.signature != zFileSignatureSound)
			goto Error;
	}
	else
	{
		if (fseek(fd, fileOffset, SEEK_SET) != 0)
			goto Error;
	}
	
	/* Read the object size value. */
	if (fread(&size, 1, sizeof(size), fd) != sizeof(size))
		goto Error;
	ZEnd32(&size);
	
	/* Reset file mark. */
	if (fseek(fd, -(int32)sizeof(size), SEEK_CUR) != 0)
		goto Error;
	
	/* Allocate buffer and read data. */
	data = (BYTE*)ZMalloc(size);
	if (data == NULL)
		goto Error;
	if (fread(data, 1, size, fd) != size)
		goto Error;
	
	/* Close file. */
	fclose(fd);
	fd = NULL;
	
	/* Create object. */
	sound = ZSoundNew();
	if (sound == NULL)
		goto Error;
	if (ZSoundInit(sound, (ZSoundDescriptor*) data) != zErrNone)
		goto Error;
	
	ZFree(data);
	data = NULL;
	
	goto Exit;

Error:
	if (fd != NULL)
		fclose(fd);
	if (data != NULL)
		ZFree(data);
	if (sound != NULL)
		ZSoundDelete(sound);
	sound = NULL;

Exit:
	
	return(sound);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static void* GetObjectFromFile(TCHAR* fileName, uint32 objectType)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	BYTE*				data = NULL;


	/* Open file. */
	if ((fd = fopen(fileName, "rb")) == NULL)
		goto Error;
	
	/* Read file header. */
	if (fread(&header, 1, sizeof(header), fd) != sizeof(header))
		goto Error;
	
	/* Check file signature. */
	ZFileHeaderEndian(&header);
	if (header.signature != objectType)
		goto Error;
	
	data = (BYTE*)ZMalloc(header.fileDataSize);
	if (data == NULL)
		goto Error;
	if (fread(data, 1, header.fileDataSize, fd) != header.fileDataSize)
		goto Error;
	
	fclose(fd);
	fd = NULL;
	
	goto Exit;

Error:
	if (data != NULL)
		ZFree(data);
	data = NULL;

Exit:
	if (fd != NULL)
		fclose(fd);
	
	return(data);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zimage.cpp ===
/*******************************************************************************

	ZImage.c
	
		Zone(tm) Image management routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Friday, May 12, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		05/12/95	HI		Created.
	 
*******************************************************************************/


#include "zone.h"
#include "zpkbytes.h"
#include "zimage.h"
#include "zonemem.h"


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/
/*
	ZPackImage()
	
	Compresses the source image into packed scan lines and stores
	the packed image data into dst. It packs srcWidthBytes bytes per
	scan line where each scan line is srcRowBytes wide
	and it packs numLines of scan lines. Each scan line is preceded
	by a word containing the byte count of the packed scan line data.
	It returns the size of the whole packed image in bytes.
	
	It assumes that the destination buffer, dst, is large enough to
	hold the packed data. Worst case, the packed data will be
		numLines * 2 + (rowBytes + (rowBytes + 126) / 127) bytes.
	This is because it uses ZPackBytes() to pack a scan line and adds
	a word in front of each scan line for byte count of the packed
	data.
	
	It pads the image at the end for quad-byte alignment; just to be nice.
*/
int32 ZPackImage(BYTE* dst, BYTE* src, int16 srcWidthBytes, int16 srcRowBytes, int16 numLines)
{
	BYTE*			origDst;
	int32			dstLen;
	int16			lineLen;
	
	
	origDst = dst;
	
	while (--numLines >= 0)
	{
		lineLen = ZPackBytes(dst + 2, src, srcWidthBytes);
		*dst++ = lineLen >> 8;
		*dst++ = lineLen & 0xFF;
		dst += lineLen;
		src += srcRowBytes;
	}
	
	/* Pad for quad-byte alignment. */
	dstLen = (int32) (dst - origDst);
	if ((lineLen = dstLen % 4) != 0)
	{
		lineLen = 4 - lineLen;
		dstLen += lineLen;
		while (--lineLen >= 0)
			*dst++ = 0;
	}
	
	return (dstLen);
}


/*
	ZUnpackImage()
	
	Uncompresses the source image from packed scan line data into
	unpacked scan line data and stores the result into dst. The resulting
	image data is dstRowBytes wide. It unpacks only numLines of scan lines.
	
	It assumes that dst is large enough to hold the unpacked data. It
	should be dstRowBytes * numLines bytes large.
*/
void ZUnpackImage(BYTE* dst, BYTE* src, int16 dstRowBytes, int16 numLines)
{
	int16			lineLen;
	int16			len;
	
	
	while (--numLines >= 0)
	{
		lineLen = ((BYTE) *src << 8) | (uchar) *(src + 1);
		src += 2;
		len = ZUnpackBytes(dst, src, lineLen);
		src += lineLen;
		dst += dstRowBytes;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zhelp.cpp ===
/*******************************************************************************

	ZHelp.c
	
		Zone(tm) help module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Monday, October 9, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	3		12/12/96	HI		Remove MSVCRT.DLL dependency.
	2		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
    1       10/13/96    HI      Fixed compiler warnings.
	0		10/09/95	HI		Created.
	 
*******************************************************************************/

#include <windows.h>

#include "zonecli.h"

// This code isn't used--but it is still referenced.
// keep the API but don't actually implement any of it.

/*
#define ZW(n)							((ZHelpWindow) (n))
#define IW(n)							((IHelpWindow) (n))

#define ZB(n)							((ZHelpButton) (n))
#define IB(n)							((IHelpButton) (n))

#define zHelpFileName					"zhelp.dll"
                                                  
#define zWindowMargin					16
#define zVersionMargin					10

#define zButtonHeight					20

#define zZoneCreditButtonWidth			160
#define zZoneCreditButtonTitle			"Gaming Zone"


enum
{
	zHelpImageUp = 0,
	zHelpImageDown
};


typedef struct
{
	ZWindow				helpWindow;
	ZGetHelpTextFunc	getHelpTextFunc;
	ZEditText			editText;
	ZButton				zoneCreditButton;
	ZButton				gameCreditButton;
	ZBool				gotText;
	ZBool				showVersion;
	void*				userData;
} IHelpWindowType, *IHelpWindow;

typedef struct
{
	ZPictButton			helpButton;
	ZImage				helpUpImage;
	ZImage				helpDownImage;
	ZHelpWindow			helpWindow;
	ZHelpButtonFunc		buttonFunc;
	void*				userData;
} IHelpButtonType, *IHelpButton;


// -------- Globals -------- 

//-------- Internal Routines -------- 
static ZBool HelpWindowFunc(ZWindow window, ZMessage* message);
static ZBool GetHelpImages(ZImage* helpUpImage, ZImage* helpDownImage);
static void HelpButtonFunc(ZPictButton pictButton, void* userData);
static void ZoneCreditButtonFunc(ZButton button, void* userData);
*/

/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

ZHelpWindow ZHelpWindowNew(void)
{
    /*
	IHelpWindow			help;
	
	
	if ((help = (IHelpWindow) ZMalloc(sizeof(IHelpWindowType))) != NULL)
	{
		help->helpWindow = NULL;
		help->getHelpTextFunc = NULL;
		help->editText = NULL;
		help->zoneCreditButton = NULL;
		help->gameCreditButton = NULL;
		help->userData = NULL;
	}
	
	return (ZW(help));
    */
    return NULL;
}


ZError ZHelpWindowInit(ZHelpWindow helpWindow, ZWindow parentWindow, TCHAR* windowTitle,
		ZRect* windowRect, ZBool showCredits, ZBool showVersion,
		ZGetHelpTextFunc getHelpTextFunc, void* userData)
{
    /*
	ZError			err = zErrNone;
	IHelpWindow		this = IW(helpWindow);
	ZRect			rect, rect2;
	
	
	if (this != NULL)
	{
		this->helpWindow = ZWindowNew();
		if (this->helpWindow != NULL)
		{
			// Create the help window.
			ZWindowInit(this->helpWindow, windowRect, zWindowStandardType, parentWindow,
					windowTitle, FALSE, FALSE, TRUE, HelpWindowFunc, zWantAllMessages,
					this);
			
			// Create the edit text box. 
			this->editText = ZEditTextNew();
			rect = *windowRect;
			ZRectInset(&rect, zWindowMargin, zWindowMargin);
			if (showCredits)
				rect.bottom -= 30;
			if (showVersion)
				rect.bottom -= 10;
			ZEditTextInit(this->editText, this->helpWindow, &rect, NULL, (ZFont) ZGetStockObject(zObjectFontApp12Normal),
					TRUE, TRUE, TRUE, TRUE, NULL, NULL);
			
			if (showCredits)
			{
				// Create the credit buttons.
				this->zoneCreditButton = ZButtonNew();
				rect2 = rect;
				rect2.right = rect2.left + zZoneCreditButtonWidth;
				if (rect2.right > rect.right)
					rect2.right = rect.right;
				rect2.bottom = windowRect->bottom - 10;
				rect2.top = rect2.bottom - zButtonHeight;
				if (showVersion)
					ZRectOffset(&rect2, 0, -zVersionMargin);
				ZButtonInit(this->zoneCreditButton, this->helpWindow, &rect2,
						zZoneCreditButtonTitle, TRUE, TRUE, ZoneCreditButtonFunc, NULL);
			}
			
			this->getHelpTextFunc = getHelpTextFunc;
			this->userData = userData;
			this->gotText = FALSE;
			this->showVersion = showVersion;
			
			// If no function to call to get the text, then we'll never get it.
			if (getHelpTextFunc == NULL)
				this->gotText = TRUE;
		}
		else
		{
			ZAlert("Out of memory while creating help window.", NULL);
		}
	}
	
    */
	return zErrNotImplemented;
}


void ZHelpWindowDelete(ZHelpWindow helpWindow)
{
    /*
	IHelpWindow			this = IW(helpWindow);
	
	
	if (this != NULL)
	{
		if (this->editText != NULL)
			ZEditTextDelete(this->editText);
		if (this->zoneCreditButton != NULL)
			ZButtonDelete(this->zoneCreditButton);
		if (this->gameCreditButton != NULL)
			ZButtonDelete(this->gameCreditButton);
		if (this->helpWindow != NULL)
			ZWindowDelete(this->helpWindow);
		ZFree(this);
	}
    */
}


void ZHelpWindowShow(ZHelpWindow helpWindow)
{
    /*
	IHelpWindow			this = IW(helpWindow);
	char*				helpText;
	char*				newText;
	
	
	if (this != NULL)
	{
		if (this->gotText == FALSE)
		{
			helpText = this->getHelpTextFunc(this->userData);
			if (helpText != NULL)
			{
				newText = ZTranslateText(helpText, zToSystem);
				ZFree(helpText);
				helpText = newText;

				ZEditTextSetText(this->editText, helpText);
				ZFree(helpText);
				ZEditTextSetSelection(this->editText, 0, 0);
			}
			
			this->gotText = TRUE;
		}
		
		ZWindowBringToFront(this->helpWindow);
	}
    */
}


void ZHelpWindowHide(ZHelpWindow helpWindow)
{
    /*
	IHelpWindow			this = IW(helpWindow);
	
	
	if (this != NULL)
	{
		ZWindowHide(this->helpWindow);
	}
    */
}



ZHelpButton ZHelpButtonNew(void)
{
    /*
	IHelpButton			help;
	
	
	if ((help = (IHelpButton) ZMalloc(sizeof(IHelpButtonType))) != NULL)
	{
		help->helpUpImage = NULL;
		help->helpDownImage = NULL;
		help->helpButton = NULL;
		help->buttonFunc = NULL;
		help->helpWindow = NULL;
		help->userData = NULL;
	}
	
	return (ZB(help));
    */
    return NULL;
}


ZError ZHelpButtonInit(ZHelpButton helpButton, ZWindow parentWindow,
		ZRect* buttonRect, ZHelpWindow helpWindow, ZHelpButtonFunc helpButtonFunc,
		void* userData)
{
    /*
	ZError			err = zErrNone;
	IHelpButton		this = IB(helpButton);
	
	
	if (this != NULL)
	{
		if (GetHelpImages(&this->helpUpImage, &this->helpDownImage))
		{
			this->helpButton = ZPictButtonNew();
			ZPictButtonInit(this->helpButton, parentWindow, buttonRect, this->helpUpImage,
					this->helpDownImage, TRUE, TRUE, HelpButtonFunc, this);
			
			this->helpWindow = helpWindow;
			this->buttonFunc = helpButtonFunc;
			this->userData = userData;
		}
		else
		{
			err = zErrOutOfMemory;
			ZAlert("Out of memory while creating help button.", NULL);
		}
	}
	
	return (err);
    */
    return zErrNotImplemented;
}


void ZHelpButtonDelete(ZHelpButton helpButton)
{
    /*
	IHelpButton			this = IB(helpButton);
	
	
	if (this != NULL)
	{
		if (this->helpButton != NULL)
			ZPictButtonDelete(this->helpButton);
		if (this->helpUpImage != NULL)
			ZImageDelete(this->helpUpImage);
		if (this->helpDownImage != NULL)
			ZImageDelete(this->helpDownImage);
		ZFree(this);
	}
    */
}



/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/

/*
static ZBool HelpWindowFunc(ZWindow window, ZMessage* message)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	IHelpWindow		this = IW(message->userData);
	ZBool			msgHandled;
	char			str[40];
	ZVersion		version;
	ZRect			rect;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(window);
			
			// Draw the background.
			ZSetForeColor(window, (ZColor*) ZGetStockObject(zObjectColorLightGray));
			ZRectPaint(window, &message->drawRect);
			ZSetForeColor(window, (ZColor*) ZGetStockObject(zObjectColorBlack));
			
			// Draw the version.
			if (this->showVersion)
			{
				ZSetFont(window, (ZFont) ZGetStockObject(zObjectFontApp9Normal));
				ZWindowGetRect(window, &rect);
				ZRectOffset(&rect, (int16) -rect.left, (int16) -rect.top);
				rect.top = rect.bottom - ZTextHeight(window, str) - 2;
				ZRectOffset(&rect, 0, -2);
				ZRectInset(&rect, 4, 0);

				version = ZSystemVersion();
				wsprintf(str, "Lib version: %u.%u.%u", (version & 0xFFFF0000) >> 16,
						(version & 0x0000FF00) >> 8, version & 0x000000FF);
				ZDrawText(window, &rect, zTextJustifyLeft, str);

				// Draw the client version.
				version = ZClientVersion();
				wsprintf(str, "Game version: %u.%u.%u", (version & 0xFFFF0000) >> 16,
						(version & 0x0000FF00) >> 8, version & 0x000000FF);
				ZDrawText(window, &rect, zTextJustifyRight, str);
			}
			
			ZEndDrawing(window);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			ZHelpWindowHide(ZW(this));
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static ZBool GetHelpImages(ZImage* helpUpImage, ZImage* helpDownImage)
{
	ZBool				gotThem = FALSE;
	ZResource			resFile;


	if ((resFile = ZResourceNew()) != NULL)
	{
		if (ZResourceInit(resFile, ZGetCommonDataFileName(zHelpFileName)) == zErrNone)
		{
			*helpUpImage = ZResourceGetImage(resFile, zHelpImageUp);
			*helpDownImage = ZResourceGetImage(resFile, zHelpImageDown);
			
			if (*helpUpImage != NULL && *helpDownImage != NULL)
			{
				gotThem = TRUE;
			}
			else
			{
				if (*helpUpImage != NULL)
					ZImageDelete(*helpUpImage);
				if (*helpDownImage != NULL)
					ZImageDelete(*helpDownImage);
				gotThem = FALSE;
			}
		}
		ZResourceDelete(resFile);
	}
	
	return (gotThem);
}


static void HelpButtonFunc(ZPictButton pictButton, void* userData)
{
	IHelpButton		this = IB(userData);
	
	
	if (this->helpWindow != NULL)
		ZHelpWindowShow(this->helpWindow);
	if (this->buttonFunc != NULL)
		this->buttonFunc(ZB(userData), this->userData);
}


static void ZoneCreditButtonFunc(ZButton button, void* userData)
{
	ZDisplayZoneCredit(FALSE, NULL);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zimage1.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZImage.cpp

#include "zui.h"
#include "zimage.h"
#include "zonecli.h"
#include "zonemem.h"


class ZImageI : public ZObjectHeader {
public:
	HBITMAP hBitmapImage;
	HBITMAP hBitmapMask;
	int16 width;
	int16 height;
};

/*
	This mapping is d^2 = r^2 + g^2 + b^2.
*/
static short gPaletteMapping[256] =
{
	 255, 246, 160, 229,  94, 251, 222, 189, 154, 122,  89,  56, 216, 183, 148, 117,
	  83,  50, 231, 210, 177, 227,  77,  44, 204, 171, 143, 106,  71,  38, 253, 127,
	 137, 100,  65, 249, 226,   8, 159, 126,  93,  59, 221,   7, 153, 121,  88,  55,
	 215, 182, 147, 116,  82,  49, 209, 176, 142, 111,  76,  43, 203, 170, 136, 105,
	  70,  37, 128, 165, 132,  99,  64,  32, 225, 193, 158, 125,  92,  58,   9, 187,
	 152, 120,  87,  54, 214, 181, 146, 115,  81,   3, 208, 175, 141, 110,  75,  42,
	 202, 169, 130, 104,  69,  36, 198, 164,   5,  98,  63,  31, 232, 224, 192, 228,
	  91,  57, 219, 186, 157, 151,  86,  53, 213, 180, 145, 114,  80,  47, 230, 207,
	 174, 109,  74,  41, 201, 168, 140, 103,  68,  35, 197, 163, 135,  97,  62,  30,
	 223, 191, 156, 124,  90,  52, 218, 185, 150, 119,  85,  52, 212, 179, 144, 113,
	  79,  46, 206, 173, 139, 108,  73,  40, 200, 167, 134, 102,  67,  34, 196, 196,
	 162,  96,  61,  29, 254, 190, 155, 123,  84, 250, 217, 184, 149, 118,  84,  51,
	 211, 178,   6, 112,  78,  45, 205, 172, 138, 107,  72,  39, 199, 199, 166, 101,
	  66,  33, 252, 161, 133,  95,  60, 249,  32,  32,  31,   1,   1,  30,  29,  29,
	  10, 250,  51,  51,  45,   2,   2,  39,  33,  33,  10, 252, 161, 161, 133,   4,
	   4,  95,  60,  60,  10, 244, 241,   7, 247, 248, 235,  18,  20,  16,  13,   0,
};

/*
	This mapping is generated by repalettizing through photoshop.
*/
/*
static unsigned char gPaletteMapping[256] =
{
	 255, 245, 160, 229,  94, 251, 222, 189, 154, 122,  89,  56, 216, 183, 148, 117,
	  83,  50, 231, 210, 177, 227,  77,  44, 204, 171, 143, 106,  71,  38, 253, 127,
	 137, 100,  65, 249, 226,   7, 159, 126,  93,  59, 221,   7, 153, 121,  88,  55,
	 215, 182, 147, 116,  82,  49, 209, 176, 142, 111,  76,  43, 203, 170, 136, 105,
	  70,  37, 128, 165, 132,  99,  64,  32, 225, 193, 158, 125,  92,  58, 220, 187,
	 152, 120,  87,  54, 214, 181, 146, 115,  81,   3, 208, 175, 141, 110,  75,  42,
	 202, 169, 130, 104,  69,  36, 198, 164,   5,  98,  63,  31, 232, 224, 192, 228,
	  91,  57, 219, 186, 157, 151,  86,  53, 213, 180, 145, 114,  80,  47, 230, 207,
	 174, 109,  74,  41, 201, 168, 140, 103,  68,  35, 197, 163, 135,  97,  62,  30,
	 223, 191, 156, 124,  90,  52, 218, 185, 150, 119,  85,  52, 212, 179, 144, 113,
	  79,  46, 206, 173, 139, 108,  73,  40, 200, 167, 134, 102,  67,  34, 200, 196,
	 162,  96,  61,  29, 254, 190, 155, 123,  84, 250, 217, 184, 149, 118,  84,  51,
	 211, 178,   6, 112,  78,  45, 205, 172, 138, 107,  72,  39, 252, 199, 166, 101,
	  66,  33, 252, 161, 133,  95,  60, 249,  32,  32,  31,   1,  30,  30,  29,  29,
	   0, 250,  51,  51,  45,   2,  39,  39,  33,  33,   0, 252, 161, 161, 133,   4,
	  95,  95,  60,  60,   0, 243, 241, 239, 247, 236, 235,  18,  20,  16,  13,   0
};
*/

// local routines

void ZImageCleanUp(ZImage image);


////////////////////////////////////////////////////////////////////////
// ZImage

ZImage ZLIBPUBLIC ZImageNew(void)
{
	ZImageI* pImage = new ZImageI;


	if (pImage)
	{
		pImage->nType = zTypeImage;
		pImage->hBitmapImage = NULL;
		pImage->hBitmapMask = NULL;
		return (ZImage)pImage;
	}

	return NULL;
}

void ZLIBPUBLIC ZImageDelete(ZImage image)
{
	if (image)
	{
		ZImageI* pImage = (ZImageI*)image;

		ZImageCleanUp(image);
		delete pImage;
	}
}

void ZImageCleanUp(ZImage image)
{
	if (image)
	{
		ZImageI* pImage = (ZImageI*)image;

		if (pImage->hBitmapImage)
			DeleteObject(pImage->hBitmapImage);
		if (pImage->hBitmapMask)
			DeleteObject(pImage->hBitmapMask);

		pImage->hBitmapMask = NULL;
		pImage->hBitmapImage = NULL;
	}
}

HBITMAP ZImageGetMask(ZImage image)
{
	if (image)
	{
		ZImageI* pImage = (ZImageI*)image;
		return pImage->hBitmapMask;
	}
	return NULL;
}

HBITMAP ZImageGetHBitmapImage(ZImage image)
{
	if (image)
	{
		ZImageI* pImage = (ZImageI*)image;
		return pImage->hBitmapImage;
	}
	return NULL;
}

void ZImageSetHBitmapImageMask(ZImage image, HBITMAP hBitmapMask)
{
	if (image)
	{
		ZImageI* pImage = (ZImageI*)image;
		pImage->hBitmapMask = hBitmapMask;
	}

}
void ZImageSetHBitmapImage(ZImage image, HBITMAP hBitmap)
{
	if (image)
	{
		ZImageI* pImage = (ZImageI*)image;
		pImage->hBitmapImage = hBitmap;
	}
}

void ZColorTableGetWinColors(ZColorTable* pColorTable, void* pData)
{
	RGBQUAD* pColors = (RGBQUAD*) pData;
	ZColor* pColor = (ZColor*)(pColorTable->colors);
	uint32 nColors = pColorTable->numColors;
	uint32 i;
	for (i = 0;i < nColors; i++) {
		pColors[i].rgbRed = pColor->red;
		pColors[i].rgbGreen = pColor->green;
		pColors[i].rgbBlue = pColor->blue;
		pColors[i].rgbReserved = 0;
		pColor++;
	}
}

ZError ZLIBPUBLIC ZImageInit(ZImage image, ZImageDescriptor* imageData,
		ZImageDescriptor* maskData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZImageI* pImage = (ZImageI*)image;
	ZImageDescriptor* pID = imageData;
	HDC hDC = GetDC(NULL);
	ZBool colorTableAllocated = FALSE;
	int i, j;


	// there may not be an image!, this could be a mask only
	// perhaps a mask only in the image pID
	if (pID && pID->imageDataOffset)
	{
		// get the color table 
		ZColorTable* pColorTable;
		if (pID->colorTableOffset) {
			// yeah, provided a color table!!
			pColorTable = (ZColorTable*)((BYTE*)pID + pID->colorTableOffset);
		} else {
			// use a color table default
			pColorTable = ZGetSystemColorTable();
			if( pColorTable == NULL )
			{
				//pColorTable failed to be allocated!
				//Prefix Warning: Don't dereference pColorTable if it is NULL
				return zErrOutOfMemory;	
			}
			colorTableAllocated = TRUE;
		}

		int16 width = (pID->imageRowBytes+3)/4*4;
		int16 height = pID->height;
		uint32 nColors = pColorTable->numColors;
		void *pData = (void*)((BYTE*)pID + pID->imageDataOffset);
		uint32 nImageSize = (int32)width * height;
		BITMAPINFO* pBMI = (BITMAPINFO*)ZMalloc(sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD)*nColors);

		ZColorTableGetWinColors(pColorTable,&pBMI->bmiColors);

		if (colorTableAllocated)
			ZFree(pColorTable);

		pBMI->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
		pBMI->bmiHeader.biWidth = width;
		pBMI->bmiHeader.biHeight = height;
		pBMI->bmiHeader.biPlanes = 1;
		pBMI->bmiHeader.biBitCount = 8;
		pBMI->bmiHeader.biCompression = BI_RGB;
		pBMI->bmiHeader.biSizeImage = 0;
		pBMI->bmiHeader.biXPelsPerMeter = 0;
		pBMI->bmiHeader.biYPelsPerMeter = 0;
		pBMI->bmiHeader.biClrUsed = 0;
		pBMI->bmiHeader.biClrImportant = 0;

		// unpack all the bits
		BYTE *pDataBits = (BYTE*)ZMalloc(nImageSize);
		// unpack all rows in reverse order, windows seems to like bitmaps inverted!
		ZUnpackImage((BYTE*)pDataBits+nImageSize-width,(BYTE*)pData,-width,height);

#if 1
		// Repalettize the image.
		BYTE index;
		for (i = 0; i < height; i++)
			for (j = 0; j < width; j++)
			{
				index = pDataBits[i * width + j];
				pDataBits[i * width + j] = (BYTE) gPaletteMapping[index];
			}
#endif

		int16* pColorIndex = (int16*)&pBMI->bmiColors;
		for (i = 0;i < 256;i++) {
			pColorIndex[i] = i;
		}

		// create the windows bitmap
		HPALETTE hPalOld = SelectPalette(hDC, ZShellZoneShell()->GetPalette(),FALSE);
		RealizePalette(hDC);
		pImage->hBitmapImage = CreateDIBitmap(hDC,(LPBITMAPINFOHEADER)pBMI,CBM_INIT,pDataBits,(LPBITMAPINFO)pBMI,DIB_PAL_COLORS);
		SelectPalette(hDC,hPalOld,FALSE);

		ZFree(pBMI);

		ZFree(pDataBits);

		pImage->height = pID->height;
		pImage->width = pID->width;
	}

	// allow for a default mask to be used in case there is no mask in the
	// main image descriptor.
	ZImageDescriptor* pIDMask;
	if (pID && pID->maskDataOffset) {
		pIDMask = pID;
	} else if (maskData && maskData->maskDataOffset) {
		pIDMask = maskData;
	} else {
		pIDMask = NULL;
	}

	// if there is a mask, create a device specific bitmap
	if (pIDMask && pIDMask->maskDataOffset) 
	{
		// Create the mask

		int16 width = (pIDMask->maskRowBytes +3)/4*4;
  		int16 height = pIDMask->height;

		int16 nColors = 2;
		void *pData = (void*)((BYTE*)pIDMask + pIDMask->maskDataOffset);
		uint32 nImageSize = (int32)width * height;

		BITMAPINFO* pBMI = (BITMAPINFO*)ZMalloc(sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD)*nColors);
#if 0
		RGBQUAD* pColors = (RGBQUAD*) &pBMI->bmiColors;
		pColors[0].rgbRed = pColors[0].rgbGreen = pColors[0].rgbBlue = pColors[0].rgbReserved = 0;
		pColors[1].rgbRed = pColors[1].rgbGreen = pColors[1].rgbBlue = 0xff;
		pColors[1].rgbReserved = 0;
#else
		int16* pColorIndex = (int16*)&pBMI->bmiColors;
#if 0
		pColorIndex[0] = 0x00;
		pColorIndex[1] = 0xff;
#else
		pColorIndex[0] = 0xFF;
		pColorIndex[1] = 0x00;
#endif
#endif

		pBMI->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
		pBMI->bmiHeader.biWidth = width*8;
		pBMI->bmiHeader.biHeight = height;
		pBMI->bmiHeader.biPlanes = 1;
		pBMI->bmiHeader.biBitCount = 1;
		pBMI->bmiHeader.biCompression = BI_RGB;
		pBMI->bmiHeader.biSizeImage = 0;
		pBMI->bmiHeader.biXPelsPerMeter = 0;
		pBMI->bmiHeader.biYPelsPerMeter = 0;
		pBMI->bmiHeader.biClrUsed = 0;
		pBMI->bmiHeader.biClrImportant = 0;

		// unpack the bits
		BYTE *pDataBits = (BYTE*)ZMalloc(nImageSize);
					
		ZUnpackImage((BYTE*)pDataBits+nImageSize - width,(BYTE*)pData,-width,height);
#if 0
		for (int j = 0;j < width;j++)
			for (int i = 0;i < height; i++)
				pDataBits[width - j-1+i*width] = j&1?0:0xff;
#endif
		HPALETTE hPalOld = SelectPalette(hDC, ZShellZoneShell()->GetPalette(),FALSE);
		RealizePalette(hDC);
		pImage->hBitmapMask = CreateDIBitmap(hDC,(LPBITMAPINFOHEADER)pBMI,CBM_INIT,pDataBits,(LPBITMAPINFO)pBMI,DIB_PAL_COLORS);
		SelectPalette(hDC,hPalOld,FALSE);
		ZFree(pBMI);

		ZFree(pDataBits);

		pImage->height = pIDMask->height;
		pImage->width = pIDMask->width;
	}

	ReleaseDC(NULL,hDC);

	return zErrNone;	
}


void ZLIBPUBLIC ZImageDraw2(ZImage image, ZGrafPort grafPort, 
		ZRect* bounds, uint16 drawMode, ZImage mask, ZPoint* source);

void ZImageDraw(ZImage image, ZGrafPort grafPort,
	ZRect* bounds, ZImage mask, uint16 drawMode)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZImageI*		pImage = (ZImageI*)image;
	ZImageI*		pImageMask = (ZImageI*)mask;
	HDC				hDC = ZGrafPortGetWinDC(grafPort);
	HBITMAP			hBitmapMask;


	// there are two "images" here, the mask's mask is used only if
	// there is no image mask in the image!
	if (pImage->hBitmapMask)
	{
		// normal standard mask provided, use it...
		hBitmapMask = pImage->hBitmapMask;
	}
	else if (pImageMask && pImageMask->hBitmapMask)
	{
		// an alternative, secondary mask provided, use it.
		hBitmapMask = pImageMask->hBitmapMask;
	}
	else
	{
		// no mask provided at all, don't use a mask
		hBitmapMask = NULL;
	}
	
	if (!hBitmapMask)
	{
		ZPoint pt;
		pt.x = 0;
		pt.y = 0;
		ZImageDraw2(image,grafPort,bounds,drawMode,mask,&pt);
		return;
	}

	int width = bounds->right - bounds->left;
	int height = bounds->bottom - bounds->top;

	HDC hDCTemp0 = CreateCompatibleDC(hDC);
	HDC hDCTemp1 = CreateCompatibleDC(hDC);
	HDC hDCMask = CreateCompatibleDC(hDC);

	//Prefix error, select object below will dereference NULL pointer if CreateCompatibleDC fails
	if( hDCTemp0 == NULL ||
		hDCTemp1 == NULL ||
		hDCMask == NULL )
	{
		
		return;
	}

	HBITMAP hbmImageAndNotMask = CreateCompatibleBitmap(hDC,width,height);
	HBITMAP hbmBackgroundAndMask = CreateCompatibleBitmap(hDC,width,height);
    HBITMAP hbmCompatibleMask = CreateCompatibleBitmap(hDC,width,height);

	HBITMAP bmOld0 = (HBITMAP)SelectObject(hDCTemp0,hBitmapMask);
	HBITMAP bmOld1 = (HBITMAP)SelectObject(hDCTemp1,hbmImageAndNotMask);
	HBITMAP bmOldMask = (HBITMAP)SelectObject(hDCMask,hbmCompatibleMask);

    HPALETTE hZonePal = ZShellZoneShell()->GetPalette();
	SelectPalette(hDCTemp0, hZonePal, FALSE);
	SelectPalette(hDCTemp1, hZonePal, FALSE);

    // if the hBitmapMask is in an RGB mde and the display is in a palette mode, sometimes BitBlt doesn't map
    // black to black, who knows why.  it's been giving me 0x040404, index 0x0a, which screws up the whole masking.
    // make up a crazy palette so that doesn't happen
    static const DWORD sc_buff[] = { 0x01000300,
        0x00000000, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff,
        0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x000080ff, 0x00ffffff };
    static const LOGPALETTE *sc_pLogPalette = (LOGPALETTE *) sc_buff;

    HPALETTE hDumbPal = CreatePalette(sc_pLogPalette);
	//Prefix Warning: If CreatePalette fails, DeleteObject will dereference NULL

	SelectPalette(hDCMask, hDumbPal ? hDumbPal : hZonePal, FALSE);
	BitBlt(hDCMask,0,0,width,height,hDCTemp0,0,0,SRCCOPY);

    if( hDumbPal != NULL )
    {
		SelectPalette(hDCMask, hZonePal, FALSE);
   		DeleteObject(hDumbPal);
    }

	BitBlt(hDCTemp1,0,0,width,height,hDCMask,0,0,SRCCOPY); // copy Mask
	SelectObject(hDCTemp0,pImage->hBitmapImage);
	BitBlt(hDCTemp1,0,0,width,height,hDCTemp0,0,0,SRCERASE); // and with not mask (code: SDna)

	SelectObject(hDCTemp1,hbmBackgroundAndMask);
	BitBlt(hDCTemp1,0,0,width,height,hDC,bounds->left,bounds->top,SRCCOPY); // copy background
	BitBlt(hDCTemp1,0,0,width,height,hDCMask,0,0,SRCAND); // and with mask

	// or the two together
	SelectObject(hDCTemp0,hbmImageAndNotMask);
	BitBlt(hDCTemp1,0,0,width,height,hDCTemp0,0,0,SRCPAINT); // and with mask

	// copy the result to the grafport...

	BitBlt(hDC,bounds->left,bounds->top,width,height,hDCTemp1,0,0,SRCCOPY);

	SelectObject(hDCTemp0,bmOld0);
	SelectObject(hDCTemp1,bmOld1);
	SelectObject(hDCMask,bmOldMask);

	DeleteObject(hbmImageAndNotMask);
	DeleteObject(hbmBackgroundAndMask);
	DeleteObject(hbmCompatibleMask);

	DeleteDC(hDCTemp0);
	DeleteDC(hDCTemp1);
	DeleteDC(hDCMask);
}

void ZImageDrawPartial(ZImage image, ZGrafPort grafPort, 
		ZRect* bounds, ZMask mask, uint16 drawMode, ZPoint* source)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZImageI*		pImage = (ZImageI*)image;
	ZImageI*		pImageMask = (ZImageI*)mask;
	HDC				hDC = ZGrafPortGetWinDC(grafPort);
	HBITMAP			hBitmapMask;


	// there are two "images" here, the mask's mask is used only if
	// there is no image mask in the image!
	if (pImage->hBitmapMask)
	{
		// normal standard mask provided, use it...
		hBitmapMask = pImage->hBitmapMask;
	}
	else if (pImageMask && pImageMask->hBitmapMask)
	{
		// an alternative, secondary mask provided, use it.
		hBitmapMask = pImageMask->hBitmapMask;
	}
	else
	{
		// no mask provided at all, don't use a mask
		hBitmapMask = NULL;
	}
	
	if (!hBitmapMask)
	{
		ZImageDraw2(image,grafPort,bounds,drawMode,mask,source);
		return;
	}

	// TODO: Implement the rest of the partial blit function.  This
	// source will work just like a normal blit, not taking into
	// account the source variable.
    // also need to add the palette handling from above
    ASSERT(FALSE);
	int width = bounds->right - bounds->left;
	int height = bounds->bottom - bounds->top;

	HDC hDCTemp0 = CreateCompatibleDC(hDC);
	if( hDCTemp0 == NULL )
	{
		return;
	}
	HDC hDCTemp1 = CreateCompatibleDC(hDC);
	if( hDCTemp1 == NULL )
	{
		return;
	}
	HBITMAP hbmImageAndNotMask = CreateCompatibleBitmap(hDC,width,height);
	HBITMAP hbmBackgroundAndMask = CreateCompatibleBitmap(hDC,width,height);

	HBITMAP bmOld1 = (HBITMAP)SelectObject(hDCTemp1,hbmImageAndNotMask);
	HBITMAP bmOld0 = (HBITMAP)SelectObject(hDCTemp0,hBitmapMask);

    HPALETTE hZonePal = ZShellZoneShell()->GetPalette();
	SelectPalette(hDCTemp0, hZonePal, FALSE);
	SelectPalette(hDCTemp1, hZonePal, FALSE);

	BitBlt(hDCTemp1,0,0,width,height,hDCTemp0,0,0,SRCCOPY); // copy Mask
	SelectObject(hDCTemp0,pImage->hBitmapImage);
	BitBlt(hDCTemp1,0,0,width,height,hDCTemp0,0,0,SRCERASE); // and with not mask (code: SDna)

	SelectObject(hDCTemp1,hbmBackgroundAndMask);
	BitBlt(hDCTemp1,0,0,width,height,hDC,bounds->left,bounds->top,SRCCOPY); // copy background
	SelectObject(hDCTemp0,hBitmapMask);
	BitBlt(hDCTemp1,0,0,width,height,hDCTemp0,0,0,SRCAND); // and with mask
	
	// or the two together
	SelectObject(hDCTemp0,hbmImageAndNotMask);
	BitBlt(hDCTemp1,0,0,width,height,hDCTemp0,0,0,SRCPAINT); // and with mask

	// copy the result to the grafport...

	BitBlt(hDC,bounds->left,bounds->top,width,height,hDCTemp1,0,0,SRCCOPY);

	SelectObject(hDCTemp0,bmOld0);
	SelectObject(hDCTemp1,bmOld1);

	if( hbmImageAndNotMask != NULL )
	{
		DeleteObject(hbmImageAndNotMask);
	}
	if( hbmBackgroundAndMask != NULL )
	{
		DeleteObject(hbmBackgroundAndMask);
	}

	DeleteDC(hDCTemp0);
	DeleteDC(hDCTemp1);
}



void ZLIBPUBLIC ZImageDraw2(ZImage image, ZGrafPort grafPort, 
		ZRect* bounds, uint16 drawMode, ZImage mask, ZPoint* source)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZImageI* pImage = (ZImageI*)image;
	ZImageI* pImageMask = (ZImageI*)mask;
	HBITMAP hBitmapImage;
	HBITMAP hBitmapMask;
	int width;
	int height;
	int x,y;
	uint32 ropCode;
	// the modesMask may be off for the values drawMode > 0, seems ca was really ac, the others could be reversed too...
	static uint32 modesMask[] = { 0x00ac0744, 0x000ea02e9, 0x006a01e9, 0x003a0644, 0x001a06c5, 0x009a0709 };
	static uint32 modesNoMask[] = { SRCCOPY, SRCPAINT, SRCINVERT, NOTSRCCOPY, MERGEPAINT, 0x00990066 };

    // take out the mirror mode so the drawMode -> rop map will work correctly.
    uint16 mirrorMode = drawMode & zDrawMirrorModeMask;
    drawMode &= zDrawModeMask;

	// there are two "images" here, the mask's mask is used only if
	// there is no image mask in the image!
	if (pImage->hBitmapMask) {
		// normal standard mask provided, use it...
		hBitmapMask = pImage->hBitmapMask;
	} else if (pImageMask && pImageMask->hBitmapMask) {
		// an alternative, secondary mask provided, use it.
		hBitmapMask = pImageMask->hBitmapMask;
	} else {
		// no mask provided at all, don't use a mask
		hBitmapMask = NULL;
	}
	
	// finding the image bitmap is easy...
	hBitmapImage = pImage->hBitmapImage;

    ZBool fUseStretch = FALSE;
	// get the standard parameters
	x = bounds->left;
	y = bounds->top;
	width = bounds->right - bounds->left;
	height = bounds->bottom - bounds->top;
    int dstwidth = width, dstheight = height;
    // are we set in mirror mode?
    if ( mirrorMode & zDrawMirrorHorizontal )
    {
        x += dstwidth;
        dstwidth *= -1;
        fUseStretch = TRUE;
    }
    if ( mirrorMode & zDrawMirrorVertical )
    {
        y += dstheight;
        dstheight *= -1;
        fUseStretch = TRUE;
    }

	// get the appropriate drawing rop mode, if there
	// is a mask or not will effect this
	if (hBitmapMask) {
		ropCode = modesMask[drawMode];
	} else {
		ropCode = modesNoMask[drawMode];
	}

	HDC hDC = ZGrafPortGetWinDC(grafPort);
	HBRUSH brPattern=NULL;
	HBRUSH brOld=NULL;
	if (hBitmapMask) {
		// need to create a pattern brush of the mask...
		brPattern = CreatePatternBrush(hBitmapMask);
		POINT pt;
		pt.x = x;
		pt.y = y;
		LPtoDP(hDC,&pt,1);
#ifdef WIN32
		// Hmm... needs x,y greater than 7, is this a bug in the windows docs?
		// or does it only work with certain video drivers???
		SetBrushOrgEx(hDC,pt.x,pt.y,NULL);
#else
		SetBrushOrg(hDC,pt.x & 0x7,pt.y & 0x7);
#endif
		brOld = (HBRUSH)SelectObject(hDC,brPattern);
	}
	HDC hDCTemp = CreateCompatibleDC(hDC);
	if( hDCTemp == NULL )
	{
		//Out of memory
		if (hBitmapMask) SelectObject(hDC,brOld);
		if (brPattern) DeleteObject(brPattern);
		ASSERT(FALSE);
		return;
	}
	
	HBITMAP bmOld = (HBITMAP)SelectObject(hDCTemp,pImage->hBitmapImage);
	HPALETTE palOld = SelectPalette(hDCTemp, ZShellZoneShell()->GetPalette(), FALSE);

	// do the bitblt
//	BitBlt(hDC,x,y,width,height,hDCTemp,0,0,ropCode);

    if ( fUseStretch )
    {
        StretchBlt(hDC,x,y,dstwidth,dstheight,hDCTemp,source->x,source->y,width,height,ropCode);
    }
    else
    {
        BitBlt(hDC,x,y,width,height,hDCTemp,source->x,source->y,ropCode);
    }
//	long nHeight = height; long nWidth = width;
//	StretchBlt(hDC,0,nHeight-1,nWidth,-nHeight,hDCTemp,x,y,nWidth,nHeight,ropCode);

	if (hBitmapMask) SelectObject(hDC,brOld);
	if (brPattern) DeleteObject(brPattern);

	SelectObject(hDCTemp,bmOld);
    SelectPalette(hDCTemp, palOld, FALSE);
	DeleteDC(hDCTemp);
}



int16 ZLIBPUBLIC ZImageGetWidth(ZImage image)
{
	ZImageI* pImage = (ZImageI*)image;
	return pImage->width;
}
int16 ZLIBPUBLIC ZImageGetHeight(ZImage image)
{
	ZImageI* pImage = (ZImageI*)image;
	return pImage->height;
}

ZBool ZLIBPUBLIC ZImagePointInside(ZImage image, ZPoint* point)
	/*
		Returns TRUE if the given point is inside the image. If the image has a mask,
		then it checks whether the point is inside the mask. If the image does not have
		a mask, then it simply checks the image bounds.
	*/
{
	ZRect rect;
	rect.left = 0; rect.top = 0;
	rect.right = ZImageGetWidth(image);
	rect.bottom = ZImageGetHeight(image);
	if (ZPointInRect(point,&rect)) {
		BOOL inside = TRUE;
		ZImageI* pImage = (ZImageI*)image;

		/* if the image has a mask, check the mask for which points are inside */
		/* else, just use the rectangle */
		if (pImage->hBitmapMask) {
			HDC hDCTemp = CreateCompatibleDC(NULL);
			HBITMAP bmOld = (HBITMAP)SelectObject(hDCTemp,pImage->hBitmapMask);

			COLORREF c = GetPixel(hDCTemp,point->x,point->y);
			inside = c != RGB(0xff,0xff,0xff);
		
			SelectObject(hDCTemp,bmOld);
			DeleteDC(hDCTemp);
		}

		return inside;
	}

	return FALSE;
}

ZError ZImageMake(ZImage image, ZOffscreenPort imagePort, ZRect* imageRect,
		ZOffscreenPort maskPort, ZRect* maskRect)
	/*
		Creates a ZImage object from a ZOffscreenPort object. Both the image and
		mask can be specified. Either can be non-existent but not both. Both
		imageRect and maskRect are in the local coordinates of their respective
		offscreen ports.
	*/
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


	if (!imagePort && !maskPort) {
			return zErrBadParameter;
	}

	ZImageI* pImage = (ZImageI*)image;
	ZImageCleanUp(image);

	HDC hDCSource = CreateCompatibleDC(NULL);
	HDC hDCDest = CreateCompatibleDC(NULL);

	ZRect* rect = imageRect;
	ZGraphicsObjectHeader* pOffscreenPort = (ZGraphicsObjectHeader*)imagePort;
	if (pOffscreenPort) {
		ZGraphicsObjectHeader* pOffscreenPort = (ZGraphicsObjectHeader*)imagePort;
		HBITMAP sourceBitmap = pOffscreenPort->hBitmap;
		int16 width = ZRectWidth(rect);
		int16 height = ZRectHeight(rect);
		int16 x0 = rect->left;
		int16 y0 = rect->top;

		HBITMAP oldSrc = (HBITMAP)SelectObject(hDCSource, sourceBitmap);
		HBITMAP destBitmap = CreateCompatibleBitmap(hDCSource, width, height);
		HBITMAP oldDest = (HBITMAP)SelectObject(hDCDest,destBitmap);
		HPALETTE oldPal = (HPALETTE)SelectPalette(hDCDest, ZShellZoneShell()->GetPalette(), FALSE);
		BitBlt(hDCDest,0,0,width,height,hDCSource, x0,y0, SRCCOPY);

		pImage->width = width;
		pImage->height = height;
		SelectObject(hDCDest,oldDest);
		SelectObject(hDCSource,oldSrc);
		SelectPalette(hDCDest, oldPal, FALSE);
		pImage->hBitmapImage = destBitmap;
	}

	rect = maskRect;
	pOffscreenPort = (ZGraphicsObjectHeader*)maskPort;
	if (pOffscreenPort) {
		HBITMAP sourceBitmap = pOffscreenPort->hBitmap;
		int16 width = ZRectWidth(rect);
		int16 height = ZRectHeight(rect);
		int16 x0 = rect->left;
		int16 y0 = rect->top;

		HBITMAP oldSrc = (HBITMAP)SelectObject(hDCSource,sourceBitmap);
		HBITMAP destBitmap = CreateCompatibleBitmap(hDCSource, width, height);
		HBITMAP oldDest = (HBITMAP)SelectObject(hDCDest,destBitmap);
		BitBlt(hDCDest,0,0,width,height,hDCSource, x0,y0, SRCCOPY);

		pImage->width = width;
		pImage->height = height;
		SelectObject(hDCDest,oldDest);
		SelectObject(hDCSource,oldSrc);
		pImage->hBitmapMask = destBitmap;
	}

	if( hDCSource != NULL )
	{
		DeleteDC(hDCSource);
	}
	if( hDCSource != NULL )
	{
		DeleteDC(hDCDest);
	}

	return zErrNone;
}


ZImage ZImageCreateFromResourceManager( WORD resID, COLORREF clrTransparent )
{
	ZImage image = NULL;
	HBITMAP hBitmap = (HBITMAP)ZShellResourceManager()->LoadImage( MAKEINTRESOURCE(resID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);

	if (hBitmap)
		image = ZImageCreateFromBMP( hBitmap, clrTransparent );
    return image;
}


/*
	Creates ZImage from a BMP resource. Creates both the image and mask.
	Returns NULL in caes of error.
*/
ZImage ZImageCreateFromBMPRes(HINSTANCE hInstance, WORD resID, COLORREF transparentColor)
{
	ZImage image = NULL;
	HBITMAP hBitmap = (HBITMAP)LoadImage(hInstance, MAKEINTRESOURCE(resID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);


	if (hBitmap)
		image = ZImageCreateFromBMP(hBitmap, transparentColor);

	return (image);
}


ZImage ZImageCreateFromBMP(HBITMAP hBitmap, COLORREF transparentColor)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	ZImageI* image = NULL;
	BITMAP bitmap;
	BITMAPINFO* bitmapInfo;
	HDC hScreenDC;
	BYTE* pBits;
	HBITMAP hMask;
	int rowBytes;
	int transparentColorIndex;


	if (hBitmap)
	{
		if (image = (ZImageI*) ZImageNew())
		{
			image->hBitmapImage = NULL;
			image->hBitmapMask = NULL;

			GetObject(hBitmap, sizeof(bitmap), &bitmap);

			// Set the image width and height.
			image->width = (int16) bitmap.bmWidth;
			image->height = (int16) bitmap.bmHeight;
			rowBytes = ((image->width + 3) / 4) * 4;

			if (transparentColor == 0)
			{
				image->hBitmapImage = hBitmap;
			}
			else
			{
				// Allocate buffer to hold image info and color table.
				bitmapInfo = (BITMAPINFO*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
				if (bitmapInfo)
				{
					bitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
					bitmapInfo->bmiHeader.biWidth = image->width;
					bitmapInfo->bmiHeader.biHeight = -image->height;		// top-down dib requires negative height.
					bitmapInfo->bmiHeader.biPlanes = 1;
					bitmapInfo->bmiHeader.biBitCount = 8;
					bitmapInfo->bmiHeader.biCompression = BI_RGB;

					hScreenDC = GetDC(NULL);

					// Allocate buffer for bitmap data. This buffer is converted to the mask data.
					pBits = (BYTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, rowBytes * image->height);
					if (pBits)
					{
						// Get image info.
						if (GetDIBits(hScreenDC, hBitmap, 0, image->height, pBits, bitmapInfo, DIB_RGB_COLORS))
						{
							// Create image data.
							/*
							image->hBitmapImage = CreateCompatibleBitmap(hScreenDC, image->width, image->height);
							if (image->hBitmapImage)
								SetDIBits(hScreenDC, image->hBitmapImage, 0, image->height, pBits, bitmapInfo, DIB_RGB_COLORS);
							*/
							image->hBitmapImage = hBitmap;

							// Find the transparent color index.
							transparentColorIndex = -1;
							for (int i = 0; i < 255; i++)
							{
								if (	bitmapInfo->bmiColors[i].rgbRed == GetRValue(transparentColor) &&
										bitmapInfo->bmiColors[i].rgbGreen == GetGValue(transparentColor) &&
										bitmapInfo->bmiColors[i].rgbBlue == GetBValue(transparentColor))
								{
									transparentColorIndex = i;
									break;
								}
							}

							// Convert to mask data.
							BOOL bHasMask = FALSE;
							int k = 0;
							for (i = 0; i < image->height; i++)
								for (int j = 0; j < rowBytes; j++, k++)
									if (pBits[k] == transparentColorIndex)
									{
										bHasMask = TRUE;
										pBits[k] = 0xFF;		// White = masked
									}
									else
									{
										pBits[k] = 0x00;		// Black == not masked
									}

							// Create the mask bitmap.
							if (bHasMask)
							{
								image->hBitmapMask = CreateCompatibleBitmap(hScreenDC, image->width, image->height);
								if (image->hBitmapMask)
									SetDIBits(hScreenDC, image->hBitmapMask, 0, image->height, pBits, bitmapInfo, DIB_RGB_COLORS);
							}
						}

						HeapFree(GetProcessHeap(), 0, pBits);
					}

					if (hScreenDC)
						ReleaseDC(NULL, hScreenDC);

					if (bitmapInfo)
						HeapFree(GetProcessHeap(), 0, bitmapInfo);
				}
			}

			if (image->hBitmapImage == NULL)
			{
				ZImageDelete(image);
				image = NULL;
			}
		}
	}

	return ((ZImage) image);
}


#if 0  // currently unused & trying to clean up palette stuff
HPALETTE GetBitmapPalette(HBITMAP hBitmap)
{
	HPALETTE hPalette = NULL;
	BITMAP bitmap;
	BITMAPINFO* bitmapInfo;
	LOGPALETTE* palette;
	HDC hdc;


	if (hBitmap)
	{
		// Allocate buffer to hold image info and color table.
		bitmapInfo = (BITMAPINFO*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
		if (bitmapInfo)
		{
			GetObject(hBitmap, sizeof(bitmap), &bitmap);

			bitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
			bitmapInfo->bmiHeader.biWidth = bitmap.bmWidth;
			bitmapInfo->bmiHeader.biHeight = bitmap.bmHeight;
			bitmapInfo->bmiHeader.biPlanes = bitmap.bmPlanes;
			bitmapInfo->bmiHeader.biBitCount = bitmap.bmBitsPixel;
			bitmapInfo->bmiHeader.biCompression = BI_RGB;

			// Create a temporary DC.
			hdc = CreateCompatibleDC(NULL);
			if (hdc)
			{
				// Get image info.
				if (GetDIBits(hdc, hBitmap, 0, bitmap.bmHeight, NULL, bitmapInfo, DIB_RGB_COLORS))
				{
					// Allocate palette buffer.
					palette = (LOGPALETTE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * 255);
					if (palette)
					{
						// Create palette log structure.
						palette->palVersion = 0x300;
						palette->palNumEntries = (WORD) (bitmapInfo->bmiHeader.biClrUsed ? bitmapInfo->bmiHeader.biClrUsed : 256);
						for (int i = 0; i < 256; i++)
						{
							palette->palPalEntry[i].peRed = bitmapInfo->bmiColors[i].rgbRed;
							palette->palPalEntry[i].peGreen = bitmapInfo->bmiColors[i].rgbGreen;
							palette->palPalEntry[i].peBlue = bitmapInfo->bmiColors[i].rgbBlue;
							palette->palPalEntry[i].peFlags = 0;
						}

						// Create palette.
						hPalette = CreatePalette(palette);

						HeapFree(GetProcessHeap(), 0, palette);
					}
				}

				DeleteDC(hdc);
			}

			if (bitmapInfo)
				HeapFree(GetProcessHeap(), 0, bitmapInfo);
		}
	}

	return (hPalette);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zimage.h ===
/*******************************************************************************

	ZImage.h
	
		Zone(tm) Image management routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Friday, May 12, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		05/12/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZIMAGE_
#define _ZIMAGE_


#ifdef __cplusplus
extern "C" {
#endif

int32 ZPackImage(BYTE* dst, BYTE* src, int16 srcWidthBytes, int16 srcRowBytes, int16 numLines);
	/*
		Compresses the source image into packed scan lines and stores
		the packed image data into dst. It packs srcWidthBytes bytes per
		scan line where each scan line is srcRowBytes wide
		and it packs numLines of scan lines. Each scan line is preceded
		by a word containing the byte count of the packed scan line data.
		It returns the size of the whole packed image in bytes.
		
		It assumes that the destination buffer, dst, is large enough to
		hold the packed data. Worst case, the packed data will be
			numLines * 2 + (rowBytes + (rowBytes + 126) / 127) bytes.
		This is because it uses ZPackBytes() to pack a scan line and adds
		a word in front of each scan line for byte count of the packed
		data.
		
		It pads the image at the end for quad-byte alignment; just to be nice.
	*/

void ZUnpackImage(BYTE* dst, BYTE* src, int16 dstRowBytes, int16 numLines);
	/*
		Uncompresses the source image from packed scan line data into
		unpacked scan line data and stores the result into dst. The resulting
		image data is dstRowBytes wide. It unpacks only numLines of scan lines.
		
		It assumes that dst is large enough to hold the unpacked data. It
		should be dstRowBytes * numLines bytes large.
	*/

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zfont.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZFont.cpp

#include <stdlib.h>
#include <string.h>

#include "zonecli.h"
#include "zui.h"
#define FONT_MULT 96
#define FONT_MULT 96

HFONT ZCreateFontIndirect(ZONEFONT* zFont, HDC hDC, BYTE bItalic, BYTE bUnderline,BYTE bStrikeOut)
{
	LOGFONT lFont;
	HFONT   hFont = NULL;
		
	memset(&lFont, 0, sizeof(LOGFONT));	
	lFont.lfCharSet = DEFAULT_CHARSET;

	// If font size > 0, it is a fixed pixel size, otherwise it is a
	// true logical font size which respects the user's "large font" setting.
	if ( zFont->lfHeight > 0 )
	{
		lFont.lfHeight = -MulDiv(zFont->lfHeight, FONT_MULT, 72);
	}
	else
	{		
		lFont.lfHeight = MulDiv(zFont->lfHeight, GetDeviceCaps( hDC, LOGPIXELSY), 72);
	}
	
	lFont.lfWeight    = zFont->lfWeight;
	lFont.lfItalic    = bItalic;
	lFont.lfUnderline = bUnderline;
	lFont.lfStrikeOut = bStrikeOut;

	lstrcpyn(lFont.lfFaceName, zFont->lfFaceName, sizeof(lFont.lfFaceName)/sizeof(TCHAR));

	return CreateFontIndirect(&lFont);
}

HFONT ZCreateFontIndirectBackup(ZONEFONT* zfPreferred, ZONEFONT* zfBackup, HDC hDC, BYTE bItalic, BYTE bUnderline,BYTE bStrikeOut)
{
	HFONT hFont = NULL;
	
	ASSERT( zfPreferred != NULL && zfBackup != NULL );

	if ( (hFont = ZCreateFontIndirect( zfPreferred, hDC, bItalic, bUnderline, bStrikeOut)) == NULL )
	{
		hFont = ZCreateFontIndirect( zfBackup, hDC, bItalic, bUnderline, bStrikeOut);
	}

	return hFont;
}

class ZFontI {
public:
	ZObjectType nType;
	int16 fontType;
	int16 style;
	int16 size;
	HFONT hFont;
};

//////////////////////////////////////////////////////////////////////////////////////////////
//	ZFont

ZFont ZLIBPUBLIC ZFontNew(void)
{
    ZFontI* pFont = (ZFontI*)ZMalloc(sizeof(ZFontI));
	pFont->nType = zTypeFont;
	pFont->hFont = NULL;

	return (ZFont)pFont;
}

ZError ZLIBPUBLIC ZFontInit(ZFont font, int16 fontType, int16 style,
		int16 size)
{
	ZFontI* pFont = (ZFontI*)font;

	pFont->fontType = fontType;
	pFont->style = style;
	pFont->size = size;

	// for now, use default system font always, fontType ignored.
	LOGFONT logfont;
	memset(&logfont,0,sizeof(LOGFONT));
	logfont.lfUnderline = (style & zFontStyleUnderline);
	logfont.lfItalic = (style & zFontStyleItalic);
	logfont.lfHeight = -size;
	logfont.lfWidth = (size+1)/2;
	if (fontType == zFontApplication) {
		// application font...
		lstrcpy(logfont.lfFaceName,_T("Arial"));
	} else {
		// system font...
		lstrcpy(logfont.lfFaceName,_T("Times New Roman"));
	}

	if (zFontStyleBold & style) {
		logfont.lfWeight = FW_BOLD;
		if (size <= 10)
		logfont.lfWidth += 1;
	} else {
		logfont.lfWeight = FW_NORMAL;
	}

	pFont->hFont = CreateFontIndirect(&logfont);

	return zErrNone;
}

// internal use only
ZFont ZFontCopyFont(ZFont font)
{
	ZFontI* pFont = (ZFontI*)font;

	ZFont fontCopy = ZFontNew();
	ZFontInit(fontCopy,pFont->fontType,pFont->style,pFont->size);

	return fontCopy;
}


void ZLIBPUBLIC ZFontDelete(ZFont font)
{
	ZFontI* pFont = (ZFontI*)font;
	if (pFont->hFont) DeleteObject(pFont->hFont);
    ZFree(pFont);
}

HFONT ZFontWinGetFont(ZFont font)
{
	ZFontI* pFont = (ZFontI*)font;
	return pFont->hFont;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZInfo.cpp

#include <windows.h>
#include "zui.h"
#include "zonecli.h"
#include "zonemem.h"

class ZInfoI : public ZObjectHeader {
public:
	uint16 width;
	ZBool progressBar;
	uint16 totalProgress;
	uint16 progress;
	HWND hWnd;
	TCHAR* infoString;
	RECT rect; // the progress bar rectangle
 };

LRESULT CALLBACK ZInfoWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
static TCHAR* gInfoWndClass = _T("ZInfoWndClass");

ZBool
ZInfoInitApplication(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	WNDCLASS wndcls;

	// Check if our window class has already been registered.
	if (GetClassInfo(g_hInstanceLocal, gInfoWndClass, &wndcls) == FALSE)
	{
		// otherwise we need to register a new class
		wndcls.style = 0;
		wndcls.lpfnWndProc = ZInfoWindowProc;
		wndcls.cbClsExtra = 0;
		wndcls.cbWndExtra = 4;
		wndcls.hInstance = g_hInstanceLocal;
		wndcls.hIcon = NULL;
		wndcls.hCursor = NULL;
		wndcls.hbrBackground = (HBRUSH)::GetStockObject(WHITE_BRUSH);
		wndcls.lpszMenuName = NULL;
		wndcls.lpszClassName = gInfoWndClass;

		if (!RegisterClass(&wndcls)) 
			return FALSE;
	}

	return TRUE;
}

void ZInfoTermApplication(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
//	UnregisterClass(gInfoWndClass,g_hInstanceLocal);
}


ZInfo ZLIBPUBLIC ZInfoNew(void)
{
	ZInfoI* pInfo = (ZInfoI*) new ZInfoI;

	pInfo->nType = zTypeInfo;
#if 0
	// register our window class if needed
	static BOOL registered = FALSE;
	if (!registered) {
		WNDCLASS wndcls;

		// otherwise we need to register a new class
		wndcls.style = 0;
		wndcls.lpfnWndProc = ZInfoWindowProc;
		wndcls.cbClsExtra = 0;
		wndcls.cbWndExtra = 4;
		wndcls.hInstance = g_hInstanceLocal;
		wndcls.hIcon = NULL;
		wndcls.hCursor = NULL;
		wndcls.hbrBackground = (HBRUSH)::GetStockObject(WHITE_BRUSH);
		wndcls.lpszMenuName = NULL;
		wndcls.lpszClassName = gInfoWndClass;
		if (!RegisterClass(&wndcls)) return NULL;

		registered = TRUE;
	}
#endif

	return (ZInfo)pInfo;
}

#define LAYOUT_TOP_TEXT 8
#define LAYOUT_TOP_BAR 28
#define LAYOUT_HEIGHT_CLIENT 52

void ZWinCenterPopupWindow(HWND parent, int width, int height, RECT* rect)
{
	if (!parent) {
		/* using the desktop window as the parent */
		int cx = GetSystemMetrics(SM_CXSCREEN);
		int cy = GetSystemMetrics(SM_CYSCREEN);
		int x = (cx-width)/2;
		int y = (cy-height)/2;
		rect->left = x;
		rect->top = y;
		rect->right = x+width;
		rect->bottom = y + height;
	} else {
		/* we have a real window as the parent */
		RECT rectParent;
		GetWindowRect(parent,&rectParent);
		int cx = rectParent.right - rectParent.left;
		int cy = rectParent.bottom - rectParent.top;
		int x = (cx-width)/2;
		int y = (cy-height)/2;
		rect->left = rectParent.left + x;
		rect->top = rectParent.top + y;
		rect->right = rect->left + width;
		rect->bottom = rect->top + height;
	}

}


ZError ZLIBPUBLIC ZInfoInit(ZInfo info, ZWindow parentWindow, TCHAR* infoString, uint16 width,
		ZBool progressBar, uint16 totalProgress)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZInfoI* pInfo = (ZInfoI*) info;
	DWORD dwStyle = WS_CAPTION | WS_POPUP;
	int height = GetSystemMetrics(SM_CYCAPTION) + LAYOUT_HEIGHT_CLIENT;
	RECT rect;

	// get a parent window if there is one 
	HWND hwndParent = ZWinGetDesktopWindow();
    /* Stupid hack going in for now. */
    if (parentWindow == NULL)
        hwndParent = ZWindowWinGetOCXWnd();
	else if (parentWindow) {
		hwndParent = ZWindowWinGetWnd(parentWindow);
	}

	ZWinCenterPopupWindow(hwndParent,width,height,&rect);

	//Prefix Warning: Function pointer could be NULL
	if( ZClientName != NULL )
	{
		
		pInfo->hWnd = ::CreateWindowEx(0/*WS_EX_TOPMOST*/,gInfoWndClass,
			ZClientName(),dwStyle,
			rect.left,rect.top,rect.right-rect.left,
			rect.bottom - rect.top, hwndParent, NULL, g_hInstanceLocal, pInfo);
	}
	else
	{
		pInfo->hWnd = NULL;
	}
		
			
	if (!pInfo->hWnd) return zErrWindowSystemGeneric;

	// calculate the rectangle for the progress bar..
	pInfo->rect.left = 16;
	pInfo->rect.right = width-16;
	pInfo->rect.top = LAYOUT_TOP_BAR;
	pInfo->rect.bottom = pInfo->rect.top + 12;

	// store the parameters
	if (infoString) {
        pInfo->infoString = (TCHAR*)ZMalloc((lstrlen(infoString)+1)*sizeof(TCHAR));
		lstrcpy(pInfo->infoString,infoString);
	} else {
        pInfo->infoString = (TCHAR*)ZMalloc(sizeof(TCHAR));
		pInfo->infoString[0] = 0;
	}

	pInfo->width = width;
	pInfo->progressBar = progressBar;
	pInfo->totalProgress = totalProgress;

	// currently no progress
	pInfo->progress = 0;

	return zErrNone;
}

void ZLIBPUBLIC ZInfoDelete(ZInfo info)
{
	ZInfoI* pInfo = (ZInfoI*) info;
	if ( IsWindow(pInfo->hWnd) ) DestroyWindow(pInfo->hWnd);
    if (pInfo->infoString) ZFree(pInfo->infoString);
	delete pInfo;
}
void ZLIBPUBLIC ZInfoShow(ZInfo info)
{
    // disabled in Millennium
    return;

	ZInfoI* pInfo = (ZInfoI*) info;
	ShowWindow(pInfo->hWnd,SW_SHOW);
	UpdateWindow(pInfo->hWnd);
}
void ZLIBPUBLIC ZInfoHide(ZInfo info)
{
	ZInfoI* pInfo = (ZInfoI*) info;
	ShowWindow(pInfo->hWnd,SW_HIDE);
}
void ZLIBPUBLIC ZInfoSetText(ZInfo info, TCHAR* infoString)
{
	ZInfoI* pInfo = (ZInfoI*) info;
    if (pInfo->infoString) ZFree(pInfo->infoString);
    pInfo->infoString = (TCHAR*)ZMalloc((lstrlen(infoString)+1)*sizeof(TCHAR));
	lstrcpy(pInfo->infoString,infoString);
	InvalidateRect(pInfo->hWnd,NULL,TRUE);
	UpdateWindow(pInfo->hWnd);
}
void ZLIBPUBLIC ZInfoSetProgress(ZInfo info, uint16 progress)
{
	ZInfoI* pInfo = (ZInfoI*) info;
	pInfo->progress = progress;
#if 0
	/*
		It's silly to assert just because of a bad count.
		This also causes network activity to take place and things
		work out of synch than expected.
	*/
	ASSERT(pInfo->progress <= pInfo->totalProgress);
#endif
	pInfo->progress = MIN(pInfo->progress,pInfo->totalProgress);
	InvalidateRect(pInfo->hWnd,NULL,FALSE);
	UpdateWindow(pInfo->hWnd);
}
void ZLIBPUBLIC ZInfoIncProgress(ZInfo info, int16 incProgress)
{
	ZInfoI* pInfo = (ZInfoI*) info;
	pInfo->progress += incProgress;
#if 0
	/*
		It's silly to assert just because of a bad count.
		This also causes network activity to take place and things
		work out of synch than expected.
	*/
	ASSERT(pInfo->progress <= pInfo->totalProgress);
#endif
	pInfo->progress = MIN(pInfo->progress,pInfo->totalProgress);
	InvalidateRect(pInfo->hWnd,NULL,FALSE);
	UpdateWindow(pInfo->hWnd);
}
void ZLIBPUBLIC ZInfoSetTotalProgress(ZInfo info, uint16 totalProgress)
{
	ZInfoI* pInfo = (ZInfoI*) info;
	pInfo->totalProgress = totalProgress;
	InvalidateRect(pInfo->hWnd,NULL,FALSE);
	UpdateWindow(pInfo->hWnd);
}


LRESULT CALLBACK ZInfoWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return DefWindowProc(hWnd,msg,wParam,lParam);
    }


	switch (msg) {
	case WM_CREATE:
	{
		// set up paramters for Charial calls to the users message proc.
		CREATESTRUCT* pCreateStruct = (CREATESTRUCT*)lParam;
		ZInfoI* pInfo = (ZInfoI*) pCreateStruct->lpCreateParams;
		pInfo->hWnd = hWnd;	
		SetWindowLong(pInfo->hWnd, 0,(LONG)pInfo);
		
		break;
    }
	case WM_PAINT:
	{
		ZInfoI* pInfo = (ZInfoI*)GetWindowLong(hWnd,0);

		PAINTSTRUCT ps;
		HDC hDC = BeginPaint(hWnd,&ps);

		// do we have infoString?
		if (pInfo->infoString) {
			SetTextAlign(hDC,TA_LEFT);
			TextOut(hDC,pInfo->rect.left,LAYOUT_TOP_TEXT,pInfo->infoString,lstrlen(pInfo->infoString));
		}

		// do we have a progress bar?
		if (pInfo->progressBar) {
			// draw a black outline of the total progress rectangle
			HPEN hPenOld = (HPEN)SelectObject(hDC,(HPEN)::GetStockObject(BLACK_PEN));
			Rectangle(hDC,pInfo->rect.left,pInfo->rect.top,pInfo->rect.right,pInfo->rect.bottom);
			SelectObject(hDC,hPenOld);

			// draw a black filled rectangle to indicate the progress.
			RECT rect;
			rect.left = pInfo->rect.left;
			// possible that totalProgress is zero and so is progress...
			if (pInfo->totalProgress == pInfo->progress) {
				rect.right = pInfo->rect.right;
			} else {
				rect.right = rect.left + (pInfo->rect.right - pInfo->rect.left)*pInfo->progress/pInfo->totalProgress;
			}
			rect.top = pInfo->rect.top;
			rect.bottom = pInfo->rect.bottom;
			FillRect(hDC,&rect,(HBRUSH)::GetStockObject(BLACK_BRUSH));
		}
		EndPaint(hWnd,&ps);
		break;
	}
	default:
		break;
	} // switch

	return DefWindowProc(hWnd,msg,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zmessage.cpp ===
/*******************************************************************************

	ZMessage.c
	
		Message handling routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Tuesday, July 11, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	4		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
	3		11/15/96	HI		More changes related to ZONECLI_DLL.
	2		11/08/96	HI		Conditionalized changes for ZONECLI_DLL.
	1		09/05/96	HI		Added ZBeep() when displaying a text message.
	0		07/11/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>

#include "zoneint.h"
//#include "zconnint.h"
//#include "SystemMsg.h"
#include "zonecli.h"
#include "zui.h"
#include "zonemem.h"
#include "zoneresource.h"


#define MT(item)					((void*) (uint32) (item))


typedef struct
{
	ZMessageFunc		messageFunc;
	ZMessage			message;
} MessageItemType, *MessageItem;


/* -------- Globals -------- */
#ifdef ZONECLI_DLL

#define gMessageInited				(pGlobals->m_gMessageInited)
#define gMessageList				(pGlobals->m_gMessageList)

#else

static ZBool			gMessageInited = FALSE;
static ZLList			gMessageList = NULL;

#endif


/* -------- Internal Routines -------- */
static void MessageCheckFunc(void* userData);
static void MessageExitFunc(void* userData);
static void MessageDeleteFunc(void* objectType, void* objectData);


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

/*
	ZSendMessage()
	
	Calls the message procedures by creating a message structure with the
	parameters.
*/
ZBool ZSendMessage(ZObject theObject, ZMessageFunc messageFunc,
		uint16 messageType, ZPoint* where, ZRect* drawRect, uint32 message,
		void* messagePtr, uint32 messageLen, void* userData)
{
	ZMessage		pThis;
	

	if (messageFunc != NULL)
	{
		pThis.object = theObject;
		pThis.messageType = messageType;
		if (where != NULL)
			pThis.where = *where;
		else
			pThis.where.x = pThis.where.y = 0;
		if (drawRect != NULL)
			pThis.drawRect = *drawRect;
		else
			pThis.drawRect.left = pThis.drawRect.top = pThis.drawRect.right = pThis.drawRect.bottom = 0;
		pThis.message = message;
		pThis.messagePtr = messagePtr;
		pThis.messageLen = messageLen;
		pThis.userData = userData;
		
		return ((*messageFunc)(theObject, &pThis));
	}
	else
	{
		return (FALSE);
	}
}


/*
	Post messages even if messageFunc is NULL. System messages have messageFunc as NULL.
	We should also allow all messages to be posted so that they may be gotten and removed.
	We will simply not call the messageFunc if it's NULL so that we don't crash.
*/
void ZPostMessage(ZObject theObject, ZMessageFunc messageFunc,
		uint16 messageType, ZPoint* where, ZRect* drawRect, uint32 message,
		void* messagePtr, uint32 messageLen, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	MessageItem		msg;
	
	
	/* Has it been initialized yet? */
	if (gMessageInited == FALSE)
	{
		/* Create the message linked list object. */
		gMessageList = ZLListNew(MessageDeleteFunc);
		if (gMessageList != NULL)
		{
			/* Install the exit function. */
			ZCommonLibInstallExitFunc(MessageExitFunc, NULL);
			
			/* Install the periodic check function. */
			ZCommonLibInstallPeriodicFunc(MessageCheckFunc, NULL);
			
			gMessageInited = TRUE;
		}
		else
		{
            ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
		}
	}
	
	if (gMessageInited)
	{
		/* Create a new message item */
		msg = (MessageItem)ZMalloc(sizeof(MessageItemType));
		if (msg != NULL)
		{
			msg->messageFunc = messageFunc;
			msg->message.object = theObject;
			msg->message.messageType = messageType;
			if (where != NULL)
				msg->message.where = *where;
			else
				msg->message.where.x = msg->message.where.y = 0;
			if (drawRect != NULL)
				msg->message.drawRect = *drawRect;
			else
				msg->message.drawRect.left = msg->message.drawRect.top =
						msg->message.drawRect.right = msg->message.drawRect.bottom = 0;
			msg->message.message = message;
			msg->message.messagePtr = messagePtr;
			msg->message.messageLen = messageLen;
			msg->message.userData = userData;
			
			/* Add the new message to the list. */
			ZLListAdd(gMessageList, NULL, MT(messageType), msg, zLListAddLast);
		}
	}
}


/*
	Retrieves a message of the given type for theObject. It returns TRUE if a
	message of the given type is found and retrieved; otherwise, it returns FALSE.
	
	The original message is NOT removed from the queue.
*/
ZBool ZGetMessage(ZObject theObject, uint16 messageType, ZMessage* message,
		ZBool remove)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZBool			gotIt = FALSE;
	ZLListItem		listItem;
	MessageItem		msg;
	
	
	if (gMessageInited)
	{
		listItem = ZLListGetFirst(gMessageList, MT(messageType));
		while (listItem != NULL)
		{
			msg = (MessageItem)ZLListGetData(listItem, NULL);
			if (msg->message.object == theObject)
			{
				if (message != NULL)
					*message = msg->message;
				if (remove)
					ZLListRemove(gMessageList, listItem);
				gotIt = TRUE;
				break;
			}
			listItem = ZLListGetNext(gMessageList, listItem, MT(messageType));
		}
	}
	
	return (gotIt);
}


/*
	Removes a message of messageType from the message queue. If allInstances is
	TRUE, then all messages of messageType in the queue will be removed. If
	messageType is zMessageAllTypes, then the message queue is emptied. If returns
	TRUE if the specified message was found and removed; otherwise, it returns FALSE.
*/
ZBool ZRemoveMessage(ZObject theObject, uint16 messageType, ZBool allInstances)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZBool			gotIt = FALSE;
	ZLListItem		listItem;
	MessageItem		msg;
	void*			type;
	
	
	if (gMessageInited)
	{
		if (theObject == NULL)
		{
			if (messageType == zMessageAllTypes)
			{
				ZLListRemoveType(gMessageList, zLListAnyType);
				gotIt = TRUE;
			}
			else if (allInstances)
			{
				if (ZLListCount(gMessageList, MT(messageType)) > 0)
				{
					ZLListRemoveType(gMessageList, MT(messageType));
					gotIt = TRUE;
				}
			}
			else
			{
				listItem = ZLListGetFirst(gMessageList, MT(messageType));
				if (listItem != NULL)
				{
					ZLListRemove(gMessageList, listItem);
					gotIt = TRUE;
				}
			}
		}
		else
		{
			listItem = ZLListGetFirst(gMessageList, zLListAnyType);
			while (listItem != NULL)
			{
				msg = (MessageItem)ZLListGetData(listItem, &type);
				if (msg->message.object == theObject)
				{
					if (messageType == zMessageAllTypes)
					{
						ZLListRemove(gMessageList, listItem);
						gotIt = TRUE;
					}
					else if ((uint16) type == messageType)
					{
						ZLListRemove(gMessageList, listItem);
						gotIt = TRUE;
						if (allInstances == FALSE)
							break;
					}
				}
				listItem = ZLListGetNext(gMessageList, listItem, zLListAnyType);
			}
		}
	}
	
	return (gotIt);
}


/*
	Must free the message buffer, if not NULL.
*/
void ZSystemMessageHandler(int32 messageType, int32 messageLen, char* message)
{
    // PCWTODO: The only thing which uses us is zclicon, which is unused.
    ASSERT( !"Implement me!" );
    /* 
	switch (messageType)
	{
        case zConnectionSystemAlertExMessage:
        case zConnectionSystemAlertMessage:
            {
				ZSystemMsgAlert*	msg = (ZSystemMsgAlert*) message;
				char*				newText = NULL;
				
				
				if (msg != NULL)
				{
//					ZSystemMsgAlertEndian(msg);
					newText = (char*) msg + sizeof(ZSystemMsgAlert);
					ZBeep();
					if (messageType == zConnectionSystemAlertExMessage)
						ZMessageBoxEx(NULL, ZClientName(), newText);
					else
						ZDisplayText(newText, NULL, NULL);
				}
			}
			break;
		default:
			break;
	}
    */	
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static void MessageCheckFunc(void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZLListItem			listItem;
	MessageItemType		msg;
	
	
	/* Get the first message in the list. */
	listItem = ZLListGetFirst(gMessageList, zLListAnyType);
	if (listItem != NULL)
	{
		msg = *(MessageItem)ZLListGetData(listItem, NULL);
		
		/* Remove it from the list */
		ZLListRemove(gMessageList, listItem);
		
		/* Send the message to the object. */
		//Prefix Warning: Function pointer could be NULL
		if (msg.message.object == zObjectSystem && ZClientMessageHandler != NULL )
		{
			ZClientMessageHandler(&msg.message);
		}
		else
		{
			if (msg.messageFunc != NULL)
				msg.messageFunc(msg.message.object, &msg.message);
		}
	}
}


static void MessageExitFunc(void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	/* Dispose of the message list object. */
	ZLListDelete(gMessageList);
	gMessageList = NULL;
	gMessageInited = FALSE;
}


static void MessageDeleteFunc(void* objectType, void* objectData)
{
	/* Free the message object. */
	if (objectData != NULL)
		ZFree(objectData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zoneclires.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by zonecli.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        120
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zone1.cpp ===
/*******************************************************************************

	Zone1.c
	
		Contains endian conversion routines.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, November 12, 1994 08:39:47 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		11/12/94	HI		Created.
	 
*******************************************************************************/


#include "zoneint.h"


void ZRectEndian(ZRect *rect)
{
	ZEnd16(&rect->left);
	ZEnd16(&rect->top);
	ZEnd16(&rect->right);
	ZEnd16(&rect->bottom);
}


void ZPointEndian(ZPoint *point)
{
	ZEnd16(&point->x);
	ZEnd16(&point->y);
}


void ZColorTableEndian(ZColorTable* table)
{
	ZEnd32(&table->numColors);
}


void ZImageDescriptorEndian(ZImageDescriptor *imageDesc, ZBool doAll,
		int16 conversion)
{
	if (doAll && conversion == zEndianToStandard)
	{
		if (imageDesc->colorTableOffset > 0)
			ZColorTableEndian((ZColorTable*) ((char*) imageDesc +
					imageDesc->colorTableOffset));
	}
	
	ZEnd32(&imageDesc->objectSize);
	ZEnd32(&imageDesc->descriptorVersion);
	ZEnd16(&imageDesc->width);
	ZEnd16(&imageDesc->height);
	ZEnd16(&imageDesc->imageRowBytes);
	ZEnd16(&imageDesc->maskRowBytes);
	ZEnd32(&imageDesc->colorTableDataSize);
	ZEnd32(&imageDesc->imageDataSize);
	ZEnd32(&imageDesc->maskDataSize);
	ZEnd32(&imageDesc->colorTableOffset);
	ZEnd32(&imageDesc->imageDataOffset);
	ZEnd32(&imageDesc->maskDataOffset);

	if (doAll && conversion == zEndianFromStandard)
	{
		if (imageDesc->colorTableOffset > 0)
			ZColorTableEndian((ZColorTable*) ((char*) imageDesc +
					imageDesc->colorTableOffset));
	}
}


void ZAnimFrameEndian(ZAnimFrame* frame)
{
	ZEnd16(&frame->nextFrameIndex);
}


void ZAnimationDescriptorEndian(ZAnimationDescriptor *animDesc, ZBool doAll,
		int16 conversion)
{
	int16			i;
	int16 			count;
	uint32*			offsets;
	ZAnimFrame*		frames;


	if (doAll && conversion == zEndianToStandard)
	{
		count = animDesc->numFrames;
		frames = (ZAnimFrame*) ((char*) animDesc + animDesc->sequenceOffset);
		for (i = 0; i < count; i++)
			ZAnimFrameEndian(&frames[i]);
		
		count = animDesc->numImages;
		offsets = (uint32*) ((char*) animDesc + animDesc->imageArrayOffset);
		for (i = 0; i < count; i++)
		{
			ZImageDescriptorEndian((ZImageDescriptor*) ((char*) animDesc +
					offsets[i]), TRUE, conversion);
			ZEnd32(&offsets[i]);
		}
		
		count = animDesc->numSounds;
		offsets = (uint32*) ((char*) animDesc + animDesc->soundArrayOffset);
		for (i = 0; i < count; i++)
		{
			ZSoundDescriptorEndian((ZSoundDescriptor*) ((char*) animDesc +
					offsets[i]));
			ZEnd32(&offsets[i]);
		}
		
		if (animDesc->maskDataOffset > 0)
			ZImageDescriptorEndian((ZImageDescriptor*) ((char*) animDesc +
					animDesc->maskDataOffset), TRUE, conversion);
	}
	
	ZEnd32(&animDesc->objectSize);
	ZEnd32(&animDesc->descriptorVersion);
	ZEnd16(&animDesc->numFrames);
	ZEnd16(&animDesc->totalTime);
	ZEnd16(&animDesc->numImages);
	ZEnd16(&animDesc->numSounds);
	ZEnd32(&animDesc->sequenceOffset);
	ZEnd32(&animDesc->maskDataOffset);
	ZEnd32(&animDesc->imageArrayOffset);
	ZEnd32(&animDesc->soundArrayOffset);

	if (doAll && conversion == zEndianFromStandard)
	{
		count = animDesc->numFrames;
		frames = (ZAnimFrame*) ((char*) animDesc + animDesc->sequenceOffset);
		for (i = 0; i < count; i++)
			ZAnimFrameEndian(&frames[i]);
		
		count = animDesc->numImages;
		offsets = (uint32*) ((char*) animDesc + animDesc->imageArrayOffset);
		for (i = 0; i < count; i++)
		{
			ZEnd32(&offsets[i]);
			ZImageDescriptorEndian((ZImageDescriptor*) ((char*) animDesc +
					offsets[i]), TRUE, conversion);
		}
		
		count = animDesc->numSounds;
		offsets = (uint32*) ((char*) animDesc + animDesc->soundArrayOffset);
		for (i = 0; i < count; i++)
		{
			ZEnd32(&offsets[i]);
			ZSoundDescriptorEndian((ZSoundDescriptor*) ((char*) animDesc +
					offsets[i]));
		}
		
		if (animDesc->maskDataOffset > 0)
			ZImageDescriptorEndian((ZImageDescriptor*) ((char*) animDesc +
					animDesc->maskDataOffset), TRUE, conversion);
	}
}


void ZSoundDescriptorEndian(ZSoundDescriptor *soundDesc)
{
	ZEnd32(&soundDesc->objectSize);
	ZEnd32(&soundDesc->descriptorVersion);
	ZEnd16(&soundDesc->soundType);
	ZEnd32(&soundDesc->soundDataSize);
	ZEnd32(&soundDesc->soundSamplingRate);
	ZEnd32(&soundDesc->soundDataOffset);
}


void ZFileHeaderEndian(ZFileHeader* header)
{
	ZEnd32(&header->version);
	ZEnd32(&header->signature);
	ZEnd32(&header->fileDataSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zmisc.cpp ===
/*******************************************************************************

	Misc.c
	
		Miscellaneous routines.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, November 12, 1994 10:04:52 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
    ----------------------------------------------------------------------------
	8		2/09/96		CHB		Added ZLaunchURL().
    7       1/09/97  craigli    #ifdef'd zone.ini code
    6       12/16/96    HI      Changed ZMemCpy() to memcpy().
	5		12/12/96	HI		Remove MSVCRT.DLL dependency.
	4		11/08/96	HI		Conditional removal of fonts and colors for
								ZONECLI_DLL.
    3       10/28/96 craigli    Added GetPrivateProfile commands.
    2       10/23/96    HI      Changed ZParseVillageCommandLine().
	1		10/23/96	HI		Changed ZParseVillageCommandLine() to accept
								char* for serverAddr and parse the server address
								as a string instead of as a number.
	0		11/12/94	HI		Created.
	 
*******************************************************************************/


#include <windows.h>
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>

#include "zoneint.h"
#include "zonecli.h"
#include "zonemem.h"


/* -------- Globals -------- */

#ifndef ZONECLI_DLL

/* -------- Predefined Colors -------- */
ZColor			zColorBlack			=	{	0,	0x00,	0x00,	0x00};
ZColor			zColorDarkGray		=	{	0,	0x33,	0x33,	0x33};
ZColor			zColorGray			=	{	0,	0x80,	0x80,	0x80};
ZColor			zColorLightGray		=	{	0,	0xC0,	0xC0,	0xC0};
ZColor			zColorWhite			=	{	0,	0xFF,	0xFF,	0xFF};
ZColor			zColorRed			=	{	0,	0xFF,	0x00,	0x00};
ZColor			zColorGreen			=	{	0,	0x00,	0xFF,	0x00};
ZColor			zColorBlue			=	{	0,	0x00,	0x00,	0xFF};
ZColor			zColorYellow		=	{	0,	0xFF,	0xFF,	0x00};
ZColor			zColorCyan			=	{	0,	0x00,	0xFF,	0xFF};
ZColor			zColorMagenta		=	{	0,	0xFF,	0x00,	0xFF};

/* -------- Predefined Font Objects -------- */
ZFont			zFontSystem12Normal;
ZFont			zFontApp9Normal;
ZFont			zFontApp9Bold;
ZFont			zFontApp12Normal;
ZFont			zFontApp12Bold;

#endif


/* -------- Internal Routines -------- */


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

/*
	ZRectIntersect()
	
	Returns TRUE if rectA and rectB overlap; otherwise, it returns FALSE.

	Also stores the intersection into rectC. If rectC is NULL, then it
	does not return the intersection.

	Either rectA or rectB can be specified as rectC.
*/
ZBool ZRectIntersection(ZRect *rectA, ZRect *rectB, ZRect *rectC)
{
	ZBool		intersects = FALSE;
	int16		left, right, top, bottom;
	
	
	left = MAX(rectA->left, rectB->left);
	right = MIN(rectA->right, rectB->right);
	if (right - left > 0)
	{
		top = MAX(rectA->top, rectB->top);
		bottom = MIN(rectA->bottom, rectB->bottom);
		if (bottom - top > 0)
		{
			intersects = TRUE;
			
			if (rectC != NULL)
			{
				rectC->left = left;
				rectC->right = right;
				rectC->top = top;
				rectC->bottom = bottom;
			}
		}
	}
	
	return (intersects);
}


/*
	ZRectUnion()
	
	Determines the union of rectA and rectB and stores into rectC.

	Either rectA or rectB can be specified as rectC.
*/
void ZRectUnion(ZRect *rectA, ZRect *rectB, ZRect *rectC)
{
	int16		left, right, top, bottom;
	
	
	left = MIN(rectA->left, rectB->left);
	right = MAX(rectA->right, rectB->right);
	top = MIN(rectA->top, rectB->top);
	bottom = MAX(rectA->bottom, rectB->bottom);
	if (rectC != NULL)
	{
		rectC->left = left;
		rectC->right = right;
		rectC->top = top;
		rectC->bottom = bottom;
	}
}


/*
	ZRectEmpty()
	
	Returns TRUE if rect is empty. A rectangle is empty if it does not contain a pixel
	inside it.
*/
ZBool ZRectEmpty(ZRect *rect)
{
	return (rect->right - rect->left <= 0 && rect->bottom - rect->top <= 0);
}


/*
	ZPointInRect()
	
	Returns TRUE if point is inside or on the boundry of rect. Otherwise, it returns
	FALSE.
*/
ZBool ZPointInRect(ZPoint *point, ZRect *rect)
{
	return (rect->left <= point->x && point->x < rect->right &&
			rect->top <= point->y && point->y < rect->bottom);
}


/*
	ZRectOffset()
	
	Moves the rectangle by dx and dy.
*/
void ZRectOffset(ZRect *rect, int16 dx, int16 dy)
{
	rect->left += dx;
	rect->right += dx;
	rect->top += dy;
	rect->bottom += dy;
}


/*
	ZRectInset()
	
	Insets the rectangle by dx and dy. It outsets the rectangle if
	dx and dy are negative.
*/
void ZRectInset(ZRect *rect, int16 dx, int16 dy)
{
	rect->left += dx;
	rect->right -= dx;
	rect->top += dy;
	rect->bottom -= dy;
}


/*
	ZCenterRectToRect()
	
	Centers rectA to rectB.
*/
void ZCenterRectToRect(ZRect* rectA, ZRect* rectB, uint16 flags)
{
	int16			width, height;
	
	
	width = ZRectWidth(rectA);
	height = ZRectHeight(rectA);
	
	if (flags == 0 || (flags & zCenterHorizontal))
	{
		rectA->left = (rectB->left + rectB->right + rectA->left - rectA->right) / 2;
		rectA->right = rectA->left + width;
	}
	
	if (flags == 0 || (flags & zCenterVertical))
	{
		rectA->top = (rectB->top + rectB->bottom + rectA->top - rectA->bottom) / 2;
		rectA->bottom = rectA->top + height;
	}
}


/*
	ZPointOffset()
	
	Moves the point by dx and dy.
*/
void ZPointOffset(ZPoint* point, int16 dx, int16 dy)
{
	point->x += dx;
	point->y += dy;
}


/*
	ZGetSystemColorTable()
	
	Returns a copy of the Zone(tm) system color table. It copies it instead
	of returning the pointer to it to protect the system color table.
*/
ZColorTable* ZGetSystemColorTable(void)
{
#define zNumSystemColors			256
	static ZColor		systemColors[zNumSystemColors] =
			{
#if 0
				{0x00, 0xFF, 0xFF, 0xFF}, {0x01, 0xFF, 0xFB, 0xF0}, {0x02, 0xFF, 0xFF, 0x99},
				{0x03, 0xFF, 0xFF, 0x66}, {0x04, 0xFF, 0xFF, 0x33}, {0x05, 0xFF, 0xFF, 0x00},
				{0x06, 0xFF, 0xCC, 0xFF}, {0x07, 0xFF, 0xCC, 0xCC}, {0x08, 0xFF, 0xCC, 0x99},
				{0x09, 0xFF, 0xCC, 0x66}, {0x0A, 0xFF, 0xCC, 0x33}, {0x0B, 0xFF, 0xCC, 0x00},
				{0x0C, 0xFF, 0x99, 0xFF}, {0x0D, 0xFF, 0x99, 0xCC}, {0x0E, 0xFF, 0x99, 0x99},
				{0x0F, 0xFF, 0x99, 0x66}, {0x10, 0xFF, 0x99, 0x33}, {0x11, 0xFF, 0x99, 0x00},
				{0x12, 0xFF, 0x66, 0xFF}, {0x13, 0xFF, 0x66, 0xCC}, {0x14, 0xFF, 0x66, 0x99},
				{0x15, 0xFF, 0x66, 0x66}, {0x16, 0xFF, 0x66, 0x33}, {0x17, 0xFF, 0x66, 0x00},
				{0x18, 0xFF, 0x33, 0xFF}, {0x19, 0xFF, 0x33, 0xCC}, {0x1A, 0xFF, 0x33, 0x99},
				{0x1B, 0xFF, 0x33, 0x66}, {0x1C, 0xFF, 0x33, 0x33}, {0x1D, 0xFF, 0x33, 0x00},
				{0x1E, 0xFF, 0x00, 0xFF}, {0x1F, 0xFF, 0x00, 0xCC}, {0x20, 0xFF, 0x00, 0x99},
				{0x21, 0xFF, 0x00, 0x66}, {0x22, 0xFF, 0x00, 0x33}, {0x23, 0xFF, 0x00, 0x00},
				{0x24, 0xCC, 0xFF, 0xFF}, {0x25, 0xC0, 0xDC, 0xC0}, {0x26, 0xCC, 0xFF, 0x99},
				{0x27, 0xCC, 0xFF, 0x66}, {0x28, 0xCC, 0xFF, 0x33}, {0x29, 0xCC, 0xFF, 0x00},
				{0x2A, 0xCC, 0xCC, 0xFF}, {0x2B, 0xC0, 0xC0, 0xC0}, {0x2C, 0xCC, 0xCC, 0x99},
				{0x2D, 0xCC, 0xCC, 0x66}, {0x2E, 0xCC, 0xCC, 0x33}, {0x2F, 0xCC, 0xCC, 0x00},
				{0x30, 0xCC, 0x99, 0xFF}, {0x31, 0xCC, 0x99, 0xCC}, {0x32, 0xCC, 0x99, 0x99},
				{0x33, 0xCC, 0x99, 0x66}, {0x34, 0xCC, 0x99, 0x33}, {0x35, 0xCC, 0x99, 0x00},
				{0x36, 0xCC, 0x66, 0xFF}, {0x37, 0xCC, 0x66, 0xCC}, {0x38, 0xCC, 0x66, 0x99},
				{0x39, 0xCC, 0x66, 0x66}, {0x3A, 0xCC, 0x66, 0x33}, {0x3B, 0xCC, 0x66, 0x00},
				{0x3C, 0xCC, 0x33, 0xFF}, {0x3D, 0xCC, 0x33, 0xCC}, {0x3E, 0xCC, 0x33, 0x99},
				{0x3F, 0xCC, 0x33, 0x66}, {0x40, 0xCC, 0x33, 0x33}, {0x41, 0xCC, 0x33, 0x00},
				{0x42, 0xCC, 0x00, 0xFF}, {0x43, 0xCC, 0x00, 0xCC}, {0x44, 0xCC, 0x00, 0x99},
				{0x45, 0xCC, 0x00, 0x66}, {0x46, 0xCC, 0x00, 0x33}, {0x47, 0xCC, 0x00, 0x00},
				{0x48, 0x99, 0xFF, 0xFF}, {0x49, 0x99, 0xFF, 0xCC}, {0x4A, 0x99, 0xFF, 0x99},
				{0x4B, 0x99, 0xFF, 0x66}, {0x4C, 0x99, 0xFF, 0x33}, {0x4D, 0x99, 0xFF, 0x00},
				{0x4E, 0xA6, 0xCA, 0xF0}, {0x4F, 0x99, 0xCC, 0xCC}, {0x50, 0x99, 0xCC, 0x99},
				{0x51, 0x99, 0xCC, 0x66}, {0x52, 0x99, 0xCC, 0x33}, {0x53, 0x99, 0xCC, 0x00},
				{0x54, 0x99, 0x99, 0xFF}, {0x55, 0x99, 0x99, 0xCC}, {0x56, 0x99, 0x99, 0x99},
				{0x57, 0x99, 0x99, 0x66}, {0x58, 0x99, 0x99, 0x33}, {0x59, 0x80, 0x80, 0x00},
				{0x5A, 0x99, 0x66, 0xFF}, {0x5B, 0x99, 0x66, 0xCC}, {0x5C, 0x99, 0x66, 0x99},
				{0x5D, 0x99, 0x66, 0x66}, {0x5E, 0x99, 0x66, 0x33}, {0x5F, 0x99, 0x66, 0x00},
				{0x60, 0x99, 0x33, 0xFF}, {0x61, 0x99, 0x33, 0xCC}, {0x62, 0x99, 0x33, 0x99},
				{0x63, 0x99, 0x33, 0x66}, {0x64, 0x99, 0x33, 0x33}, {0x65, 0x99, 0x33, 0x00},
				{0x66, 0x99, 0x00, 0xFF}, {0x67, 0x99, 0x00, 0xCC}, {0x68, 0x80, 0x00, 0x80},
				{0x69, 0x99, 0x00, 0x66}, {0x6A, 0x99, 0x00, 0x33}, {0x6B, 0x99, 0x00, 0x00},
				{0x6C, 0x66, 0xFF, 0xFF}, {0x6D, 0x66, 0xFF, 0xCC}, {0x6E, 0x66, 0xFF, 0x99},
				{0x6F, 0x66, 0xFF, 0x66}, {0x70, 0x66, 0xFF, 0x33}, {0x71, 0x66, 0xFF, 0x00},
				{0x72, 0x66, 0xCC, 0xFF}, {0x73, 0x66, 0xCC, 0xCC}, {0x74, 0x66, 0xCC, 0x99},
				{0x75, 0x66, 0xCC, 0x66}, {0x76, 0x66, 0xCC, 0x33}, {0x77, 0x66, 0xCC, 0x00},
				{0x78, 0x66, 0x99, 0xFF}, {0x79, 0x66, 0x99, 0xCC}, {0x7A, 0x66, 0x99, 0x99},
				{0x7B, 0x66, 0x99, 0x66}, {0x7C, 0x66, 0x99, 0x33}, {0x7D, 0x66, 0x99, 0x00},
				{0x7E, 0x66, 0x66, 0xFF}, {0x7F, 0x66, 0x66, 0xCC}, {0x80, 0x66, 0x66, 0x99},
				{0x81, 0x66, 0x66, 0x66}, {0x82, 0x66, 0x66, 0x33}, {0x83, 0x66, 0x66, 0x00},
				{0x84, 0x66, 0x33, 0xFF}, {0x85, 0x66, 0x33, 0xCC}, {0x86, 0x66, 0x33, 0x99},
				{0x87, 0x66, 0x33, 0x66}, {0x88, 0x66, 0x33, 0x33}, {0x89, 0x66, 0x33, 0x00},
				{0x8A, 0x66, 0x00, 0xFF}, {0x8B, 0x66, 0x00, 0xCC}, {0x8C, 0x66, 0x00, 0x99},
				{0x8D, 0x66, 0x00, 0x66}, {0x8E, 0x66, 0x00, 0x33}, {0x8F, 0x66, 0x00, 0x00},
				{0x90, 0x33, 0xFF, 0xFF}, {0x91, 0x33, 0xFF, 0xCC}, {0x92, 0x33, 0xFF, 0x99},
				{0x93, 0x33, 0xFF, 0x66}, {0x94, 0x33, 0xFF, 0x33}, {0x95, 0x33, 0xFF, 0x00},
				{0x96, 0x33, 0xCC, 0xFF}, {0x97, 0x33, 0xCC, 0xCC}, {0x98, 0x33, 0xCC, 0x99},
				{0x99, 0x33, 0xCC, 0x66}, {0x9A, 0x33, 0xCC, 0x33}, {0x9B, 0x33, 0xCC, 0x00},
				{0x9C, 0x33, 0x99, 0xFF}, {0x9D, 0x33, 0x99, 0xCC}, {0x9E, 0x33, 0x99, 0x99},
				{0x9F, 0x33, 0x99, 0x66}, {0xA0, 0x33, 0x99, 0x33}, {0xA1, 0x33, 0x99, 0x00},
				{0xA2, 0x33, 0x66, 0xFF}, {0xA3, 0x33, 0x66, 0xCC}, {0xA4, 0x33, 0x66, 0x99},
				{0xA5, 0x33, 0x66, 0x66}, {0xA6, 0x33, 0x66, 0x33}, {0xA7, 0x33, 0x66, 0x00},
				{0xA8, 0x33, 0x33, 0xFF}, {0xA9, 0x33, 0x33, 0xCC}, {0xAA, 0x33, 0x33, 0x99},
				{0xAB, 0x33, 0x33, 0x66}, {0xAC, 0x33, 0x33, 0x33}, {0xAD, 0x33, 0x33, 0x00},
				{0xAE, 0x33, 0x00, 0xFF}, {0xAF, 0x33, 0x00, 0xCC}, {0xB0, 0x33, 0x00, 0x99},
				{0xB1, 0x33, 0x00, 0x66}, {0xB2, 0x33, 0x00, 0x33}, {0xB3, 0x33, 0x00, 0x00},
				{0xB4, 0x00, 0xFF, 0xFF}, {0xB5, 0x00, 0xFF, 0xCC}, {0xB6, 0x00, 0xFF, 0x99},
				{0xB7, 0x00, 0xFF, 0x66}, {0xB8, 0x00, 0xFF, 0x33}, {0xB9, 0x00, 0xFF, 0x00},
				{0xBA, 0x00, 0xCC, 0xFF}, {0xBB, 0x00, 0xCC, 0xCC}, {0xBC, 0x00, 0xCC, 0x99},
				{0xBD, 0x00, 0xCC, 0x66}, {0xBE, 0x00, 0xCC, 0x33}, {0xBF, 0x00, 0xCC, 0x00},
				{0xC0, 0x00, 0x99, 0xFF}, {0xC1, 0x00, 0x99, 0xCC}, {0xC2, 0x00, 0x80, 0x80},
				{0xC3, 0x00, 0x99, 0x66}, {0xC4, 0x00, 0x99, 0x33}, {0xC5, 0x00, 0x99, 0x00},
				{0xC6, 0x00, 0x66, 0xFF}, {0xC7, 0x00, 0x66, 0xCC}, {0xC8, 0x00, 0x66, 0x99},
				{0xC9, 0x00, 0x66, 0x66}, {0xCA, 0x00, 0x66, 0x33}, {0xCB, 0x00, 0x66, 0x00},
				{0xCC, 0x00, 0x33, 0xFF}, {0xCD, 0x00, 0x33, 0xCC}, {0xCE, 0x00, 0x33, 0x99},
				{0xCF, 0x00, 0x33, 0x66}, {0xD0, 0x00, 0x33, 0x33}, {0xD1, 0x00, 0x33, 0x00},
				{0xD2, 0x00, 0x00, 0xFF}, {0xD3, 0x00, 0x00, 0xCC}, {0xD4, 0x00, 0x00, 0x99},
				{0xD5, 0x00, 0x00, 0x66}, {0xD6, 0x00, 0x00, 0x33}, {0xD7, 0xEE, 0x00, 0x00},
				{0xD8, 0xDD, 0x00, 0x00}, {0xD9, 0xBB, 0x00, 0x00}, {0xDA, 0xAA, 0x00, 0x00},
				{0xDB, 0x80, 0x00, 0x00}, {0xDC, 0x77, 0x00, 0x00}, {0xDD, 0x55, 0x00, 0x00},
				{0xDE, 0x44, 0x00, 0x00}, {0xDF, 0x22, 0x00, 0x00}, {0xE0, 0x11, 0x00, 0x00},
				{0xE1, 0x00, 0xEE, 0x00}, {0xE2, 0x00, 0xDD, 0x00}, {0xE3, 0x00, 0xBB, 0x00},
				{0xE4, 0x00, 0xAA, 0x00}, {0xE5, 0x00, 0x80, 0x00}, {0xE6, 0x00, 0x77, 0x00},
				{0xE7, 0x00, 0x55, 0x00}, {0xE8, 0x00, 0x44, 0x00}, {0xE9, 0x00, 0x22, 0x00},
				{0xEA, 0x00, 0x11, 0x00}, {0xEB, 0x00, 0x00, 0xEE}, {0xEC, 0x00, 0x00, 0xDD},
				{0xED, 0x00, 0x00, 0xBB}, {0xEE, 0x00, 0x00, 0xAA}, {0xEF, 0x00, 0x00, 0x80},
				{0xF0, 0x00, 0x00, 0x77}, {0xF1, 0x00, 0x00, 0x55}, {0xF2, 0x00, 0x00, 0x44},
				{0xF3, 0x00, 0x00, 0x22}, {0xF4, 0x00, 0x00, 0x11}, {0xF5, 0xEE, 0xEE, 0xEE},
				{0xF6, 0xDD, 0xDD, 0xDD}, {0xF7, 0xBB, 0xBB, 0xBB}, {0xF8, 0xA0, 0xA0, 0xA4},
				{0xF9, 0x80, 0x80, 0x80}, {0xFA, 0x77, 0x77, 0x77}, {0xFB, 0x55, 0x55, 0x55},
				{0xFC, 0x44, 0x44, 0x44}, {0xFD, 0x22, 0x22, 0x22}, {0xFE, 0x11, 0x11, 0x11},
				{0xFF, 0x00, 0x00, 0x00}
#else
				{0x00, 0x00, 0x00, 0x00}, {0x01, 0x80, 0x00, 0x00}, {0x02, 0x00, 0x80, 0x00}, {0x03, 0x80, 0x80, 0x00},
				{0x04, 0x00, 0x00, 0x80}, {0x05, 0x80, 0x00, 0x80}, {0x06, 0x00, 0x80, 0x80}, {0x07, 0xC0, 0xC0, 0xC0},
				{0x08, 0xC0, 0xDC, 0xC0}, {0x09, 0xA6, 0xCA, 0xF0}, {0x0A, 0x04, 0x04, 0x04}, {0x0B, 0x08, 0x08, 0x08},
				{0x0C, 0x0C, 0x0C, 0x0C}, {0x0D, 0x11, 0x11, 0x11}, {0x0E, 0x16, 0x16, 0x16}, {0x0F, 0x1C, 0x1C, 0x1C},
				{0x10, 0x22, 0x22, 0x22}, {0x11, 0x29, 0x29, 0x29}, {0x12, 0x55, 0x55, 0x55}, {0x13, 0x4D, 0x4D, 0x4D},
				{0x14, 0x42, 0x42, 0x42}, {0x15, 0x39, 0x39, 0x39}, {0x16, 0xFF, 0x7C, 0x80}, {0x17, 0xFF, 0x50, 0x50},
				{0x18, 0xD6, 0x00, 0x93}, {0x19, 0xCC, 0xEC, 0xFF}, {0x1A, 0xEF, 0xD6, 0xC6}, {0x1B, 0xE7, 0xE7, 0xD6},
				{0x1C, 0xAD, 0xA9, 0x90}, {0x1D, 0x33, 0x00, 0x00}, {0x1E, 0x66, 0x00, 0x00}, {0x1F, 0x99, 0x00, 0x00},
				{0x20, 0xCC, 0x00, 0x00}, {0x21, 0x00, 0x33, 0x00}, {0x22, 0x33, 0x33, 0x00}, {0x23, 0x66, 0x33, 0x00},
				{0x24, 0x99, 0x33, 0x00}, {0x25, 0xCC, 0x33, 0x00}, {0x26, 0xFF, 0x33, 0x00}, {0x27, 0x00, 0x66, 0x00},
				{0x28, 0x33, 0x66, 0x00}, {0x29, 0x66, 0x66, 0x00}, {0x2A, 0x99, 0x66, 0x00}, {0x2B, 0xCC, 0x66, 0x00},
				{0x2C, 0xFF, 0x66, 0x00}, {0x2D, 0x00, 0x99, 0x00}, {0x2E, 0x33, 0x99, 0x00}, {0x2F, 0x66, 0x99, 0x00},
				{0x30, 0x99, 0x99, 0x00}, {0x31, 0xCC, 0x99, 0x00}, {0x32, 0xFF, 0x99, 0x00}, {0x33, 0x00, 0xCC, 0x00},
				{0x34, 0x33, 0xCC, 0x00}, {0x35, 0x66, 0xCC, 0x00}, {0x36, 0x99, 0xCC, 0x00}, {0x37, 0xCC, 0xCC, 0x00},
				{0x38, 0xFF, 0xCC, 0x00}, {0x39, 0x66, 0xFF, 0x00}, {0x3A, 0x99, 0xFF, 0x00}, {0x3B, 0xCC, 0xFF, 0x00},
				{0x3C, 0x00, 0x00, 0x33}, {0x3D, 0x33, 0x00, 0x33}, {0x3E, 0x66, 0x00, 0x33}, {0x3F, 0x99, 0x00, 0x33},
				{0x40, 0xCC, 0x00, 0x33}, {0x41, 0xFF, 0x00, 0x33}, {0x42, 0x00, 0x33, 0x33}, {0x43, 0x33, 0x33, 0x33},
				{0x44, 0x66, 0x33, 0x33}, {0x45, 0x99, 0x33, 0x33}, {0x46, 0xCC, 0x33, 0x33}, {0x47, 0xFF, 0x33, 0x33},
				{0x48, 0x00, 0x66, 0x33}, {0x49, 0x33, 0x66, 0x33}, {0x4A, 0x66, 0x66, 0x33}, {0x4B, 0x99, 0x66, 0x33},
				{0x4C, 0xCC, 0x66, 0x33}, {0x4D, 0xFF, 0x66, 0x33}, {0x4E, 0x00, 0x99, 0x33}, {0x4F, 0x33, 0x99, 0x33},
				{0x50, 0x66, 0x99, 0x33}, {0x51, 0x99, 0x99, 0x33}, {0x52, 0xCC, 0x99, 0x33}, {0x53, 0xFF, 0x99, 0x33},
				{0x54, 0x00, 0xCC, 0x33}, {0x55, 0x33, 0xCC, 0x33}, {0x56, 0x66, 0xCC, 0x33}, {0x57, 0x99, 0xCC, 0x33},
				{0x58, 0xCC, 0xCC, 0x33}, {0x59, 0xFF, 0xCC, 0x33}, {0x5A, 0x33, 0xFF, 0x33}, {0x5B, 0x66, 0xFF, 0x33},
				{0x5C, 0x99, 0xFF, 0x33}, {0x5D, 0xCC, 0xFF, 0x33}, {0x5E, 0xFF, 0xFF, 0x33}, {0x5F, 0x00, 0x00, 0x66},
				{0x60, 0x33, 0x00, 0x66}, {0x61, 0x66, 0x00, 0x66}, {0x62, 0x99, 0x00, 0x66}, {0x63, 0xCC, 0x00, 0x66},
				{0x64, 0xFF, 0x00, 0x66}, {0x65, 0x00, 0x33, 0x66}, {0x66, 0x33, 0x33, 0x66}, {0x67, 0x66, 0x33, 0x66},
				{0x68, 0x99, 0x33, 0x66}, {0x69, 0xCC, 0x33, 0x66}, {0x6A, 0xFF, 0x33, 0x66}, {0x6B, 0x00, 0x66, 0x66},
				{0x6C, 0x33, 0x66, 0x66}, {0x6D, 0x66, 0x66, 0x66}, {0x6E, 0x99, 0x66, 0x66}, {0x6F, 0xCC, 0x66, 0x66},
				{0x70, 0x00, 0x99, 0x66}, {0x71, 0x33, 0x99, 0x66}, {0x72, 0x66, 0x99, 0x66}, {0x73, 0x99, 0x99, 0x66},
				{0x74, 0xCC, 0x99, 0x66}, {0x75, 0xFF, 0x99, 0x66}, {0x76, 0x00, 0xCC, 0x66}, {0x77, 0x33, 0xCC, 0x66},
				{0x78, 0x99, 0xCC, 0x66}, {0x79, 0xCC, 0xCC, 0x66}, {0x7A, 0xFF, 0xCC, 0x66}, {0x7B, 0x00, 0xFF, 0x66},
				{0x7C, 0x33, 0xFF, 0x66}, {0x7D, 0x99, 0xFF, 0x66}, {0x7E, 0xCC, 0xFF, 0x66}, {0x7F, 0xFF, 0x00, 0xCC},
				{0x80, 0xCC, 0x00, 0xFF}, {0x81, 0x00, 0x99, 0x99}, {0x82, 0x99, 0x33, 0x99}, {0x83, 0x99, 0x00, 0x99},
				{0x84, 0xCC, 0x00, 0x99}, {0x85, 0x00, 0x00, 0x99}, {0x86, 0x33, 0x33, 0x99}, {0x87, 0x66, 0x00, 0x99},
				{0x88, 0xCC, 0x33, 0x99}, {0x89, 0xFF, 0x00, 0x99}, {0x8A, 0x00, 0x66, 0x99}, {0x8B, 0x33, 0x66, 0x99},
				{0x8C, 0x66, 0x33, 0x99}, {0x8D, 0x99, 0x66, 0x99}, {0x8E, 0xCC, 0x66, 0x99}, {0x8F, 0xFF, 0x33, 0x99},
				{0x90, 0x33, 0x99, 0x99}, {0x91, 0x66, 0x99, 0x99}, {0x92, 0x99, 0x99, 0x99}, {0x93, 0xCC, 0x99, 0x99},
				{0x94, 0xFF, 0x99, 0x99}, {0x95, 0x00, 0xCC, 0x99}, {0x96, 0x33, 0xCC, 0x99}, {0x97, 0x66, 0xCC, 0x66},
				{0x98, 0x99, 0xCC, 0x99}, {0x99, 0xCC, 0xCC, 0x99}, {0x9A, 0xFF, 0xCC, 0x99}, {0x9B, 0x00, 0xFF, 0x99},
				{0x9C, 0x33, 0xFF, 0x99}, {0x9D, 0x66, 0xCC, 0x99}, {0x9E, 0x99, 0xFF, 0x99}, {0x9F, 0xCC, 0xFF, 0x99},
				{0xA0, 0xFF, 0xFF, 0x99}, {0xA1, 0x00, 0x00, 0xCC}, {0xA2, 0x33, 0x00, 0x99}, {0xA3, 0x66, 0x00, 0xCC},
				{0xA4, 0x99, 0x00, 0xCC}, {0xA5, 0xCC, 0x00, 0xCC}, {0xA6, 0x00, 0x33, 0x99}, {0xA7, 0x33, 0x33, 0xCC},
				{0xA8, 0x66, 0x33, 0xCC}, {0xA9, 0x99, 0x33, 0xCC}, {0xAA, 0xCC, 0x33, 0xCC}, {0xAB, 0xFF, 0x33, 0xCC},
				{0xAC, 0x00, 0x66, 0xCC}, {0xAD, 0x33, 0x66, 0xCC}, {0xAE, 0x66, 0x66, 0x99}, {0xAF, 0x99, 0x66, 0xCC},
				{0xB0, 0xCC, 0x66, 0xCC}, {0xB1, 0xFF, 0x66, 0x99}, {0xB2, 0x00, 0x99, 0xCC}, {0xB3, 0x33, 0x99, 0xCC},
				{0xB4, 0x66, 0x99, 0xCC}, {0xB5, 0x99, 0x99, 0xCC}, {0xB6, 0xCC, 0x99, 0xCC}, {0xB7, 0xFF, 0x99, 0xCC},
				{0xB8, 0x00, 0xCC, 0xCC}, {0xB9, 0x33, 0xCC, 0xCC}, {0xBA, 0x66, 0xCC, 0xCC}, {0xBB, 0x99, 0xCC, 0xCC},
				{0xBC, 0xCC, 0xCC, 0xCC}, {0xBD, 0xFF, 0xCC, 0xCC}, {0xBE, 0x00, 0xFF, 0xCC}, {0xBF, 0x33, 0xFF, 0xCC},
				{0xC0, 0x66, 0xFF, 0x99}, {0xC1, 0x99, 0xFF, 0xCC}, {0xC2, 0xCC, 0xFF, 0xCC}, {0xC3, 0xFF, 0xFF, 0xCC},
				{0xC4, 0x33, 0x00, 0xCC}, {0xC5, 0x66, 0x00, 0xFF}, {0xC6, 0x99, 0x00, 0xFF}, {0xC7, 0x00, 0x33, 0xCC},
				{0xC8, 0x33, 0x33, 0xFF}, {0xC9, 0x66, 0x33, 0xFF}, {0xCA, 0x99, 0x33, 0xFF}, {0xCB, 0xCC, 0x33, 0xFF},
				{0xCC, 0xFF, 0x33, 0xFF}, {0xCD, 0x00, 0x66, 0xFF}, {0xCE, 0x33, 0x66, 0xFF}, {0xCF, 0x66, 0x66, 0xCC},
				{0xD0, 0x99, 0x66, 0xFF}, {0xD1, 0xCC, 0x66, 0xFF}, {0xD2, 0xFF, 0x66, 0xCC}, {0xD3, 0x00, 0x99, 0xFF},
				{0xD4, 0x33, 0x99, 0xFF}, {0xD5, 0x66, 0x99, 0xFF}, {0xD6, 0x99, 0x99, 0xFF}, {0xD7, 0xCC, 0x99, 0xFF},
				{0xD8, 0xFF, 0x99, 0xFF}, {0xD9, 0x00, 0xCC, 0xFF}, {0xDA, 0x33, 0xCC, 0xFF}, {0xDB, 0x66, 0xCC, 0xFF},
				{0xDC, 0x99, 0xCC, 0xFF}, {0xDD, 0xCC, 0xCC, 0xFF}, {0xDE, 0xFF, 0xCC, 0xFF}, {0xDF, 0x33, 0xFF, 0xFF},
				{0xE0, 0x66, 0xFF, 0xCC}, {0xE1, 0x99, 0xFF, 0xFF}, {0xE2, 0xCC, 0xFF, 0xFF}, {0xE3, 0xFF, 0x66, 0x66},
				{0xE4, 0x66, 0xFF, 0x66}, {0xE5, 0xFF, 0xFF, 0x66}, {0xE6, 0x66, 0x66, 0xFF}, {0xE7, 0xFF, 0x66, 0xFF},
				{0xE8, 0x66, 0xFF, 0xFF}, {0xE9, 0xA5, 0x00, 0x21}, {0xEA, 0x5F, 0x5F, 0x5F}, {0xEB, 0x77, 0x77, 0x77},
				{0xEC, 0x86, 0x86, 0x86}, {0xED, 0x96, 0x96, 0x96}, {0xEE, 0xCB, 0xCB, 0xCB}, {0xEF, 0xB2, 0xB2, 0xB2},
				{0xF0, 0xD7, 0xD7, 0xD7}, {0xF1, 0xDD, 0xDD, 0xDD}, {0xF2, 0xE3, 0xE3, 0xE3}, {0xF3, 0xEA, 0xEA, 0xEA},
				{0xF4, 0xF1, 0xF1, 0xF1}, {0xF5, 0xF8, 0xF8, 0xF8}, {0xF6, 0xFF, 0xFB, 0xF0}, {0xF7, 0xA0, 0xA0, 0xA4},
				{0xF8, 0x80, 0x80, 0x80}, {0xF9, 0xFF, 0x00, 0x00}, {0xFA, 0x00, 0xFF, 0x00}, {0xFB, 0xFF, 0xFF, 0x00},
				{0xFC, 0x00, 0x00, 0xFF}, {0xFD, 0xFF, 0x00, 0xFF}, {0xFE, 0x00, 0xFF, 0xFF}, {0xFF, 0xFF, 0xFF, 0xFF}
#endif
			}; 
	ZColorTable*		colors;
	
	
	colors = (ZColorTable*) ZMalloc(sizeof(ZColorTable) + sizeof(ZColor) * (zNumSystemColors - 1));
	if (colors != NULL)
	{
		colors->numColors = zNumSystemColors;
		memcpy((BYTE*) colors->colors, (BYTE*) systemColors, sizeof(systemColors));
	}
	
	return (colors);
}


TCHAR* ZGetProgramDataFileName(TCHAR* dataFileName)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	return (ZGenerateDataFileName(NULL, dataFileName));
}


TCHAR* ZGetCommonDataFileName(TCHAR* dataFileName)
{
	return (ZGenerateDataFileName(NULL, dataFileName));
}


void ZParseVillageCommandLine(TCHAR* commandLine, TCHAR* programName,
		TCHAR* serverAddr, uint16* serverPort)
{
    ZASSERT( !"Implement me!" );
    /*
	char*				cmdLine;
    char*               token;
#if ZONE_INI
    char                pszIni[] = "c:\\program files\\zone\\zone.ini";
#endif

	if (commandLine != NULL)
	{
		cmdLine = (char*) ZMalloc(lstrlen(commandLine) + 1);
		lstrcpy(cmdLine, (char*) commandLine);

        // Get the program name. 
        token = strtok(cmdLine, "|");
        ZASSERT(token);
        lstrcpy(programName, token);

#if ZONE_INI
        // get defaults from ini file 
        GetPrivateProfileString( programName, "ServerName", "", serverAddr, 128, pszIni );
        *serverPort = (uint16) GetPrivateProfileInt( programName, "ServerPort", 0xFFFF, pszIni );
#else
        serverAddr[0] = '\0';
        *serverPort = 0;
#endif

        // parse any command line parameters 
        token = strtok(NULL, "|");
        if ( token )
            sscanf(token, "%s %hu", serverAddr, serverPort);


		ZFree(cmdLine);
	}
    */
}


ZBool ZLaunchURL( TCHAR* pszURL )
{
    ZASSERT( !"Implement me!" );
    return FALSE;
    /*
	TCHAR buff[512], app[512], cmd[512], *p;
	DWORD result, bytes, type, i;
	BOOL quotes, hasPercent;
	HKEY hkey;

	// parameter paranoia
	if ( !pszURL || !lstrlen(pszURL) )
		return FALSE;

	// get file type
	result = RegOpenKeyEx( HKEY_CLASSES_ROOT, _T(".htm"), 0, KEY_READ, &hkey );
	if ( ERROR_SUCCESS != result )
	{
		result = RegOpenKeyEx( HKEY_CLASSES_ROOT, _T(".html"), 0, KEY_READ, &hkey );
		if ( ERROR_SUCCESS != result )
			return FALSE;
	}
	type = REG_SZ;
	bytes = sizeof(buff);
	result = RegQueryValueEx( hkey, NULL, 0, &type, (BYTE*) buff, &bytes );
	RegCloseKey( hkey );
	if ( ERROR_SUCCESS != result )
		return FALSE;

	// get open command
    // PCWTODO: Does this need to be localized?
	lstrcat( buff, _T("\\shell\\open\\command") );
	result = RegOpenKeyEx( HKEY_CLASSES_ROOT, buff, 0, KEY_READ, &hkey );
	if ( ERROR_SUCCESS != result )
		return FALSE;	
	type = REG_SZ;
	bytes = sizeof(buff);
	result = RegQueryValueEx( hkey, NULL, 0, &type, (BYTE*) buff, &bytes );
	RegCloseKey( hkey );
	if ( ERROR_SUCCESS != result )
		return FALSE;

	// parse application path
	for ( quotes = FALSE, p = app, i = 0; i < bytes; i++ )
	{
		if ( buff[i] == _T('\"') )
		{
			quotes = !quotes;
			continue;
		}
		else if ( buff[i] == _T(' ') )
		{
			if ( !quotes )
				break;
		}
		*p++ = buff[i];
	}
	*p = '\0';

	// parse command line, i.e. what's leftover
	if ( i < bytes )
	{
		lstrcpy( cmd, &buff[ i + 1 ] );
		lstrcat( cmd, " " );
	}
	else
		cmd[0] = '\0';

	// get rid of %1 if it exists
	// move to percent sign in string
	for(i=0;cmd[i]!=0;i++)
	{
		if(cmd[i]=='%')
		{
			cmd[i]=0;
			lstrcat( cmd, " " );
			break;
		}
	}

	
	lstrcat( cmd, pszURL );

	// run the browser
	if ( (int) ShellExecute( NULL, NULL, app, cmd, NULL, SW_SHOW )  <= 32 )
		return FALSE;
	else
		return TRUE;
    */
}

/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zoneocx.h ===
/*******************************************************************************

	Zone.h
	
		Zone(tm) System API.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, April 29, 1995 06:26:45 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	3		05/15/97	HI		Added bIsLobbyWindow field.
	2		03/23/97	HI		Added flag to ZMessageBoxType.
	1		02/15/97	HI		Added ZMessageBoxType.
	0		04/29/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZONEOCX_
#define _ZONEOCX_


#ifndef _ZTYPES_
#include "ztypes.h"
#endif

#include <windows.h>
#include "zui.h"

#ifdef __cplusplus
extern "C" {
#endif

/*
#define zNumMessageBox			10

typedef struct
{
	HWND hWnd;
	HWND parent;
	TCHAR* title;
	TCHAR* text;
	DWORD flag;
} ZMessageBoxType;
*/

#ifdef ZONECLI_DLL

#define OCXHandle					(pGlobals->m_OCXHandle)

#else

extern HWND OCXHandle;

#endif

// offset in private window data used by controls for pointer to ZWindowI structure
#define GWL_WINDOWPOINTER DLGWINDOWEXTRA
#define GWL_BYTESEXTRA (DLGWINDOWEXTRA+4)

// this is called directly by the ocx's OnDraw
int ZOCXGraphicsWindowProc(HWND hWnd,UINT msg,WPARAM wParam, LPARAM lParam, LRESULT* result);


ZError ZWindowLobbyInit(ZWindow window, ZRect* windowRect,
		int16 windowType, ZWindow parentWindow,
		TCHAR* title, ZBool visible, ZBool talkSection, ZBool center,
		ZMessageFunc windowFunc, uint32 wantMessages, void* userData);

class ZWindowI : public ZGraphicsObjectHeader {
public:
	HWND hWnd;
	void* userData;
	uint16 nControlCount;
	ZMessageFunc messageFunc;
	BOOL talkSection;
	uint32 wantMessages;
	int16 windowType;
	ZWindowI* parentWindow;
	HWND hWndTalkInput;
	HWND hWndTalkOutput;
	int32 windowHeight; /* the height of the drawing area of the window */
	int32 windowWidth; /* the width of the drawing area of the window */
	RECT talkOutputRect;
	RECT talkInputRect;
	RECT fullWindowRect; // rectangle includinding borders/title bar etc.
	RECT minFullWindowRect; // rectangle includinding borders/title bar etc.
	RECT minTalkOutputRect;
	uint32 borderHeight;
	uint32 borderWidth;
	uint32 captionHeight;
	HDC hPaintDC;  // dc for use when WPAINT message comes in and we want to draw with the PaintDC
	BOOL isDialog; // tells whether this is a dialog window
	BOOL isChild; // tells whether this is a child window
	ZButton defaultButton;
	ZButton cancelButton;
	WNDPROC defaultTalkOutputWndProc;
	WNDPROC defaultTalkInputWndProc;
	
	ZMessageFunc trackCursorMessageFunc;
	void*	trackCursorUserData;

	ZLList objectList;
	ZObject objectFocused;

//	ZMessageBoxType mbox[zNumMessageBox];

	BOOL bIsLobbyWindow;
	BOOL bHasTyped;

	ZLList chatMsgList;
	DWORD lastChatMsgTime;
	UINT chatMsgQueueTimerID;
};

void ZWindowSendMessageToAllObjects(ZWindowI* pWindow, uint16 msg, ZPoint* point, ZRect* rect);
// if fRestrictToRect = TRUE, the message is to the objects whose boundary rects
// include the point
ZBool ZWindowSendMessageToObjects(ZWindowI* pWindow, uint16 msg, ZPoint* points, TCHAR c, 
                                  BOOL fRestrictToBounds=TRUE);



#define ZSetColor(pColor, r, g, b)			{\
												((ZColor*) pColor)->red = (r);\
												((ZColor*) pColor)->green = (g);\
												((ZColor*) pColor)->blue = (b);\
											}

#define ZDarkenColor(pColor)				{\
												((ZColor*) pColor)->red >>= 1;\
												((ZColor*) pColor)->green >>= 1;\
												((ZColor*) pColor)->blue >>= 1;\
											}

#define ZBrightenColor(pColor)				{\
												((ZColor*) pColor)->red <<= 1;\
												((ZColor*) pColor)->green <<= 1;\
												((ZColor*) pColor)->blue <<= 1;\
											}

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zonecli.cpp ===
/*******************************************************************************

	ZoneCli.c
	
		Zone(tm) Client DLL.
	
	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on Thursday, November 7, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		03/13/97	HI		Append '\' to end of path just in case in root.
								'C:' is not valid path, "C:\" is valid.
	1		12/27/96	HI		Modified global initialization.
	0		11/07/96	HI		Created.
	 
*******************************************************************************/


#include <stdlib.h>

#include "zoneint.h"
#include "zonedebug.h"
#include "zonecli.h"



/* -------- Globals -------- */
ZClientMainFunc ZClientMain = NULL;
ZClientExitFunc ZClientExit = NULL;
ZClientMessageHandlerFunc ZClientMessageHandler = NULL;
ZClientNameFunc ZClientName = NULL;
ZClientInternalNameFunc ZClientInternalName = NULL;
ZClientVersionFunc ZClientVersion = NULL;
ZCGameNewFunc ZCGameNew = NULL;
ZCGameDeleteFunc ZCGameDelete = NULL;
ZCGameProcessMessageFunc ZCGameProcessMessage = NULL;
ZCGameAddKibitzerFunc ZCGameAddKibitzer = NULL;
ZCGameRemoveKibitzerFunc ZCGameRemoveKibitzer = NULL;


/* -------- Predefined Colors -------- */
static ZColor		gColorBlack			=	{	0,	0x00,	0x00,	0x00};
static ZColor		gColorDarkGray		=	{	0,	0x33,	0x33,	0x33};
static ZColor		gColorGray			=	{	0,	0x80,	0x80,	0x80};
static ZColor		gColorLightGray		=	{	0,	0xC0,	0xC0,	0xC0};
static ZColor		gColorWhite			=	{	0,	0xFF,	0xFF,	0xFF};
static ZColor		gColorRed			=	{	0,	0xFF,	0x00,	0x00};
static ZColor		gColorGreen			=	{	0,	0x00,	0xFF,	0x00};
static ZColor		gColorBlue			=	{	0,	0x00,	0x00,	0xFF};
static ZColor		gColorYellow		=	{	0,	0xFF,	0xFF,	0x00};
static ZColor		gColorCyan			=	{	0,	0x00,	0xFF,	0xFF};
static ZColor		gColorMagenta		=	{	0,	0xFF,	0x00,	0xFF};


/* -------- Internal Routine Prototypes -------- */
static void GetLocalPath(ClientDllGlobals pGlobals);
static ZError LoadGameDll(ClientDllGlobals pGlobals, GameInfo gameInfo);
static void UnloadGameDll(ClientDllGlobals pGlobals);


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

void* ZGetStockObject(int32 objectID)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();

	
	if (pGlobals == NULL)
		return (NULL);

	switch (objectID)
	{
		/* -------- Predefine Fonts -------- */
		case zObjectFontSystem12Normal:
			return ((void*) pGlobals->m_gFontSystem12Normal);
		case zObjectFontApp9Normal:
			return ((void*) pGlobals->m_gFontApp9Normal);
		case zObjectFontApp9Bold:
			return ((void*) pGlobals->m_gFontApp9Bold);
		case zObjectFontApp12Normal:
			return ((void*) pGlobals->m_gFontApp12Normal);
		case zObjectFontApp12Bold:
			return ((void*) pGlobals->m_gFontApp12Bold);

		/* -------- Predefined Colors -------- */
		case zObjectColorBlack:
			return ((void*) &gColorBlack);
		case zObjectColorDarkGray:
			return ((void*) &gColorDarkGray);
		case zObjectColorGray:
			return ((void*) &gColorGray);
		case zObjectColorLightGray:
			return ((void*) &gColorLightGray);
		case zObjectColorWhite:
			return ((void*) &gColorWhite);
		case zObjectColorRed:
			return ((void*) &gColorRed);
		case zObjectColorGreen:
			return ((void*) &gColorGreen);
		case zObjectColorBlue:
			return ((void*) &gColorBlue);
		case zObjectColorYellow:
			return ((void*) &gColorYellow);
		case zObjectColorCyan:
			return ((void*) &gColorCyan);
		case zObjectColorMagenta:
			return ((void*) &gColorMagenta);
		default:
			break;
	}

	return (NULL);
}


ZError ZClientDllInitGlobals(HINSTANCE hInst, GameInfo gameInfo)
{
	ClientDllGlobals	pGlobals;
	ZError				err = zErrNone;
	int16				i;


	/* Allocate and set the client dll global object. */
	if ((pGlobals = (ClientDllGlobals) ZCalloc(1, sizeof(ClientDllGlobalsType))) == NULL)
		return (zErrOutOfMemory);
	ZSetClientGlobalPointer((void*) pGlobals);

	pGlobals->m_screenWidth = gameInfo->screenWidth;
	pGlobals->m_screenHeight = gameInfo->screenHeight;

	pGlobals->m_gMessageInited = FALSE;
	pGlobals->m_gNetworkEnableMessages = TRUE;

	pGlobals->m_gCustomItemFunc = NULL;

    pGlobals->m_gpCurrentTip = NULL;
    pGlobals->m_gdwTipDisplayMask = 0;
    pGlobals->m_gpTipFinding = NULL;
    pGlobals->m_gpTipStarting = NULL;
    pGlobals->m_gpTipWaiting = NULL;
    pGlobals->m_g_hInstanceLocal = hInst;


	/* Initialize stock fonts. */
	if ((pGlobals->m_gFontSystem12Normal = ZFontNew()) == NULL)
		return (zErrOutOfMemory);
	if ((err = ZFontInit(pGlobals->m_gFontSystem12Normal, zFontSystem, zFontStyleNormal, 12)) != zErrNone)
		return (err);
		
	if ((pGlobals->m_gFontApp9Normal = ZFontNew()) == NULL)
		return (zErrOutOfMemory);
	if ((err = ZFontInit(pGlobals->m_gFontApp9Normal, zFontApplication, zFontStyleNormal, 9)) != zErrNone)
		return (err);
		
	if ((pGlobals->m_gFontApp9Bold = ZFontNew()) == NULL)
		return (zErrOutOfMemory);
	if ((err = ZFontInit(pGlobals->m_gFontApp9Bold, zFontApplication, zFontStyleBold, 9)) != zErrNone)
		return (err);
		
	if ((pGlobals->m_gFontApp12Normal = ZFontNew()) == NULL)
		return (zErrOutOfMemory);
	if ((err = ZFontInit(pGlobals->m_gFontApp12Normal, zFontApplication, zFontStyleNormal, 12)) != zErrNone)
		return (err);
		
	if ((pGlobals->m_gFontApp12Bold = ZFontNew()) == NULL)
		return (zErrOutOfMemory);
	if ((err = ZFontInit(pGlobals->m_gFontApp12Bold, zFontApplication, zFontStyleBold, 12)) != zErrNone)
		return (err);

	GetLocalPath(pGlobals);

	/* Copy the game dll name. */
	lstrcpy(pGlobals->gameDllName, gameInfo->gameDll);

    lstrcpyn(pGlobals->gameID, gameInfo->gameID, zGameIDLen + 1);

	/* mdm 8.18.97  Chat only lobby */
	pGlobals->m_gChatOnly = gameInfo->chatOnly;

	/* Load the game dll. */
	if (LoadGameDll(pGlobals, gameInfo) != zErrNone)
		return (zErrGeneric);

	return (err);
}


void ZClientDllDeleteGlobals(void)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


	if (pGlobals == NULL)
		return;

	/* Delete stock fonts. */
	if (pGlobals->m_gFontSystem12Normal != NULL)
		ZFontDelete(pGlobals->m_gFontSystem12Normal);
	if (pGlobals->m_gFontApp9Normal != NULL)
		ZFontDelete(pGlobals->m_gFontApp9Normal);
	if (pGlobals->m_gFontApp9Bold != NULL)
		ZFontDelete(pGlobals->m_gFontApp9Bold);
	if (pGlobals->m_gFontApp12Normal != NULL)
		ZFontDelete(pGlobals->m_gFontApp12Normal);
	if (pGlobals->m_gFontApp12Bold != NULL)
		ZFontDelete(pGlobals->m_gFontApp12Bold);
	
	UnloadGameDll(pGlobals);

	/* Delete the client dll globals object. */
	ZFree((void*) pGlobals);

	ZSetClientGlobalPointer(NULL);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static void GetLocalPath(ClientDllGlobals pGlobals)
{
	TCHAR		str[MAX_PATH];
	int			i, len;

	
	pGlobals->localPath[0] = _T('\0');

    // PCWTODO: I actually don't know when this is loaded.
    // it better not be NULL, or we will get the wrong name. Probably.
    ASSERT( pGlobals->m_g_hInstanceLocal );
	if (GetModuleFileName(pGlobals->m_g_hInstanceLocal, str, MAX_PATH) > 0)
	{
		/* Search from the back for the first backslash. */
		len = lstrlen(str);
		while (len >= 0)
		{
			if (str[len] == _T('\\'))
			{
				/* Found it. Terminate the string and copy it. */
				str[len] = _T('\0');
				lstrcpy(pGlobals->localPath, str);
				break;
			}
			len--;
		}
    }
}


static ZError LoadGameDll(ClientDllGlobals pGlobals, GameInfo gameInfo)
{
	HINSTANCE		hLib;
	ZError			err = zErrNone;
	TCHAR			oldDir[_MAX_PATH + 1];
	TCHAR			temp[_MAX_PATH + 1];


	/* Get current directory and set our own. */
	GetCurrentDirectory(_MAX_PATH, oldDir);
	lstrcpy(temp, pGlobals->localPath);
	lstrcat(temp, _T("\\"));
	SetCurrentDirectory(temp);

	/* Load the game dll. */
//	hLib = LoadLibrary(ZGenerateDataFileName(NULL, pGlobals->gameDllName));
	hLib = LoadLibrary(pGlobals->gameDllName);
//	ASSERT(hLib != NULL);
	if (hLib == NULL)
	{
		err = (ZError) GetLastError();
		return (err);
	}

	/* Restore current directory. */
	SetCurrentDirectory(oldDir);

	if (hLib)
	{
		pGlobals->gameDll = hLib;

		/* Get the needed game exported routines. */
		pGlobals->pZGameDllInitFunc = (ZGameDllInitFunc) GetProcAddress(hLib,"ZoneGameDllInit");
		ASSERT(pGlobals->pZGameDllInitFunc != NULL);
		pGlobals->pZGameDllDeleteFunc = (ZGameDllDeleteFunc) GetProcAddress(hLib,"ZoneGameDllDelete");
		ASSERT(pGlobals->pZGameDllDeleteFunc != NULL);

		ZClientMain = (ZClientMainFunc) GetProcAddress(hLib,"ZoneClientMain");
		ZClientExit = (ZClientExitFunc) GetProcAddress(hLib,"ZoneClientExit");
		ZClientMessageHandler = (ZClientMessageHandlerFunc) GetProcAddress(hLib,"ZoneClientMessageHandler");
		ZClientName = (ZClientNameFunc) GetProcAddress(hLib,"ZoneClientName");
		ZClientInternalName = (ZClientInternalNameFunc) GetProcAddress(hLib,"ZoneClientInternalName");
		ZClientVersion = (ZClientVersionFunc) GetProcAddress(hLib,"ZoneClientVersion");
		ZCGameNew = (ZCGameNewFunc) GetProcAddress(hLib,"ZoneClientGameNew");
		ZCGameDelete = (ZCGameDeleteFunc) GetProcAddress(hLib,"ZoneClientGameDelete");
		ZCGameProcessMessage = (ZCGameProcessMessageFunc) GetProcAddress(hLib,"ZoneClientGameProcessMessage");
		ZCGameAddKibitzer = (ZCGameAddKibitzerFunc) GetProcAddress(hLib,"ZoneClientGameAddKibitzer");
		ZCGameRemoveKibitzer = (ZCGameRemoveKibitzerFunc) GetProcAddress(hLib,"ZoneClientGameRemoveKibitzer");

		//Make sure we got all the functions successfully loaded
		if ( pGlobals->pZGameDllInitFunc == NULL ||
            pGlobals->pZGameDllDeleteFunc == NULL ||
            ZClientMain == NULL ||
			ZClientExit == NULL ||
			ZClientMessageHandler == NULL ||
			ZClientName == NULL ||
			ZClientInternalName == NULL ||
			ZClientVersion == NULL ||
			ZCGameNew == NULL ||
			ZCGameDelete == NULL ||
			ZCGameProcessMessage == NULL ||
			ZCGameAddKibitzer == NULL ||
			ZCGameRemoveKibitzer == NULL)
		{
			UnloadGameDll( pGlobals );
			return ( zErrLobbyDllInit );
		}


		/* Call the game dll init function to initialize it. */
		//Prefix warning: Verify function pointer before dereferencing
		if((err = (*pGlobals->pZGameDllInitFunc)(hLib, gameInfo)) != zErrNone)
		{
			UnloadGameDll(pGlobals);
		}
	}

	return (err);
}


static void UnloadGameDll(ClientDllGlobals pGlobals)
{
	if (pGlobals->gameDll != NULL)
	{
		if (pGlobals->pZGameDllDeleteFunc != NULL)
			(*pGlobals->pZGameDllDeleteFunc)();
		FreeLibrary(pGlobals->gameDll);
		pGlobals->gameDll = NULL;
	}
		ZClientMain = NULL;
		ZClientExit = NULL;
		ZClientMessageHandler = NULL;
		ZClientName = NULL;
		ZClientInternalName = NULL;
		ZClientVersion = NULL;
		ZCGameNew = NULL;
		ZCGameDelete = NULL;
		ZCGameProcessMessage = NULL;
		ZCGameAddKibitzer = NULL;
		ZCGameRemoveKibitzer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zoffscrn.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZOffscreenPort.cpp
#include "zui.h"
//#define DEBUG_Offscreen 1

class ZOffscreenPortI : public ZGraphicsObjectHeader {
public:
	int32 width;
	int32 height;
};

//////////////////////////////////////////////////////////////////////////
// ZOffscreenPort

ZOffscreenPort ZLIBPUBLIC ZOffscreenPortNew(void)
{
	ZOffscreenPortI* pOffscreenPort = (ZOffscreenPortI*) new ZOffscreenPortI;
	if( pOffscreenPort == NULL )
	{
		//Out of Memory
		return NULL;
	}
	pOffscreenPort->nType = zTypeOffscreenPort;
	pOffscreenPort->hBitmap = NULL;
	return (ZOffscreenPort)pOffscreenPort;
}

ZError ZLIBPUBLIC ZOffscreenPortInit(ZOffscreenPort OffscreenPort,
									ZRect* portRect)
{
	ZOffscreenPortI* pOffscreenPort = (ZOffscreenPortI*)OffscreenPort;
	if( pOffscreenPort == NULL )
	{
		return zErrBadParameter;
	}
	ZRectToWRect(&pOffscreenPort->portRect, portRect);
	pOffscreenPort->width = portRect->right - portRect->left;
	pOffscreenPort->height = portRect->bottom - portRect->top;

	// initialize a bitmap
#ifndef DEBUG_Offscreen
#if 0
	pOffscreenPort->hBitmap = CreateBitmap(
		pOffscreenPort->width, pOffscreenPort->height,1,8,NULL);
#else
	HDC hDC = GetDC(NULL);
	pOffscreenPort->hBitmap = CreateCompatibleBitmap(hDC,
		pOffscreenPort->width, pOffscreenPort->height);
	ReleaseDC(NULL,hDC);
#endif
#else 	
	HDC hDC = CreateCompatibleDC(NULL);
	TCHAR *title = _T("Offscreen");
	DWORD dwStyle = WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_BORDER;
	RECT rect;
	static int cnt = 0;
	rect.left = 0;
	rect.top = 500 + 300 * (cnt);
	cnt++;
	rect.right = 0+pOffscreenPort->width+300;
	rect.bottom = rect.top + 300; //pOffscreenPort->height;

	static TCHAR *pszClassName = NULL;
	if (!pszClassName)
	{
		WNDCLASS wndcls;
		static TCHAR* szClassName = _T("DebugOffscreen");

		if (GetClassInfo(g_hInstanceLocal, szClassName, &wndcls) == FALSE)
		{
			// otherwise we need to register a new class
			wndcls.style = 0;
			wndcls.lpfnWndProc = DefWindowProcU;
			wndcls.cbClsExtra = wndcls.cbWndExtra = 0;
			wndcls.hInstance = g_hInstanceLocal;
			wndcls.hIcon = NULL;
			wndcls.hCursor = NULL;
			wndcls.hbrBackground = NULL;
			wndcls.lpszMenuName = NULL;
			wndcls.lpszClassName = szClassName;
			RegisterClass(&wndcls);
		}
		
		pszClassName = szClassName;
	}

	pOffscreenPort->hWnd = CreateWindow(pszClassName, title,dwStyle,
			rect.left,rect.top,rect.right-rect.left,
			rect.bottom - rect.top, NULL, NULL, g_hInstanceLocal, NULL);
#endif	

	// grafport stuff
	pOffscreenPort->nDrawingCallCount = 0;
	return zErrNone;
}

void   ZLIBPUBLIC ZOffscreenPortDelete(ZOffscreenPort OffscreenPort)
{
	ZOffscreenPortI* pOffscreenPort = (ZOffscreenPortI*)OffscreenPort;

	ASSERT(pOffscreenPort->nDrawingCallCount == 0);

	if (pOffscreenPort->nDrawingCallCount) DeleteDC(pOffscreenPort->hDC);
	if (pOffscreenPort->hBitmap) DeleteObject(pOffscreenPort->hBitmap);

	delete pOffscreenPort;
}

ZOffscreenPort ZOffscreenPortCreateFromResourceManager( WORD resID, COLORREF clrTransparent )
{
    ZOffscreenPort port;
    ZImage tempImage = ZImageCreateFromResourceManager( resID, clrTransparent );

	if ( !tempImage )
	{
        return NULL;
    }
	port = ZConvertImageToOffscreenPort( tempImage );
	if ( !port )
	{
        return NULL;
	}
    return port;
}


ZOffscreenPort ZConvertImageMaskToOffscreenPort(ZImage image)
{
	ZOffscreenPort offscreenPort = ZOffscreenPortNew();
	if( offscreenPort == NULL )
	{
		return NULL;
	}
	ZOffscreenPortI* pOffscreenPort = (ZOffscreenPortI*)offscreenPort;
	ZRect rect;

	/* we will replace the offscreen port bitmap with our image bitmap */
	/* the image will be unusable by the calling program, it is our */
	/* responsibility to delete it from now on */
	rect.left = rect.top = 0;
	rect.right = ZImageGetHeight(image);
	rect.bottom = ZImageGetWidth(image);
	//Prefix Warning: We should make sure this function succeeds
	if( ZOffscreenPortInit(offscreenPort,&rect) != zErrNone )
	{
		//Should we delete the image in the failure case?
		// Probably so that the memory is not leaked since the
		// normal code path deletes the image.
		ZImageDelete(image);
		ZOffscreenPortDelete( offscreenPort );
		return NULL;		
	}
	//Prefix Warning: don't delete handle if NULL
	if( pOffscreenPort->hBitmap != NULL )
	{
		DeleteObject(pOffscreenPort->hBitmap);
	}
	pOffscreenPort->hBitmap = ZImageGetMask(image);

	/* we stold the bitmap of the image, now set it to null in the image */
	/* and delete the image */
	ZImageSetHBitmapImageMask(image,NULL);
	ZImageDelete(image);

	return offscreenPort;
}
ZOffscreenPort ZConvertImageToOffscreenPort(ZImage image)
	/*
		Converts the given image object into an offscreen port object. The given
		image object is deleted and, hence, becomes unusable. The mask data, if any,
		is ignored. The offscreen port portRect is set to (0, 0, width, height),
		where width and height are the image's width and height, respectively.
		
		This routine is useful in converting a large image object into an
		offscreen port object with minimal additonal memory.
		
		Returns NULL if it fails to convert the image and the image is unchanged.
	*/
{
	ZOffscreenPort offscreenPort = ZOffscreenPortNew();
	if( offscreenPort == NULL )
	{
		return NULL;
	}
	ZOffscreenPortI* pOffscreenPort = (ZOffscreenPortI*)offscreenPort;
	ZRect rect;

	/* we will replace the offscreen port bitmap with our image bitmap */
	/* the image will be unusable by the calling program, it is our */
	/* responsibility to delete it from now on */
	rect.left = rect.top = 0;
	rect.right = ZImageGetHeight(image);
	rect.bottom = ZImageGetWidth(image);
	if( ZOffscreenPortInit(offscreenPort,&rect) != zErrNone )
	{
		if( pOffscreenPort->hBitmap != NULL )
		{
			DeleteObject(pOffscreenPort->hBitmap);
		}
		ZOffscreenPortDelete( offscreenPort );
		//Should we delete the image in the failure case?
		// Probably so that the memory is not leaked since the
		// normal code path deletes the image.
		ZImageDelete(image);
		return NULL;
	}
	//Prefix Warning: Don't delete handle if NULL
	if( pOffscreenPort->hBitmap != NULL )
	{
		DeleteObject(pOffscreenPort->hBitmap);
	}
	pOffscreenPort->hBitmap = ZImageGetHBitmapImage(image);

	/* we stold the bitmap of the image, now set it to null in the image */
	/* and delete the image */
	ZImageSetHBitmapImage(image,NULL);
	ZImageDelete(image);

	return offscreenPort;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zpkbytes.h ===
/*******************************************************************************

	ZPkBytes.h
	
		Zone(tm) byte packing module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Thursday, May 11, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		05/11/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZPKBYTES_
#define _ZPKBYTES_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

int16 ZPackBytes(BYTE* dst, BYTE* src, int16 srcLen);
	/*
		Compresses source bytes into RLE-like encoding. The worst case is
		dstLen = (srcLen + (srcLen + 126) / 127). It returns the length of
		the packed bytes. The destination buffer, dst, must be large enough
		to hold the packed bytes.
	*/

int16 ZUnpackBytes(BYTE* dst, BYTE* src, int16 srcLen);
	/*
		Uncompresses the packed bytes from src, previously from ZPackBytes,
		into dst. It returns the length of the total unpacked bytes. The
		destination buffer, dst, must be large enough to hold the unpacked
		bytes.
	*/

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zpkbytes.cpp ===
/*******************************************************************************

	ZPkBytes.c
	
		Zone(tm) byte packing module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Thursday, May 11, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
    1       10/13/96    HI      Fixed compiler warnings.
	0		05/11/95	HI		Created.
	 
*******************************************************************************/


#include "ztypes.h"
#include "zpkbytes.h"


#define zMaxSubLen				127
#define zDupMask				0x80


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

/*
	ZPackBytes()
	
	Compresses source bytes into RLE-like encoding. The worst case is
	dstLen = (srcLen + (srcLen + 126) / 127). It returns the length of
	the packed bytes. The destination buffer, dst, must be large enough
	to hold the packed bytes.
*/
int16 ZPackBytes(BYTE* dst, BYTE* src, int16 srcLen)
{
	int16			subLen, dupCount, diff;
	BYTE*			lastPos;
	BYTE			curByte, dupByte;
	BYTE*			origDst;
	
	
	origDst = dst;
	
	lastPos = src;
	subLen = 1;
	curByte = *src++;
	srcLen--;
	dupCount = 1;
	dupByte = curByte;
	while (--srcLen >= 0)
	{
		curByte = *src++;
		
		if (curByte == dupByte)
		{
			dupCount++;
			subLen++;
			
			if (dupCount >= 3 && subLen > dupCount)
			{
				subLen -= dupCount;
				*dst++ = (BYTE) subLen;
				while (--subLen >= 0)
					*dst++ = *lastPos++;
				subLen = dupCount;
			}
			else if (dupCount > zMaxSubLen)
			{
				*dst++ = (BYTE) (((BYTE) zMaxSubLen) | zDupMask);
				*dst++ = dupByte;

				dupCount = 1;
				subLen = 1;
				lastPos = src - 1;
			}
		}
		else
		{
			if (dupCount >= 3)
			{
				*dst++ = ((BYTE) dupCount) | zDupMask;
				*dst++ = dupByte;
				
				lastPos = src - 1;
				dupByte = curByte;
				dupCount = 1;
				subLen = 1;
			}
			else
			{
				if (subLen >= zMaxSubLen)
				{
					*dst++ = zMaxSubLen;
					diff = subLen - zMaxSubLen;
					subLen = zMaxSubLen;
					while (--subLen >= 0)
						*dst++ = *lastPos++;
					subLen = diff;
					lastPos = src - subLen - 1;
				}

				dupByte = curByte;
				subLen++;
				dupCount = 1;
			}
		}
	}
	if (dupCount >= 3)
	{
		*dst++ = ((BYTE) dupCount) | zDupMask;
		*dst++ = dupByte;
	}
	else
	{
		*dst++ = (BYTE) subLen;
		while (--subLen >= 0)
			*dst++ = *lastPos++;
	}
	
	return ((int16) (dst - origDst));
}


/*
	ZUnpackBytes()
	
	Uncompresses the packed bytes from src, previously from ZPackBytes,
	into dst. It returns the length of the total unpacked bytes. The
	destination buffer, dst, must be large enough to hold the unpacked
	bytes.
*/
int16 ZUnpackBytes(BYTE* dst, BYTE* src, int16 srcLen)
{
	BYTE*			origDst;
	int16			subLen;
	BYTE			curByte, dupByte;
	
	
	origDst = dst;
	
	while (--srcLen >= 0)
	{
		curByte = *src++;
		
		if (curByte & zDupMask)
		{
			subLen = (uchar) curByte & ~zDupMask;
			dupByte = *src++;
			srcLen--;
			while (--subLen >= 0)
				*dst++ = dupByte;
		}
		else
		{
			subLen = curByte;
			while (--subLen >= 0)
				*dst++ = *src++;
			srcLen -= curByte;
		}
	}
	
	return ((int16) (dst - origDst));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zpict.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZInfo.cpp

#include "zui.h"

class ZPictButtonI {
public:
	ZWindow window; // the window containing the picButton

	// stored data
	ZImage normalButtonImage;
	ZImage selectedButtonImage;
	void* userData;
	ZPictButtonFunc pictButtonFunc;

	uint16 selected; // determines which image to draw
	ZRect boundsRect; // rectangle bounding drawn image
};

ZBool MyPictButtonWindowProc(ZWindow window, ZMessage *message);

ZPictButton ZLIBPUBLIC ZPictButtonNew(void)
{
	ZPictButtonI* pButton = new ZPictButtonI;
	if( pButton == NULL )
	{
		//Out of memory
		return NULL;
	}
	pButton->selected = FALSE;
	return (ZButton)pButton;
}


ZError ZLIBPUBLIC ZPictButtonInit(ZPictButton pictButton, ZWindow parentWindow,
		ZRect* pictButtonRect, ZImage normalButtonImage, ZImage selectedButtonImage,
		ZBool visible, ZBool enabled, ZPictButtonFunc pictButtonFunc, void* userData)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	//Prefix Warning: Make sure pButton is valid before dereferencing
	if( pButton == NULL )
	{
		return zErrOutOfMemory;
	}

	pButton->window = ZWindowNew();
	/* hard code type for now... make sure we get a window without boarder... the type */
	/* plain has changed to a boarder :( */
	ZError err = ZWindowInit(pButton->window,pictButtonRect,0x4000/*zWindowPlainType*/,
					parentWindow,NULL,visible,FALSE,FALSE,MyPictButtonWindowProc,
					zWantAllMessages, pButton);
	if (err != zErrNone) return err;

	// calc bounds rectangle...
	pButton->boundsRect.left = 0;
	pButton->boundsRect.right = pictButtonRect->right - pictButtonRect->left;
	pButton->boundsRect.top = 0;
	pButton->boundsRect.bottom = pictButtonRect->bottom - pictButtonRect->top;

	pButton->userData = userData;
	pButton->normalButtonImage = normalButtonImage;
	pButton->selectedButtonImage = selectedButtonImage;
	pButton->pictButtonFunc = pictButtonFunc;

	return zErrNone;
}

void ZLIBPUBLIC ZPictButtonDelete(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;

	if (pButton->window) ZWindowDelete(pButton->window);
	delete pButton;
}
void ZLIBPUBLIC ZPictButtonGetRect(ZPictButton pictButton, ZRect* pictButtonRect)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	ZWindowGetRect(pButton,pictButtonRect);
}
ZError ZLIBPUBLIC ZPictButtonSetRect(ZPictButton pictButton, ZRect* pictButtonRect)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowSetRect(pButton->window,pictButtonRect);
}
ZError ZLIBPUBLIC ZPictButtonMove(ZPictButton pictButton, int16 left, int16 top)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowMove(pButton->window,left,top);
}
ZError ZLIBPUBLIC ZPictButtonSize(ZPictButton pictButton, int16 width, int16 height)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowSize(pButton->window,width,height);
}
ZBool ZLIBPUBLIC ZPictButtonIsVisible(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowIsVisible(pButton->window);
}
ZError ZLIBPUBLIC ZPictButtonShow(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowShow(pButton->window);
}
ZError ZLIBPUBLIC ZPictButtonHide(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowHide(pButton->window);
}
ZBool ZLIBPUBLIC ZPictButtonIsEnabled(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowIsEnabled(pButton->window);
}
ZError ZLIBPUBLIC ZPictButtonEnable(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowEnable(pButton->window);
}
ZError ZLIBPUBLIC ZPictButtonDisable(ZPictButton pictButton)
{
	ZPictButtonI* pButton = (ZPictButtonI*) pictButton;
	return ZWindowDisable(pButton->window);
}


ZBool MyPictButtonWindowProc(ZWindow window, ZMessage *message)
{
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
		{
			ZPictButtonI* pButton = (ZPictButtonI*)message->userData;
			ASSERT( pButton != NULL );
			if( pButton != NULL )
			{
				ZImage image;
				ZBeginDrawing(window);
				if (pButton->selected) {
					image = pButton->selectedButtonImage;
				} else {
					image = pButton->normalButtonImage;
				}
				// this does not scale the image, we would have to use ZCopyImage for this
				ZImageDraw(image,window,&pButton->boundsRect,NULL, zDrawCopy);

				ZEndDrawing(window);
				
				msgHandled = TRUE;
				break;				
			}
		}
		case zMessageWindowButtonUp:
		{
			ZPictButtonI* pButton = (ZPictButtonI*)message->userData;

			// if we are in the selected state
			if (pButton != NULL && pButton->selected) 
			{
				// call the clicked proc, if mouse still over button
				// are we inside the image?
				ZPoint point = message->where;
				if (ZImagePointInside(pButton->normalButtonImage,&point)) 
				{
					pButton->pictButtonFunc(pButton,pButton->userData);
				}
				// release mouse capture
				ZWindowClearMouseCapture(pButton->window);
				pButton->selected = FALSE;
				ZWindowDraw(pButton->window,NULL);
			} 
			msgHandled = TRUE;
			break;
		}
		case zMessageWindowButtonDown:
		{
			ZPictButtonI* pButton = (ZPictButtonI*)message->userData;

			// are we inside the image?
			ZPoint point = message->where;
			if (ZImagePointInside(pButton->normalButtonImage,&point)) {

				// need to capture so we can get the button up message
				ZWindowSetMouseCapture(pButton->window);

				// change button state
				pButton->selected = TRUE;
				ZWindowDraw(pButton->window,NULL);
			}

			msgHandled = TRUE;
			break;
		}
		case zMessageWindowButtonDoubleClick:
		case zMessageWindowClose:
			break;
	}
	
	return (msgHandled);
}
ZPictButtonFunc ZLIBPUBLIC ZPictButtonGetFunc(ZPictButton pictButton)
{
	ZPictButtonI* pPictButton = (ZPictButtonI*)pictButton;

	return pPictButton->pictButtonFunc;
}	
	
void ZLIBPUBLIC ZPictButtonSetFunc(ZPictButton pictButton, ZPictButtonFunc pictButtonFunc)
{
	ZPictButtonI* pPictButton = (ZPictButtonI*)pictButton;

	pPictButton->pictButtonFunc = pictButtonFunc;
}	

void* ZLIBPUBLIC ZPictButtonGetUserData(ZPictButton pictButton)
{
	ZPictButtonI* pPictButton = (ZPictButtonI*)pictButton;

	return pPictButton->userData;
}	
	
void ZLIBPUBLIC ZPictButtonSetUserData(ZPictButton pictButton, void* userData)
{
	ZPictButtonI* pPictButton = (ZPictButtonI*)pictButton;

	pPictButton->userData = userData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zoptions.cpp ===
/*******************************************************************************

	ZOptions.c
	
		Zone(tm) options button module.
	
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Sunday, May 12, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		05/12/96	HI		Created.
	 
*******************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zone.h"
#include "zonemem.h"


/*
#define Z(n)							((ZOptionsButton) (n))
#define I(n)							((IButton) (n))

#define zOptionsFileName				"zoptions.zrs"


enum
{
	zResOptionsImageUp = 0,
	zResOptionsImageDown
};


typedef struct
{
	ZPictButton			button;
	ZImage				upImage;
	ZImage				downImage;
	ZOptionsButtonFunc	buttonFunc;
	void*				userData;
} IButtonType, *IButton;


// -------- Globals -------- 

// -------- Internal Routines -------- 
static ZBool GetImages(ZImage* upImage, ZImage* downImage);
static void ButtonFunc(ZPictButton pictButton, void* userData);
*/

/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

ZOptionsButton ZOptionsButtonNew(void)
{
    /*
	IButton			options;
	
	
	if ((options = (IButton) ZMalloc(sizeof(IButtonType))) != NULL)
	{
		options->upImage = NULL;
		options->downImage = NULL;
		options->button = NULL;
		options->buttonFunc = NULL;
		options->userData = NULL;
	}
	
	return (Z(options));
    */
    return NULL;
}


ZError ZOptionsButtonInit(ZOptionsButton optionsButton, ZWindow parentWindow,
		ZRect* buttonRect, ZOptionsButtonFunc optionsButtonFunc, void* userData)
{
    /*
	ZError			err = zErrNone;
	IButton			this = I(optionsButton);
	
	
	if (this != NULL)
	{
		if (GetImages(&this->upImage, &this->downImage))
		{
			this->button = ZPictButtonNew();
			ZPictButtonInit(this->button, parentWindow, buttonRect, this->upImage,
					this->downImage, TRUE, TRUE, ButtonFunc, this);
			
			this->buttonFunc = optionsButtonFunc;
			this->userData = userData;
		}
		else
		{
			err = zErrOutOfMemory;
			ZAlert(GetErrStr(zErrOutOfMemory), NULL);
		}
	}
	
	return (err);
    */
    return zErrNotImplemented;
}


void ZOptionsButtonDelete(ZOptionsButton optionsButton)
{              
    /*
	IButton			this = I(optionsButton);
	
	
	if (this != NULL)
	{
		if (this->button != NULL)
			ZPictButtonDelete(this->button);
		if (this->upImage != NULL)
			ZImageDelete(this->upImage);
		if (this->downImage != NULL)
			ZImageDelete(this->downImage);
		ZFree(this);
	}
    */
}



/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/

/*
static ZBool GetImages(ZImage* upImage, ZImage* downImage)
{
	ZBool				gotThem = FALSE;
	ZResource			resFile;


	if ((resFile = ZResourceNew()) != NULL)
	{
		if (ZResourceInit(resFile, ZGetCommonDataFileName(zOptionsFileName)) == zErrNone)
		{
			*upImage = ZResourceGetImage(resFile, zResOptionsImageUp);
			*downImage = ZResourceGetImage(resFile, zResOptionsImageDown);
			
			if (*upImage != NULL && *downImage != NULL)
			{
				gotThem = TRUE;
			}
			else
			{
				if (*upImage != NULL)
					ZImageDelete(*upImage);
				if (*downImage != NULL)
					ZImageDelete(*downImage);
				gotThem = FALSE;
			}
		}
		ZResourceDelete(resFile);
	}
	
	return (gotThem);
}


static void ButtonFunc(ZPictButton pictButton, void* userData)
{
	IButton		this = I(userData);
	
	
	if (this->buttonFunc != NULL)
		this->buttonFunc(Z(userData), this->userData);
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zprefs.cpp ===
/*******************************************************************************

	ZPrefs.c
	
		Preference File operation routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Sunday, December 24, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
    1       10/13/96    HI      Fixed compiler warnings.
	0		12/24/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>

#include "zone.h"
#include "zprefs.h"


/* -------- Internal Routines -------- */


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

ZBool ZPreferenceFileExists(void)
{
    FILE*				fd = NULL;
    ZBool				exists = FALSE;


	/* Open file. */
	if ((fd = fopen(ZGetProgramDataFileName(zPreferenceFileName), "rb")) != NULL)
	{
		exists = TRUE;
		fclose(fd);
	}

	return (exists);
}


/*
	Endianing is not performed because a pref file is created on the running
	machine only. It cannot be copied to another platform.
*/
ZVersion ZPreferenceFileVersion(void)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	ZVersion			version = 0;


	/* Open file. */
	if ((fd = fopen(ZGetProgramDataFileName(zPreferenceFileName), "rb")) != NULL)
	{
		/* Read file header. */
		if (fread(&header, 1, sizeof(header), fd) == sizeof(header))
			version = header.version;
		
		fclose(fd);
	}

	return (version);
}


int32 ZPreferenceFileRead(void* prefPtr, int32 len)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	ZVersion			version = 0;
	int32				bytesRead = -1;


	/* Open file. */
	if ((fd = fopen(ZGetProgramDataFileName(zPreferenceFileName), "rb")) != NULL)
	{
		/* Read file header. */
		if (fread(&header, 1, sizeof(header), fd) == sizeof(header))
		{
			if (len > (int32) header.fileDataSize)
				len = header.fileDataSize;
			bytesRead = fread(prefPtr, len, 1, fd);
		}
		
		fclose(fd);
	}

	return (bytesRead);
}


int32 ZPreferenceFileWrite(ZVersion version, void* prefPtr, int32 len)
{
    FILE*				fd = NULL;
	ZFileHeader			header;
	int32				bytesWritten = -1;


	/* Open file. */
	if ((fd = fopen(ZGetProgramDataFileName(zPreferenceFileName), "w")) != NULL)
	{
		/* Set new file data size. */
		header.signature = 0;
		header.version = version;
		header.fileDataSize = len;
		fwrite(&header, 1, sizeof(header), fd);
		
		/* Write the new pref data out. */
		bytesWritten = fwrite(prefPtr, len, 1, fd);
		
		fclose(fd);
	}

	return (bytesWritten);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zprompt.cpp ===
/*******************************************************************************

	ZPrompt.c
	
		Zone(tm) simple dialog prompting module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Tuesday, July 12, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	3		01/02/97	HI		Create windows hidden and then show to bring
								windows to front.
	2		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
    1       10/13/96    HI      Fixed compiler warnings.
	0		07/12/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>

#include "zonecli.h"
#include "zoneresource.h"


#define zMinWidth			240
#define zMinHeight			80

#define zButtonWidth		70
#define zButtonHeight		20
// PCWTODO: Strings!
#define zYesButtonTitle		_T("Yes")
#define zNoButtonTitle		_T("No")
#define zCancelButtonTitle	_T("Cancel")

#define zMargin				10


enum
{
	zPromptCallFunc = 1024
};


typedef struct
{
	ZWindow					promptWindow;
	ZButton					yesButton;
	ZButton					noButton;
	ZButton					cancelButton;
	ZEditText				promptText;
	ZPromptResponseFunc		responseFunc;
	void*					userData;
} PromptType, *Prompt;


/* -------- Globals -------- */


/* -------- Internal Routines -------- */
static ZBool PromptWindowFunc(ZWindow window, ZMessage* message);
static void PromptButtonFunc(ZButton button, void* userData);
static ZBool PromptMessageFunc(void *p, ZMessage* message);


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

/*
	Displays a modal dialog box with the given prompt. If there is no
	parent window, then set parentWindow to NULL. The dialog box will
	be centered within the parent window.
	
	The buttons parameter indicates which of the Yes, No, and Cancel
	button will be available to the user.
	
	Once the user selects one of the buttons, the response function
	is called with the selected button. Before the resonse function is
	called, the dialog box is hidden from the user.
*/
ZError ZPrompt(TCHAR* prompt, ZRect* rect, ZWindow parentWindow, ZBool autoPosition,
		int16 buttons, TCHAR* yesButtonTitle, TCHAR* noButtonTitle,
		TCHAR* cancelButtonTitle, ZPromptResponseFunc responseFunc, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZError			err = zErrNone;
	ZRect			tempRect, rect2;
	Prompt			pThis;
	TCHAR*			title;
	
	
	pThis = (Prompt)ZMalloc(sizeof(PromptType));
	if (pThis != NULL)
	{
		/* Check for minimum rectangle size. */
		tempRect = *rect;
		if (ZRectWidth(&tempRect) < zMinWidth)
			tempRect.right = tempRect.left + zMinWidth;
		if (ZRectHeight(&tempRect) < zMinHeight)
			tempRect.bottom = tempRect.top + zMinHeight;
		
		/* Create window. */
		pThis->promptWindow = ZWindowNew();
		if (pThis->promptWindow == NULL)
			goto OutOfMemoryExit;
		if ( (err = ZWindowInit(pThis->promptWindow, &tempRect, zWindowDialogType, parentWindow,
				ZClientName(), FALSE, FALSE, autoPosition, PromptWindowFunc, zWantAllMessages,
				pThis)) != zErrNone)
			goto Exit;
		
		ZRectOffset(&tempRect, (int16) -tempRect.left, (int16) -tempRect.top);
		
		/* Create edit text item. */
		pThis->promptText = ZEditTextNew();
		if (pThis->promptText == NULL)
			goto OutOfMemoryExit;
		rect2 = tempRect;
		ZRectInset(&rect2, zMargin, zMargin);
		rect2.bottom -= zMargin + zButtonHeight;
		if ((err = ZEditTextInit(pThis->promptText, pThis->promptWindow, &rect2, prompt,
				(ZFont) ZGetStockObject(zObjectFontSystem12Normal), FALSE,
				TRUE, TRUE, FALSE, NULL, NULL)) != zErrNone)
			goto Exit;
		
		pThis->yesButton = NULL;
		pThis->noButton = NULL;
		pThis->cancelButton = NULL;
		
		/* Initialize the first button rectangle. */
		rect2 = tempRect;
		ZRectInset(&rect2, zMargin, zMargin);
		rect2.left = rect2.right - zButtonWidth;
		rect2.top = rect2.bottom - zButtonHeight;
		
		/* Create the Cancel button. */
		if (buttons & zPromptCancel)
		{
			if (cancelButtonTitle != NULL)
				title = cancelButtonTitle;
			else
				title = zCancelButtonTitle;
			pThis->cancelButton = ZButtonNew();
			if (pThis->cancelButton == NULL)
				goto OutOfMemoryExit;
			if ((err = ZButtonInit(pThis->cancelButton, pThis->promptWindow, &rect2,
					title, TRUE, TRUE, PromptButtonFunc, pThis)) != zErrNone)
				goto Exit;
			ZRectOffset(&rect2, -(zButtonWidth + zMargin), 0);
		}
		
		/* Create the No button. */
		if (buttons & zPromptNo)
		{
			if (noButtonTitle != NULL)
				title = noButtonTitle;
			else
				title = zNoButtonTitle;
			pThis->noButton = ZButtonNew();
			if (pThis->noButton == NULL)
				goto OutOfMemoryExit;
			if ((err = ZButtonInit(pThis->noButton, pThis->promptWindow, &rect2, title,
					TRUE, TRUE, PromptButtonFunc, pThis)) != zErrNone)
				goto Exit;
			ZRectOffset(&rect2, -(zButtonWidth + zMargin), 0);
		}
		
		/* Create the Yes button. */
		if (buttons == 0 || (buttons & zPromptYes))
		{
			if (yesButtonTitle != NULL)
				title = yesButtonTitle;
			else
				title = zYesButtonTitle;
			pThis->yesButton = ZButtonNew();
			if (pThis->yesButton == NULL)
				goto OutOfMemoryExit;
			if ((err = ZButtonInit(pThis->yesButton, pThis->promptWindow, &rect2, title,
					TRUE, TRUE, PromptButtonFunc, pThis)) != zErrNone)
				goto Exit;
		}
		
		pThis->responseFunc = responseFunc;
		pThis->userData = userData;

		ZWindowBringToFront(pThis->promptWindow);
		
		/* Make the window modal. */
		ZWindowModal(pThis->promptWindow);
		
		goto Exit;
	}

OutOfMemoryExit:
    // PCWTODO: Strings
    ZShellGameShell()->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
	err = zErrOutOfMemory;
	
Exit:
	
	return (err);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/

static ZBool PromptWindowFunc(ZWindow window, ZMessage* message)
{
	Prompt		pThis = (Prompt) message->userData;
	ZBool		msgHandled;
	
	
	msgHandled = FALSE;
	
	switch (message->messageType) 
	{
		case zMessageWindowDraw:
			ZBeginDrawing(window);
			ZRectErase(window, &message->drawRect);
			ZEndDrawing(window);
			msgHandled = TRUE;
			break;
		case zMessageWindowClose:
			/*
				Delete all graphical objects but NOT the prompt object itself.
			*/
			if (pThis->yesButton != NULL)
				ZButtonDelete(pThis->yesButton);
			if (pThis->noButton != NULL)
				ZButtonDelete(pThis->noButton);
			if (pThis->cancelButton != NULL)
				ZButtonDelete(pThis->cancelButton);
			if (pThis->promptText != NULL)
				ZEditTextDelete(pThis->promptText);
			ZWindowDelete(pThis->promptWindow);
			msgHandled = TRUE;
			break;
	}
	
	return (msgHandled);
}


static void PromptButtonFunc(ZButton button, void* userData)
{
	Prompt			pThis = (Prompt) userData;
	int16			value;
	
	
	if (button == pThis->noButton)
		value = zPromptNo;
	else if (button == pThis->cancelButton)
		value = zPromptCancel;
	else
		value = zPromptYes;

	/* Hide the window and send a close window message. */
	ZWindowNonModal(pThis->promptWindow);
	ZWindowHide(pThis->promptWindow);
	ZPostMessage(pThis->promptWindow, PromptWindowFunc, zMessageWindowClose, NULL, NULL,
			0, NULL, 0, pThis);
	
	/* Post message to call the response function. */
	ZPostMessage(pThis, PromptMessageFunc, zPromptCallFunc, NULL, NULL,
			value, NULL, 0, NULL);
#if 0
	/* Call the response function. */
	pThis->responseFunc(value, pThis->userData);
#endif
}


static ZBool PromptMessageFunc(void *p, ZMessage* message)
{

    Prompt prompt = (Prompt)p;
	ZBool			msgHandled = FALSE;
	
	
	if (message->messageType == zPromptCallFunc)
	{
		/* Call the response function. */
		prompt->responseFunc((int16) message->message, prompt->userData);
		
		/* Dispose of the prompt object. */
		ZFree(prompt);
		
		msgHandled = TRUE;
	}
	
	return (msgHandled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zprefs.h ===
/*******************************************************************************

	ZPrefs.h
	
		Zone(tm) preference file module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Sunday, December 24, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		12/24/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZPREFS_
#define _ZPREFS_


#define zPreferenceFileName				"zprefs"


#ifdef __cplusplus
extern "C" {
#endif

/* -------- Exported Routines -------- */
ZBool ZPreferenceFileExists(void);
ZVersion ZPreferenceFileVersion(void);
int32 ZPreferenceFileRead(void* prefPtr, int32 len);
int32 ZPreferenceFileWrite(ZVersion version, void* prefPtr, int32 len);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zradio.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZRadio.cpp

#include "zui.h"
#include "zonecli.h"

class ZRadioI : public ZObjectHeader {
public:
	ZRadioFunc checkBoxFunc;
	HWND hWnd;
	void *userData;
	WNDPROC defaultWndProc;
};

////////////////////////////////////////////////////////////////////////
// ZRadio

ZRadio ZLIBPUBLIC ZRadioNew(void)
{
	ZRadioI* pRadio = new ZRadioI;
	pRadio->nType = zTypeRadio;
	return (ZRadio)pRadio;
}

LRESULT CALLBACK MyRadioWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
        // PCWTODO: Need to call convert message?
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE) {
			SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}
	} // switch
	default:
		break;
	}
	ZRadioI* pRadio = (ZRadioI*)MyGetProp32(hWnd,_T("pWindow"));

	return CallWindowProc((ZONECLICALLWNDPROC)pRadio->defaultWndProc,hWnd,msg,wParam,lParam);
}

ZError ZLIBPUBLIC ZRadioInit(ZRadio checkBox, ZWindow parentWindow,
		ZRect* checkBoxRect, TCHAR* title, ZBool checked, ZBool visible, ZBool enabled,
		ZRadioFunc checkBoxProc, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	pRadio->checkBoxFunc = checkBoxProc;
	pRadio->userData = userData;			


	{
		DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_TABSTOP;
		if (visible) dwStyle |= WS_VISIBLE;
		if (!enabled) dwStyle |= WS_DISABLED;
		dwStyle |=  BS_RADIOBUTTON;
		pRadio->hWnd = CreateWindow(_T("BUTTON"),title,dwStyle,
			checkBoxRect->left,checkBoxRect->top,checkBoxRect->right-checkBoxRect->left,
			checkBoxRect->bottom - checkBoxRect->top, 
			ZWindowWinGetWnd(parentWindow), (HMENU)ZWindowWinGetNextControlID(parentWindow),
			g_hInstanceLocal, pRadio);

		if (!pRadio->hWnd) return zErrWindowSystemGeneric;
	 	// checkBoxs can't use the extra data, they will use the set prop feature
		MySetProp32(pRadio->hWnd,_T("pWindow"),(void*)pRadio);

		pRadio->defaultWndProc = (WNDPROC)SetWindowLong(pRadio->hWnd,GWL_WNDPROC,(LONG)MyRadioWndProc);

		// set the check if required
		if (checked) {
			ZRadioSelect(checkBox);
		}
	}
	return zErrNone;
}

void    ZLIBPUBLIC ZRadioDelete(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	if (pRadio->hWnd) {
		SetWindowLong(pRadio->hWnd,GWL_WNDPROC,(LONG)pRadio->defaultWndProc);
		MyRemoveProp32(pRadio->hWnd,_T("pWindow"));
		DestroyWindow(pRadio->hWnd);
	}
	delete pRadio;
}

void    ZLIBPUBLIC ZRadioGetRect(ZRadio checkBox, ZRect *checkBoxRect)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	RECT rect;
	GetClientRect(pRadio->hWnd,&rect);
	WRectToZRect(checkBoxRect,&rect);
}

ZError  ZLIBPUBLIC ZRadioSetRect(ZRadio checkBox, ZRect *checkBoxRect)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	BOOL bOk = SetWindowPos(pRadio->hWnd, NULL,checkBoxRect->left,
		checkBoxRect->top, checkBoxRect->right - checkBoxRect->left,
		checkBoxRect->bottom - checkBoxRect->top,
		SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZRadioMove(ZRadio checkBox, int16 left, int16 top)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	BOOL bOk = SetWindowPos(pRadio->hWnd, NULL,left,top,
		0,0,SWP_NOSIZE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZRadioSize(ZRadio checkBox, int16 width, int16 height)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;

	BOOL bOk = SetWindowPos(pRadio->hWnd, NULL,0,0,
		width,height,SWP_NOMOVE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZBool ZLIBPUBLIC ZRadioIsVisible(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	return IsWindowVisible(pRadio->hWnd);
}

ZError  ZLIBPUBLIC ZRadioShow(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	ShowWindow(pRadio->hWnd, SW_SHOWNORMAL);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZRadioHide(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	ShowWindow(pRadio->hWnd, SW_HIDE);
	return zErrNone;
}

ZBool ZLIBPUBLIC ZRadioIsEnabled(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	return IsWindowEnabled(pRadio->hWnd);
}

ZError  ZLIBPUBLIC ZRadioEnable(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	EnableWindow(pRadio->hWnd, TRUE);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZRadioDisable(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	EnableWindow(pRadio->hWnd, FALSE);
	return zErrNone;
}

void    ZLIBPUBLIC ZRadioGetTitle(ZRadio checkBox, TCHAR* title, uint16 len)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	GetWindowText(pRadio->hWnd, title,len);
}

ZError  ZLIBPUBLIC ZRadioSetTitle(ZRadio checkBox, TCHAR* title)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	SetWindowText(pRadio->hWnd,title);
	return zErrNone;
}

LRESULT ZRadioDispatchProc(ZRadio checkBox, WORD wNotifyCode)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	ZBool state;

	switch (wNotifyCode) {
	case BN_CLICKED:
		state = !(SendMessage(pRadio->hWnd, BM_GETCHECK,0,0));
		SendMessage(pRadio->hWnd, BM_SETCHECK, state, 0);
		pRadio->checkBoxFunc(pRadio, state, pRadio->userData);
	}
	return 0L;
}

ZBool ZRadioIsSelected(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	ZBool rval = (ZBool)SendMessage(pRadio->hWnd, BM_GETCHECK, 0, 0);

	return rval;
}

ZError ZRadioSelect(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	SendMessage(pRadio->hWnd, BM_SETCHECK, 1, 0);
	return zErrNone;
}

ZError ZRadioUnSelect(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;
	SendMessage(pRadio->hWnd, BM_SETCHECK, 0, 0);
	return zErrNone;
}

ZRadioFunc ZLIBPUBLIC ZRadioGetFunc(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;

	return pRadio->checkBoxFunc;
}	
	
void ZLIBPUBLIC ZRadioSetFunc(ZRadio checkBox, ZRadioFunc checkBoxFunc)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;

	pRadio->checkBoxFunc = checkBoxFunc;
}	

void* ZLIBPUBLIC ZRadioGetUserData(ZRadio checkBox)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;

	return pRadio->userData;
}	
	
void ZLIBPUBLIC ZRadioSetUserData(ZRadio checkBox, void* userData)
{
	ZRadioI* pRadio = (ZRadioI*)checkBox;

	pRadio->userData = userData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zrollover.cpp ===
/*******************************************************************************

	ZRolloverButton.c
	
		Zone(tm) Rollover button module.

	Copyright (c) Microsoft Corp. 1996. All rights reserved.
	Written by Hoon Im
	Created on Monday, July 22, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	5		11/09/96	HI		Don't draw in TrackCursor() unless the state
								changed.
    4       10/13/96    HI      Fixed compiler warnings.
	3		09/05/96	HI		Modified ZRolloverButtonSetRect() to reregister
								the object with the parent window when the
								object is moved. Due to lack of ZWindowMoveObject()
								API, moved objects are not recognized by the parent
								window.
	2		08/16/96	HI		Couple of bug fixes.
	1		08/12/96	HI		Added button down feedback.
	0		07/22/96	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#include "zone.h"
#include "zrollover.h"
#include "zonemem.h"
#include "zui.h"



#define I(object)				((IRollover) (object))
#define Z(object)				((ZRolloverButton) (object))

#define zButtonFlashDelay		20


enum
{
	zWasNowhere = 0,
	zWasInside,
	zWasOutside
};


struct RolloverStateInfo
{
    ZImage image;
    DWORD dwFontIndex;
    HFONT hFont;
    ZRect rcTextBounds;
    COLORREF clrFont;
};

typedef struct
{
	ZWindow window;
	ZRect bounds;
	ZRolloverButtonDrawFunc drawFunc;
	ZRolloverButtonFunc func;
	void* userData;

	ZBool visible;
	ZBool enabled;
	int16 state;
	ZBool clicked;
	int16 wasInside;
    LPTSTR pszText;
    ZImage maskImage;

    // multi-state font info
    IZoneMultiStateFont *m_pFont;

    RolloverStateInfo stateInfo[zNumStates];
} IRolloverType, *IRollover;


/* -------- Internal Routines -------- */
static ZBool RolloverMessageFunc(ZRolloverButton rollover, ZMessage* message);
static void RolloverDraw(IRollover rollover, int16 state);
static void HandleButtonDown(IRollover rollover, ZPoint* where);
static void HandleButtonUp(IRollover rollover, ZPoint* where);
static BOOL TrackCursor(IRollover rollover, ZPoint* where);
static void FontRectToBoundRect( ZRect *bound, RECT *pFontRect );
static ZBool ZPointInsideRollover(IRollover rollover, ZPoint* point);

static const WCHAR *STATE_NAMES[zNumStates] = 
{
    L"Idle",
    L"Hilited",
    L"Selected",
    L"Disabled"
};


// this is whichever button is currently down.
static IRollover g_pTracker;

/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

ZRolloverButton ZRolloverButtonNew(void)
{
	IRollover			rollover;
	
	
	if ((rollover = (IRollover) ZCalloc(sizeof(IRolloverType), 1)) != NULL)
	{
        ZeroMemory( rollover, sizeof(IRolloverType) );
	}
	
	return (rollover);
}


ZError ZRolloverButtonInit(ZRolloverButton rollover, ZWindow window, ZRect* bounds, ZBool visible,
		ZBool enabled, ZImage idleImage, ZImage hiliteImage, ZImage selectedImage,
		ZImage disabledImage, ZRolloverButtonDrawFunc drawFunc, ZRolloverButtonFunc rolloverFunc, void* userData)
{
    ASSERT( !"Call ZRolloverButtonInit2 -- it's spiffier" );
    return zErrNotImplemented;
}


ZError ZRolloverButtonInit2(ZRolloverButton rollover, ZWindow window, ZRect *bounds, 
                            ZBool visible, ZBool enabled,
                            ZImage idleImage, ZImage hiliteImage, ZImage selectedImage, 
                            ZImage disabledImage, ZImage maskImage,
                            LPCTSTR pszText,
                            ZRolloverButtonDrawFunc drawFunc,
                            ZRolloverButtonFunc rolloverFunc,
                            void *userData )
{
	IRollover pThis = I(rollover);
    ZRolloverButtonSetText( rollover, pszText );

    pThis->window = window;
    pThis->bounds = *bounds;
    pThis->visible = visible;
    pThis->enabled = enabled;
    pThis->stateInfo[zRolloverStateIdle].image = idleImage;
    pThis->stateInfo[zRolloverStateHilited].image = hiliteImage;
    pThis->stateInfo[zRolloverStateSelected].image = selectedImage;
    pThis->stateInfo[zRolloverStateDisabled].image = disabledImage;
    pThis->drawFunc = drawFunc;
    pThis->func = rolloverFunc;
    pThis->userData = userData;
    pThis->maskImage = maskImage;

	pThis->state = zRolloverStateIdle;
	pThis->clicked = FALSE;
	pThis->wasInside = zWasNowhere;
    
    ZRolloverButtonSetMultiStateFont( rollover, NULL );

    ZWindowAddObject(window, pThis, bounds, RolloverMessageFunc, pThis);
    return zErrNone;
}


void ZRolloverButtonDelete(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);
	
	 
	if (pThis != NULL)
	{
		ZWindowRemoveObject(pThis->window, pThis);
		
        ZRolloverButtonSetMultiStateFont( rollover, NULL );

        if ( pThis->pszText )
        {
            ZFree( pThis->pszText );
            pThis->pszText = NULL;
        }

		ZFree(pThis);
	}
}


void ZRolloverButtonGetText( ZRolloverButton rollover, LPTSTR pszText, int cchBuf )
{
    IRollover pThis = I(rollover);
    if ( ( pThis != NULL ) && pThis->pszText )
    {
        lstrcpyn( pszText, pThis->pszText, cchBuf );
    }
    else
    {
    	//Prefix Warning:  Changing
    	//         lstrcpyn( pszText, _T('\0'), cchBuf );
		//  to
        lstrcpyn( pszText, _T("\0"), cchBuf );
    	// The old version has single quotes, meaning the value of '\0' is 0.  That was cast to 
    	// a LPCWSTR and passed into lstrcpyn.  Double quotes mean a constant string who's value
    	// is "\0" is being passed into lstrcpyn.
    }
}


void ZRolloverButtonSetText( ZRolloverButton rollover, LPCTSTR pszNewText )
{
    IRollover pThis = I(rollover);
    if ( pThis != NULL ) 
    {
        if ( pThis->pszText )
        {
            ZFree( pThis->pszText );
            pThis->pszText = NULL;
        }
        if ( pszNewText )
        {
            pThis->pszText = (TCHAR *) ZMalloc( (lstrlen( pszNewText )+1)*sizeof(TCHAR) );
            lstrcpy( pThis->pszText, pszNewText );
        }
    }
}


void ZRolloverButtonSetRect(ZRolloverButton rollover, ZRect* rect)
{
	IRollover			pThis = I(rollover);


	if (pThis->visible)
	{
		ZRolloverButtonHide(rollover, FALSE);
		pThis->bounds = *rect;
		ZRolloverButtonShow(rollover);
	}
	else
	{
		pThis->bounds = *rect;
	}

	ZWindowMoveObject(pThis->window, pThis, &pThis->bounds);
}


void ZRolloverButtonGetRect(ZRolloverButton rollover, ZRect* rect)
{
	IRollover			pThis = I(rollover);


	*rect = pThis->bounds;
}


void ZRolloverButtonDraw(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);

	ASSERT( rollover != NULL );
	if (pThis->visible)
	{
		if (pThis->enabled)
		{
			RolloverDraw(pThis, pThis->state);
		}
		else
		{
			RolloverDraw(pThis, zRolloverStateDisabled);
		}
	}
}


ZBool ZRolloverButtonIsEnabled(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);


	return (pThis->enabled);
}


void ZRolloverButtonEnable(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);


	if (pThis->enabled == FALSE)
	{
		pThis->enabled = TRUE;
		pThis->state = zRolloverStateIdle;
		pThis->wasInside = zWasNowhere;
		ZRolloverButtonDraw(rollover);
	}
}


void ZRolloverButtonDisable(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);


	if (pThis->enabled)
	{
		pThis->enabled = FALSE;
		pThis->state = zRolloverStateDisabled;
		pThis->clicked = FALSE;
		ZRolloverButtonDraw(rollover);
	}
}


ZBool ZRolloverButtonIsVisible(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);


	return (pThis->visible);
}


void ZRolloverButtonShow(ZRolloverButton rollover)
{
	IRollover			pThis = I(rollover);


	pThis->visible = TRUE;
	pThis->wasInside = zWasNowhere;
	ZRolloverButtonDraw(rollover);
	ASSERT(pThis->window != NULL );
	ZWindowValidate(pThis->window, &pThis->bounds);
}


void ZRolloverButtonHide(ZRolloverButton rollover, ZBool immediate)
{
	IRollover pThis = I(rollover);

	pThis->visible = FALSE;
	pThis->state = zRolloverStateIdle;
	pThis->clicked = FALSE;

	if (immediate)
		ZRolloverButtonDraw(rollover);
	else
		ZWindowInvalidate(pThis->window, &pThis->bounds);
}


ZBool ZRolloverButtonSetMultiStateFont( ZRolloverButton rollover, IZoneMultiStateFont *pFont )
{
	IRollover pThis = I(rollover);

    if ( pThis->m_pFont )
    {
        pThis->m_pFont->Release();
        pThis->m_pFont = NULL;
        for ( DWORD i=0; i < zNumStates; i++ )
        {
            pThis->stateInfo[i].dwFontIndex = 0xFFFFFFFF;
            pThis->stateInfo[i].hFont = NULL;
        }
    }
    if ( pFont )
    {
        DWORD dwFontIndex;
        RECT rect;
        // fill the font state into with this information so we no longer have to call it again
        for ( DWORD i=0; i < zNumStates; i++ )
        {
            if ( FAILED( pFont->FindState( STATE_NAMES[i], &pThis->stateInfo[i].dwFontIndex ) ) )
            {
                return FALSE;
            }
            dwFontIndex = pThis->stateInfo[i].dwFontIndex;
            pFont->GetHFont( dwFontIndex, &pThis->stateInfo[i].hFont );
            pFont->GetColor( dwFontIndex, &pThis->stateInfo[i].clrFont );
            // make sure this is a PALETTERGB
            pThis->stateInfo[i].clrFont |= 0x02000000;

            pFont->GetRect( dwFontIndex, &rect );
            pThis->stateInfo[i].rcTextBounds = pThis->bounds;
            FontRectToBoundRect( &pThis->stateInfo[i].rcTextBounds, &rect );
        }
        pThis->m_pFont = pFont;
        pThis->m_pFont->AddRef();
    }
    return TRUE;
}


/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/

ZBool RolloverMessageFunc(ZRolloverButton rollover, ZMessage* message)
{
	IRollover		pThis = I(message->userData);
	ZBool			messageHandled = FALSE;
	

	if (pThis->visible == FALSE)
		return (FALSE);

	if (pThis->enabled == FALSE && message->messageType != zMessageWindowDraw)
		return (FALSE);
	
	switch (message->messageType)
	{
		case zMessageWindowMouseMove:
			TrackCursor(pThis, &message->where);
			break;
		case zMessageWindowButtonDown:
			HandleButtonDown(pThis, &message->where);
			messageHandled = TRUE;
			break;
		case zMessageWindowButtonUp:
			HandleButtonUp(pThis, &message->where);
			messageHandled = TRUE;
			break;
		case zMessageWindowDraw:
			ZRolloverButtonDraw(Z(pThis));
			messageHandled = TRUE;
			break;
		case zMessageWindowObjectTakeFocus:
			messageHandled = TRUE;
			break;
		case zMessageWindowObjectLostFocus:
			messageHandled = TRUE;
			break;
		case zMessageWindowButtonDoubleClick:
		case zMessageWindowChar:
		case zMessageWindowActivate:
		case zMessageWindowDeactivate:
			break;
	}
	
	return (messageHandled);
}


static void RolloverDraw(IRollover rollover, int16 state)
{
	ZRect			oldClip;
	ZImage			image;
	
	
	if (rollover != NULL)
	{
		ZBeginDrawing(rollover->window);
		
		ZGetClipRect(rollover->window, &oldClip);
		ZSetClipRect(rollover->window, &rollover->bounds);

		if (rollover->visible)
		{
            RolloverStateInfo *pState = &rollover->stateInfo[state];

		    if ( ( rollover->drawFunc == NULL ) ||
			     !rollover->drawFunc(Z(rollover), rollover->window, state, &rollover->bounds, rollover->userData) )
            {

			    if ( pState->image != NULL)
                {
				    ZImageDraw( pState->image, rollover->window, &rollover->bounds, rollover->maskImage, zDrawCopy);
                }
            }

            if ( rollover->pszText )
            {
                if ( rollover->m_pFont )
                {
                    HDC hdc;
                    HGDIOBJ hFontOld;
                    COLORREF colorOld;

                    hdc = ZGrafPortGetWinDC( rollover->window );

                    hFontOld = SelectObject( hdc, pState->hFont );
                    colorOld = SetTextColor( hdc, pState->clrFont );

                    ZDrawText( rollover->window, &pState->rcTextBounds, zTextJustifyCenter, rollover->pszText );

                    // unselect our stuff
                    SelectObject( hdc, hFontOld );
                    SetTextColor( hdc, colorOld );
                }
                else
                {
                    ZDrawText( rollover->window, &rollover->bounds, zTextJustifyCenter, rollover->pszText );
                }
            }
		}

		ZSetClipRect(rollover->window, &oldClip);
		
		ZEndDrawing(rollover->window);
	}
}


static void HandleButtonDown(IRollover rollover, ZPoint* where)
{
	if ( ZPointInsideRollover( rollover, where ) )
	{
		// Show the button down state before calling the button func.
		RolloverDraw(rollover, zRolloverStateSelected);
		ZDelay(zButtonFlashDelay);

		// Call button func.
		if (rollover->func != NULL)
		{
			rollover->func(Z(rollover), zRolloverButtonDown, rollover->userData);
			rollover->clicked = TRUE;
			rollover->state = zRolloverStateSelected;
            ZWindowTrackCursor(rollover->window, RolloverMessageFunc, rollover);
            g_pTracker = rollover;
		}
		else
		{
			rollover->clicked = FALSE;
			rollover->state = zRolloverStateIdle;
		}
	}
	else
	{
		rollover->clicked = FALSE;
		rollover->state = zRolloverStateIdle;
	}
	ZRolloverButtonDraw(Z(rollover));
}


static void HandleButtonUp(IRollover rollover, ZPoint* where)
{
    int16 oldState = rollover->state;
    g_pTracker = NULL;

    if ( ZPointInsideRollover( rollover, where ) )
    {
        if ( rollover->func )
        {
            rollover->func( Z(rollover), zRolloverButtonUp, rollover->userData );
        }

        rollover->state = zRolloverStateIdle;
        if ( rollover->clicked )
        {
            if ( rollover->func )
            {
                rollover->func( Z(rollover), zRolloverButtonClicked, rollover->userData );
            }
        }
		// This should be done before calling the button callback as inside the callback button state
		// might change which again gets overridden by Idle state. 
        //rollover->state = zRolloverStateIdle;
        rollover->clicked = FALSE;
    }
    else
    {
        rollover->clicked = FALSE;
        rollover->state = zRolloverStateIdle;
    }

    if ( oldState != rollover->state )
    {
		RolloverDraw( rollover, rollover->state );
    }
}


static BOOL TrackCursor(IRollover rollover, ZPoint* where)
{
	int16 oldState = rollover->state;
    BOOL fRet;

	if ( fRet = ZPointInsideRollover( rollover, where ) )
	{
		if (rollover->wasInside == zWasOutside)
        {
			if (rollover->func)
            {
				rollover->func(Z(rollover), zRolloverButtonMovedIn, rollover->userData);
            }
            // there are three states we could be in right now:
            // One, if the user clicked in us and currently has the mouse down,
            // then we are selected. If the user hasn't clicked us, but
            // HAS clicked another button, we are idle.
            // Otherwise, they are just rolling over us and we should be hilited.
            if ( rollover->clicked )
            {
                rollover->state = zRolloverStateSelected;   
            }
            else if ( g_pTracker )
            {
                rollover->state = zRolloverStateIdle;
            }
            else
            {
                rollover->state = zRolloverStateHilited;
            }
        }
		rollover->wasInside = zWasInside;
	}
	else
	{
		if (rollover->wasInside == zWasInside)
        {
			if (rollover->func)
            {
				rollover->func(Z(rollover), zRolloverButtonMovedOut, rollover->userData);
            }
            // keep us hot even after we move outside the button
            rollover->state = rollover->clicked ? zRolloverStateHilited : zRolloverStateIdle;
        }
		rollover->wasInside = zWasOutside;
	}

	if (oldState != rollover->state)
    {
		RolloverDraw(rollover, rollover->state);
    }
    return fRet;
}


static void FontRectToBoundRect( ZRect *bound, RECT *pRect )
{
    bound->left += int16(pRect->left);
    bound->right += int16(pRect->right);
    bound->top += int16(pRect->top);
    bound->bottom += int16(pRect->bottom);
}

// Barna 092999
// This is to enable transparent rollover buttons in checkers and reversi to respond 
// when clicked in the blank ares inside the button.
static ZBool ZPointInsideRollover(IRollover rollover, ZPoint* point)
	/*
		Returns TRUE if the given point is inside the image. If the image has a mask,
		then it checks whether the point is inside the mask. If the image does not have
		a mask, then it simply checks the image bounds.
	*/
{
    return ZPointInRect( point, &rollover->bounds );
}
// Barna 092999
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zsound.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZSound.cpp

#include "zui.h"
#include <mmsystem.h>

class ZSoundI
{
public:
	ZObjectType nType;
	TCHAR FileName[MAX_PATH + 1];
};

////////////////////////////////////////////////////////////////////////
// ZSound

ZSound ZLIBPUBLIC ZSoundNew(void)
{
	ZSoundI* pSound = new ZSoundI;
	if ( pSound )
	{
		pSound->nType = zTypeSound;
		pSound->FileName[0] = _T('\0');
	}
	return (ZSound) pSound;
}


ZError ZLIBPUBLIC ZSoundInit(ZSound sound, ZSoundDescriptor* pSD)
{
	ZSoundI* pSound = (ZSoundI*) sound;

	if ( !pSound || !pSD )
		return zErrBadParameter;

	pSound->FileName[0] = _T('\0');
	return zErrNone;
}


ZError ZLIBPUBLIC ZSoundInitFileName(ZSound sound, TCHAR* FileName)
{
	ZSoundI* pSound = (ZSoundI*) sound;

	if ( !pSound || !FileName )
		return zErrBadParameter;

	lstrcpyn( pSound->FileName, FileName, MAX_PATH );
	pSound->FileName[ MAX_PATH ] = _T('\0');
	return zErrNone;
}


void ZLIBPUBLIC ZSoundDelete(ZSound sound)
{
	ZSoundI* pSound = (ZSoundI*) sound;
	if (pSound)
		delete pSound;
}


ZError ZLIBPUBLIC ZSoundStart(ZSound sound, ZBool loop)
{
	DWORD flags;
	ZSoundI* pSound = (ZSoundI*) sound;

	if ( !pSound || pSound->FileName[0] == _T('\0'))
		return zErrBadParameter;
	
	flags = SND_ASYNC | SND_NODEFAULT;
	if ( loop )
		flags |= SND_LOOP;
	PlaySound( pSound->FileName, NULL, flags );
	return zErrNone;
}


ZError ZLIBPUBLIC ZSoundStop(ZSound sound)
{
	ZSoundI* pSound = (ZSoundI*) sound;

	if ( !pSound || pSound->FileName[0] == _T('\0'))
		return zErrBadParameter;
	
	PlaySound( NULL, NULL, SND_PURGE );
	return zErrNone;
}


ZError ZLIBPUBLIC ZSoundStopAll()
{
	PlaySound( NULL, NULL, SND_PURGE );
	return zErrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zscroll.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZScroll.cpp

#include "zui.h"
#include "zonecli.h"

class ZScrollBarI : public ZObjectHeader {
public:
	ZScrollBarFunc scrollBarFunc;
	int16 singleIncrement;
	int16 pageIncrement;
	int16 value;
	int16 minValue;
	int16 maxValue;

	HWND hWnd;
	void* userData;
	WNDPROC defaultWndProc;
};

////////////////////////////////////////////////////////////////////////
// ZScrollBar
ZScrollBar ZLIBPUBLIC ZScrollBarNew(void)
{
	ZScrollBarI* pScrollBar = new ZScrollBarI;
	pScrollBar->nType = zTypeScrollBar;
	pScrollBar->hWnd = NULL;
	pScrollBar->singleIncrement = 1;
	pScrollBar->pageIncrement = 1;
	return (ZScrollBar) pScrollBar;
}

LRESULT CALLBACK MyScrollBarWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
        // PCWTODO: Need to call convert message?
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE) {
			SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}
	}
	default:
		break;
	}
	ZScrollBarI* pScrollBar = (ZScrollBarI*)MyGetProp32(hWnd,_T("pScrollBar"));

	return CallWindowProc((ZONECLICALLWNDPROC)pScrollBar->defaultWndProc,hWnd,msg,wParam,lParam);
}

ZError ZLIBPUBLIC ZScrollBarInit(ZScrollBar scrollBar, ZWindow parentWindow, 
		ZRect* scrollBarRect, int16 value, int16 minValue, int16 maxValue,
		int16 singleIncrement, int16 pageIncrement,
		ZBool visible, ZBool enabled,	ZScrollBarFunc scrollBarProc,
		void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	pScrollBar->scrollBarFunc = scrollBarProc;
	pScrollBar->userData = userData;

	{
		SCROLLINFO scrollInfo;
		DWORD dwStyle = WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
		if (visible) dwStyle |= WS_VISIBLE;
		if (!enabled) dwStyle |= WS_DISABLED;

		// what type of scrollbar to draw?
		int16 width = scrollBarRect->right - scrollBarRect->left;
		int16 height = scrollBarRect->bottom - scrollBarRect->top;

		if (width > height ) {
			dwStyle |=  SBS_HORZ;
		} else {
			dwStyle |=  SBS_VERT;
		}
		pScrollBar->hWnd = CreateWindow(_T("SCROLLBAR"),_T("ASCROLLBAR"),dwStyle,
			scrollBarRect->left,scrollBarRect->top,scrollBarRect->right-scrollBarRect->left,
			scrollBarRect->bottom - scrollBarRect->top,
			ZWindowWinGetWnd(parentWindow), (HMENU)ZWindowWinGetNextControlID(parentWindow),
			g_hInstanceLocal, pScrollBar);

	 	// scrollbars can't use the extra data, they will use the set prop feature
		if (!pScrollBar->hWnd) return zErrWindowSystemGeneric;
		MySetProp32(pScrollBar->hWnd,_T("pScrollBar"),(void*)pScrollBar);

		pScrollBar->defaultWndProc = (WNDPROC)SetWindowLong(pScrollBar->hWnd,GWL_WNDPROC,(LONG)MyScrollBarWndProc);

		pScrollBar->singleIncrement = singleIncrement;
		pScrollBar->pageIncrement = pageIncrement;
		pScrollBar->maxValue = maxValue;
		pScrollBar->minValue = minValue;
		pScrollBar->value = value;

		scrollInfo.cbSize		= sizeof(scrollInfo);
		scrollInfo.fMask		= SIF_ALL | SIF_DISABLENOSCROLL;
		scrollInfo.nMin			= pScrollBar->minValue;
		scrollInfo.nMax			= pScrollBar->maxValue;
		scrollInfo.nPage		= 1;
		scrollInfo.nPos			= pScrollBar->value;
		SetScrollInfo(pScrollBar->hWnd, SB_CTL, &scrollInfo, TRUE);
/*
		SetScrollRange(pScrollBar->hWnd,SB_CTL,minValue,maxValue,FALSE);
		SetScrollPos(pScrollBar->hWnd,SB_CTL,value,TRUE);
*/
	}
	return zErrNone;
}

void    ZLIBPUBLIC ZScrollBarDelete(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	if (pScrollBar->hWnd) {
		SetWindowLong(pScrollBar->hWnd,GWL_WNDPROC,(LONG)pScrollBar->defaultWndProc);
		MyRemoveProp32(pScrollBar->hWnd,_T("pScrollBar"));
		DestroyWindow(pScrollBar->hWnd);
	}
	delete pScrollBar;
}

void    ZLIBPUBLIC ZScrollBarGetRect(ZScrollBar scrollBar, ZRect *scrollBarRect)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	RECT rect;
	GetClientRect(pScrollBar->hWnd,&rect);
	WRectToZRect(scrollBarRect,&rect);
}

ZError  ZLIBPUBLIC ZScrollBarSetRect(ZScrollBar scrollBar, ZRect *scrollBarRect)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	BOOL bOk = SetWindowPos(pScrollBar->hWnd, NULL,scrollBarRect->left,
		scrollBarRect->top, scrollBarRect->right - scrollBarRect->left,
		scrollBarRect->bottom - scrollBarRect->top,
		SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZScrollBarMove(ZScrollBar scrollBar, int16 left, int16 top)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	BOOL bOk = SetWindowPos(pScrollBar->hWnd, NULL,left,top,
		0,0,SWP_NOSIZE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZError  ZLIBPUBLIC ZScrollBarSize(ZScrollBar scrollBar, int16 width, int16 height)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	BOOL bOk = SetWindowPos(pScrollBar->hWnd, NULL,0,0,
		width,height,SWP_NOMOVE|SWP_NOZORDER);
	return bOk ? zErrNone : zErrWindowSystemGeneric;
}

ZBool ZLIBPUBLIC ZScrollBarIsVisible(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	return IsWindowVisible(pScrollBar->hWnd);
}

ZError  ZLIBPUBLIC ZScrollBarShow(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	ShowWindow(pScrollBar->hWnd, SW_SHOWNORMAL);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZScrollBarHide(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	ShowWindow(pScrollBar->hWnd, SW_HIDE);
	return zErrNone;
}

ZBool ZLIBPUBLIC ZScrollBarIsEnabled(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	return IsWindowEnabled(pScrollBar->hWnd);
}

ZError  ZLIBPUBLIC ZScrollBarEnable(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	EnableWindow(pScrollBar->hWnd, TRUE);
	return zErrNone;
}

ZError  ZLIBPUBLIC ZScrollBarDisable(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	EnableWindow(pScrollBar->hWnd, FALSE);
	return zErrNone;
}

int16   ZLIBPUBLIC ZScrollBarGetValue(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	return (int16)pScrollBar->value;
}

ZError  ZLIBPUBLIC ZScrollBarSetValue(ZScrollBar scrollBar, int16 value)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	SCROLLINFO scrollInfo;


	pScrollBar->value = value;
	scrollInfo.cbSize	= sizeof(scrollInfo);
	scrollInfo.fMask	= SIF_POS;
	scrollInfo.nPos		= pScrollBar->value;
	SetScrollInfo(pScrollBar->hWnd, SB_CTL, &scrollInfo, TRUE);
/*
	if (!SetScrollPos(pScrollBar->hWnd,SB_CTL,pScrollBar->value,TRUE)) {
		return zErrWindowSystemGeneric;
	}
*/

	return zErrNone;
}

void ZLIBPUBLIC ZScrollBarGetRange(ZScrollBar scrollBar, int16* minValue, int16* maxValue)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	*minValue = (int16)pScrollBar->minValue;
	*maxValue = (int16)pScrollBar->maxValue;
}

ZError  ZLIBPUBLIC ZScrollBarSetRange(ZScrollBar scrollBar, int16 minValue, int16 maxValue)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	SCROLLINFO scrollInfo;


	if (maxValue < minValue)
		maxValue = minValue;

	pScrollBar->minValue = minValue;
	pScrollBar->maxValue = maxValue;

	scrollInfo.cbSize	= sizeof(scrollInfo);
	scrollInfo.fMask	= SIF_RANGE | SIF_POS | SIF_DISABLENOSCROLL;
	scrollInfo.nPos		= pScrollBar->value;
	scrollInfo.nMin		= pScrollBar->minValue;
	scrollInfo.nMax		= pScrollBar->maxValue;
	SetScrollInfo(pScrollBar->hWnd, SB_CTL, &scrollInfo, TRUE);

/*
	SetScrollRange(pScrollBar->hWnd,SB_CTL,minValue, maxValue,FALSE);
	SetScrollPos(pScrollBar->hWnd,SB_CTL,pScrollBar->value,TRUE);
*/

	return zErrNone;
}

LRESULT ZScrollBarDispatchProc(ZScrollBar scrollBar, WORD wNotifyCode, short nPos)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	int16 value;

	switch (wNotifyCode) {
	case SB_BOTTOM:
		value = pScrollBar->maxValue;
		break;
	case SB_LINEDOWN:
		value = min(pScrollBar->value+pScrollBar->singleIncrement, pScrollBar->maxValue);
		break;
	case SB_LINEUP:
		value = max(pScrollBar->value-pScrollBar->singleIncrement, pScrollBar->minValue);
		break;
	case SB_PAGEDOWN:
		value = min(pScrollBar->value+pScrollBar->pageIncrement, pScrollBar->maxValue);
		break;
	case SB_PAGEUP:
		value = max(pScrollBar->value-pScrollBar->pageIncrement, pScrollBar->minValue);
		break;
	case SB_TOP:
		value = pScrollBar->minValue;
		break;
	case SB_THUMBPOSITION:
	case SB_THUMBTRACK:
		value = (int16)nPos;
		break;
	case SB_ENDSCROLL:
	default:
		// lets ignore this one
		return 0;
		break;
	}

	// if the position did not change, do nothing
	if (value == pScrollBar->value)
		return 0;

	// enable/disable arrows on scrollbar as appropriate
#ifdef WIN32
	SendMessage(pScrollBar->hWnd,SBM_ENABLE_ARROWS,ESB_ENABLE_BOTH,0L);
	if (value == pScrollBar->maxValue) {
		SendMessage(pScrollBar->hWnd,SBM_ENABLE_ARROWS,ESB_DISABLE_RTDN,0L);
	} else if (value == pScrollBar->minValue) {
		SendMessage(pScrollBar->hWnd,SBM_ENABLE_ARROWS,ESB_DISABLE_LTUP,0L);
	}
#endif  // feature available in win32 only

	// reset the scroll position, send message to client application
	ZScrollBarSetValue(pScrollBar,value);

	pScrollBar->scrollBarFunc(pScrollBar,pScrollBar->value,pScrollBar->userData);
	return 0L;
}


ZScrollBarFunc ZLIBPUBLIC ZScrollBarGetFunc(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;

	return pScrollBar->scrollBarFunc;
}	
	
void ZLIBPUBLIC ZScrollBarSetFunc(ZScrollBar scrollBar, ZScrollBarFunc scrollBarFunc)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;

	pScrollBar->scrollBarFunc = scrollBarFunc;
}	

void* ZLIBPUBLIC ZScrollBarGetUserData(ZScrollBar scrollBar)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;

	return pScrollBar->userData;
}	
	
void ZLIBPUBLIC ZScrollBarSetUserData(ZScrollBar scrollBar, void* userData)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;

	pScrollBar->userData = userData;
}

void ZScrollBarGetIncrements(ZScrollBar scrollBar, int16* singleInc, int16* pageInc)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;

	*singleInc = pScrollBar->singleIncrement;
	*pageInc = pScrollBar->pageIncrement;
}

ZError ZScrollBarSetIncrements(ZScrollBar scrollBar, int16 singleInc, int16 pageInc)
{
	ZScrollBarI* pScrollBar = (ZScrollBarI*)scrollBar;
	SCROLLINFO scrollInfo;

	pScrollBar->pageIncrement = pageInc;
	pScrollBar->singleIncrement = singleInc;

	scrollInfo.cbSize	= sizeof(scrollInfo);
	scrollInfo.fMask	= SIF_PAGE;
	scrollInfo.nPage	= 1;
	SetScrollInfo(pScrollBar->hWnd, SB_CTL, &scrollInfo, FALSE);

	return zErrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zsystem.cpp ===
#include <windows.h>
#include <direct.h>
#include <stdio.h>
#include <stdlib.h>

#include "ZoneUtil.h"

#include "zoneocx.h"
#include "zoneint.h"
#include "zonecli.h"
#include "lobbymsg.h"
#include "zservcon.h"
#include "zoneresource.h"
#include "keyname.h"

#define EXPORTME __declspec(dllexport)

#ifdef ZONECLI_DLL 

#define gIdleTimer					(pGlobals->m_gIdleTimer)
#define gptCursorLast				(pGlobals->m_gptCursorLast)
#define gnMsgLast					(pGlobals->m_gnMsgLast)
#define gClientDisabled             (pGlobals->m_gClientDisabled)
#define gGameShell                  (pGlobals->m_gGameShell)

#define g_hWndNotify                (pGlobals->m_g_hWndNotify)

#else

// global used for palette.  need to delete it...
//HPALETTE gPal = NULL;

HINSTANCE g_hInstanceLocal = NULL;

ZTimer gIdleTimer;
POINT gptCursorLast;
UINT gnMsgLast;
BOOL gClientDisabled = FALSE;

HWND g_hWndNotify = NULL;

#endif

#ifndef WIN32
BOOL MySetProp32(HWND hwnd, LPCSTR lpsz, void* data)
{
	char sz[80];
	wsprintf(sz,"%s1",lpsz);
	if (!SetProp(hwnd,sz,LOWORD(data))) return FALSE;
	wsprintf(sz,"%s2",lpsz);
	if (!SetProp(hwnd,sz,HIWORD(data))) return FALSE;
	return TRUE;
}

void* MyRemoveProp32(HWND hwnd, LPCSTR lpsz)
{
	char sz[80];
	WORD lw,hw;

	wsprintf(sz,"%s1",lpsz);
	lw = RemoveProp(hwnd,sz);
	if (!lw) return NULL;
	wsprintf(sz,"%s2",lpsz);
	hw = RemoveProp(hwnd,sz);
	if (!hw) return NULL;
	return (void*)MAKELONG(lw,hw);
}

void* MyGetProp32(HWND hwnd, LPCSTR lpsz)
{
	char sz[80];
	WORD lw,hw;

	wsprintf(sz,"%s1",lpsz);
	lw = GetProp(hwnd,sz);
	wsprintf(sz,"%s2",lpsz);
	hw = GetProp(hwnd,sz);
	return (void*)MAKELONG(lw,hw);
}
#endif

void ZPrintf(TCHAR *format, ...)
{
	TCHAR szTemp[256];
	wvsprintf(szTemp,format,  (va_list)&format+1);
	OutputDebugString(szTemp);
}

BOOL IsIdleMessage(MSG* pMsg);

// simulate idle message to all windows
void IdleTimerFunc(ZTimer timer, void* userData)
{
	ZWindowIdle();
}


int EXPORTME UserMainInit(HINSTANCE hInstance,HWND OCXWindow, IGameShell *piGameShell, GameInfo gameInfo) 
{
	ZError				err = zErrNone;
	ClientDllGlobals	pGlobals;

    // need this in ZClientDllInitGlobals

	if ((err = ZClientDllInitGlobals(hInstance, gameInfo)) != zErrNone)
	{
		if (err == zErrOutOfMemory)
			piGameShell->ZoneAlert(ErrorTextOutOfMemory, NULL, NULL, false, true);
		return FALSE;
	}

	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	OCXHandle = OCXWindow;
	gClientDisabled = FALSE;
    gGameShell = piGameShell;

	// init our global palette 
    // PCWPAL
    //gPal = piGameShell->GetZoneShell()->GetPalette();
	//gPal = ZColorTableCreateWinPalette();

/*
    if (!ZNetworkInitApplication()) {
        return FALSE;
    }

    if (ZSConnectionLibraryInitClientOnly()) {
        return FALSE;
	}

    DWORD tid;
    g_hThread = CreateThread( NULL, 4096, NetWaitProc, NULL, 0, &tid );
*/
	if (!ZTimerInitApplication()) {
		return FALSE;
	}

	if (ZWindowInitApplication() != zErrNone) {
		return FALSE;
	}

	if (!ZInfoInitApplication())
		return FALSE;
	
	// initialize the common code
	if (zErrNone != ZCommonLibInit()) {
		return FALSE;
	}

    if (ZClientMain(gameInfo->gameCommandLine, piGameShell) != zErrNone) {
            return (FALSE);
    }

	gIdleTimer = ZTimerNew();
	ZTimerInit(gIdleTimer,20,IdleTimerFunc, NULL);

	return (TRUE);
}

int UserMainRun(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* result)
{
	int handled = FALSE;
	
	
	*result = 0;
    
	if (msg == WM_QUERYENDSESSION)
	{
		// Check if we need to prompt the user before exiting.
		if (!ZCRoomPromptExit())
		{
			*result = TRUE;
		}
			handled = TRUE;
	}
	else
	{
		handled = ZOCXGraphicsWindowProc(hWnd, msg, wParam, lParam, result);
	}
	
	return (handled);
}

int UserMainStop()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return 0;

	if (g_hInstanceLocal)
	{
        ZTimerDelete(gIdleTimer);

        ZClientExit();
        
        ZCommonLibExit();
		ZInfoTermApplication();
		ZWindowTermApplication();
        ZTimerTermApplication();

		g_hInstanceLocal = NULL;
	}

	ZClientDllDeleteGlobals();

	return(0);
}

BOOL IsIdleMessage(MSG* pMsg)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return FALSE;

	// Return FALSE if the message just dispatched should _not_
	// cause OnIdle to be run.  Messages which do not usually
	// affect the state of the user interface and happen very
	// often are checked for.

	// redundant WM_MOUSEMOVE and WM_NCMOUSEMOVE
	if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE)
	{
		// mouse move at same position as last mouse move?
		if (gptCursorLast.x == pMsg->pt.x &&
			gptCursorLast.y == pMsg->pt.y && pMsg->message == gnMsgLast)
			return FALSE;

		gptCursorLast = pMsg->pt;  // remember for next time
		gnMsgLast = pMsg->message;
		return TRUE;
	}

	// WM_PAINT and WM_SYSTIMER (caret blink)
	return pMsg->message != WM_PAINT && pMsg->message != 0x0118;
}

// the exit funtions to perform windows specific cleanup and exit
void ZExit()
{
	//Instead of quitting, we now just set a boolean variable to indicate
	// to the OCX that it shouldn't shut down, just stop processing messages...

	//PostQuitMessage(0);

    // not supported in millennium
    ASSERT(FALSE);
/*
	#ifdef ZONECLI_DLL
		ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	#endif


	if (!pGlobals)
		return;

	ZClientExit();

    gClientDisabled = TRUE;

	PostMessageA( OCXHandle, LM_EXIT, 0, 0 );
*/
}

BOOL EXPORTME UserMainDisabled()
{
	#ifdef ZONECLI_DLL
		ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	#endif

	if (!pGlobals)
		return TRUE;

	return gClientDisabled;
}


void ZLaunchHelp( DWORD helpID )
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


//	PostMessageA( OCXHandle, LM_LAUNCH_HELP, (WPARAM) helpID, 0 );
    gGameShell->ZoneLaunchHelp();
}


void ZEnableAdControl( DWORD setting )
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


	PostMessageA( OCXHandle, LM_ENABLE_AD_CONTROL, (WPARAM) setting, 0 );
}


void ZPromptOnExit( BOOL bPrompt )
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


	PostMessageA( OCXHandle, LM_PROMPT_ON_EXIT, (WPARAM) bPrompt, 0 );
}

void ZSetCustomMenu( LPSTR szText )
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


	PostMessageA( OCXHandle, LM_SET_CUSTOM_ITEM, (WPARAM) 0, (LPARAM) szText );
}


/*
	Called with a user name. A buffer is allocated for the user name. The name
	is copied and the pointer is passed into PostMessage. Since we don't know
	the lifespan of the username pointer passed, it is safer for us to allocate
	out own copy since we are posting a message instead of sending it straight.

	NOTE: This message's handler must free up the name buffer. This is bad in
	that one components allocates and another frees the memory buffer.
*/
void ZSendZoneMessage( LPSTR szUserName )
{
    /* 
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	LPSTR name;

	
	if ( szUserName == NULL || szUserName[0] == '\0' )
		return;

	name = (LPSTR) ZMalloc( lstrlen( szUserName ) + 1 );
	if ( name )
	{
		lstrcpy( name, szUserName );
		PostMessage( OCXHandle, LM_SEND_ZONE_MESSAGE, (WPARAM) 0, (LPARAM) name );
	}
    */
}


/*
	Called with a user name. A buffer is allocated for the user name. The name
	is copied and the pointer is passed into PostMessage. Since we don't know
	the lifespan of the username pointer passed, it is safer for us to allocate
	out own copy since we are posting a message instead of sending it straight.

	NOTE: This message's handler must free up the name buffer. This is bad in
	that one components allocates and another frees the memory buffer.
*/
void ZViewProfile( LPSTR szUserName )
{
    /*
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	LPSTR name;


	if ( szUserName == NULL || szUserName[0] == '\0' )
		return;

	name = (LPSTR) ZMalloc( lstrlen( szUserName ) + 1 );
	if ( name )
	{
		lstrcpy( name, szUserName );
		PostMessage( OCXHandle, LM_VIEW_PROFILE, (WPARAM) 0, (LPARAM) name );
	}
    */
}


//////////////////////////////////////////////////////////////
// Alerts

void ZLIBPUBLIC ZAlert(TCHAR* szText, ZWindow window)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	// for now, guess the window with the focus,
//	HWND hWnd;


	if (!pGlobals)
		return;
/*
	if (window) {
		hWnd = ZWindowWinGetWnd(window);
	} else  {
		hWnd = NULL;
	}

	{
		// around message box, make sure network traffic is off
//        ZNetworkEnableMessages(FALSE);

		// preserve the window with the focus
		HWND focusWnd = GetFocus();

//		MessageBeep(MB_OK);
        MessageBox(hWnd, szText, ZClientName(), MB_OK | MB_APPLMODAL);

		SetFocus(focusWnd);

//        ZNetworkEnableMessages(TRUE);
	}
*/

    // MILLENNIUM implementation - people shouldn't use this actually
    gGameShell->ZoneAlert(szText);
}

void ZLIBPUBLIC ZAlertSystemFailure(char* szText)
{
    /*
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	char szTemp[200];
	wsprintf("%s: System Failure",ZClientName());

	{
		// around message box, make sure network traffic is off
//        ZNetworkEnableMessages(FALSE);

		MessageBox(gHWNDMainWindow,szText, szTemp, MB_OK|MB_APPLMODAL);

//        ZNetworkEnableMessages(TRUE);
	}
    */
}

void ZLIBPUBLIC ZBeep()
{
//	MessageBeep(MB_OK);
}

void ZLIBPUBLIC ZDelay(uint32 delay)
{
	Sleep(delay*10);
}


typedef struct {
	TCHAR name[128];
	HWND hWnd;
	BOOL found;
} LaunchData;

static BOOL CALLBACK LaunchEnumFunc(HWND hWnd, LPARAM lParam)
{
    /*
	LaunchData* ld = (LaunchData*) lParam;
	TCHAR str[128];
	int16 len;
	int i;

	GetWindowText(hWnd,str,80);
	len = lstrlen(str);

	for (i = 0;i < len; i++) {
		// search for the main room window... 
		if (!_tcsnicmp(&str[i],ld->name,lstrlen(ld->name))) {
			ld->found = TRUE;
			ld->hWnd = hWnd;
			// found the file 
			return FALSE;
		}
	}
    return TRUE;
    */
    return FALSE;
}

static ZBool FindWindowWithString(char* programName, HWND* hwnd)
	/*
		Returns TRUE if the program programName is already running from programFileName.
		This call is system dependent on whether the system supports multiple instances of
		a program or not (ZSystemHasMultiInstanceSupport). If it does, then it checks for
		the programName of the instance. If not, it checks for an instance of programFileName.
		
		If programName is NULL, then it checks for an instance of programFileName only.
	*/
{
	/* is the program already running? */
    /*
	LaunchData launchData;
	LaunchData* ld = &launchData;
	TCHAR cwd[128];
	_tgetcwd(cwd,128);
	ld->found = FALSE;
	lstrcpy(ld->name,programName);
	{
		HWND hWnd = GetWindow(GetDesktopWindow(),GW_CHILD);
		BOOL rval= TRUE;
		while ((hWnd = GetWindow(hWnd,GW_HWNDNEXT)) && rval) {
			rval = LaunchEnumFunc(hWnd,(LPARAM)ld);
		}
	}

	if (hwnd) 
		*hwnd = ld->hWnd;

	return ld->found;
    */
    return FALSE;
}

ZError ZLaunchProgram(char* programName, char* programFileName, uchar* commandLineData)
	/*
		Runs the program called programName from the file programFileName. If programName
		is already running, it simply brings this process to the foreground. Otherwise,
		it runs an instance of programFileName as programName and passes commandLineData
		as command line.
	*/
{
	// is the program already running?
    /*
	HWND hWnd;

	if (FindWindowWithString(programName,&hWnd)) {
		BringWindowToTop(hWnd);
	} else {
		// program not already running, launch it
		TCHAR szTemp[256];
		wsprintf(szTemp, _T("games\\%s %s"),
					programFileName,commandLineData);

		UINT rval = WinExec(szTemp,SW_SHOWNORMAL);
		if (rval <32) return zErrLaunchFailure;
	}

	return zErrNone;
    */
    return zErrNotImplemented;
}

ZBool ZProgramIsRunning(TCHAR* programName, TCHAR* programFileName)
	/*
		Returns TRUE if the program programName is already running from programFileName.
		This call is system dependent on whether the system supports multiple instances of
		a program or not (ZSystemHasMultiInstanceSupport). If it does, then it checks for
		the programName of the instance. If not, it checks for an instance of programFileName.
		
		If programName is NULL, then it checks for an instance of programFileName only.
	*/
{
	return FALSE; //FindWindowWithString(programName,NULL);
}

ZBool ZSystemHasMultiInstanceSupport(void)
	/*
		Returns TRUE if the system can spawn multiple instances of a program from one
		program file.
	*/
{
	return TRUE;
}

ZBool ZProgramExists(char* programFileName)
{
    ASSERT( !"Implement me!" );

	//Determines whether the given program exists and returns TRUE if so.
    /*
	TCHAR szTemp[256];
	wsprintf(szTemp,_T("games\\%s.exe"), programFileName);

	// provide simpel check by trying to open the game file 
	FILE* f = fopen(szTemp,_T("r"));
	if (f) {
		fclose(f);
		return TRUE;
	}
    */
	return FALSE;
}

ZError ZLIBPUBLIC ZTerminateProgram(char *programFileName)
{
	/*
		Terminates the program called programFileName.
	*/
	ASSERT(FALSE);
	return zErrNone;
}

ZVersion ZSystemVersion(void)
	/*
		Returns the system library version number.
	*/
{
	return zVersionWindows;
}

uint16 ZLIBPUBLIC ZGetProcessorType(void)
{
	return zProcessor80x86;
}

uint16 ZLIBPUBLIC ZGetOSType(void)
{
	OSVERSIONINFO ver;
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&ver);
	switch(ver.dwPlatformId) {
	case VER_PLATFORM_WIN32_NT:
		return zOSWindowsNT;
	case VER_PLATFORM_WIN32s:
		return zOSWindows31;
	default:
		return zOSWindows95;
	}
	return zOSWindows31;
}


TCHAR* ZLIBPUBLIC ZGenerateDataFileName(TCHAR *gameName,TCHAR *dataFileName)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();


	if (!pGlobals)
		return NULL;

	if (!gameName)
	{
		if (lstrlen(pGlobals->localPath) + lstrlen(dataFileName) < _MAX_PATH)
			wsprintf(pGlobals->tempStr,_T("%s\\%s"), pGlobals->localPath, dataFileName);
		else
			lstrcpy(pGlobals->tempStr, pGlobals->localPath);
	}
	else
	{
		if (lstrlen(pGlobals->localPath) + lstrlen(gameName) + lstrlen(dataFileName) < _MAX_PATH)
			wsprintf(pGlobals->tempStr,_T("%s\\%s\\%s"), pGlobals->localPath, gameName, dataFileName);
		else
			lstrcpy(pGlobals->tempStr, pGlobals->localPath);
	}

	return(pGlobals->tempStr);
}

uint16 ZLIBPUBLIC ZGetDefaultScrollBarWidth(void)
	/*
		Returns the system's default width for a scroll bar. This is made available for
		the user to consistently determine the scroll bar width for all platforms.
	*/
{
	return GetSystemMetrics(SM_CXVSCROLL);
}

ZBool ZLIBPUBLIC ZIsButtonDown(void)
	/*
		Returns TRUE if the mouse button is down; otherwise, it returns FALSE.
	*/
{
	// how do I do this???
//	TRACE0("ZIsButtonDown not supported yet(how under windows?)\n");
	return FALSE;
}

void ZLIBPUBLIC ZGetScreenSize(int32* width, int32* height)
	/*
		Returns the size of the screen in pixels.
	*/
{
	*width = GetSystemMetrics(SM_CXSCREEN);
	*height = GetSystemMetrics(SM_CYSCREEN);
}

/* function to return the window to be treated as the desktop window */
/* note: active x will use a child of the web browser as its window */
HWND ZWinGetDesktopWindow(void)
{
	return NULL;
}

void ZSystemAssert(ZBool x)
{
    ASSERT( !"Implement me!" );
    /*
	if (!x) {
		MessageBoxUNULL,_T("ASSERT ERORR", "Assertion Failed"), MB_OK);
		DebugBreak();
	}
    */
}


#if 0 // one possibility

inline DECLARE_MAYBE_FUNCTION_1(BOOL, GetProcessDefaultLayout, DWORD *);

ZBool ZLIBPUBLIC ZIsLayoutRTL()
{
    DWORD dw;
    if(!CALL_MAYBE(GetProcessDefaultLayout)(&dw))    //  this will not work on NT4 or Win95
        return FALSE;

    if(dw & LAYOUT_RTL)
        return TRUE;

    return FALSE;
}

#else // another possibility

ZBool ZLIBPUBLIC ZIsLayoutRTL()
{
    LCID lcid = ZShellZoneShell()->GetApplicationLCID();
    if(PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_HEBREW ||
        PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_ARABIC)
        return TRUE;
    return FALSE;
}

#endif


ZBool ZLIBPUBLIC ZIsSoundOn()
{
    long lSound = DEFAULT_PrefSound;
    const TCHAR *arKeys[] = { key_Lobby, key_PrefSound };
    ZShellDataStorePreferences()->GetLong(arKeys, 2, &lSound);
    return lSound ? TRUE : FALSE;
}


//////////////////////////////////////////////////////////////
// Utility functions

void ZRectToWRect(RECT* rect, ZRect* zrect)
{
	rect->left = zrect->left;
	rect->right = zrect->right;
	rect->top = zrect->top;
	rect->bottom = zrect->bottom;
}

void WRectToZRect(ZRect* zrect, RECT* rect)
{
	zrect->left = (int16)rect->left;
	zrect->right = (int16)rect->right;
	zrect->top = (int16)rect->top;
	zrect->bottom = (int16)rect->bottom;
}

void ZPointToWPoint(POINT* point, ZPoint* zpoint)
{
	point->x = zpoint->x;
	point->y = zpoint->y;
}

void WPointToZPoint(ZPoint* zpoint, POINT* point)
{
	zpoint->x = (int16)point->x;
	zpoint->y = (int16)point->y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\ztableb.cpp ===
/*******************************************************************************

	ZTableB.c
	
		Zone(tm) TableBox module.
			
	Copyright (c) Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Sunday, October 22, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		11/21/96	HI		Now references color and fonts through
								ZGetStockObject().
    1       10/13/96    HI      Fixed compiler warnings.
	0		10/22/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zone.h"
#include "zonemem.h"


#define IT(object)				((ITable) (object))
#define ZT(object)				((ZTableBox) (object))

#define IC(object)				((ICell) (object))
#define ZC(object)				((ZTableBoxCell) (object))


/* Forward declaration. */
typedef struct ITableStruct ITableType, *ITable;

typedef struct
{
	ITable						table;
	int16						column;
	int16						row;
	ZBool						selected;
    void*						data;
} ICellType, *ICell;

typedef struct ITableStruct
{
	ZWindow						window;
	ZRect						bounds;
	int16						numColumns;
	int16						numRows;
	int16						cellWidth;
	int16						cellHeight;
	uint32						flags;
	ZTableBoxDrawFunc			drawFunc;
	ZTableBoxDoubleClickFunc	doubleClickFunc;
	ZTableBoxDeleteFunc			deleteFunc;
	void*						userData;
	
	ICellType**					cells;
	ZOffscreenPort				cellPort;
	ZScrollBar					hScrollBar;
	ZScrollBar					vScrollBar;
	ZBool						locked;
	int16						topLeftX;
	int16						topLeftY;
	uint16						totalWidth;
	uint16						totalHeight;
	ZRect						contentBounds;
	int16						realCellWidth;
	int16						realCellHeight;
	ZBool						tracking;
	ZBool						multSelection;
	ICell						lastSelectedCell;
} ITableType, *ITable;


/* -------- Internal Routines -------- */
static ZBool TableBoxMessageFunc(ZTableBox table, ZMessage* message);
static void ResetCellLocations(ITable table);
static void DrawTable(ITable table);
static void SynchScrollBars(ITable table);
static void RecalcContentSize(ITable table);
static ICell GetCell(ITable table, int16 x, int16 y);
static void GetCellRect(ITable table, int16 column, int16 row, ZRect* rect);
static void TableBoxScrollBarFunc(ZScrollBar scrollBar, int16 curValue, void* userData);
static void HandleButtonDown(ITable table, ZPoint* where, ZBool doubleClick, uint32 modifier);
static void TrackCursor(ITable table, ZPoint* where);
static void InvertCell(ICell cell);
static void BringCellToView(ICell cell);


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

ZTableBox ZTableBoxNew(void)
{
	ITable				table;
	
	
	if ((table = (ITable) ZMalloc(sizeof(ITableType))) != NULL)
	{
		table->window = NULL;
		table->drawFunc = NULL;
		table->doubleClickFunc = NULL;
		table->deleteFunc = NULL;
		table->cells = NULL;
		table->cellPort = NULL;
		table->hScrollBar = NULL;
		table->vScrollBar = NULL;
	}
	
	return (table);
}


/*
	Initializes the table object. The deleteFunc provided by the caller is
	called when deleting the object.
	
	boxRect specifies the bounding box of the table box. This includes the
	scroll bars if any.
	
	cellWidth and cellHeight specify the width and height of the cell in
	pixels.
	
	drawFunc must be specified. Otherwise, no drawing will take place.
	
	If deleteFunc is NULL, then no delete function is called when an
	object is deleted.
	
	The flags parameter defines special properties of the table box. If it
	is 0, then the default behavior is as defined:
		- No scroll bars,
		- Not selectable, and
		- Double clicks do nothing.
*/
ZError ZTableBoxInit(ZTableBox table, ZWindow window, ZRect* boxRect,
		int16 numColumns, int16 numRows, int16 cellWidth, int16 cellHeight, ZBool locked,
		uint32 flags, ZTableBoxDrawFunc drawFunc, ZTableBoxDoubleClickFunc doubleClickFunc,
		ZTableBoxDeleteFunc deleteFunc, void* userData)
{
	ZError			err = zErrNone;
	ITable			pThis = IT(table);
	ZRect			rect;
	
	
	if (pThis != NULL)
	{
		if ((flags & zTableBoxDoubleClickable) || (flags & zTableBoxMultipleSelections))
			flags |= zTableBoxSelectable;
		
		pThis->window = window;
		pThis->bounds = *boxRect;
		pThis->numColumns = numColumns;
		pThis->numRows = 0;
		pThis->cellWidth = cellWidth;
		pThis->cellHeight = cellHeight;
		pThis->flags = flags;
		pThis->drawFunc = drawFunc;
		pThis->doubleClickFunc = doubleClickFunc;
		pThis->deleteFunc = deleteFunc;
		pThis->userData = userData;
		pThis->locked = locked;
		pThis->tracking = FALSE;
		pThis->lastSelectedCell = NULL;
		
		pThis->realCellWidth = cellWidth;
		pThis->realCellHeight = cellHeight;
		if (pThis->flags & zTableBoxDrawGrids)
		{
			pThis->realCellWidth++;
			pThis->realCellHeight++;
		}

		pThis->topLeftX = 0;
		pThis->topLeftY = 0;
		
		if (numColumns == 0)
			pThis->totalWidth = 0;
		else
			pThis->totalWidth = pThis->numColumns * pThis->realCellWidth - 1;
		if (numRows == 0)
			pThis->totalHeight = 0;
		else
			pThis->totalHeight = numRows * pThis->realCellHeight - 1;
		
		/* Allocate cells. */
		ZTableBoxAddRows(table, -1, numRows);
		
		/* Allocate cell offscreen port. */
		ZSetRect(&rect, 0, 0, cellWidth, cellHeight);
		if ((pThis->cellPort = ZOffscreenPortNew()) == NULL)
			goto OutOfMemory;
		ZOffscreenPortInit(pThis->cellPort, &rect);
		
		pThis->contentBounds = pThis->bounds;
		ZRectInset(&pThis->contentBounds, 1, 1);
		
		// Must include before scroll bars so that they get mouse clicks.
		ZWindowAddObject(window, pThis, boxRect, TableBoxMessageFunc, pThis);
		
		if ((flags & zTableBoxHorizScrollBar) || (flags & zTableBoxVertScrollBar))
		{
			if (flags & zTableBoxHorizScrollBar)
				pThis->contentBounds.bottom -= ZGetDefaultScrollBarWidth() - 1;
			if (flags & zTableBoxVertScrollBar)
				pThis->contentBounds.right -= ZGetDefaultScrollBarWidth() - 1;
			
			if (flags & zTableBoxHorizScrollBar)
			{
				/* Create the horizontal scroll bar. */
				rect = pThis->bounds;
				rect.top = pThis->contentBounds.bottom;
				rect.right = pThis->contentBounds.right + 1;
				pThis->hScrollBar = ZScrollBarNew();
				ZScrollBarInit(pThis->hScrollBar, pThis->window, &rect, 0, 0, 0, 1, 1, TRUE,
						TRUE, TableBoxScrollBarFunc, pThis);
			}
			
			if (flags & zTableBoxVertScrollBar)
			{
				/* Create the vertical scroll bar. */
				rect = pThis->bounds;
				rect.left = pThis->contentBounds.right;
				rect.bottom = pThis->contentBounds.bottom + 1;
				pThis->vScrollBar = ZScrollBarNew();
				ZScrollBarInit(pThis->vScrollBar, pThis->window, &rect, 0, 0, 0, 1, 1, TRUE,
						TRUE, TableBoxScrollBarFunc, pThis);
			}
		}
		
		SynchScrollBars(pThis);
		SynchScrollBars(pThis);
		
		DrawTable(pThis);
	}
	
	goto Exit;

OutOfMemory:
	err = zErrOutOfMemory;

Exit:
	
	return (err);
}


/*
	Destroys the table object by deleting all cell objects.
*/
void ZTableBoxDelete(ZTableBox table)
{
	ITable			pThis = IT(table);
	
	 
	if (pThis != NULL)
	{
		ZWindowRemoveObject(pThis->window, pThis);
		
		if (pThis->cells != NULL)
			ZTableBoxDeleteRows(table, 0, -1);
		
		if (pThis->cellPort != NULL)
			ZOffscreenPortDelete(pThis->cellPort);
		
		if (pThis->hScrollBar != NULL)
			ZScrollBarDelete(pThis->hScrollBar);
		
		if (pThis->vScrollBar != NULL)
			ZScrollBarDelete(pThis->vScrollBar);
		
		ZFree(pThis);
	}
}


/*
	Draws the table box.
*/
void ZTableBoxDraw(ZTableBox table)
{
	DrawTable(IT(table));
}


/*
	Moves the table box to the specified given location. Size is not changed.
*/
void ZTableBoxMove(ZTableBox table, int16 left, int16 top)
{
	ITable			pThis = IT(table);


	ZRectErase(pThis->window, &pThis->bounds);
	ZWindowInvalidate(pThis->window, &pThis->bounds);
	ZRectOffset(&pThis->bounds, (int16) (left - pThis->bounds.left), (int16) (top - pThis->bounds.top));
	DrawTable(pThis);
}


/*
	Resizes the table box to the specified width and height.
*/
void ZTableBoxSize(ZTableBox table, int16 width, int16 height)
{
	ITable			pThis = IT(table);
	ZRect			rect;
	
	
	if (pThis != NULL)
	{
		ZRectErase(pThis->window, &pThis->bounds);
		ZWindowInvalidate(pThis->window, &pThis->bounds);

		pThis->bounds.right = pThis->bounds.left + width;
		pThis->bounds.bottom = pThis->bounds.top + height;
		
		pThis->contentBounds = pThis->bounds;
		ZRectInset(&pThis->contentBounds, 1, 1);
		
		if ((pThis->flags & zTableBoxHorizScrollBar) || (pThis->flags & zTableBoxVertScrollBar))
		{
			if (pThis->flags & zTableBoxHorizScrollBar)
				pThis->contentBounds.bottom -= ZGetDefaultScrollBarWidth() - 1;
			if (pThis->flags & zTableBoxVertScrollBar)
				pThis->contentBounds.right -= ZGetDefaultScrollBarWidth() - 1;
			
			if (pThis->flags & zTableBoxHorizScrollBar)
			{
				/* Resize the horizontal scroll bar. */
				rect = pThis->bounds;
				rect.top = pThis->contentBounds.bottom;
				rect.right = pThis->contentBounds.right + 1;
				ZScrollBarSetRect(pThis->hScrollBar, &rect);
			}
			
			if (pThis->flags & zTableBoxVertScrollBar)
			{
				/* Resize the vertical scroll bar. */
				rect = pThis->bounds;
				rect.left = pThis->contentBounds.right;
				rect.bottom = pThis->contentBounds.bottom + 1;
				ZScrollBarSetRect(pThis->vScrollBar, &rect);
			}
		}
		
		RecalcContentSize(pThis);
		DrawTable(pThis);
	}
}


/*
	Locks the table box so that the cells are not selectable.
*/
void ZTableBoxLock(ZTableBox table)
{
	ITable			pThis = IT(table);
	
	
	pThis->locked = TRUE;
	ZTableBoxDeselectCells(table, 0, 0, -1, -1);
	DrawTable(pThis);
}


/*
	Unlocks the table box from its locked state so that the cells are selectable.
*/
void ZTableBoxUnlock(ZTableBox table)
{
	ITable			pThis = IT(table);
	
	
	pThis->locked = FALSE;
}


/*
	Returns the number of rows and columns in the table.
*/
void ZTableBoxNumCells(ZTableBox table, int16* numColumns, int16* numRows)
{
	ITable			pThis = IT(table);
	
	
	*numRows = pThis->numRows;
	*numColumns = pThis->numColumns;
}


/*
	Adds numRows of rows to the table in front of the beforeRow row.
	
	If beforeRow is -1, then the rows are added to the end.
*/
ZError ZTableBoxAddRows(ZTableBox table, int16 beforeRow, int16 numRows)
{
	ITable			pThis = IT(table);
	ZError			err = zErrNone;
	int16			i, j;
	
	
	if (numRows > 0)
	{
		/* Allocate/reallocate the row cell array. */
		if (pThis->cells == NULL)
		{
			if ((pThis->cells = (ICell *) ZMalloc(numRows * sizeof(ICellType*))) == NULL)
				goto OutOfMemory;
		}
		else
		{
			/* Reallocate the row cell array to the new size. */
			if ((pThis->cells = (ICell *) ZRealloc(pThis->cells, (pThis->numRows + numRows) *
					sizeof(ICellType*))) == NULL)
				goto OutOfMemory;
			
			if (beforeRow != -1)
			{
				/* Move cells to make space in the middle. */
				memmove(&pThis->cells[beforeRow + numRows], &pThis->cells[beforeRow],
						(pThis->numRows - beforeRow) * sizeof(ICellType*));
			}
		}
		
		/* Allocate the column cell arrays. */
		if (beforeRow == -1)
			beforeRow = pThis->numRows;
		for (i = 0; i < numRows; i++)
		{
			if ((pThis->cells[beforeRow + i] = (ICell) ZMalloc(pThis->numColumns * sizeof(ICellType)))
					== NULL)
				goto OutOfMemory;
			for (j = 0; j < pThis->numColumns; j++)
			{
				((ICellType*) pThis->cells[i])[j].table = pThis;
				((ICellType*) pThis->cells[i])[j].selected = FALSE;
				((ICellType*) pThis->cells[i])[j].data = NULL;
			}
		}
		
		pThis->numRows += numRows;
		
		ResetCellLocations(pThis);
		RecalcContentSize(pThis);
	}
	
	goto Exit;

OutOfMemory:
	err = zErrOutOfMemory;

Exit:
	
	return (err);
}


/*
	Deletes numRows of rows from the table starting from startRow row.
	
	If numRows is -1, then all the rows starting from startRow to the end
	are deleted.
*/
void ZTableBoxDeleteRows(ZTableBox table, int16 startRow, int16 numRows)
{
	ITable			pThis = IT(table);
	int16			i, j;
	
	
	if (numRows == -1)
		numRows = pThis->numRows - startRow;
	
	if (numRows > 0)
	{
		for (i = startRow; i < startRow + numRows; i++)
		{
			if (pThis->deleteFunc != NULL)
			{
				for (j = 0; j < pThis->numColumns; j++)
				{
					if (((ICellType*) pThis->cells[i])[j].data != NULL)
						pThis->deleteFunc(ZC(&((ICellType*) pThis->cells[i])[j]),
								((ICellType*) pThis->cells[i])[j].data, pThis->userData);
				}
			}
			
			/* Free the column cell array. */
			ZFree(pThis->cells[i]);
		}
		
		/* Fill in the deleted rows. */
		if (startRow + numRows < pThis->numRows - 1)
			memmove(&pThis->cells[startRow], &pThis->cells[startRow + numRows],
					(pThis->numRows - (startRow + numRows)) * sizeof(ICellType*));
		
		/* Reallocate the row cell array. */
		pThis->cells = (ICell *) ZRealloc(pThis->cells, (pThis->numRows - numRows) * sizeof(ICellType*));
		
		pThis->numRows -= numRows;
		
		ResetCellLocations(pThis);
		RecalcContentSize(pThis);
	}
}


/*
	Adds numColumns of columns to the table in front of the beforeColumn column.
	
	If beforeColumn is -1, then the columns are added to the end.
*/
ZError ZTableBoxAddColumns(ZTableBox table, int16 beforeColumn, int16 numColumns)
{
	ITable			pThis = IT(table);
	ZError			err = zErrNone;
	int16			i, j;
	ICellType*		row;
	
	
	if (numColumns > 0)
	{
		if (beforeColumn == -1)
			beforeColumn = pThis->numColumns;
		
		for (i = 0; i < pThis->numRows; i++)
		{
			/* Reallocate the column cell array. */
			if ((pThis->cells[i] = (ICell) ZRealloc(pThis->cells[i], (pThis->numColumns + numColumns) *
					sizeof(ICellType))) == NULL)
				goto OutOfMemory;
			
			row = pThis->cells[i];
			
			/* Move the necessary cells. */
			if (beforeColumn < pThis->numColumns)
				memmove(&row[beforeColumn + numColumns], &row[beforeColumn],
						(pThis->numColumns - beforeColumn) * sizeof(ICellType));
			
			/* Initialize cells. */
			for (j = 0; j < numColumns; j++)
			{
				row[j + beforeColumn].table = pThis;
				row[j + beforeColumn].selected = FALSE;
				row[j + beforeColumn].data = NULL;
			}
		}
		
		pThis->numColumns += numColumns;
		
		ResetCellLocations(pThis);
		RecalcContentSize(pThis);
	}
	
	goto Exit;

OutOfMemory:
	err = zErrOutOfMemory;

Exit:
	
	return (err);
}


/*
	Deletes numColumns of columns from the table starting from startColumn column.
	
	If numColumns is -1, then all the columns starting from startColumn to the
	end are deleted.
*/
void ZTableBoxDeleteColumns(ZTableBox table, int16 startColumn, int16 numColumns)
{
	ITable			pThis = IT(table);
	ZError			err = zErrNone;
	int16			i, j;
	ICellType*		row;
	
	
	if (numColumns == -1)
		numColumns = pThis->numColumns - startColumn;
	
	if (numColumns > 0)
	{
		for (i = 0; i < pThis->numRows; i++)
		{
			row = pThis->cells[i];

			/* Delete each cell. */
			if (pThis->deleteFunc != NULL)
			{
				for (j = 0; j < pThis->numColumns; j++)
				{
					if (row[j].data != NULL)
						pThis->deleteFunc(ZC(&row[j]), row[j].data, pThis->userData);
				}
			}
			
			/* Fill in the deleted cells. */
			if (startColumn + numColumns < pThis->numColumns - 1)
				memmove(&row[startColumn], &row[startColumn + numColumns],
						(pThis->numColumns - (startColumn + numColumns)) * sizeof(ICellType));
			
			/* Reallocate the column cell array. */
			pThis->cells[i] = (ICell) ZRealloc(pThis->cells[i], (pThis->numColumns - numColumns) *
					sizeof(ICellType));
		}
		
		pThis->numColumns -= numColumns;
		
		ResetCellLocations(pThis);
		RecalcContentSize(pThis);
	}
}


/*
	Highlights all cells included in the rectangle bounded by
	(startColumn, startRow) and (startColumn + numColumns, startRow + numRows)
	as selected.
	
	If numRows is -1, then all the cells in the column starting from startRow
	are selected. Similarly for numColumns.
*/
void ZTableBoxSelectCells(ZTableBox table, int16 startColumn, int16 startRow,
		int16 numColumns, int16 numRows)
{
	ITable			pThis = IT(table);
	int16			i, j;
	ICellType*		row;
	
	
	if (numRows == -1)
		numRows = pThis->numRows - startRow;
	if (numColumns == -1)
		numColumns = pThis->numColumns - startColumn;
	
	for (i = startRow; i < startRow + numRows; i++)
	{
		row = pThis->cells[i];
		for (j = startColumn; j < startColumn + numColumns; j++)
		{
			ZTableBoxCellSelect(ZC(&row[j]));
		}
	}
}


/*
	Unhighlights all cells included in the rectangle bounded by
	(startColumn, startRow) and (startColumn + numColumns, startRow + numRows)
	as deselected.
	
	If numRows is -1, then all the cells in the column starting from startRow
	are deselected. Similarly for numColumns.
*/
void ZTableBoxDeselectCells(ZTableBox table, int16 startColumn, int16 startRow,
		int16 numColumns, int16 numRows)
{
	ITable			pThis = IT(table);
	int16			i, j;
	ICellType*		row;
	
	
	if (numRows == -1)
		numRows = pThis->numRows - startRow;
	if (numColumns == -1)
		numColumns = pThis->numColumns - startColumn;
	
	for (i = startRow; i < startRow + numRows; i++)
	{
		row = pThis->cells[i];
		for (j = startColumn; j < startColumn + numColumns; j++)
		{
			ZTableBoxCellDeselect(ZC(&row[j]));
		}
	}
}


/*
	Clears the whole data. All cells are cleared of any associated data.
*/
void ZTableBoxClear(ZTableBox table)
{
	ITable			pThis = IT(table);
	int16			i, j;
	ICellType*		row;
	
	
	for (i = 0; i < pThis->numRows; i++)
	{
		row = pThis->cells[i];
		for (j = 0; j < pThis->numColumns; j++)
		{
			ZTableBoxCellClear(ZC(&row[j]));
		}
	}
}


/*
	Searches through the table for a cell associated with the given data.
	It returns the first cell found to contain the data.
	
	If fromCell is not NULL, then it search starting after fromCell.
	
	Search is done from top row to bottom row and from left column to
	right column; i.e. (0, 0), (1, 0), (2, 0), ... (0, 1), (1, 1), ...
*/
ZTableBoxCell ZTableBoxFindCell(ZTableBox table, void* data, ZTableBoxCell fromCell)
{
	ITable			pThis = IT(table);
	int16			i = 0, j = 0, k = 0;
	ICellType*		row;
	
	
	if (fromCell != NULL)
	{
		ZTableBoxCellLocation(fromCell, &k, &i);
		if (++k == pThis->numColumns)
		{
			i++;
			k = 0;
		}
	}
	
	for (; i < pThis->numRows; i++)
	{
		row = pThis->cells[i];
		for (j = k; j < pThis->numColumns; j++)
		{
			if (row[j].data == data)
				return (ZC(&row[j]));
		}
		k = 0;
	}
	
	return (NULL);
}


/*
	Returns the first selected cell. The search order is the same as in
	ZTableBoxFindCell().
*/
ZTableBoxCell ZTableBoxGetSelectedCell(ZTableBox table, ZTableBoxCell fromCell)
{
	ITable			pThis = IT(table);
	int16			i = 0, j= 0, k = 0;
	ICellType*		row;
	
	
	if (fromCell != NULL)
	{
		ZTableBoxCellLocation(fromCell, &k, &i);
		if (++k == pThis->numColumns)
		{
			i++;
			k = 0;
		}
	}
	
	for (; i < pThis->numRows; i++)
	{
		row = pThis->cells[i];
		for (j = k; j < pThis->numColumns; j++)
		{
			if (row[j].selected)
				return (ZC(&row[j]));
		}
		k = 0;
	}
	
	return (NULL);
}


/*
	Returns the cell object of the table at the specified location.
	
	The returned cell object is specific to the given table. It cannot
	be used in any other manner except as provided. No two tables can
	share cells.
*/
ZTableBoxCell ZTableBoxGetCell(ZTableBox table, int16 column, int16 row)
{
	ITable			pThis = IT(table);
	
	
	if (row < 0 || row >= pThis->numRows || column < 0 || column >= pThis->numColumns)
		return (NULL);
	
	return (ZC(&((ICellType*) pThis->cells[row])[column]));
}


/*
	Sets the given data to the cell.
*/
void ZTableBoxCellSet(ZTableBoxCell cell, void* data)
{
	ICell			pThis = IC(cell);
	ITable			table = IT(pThis->table);
	
	
	if (pThis->data != NULL)
		if (table->deleteFunc != NULL)
			table->deleteFunc(cell, pThis->data, table->userData);
	pThis->data = data;
	pThis->selected = FALSE;
	ZTableBoxCellDraw(cell);
}


/*
	Gets the data associated with the cell.
*/
void* ZTableBoxCellGet(ZTableBoxCell cell)
{
	ICell			pThis = IC(cell);
	
	
	return (pThis->data);
}


/*
	Clears any data associated with the cell. Same as ZTableBoxCellSet(cell, NULL).
*/
void ZTableBoxCellClear(ZTableBoxCell cell)
{
	ICell			pThis = IC(cell);
	
	
	if (pThis->data != NULL)
		ZTableBoxCellSet(cell, NULL);
}


/*
	Draws the given cell immediately.
*/
void ZTableBoxCellDraw(ZTableBoxCell cell)
{
	ICell			pThis = IC(cell);
	ITable			table = IT(pThis->table);
	ZRect			rect, cellRect, dstRect;
	
	
	/* Determine the destination rectangle. */
	GetCellRect(table, pThis->column, pThis->row, &cellRect);
	ZRectOffset(&cellRect, (int16) (-table->topLeftX + table->contentBounds.left), (int16) (-table->topLeftY + table->contentBounds.top));
	if (ZRectIntersection(&cellRect, &table->contentBounds, &dstRect))
	{
		ZBeginDrawing(table->cellPort);
		
		ZSetRect(&rect, 0, 0, table->cellWidth, table->cellHeight);
		ZRectErase(table->cellPort, &rect);
		
		if (table->drawFunc != NULL)
			table->drawFunc(cell, table->cellPort, &rect, pThis->data, table->userData);
		
		if (pThis->selected)
			ZRectInvert(table->cellPort, &rect);
		
		ZEndDrawing(table->cellPort);
		
		/* Copy cell image onto the window. */
		rect = dstRect;
		ZRectOffset(&rect, (int16) -cellRect.left, (int16) -cellRect.top);
		ZCopyImage(table->cellPort, table->window, &rect, &dstRect, NULL, zDrawCopy);
	}
}


/*
	Returns the location (row, column) of the given cell within its table.
*/
void ZTableBoxCellLocation(ZTableBoxCell cell, int16* column, int16* row)
{
	ICell			pThis = IC(cell);
	
	
	*row = pThis->row;
	*column = pThis->column;
}


/*
	Hilights the given cell as selected.
*/
void ZTableBoxCellSelect(ZTableBoxCell cell)
{
	ICell			pThis = IC(cell);
	
	
	if (pThis->selected == FALSE)
	{
		pThis->selected = TRUE;
		ZTableBoxCellDraw(cell);
	}
}


/*
	Unhilights the given cell as deselected.
*/
void ZTableBoxCellDeselect(ZTableBoxCell cell)
{
	ICell			pThis = IC(cell);
	
	
	if (pThis->selected)
	{
		pThis->selected = FALSE;
		ZTableBoxCellDraw(cell);
	}
}


/*
	Returns TRUE if the given cell is selected; otherwise, FALSE.
*/
ZBool ZTableBoxCellIsSelected(ZTableBoxCell cell)
{
	ICell			pThis = IC(cell);
	
	
	return (pThis->selected);
}


/*
	Enumerates through all the objects in the table through the
	caller supplied enumFunc enumeration function. It passes along to the
	enumeration function the caller supplied userData parameter. It stops
	enumerating when the user supplied function returns TRUE and returns
	the cell object in which the enumeration stopped.
	
	If selectedOnly is TRUE, then the enumeration is done only through the
	selected cells.
*/
ZTableBoxCell ZTableBoxEnumerate(ZTableBox table, ZBool selectedOnly,
		ZTableBoxEnumFunc enumFunc, void* userData)
{
	ITable			pThis = IT(table);
	int16			i, j;
	ICellType*		row;
	
	
	for (i = 0; i < pThis->numRows; i++)
	{
		row = pThis->cells[i];
		for (j = 0; j < pThis->numColumns; j++)
		{
			if ((selectedOnly && row[j].selected) || selectedOnly == FALSE)
				if (enumFunc(ZC(&row[j]), row[j].data, userData))
					return (ZC(&row[j]));
		}
	}
	
	return (NULL);
}


/*******************************************************************************
		INTERNAL ROUTINES
*******************************************************************************/

/*
	Called by the user to pass the message to the table box object.
	If the object handled the message, then it return TRUE; otherwise,
	it returns FALSE.
	
	Handles the arrow keys for moving selections.
*/
ZBool TableBoxMessageFunc(ZTableBox table, ZMessage* message)
{
	ITable			pThis = IT(message->userData);
	ZBool			messageHandled = FALSE;
	
	
	switch (message->messageType)
	{
		case zMessageWindowIdle:
			if (pThis->tracking)
			{
				TrackCursor(pThis, &message->where);
			}
			messageHandled = TRUE;
			break;
		case zMessageWindowButtonDown:
			HandleButtonDown(pThis, &message->where, FALSE, message->message);
			messageHandled = TRUE;
			break;
		case zMessageWindowButtonDoubleClick:
			HandleButtonDown(pThis, &message->where, TRUE, message->message);
			messageHandled = TRUE;
			break;
		case zMessageWindowButtonUp:
			if (pThis->tracking)
			{
				pThis->tracking = FALSE;
			}
			messageHandled = TRUE;
			break;
		case zMessageWindowChar:
			messageHandled = TRUE;
			break;
		case zMessageWindowDraw:
			DrawTable(pThis);
			messageHandled = TRUE;
			break;
		case zMessageWindowObjectTakeFocus:
			messageHandled = TRUE;
			break;
		case zMessageWindowObjectLostFocus:
			messageHandled = TRUE;
			break;
		case zMessageWindowActivate:
		case zMessageWindowDeactivate:
			break;
	}
	
	return (messageHandled);
}


/*
	Sets the row and column fields of all cells.
*/
static void ResetCellLocations(ITable table)
{
	int16				i, j;
	
	
	for (i = 0; i < table->numRows; i++)
	{
		for (j = 0; j < table->numColumns; j++)
		{
			((ICellType*) table->cells[i])[j].row = i;
			((ICellType*) table->cells[i])[j].column = j;
		}
	}
}


/*
	Draws the table.
	
	Draws only the visible cells.
*/
static void DrawTable(ITable table)
{
	int16			column, row, column2, x, y;
	ICell			cell;
	ZRect			rect, oldClip;
	
	
	if (table != NULL)
	{
		ZBeginDrawing(table->window);
		
		ZGetClipRect(table->window, &oldClip);
		ZSetClipRect(table->window, &table->bounds);

		ZSetForeColor(table->window, (ZColor*) ZGetStockObject(zObjectColorBlack));
		ZSetBackColor(table->window, (ZColor*) ZGetStockObject(zObjectColorWhite));
		ZSetPenWidth(table->window, 1);
		ZSetDrawMode(table->window, zDrawCopy);
		
		/* Draw the table box bounds. */
		ZRectDraw(table->window, &table->bounds);
		
		/* Draw the content bounds. */
		rect = table->contentBounds;
		ZRectInset(&rect, -1, -1);
		ZRectDraw(table->window, &rect);
		
		if (table->numRows > 0 && table->numColumns > 0)
		{
			ZSetClipRect(table->window, &table->contentBounds);
	
			/* Get the first cell. */
			cell = GetCell(table, 0, 0);
			ZTableBoxCellLocation(cell, &column, &row);
			GetCellRect(table, column, row, &rect);
			ZRectOffset(&rect, (int16) (-table->topLeftX + table->contentBounds.left), (int16) (-table->topLeftY + table->contentBounds.top));
			
			/* Draw the grids. */
			if (table->flags & zTableBoxDrawGrids)
			{
				x = rect.left - 1;
				if (x < table->contentBounds.left)
					x += table->realCellWidth;
				while (x <= table->contentBounds.right)
				{
					ZMoveTo(table->window, x, table->contentBounds.top);
					ZLineTo(table->window, x, table->contentBounds.bottom);
					x += table->realCellWidth;
				}
				
				y = rect.top - 1;
				if (y < table->contentBounds.top)
					y += table->realCellHeight;
				while (y <= table->contentBounds.bottom)
				{
					ZMoveTo(table->window, table->contentBounds.left, y);
					ZLineTo(table->window, table->contentBounds.right, y);
					y += table->realCellHeight;
				}
			}
			
			/* Draw all the cells. */
			column2 = column;
			while (rect.top <= table->contentBounds.bottom)
			{
				while (rect.left <= table->contentBounds.right)
				{
					cell = (ICell) ZTableBoxGetCell(ZT(table), column, row);
					ZTableBoxCellDraw(cell);
					column++;
					if (column >= table->numColumns)
						break;
					GetCellRect(table, column, row, &rect);
					ZRectOffset(&rect, (int16) (-table->topLeftX + table->contentBounds.left), (int16) (-table->topLeftY + table->contentBounds.top));
				}
				row++;
				if (row >= table->numRows)
					break;
				column = column2;
				GetCellRect(table, column, row, &rect);
				ZRectOffset(&rect, (int16) (-table->topLeftX + table->contentBounds.left), (int16) (-table->topLeftY + table->contentBounds.top));
			}
		}
		
		ZSetClipRect(table->window, &oldClip);
		
		ZEndDrawing(table->window);
	}
}


/*
	Synchronizes the scroll bar to the contents of the table box.
	
	Sets the value, min/max, and single/page increments of the scroll bars.
*/
static void SynchScrollBars(ITable table)
{
	uint16			num, size;
	ICell			cell;
	
	
	if (table->flags & zTableBoxHorizScrollBar)
	{
		size = ZRectWidth(&table->contentBounds);
		if (table->totalWidth <= size)
		{
			/* Set cur value and min/max ranges. */
			ZScrollBarSetValue(table->hScrollBar, 0);
			ZScrollBarSetRange(table->hScrollBar, 0, 0);
		}
		else
		{
			/* Determine number of cells fully visible in content area. */
			num = size / table->realCellWidth;
			
			/* Set min/max ranges. */
			ZScrollBarSetRange(table->hScrollBar, 0, (int16) (table->numColumns - num));
			
			/* Set page increment value. */
			if (num * table->realCellWidth >= size)
				num--;
			ZScrollBarSetIncrements(table->hScrollBar, 1, num);
			
			/* Determine the first cell and set the cur value. */
			cell = GetCell(table, 0, 0);
			if( cell != NULL )
			{
				ZScrollBarSetValue(table->hScrollBar, cell->column);
			}
		}
	}
	
	if (table->flags & zTableBoxVertScrollBar)
	{
		size = ZRectHeight(&table->contentBounds);
		if (table->totalHeight <= size)
		{
			/* Set cur value and min/max ranges. */
			ZScrollBarSetValue(table->vScrollBar, 0);
			ZScrollBarSetRange(table->vScrollBar, 0, 0);
		}
		else
		{
			/* Determine number of cells fully visible in content area. */
			num = size / table->realCellHeight;
			
			/* Set min/max ranges. */
			ZScrollBarSetRange(table->vScrollBar, 0, (int16) (table->numRows - num));
			
			/* Set page increment value. */
			if (num * table->realCellHeight >= size)
				num--;
			ZScrollBarSetIncrements(table->vScrollBar, 1, num);
			
			/* Determine the first cell and set the cur value. */
			cell = GetCell(table, 0, 0);
			if( cell != NULL )
			{
				ZScrollBarSetValue(table->vScrollBar, cell->row);
			}
		}
	}
}


/*
	Recalculates the topLeft position and total content size.
*/
static void RecalcContentSize(ITable table)
{
	uint16			size;
	
	
	if (table->numColumns == 0)
		table->totalWidth = 0;
	else
		table->totalWidth = table->numColumns * table->realCellWidth - 1;
	if (table->numRows == 0)
		table->totalHeight = 0;
	else
		table->totalHeight = table->numRows * table->realCellHeight - 1;
	
	size = ZRectWidth(&table->contentBounds);
	if (table->totalWidth > size && table->topLeftX + size > table->totalWidth)
	{
		table->topLeftX = table->totalWidth - size;
		
		SynchScrollBars(table);
	}
	
	size = ZRectHeight(&table->contentBounds);
	if (table->totalHeight > size && table->topLeftY + size > table->totalHeight)
	{
		table->topLeftY = table->totalHeight - size;
		
		SynchScrollBars(table);
	}
}


/*
	Given the x,y coordinate local to the content area, it returns the
	corresponding cell.
*/
static ICell GetCell(ITable table, int16 x, int16 y)
{
	ICell			cell = NULL;
	uint32			ax, ay;
	int32			row, column;
	
	
	ax = x + table->topLeftX;
	ay = y + table->topLeftY;
	if (ax < table->totalWidth && ay < table->totalHeight)
	{
		column = ax / table->realCellWidth;
		row = ay / table->realCellHeight;
		
		if (column < table->numColumns && row < table->numRows)
			cell = &((ICellType*) table->cells[row])[column];
	}
	
	return (cell);
}


/*
	Returns the bounding rectangle for the specified cell.
*/
static void GetCellRect(ITable table, int16 column, int16 row, ZRect* rect)
{
	if (rect != NULL)
	{
		ZSetRect(rect, 0, 0, 0, 0);
		
		if (column >= 0 && column < table->numColumns && row >= 0 && row < table->numRows)
		{
			rect->left = column * table->realCellWidth;
			rect->top = row * table->realCellHeight;
			rect->right = rect->left + table->cellWidth;
			rect->bottom = rect->top + table->cellHeight;
		}
	}
}


/*
	Performance could be improved by drawing only the differential.
*/
static void TableBoxScrollBarFunc(ZScrollBar scrollBar, int16 curValue, void* userData)
{
	ITable			table = IT(userData);
	ZRect			rect;
	uint16			size;
	
	
	if (scrollBar == table->hScrollBar)
	{
		GetCellRect(table, curValue, 0, &rect);
		table->topLeftX = rect.left;
		size = ZRectWidth(&table->contentBounds);
		if (table->totalWidth > size && table->topLeftX + size > table->totalWidth)
			table->topLeftX = table->totalWidth - size;
	}
	else if (scrollBar == table->vScrollBar)
	{
		GetCellRect(table, 0, curValue, &rect);
		table->topLeftY = rect.top;
		size = ZRectHeight(&table->contentBounds);
		if (table->totalHeight > size && table->topLeftY + size > table->totalHeight)
			table->topLeftY = table->totalHeight - size;
	}
	
	DrawTable(table);
}


static void HandleButtonDown(ITable table, ZPoint* where, ZBool doubleClick, uint32 modifier)
{
	ICell			cell;
	ZPoint			pt;
	
	
	/* Handle mouse down only if selectable. */
	if (table->flags & zTableBoxSelectable)
	{
		if (ZPointInRect(where, &table->contentBounds))
		{
			pt = *where;
			ZPointOffset(&pt, (int16) -table->contentBounds.left, (int16) -table->contentBounds.top);
			if ((cell = GetCell(table, pt.x, pt.y)) != NULL)
			{
				if (doubleClick && table->doubleClickFunc != NULL)
				{
					if (table->flags & zTableBoxDoubleClickable)
						table->doubleClickFunc(cell, cell->data, table->userData);
				}
				else
				{
					table->tracking = TRUE;
					
					if ((table->flags & zTableBoxMultipleSelections) &&
							(modifier & zCharShiftMask))
						table->multSelection = TRUE;
					else
						table->multSelection = FALSE;
					
					if (table->multSelection == FALSE)
						ZTableBoxDeselectCells(table, 0, 0, -1, -1);
					
					InvertCell(cell);
					table->lastSelectedCell = cell;
					
					ZWindowTrackCursor(table->window, TableBoxMessageFunc, table);
				}
			}
		}
	}
}


static void TrackCursor(ITable table, ZPoint* where)
{
	ICell			cell = NULL;
	ZPoint			pt;
	ZRect			cellRect;
	int16			dx, dy;
	
	
	pt = *where;
	ZPointOffset(&pt, (int16) -table->contentBounds.left, (int16) -table->contentBounds.top);

	/*
		If inside the content region, then select the cell under the cursor.
		Otherwise, start scrolling towards the cursor.
	*/
	if (ZPointInRect(where, &table->contentBounds))
	{
		cell = GetCell(table, pt.x, pt.y);
	}
	else
	{
		GetCellRect(table, table->lastSelectedCell->column, table->lastSelectedCell->row,
				&cellRect);
		ZRectOffset(&cellRect, (int16) -table->topLeftX, (int16) -table->topLeftY);
		
		dx = dy = 0;
		if (pt.x < cellRect.left)
			dx = -1;
		else if (pt.x > cellRect.right)
			dx = 1;
		if (pt.y < cellRect.top)
			dy = -1;
		else if (pt.y > cellRect.bottom)
			dy = 1;
		
		dx += table->lastSelectedCell->column;
		dy += table->lastSelectedCell->row;
		if (dx < 0)
			dx = 0;
		else if (dx >= table->numColumns)
			dx = table->numColumns - 1;
		if (dy < 0)
			dy = 0;
		else if (dy >= table->numRows)
			dy = table->numRows - 1;
		cell = IC(ZTableBoxGetCell(ZT(table), dx, dy));
	}
	
	if (cell != NULL)
	{
		if (cell != table->lastSelectedCell)
		{
			if (table->multSelection)
			{
				BringCellToView(cell);
				InvertCell(cell);
			}
			else
			{
				InvertCell(table->lastSelectedCell);
				BringCellToView(cell);
				ZTableBoxCellSelect(ZC(cell));
			}
			table->lastSelectedCell = cell;
		}
	}
}


static void InvertCell(ICell cell)
{
	if (ZTableBoxCellIsSelected(cell))
		ZTableBoxCellDeselect(ZC(cell));
	else
		ZTableBoxCellSelect(ZC(cell));
}


/*
	Repositions the content region to make sure the given cell is fully visible. If the
	cell is already fully visible, then the content region is not repositioned.
*/
static void BringCellToView(ICell cell)
{
	ITable			table = cell->table;
	ZRect			cellRect, tmpRect;
	int16			width, height, min, max;
	ZBool			moved = FALSE;
	ICell			bottomCell;
	
	
	width = ZRectWidth(&table->contentBounds);
	height = ZRectHeight(&table->contentBounds);

	GetCellRect(table, cell->column, cell->row, &cellRect);
	tmpRect = cellRect;
	ZRectOffset(&tmpRect, (int16) (-table->topLeftX + table->contentBounds.left), (int16) (-table->topLeftY + table->contentBounds.top));
	if (tmpRect.left < table->contentBounds.left)
	{
		table->topLeftX = cellRect.left;
		if (table->totalWidth > width && table->topLeftX + width > table->totalWidth)
			table->topLeftX = table->totalWidth - width;
		moved = TRUE;
	}
	else if (tmpRect.right > table->contentBounds.right)
	{
		table->topLeftX = cellRect.right - width;
		if (table->topLeftX < 0)
			table->topLeftX = 0;
		moved = TRUE;
	}

	if (tmpRect.top < table->contentBounds.top)
	{
		table->topLeftY = cellRect.top;
		if (table->totalHeight > height && table->topLeftY + height > table->totalHeight)
			table->topLeftY = table->totalHeight - height;
		moved = TRUE;
	}
	else if (tmpRect.bottom > table->contentBounds.bottom)
	{
		table->topLeftY = cellRect.bottom - height;
		if (table->topLeftY < 0)
			table->topLeftY = 0;
		moved = TRUE;
	}

	if (moved)
	{
		/* Set the scroll bar values. */
		cell = GetCell(table, 0, 0);
		tmpRect = table->contentBounds;
		ZRectOffset(&tmpRect, (int16) -table->contentBounds.left, (int16) -table->contentBounds.top);
		bottomCell = GetCell(table, (int16) (tmpRect.right - 1), (int16) (tmpRect.bottom - 1));
		if( bottomCell == NULL )
		{
			//Prefix Warning: bottomCell could be NULL
			return;
		}
		if (table->flags & zTableBoxHorizScrollBar)
		{
			if (bottomCell->column == table->numColumns - 1)
			{
				ZScrollBarGetRange(table->hScrollBar, &min, &max);
				ZScrollBarSetValue(table->hScrollBar, max);
			}
			else
			{
				ZScrollBarSetValue(table->hScrollBar, cell->column);
			}
		}
		if (table->flags & zTableBoxVertScrollBar)
		{
			if (bottomCell->row == table->numRows - 1)
			{
				ZScrollBarGetRange(table->vScrollBar, &min, &max);
				ZScrollBarSetValue(table->vScrollBar, max);
			}
			else
			{
				ZScrollBarSetValue(table->vScrollBar, cell->row);
			}
		}
		
		DrawTable(table);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zoneclient\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zoneclient\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#include <BasicATL.h>


#if 0
//!! do we want any of this?
#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zres.cpp ===
/*******************************************************************************

	ZRes.c
	
		Zone(tm) resource module.
		
		NOTE:
		1.	TEXT resources are returned with a terminating null byte; HOWEVER,
			the null byte is not included in the resource size.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Thursday, March 16, 1995 03:58:26 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		07/18/99	HI		MAJOR MODIFICATION: Modified to user DLL's instead
								of ZRS files for resource. Many functions are not
								supported and return errors now.
    1       10/13/96    HI      Fixed compiler warnings.
	0		03/16/95	HI		Created.
	 
*******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "zone.h"
#include "zoneint.h"
#include "zonemem.h"
#include "zres.h"



#define I(object)			((IResource) (object))
#define Z(object)			((ZResource) (object))


typedef struct
{
	TCHAR			resFileName[128];
    HINSTANCE       resFile;
} IResourceType, *IResource;


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

ZResource ZResourceNew(void)
{
	IResource		obj;
	
	
	obj = (IResource) ZMalloc(sizeof(IResourceType));
	if (obj != NULL)
	{
		obj->resFileName[0] = 0;
        obj->resFile = NULL;
	}
	
	return(Z(obj));
}


ZError ZResourceInit(ZResource resource, TCHAR* fileName)
{
	IResource			obj = I(resource);
	ZError				err = zErrNone;


    lstrcpy(obj->resFileName, fileName);

	// Open resource DLL.
	obj->resFile = LoadLibrary( obj->resFileName );
	if ( obj->resFile == NULL )
		err = zErrFileNotFound;

	return err;
}


void ZResourceDelete(ZResource resource)
{
	IResource		obj = I(resource);
	

	if ( obj->resFile )
	{
		FreeLibrary( obj->resFile );
		obj->resFile = NULL;
	}
	ZFree(obj);
}


/*******************************************************************************
	NOT SUPPORTED ANYMORE
*******************************************************************************/
uint16 ZResourceCount(ZResource resource)
{
	return 0;
}


/*******************************************************************************
	NOT SUPPORTED ANYMORE
*******************************************************************************/
void* ZResourceGet(ZResource resource, uint32 resID, uint32* resSize, uint32* resType)
{
	return NULL;
}


/*******************************************************************************
	NOT SUPPORTED ANYMORE
*******************************************************************************/
uint32 ZResourceGetSize(ZResource resource, uint32 resID)
{
	return 0;
}


/*******************************************************************************
	NOT SUPPORTED ANYMORE
*******************************************************************************/
uint32 ZResourceGetType(ZResource resource, uint32 resID)
{
	return 0;
}


ZImage ZResourceGetImage(ZResource resource, uint32 resID)
{
	IResource		obj = I(resource);
	ZImage			image = NULL;
	
	
    if (obj->resFile != NULL)
	{
		image = ZImageCreateFromBMPRes( obj->resFile, (WORD) resID + 100, RGB( 0xFF, 0x00, 0xFF ) );
	}
	
	return (image);
}


ZAnimation ZResourceGetAnimation(ZResource resource, uint32 resID)
{
	IResource		obj = I(resource);
	ZAnimation		anim = NULL;
	
	
	if (obj->resFile != NULL)
	{
		anim = ZAnimationCreateFromFile( obj->resFileName, resID + 100);
	}
	
	return (anim);
}


/*******************************************************************************
	NOT SUPPORTED ANYMORE
*******************************************************************************/
ZSound ZResourceGetSound(ZResource resource, uint32 resID)
{
	return NULL;
}


/*******************************************************************************
	NOT SUPPORTED ANYMORE
*******************************************************************************/
TCHAR* ZResourceGetText(ZResource resource, uint32 resID)
{
	return NULL;
}


/*
	Resource type = zResourceTypeRectList.
		Format (stored as text):
			int16			numRectInList
			ZRect			rects[]
	
	Fills in the rect array with the contents of the specified resource.
	Returns the number of rects it filled in.
	
	The rects parameter must have been preallocated and large enough for
	numRects rects.
*/
int16 ZResourceGetRects(ZResource resource, uint32 resID, int16 numRects, ZRect* rects)
{
	IResource		obj = I(resource);
	int16			numStored = zErrResourceNotFound;
	int16			i, count;
	int32			numBytesRead;
	char*			str1;
	char*			str2;
	HRSRC			hRsrc = NULL;
	HGLOBAL			hData = NULL;
	
	
	if (obj->resFile != NULL)
	{
		hRsrc = FindResource( obj->resFile, MAKEINTRESOURCE( resID + 100 ), _T("RECT") );
		if ( hRsrc == NULL )
			goto Error;

		hData = LoadResource( obj->resFile, hRsrc );
		if ( hData == NULL )
			goto Error;

		str1 = (char*) LockResource( hData );
		if ( str1 == NULL )
			goto Error;

		if (str1 != NULL)
		{
			str2 = str1;
			
			/* Get the number of rectangles in the resource. */
			//Prefix Warning: Check sscanf return to make sure it initialized both variables.
			int iRet = sscanf(str2, "%hd%n", &count, &numBytesRead);
			if( iRet != 2 )
			{
				//Error reading the count and BytesRead
				goto Error;
			}
			str2 += numBytesRead;
			
			numStored = 0;
			
			if (count > 0)
			{
				if (count > numRects)
					count = numRects;
				
				for (i = 0; i < count; i++, numStored++)
				{
					if( sscanf(str2, "%hd%hd%hd%hd%n", &rects[i].left, &rects[i].top,
							&rects[i].right, &rects[i].bottom, &numBytesRead) != 5 )
					{
						//sscanf wasn't able to read all the data fields.
						goto Error;
					}
					str2 += numBytesRead;
				}
			}
		}
	}
	
	return (numStored);

Error:
	
	return 0;
}


void ZResourceHeaderEndian(ZResourceHeader* header)
{
	ZEnd32(&header->version);
	ZEnd32(&header->signature);
	ZEnd32(&header->fileDataSize);
	ZEnd32(&header->dirOffset);
}


void ZResourceDirEndian(ZResourceDir* dir)
{
	ZEnd32(&dir->count);
}


void ZResourceItemEndian(ZResourceItem* item)
{
	ZEnd32(&item->type);
	ZEnd32(&item->id);
	ZEnd32(&item->offset);
	ZEnd32(&item->size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zwindow.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZWindow.cpp
#include <stdlib.h>
#include <string.h>

#include "zoneint.h"
#include "zoneocx.h"
#include "memory.h"
#include "zonecli.h"
#include "zoneclires.h"

#include "zoneresids.h"


#define kMaxTalkOutputLen           16384

#define kMinTimeBetweenChats		500
#define kMaxNumChatQueue			10
#define kChatQueueTimerID			0x1234


typedef struct {
	ZRect bounds;
	ZMessageFunc messageFunc;
	ZObject	object;
	void * userData;
} ZObjectI;


#ifdef ZONECLI_DLL

#define gModalWindow				(pGlobals->m_gModalWindow)
#define gModalParentWnd				(pGlobals->m_gModalParentWnd)
#define gWindowList					(pGlobals->m_gWindowList)

#else

// static variables
ZWindowI* gModalWindow = NULL;
HWND gModalParentWnd = NULL;
HWND gHWNDMainWindow = NULL;
HWND OCXHandle;
void *gWindowList = NULL; // Keep track of all windows created..

#endif

int ZOCXGraphicsWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* result);
LRESULT CALLBACK ZGraphicsWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT ZWindowDispatchProc(ZWindowI* pWindow, UINT msg, WPARAM wParam, LPARAM lParam);
void TalkWindowInputComplete(ZWindowI* pWindow);
static void ZWindowPlaceWindows(ZWindowI* pWindow);
static void ZWindowCalcWindowPlacement(ZWindowI* pWindow);
void CreateChatFont(void);
static int CALLBACK EnumFontFamProc(ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, int FontType, LPARAM lParam);


static uint32 ZWindowGetKeyState(TCHAR c);

// offset in private window data used by controls for pointer to ZWindowI structure
#define GWL_WINDOWPOINTER DLGWINDOWEXTRA
#define GWL_BYTESEXTRA (DLGWINDOWEXTRA+4)

// defines
#define ID_TALKOUTPUT 32767
#define ID_TALKINPUT 32766


/*
static void ClearAllMessageBoxes(ZWindowI* pWindow);
static int GetAvailMessageBox(ZWindowI* pWindow);
static void CloseAllMessageBoxes(ZWindowI* pWindow);
static void ShowMessageBox(ZMessageBoxType* mbox, HWND parent, TCHAR* title, TCHAR* text, DWORD flag);
static DWORD WINAPI ZMessageBoxThreadFunc(LPVOID param);
static INT_PTR CALLBACK ZMessageBoxDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
*/

//#include "chatfilter.h"
//#include "chatfilter.cpp"


//////////////////////////////////////////////////////////////////////////////////////
// Window Init/Term

// the window class we use for our "Zone" windows
const TCHAR* g_szWindowClass = _T("ZoneGraphicsWindowClass-Classic");

ZError ZWindowInitApplication()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return zErrGeneric;

	gWindowList = ZLListNew(NULL);

	/* Register the window class. */
	WNDCLASSEX wc;

	wc.cbSize = sizeof( wc );

	if (GetClassInfoEx(g_hInstanceLocal, g_szWindowClass, &wc) == FALSE)
	{
        wc.cbSize        = sizeof(wc);
		wc.style = CS_BYTEALIGNCLIENT | CS_DBLCLKS;
		wc.lpfnWndProc   = ZGraphicsWindowProc;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = GWL_BYTESEXTRA;
		wc.hInstance     = g_hInstanceLocal;
//		wc.hIcon         = LoadIcon(g_hInstanceLocal,MAKEINTRESOURCE(IDI_ZONE_ICON));
		wc.hIcon         = LoadIcon(pGlobals->gameDll,MAKEINTRESOURCE(IDI_ZONE_ICON));
		wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
		wc.hbrBackground = (HBRUSH) GetStockObject(NULL_BRUSH);
		wc.lpszMenuName  = NULL;
			
		wc.lpszClassName = g_szWindowClass;
        wc.hIconSm       = NULL;
			
		// we could be called more than once...
		if (!RegisterClassEx(&wc))
			goto Exit;
	}

	CreateChatFont();

	pGlobals->m_bBackspaceWorks = FALSE;

Exit:

	return zErrNone;
}

void ZWindowTermApplication()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return;

	if (pGlobals->m_chatFont)
		DeleteObject(pGlobals->m_chatFont);

	// comment this check out for now since it looks like
	// a crash to users.
#if 0 // hoon does not do this--press quit in the village login window!
	// users better have cleaned up windows
	ASSERT(ZLListCount(gWindowList,zLListAnyType) == 0);
#endif

	// Go through the list and manually delete all windows.
	{
		ZLListItem listItem;
		ZWindowI* pWindow;


		listItem = ZLListGetFirst(gWindowList, zLListAnyType);
		while (listItem != NULL)
		{
			pWindow = (ZWindowI*) ZLListGetData(listItem, NULL);
			ZLListRemove(gWindowList, listItem);
			if (pWindow)
			{
				ZWindowDelete((ZWindow) pWindow);
			}
			listItem = ZLListGetFirst(gWindowList, zLListAnyType);
		}
	}

	ZLListDelete(gWindowList);

	// Don't unregister window class.
//	UnregisterClass(g_szWindowClass,g_hInstanceLocal);
}


void CreateChatFont(void)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	int fontExists = FALSE;
	HDC hdc;


	if (!pGlobals)
		return;

	hdc = GetDC(GetDesktopWindow());
	EnumFontFamilies(hdc, _T("Verdana"), (FONTENUMPROC) EnumFontFamProc, (LPARAM) &fontExists);
	if (hdc)
		ReleaseDC(GetDesktopWindow(), hdc);
	if (fontExists)
	{
		pGlobals->m_chatFont = CreateFont(-11, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
				DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
				DEFAULT_PITCH | FF_DONTCARE, _T("Verdana"));
	}
	else
	{
		pGlobals->m_chatFont = NULL;
	}
}


static int CALLBACK EnumFontFamProc(ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, int FontType, LPARAM lParam)
{
	*(int*)lParam = TRUE;
	return 0;
}


static void ChatMsgListDeleteFunc( void* objectType, void* objectData )
{
	if ( objectData != NULL )
	{
		ZFree( (char*) objectData );
	}
}


//////////////////////////////////////////////////////////////////////////
// ZWindow

ZWindow ZLIBPUBLIC ZWindowNew(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*) new ZWindowI;


	if (!pGlobals)
		return NULL;

	pWindow->nType = zTypeWindow;
	pWindow->nControlCount = 0;  // used when creating controls
	pWindow->hWnd = NULL;
	pWindow->hWndTalkInput = NULL;
	pWindow->hWndTalkOutput = NULL;
	pWindow->hPaintDC = NULL;
	pWindow->defaultButton = NULL;
	pWindow->cancelButton = NULL;

	// add window to list of windows active and processed in our window proc
	ZLListAdd(gWindowList,NULL,pWindow,pWindow,zLListAddFirst);

	pWindow->objectList = ZLListNew(NULL);
	pWindow->objectFocused = NULL;

	pWindow->trackCursorMessageFunc = NULL;
	pWindow->trackCursorUserData = NULL;

//	ClearAllMessageBoxes(pWindow);

	pWindow->bIsLobbyWindow = FALSE;
	pWindow->bHasTyped = FALSE;

	// Create chat msg list.
	pWindow->chatMsgList = ZLListNew(ChatMsgListDeleteFunc);
	pWindow->lastChatMsgTime = 0;
	pWindow->chatMsgQueueTimerID = 0;

	// windows limit: can never create more than 65535 controls
	return (ZWindow)pWindow;
}

void   ZLIBPUBLIC ZWindowDelete(ZWindow window)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*)window;


	if (!pGlobals)
		return;

	if ( pWindow->chatMsgList != NULL )
	{
		ZLListDelete( pWindow->chatMsgList );
		pWindow->chatMsgList = NULL;
	}
	if ( pWindow->chatMsgQueueTimerID != 0 )
	{
		KillTimer( pWindow->hWnd, kChatQueueTimerID );
		pWindow->chatMsgQueueTimerID = 0;
	}

//	CloseAllMessageBoxes(pWindow);

	ASSERT(pWindow->nDrawingCallCount == 0);
	if (pWindow->nDrawingCallCount) DeleteDC(pWindow->hDC);

	if (pWindow->talkSection)
	{
		if (pWindow->hWndTalkOutput)
		{
			MyRemoveProp32(pWindow->hWndTalkOutput,_T("pWindow"));
			SetWindowLong(pWindow->hWndTalkOutput,GWL_WNDPROC,(LONG)pWindow->defaultTalkOutputWndProc);
			DestroyWindow(pWindow->hWndTalkOutput);
		}
		if (pWindow->hWndTalkInput)
		{
			MyRemoveProp32(pWindow->hWndTalkInput,_T("pWindow"));
			SetWindowLong(pWindow->hWndTalkInput,GWL_WNDPROC,(LONG)pWindow->defaultTalkInputWndProc);
			DestroyWindow(pWindow->hWndTalkInput);
		}
	}

	// remove the current window from our list of windows
	ZLListItem listItem = ZLListFind(gWindowList,NULL,pWindow,zLListFindForward);
	if (listItem)
		ZLListRemove(gWindowList,listItem);

	if (IsWindow(pWindow->hWnd))
	{
		if(pWindow->bIsLobbyWindow) // mdm 9.30.97
		{
			// Delete all the children of this window explicitely
			// because parent window will not actually get deleted
			HWND hwndChild, hwndDeadChild;
			hwndChild = GetWindow (pWindow->hWnd, GW_CHILD);
			while (hwndChild)
			{
				hwndDeadChild = hwndChild;
				hwndChild = ::GetWindow(hwndChild, GW_HWNDNEXT);
				if (IsWindow(hwndDeadChild))
					DestroyWindow(hwndDeadChild);
			}
		}
		else // Just destroy the window and so will go the children
			DestroyWindow(pWindow->hWnd);
	}
	if (pWindow == gModalWindow) {
		gModalWindow = NULL;
	}

	// users better have deleted all objects
	// ASSERT(ZLListCount(pWindow->objectList,zLListAnyType) == 0);
	ZLListDelete(pWindow->objectList);

	delete pWindow;
}

ZBool ZWindowEnumFunc(ZLListItem listItem, void *objectType, void *objectData, void* userData)
{
	ZWindowI* pWindow = (ZWindowI*)objectData;
	HWND parent, hWnd;


	ZPoint where;
	where.x = where.y = -1;

	// If this window or it's top-most parent is not the foreground window, then set cursor to nowhere.
	parent = pWindow->hWnd;
	while (hWnd = GetParent(parent))
		parent = hWnd;
	if (GetForegroundWindow() == pWindow->hWnd || GetForegroundWindow() == parent)
		ZGetCursorPosition(pWindow,&where);

	ZWindowSendMessageToAllObjects(pWindow, zMessageWindowIdle,&where,NULL);
	ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowIdle,&where,NULL,
		ZWindowGetKeyState(0),NULL,0L,pWindow->userData);

	if (pWindow->trackCursorMessageFunc) {
		ZSendMessage(pWindow,pWindow->trackCursorMessageFunc, zMessageWindowIdle,&where,NULL,
			ZWindowGetKeyState(0),NULL,0L,pWindow->trackCursorUserData);
	}

	// return FALSE to see that we get all items
	return FALSE;
}

void ZWindowIdle()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return;

	ZLListEnumerate(gWindowList,ZWindowEnumFunc,zLListAnyType,(void*)NULL, zLListFindForward);
}

/*
	Enumerate through all the windows and check whether the given message belongs
	to the window or the window's chat window. If so, handle it appropriately.
*/
BOOL ZWindowIsDialogMessage(LPMSG pmsg)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	ZLListItem listItem;
	ZWindowI* pWindow;


	if (pGlobals)
	{
		listItem = ZLListGetFirst(gWindowList, zLListAnyType);
		while (listItem != NULL)
		{
			pWindow = (ZWindowI*) ZLListGetData(listItem, NULL);
			if (pWindow)
			{
				if (pWindow->hWnd == pmsg->hwnd)
					return IsDialogMessage(pWindow->hWnd, pmsg);
				if (pWindow->hWndTalkInput && pWindow->hWndTalkInput == pmsg->hwnd)
					return IsDialogMessage(pWindow->hWnd, pmsg);
				if (pWindow->hWndTalkOutput && pWindow->hWndTalkOutput == pmsg->hwnd)
					return IsDialogMessage(pWindow->hWnd, pmsg);
			}
			listItem = ZLListGetNext(gWindowList, listItem, zLListAnyType);
		}
	}

	return FALSE;
}

LRESULT CALLBACK MyTalkOutputWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ZWindowI* pWindow = (ZWindowI*)MyGetProp32(hWnd,_T("pWindow"));

    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE) {
			SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}
	}
	default:
		break;
	}

	return CallWindowProc((ZONECLICALLWNDPROC)pWindow->defaultTalkOutputWndProc,hWnd,msg,wParam,lParam);
}

LRESULT CALLBACK MyTalkInputWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	ZWindowI* pWindow = (ZWindowI*)MyGetProp32(hWnd,_T("pWindow"));

    // we really DON'T need to convert this (millenium windows will never create 
    // the talk window.
    // But what the hell.

    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	switch (msg) {
	case WM_LBUTTONDOWN:
	case WM_KEYDOWN:
		// If has not typed in this before, clear window first.
		if (!pWindow->bHasTyped)
		{
			SetWindowText(hWnd, _T(""));
			pWindow->bHasTyped = TRUE;
		}
		break;
    case WM_IME_CHAR:
        // fall through to WM_CHAR--it's already been taken care of with ConvertMessage
	case WM_CHAR:
	{
		TCHAR c = (TCHAR)wParam;

		// grab the character message we need for moving from control to control
		if (c == _T('\r')) {
			// send off the data
            // PCWTODO: We should flag this more when we go to move stuff back for Z7.
			//TalkWindowInputComplete(pWindow);
			return 0L;
		}
		// grab the character message we need for moving from control to control
		if (c == _T('\t') || c == _T('\r') || c == VK_ESCAPE) {
			SendMessage(GetParent(hWnd), msg, wParam, lParam);
			return 0L;
		}
		if (c == _T('\b'))
			pGlobals->m_bBackspaceWorks = TRUE;
	}

	case WM_KEYUP:
		if (pGlobals->m_bBackspaceWorks == FALSE)
		{
			if (wParam == VK_BACK)
			{
				// emulate backspace
				DWORD startSel, endSel;
				SendMessage(hWnd, EM_GETSEL, (WPARAM)&startSel, (LPARAM)&endSel) ;
				if ( startSel == endSel)
				{
					SendMessage(hWnd, EM_SETSEL, startSel - ((DWORD) lParam & 0x000000FF), endSel);
				}
				SendMessage(hWnd, WM_CLEAR, 0, 0);
				
				return 0;
			}
		}
		break;
	default:
		break;
	}
	return CallWindowProc((ZONECLICALLWNDPROC)pWindow->defaultTalkInputWndProc,hWnd,msg,wParam,lParam);
}

ZError ZLIBPUBLIC ZRoomWindowInit(ZWindow window, ZRect* windowRect,
		int16 windowType, ZWindow parentWindow,
		TCHAR* title, ZBool visible, ZBool talkSection, ZBool center,
		ZMessageFunc windowProc, uint32 wantMessages, void* userData)
{
	return ZWindowLobbyInit(window, windowRect,
		windowType, parentWindow,
		title, visible, talkSection, center,
		windowProc, wantMessages, userData);
}


ZError ZLIBPUBLIC ZWindowInit(ZWindow window, ZRect* windowRect,
		int16 windowType, ZWindow parentWindow, 
		TCHAR* title, ZBool visible, ZBool talkSection, ZBool center,
		ZMessageFunc windowProc, uint32 wantMessages, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*)window;


	if (!pGlobals || pWindow == NULL)
		return zErrGeneric;

	/* set default member values */
	pWindow->messageFunc = windowProc;
	pWindow->userData = userData;
	pWindow->talkSection = talkSection;
	pWindow->wantMessages = wantMessages;
	pWindow->windowType = windowType;
	pWindow->parentWindow = (ZWindowI*)parentWindow;
	pWindow->isDialog = pWindow->windowType == zWindowDialogType;
	pWindow->isChild = !pWindow->isDialog && parentWindow;
	memset((void*)&pWindow->talkInputRect,0,sizeof(RECT));
	pWindow->talkOutputRect = pWindow->talkInputRect;
	pWindow->minTalkOutputRect = pWindow->talkInputRect;
	pWindow->fullWindowRect = pWindow->talkInputRect;
	pWindow->minFullWindowRect = pWindow->talkInputRect;
	pWindow->borderWidth = 0;
	pWindow->borderHeight = 0;
	pWindow->captionHeight = 0;
	pWindow->windowWidth = RectWidth(windowRect);
	pWindow->windowHeight = RectHeight(windowRect);
	pWindow->fullWindowRect.left = windowRect->left;
	pWindow->fullWindowRect.top = windowRect->top;

	if (talkSection) {
		// if talk section, then make extra room for a child edit box
		// place the edit box at the bottom and respond to the messages
		HDC hDC = GetDC(NULL);
		TEXTMETRIC tm;
		RECT talkOutputRect;
		RECT talkInputRect;
		int textHeight;

		GetTextMetrics(hDC,&tm);
		ReleaseDC(NULL,hDC);
		textHeight = tm.tmHeight + tm.tmExternalLeading;

		talkOutputRect.left = 0;
		talkOutputRect.top = 0;
		talkOutputRect.bottom = textHeight*7/2;
		talkInputRect.left = 0;
		talkInputRect.top = 0;
		talkInputRect.bottom = textHeight*3/2;
		
		// save the talk window rectangles for moving around
		pWindow->talkInputRect = talkInputRect;
		pWindow->talkOutputRect = talkOutputRect;
		pWindow->minTalkOutputRect = talkOutputRect;
	}

	{
		DWORD dwStyle = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
		DWORD dwExStyle = 0;

		if (pWindow->isChild) {
			dwStyle |= WS_CHILD;
		} else {
			dwStyle |= WS_POPUP;
			if (pWindow->isDialog) {
				dwExStyle = WS_EX_DLGMODALFRAME;
				if (parentWindow) {
					// popup coords are relative to screen add left corner of window
					RECT rectParent;
					HWND hWndParent = ZWindowWinGetWnd(parentWindow);
					GetWindowRect(hWndParent,&rectParent);
					OffsetRect(&pWindow->fullWindowRect,rectParent.left,rectParent.top);
				}
			}
		}


		{
			uint16 style = pWindow->windowType & (~zWindowNoCloseBox);

			if (style == zWindowStandardType || style == zWindowDialogType) {
				pWindow->captionHeight = GetSystemMetrics(SM_CYCAPTION);
			} else {
				pWindow->captionHeight = 0;
			}

			if (style == zWindowStandardType) {
				dwStyle |= WS_CAPTION | WS_BORDER | WS_MINIMIZEBOX;

				if (!(pWindow->windowType & zWindowNoCloseBox))
					dwStyle |= WS_SYSMENU;
			}

			if (style == zWindowDialogType) {
				dwStyle |= WS_CAPTION | WS_BORDER | WS_DLGFRAME;
			}

			if (style == zWindowPlainType) {
				dwStyle |= WS_BORDER;
			}

			if (style == zWindowChild) {
				dwStyle = WS_CHILD;
			}

			/* windows with talk sections can be resized */
			if (talkSection) {
				dwStyle |= WS_THICKFRAME;
			}
		}
		

		/* find the parent */
		HWND hWndParent = NULL;
		if (pWindow->parentWindow) {
			hWndParent = pWindow->parentWindow->hWnd;
		} else {
			hWndParent = NULL;
		}
		// give all children the gHWNDMainWindow parent if the have no parent
		if (!hWndParent && gHWNDMainWindow && 
			!(dwStyle & WS_POPUP)) {
			hWndParent = gHWNDMainWindow;
		}

		// JWS 9/14/99 for Millennium
		//#IF removed because in Millennium because games are singletons

		/* all null parents no longer go to the desktop, they will be the active x */
		/* main window */
		if (!hWndParent) {
			hWndParent = OCXHandle;
		}
	
		/* adjust the size of the window to account for the */
		/* frame width and height */
		if (dwStyle & WS_BORDER) {
			int dx;
			int dy;

			if (!pWindow->isDialog) {

				if (dwStyle & WS_THICKFRAME) {
					/* expand window to account for windows border */
					dx = ::GetSystemMetrics(SM_CXFRAME);
					dy = ::GetSystemMetrics(SM_CYFRAME);
				} else {
					/* expand window to account for windows border */
					dx = ::GetSystemMetrics(SM_CXBORDER);
					dy = ::GetSystemMetrics(SM_CYBORDER);
				}
			} else {

				/* expand window to account for windows border */
				dx = ::GetSystemMetrics(SM_CXDLGFRAME);
				dy = ::GetSystemMetrics(SM_CYDLGFRAME);
			}

			pWindow->borderWidth = dx*2;
			pWindow->borderHeight = dy*2;
		}

		/* calc all the window rectangles */
		ZWindowCalcWindowPlacement(pWindow);
		pWindow->minTalkOutputRect = pWindow->minTalkOutputRect;

		// should the window be centered?
		if (center) {
			int32 height = RectHeight(&pWindow->fullWindowRect);
			int32 width = RectWidth(&pWindow->fullWindowRect);
			// center in screen
			if (!parentWindow) {
				/* just set the screen coordinates */
				pWindow->fullWindowRect.left = (GetSystemMetrics(SM_CXSCREEN) - width)/2;
				pWindow->fullWindowRect.top = (GetSystemMetrics(SM_CYSCREEN) - height)/2;
			} else {
				// center in parent
				RECT rectParent;
				HWND hWndParent = ZWindowWinGetWnd(parentWindow);
				GetWindowRect(hWndParent,&rectParent);
				if (dwStyle & WS_POPUP) {
					/* need to be in screen coords */
					pWindow->fullWindowRect.left = (RectWidth(&rectParent) - width)/2;
					pWindow->fullWindowRect.top = (RectHeight(&rectParent) - height)/2;
					/* convert to screen coords */
					/* centering in whole window, not just client coords */
					pWindow->fullWindowRect.left += rectParent.left;
					pWindow->fullWindowRect.top += rectParent.top;
				} else {
					/* need to be in child coords */
					pWindow->fullWindowRect.left = (RectWidth(&rectParent) - width)/2;
					pWindow->fullWindowRect.top = (RectHeight(&rectParent) - height)/2;
				}
			}
			pWindow->fullWindowRect.right = pWindow->fullWindowRect.left + width;
			pWindow->fullWindowRect.bottom = pWindow->fullWindowRect.top + height;
		}

		pWindow->minFullWindowRect = pWindow->fullWindowRect;
		pWindow->hWnd = CreateWindowEx(dwExStyle,g_szWindowClass,title,dwStyle,
			0,0,0,0, hWndParent, NULL, g_hInstanceLocal, pWindow);
		/* the WM_MOVE, might screw this up on the 1st time */
		pWindow->fullWindowRect = pWindow->minFullWindowRect;

		if (!pWindow->hWnd) return zErrWindowSystemGeneric;
	}


	if (talkSection) {
		// create the talk edit child windows
		// the input window will be single line
		pWindow->hWndTalkInput = CreateWindow(_T("EDIT"),
			NULL,WS_CHILD|WS_BORDER|WS_VISIBLE|ES_LEFT|ES_AUTOHSCROLL|ES_WANTRETURN|ES_MULTILINE,
			0,0,0,0,
			pWindow->hWnd, (HMENU)ID_TALKINPUT, g_hInstanceLocal, NULL);
		MySetProp32(pWindow->hWndTalkInput,_T("pWindow"),(void*)pWindow);
		pWindow->defaultTalkInputWndProc = (WNDPROC)SetWindowLong(pWindow->hWndTalkInput,
									GWL_WNDPROC,(LONG)MyTalkInputWndProc);
        SendMessage(pWindow->hWndTalkInput, EM_LIMITTEXT, zMaxChatInput-1, 0 );
		if (pGlobals->m_chatFont)
			SendMessage(pWindow->hWndTalkInput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);

		// the output has a vscrollbar and is read only
		pWindow->hWndTalkOutput = CreateWindow(_T("EDIT"),
			NULL,WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|ES_LEFT|ES_MULTILINE|ES_AUTOVSCROLL,
			0,0,0,0,
			pWindow->hWnd, (HMENU)ID_TALKOUTPUT, g_hInstanceLocal, NULL);
		SendMessage(pWindow->hWndTalkOutput, EM_SETREADONLY, TRUE, 0);
		MySetProp32(pWindow->hWndTalkOutput,_T("pWindow"),(void*)pWindow);
		pWindow->defaultTalkOutputWndProc = (WNDPROC)SetWindowLong(pWindow->hWndTalkOutput,
									GWL_WNDPROC,(LONG)MyTalkOutputWndProc);
		if (pGlobals->m_chatFont)
			SendMessage(pWindow->hWndTalkOutput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);
	}

	/* calc rects and place all windows */
	ZWindowPlaceWindows(pWindow);

	if (visible) {
		ZWindowShow(window);
	}
	
	// grafport stuff
	pWindow->nDrawingCallCount = 0;
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowLobbyInit(ZWindow window, ZRect* windowRect,
		int16 windowType, ZWindow parentWindow,
		TCHAR* title, ZBool visible, ZBool talkSection, ZBool center,
		ZMessageFunc windowProc, uint32 wantMessages, void* userData)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*)window;


	if (!pGlobals)
		return zErrGeneric;

	/* set default member values */
	pWindow->bIsLobbyWindow = TRUE;
	pWindow->messageFunc = windowProc;
	pWindow->userData = userData;
	pWindow->talkSection = talkSection;
	pWindow->wantMessages = wantMessages;
	pWindow->windowType = windowType;
	pWindow->parentWindow = (ZWindowI*)parentWindow;
	pWindow->isDialog = pWindow->windowType & zWindowDialogType;
	pWindow->isChild = !pWindow->isDialog && parentWindow;
	memset((void*)&pWindow->talkInputRect,0,sizeof(RECT));
	pWindow->talkOutputRect = pWindow->talkInputRect;
	pWindow->minTalkOutputRect = pWindow->talkInputRect;
	pWindow->fullWindowRect = pWindow->talkInputRect;
	pWindow->minFullWindowRect = pWindow->talkInputRect;
	pWindow->borderWidth = 0;
	pWindow->borderHeight = 0;
	pWindow->captionHeight = 0;
	pWindow->windowWidth = RectWidth(windowRect);
	pWindow->windowHeight = RectHeight(windowRect);
//	pWindow->fullWindowRect.left = windowRect->left;
//	pWindow->fullWindowRect.top = windowRect->top;
	pWindow->fullWindowRect.left = 0;
	pWindow->fullWindowRect.top = 0;

	if (talkSection) 
	{
		// if talk section, then make extra room for a child edit box
		// place the edit box at the bottom and respond to the messages
		HDC hDC = GetDC(NULL);
		TEXTMETRIC tm;
		RECT talkOutputRect;
		RECT talkInputRect;
		int textHeight;


		GetTextMetrics(hDC,&tm);
		ReleaseDC(NULL,hDC);
		textHeight = tm.tmHeight + tm.tmExternalLeading;

		talkInputRect.left = 0;
		talkInputRect.top = 0;
		talkInputRect.bottom = textHeight*3/2;
		talkOutputRect.left = 0;
		talkOutputRect.top = 0;
//		talkOutputRect.bottom = textHeight*7/2;
		talkOutputRect.bottom = pGlobals->m_screenHeight - pWindow->windowHeight - (talkInputRect.bottom - talkInputRect.top);
		
		// save the talk window rectangles for moving around
		pWindow->talkInputRect = talkInputRect;
		pWindow->talkOutputRect = talkOutputRect;
		pWindow->minTalkOutputRect = talkOutputRect;
	}

//	{
		DWORD dwStyle = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
		DWORD dwExStyle = 0;

		pWindow->isChild = 1;


/*
		if (pWindow->isChild) {
			dwStyle |= WS_CHILD;
		} else {
			dwStyle |= WS_POPUP;
			if (pWindow->isDialog) {
				dwExStyle = WS_EX_DLGMODALFRAME;
				if (parentWindow) {
					// popup coords are relative to screen add left corner of window
					RECT rectParent;
					HWND hWndParent = ZWindowWinGetWnd(parentWindow);
					GetWindowRect(hWndParent,&rectParent);
					OffsetRect(&pWindow->fullWindowRect,rectParent.left,rectParent.top);
				}
			}
		}



		{
			uint16 style = pWindow->windowType & (~zWindowNoCloseBox);

			if (style == zWindowStandardType || style == zWindowDialogType) {
				pWindow->captionHeight = GetSystemMetrics(SM_CYCAPTION);
			} else {
				pWindow->captionHeight = 0;
			}

			if (style == zWindowStandardType) {
				dwStyle |= WS_CAPTION | WS_BORDER | WS_MINIMIZEBOX;

				if (!(pWindow->windowType & zWindowNoCloseBox))
					dwStyle |= WS_SYSMENU;
			}

			if (style == zWindowDialogType) {
				dwStyle |= WS_CAPTION | WS_BORDER | WS_DLGFRAME;
			}

			if (style == zWindowPlainType) {
				dwStyle |= WS_BORDER;
			}
*/

			/* windows with talk sections can be resized */
/*
			if (talkSection) {
				dwStyle |= WS_THICKFRAME;
			}
*/
//	}
		

		/* find the parent */
//		HWND hWndParent;
//		if (pWindow->parentWindow) {
//			hWndParent = pWindow->parentWindow->hWnd;
//		} else {
//			hWndParent = NULL;
//		}
		// give all children the gHWNDMainWindow parent if the have no parent
//		if (!hWndParent && gHWNDMainWindow && 
//			!(dwStyle & WS_POPUP)) {
//			hWndParent = gHWNDMainWindow;
//		}

	
		/* adjust the size of the window to account for the */
		/* frame width and height */
/*
		if (dwStyle & WS_BORDER) {
			int dx;
			int dy;

			if (!pWindow->isDialog) {

				if (dwStyle & WS_THICKFRAME) {
					// expand window to account for windows border 
					dx = ::GetSystemMetrics(SM_CXFRAME);
					dy = ::GetSystemMetrics(SM_CYFRAME);
				} else {
					// expand window to account for windows border 
					dx = ::GetSystemMetrics(SM_CXBORDER);
					dy = ::GetSystemMetrics(SM_CYBORDER);
				}
			} else {

				// expand window to account for windows border 
				dx = ::GetSystemMetrics(SM_CXDLGFRAME);
				dy = ::GetSystemMetrics(SM_CYDLGFRAME);
			}

			pWindow->borderWidth = dx*2;
			pWindow->borderHeight = dy*2;
		}
*/
		/* calc all the window rectangles */
		ZWindowCalcWindowPlacement(pWindow);
//		pWindow->minTalkOutputRect = pWindow->minTalkOutputRect;


		RECT rectParent;
		POINT	topLeft;
		topLeft.x = 0;
		topLeft.y = 0;
		DWORD result;
#if 0 // Not needed anymore?
		HWND hWndParent = GetParent(OCXHandle);
		if (!hWndParent)
		{
			MessageBox(NULL,_T("No Parent"),_T("Notice"),MB_OK);
		}
		else
		{
			result = MapWindowPoints(hWndParent,OCXHandle,&topLeft,1);

//			GetClientRect(OCXHandle,&rectParent);
			OffsetRect(&pWindow->fullWindowRect,LOWORD(result),HIWORD(result));
		}
#endif

		// should the window be centered?
//		if (center) {
///			int32 height = RectHeight(&pWindow->fullWindowRect);
///			int32 width = RectWidth(&pWindow->fullWindowRect);

			// center in screen
//			if (!parentWindow) {
//				/* just set the screen coordinates */
//				pWindow->fullWindowRect.left = (GetSystemMetrics(SM_CXSCREEN) - width)/2;
//				pWindow->fullWindowRect.top = (GetSystemMetrics(SM_CYSCREEN) - height)/2;
//			} else {
				// center in parent
///				RECT rectParent;
//				HWND hWndParent = ZWindowWinGetWnd(parentWindow);
///				GetWindowRect(OCXHandle,&rectParent);
//				if (dwStyle & WS_POPUP) {
					/* need to be in screen coords */
///					pWindow->fullWindowRect.left = (RectWidth(&rectParent) - width)/2;
///					pWindow->fullWindowRect.top = (RectHeight(&rectParent) - height)/2;
					/* convert to screen coords */
					/* centering in whole window, not just client coords */
///					pWindow->fullWindowRect.left += rectParent.left;
///					pWindow->fullWindowRect.top += rectParent.top;
//				} else {
					/* need to be in child coords */
//					pWindow->fullWindowRect.left = (RectWidth(&rectParent) - width)/2;
//					pWindow->fullWindowRect.top = (RectHeight(&rectParent) - height)/2;
//				}
//			}
///			pWindow->fullWindowRect.right = pWindow->fullWindowRect.left + width;
///			pWindow->fullWindowRect.bottom = pWindow->fullWindowRect.top + height;
//		}

		pWindow->minFullWindowRect = pWindow->fullWindowRect;


		pWindow->hWnd = OCXHandle;
		SetLastError(0);
		long err = SetWindowLong(OCXHandle, GWL_WINDOWPOINTER,(LONG)pWindow);
		if (err == 0)
		{
			// we *might* have failed, if there happened to be 0 in the previous long of the window, we have to check 
			// error condition to make sure...
			if (GetLastError())
			{
				// error!
				return zErrWindowSystemGeneric;
			}
		}
		
//		pWindow->hWnd = CreateWindowEx(dwExStyle,g_szWindowClass,(const char*)title,dwStyle,
//			0,0,0,0, hWndParent, NULL, g_hInstanceLocal, pWindow);
		/* the WM_MOVE, might screw this up on the 1st time */


//		pWindow->fullWindowRect = pWindow->minFullWindowRect;

		if (!pWindow->hWnd) return zErrWindowSystemGeneric;
//	}


	if (talkSection) 
	{
		// create the talk edit child windows
		// the input window will be single line
		pWindow->hWndTalkInput = CreateWindow(_T("EDIT"),
			NULL,WS_CHILD|WS_BORDER|WS_VISIBLE|ES_LEFT|ES_AUTOHSCROLL|ES_WANTRETURN|ES_MULTILINE,
			0,0,0,0,
			pWindow->hWnd, (HMENU)ID_TALKINPUT, g_hInstanceLocal, NULL);

		//Prefix Warning:  Don't call SetWindowLong will a possibly NULL pointer.
		if(!pWindow->hWndTalkInput)
            return zErrOutOfMemory;

		MySetProp32(pWindow->hWndTalkInput,_T("pWindow"),(void*)pWindow);

        pWindow->defaultTalkInputWndProc = (WNDPROC) SetWindowLong(pWindow->hWndTalkInput,
		    GWL_WNDPROC, (LONG) MyTalkInputWndProc);

        SendMessage(pWindow->hWndTalkInput, EM_LIMITTEXT, zMaxChatInput-1, 0 );
		if (pGlobals->m_chatFont)
			SendMessage(pWindow->hWndTalkInput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);

		// Enter default text into the input window.
        // PCWTODO: Strings: if we even care.
		SetWindowText(pWindow->hWndTalkInput, _T("[ Type here to talk to others in the room ]"));
		SendMessage(pWindow->hWndTalkInput, EM_SETSEL, 0, -1 );

		// the output has a vscrollbar and is read only
		pWindow->hWndTalkOutput = CreateWindow(_T("EDIT"),
			NULL,WS_CHILD|WS_BORDER|WS_VISIBLE|WS_VSCROLL|ES_LEFT|ES_MULTILINE|ES_AUTOVSCROLL,
			0,0,0,0,
			pWindow->hWnd, (HMENU)ID_TALKOUTPUT, g_hInstanceLocal, NULL);

        if(!pWindow->hWndTalkOutput)
        {
            DestroyWindow(pWindow->hWndTalkInput);
            return zErrOutOfMemory;
        }

		SendMessage(pWindow->hWndTalkOutput, EM_SETREADONLY, TRUE, 0);
		MySetProp32(pWindow->hWndTalkOutput,_T("pWindow"),(void*)pWindow);
		pWindow->defaultTalkOutputWndProc = (WNDPROC)SetWindowLong(pWindow->hWndTalkOutput,
									GWL_WNDPROC,(LONG)MyTalkOutputWndProc);
		if (pGlobals->m_chatFont)
			SendMessage(pWindow->hWndTalkOutput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);
	}

	/* calc rects and place all windows */
	ZWindowPlaceWindows(pWindow);

	if (visible) 
	{
		ZWindowShow(window);
	}
	
	// grafport stuff
	pWindow->nDrawingCallCount = 0;
	return zErrNone;
}


void   ZLIBPUBLIC ZWindowGetRect(ZWindow window, ZRect *windowRect)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	RECT rect;

	/* get current window position */
	GetWindowRect(pWindow->hWnd,&rect);
	rect.bottom = rect.top + pWindow->windowHeight;
	rect.right = rect.left + pWindow->windowWidth;

	/* offset the rectangle to its parent coordinates */
	if (pWindow->parentWindow) {
		/* see that child is in parent coords */
		ZRect rectParent;
		ZWindowGetRect(pWindow->parentWindow,&rectParent);
		OffsetRect(&rect,-rectParent.left,-rectParent.top);
	}

	WRectToZRect(windowRect,&rect);
}

ZError ZLIBPUBLIC ZWindowSetRect(ZWindow window, ZRect *windowRect)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	/* set top left corner */
	pWindow->fullWindowRect.top = windowRect->top;
	pWindow->fullWindowRect.left = windowRect->left;

	/* set height/width of our window rect */
	pWindow->windowWidth = RectWidth(windowRect);
	pWindow->windowHeight = RectHeight(windowRect);

	/* recalc placement of windows */
	ZWindowCalcWindowPlacement(pWindow);
	ZWindowPlaceWindows(pWindow);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowMove(ZWindow window, int16 left, int16 top)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	BOOL bOk = SetWindowPos(pWindow->hWnd, NULL,left,top,
		0,0,SWP_NOSIZE|SWP_NOZORDER);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowSize(ZWindow window, int16 width, int16 height)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	pWindow->windowWidth = width;
	pWindow->windowHeight = height;

	ZWindowCalcWindowPlacement(pWindow);
	ZWindowPlaceWindows(pWindow);

	/* for the Zone API, a invalidate is done */
	ZWindowInvalidate(window,NULL);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowShow(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	ShowWindow(pWindow->hWnd, SW_SHOWNORMAL);

	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowHide(ZWindow window)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*)window;


	if (!pGlobals)
		return zErrGeneric;

	ShowWindow(pWindow->hWnd, SW_HIDE);

	if (pWindow == gModalWindow) {
		gModalWindow = NULL;
	}

	return zErrNone;
}

ZBool ZLIBPUBLIC ZWindowIsVisible(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	return IsWindowVisible(pWindow->hWnd);
}

ZBool ZLIBPUBLIC ZWindowIsEnabled(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	return IsWindowEnabled(pWindow->hWnd);
}

ZError ZLIBPUBLIC ZWindowEnable(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	EnableWindow(pWindow->hWnd, TRUE);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowDisable(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	EnableWindow(pWindow->hWnd, FALSE);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowSetMouseCapture(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	SetCapture(pWindow->hWnd);

	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowClearMouseCapture(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	ReleaseCapture();

	return zErrNone;
}

void ZLIBPUBLIC ZWindowGetTitle(ZWindow window, TCHAR *title, uint16 len)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	GetWindowText(pWindow->hWnd,title,len);
}

ZError ZLIBPUBLIC ZWindowSetTitle(ZWindow window, TCHAR *title)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	SetWindowText(pWindow->hWnd,title);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowBringToFront(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	ZWindowShow(window);
	BringWindowToTop(pWindow->hWnd);
	return zErrNone;
}

ZError ZLIBPUBLIC ZWindowDraw(ZWindow window, ZRect *windowRect)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	RECT* pRect;
	RECT rect;
	if (windowRect) {
		ZRectToWRect(&rect,windowRect);
		pRect = &rect;
	} else {
		pRect = NULL;
	}
	InvalidateRect(pWindow->hWnd,pRect,TRUE);
	return zErrNone;
}

void ZLIBPUBLIC ZWindowInvalidate(ZWindow window, ZRect* invalRect)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	RECT* pRect;
	RECT rect;
	if (invalRect) {
		ZRectToWRect(&rect,invalRect);
		pRect = &rect;
	} else {
		pRect = NULL;
	}
	InvalidateRect(pWindow->hWnd,pRect,TRUE);
}

void ZLIBPUBLIC ZWindowValidate(ZWindow window, ZRect* invalRect)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	RECT* pRect;
	RECT rect;
	if (invalRect) {
		ZRectToWRect(&rect,invalRect);
		pRect = &rect;
	} else {
		pRect = NULL;
	}
	ValidateRect(pWindow->hWnd,pRect);
}


static void ZWindowPlaceWindows(ZWindowI* pWindow)
{
	// Do not move lobby window around.
	if (!pWindow->bIsLobbyWindow)
	{
		SetWindowPos(pWindow->hWnd, NULL, pWindow->fullWindowRect.left,
				pWindow->fullWindowRect.top, 
				RectWidth(&pWindow->fullWindowRect), 
				RectHeight(&pWindow->fullWindowRect),
				SWP_NOZORDER);
	}

	// could be coming through during the CreateWindow of the main window
	// the talk windows may not exist.
	if (pWindow->talkSection && pWindow->hWndTalkInput) {
		SetWindowPos(pWindow->hWndTalkInput, NULL, pWindow->talkInputRect.left,
				pWindow->talkInputRect.top, 
				RectWidth(&pWindow->talkInputRect),
				RectHeight(&pWindow->talkInputRect) + 2, /* leave no space in window */
				SWP_NOZORDER);

		SetWindowPos(pWindow->hWndTalkOutput, NULL, pWindow->talkOutputRect.left,
				pWindow->talkOutputRect.top,
				RectWidth(&pWindow->talkOutputRect),
				RectHeight(&pWindow->talkOutputRect),
				SWP_NOZORDER);
	}
}

static void ZWindowCalcWindowPlacement(ZWindowI* pWindow)
{
	int borderWidth = pWindow->borderWidth;
	int borderHeight = pWindow->borderHeight;
	int	captionHeight = pWindow->captionHeight;
	int windowWidth = pWindow->windowWidth;
	int windowHeight = pWindow->windowHeight;

	RECT fullWindowRect = pWindow->fullWindowRect;
	RECT talkOutputRect = pWindow->talkOutputRect;
	RECT talkInputRect = pWindow->talkInputRect;

#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	RECT r;


	if (!pGlobals)
		return;

	fullWindowRect.right = fullWindowRect.left + windowWidth + borderWidth;
	fullWindowRect.bottom = fullWindowRect.top + borderHeight + captionHeight +
			windowHeight + (pWindow->talkSection ? 
					RectHeight(&talkInputRect) + RectHeight(&talkOutputRect): 0);

	if (pWindow->talkSection) {
		int	originalHeight;

		/* add 1 in various places to get by the 1 pixel border in the text */
		/* box, just let it be drawn outside */
		originalHeight = RectHeight(&pWindow->talkOutputRect);
		talkOutputRect.left = -1;
		talkOutputRect.top = windowHeight;
		talkOutputRect.right = talkOutputRect.left + windowWidth + 2;
		talkOutputRect.bottom = talkOutputRect.top + originalHeight;
								

		originalHeight = RectHeight(&pWindow->talkInputRect);
		talkInputRect.left = talkOutputRect.left;
		talkInputRect.top = talkOutputRect.bottom - 1;
		talkInputRect.right = talkOutputRect.right;

#if 0	// Not needed anymor.
		//	If the parent is the OCX, then we need to move the talk
		//	output box over to make room for the grab handle.
		if (pWindow->bIsLobbyWindow)
		{
			int sizeBoxWidth = GetSystemMetrics(SM_CXVSCROLL);
			talkInputRect.right = talkOutputRect.right - sizeBoxWidth;
		}
#endif

		talkInputRect.bottom = talkInputRect.top + originalHeight;

		pWindow->talkOutputRect = talkOutputRect;
		pWindow->talkInputRect = talkInputRect;
	}
	
	pWindow->fullWindowRect = fullWindowRect;

	GetWindowRect(OCXHandle, &r);
	pGlobals->m_screenWidth = r.right - r.left;
	pGlobals->m_screenHeight = r.bottom - r.top;
}

/* called from our window proc for windows with talk and resize */
static BOOL ZWindowHandleSizeMessage(ZWindowI* pWindow)
{
	/* if this is a talkSection window and if this is not during CreateWindow */
	/* then resizes our stuff */
	if (pWindow->talkSection && RectHeight(&pWindow->fullWindowRect)) {
		RECT rect;
		int windowHeightChange;
		int talkOutputHeight;
		GetWindowRect(pWindow->hWnd,&rect);
		windowHeightChange = RectHeight(&rect) - RectHeight(&pWindow->fullWindowRect);

		if (windowHeightChange) {
			talkOutputHeight = RectHeight(&pWindow->talkOutputRect) + windowHeightChange;
			pWindow->talkOutputRect.bottom = pWindow->talkOutputRect.top + talkOutputHeight;
			ZWindowCalcWindowPlacement(pWindow);
			ZWindowPlaceWindows(pWindow);
		}

		return TRUE;
	}
	return FALSE;
}


void ZLIBPUBLIC ZWindowTalk(ZWindow window, _TUCHAR* from, _TUCHAR* talkMessage)
{
    /*
	ZWindowI* pWindow = (ZWindowI*)window;
	TCHAR szTemp[zMaxChatInput + 100];
	static _TUCHAR *strNull = (_TUCHAR*)_T("");
    DWORD selStart, selEnd;


	if (!from)
		from = strNull;

	// filter text.
//	FilterOutputChatText((char*) talkMessage, lstrlen((char*) talkMessage));

    wsprintf(szTemp,_T("\r\n%s> %s"),from,talkMessage);

    // get the top visible line number.
    long firstLine = SendMessage( pWindow->hWndTalkOutput, EM_GETFIRSTVISIBLELINE, 0, 0 );

    // get current selections
    SendMessage( pWindow->hWndTalkOutput, EM_GETSEL, (WPARAM) &selStart, (LPARAM) &selEnd );
    
    //get the bottom visible line number.
    //Use the last characters position (which is in the last line) to determine whether
    //it is still visible; ie, last line is visible.
    RECT r;
    SendMessage( pWindow->hWndTalkOutput, EM_GETRECT, 0, (LPARAM) &r );
    DWORD lastCharPos = SendMessage( pWindow->hWndTalkOutput, EM_POSFROMCHAR,
            GetWindowTextLength( pWindow->hWndTalkOutput ) - 1, 0 );
    POINTS pt = MAKEPOINTS( lastCharPos );

	// place text at end of output edit box....
	SendMessage( pWindow->hWndTalkOutput, EM_SETSEL, (WPARAM)(INT)32767, (LPARAM)(INT)32767 );
	SendMessage( pWindow->hWndTalkOutput, EM_REPLACESEL, 0, (LPARAM)(LPCSTR)szTemp );

	//clear top characters of the output box if edit box size > 4096 
	int len = GetWindowTextLength( pWindow->hWndTalkOutput );
	if ( len > kMaxTalkOutputLen )
    {
        // Delete top lines.

        long cutChar = len - kMaxTalkOutputLen;
        long cutLine = SendMessage( pWindow->hWndTalkOutput, EM_LINEFROMCHAR, cutChar, 0 );
        long cutLineIndex = SendMessage( pWindow->hWndTalkOutput, EM_LINEINDEX, cutLine, 0 );

        // if cut off char is not beginning of line, then cut the whole line.
        // get char index to the next line.
        if ( cutLineIndex != cutChar )
        {
            // make sure current cut line is not the last line.
            if ( cutLine < SendMessage( pWindow->hWndTalkOutput, EM_GETLINECOUNT, 0, 0 ) )
                cutLineIndex = SendMessage( pWindow->hWndTalkOutput, EM_LINEINDEX, cutLine + 1, 0 );
        }

        //NOTE: WM_CUT and WM_CLEAR doesn't seem to work with EM_SETSEL selected text.
        //Had to use EM_REPLACESEL with a null char to cut the text out.
        // select lines to cut and cut them out.
        char p = '\0';
        SendMessage( pWindow->hWndTalkOutput, EM_SETSEL, 0, cutLineIndex );
        SendMessage( pWindow->hWndTalkOutput, EM_REPLACESEL, 0, (LPARAM) &p );
	}

    // if the last line was visible, then keep the last line visible
    //otherwise, remain at the same location w/o scrolling to show the last line.
    if ( pt.y < r.bottom )
    {
        // keep the last line visible.
        SendMessage( pWindow->hWndTalkOutput, EM_SETSEL, 32767, 32767 );
        SendMessage( pWindow->hWndTalkOutput, EM_SCROLLCARET, 0, 0 );
    }
    else
    {
        SendMessage( pWindow->hWndTalkOutput, EM_SETSEL, 0, 0 );
        SendMessage( pWindow->hWndTalkOutput, EM_SCROLLCARET, 0, 0 );
        SendMessage( pWindow->hWndTalkOutput, EM_LINESCROLL, 0, firstLine );
    }

    // restore selection
    SendMessage( pWindow->hWndTalkOutput, EM_SETSEL, (WPARAM) selStart, (LPARAM) selEnd );
    */
}

void ZLIBPUBLIC ZWindowModal(ZWindow window)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return;

	gModalWindow = (ZWindowI*)window;

	HWND hWndParent = ((ZWindowI*) gModalWindow)->hWnd;
	HWND hWnd;
	while (hWnd = GetParent(hWndParent)) {
		hWndParent = hWnd;
	}

	gModalParentWnd = hWndParent;
}

void ZLIBPUBLIC ZWindowNonModal(ZWindow window)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return;

	gModalWindow = NULL;
	gModalParentWnd = NULL;
}
void ZLIBPUBLIC ZWindowSetDefaultButton(ZWindow window, ZButton button)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	ZButtonSetDefaultButton(button);
	pWindow->defaultButton = button;
}

void ZLIBPUBLIC ZWindowSetCancelButton(ZWindow window, ZButton button)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	pWindow->cancelButton = button;
}

void ZLIBPUBLIC ZGetCursorPosition(ZWindow window, ZPoint* point)
	/*
		Returns the location of the cursor in the local coordinates of
		the given grafPort.
	*/
{
	ZWindowI* pWindow = (ZWindowI*)window;

	POINT wpoint;

	GetCursorPos(&wpoint);
	ScreenToClient(pWindow->hWnd,&wpoint);
	WPointToZPoint(point,&wpoint);
}


HDC ZWindowWinGetPaintDC(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	return pWindow->hPaintDC;
}       

HWND ZWindowWinGetWnd(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	return pWindow->hWnd;
}       

uint16 ZWindowWinGetNextControlID(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	return pWindow->nControlCount++;
}       


// we don't care
#if 0 

static VOID ChatMsgListCallbackProc( HWND hWnd, UINT uMsg, UINT idEvent, DWORD dwTime )
{
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	ZWindowI* pWindow = (ZWindowI*)GetWindowLong(hWnd,GWL_WINDOWPOINTER);
	char szTemp[ zMaxChatInput + 1 ];


	DWORD diff = dwTime - pWindow->lastChatMsgTime;
	int32 count = ZLListCount( pWindow->chatMsgList, zLListAnyType );

	if ( diff > kMinTimeBetweenChats && count > 0 )
	{
		szTemp[0] = '\0';

		ZLListItem item = ZLListGetFirst( pWindow->chatMsgList, zLListAnyType );
		if ( item )
		{
			char* pChat = (char*) ZLListGetData( item, NULL );
			lstrcpy( szTemp, pChat );
			ZLListRemove( pWindow->chatMsgList, item );
			count--;
		}

		if ( szTemp[0] != 0 )
		{
			// send message off to client
			ZSendMessage( pWindow, pWindow->messageFunc, zMessageWindowTalk, NULL, NULL, NULL,
					(void*)szTemp, lstrlen(szTemp) + 1 , pWindow->userData );

			pWindow->lastChatMsgTime = GetTickCount();
		}
	}

	if ( count <= 0 )
	{
		KillTimer( pWindow->hWnd, kChatQueueTimerID );
		pWindow->chatMsgQueueTimerID = 0;
	}
}
		

// internal routine to be called when talk message window
// receives user input
// checks for a return and if so informs client of the line ready.
void TalkWindowInputComplete(ZWindowI* pWindow)
{
    char szTemp[zMaxChatInput+1];
	int len;


	// get all the text
    len = GetWindowText(pWindow->hWndTalkInput,szTemp,zMaxChatInput);

	if (len > 0)
	{
        szTemp[len] = '\0';

		// filter input text.
//		FilterInputChatText(szTemp, len);

		DWORD diff = GetTickCount() - pWindow->lastChatMsgTime;			// possible rollover case but will happen only once. 5 - 0xFFFFFFFFD.
		int32 count = ZLListCount( pWindow->chatMsgList, zLListAnyType );

		if ( diff <= kMinTimeBetweenChats || count > 0 )
		{
			// queue msg only if less than max num queue. otherwise, drop the msg into the blackhole.
			if ( count < kMaxNumChatQueue )
			{
				// queue up the msg.
				char* pMsg = (char*) ZMalloc( lstrlen(szTemp) + 1 );
				lstrcpy( pMsg, szTemp );
				ZLListAdd( pWindow->chatMsgList, NULL, zLListNoType, pMsg, zLListAddLast );

				// create timer.
				pWindow->chatMsgQueueTimerID = SetTimer( pWindow->hWnd, kChatQueueTimerID, kMinTimeBetweenChats * ( count + 1 ), (TIMERPROC) ChatMsgListCallbackProc );
			}

			// assume no msg to send.
			szTemp[0] = '\0';

/*
			// determine whether time has passed enough to send a chat msg.
			if ( diff > kMinTimeBetweenChats )
			{
				ZLListItem item = ZLListGetFirst( pWindow->chatMsgList, zLListAnyType );
				if ( item )
				{
					char* pChat = (char*) ZLListGetData( item, NULL );
					lstrcpy( szTemp, pChat );
					ZLListRemove( pWindow->chatMsgList, item );
				}
			}
*/
		}

		if ( szTemp[0] != 0 )
		{
			// send message off to client
			ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowTalk,NULL,NULL,NULL,
				(void*)szTemp,lstrlen(szTemp)+1,pWindow->userData);

			pWindow->lastChatMsgTime = GetTickCount();
		}

		// clear the window text...
		SetWindowText(pWindow->hWndTalkInput,"");
	}
}
#endif // 0


int ZInternalGraphicsWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* result)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*)GetWindowLong(hWnd,GWL_WINDOWPOINTER);

    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }

	*result = 0;
	
	if (!pGlobals)
		goto NotHandledExit;

	/* for all our Zone windows, see that they will always */
	/* get a button up for each button down */
	switch (msg) {
	case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
		SetCapture(hWnd);
		break;
	case WM_LBUTTONUP:
		if (GetCapture() == hWnd) {
			ReleaseCapture();
		}
		break;
	default:
		// continue
		break;
	}

	// don't process any messages if another window in same window tree is modal
	// process only that windows messages
	// process all WM_PAINT messages
#if 1
	if (gModalWindow && 
			(hWnd == gModalParentWnd || IsChild(gModalParentWnd,hWnd)) &&
			!IsChild(((ZWindowI*)gModalWindow)->hWnd,hWnd) &&
			hWnd != ((ZWindowI*)gModalWindow)->hWnd) {
		// modal dialog, some messages we will eat for some windows
		switch (msg) {
		case WM_ACTIVATE:
		case WM_MOUSEACTIVATE:
		case WM_LBUTTONUP:
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
		case WM_CHAR:
		case WM_COMMAND:
		case WM_HSCROLL:
		case WM_VSCROLL:
			// skip normal procesing
			// note: might result in some edit box character being added
			// without the window knowing....
			goto NotHandledExit;
		default:
			// continue
			break;
		}
	}
#endif
	switch (msg) {
	case WM_GETMINMAXINFO:
	{
		LPMINMAXINFO pInfo = (LPMINMAXINFO) lParam;
		if (!pWindow)
			goto NotHandledExit;
		int width = RectWidth(&pWindow->fullWindowRect);

		pInfo->ptMaxSize.x = width;
		pInfo->ptMinTrackSize.x = RectWidth(&pWindow->minFullWindowRect);
		pInfo->ptMinTrackSize.y = RectHeight(&pWindow->minFullWindowRect);
		pInfo->ptMaxTrackSize.x = RectWidth(&pWindow->minFullWindowRect);

		goto HandledExit;
	}
	case WM_SIZE:
	{
		uint16 width = LOWORD(lParam);
		uint16 height = HIWORD(lParam);
		WORD fwSizeType = wParam;
		if (!pWindow)
			goto NotHandledExit;
		if (fwSizeType == SIZE_MAXIMIZED || fwSizeType == SIZE_RESTORED)
		{
			if (ZWindowHandleSizeMessage(pWindow))
				goto HandledExit;
		}
		break;
	}
	case WM_MOVE:
	{
		uint16 xPos = LOWORD(lParam);
		uint16 yPos = HIWORD(lParam);
		RECT rect;
		int dx,dy;

		if (!pWindow)
			goto NotHandledExit;
		if (!pWindow->isChild) {
			/* if this is a popup... it could be relative to the parent... yuk */
			/* just offset the current rectangle so that the WM_SIZE message */
			/* will notice a size variance */
			GetWindowRect(pWindow->hWnd,&rect);
			dx = rect.left - pWindow->fullWindowRect.left;
			dy = rect.top - pWindow->fullWindowRect.top;
			OffsetRect(&pWindow->fullWindowRect,dx,dy);
		}
		goto HandledExit;
		break;
	}
	case WM_CTLCOLORSTATIC:
	case WM_CTLCOLOREDIT:
	case WM_CTLCOLORBTN:
	{
		*result = (LRESULT)GetStockObject(WHITE_BRUSH);
		goto HandledExit;
	}
	case WM_CREATE:
	{
		// set up paramters for Charial calls to the users message proc.
		CREATESTRUCT* pCreateStruct = (CREATESTRUCT*)lParam;
		ZWindowI* pWindow = (ZWindowI*) pCreateStruct->lpCreateParams;
		pWindow->hWnd = hWnd;   
		SetWindowLong(pWindow->hWnd, GWL_WINDOWPOINTER,(LONG)pWindow);

		break;
    }
	case WM_PALETTECHANGED:
	    if ((HWND)wParam != hWnd)            // Responding to own message.
		{

			HDC hDC			 = GetDC(hWnd);
			HPALETTE hOldPal = SelectPalette(hDC, ZShellZoneShell()->GetPalette(), TRUE);
			RealizePalette(hDC);

            InvalidateRect( hWnd, NULL, TRUE );

			if ( hOldPal )
				SelectPalette(hDC, hOldPal, TRUE);

			ReleaseDC( hWnd, hDC );
		}
		
		hWnd = GetWindow(hWnd, GW_CHILD);
		while (hWnd)
		{
			SendMessage( hWnd, msg, wParam, lParam );
			hWnd = GetWindow(hWnd, GW_HWNDNEXT);
		}

		*result = TRUE;
		goto HandledExit;
	case WM_QUERYNEWPALETTE:
	{
	    HDC hDC = GetDC(hWnd);
	    HPALETTE hOldPal = SelectPalette(hDC, ZShellZoneShell()->GetPalette(), FALSE);
	    int i = RealizePalette(hDC);       // Realize drawing palette.

		// seems we should update in all cases, else one of our
		// windosw updates the palette and the others see no need
		// to invalidate the palette.
		
		InvalidateRect(hWnd, NULL, TRUE);
        UpdateWindow(hWnd);
		
//		repaint.
		if (hOldPal)
			SelectPalette(hDC, hOldPal, TRUE);
	    //RealizePalette(hDC);
	    ReleaseDC(hWnd, hDC);

		*result = TRUE;
		goto HandledExit;
	}
	case WM_MOUSEACTIVATE:
	case WM_ACTIVATE:
	case WM_SETFOCUS:
	case WM_PAINT:
		if (!pWindow)
			goto NotHandledExit;
		if (pGlobals->m_chatFont)
		{
			if (pWindow->hWndTalkInput)
			{
				SendMessage(pWindow->hWndTalkInput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);
				InvalidateRect(pWindow->hWndTalkInput, NULL, TRUE);
			}
			if (pWindow->hWndTalkOutput)
			{
				SendMessage(pWindow->hWndTalkOutput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);
				InvalidateRect(pWindow->hWndTalkOutput, NULL, TRUE);
			}
		}
	case WM_CLOSE:
	case WM_LBUTTONUP:
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
    case WM_MOUSEMOVE:
    case WM_IME_CHAR:
	case WM_CHAR:
    case WM_ENABLE:
    case WM_DISPLAYCHANGE:
	{
		if (!pWindow)
			goto NotHandledExit;
		ASSERT(pWindow!=0);
		if (pWindow->nType == zTypeWindow)
		{
			*result = ZWindowDispatchProc(pWindow,msg,wParam,lParam);
			goto HandledExit;
		}

//        MessageBox(NULL,"ERROR","ERROR",MB_OK);
		break;
	}
	case WM_COMMAND:
	{
		// get hwnd of control sending message
		HWND hWnd;
		WORD wNotifyCode;
		WORD wID;
#ifdef WIN32
		hWnd = (HWND)lParam;
		wNotifyCode = HIWORD(wParam);
		wID = LOWORD(wParam);
#else
		hWnd = (HWND)LOWORD(lParam);
		wNotifyCode = HIWORD(lParam);
		wID = wParam;
#endif
		// must be a control
		ZObjectHeader* pObject = (ZObjectHeader*)MyGetProp32(hWnd,_T("pWindow"));
		// perhaps this window is not yet created, happens with
		// edit box sometimes...
		if (!pObject) break;
		ASSERT(pObject);

		// check for our special talk controls...
		if (wID == ID_TALKINPUT) {
			// we do all needed stuf through subclassing
			break;
		} else if (wID == ID_TALKOUTPUT) {
			// we need do nothing for talk output window
			break;
		}

		switch (pObject->nType) {
			case zTypeCheckBox:
				ZCheckBoxDispatchProc((ZCheckBox)pObject,wNotifyCode);
				break;
			case zTypeButton:
				ZButtonDispatchProc((ZButton)pObject,wNotifyCode);
				break;
			case zTypeEditText:
				ZEditTextDispatchProc((ZEditText)pObject,wNotifyCode);
				break;
			case zTypeRadio:
				ZRadioDispatchProc((ZRadio)pObject,wNotifyCode);
				break;
			default:
                ASSERT( FALSE );
		}
		break;
	}

	case WM_HSCROLL:
	case WM_VSCROLL:
	{
		// get hwnd of control sending message
		HWND hWnd = (HWND)lParam;
		WORD wNotifyCode = LOWORD(wParam);
		short nPos = HIWORD(wParam);
		// must be a control
		ZObjectHeader* pObject = (ZObjectHeader*)GetProp(hWnd,_T("pScrollBar"));
		switch (pObject->nType) {
			case zTypeScrollBar:
				ZScrollBarDispatchProc((ZScrollBar)pObject,wNotifyCode,nPos);
				break;
			default:
                ASSERT( FALSE );
				break;
		}
		break;
	}
	case WM_USER:
	{
		if (!pWindow)
			goto NotHandledExit;
		ASSERT(pWindow!=0);
		if (pWindow->nType == zTypeWindow)
		{
			*result = ZWindowDispatchProc(pWindow,msg,wParam,lParam);
			goto HandledExit;
		}
		break;
	}

	default:
		goto NotHandledExit;
	} // switch

HandledExit:
	return TRUE;

NotHandledExit:
	return FALSE;
}


int ZOCXGraphicsWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* result)
{
	return ZInternalGraphicsWindowProc(hWnd, msg, wParam, lParam, result);
}


LRESULT CALLBACK ZGraphicsWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LRESULT result;


	if (!ZInternalGraphicsWindowProc(hWnd, msg, wParam, lParam, &result))
		result = DefWindowProc(hWnd, msg, wParam, lParam);

	return result;
}


LRESULT ZWindowDispatchProc(ZWindowI* pWindow, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LRESULT result = 0L;
    int16 msgType;


	switch (msg) {
		case WM_ACTIVATE:
			WORD fActive;
			
			fActive = LOWORD(wParam);
			//leonp
			if (ZWindowIsVisible((ZWindow) pWindow))
			{
				if (fActive == WA_ACTIVE || fActive == WA_CLICKACTIVE) {
					ZWindowSendMessageToAllObjects(pWindow, zMessageWindowActivate,NULL,NULL);
					ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowActivate,NULL,NULL,
						NULL,NULL,0L,pWindow->userData);
				} else {
					ZWindowSendMessageToAllObjects(pWindow, zMessageWindowDeactivate,NULL,NULL);
					ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowDeactivate,NULL,NULL,
						NULL,NULL,0L,pWindow->userData);
				}
			}
			break;
		case WM_ENABLE:
			if (ZWindowIsVisible((ZWindow) pWindow))
			{
				if (wParam) {
					ZWindowSendMessageToAllObjects(pWindow, zMessageWindowEnable,NULL,NULL);
					ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowEnable,NULL,NULL,
						NULL,NULL,0L,pWindow->userData);
				} else {
					ZWindowSendMessageToAllObjects(pWindow, zMessageWindowDisable,NULL,NULL);
					ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowDisable,NULL,NULL,
						NULL,NULL,0L,pWindow->userData);
				}
			}
			break;
		case WM_DISPLAYCHANGE:
			ZSendMessage(pWindow, pWindow->messageFunc, zMessageSystemDisplayChange, NULL, NULL,
				NULL, NULL, 0, pWindow->userData);
			break;
		case WM_MOUSEACTIVATE:
			//leonp bug 535 send new message to clients
			if( (INT)LOWORD(lParam) == HTCLIENT )
			{
				ZWindowSendMessageToAllObjects(pWindow, zMessageWindowMouseClientActivate,NULL,NULL);
				ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowMouseClientActivate,NULL,NULL,
						NULL,NULL,0L,pWindow->userData);
			}
			result = MA_ACTIVATE;
			break;
		case WM_CLOSE:
			// let the user close the window
			ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowClose,NULL,NULL,
				NULL,NULL,0L,pWindow->userData);
			break;
		case WM_PAINT:
		{
			// perform the required begin/endpaint and get the cliprect
			PAINTSTRUCT ps;
			HDC hDC = BeginPaint(pWindow->hWnd,&ps);
			RECT rect;
			GetClipBox(hDC,&rect);
			ZRect zrect;
			WRectToZRect(&zrect,&rect);

			// paint a line for the border between the window
			// and the talk window
			if (pWindow->talkSection) {
				HPEN pen = (HPEN)GetStockObject(BLACK_PEN);
				HPEN penOld = (HPEN)SelectObject(hDC,pen);
				MoveToEx(hDC,pWindow->talkOutputRect.left,pWindow->talkOutputRect.top-1,NULL);
				LineTo(hDC,pWindow->talkOutputRect.right,pWindow->talkOutputRect.top-1);
				SelectObject(hDC,penOld);
			}
	
			// this paintDC will be used as our draw dc, when the Client calls
			// BeginDrawing...  We save the hDC in this variable hPaintDC
			ASSERT(pWindow->hPaintDC == NULL);
			ASSERT(pWindow->nDrawingCallCount == 0);
			pWindow->hPaintDC = hDC;
			ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowDraw,NULL,&zrect,
				NULL,NULL,0L,pWindow->userData);
			ZWindowSendMessageToAllObjects(pWindow, zMessageWindowDraw,NULL,&zrect);
			EndPaint(pWindow->hWnd,&ps);
			pWindow->hPaintDC = NULL;

			// Set clip rect to full window.
			hDC = GetDC(pWindow->hWnd);
			RECT r;
			GetClientRect(pWindow->hWnd, &r);
			LPtoDP(hDC, (POINT*)&r, 2);
			HRGN hRgn = CreateRectRgn(r.left, r.top, r.right, r.bottom);
			//Prefix Warning: if CreateRectRgn fails, DeleteObject will dereference NULL
			if( hRgn != NULL )
			{
				SelectClipRgn(hDC, hRgn);
				DeleteObject(hRgn);
			}
			ReleaseDC(pWindow->hWnd, hDC);
			break;
		}
		case WM_SETCURSOR:
			// ZZZZZZZ ??? should we only send this on entry... how to detect leave?
			ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowCursorMovedIn,NULL,NULL,
				NULL,NULL,0L,pWindow->userData);
			break;
		case WM_LBUTTONDOWN:
		case WM_RBUTTONDOWN:
		{
			ZPoint point;
			point.x = LOWORD(lParam);
			point.y = HIWORD(lParam);

            msgType = zMessageWindowButtonDown; // default;
            if ( msg == WM_RBUTTONDOWN )
                msgType = zMessageWindowRightButtonDown;

			if (pWindow->trackCursorMessageFunc) {
				ZSendMessage(pWindow,pWindow->trackCursorMessageFunc, msgType,&point,NULL,
					ZWindowGetKeyState(0),NULL,0L,pWindow->trackCursorUserData);
			} else {
				// give an object the first change to handle it
				if (!ZWindowSendMessageToObjects(pWindow,msgType,&point,NULL)) {
					ZSendMessage(pWindow,pWindow->messageFunc, msgType,&point,NULL,
						ZWindowGetKeyState(0),NULL,0L,pWindow->userData);
				}
			}
			break;
		}
		case WM_LBUTTONUP:
		case WM_RBUTTONUP:
		{
			ZPoint point;
			point.x = LOWORD(lParam);
			point.y = HIWORD(lParam);

            msgType = zMessageWindowButtonUp; // default;
            if ( msg == WM_RBUTTONUP )
                msgType = zMessageWindowRightButtonUp;

			if (pWindow->trackCursorMessageFunc) {
				ZSendMessage(pWindow,pWindow->trackCursorMessageFunc, msgType,&point,NULL,
					ZWindowGetKeyState(0),NULL,0L,pWindow->trackCursorUserData);
				pWindow->trackCursorMessageFunc = NULL;
				pWindow->trackCursorUserData = NULL;
			} else {
				// give an object the first change to handle it
				if (!ZWindowSendMessageToObjects(pWindow,msgType,&point,NULL)) {
					ZSendMessage(pWindow,pWindow->messageFunc, msgType,&point,NULL,
						ZWindowGetKeyState(0),NULL,0L,pWindow->userData);
				}
			}
			break;
		}
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDBLCLK:
		{
			ZPoint point;
			point.x = LOWORD(lParam);
			point.y = HIWORD(lParam);

            msgType = zMessageWindowButtonDoubleClick; // default;
            if ( msg == WM_RBUTTONDBLCLK )
                msgType = zMessageWindowRightButtonDoubleClick;

			// give an object the first change to handle it
			if (!ZWindowSendMessageToObjects(pWindow,msgType,&point,NULL)) {
				ZSendMessage(pWindow,pWindow->messageFunc, msgType,&point,NULL,
					ZWindowGetKeyState(0),NULL,0L,pWindow->userData);
			}
			break;
		}
        case WM_MOUSEMOVE:
        {
			ZPoint point;
			point.x = LOWORD(lParam);
			point.y = HIWORD(lParam);

            msgType = zMessageWindowMouseMove; // default;

			if (!ZWindowSendMessageToObjects(pWindow,msgType,&point,NULL,FALSE)) {
				ZSendMessage(pWindow,pWindow->messageFunc, msgType,&point,NULL,
					ZWindowGetKeyState(0),NULL,0L,pWindow->userData);
			}
            break;
        }

		// do we want to do key translation with WKEYUP/DOWN??
        // PCWTODO: Do we need to convert this message?
        case WM_IME_CHAR:
		case WM_CHAR:
		{
			TCHAR c = (TCHAR)wParam;

			if (c == _T('\t')) {
				HWND hWndFocus = GetFocus();
				if (IsChild(pWindow->hWnd,hWndFocus)) {
					// this is a child of the current window
					// move focus to next child
					HWND hWndNext = GetWindow(hWndFocus,GW_HWNDNEXT);
					while (hWndNext && !IsWindowVisible(hWndNext)) {
						hWndNext = GetWindow(hWndNext, GW_HWNDNEXT);
					}
					if (!hWndNext) {
						// cycle to the first child
						hWndNext = GetWindow(pWindow->hWnd,GW_CHILD);
					}
					SetFocus(hWndNext);
					return 0L;
				} else if (hWndFocus == pWindow->hWnd) {
					// the parent has focus... set it to first child
					// cycle to the first child
					HWND hWndNext = GetWindow(pWindow->hWnd,GW_CHILD);
					while (hWndNext && !IsWindowVisible(hWndNext)) {
						hWndNext = GetWindow(hWndNext, GW_HWNDNEXT);
					}
					if (hWndNext) {
						// we have a child, cycle through child windows 
						SetFocus(hWndNext);
					} else {
						// no child... do we have a parent? if so, let
						// it change the focus to some other window
						HWND hWndParent = GetParent(pWindow->hWnd);
						if (hWndParent)
							SendMessage(hWndParent,WM_CHAR,wParam,lParam);
					}
					return 0L;
				} // else, how did we get it if we don't have focus??
			} else if (c == _T('\r')  && pWindow->defaultButton) {
				ZButtonClickButton(pWindow->defaultButton);
				return 0L;
			} else if (c == VK_ESCAPE && pWindow->cancelButton) {
				ZButtonClickButton(pWindow->cancelButton);
				return 0L;
			}
			// else send the keypress to the owner window
			// give an object the first change to handle it
			if (!ZWindowSendMessageToObjects(pWindow,zMessageWindowChar,NULL,c)) {
				ZSendMessage(pWindow,pWindow->messageFunc, zMessageWindowChar,NULL,NULL,
					ZWindowGetKeyState(c),NULL,0L,pWindow->userData);
			}

			break;
		}
		case WM_SETFOCUS:
		{
			/* if we have a talk window, set focus to the talk window output always */
			if (pWindow->hWndTalkInput) {
				SetFocus(pWindow->hWndTalkInput);
				return 0L;
			}

			// try to set focus to 1st child
			HWND hWndNext = GetWindow(pWindow->hWnd,GW_CHILD);
			while (hWndNext && !IsWindowVisible(hWndNext)) {
				hWndNext = GetWindow(hWndNext, GW_HWNDNEXT);
			}
			if (hWndNext) {
				// we have a child, cycle through child windows 
				SetFocus(hWndNext);
				return 0L;
			} else {
				// no child... do we have a parent? if so, let
				// it change the focus to some other window
				// this was tried and failed since the child
				// set the focus to the parent and the parent
				// set it back.  Infinite loop!  This problem
				// showed up only under windows 95.
				// else, accept the focus
				
				// for now, lets set focus to ourself.
				/* if we have a talk window, set focus to the talk window output always */
				if (pWindow->hWndTalkInput) {
					SetFocus(pWindow->hWndTalkInput);
					return 0L;
				} else {
					SetFocus(pWindow->hWnd);
					return 0L;
				}
			}
		}
		case WM_USER:
		{
			ZSendMessage(pWindow,pWindow->messageFunc,zMessageWindowUser,NULL,NULL,wParam,NULL,0L,pWindow->userData);
			break;
		}
	}
	return result;
}


ZMessageFunc ZLIBPUBLIC ZWindowGetFunc(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	return pWindow->messageFunc;
}       
	
void ZLIBPUBLIC ZWindowSetFunc(ZWindow window, ZMessageFunc messageFunc)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	pWindow->messageFunc = messageFunc;
}       


HWND ZWindowGetHWND( ZWindow window )
{
	ZWindowI* pWindow = (ZWindowI*)window;
	
	return pWindow->hWnd;
}

/*
void ZWindowSetTalkInput( ZWindow window, char* pszTalk )
{
	ZWindowI* pWindow = (ZWindowI*)window;

    if ( pWindow && pWindow->hWndTalkInput)
    {
        pWindow->bHasTyped = TRUE;
        SendMessage( pWindow->hWndTalkInput, WM_SETTEXT, NULL, (LPARAM)pszTalk );
        SendMessage( pWindow->hWndTalkInput, EM_SETSEL, lstrlen(pszTalk), lstrlen(pszTalk) );
        SetFocus( pWindow->hWndTalkInput );
    }
}
*/

void* ZLIBPUBLIC ZWindowGetUserData(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	return pWindow->userData;
}       
	
void ZLIBPUBLIC ZWindowSetUserData(ZWindow window, void* userData)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	pWindow->userData = userData;
}

void ZWindowMakeMain(ZWindow window)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZWindowI* pWindow = (ZWindowI*)window;


	if (!pGlobals)
		return;

	gHWNDMainWindow = pWindow->hWnd;
}

void ZWindowUpdateControls(ZWindow window)
{
	ZWindowI* pWindow = (ZWindowI*)window;
	/* does nothing under windows??? */
}

typedef struct {
	ZPoint* point;
	uint16 msg;
	ZRect* rect;
} SendMessageToAllObjectsData;

static ZBool ZWindowSendMessageToAllObjectsEnumFunc(ZLListItem listItem, void *objectType, void *objectData, void* userData)
{
	SendMessageToAllObjectsData* data = (SendMessageToAllObjectsData*)userData;
	ZObjectI* pObject = (ZObjectI*)objectData;
	ZObject object = (ZObject)objectType;

	// send the message to this object
	ZSendMessage(object,pObject->messageFunc,data->msg,data->point, data->rect,
			ZWindowGetKeyState(0),NULL,0L,pObject->userData);

	return FALSE;
}

void ZWindowSendMessageToAllObjects(ZWindowI* pWindow, uint16 msg, ZPoint* point, ZRect* rect)
{
	SendMessageToAllObjectsData data;
	data.msg = msg;
	data.point = point;
	data.rect = rect;
	ZLListEnumerate(pWindow->objectList,ZWindowSendMessageToAllObjectsEnumFunc,
			zLListAnyType,(void*)&data, zLListFindForward);
}

typedef struct {
	ZPoint* point;
	uint16 msg;
	ZBool messageProcessed;
	ZObject object;
	ZObjectI* pObject;
    BOOL fRestrictToBounds;  // if TRUE will only send the message if it occurred within the object's boundary
} SendMessageToObjectsData;

static ZBool ZWindowSendMessageToObjectsEnumFunc(ZLListItem listItem, void *objectType, void *objectData, void* userData)
{
	SendMessageToObjectsData* data = (SendMessageToObjectsData*)userData;
	ZObjectI* pObject = (ZObjectI*)objectData;
	ZObject object = (ZObject)objectType;

	if ( !data->fRestrictToBounds || ZPointInRect(data->point,&pObject->bounds)) {
		// the point is in the object
		if (ZSendMessage(object,pObject->messageFunc,data->msg,data->point, NULL,
				ZWindowGetKeyState(0),NULL,0L,pObject->userData)) {
			data->messageProcessed = TRUE;
			data->object = object;
			data->pObject = pObject;
			return TRUE;
		}

		// continue processing until a window accepts the message.
		return FALSE;
	}			

	// return FALSE to see that we get all items
	return FALSE;
}

static uint32 ZWindowGetKeyState(TCHAR c)
{
	uint32 state = 0;

	if (GetKeyState(VK_SHIFT) & 0x8000) {
		state |= zCharShiftMask;
	}

	if (GetKeyState(VK_CONTROL) & 0x8000) {
		state |= zCharControlMask;
	}

	if (GetKeyState(VK_MENU) & 0x8000) {
		state |= zCharAltMask;
	}

	return state | c;
}

static ZBool ZWindowSendMessageToObjects(ZWindowI* pWindow, uint16 msg, ZPoint* point, TCHAR c, BOOL fRestrictToBounds /*= TRUE*/ )
{
	if (msg == zMessageWindowChar) {
		if (pWindow->objectFocused) {
			ZLListItem listItem = ZLListFind(pWindow->objectList,NULL,pWindow->objectFocused,zLListFindForward);
			if (listItem)
			{
				ZObjectI* pObject = (ZObjectI*)ZLListGetData(listItem,NULL);
				ZBool rval;
				rval = ZSendMessage(pWindow->objectFocused, pObject->messageFunc,zMessageWindowChar,NULL,NULL,
						ZWindowGetKeyState(c),NULL,0L,pObject->userData);

				return rval;
			}
			else
			{
				pWindow->objectFocused = NULL;
			}
		}

		return FALSE;
	}

	// now hand the button down type of messages
	{
		SendMessageToObjectsData data;
		data.msg = msg;
		data.point = point;
		data.messageProcessed = FALSE;
        data.fRestrictToBounds = fRestrictToBounds;

		ZLListEnumerate(pWindow->objectList,ZWindowSendMessageToObjectsEnumFunc,
				zLListAnyType,(void*)&data,zLListFindBackward);

		if (data.messageProcessed) {
			ZBool rval;
			ZObject object = data.object;
			ZObjectI* pObject = data.pObject;
			rval = ZSendMessage(object, pObject->messageFunc,zMessageWindowObjectTakeFocus,NULL,NULL,
					NULL,NULL,0L,pObject->userData);
			if (rval) {
				// was there another window with the focus
				if (pWindow->objectFocused && pWindow->objectFocused != object) {
					ZLListItem listItem = ZLListFind(pWindow->objectList,NULL,pWindow->objectFocused,zLListFindForward);
					if (listItem)
					{
						ZObjectI* pObject = (ZObjectI*)ZLListGetData(listItem,NULL);
						ZBool rval;
						// took the focus, tell the previous object it lost the focus 
						rval = ZSendMessage(pWindow->objectFocused, pObject->messageFunc,zMessageWindowObjectLostFocus,NULL,NULL,
								NULL,NULL,0L,pObject->userData);
					}
				}
				// set the new object as the object with the focus 
				pWindow->objectFocused = object;
			}

			return TRUE;
		}
	}

	return FALSE;
}

ZError ZWindowAddObject(ZWindow window, ZObject object, ZRect* bounds,
		ZMessageFunc messageFunc, void* userData)
	/*
		Attaches the given object to the window for event preprocessing.
		
		On a user input, the object is given the user input message. If the
		object handles the message, then it is given the opportunity to take
		the focus.
		
		NOTE: All predefined objects are automatically added to the window.
		Client programs should not add predefined objects to the system -- if
		done so, the client program could crash. This routine should be used
		only when client programs are creating custom objects.
	*/
{
	ZWindowI* pWindow = (ZWindowI*)window;
	ZObjectI* pObject = (ZObjectI*)object;

	pObject = (ZObjectI*)ZMalloc(sizeof(ZObjectI));

	pObject->bounds = *bounds;
	pObject->messageFunc = messageFunc;
	pObject->userData = userData;
	pObject->object = object;

	// add timer to list of timers active and processed in our window proc
	ZLListAdd(pWindow->objectList,NULL,object,pObject,zLListAddFirst);

	return zErrNone;
}
	
ZError ZWindowRemoveObject(ZWindow window, ZObject object)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	// remove the current timer from our list of timers
	ZLListItem listItem = ZLListFind(pWindow->objectList,NULL,object,zLListFindForward);
	ZObjectI* pObject = (ZObjectI*)ZLListGetData(listItem,NULL);
	ZLListRemove(pWindow->objectList,listItem);

	// if this object had focus, give none focus
	if (pWindow->objectFocused == pObject) {
		pWindow->objectFocused = NULL;
	}

	// free the space allocated for this object
	ZFree(pObject);
	
	return zErrNone;
}

ZObject ZWindowGetFocusedObject(ZWindow window)
	/*
		Returns the object with the current focus. NULL if no object has focus.
	*/
{
	ZWindowI* pWindow = (ZWindowI*)window;

	return pWindow->objectFocused;
}
	
ZBool ZWindowSetFocusToObject(ZWindow window, ZObject object)
	/*
		Sets the focus to the given object. Returns whether the object accepted
		the focus or not. Object may refuse to accept the focus if it is not
		responding to user inputs.
		
		Removes focus from the currently focused object if object is NULL.
		
		Removes focus from the currently focused object only if the specified
		object accepts focus.
	*/
{
	ZWindowI* pWindow = (ZWindowI*)window;

	pWindow->objectFocused = object;

	return TRUE;
}

void ZWindowTrackCursor(ZWindow window, ZMessageFunc messageFunc, void* userData)
	/*
		Tracks the cursor until the mouse button down/up event occurs. The coordinates
		are local to the specified window. The messageFunc will be called with userData
		for idle, mouseDown and mouseUp events.
	*/
{
	ZWindowI* pWindow = (ZWindowI*)window;

	pWindow->trackCursorMessageFunc = messageFunc;
	pWindow->trackCursorUserData = userData;

	/* set the capture, we will release it on next button up/down.*/
	SetCapture(pWindow->hWnd);
}



ZError ZWindowMoveObject(ZWindow window, ZObject object, ZRect* bounds)
{
	ZWindowI* pWindow = (ZWindowI*)window;

	// remove the current timer from our list of timers
	ZLListItem listItem = ZLListFind(pWindow->objectList,NULL,object,zLListFindForward);
	ZObjectI* pObject = (ZObjectI*)ZLListGetData(listItem,NULL);

	pObject->bounds = *bounds;

	return zErrNone;
}


HWND ZWindowWinGetOCXWnd(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	if (!pGlobals)
		return NULL;

	return (OCXHandle);
}


void ZMessageBox(ZWindow parent, TCHAR* title, TCHAR* text)
{
/*	ZWindowI* pWindow;
	int i;
	ZMessageBoxType* mbox = NULL;
	HWND hWnd;


	if (!parent)
		parent = (ZWindow) GetWindowLong(ZWindowWinGetOCXWnd(), GWL_WINDOWPOINTER);

	if (parent)
	{
		i = GetAvailMessageBox(pWindow = (ZWindowI*) parent);
		mbox = &pWindow->mbox[i];
		hWnd = pWindow->hWnd;
	}

	if (mbox)
	{
		ShowMessageBox(mbox, hWnd, title, text, ID_MESSAGEBOX);
	}
*/}


void ZMessageBoxEx(ZWindow parent, TCHAR* title, TCHAR* text)
{
/*	ZWindowI* pWindow;
	int i;
	ZMessageBoxType* mbox = NULL;
	HWND hWnd;


	if (!parent)
		parent = (ZWindow) GetWindowLong(ZWindowWinGetOCXWnd(), GWL_WINDOWPOINTER);

	if (parent)
	{
		i = GetAvailMessageBox(pWindow = (ZWindowI*) parent);
		mbox = &pWindow->mbox[i];
		hWnd = pWindow->hWnd;
	}

//	else
//	{
//		i = GetAvailMessageBox(pWindow = (ZWindowI*) GetWindowLong(ZWindowWinGetOCXWnd(), GWL_WINDOWPOINTER));
//		mbox = &pWindow->mbox[i];
//		hWnd = NULL;
//	}


	if (mbox)
	{
		ShowMessageBox(mbox, hWnd, title, text, ID_MESSAGEBOXEX);
	}
*/}

/*
/////////////////////////////////////////////////////////////////////
//		Threaded modal dialog
//
//	Notes:
//	1.	If multiple dialogs are up for a given window, then closing
//		one of the dialogs results in the parent window not being
//		modal anymore.
/////////////////////////////////////////////////////////////////////
void ClearAllMessageBoxes(ZWindowI* pWindow)
{
	for (int i = 0; i < zNumMessageBox; i++)
	{
		pWindow->mbox[i].hWnd = NULL;
		pWindow->mbox[i].parent = NULL;
		pWindow->mbox[i].title = NULL;
		pWindow->mbox[i].text = NULL;
	}
}


int GetAvailMessageBox(ZWindowI* pWindow)
{
	for (int i = 0; i < zNumMessageBox; i++)
		if (pWindow->mbox[i].hWnd == NULL)
			return (i);

	return -1;
}


void CloseAllMessageBoxes(ZWindowI* pWindow)
{
	for (int i = 0; i < zNumMessageBox; i++)
		if (pWindow->mbox[i].hWnd)
		{
//			SendMessage(pWindow->mbox[i].hWnd, WM_CLOSE, 0, 0);
			SendMessage(pWindow->mbox[i].hWnd, WM_COMMAND, IDOK, 0);

			// Hockie ... wait until the dialog is gone.
			while (pWindow->mbox[i].hWnd)
				Sleep(0);
		}
}


void ShowMessageBox(ZMessageBoxType* mbox, HWND parent, TCHAR* title, TCHAR* text, DWORD flag)
{
	HANDLE hThread;
	DWORD threadID;


	InterlockedExchange((PLONG) &mbox->hWnd, -1);			// mbox->hWnd = -1;
	mbox->parent = parent;
	mbox->title = (TCHAR*) ZCalloc(lstrlen(title) + 1, sizeof(TCHAR));
	if (mbox->title)
		lstrcpy(mbox->title, title);
	mbox->text = (TCHAR*) ZCalloc(lstrlen(text) + 1, sizeof(TCHAR));
	if (mbox->text)
		lstrcpy(mbox->text, text);
	mbox->flag = flag;

	if (hThread = CreateThread(NULL, 0, ZMessageBoxThreadFunc, mbox, 0, &threadID))
		CloseHandle(hThread);
}


DWORD WINAPI ZMessageBoxThreadFunc(LPVOID param)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZMessageBoxType* mbox = (ZMessageBoxType*) param;


	DialogBoxParam(g_hInstanceLocal, MAKEINTRESOURCE(mbox->flag), mbox->parent, ZMessageBoxDialogProc, (long) mbox);
	InterlockedExchange((PLONG) &mbox->hWnd, NULL);			// mbox->hWnd = NULL;
	ExitThread(0);

	return 0;
}


static INT_PTR CALLBACK ZMessageBoxDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	ZMessageBoxType* mbox;


	switch (uMsg)
	{
	case WM_INITDIALOG:
		mbox = (ZMessageBoxType*) lParam;
		InterlockedExchange((PLONG) &mbox->hWnd, (LONG) hwndDlg);		// mbox->hWnd = hwndDlg;
		SetWindowText(hwndDlg, mbox->title);
		SetDlgItemText(hwndDlg, ID_MESSAGEBOX_TEXT, mbox->text);
		ZFree(mbox->title);
		ZFree(mbox->text);
		mbox->title = NULL;
		mbox->text = NULL;
//		MessageBeep(MB_OK);
		return 1;
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hwndDlg, 0);
			break;
		}
		break;
	}

	return 0;
}
*/

/////////////////////////////////////////////////////////////////////
//		Font selection
/////////////////////////////////////////////////////////////////////
void ZWindowChangeFont(ZWindow window)
{
	ClientDllGlobals pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
	CHOOSEFONT chooseFont;
	LOGFONT logFont;
	ZWindowI* pWindow = (ZWindowI*) window;


	if (!pGlobals)
		return;

	// Set up the choose font structure.
	chooseFont.lStructSize		= sizeof(chooseFont);
	chooseFont.hwndOwner		= pWindow->hWnd;
	chooseFont.hDC				= NULL;
	chooseFont.lpLogFont		= &logFont;
	chooseFont.Flags			= CF_FORCEFONTEXIST | CF_LIMITSIZE | CF_NOVERTFONTS | CF_SCREENFONTS;
	chooseFont.nSizeMin			= 4;
	chooseFont.nSizeMax			= 18;

	if (ChooseFont(&chooseFont))
	{
		if (pGlobals->m_chatFont)
			DeleteObject(pGlobals->m_chatFont);
		pGlobals->m_chatFont = CreateFontIndirect(&logFont);
		if (pGlobals->m_chatFont)
		{
			if (pWindow->hWndTalkInput)
			{
				SendMessage(pWindow->hWndTalkInput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);
				InvalidateRect(pWindow->hWndTalkInput, NULL, TRUE);
			}
			if (pWindow->hWndTalkOutput)
			{
				SendMessage(pWindow->hWndTalkOutput, WM_SETFONT, (WPARAM) pGlobals->m_chatFont, 0);
				InvalidateRect(pWindow->hWndTalkOutput, NULL, TRUE);
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////
//		Prelude
/////////////////////////////////////////////////////////////////////
#if 0
#define kPreludeWindowWidth		450
#define kPreludeWindowHeight	350
#define kPreludeWidth			440
#define kPreludeHeight			340
#define kPreludeEndState		11
#define kPreludeAnimTimeout		10

typedef struct
{
	int state;
	int blank;
	int animating;
	int animationInited;
	HDC hMemDC;
	HBITMAP hMem;
	HBITMAP hZone;
	HPALETTE hZonePalette;
	RECT zoneRect;
	HPALETTE hOldPalette;
	HBITMAP hCopyright;
	RECT copyrightRect;
} PreludeType;

static DWORD WINAPI PreludeThreadFunc(LPVOID param);
static INT_PTR CALLBACK PreludeDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static void CenterWindow(HWND hWnd, HWND hWndParent);
static void CenterRect(RECT* src, RECT* dst);
static void DrawPreludeImage(HDC hdc, RECT* r, WORD imageID);
static HPALETTE PreludeGetImagePalette(HBITMAP hBitmap);
static HBITMAP PreludeCreateBitmap(HDC hDC, long width, long height);
#endif

void ZWindowDisplayPrelude(void)
{
    /*
	HANDLE hThread;
	DWORD threadID;


	if (hThread = CreateThread(NULL, 0, PreludeThreadFunc, (LPVOID) ZWindowWinGetOCXWnd(), 0, &threadID))
		CloseHandle(hThread);
    */
}


#if 0
static DWORD WINAPI PreludeThreadFunc(LPVOID param)
{
	PreludeType* prelude;


	prelude = (PreludeType*) LocalAlloc(LPTR, sizeof(PreludeType));
	if (prelude)
	{
		prelude->hMemDC = NULL;
		prelude->hMem = NULL;
		prelude->hZone = NULL;
		prelude->hZonePalette = NULL;

		DialogBoxParam(GetModuleHandle(zZoneClientDllFileName), MAKEINTRESOURCE(ID_PRELUDE), (HWND) param, PreludeDialogProc, (LPARAM)prelude);
		LocalFree(prelude);
	}
	ExitThread(0);

	return 0;
}


static INT_PTR CALLBACK PreludeDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	PreludeType* prelude;
	PAINTSTRUCT ps;
	HDC hdc;
	RECT r, r2;
	TCHAR* str;
	int height, width;
	BITMAP bitmap;
	HDC hMemDC;
	DWORD oldLimit;
	

	prelude = (PreludeType*) GetWindowLong(hWnd, DWL_USER);

	switch (uMsg)
	{
	case WM_INITDIALOG:
		prelude = (PreludeType*) lParam;

		SetWindowPos(hWnd, NULL, 0, 0, kPreludeWindowWidth, kPreludeWindowHeight, SWP_NOMOVE | SWP_NOZORDER);
		CenterWindow(hWnd, NULL);
		SetWindowLong(hWnd, DWL_USER, (LONG) prelude);

		prelude->state = 0;
		prelude->blank = TRUE;
		prelude->animating = FALSE;

		SetTimer(hWnd, 1, 500, NULL);
		return 1;
		break;
	case WM_TIMER:
		if (prelude)
		{
			if (prelude->animating)
			{
				SetTimer(hWnd, 1, kPreludeAnimTimeout, NULL);
			}
			else
			{
				if (prelude->state == kPreludeEndState)
				{
					SendMessage(hWnd, WM_COMMAND, 0, 0);
				}
				else
				{
					prelude->blank = !prelude->blank;
					if (prelude->state >= 9)
						prelude->blank = FALSE;
					if (prelude->blank)
					{
						SetTimer(hWnd, 1, 250, NULL);
					}
					else
					{
						prelude->state++;
						if (prelude->state == kPreludeEndState)
						{
							SetTimer(hWnd, 1, 10000, NULL);
						}
						else if (prelude->state == 10)
						{
							prelude->animating = TRUE;
							prelude->animationInited = FALSE;
							SetTimer(hWnd, 1, kPreludeAnimTimeout, NULL);
						}
						else
						{
							SetTimer(hWnd, 1, 1750, NULL);
						}
					}
				}
			}
			InvalidateRect(hWnd, NULL, FALSE);
			UpdateWindow(hWnd);
		}
		break;
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		GetClientRect(hWnd, &r);
		
		if (prelude->state < 10)
//			FillRect(hdc, &r, GetStockObject(BLACK_BRUSH));
			PatBlt(hdc, r.left, r.top, r.right - r.left, r.bottom - r.top, BLACKNESS);		// Faster?
		SetTextColor(hdc, RGB(255, 255, 255));
		SetBkColor(hdc, RGB(0, 0, 0));

		if (!prelude->blank)
		{
			switch (prelude->state)
			{
			case 1:
				DrawPreludeImage(hdc, &r, ID_MS);
				break;
			case 2:
				str = "presents";
				DrawTextEx(hdc, str, lstrlen(str), &r, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE, NULL);
				break;
			case 3:
				str = "A ZoneTeam production";
				DrawTextEx(hdc, str, lstrlen(str), &r, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE, NULL);
				break;
			case 4:
				str = "In a future role by ZonePet(TM)";
				DrawTextEx(hdc, str, lstrlen(str), &r, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_VCENTER | DT_SINGLELINE, NULL);
				break;
			case 5:
				r2 = r;
				InflateRect(&r2, -20, 0);
                str = "The long awaited upgrade which required 100,000 cans of soda,"
                      " 1000 late night pizzas, 1,000,000,000,000 keystrokes,"
                      " 10,000 hours playing the latest hottest games,"
                      " countless endless useless meetings, and 1 hour of sleep";

				height = DrawTextEx(hdc, str, lstrlen(str), &r2, DT_CALCRECT | DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK, NULL);
				CenterRect(&r2, &r);
				DrawTextEx(hdc, str, lstrlen(str), &r2, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK, NULL);
				break;
			case 6:
				r2 = r;
				InflateRect(&r2, -20, 0);
				str = "Out with the old\r(sweet memories for some of us)";
				height = DrawTextEx(hdc, str, lstrlen(str), &r2, DT_CALCRECT | DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK, NULL);
				CenterRect(&r2, &r);
				DrawTextEx(hdc, str, lstrlen(str), &r2, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK, NULL);
				break;
			case 7:
				DrawPreludeImage(hdc, &r, ID_IGZ);
				break;
			case 8:
				r2 = r;
				InflateRect(&r2, -20, 0);
				str = "And in with the new\r(chance to create new memories)";
				height = DrawTextEx(hdc, str, lstrlen(str), &r2, DT_CALCRECT | DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK, NULL);
				CenterRect(&r2, &r);
				DrawTextEx(hdc, str, lstrlen(str), &r2, DT_CENTER | DT_NOCLIP | DT_NOPREFIX | DT_WORDBREAK, NULL);
				break;
			case 9:
				if (!prelude->hZone)
				{
					// Load the image from the resource file.
					prelude->hZone = LoadImage(GetModuleHandle(zZoneClientDllFileName), MAKEINTRESOURCE(ID_ZONE), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
					if (prelude->hZone)
					{
						prelude->hZonePalette = PreludeGetImagePalette(prelude->hZone);
						if (prelude->hZonePalette)
						{
							prelude->hOldPalette = SelectPalette(hdc, prelude->hZonePalette, FALSE);
							RealizePalette(hdc);
							prelude->hMemDC = CreateCompatibleDC(hdc);
							if (prelude->hMemDC)
							{
								SelectObject(prelude->hMemDC, prelude->hZone);

								GetObject(prelude->hZone, sizeof(bitmap), &bitmap);
								SetRect(&r2, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
								CenterRect(&r2, &r);
								prelude->zoneRect = r2;
							}
						}
					}
				}
				if (prelude->hZone)
				{
					r2 = prelude->zoneRect;
					width = r2.right - r2.left;
					height = r2.bottom - r2.top;
					StretchBlt(hdc, r2.left, r2.top, width, height, prelude->hMemDC, 0, 0, width, height, SRCCOPY);
				}
				break;
			case 10:
				if (!prelude->animationInited)
				{
					// Select palette first into DC before creating the bitmap.
					SelectPalette(prelude->hMemDC, prelude->hZonePalette, FALSE);

					prelude->hMem = PreludeCreateBitmap(prelude->hMemDC, kPreludeWidth, kPreludeHeight);
					if (prelude->hMem)
					{
						SelectObject(prelude->hMemDC, prelude->hMem);

						prelude->hCopyright = LoadImage(GetModuleHandle(zZoneClientDllFileName), MAKEINTRESOURCE(ID_COPYRIGHT), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
						if (prelude->hCopyright)
						{
							GetObject(prelude->hCopyright, sizeof(bitmap), &bitmap);
							SetRect(&prelude->copyrightRect, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
							CenterRect(&prelude->copyrightRect, &r);
							OffsetRect(&prelude->copyrightRect, 0, r.bottom - prelude->copyrightRect.top);
						}
					}

					prelude->animationInited = TRUE;
				}

				// Always clear background.
				SetRect(&r2, 0, 0, kPreludeWidth, kPreludeHeight);
				FillRect(prelude->hMemDC, &r2, GetStockObject(BLACK_BRUSH));
//				PatBlt(hdc, r2.left, r2.top, r2.right - r2.left, r2.bottom - r2.top, BLACKNESS);		// Faster?

				hMemDC = CreateCompatibleDC(prelude->hMemDC);
				if (hMemDC)
				{
					// Draw zone.
					if (prelude->hZone)
					{
						SelectObject(hMemDC, prelude->hZone);
						if (prelude->zoneRect.bottom + 4 >= prelude->copyrightRect.top)
							OffsetRect(&prelude->zoneRect, 0, -(prelude->zoneRect.bottom + 4 - prelude->copyrightRect.top));
						r2 = prelude->zoneRect;
						width = r2.right - r2.left;
						height = r2.bottom - r2.top;
						StretchBlt(prelude->hMemDC, r2.left, r2.top, width, height, hMemDC, 0, 0, width, height, SRCCOPY);
					}

					// Draw copyright.
					if (prelude->hCopyright)
					{
						SelectObject(hMemDC, prelude->hCopyright);
						r2 = prelude->copyrightRect;
						IntersectRect(&r2, &r2, &r);
						width = r2.right - r2.left;
						height = r2.bottom - r2.top;
						StretchBlt(prelude->hMemDC, r2.left, r2.top, width, height, hMemDC, 0, 0, width, height, SRCCOPY);
						OffsetRect(&prelude->copyrightRect, 0, -1);

						if (prelude->copyrightRect.bottom < kPreludeHeight - 8)
						{
							prelude->animating = FALSE;

							if (prelude->hZone)
								DeleteObject(prelude->hZone);
							prelude->hZone = NULL;
							if (prelude->hCopyright)
								DeleteObject(prelude->hCopyright);
							prelude->hCopyright = NULL;
						}
					}

					DeleteDC(hMemDC);
				}

				SelectPalette(hdc, prelude->hZonePalette, FALSE);
//				RealizePalette(hdc);
				StretchBlt(hdc, 0, 0, kPreludeWidth, kPreludeHeight, prelude->hMemDC, 0, 0, kPreludeWidth, kPreludeHeight, SRCCOPY);
				break;
			case 11:
				SelectPalette(hdc, prelude->hZonePalette, FALSE);
				RealizePalette(hdc);
				StretchBlt(hdc, 0, 0, kPreludeWidth, kPreludeHeight, prelude->hMemDC, 0, 0, kPreludeWidth, kPreludeHeight, SRCCOPY);
				break;
			}
		}

		EndPaint(hWnd, &ps);
		break;
	case WM_KEYDOWN:
	case WM_LBUTTONDOWN:
	case WM_COMMAND:
		if (prelude)
		{
			if (prelude->state != 0)
			{
				if (prelude->hMemDC)
					DeleteDC(prelude->hMemDC);
				if (prelude->hMem)
					DeleteObject(prelude->hMem);
				if (prelude->hZone)
					DeleteObject(prelude->hZone);
				if (prelude->hZonePalette)
					DeleteObject(prelude->hZonePalette);
				if (prelude->hCopyright)
					DeleteObject(prelude->hCopyright);
				KillTimer(hWnd, 1);
				EndDialog(hWnd, 0);
			}
		}
		break;
	}

	return 0;
}


static void CenterWindow(HWND hWnd, HWND hWndParent)
{
	RECT rcChild, rcParent;
	int x, y;


	if (hWndParent == NULL)
		hWndParent = GetDesktopWindow();

	GetWindowRect(hWnd, &rcChild);
	GetWindowRect(hWndParent, &rcParent);
	x = rcParent.left + ((rcParent.right - rcParent.left) - (rcChild.right - rcChild.left)) / 2;
	y = rcParent.top + ((rcParent.bottom - rcParent.top) - (rcChild.bottom - rcChild.top)) / 2;

	SetWindowPos(hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


static void CenterRect(RECT* src, RECT* dst)
{
	int width, height;

	
	width = src->right - src->left;
	height = src->bottom - src->top;
	src->left = dst->left + ((dst->right - dst->left) - width) / 2;
	src->top = dst->top + ((dst->bottom - dst->top) - height) / 2;
	src->right = src->left + width;
	src->bottom = src->top + height;
}


static void DrawPreludeImage(HDC hdc, RECT* r, WORD imageID)
{
	HDC hdcMem;
	HBITMAP hBitmap;
	BITMAP bitmap;
	HPALETTE hPalette, hOldPalette;
	BITMAPINFO* bitmapInfo;
	LOGPALETTE* palette;
	RECT r2;


	// Load the image from the resource file.
	hBitmap = LoadImage(GetModuleHandle(zZoneClientDllFileName), MAKEINTRESOURCE(imageID), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
	if (hBitmap)
	{
		GetObject(hBitmap, sizeof(bitmap), &bitmap);

		hPalette = PreludeGetImagePalette(hBitmap);
		if (hPalette)
		{
			SetRect(&r2, 0, 0, bitmap.bmWidth, bitmap.bmHeight);
			CenterRect(&r2, r);
			hdcMem = CreateCompatibleDC(hdc);
			if (hdcMem)
			{
				SelectObject(hdcMem, hBitmap);
				hOldPalette = SelectPalette(hdc, hPalette, FALSE);
				RealizePalette(hdc);
				StretchBlt(hdc, r2.left, r2.top, bitmap.bmWidth, bitmap.bmHeight, hdcMem, 0, 0, bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);
				SelectPalette(hdc, hOldPalette, FALSE);
				DeleteDC(hdcMem);
			}

			DeleteObject(hPalette);
		}

		DeleteObject(hBitmap);
	}
}


static HPALETTE PreludeGetImagePalette(HBITMAP hBitmap)
{
	HPALETTE hPalette = NULL;
	BITMAP bitmap;
	BITMAPINFO* bitmapInfo;
	LOGPALETTE* palette;
	HDC hdc;


	if (hBitmap)
	{
		// Allocate buffer to hold image info and color table.
		bitmapInfo = (BITMAPINFO*) LocalAlloc(LPTR, sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
		if (bitmapInfo)
		{
			GetObject(hBitmap, sizeof(bitmap), &bitmap);

			bitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
			bitmapInfo->bmiHeader.biWidth = bitmap.bmWidth;
			bitmapInfo->bmiHeader.biHeight = bitmap.bmHeight;
			bitmapInfo->bmiHeader.biPlanes = bitmap.bmPlanes;
			bitmapInfo->bmiHeader.biBitCount = bitmap.bmBitsPixel;
			bitmapInfo->bmiHeader.biCompression = BI_RLE8;

			// Create a temporary DC.
			hdc = CreateCompatibleDC(NULL);
			if (hdc)
			{
				// Get image info.
				if (GetDIBits(hdc, hBitmap, 0, bitmap.bmHeight, NULL, bitmapInfo, DIB_RGB_COLORS))
				{
					// Allocate palette buffer.
					palette = (LOGPALETTE*) LocalAlloc(LPTR, sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * 255);
					if (palette)
					{
						// Create palette log structure.
						palette->palVersion = 0x300;
						palette->palNumEntries = (WORD) (bitmapInfo->bmiHeader.biClrUsed ? bitmapInfo->bmiHeader.biClrUsed : 256);
						for (int i = 0; i < 256; i++)
						{
							palette->palPalEntry[i].peRed = bitmapInfo->bmiColors[i].rgbRed;
							palette->palPalEntry[i].peGreen = bitmapInfo->bmiColors[i].rgbGreen;
							palette->palPalEntry[i].peBlue = bitmapInfo->bmiColors[i].rgbBlue;
							palette->palPalEntry[i].peFlags = 0;
						}

						LocalFree(bitmapInfo);
						bitmapInfo = NULL;

						// Create palette.
						hPalette = CreatePalette(palette);

						LocalFree(palette);
					}
				}

				DeleteDC(hdc);
			}

			if (bitmapInfo)
				LocalFree(bitmapInfo);
		}
	}

	return (hPalette);
}


static HBITMAP PreludeCreateBitmap(HDC hDC, long width, long height)
{
	HBITMAP hBitmap = NULL;
	BITMAPINFO* bitmapInfo;
	WORD* pIdx;
	char* pBits;


	// Allocate buffer to hold image info and color table.
	bitmapInfo = (BITMAPINFO*) LocalAlloc(LPTR, sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 255);
	if (bitmapInfo)
	{
		bitmapInfo->bmiHeader.biSize			= sizeof(BITMAPINFOHEADER);
		bitmapInfo->bmiHeader.biWidth			= width;
		bitmapInfo->bmiHeader.biHeight			= height;
		bitmapInfo->bmiHeader.biPlanes			= 1;
		bitmapInfo->bmiHeader.biBitCount		= 8;
		bitmapInfo->bmiHeader.biCompression		= 0;
		bitmapInfo->bmiHeader.biSizeImage		= 0;
		bitmapInfo->bmiHeader.biClrUsed			= 0;
		bitmapInfo->bmiHeader.biClrImportant	= 0;
		bitmapInfo->bmiHeader.biXPelsPerMeter	= 0;
		bitmapInfo->bmiHeader.biYPelsPerMeter	= 0;

		// Fill in palette
		pIdx = (WORD*) bitmapInfo->bmiColors;
		for (int i = 0; i < 256; i++)
			*pIdx++ = (WORD) i;

		// Create section
		hBitmap = CreateDIBSection(hDC, bitmapInfo, DIB_PAL_COLORS, (void**) &pBits, NULL, 0);

		LocalFree(bitmapInfo);
	}
			
    return (hBitmap);
}

#endif // 0 -- commented out prelude stuff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\ztimer.cpp ===
//////////////////////////////////////////////////////////////////////////////////////
// File: ZTimer.cpp

#include "zui.h"
#include "zonecli.h"


class ZTimerI {
public:
	ZObjectType nType;
	uint32 nTimeOut;
	uint32 nCurrentTime;
	void* nUserData;
	ZTimerFunc pTimerFunc;
};

LRESULT CALLBACK ZTimerWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

const TCHAR *g_szTimerWindowClass = _T("ZoneTimerWindowClass");

#ifdef ZONECLI_DLL

#define g_hWndTimer					(pGlobals->m_g_hWndTimer)
#define g_TimerList					(pGlobals->m_g_TimerList)
#define s_nTickCount				(pGlobals->m_s_nTickCount)

#else

HWND g_hWndTimer = NULL;
ZLList g_TimerList;

#endif


// One-time init call for timers
BOOL ZTimerInitApplication()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	// link list to track timers currently running
	g_TimerList = ZLListNew(NULL);

	// hidden window to receive timer messages and dispatch them.
	WNDCLASSEX wc;

	wc.cbSize = sizeof( wc );

	if (GetClassInfoEx(g_hInstanceLocal, g_szTimerWindowClass, &wc) == FALSE)
	{
        wc.cbSize = sizeof(wc);
 		wc.style = 0;
		wc.lpfnWndProc   = ZTimerWindowProc;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = 0;
		wc.hInstance     = g_hInstanceLocal;
		wc.hIcon         = NULL;
		wc.hCursor       = NULL;
		wc.hbrBackground = (HBRUSH) (WHITE_BRUSH);
		wc.lpszMenuName  = NULL;
        wc.hIconSm       = NULL;
			
		wc.lpszClassName = g_szTimerWindowClass;
			
		// we could be called more than once...
		if (!RegisterClassEx(&wc)) {
			return FALSE;
		}
	}

	// Create our global window for a timer...
	{
		DWORD dwStyle = WS_POPUP | WS_CAPTION | WS_BORDER |  WS_SYSMENU;
		g_hWndTimer = CreateWindow(g_szTimerWindowClass,_T("TIMERWINDOW"),dwStyle,0,0,0,0,
			NULL, NULL, g_hInstanceLocal, NULL);
			
		if (!g_hWndTimer) return FALSE;
		SetTimer(g_hWndTimer,0,10,NULL);
	}

	return TRUE;
}

// One-time terminate for timers
void ZTimerTermApplication()
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif

	
	KillTimer(g_hWndTimer, 0);

#if 0
	if (ZLListCount(g_TimerList,zLListAnyType))
	{
		ZLListItem listItem;
		ZTimerI* pTimer;

		listItem = ZLListGetFirst(g_TimerList, zLListAnyType);
		while (listItem)
		{
			pTimer = (ZTimerI*) ZLListGetData(listItem, NULL);
			if (pTimer)
				pTimer->pTimerFunc(pTimer, pTimer->nUserData);
			listItem = ZLListGetNext(g_TimerList, listItem, zLListAnyType);
		}
	}
#endif

	// users better have cleaned up timers
	//ASSERT(ZLListCount(g_TimerList,zLListAnyType) == 0);
	ZLListDelete(g_TimerList);

	// clean up our hidden window
	DestroyWindow(g_hWndTimer);

//	UnregisterClass(g_szTimerWindowClass,g_hInstanceLocal);
}

ZBool ZTimerEnumFunc(ZLListItem listItem, void *objectType, void *objectData, void* userData)
{
	ZTimerI* pTimer = (ZTimerI*)objectData;
	uint32 nTicks = (uint32) userData;

	/* this timeout is disabled just return */
	if (pTimer->nTimeOut == 0) {
		return FALSE;
	}

	// has the time expired on this timer??
	if (nTicks >= pTimer->nCurrentTime) {
		// if so then notify client
		uint32 nTicksExtra = nTicks - pTimer->nCurrentTime;
		// allow the extra ticks to go into the next time unit, but
		// don't call the Func more than once per Window's Tick call here
		if (pTimer->nTimeOut <= nTicksExtra) {
			pTimer->nCurrentTime = 1;
		} else {
			pTimer->nCurrentTime = pTimer->nTimeOut - nTicksExtra;
		}
		pTimer->pTimerFunc(pTimer,pTimer->nUserData);
	} else {
		pTimer->nCurrentTime -= nTicks;
	}

	// return FALSE to see that we get all items
	return FALSE;
}

LRESULT CALLBACK ZTimerWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#else
	static uint32 s_nTickCount; // the last tick count in 100/sec
#endif

    if( !ConvertMessage( hWnd, msg, &wParam, &lParam ) ) 
    {
        return 0;
    }
	
	switch (msg) {
	case WM_CREATE:
		s_nTickCount = GetTickCount()/10;
		break;
	case WM_TIMER:
	{
		uint32 nTickCount = GetTickCount()/10; // tick count for us is in 1/100 sec
		uint32 nTicks = nTickCount - s_nTickCount;
		ZLListItem listItem = ZLListFind(g_TimerList,NULL,zLListAnyType,zLListFindForward);
		ZLListEnumerate(g_TimerList,ZTimerEnumFunc,zLListAnyType,(void*)nTicks, zLListFindForward);
		s_nTickCount = nTickCount;
		return 0;
	}
	default:
		break;
	} // switch

	return DefWindowProc(hWnd,msg,wParam,lParam);
}

////////////////////////////////////////////////////////////////////////
// ZTimer

ZTimer ZLIBPUBLIC ZTimerNew(void)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZTimerI* pTimer = new ZTimerI;
	pTimer->nType = zTypeTimer;
	pTimer->nTimeOut = 0;

	// add timer to list of timers active and processed in our window proc
	ZLListAdd(g_TimerList,NULL,pTimer,pTimer,zLListAddFirst);

	return (ZTimer)pTimer;
}

ZError ZLIBPUBLIC ZTimerInit(ZTimer timer, uint32 timeout, ZTimerFunc timerProc,
		void* userData)
{
	ZTimerI* pTimer = (ZTimerI*)timer;
	pTimer->pTimerFunc = timerProc;
	pTimer->nUserData = userData;
	pTimer->nCurrentTime = pTimer->nTimeOut;

	ZTimerSetTimeout(timer, timeout);

	return zErrNone;
}

void ZLIBPUBLIC ZTimerDelete(ZTimer timer)
{
#ifdef ZONECLI_DLL
	ClientDllGlobals	pGlobals = (ClientDllGlobals) ZGetClientGlobalPointer();
#endif
	ZTimerI* pTimer = (ZTimerI*)timer;

	// remove the current timer from our list of timers
	ZLListItem listItem = ZLListFind(g_TimerList,NULL,pTimer,zLListFindForward);
	ZLListRemove(g_TimerList,listItem);
	
	delete pTimer;
}
uint32 ZLIBPUBLIC ZTimerGetTimeout(ZTimer timer)
{
	ZTimerI* pTimer = (ZTimerI*)timer;
	return pTimer->nTimeOut;
}

ZError ZLIBPUBLIC ZTimerSetTimeout(ZTimer timer, uint32 timeout)
{
	ZTimerI* pTimer = (ZTimerI*)timer;
	pTimer->nTimeOut = timeout;
	pTimer->nCurrentTime = pTimer->nTimeOut;

	return zErrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zoneclient\main.cpp ===
#include "BasicATL.h"

#include <ZoneShell.h>
#include "..\ZoneShell\CZoneShell.h"

#include <Timer.h>
#include "..\Timer\CTimer.h"

#include <ResourceManager.h>
#include "..\ResourceManager\CResourceManager.h"

#include <LobbyDataStore.h>
#include "..\LobbyDataStore\CLobbyDataStore.h"

#include <MillEngine.h>
#include "..\MillEngine\CMillEngine.h"

#include <MillNetworkCore.h>
#include "..\MillNetworkCore\CMillNetworkCore.h"

#include <MillCore.h>
#include "..\MillCore\CMillCore.h"



#include <clientidl.h>
#include "..\LobbyWindow\LobbyWindow.h"
#include "..\WindowManager\WindowManager.h"
#include "..\Chat\chatctl.h"
#include "..\InputManager\CInputManager.h"
#include "..\AccessibilityManager\CAccessibilityManager.h"
#include "..\GraphicalAcc\CGraphicalAcc.h"
#include "..\MillCommand\CMillCommand.h"
#include "..\NetworkManager\CNetworkManager.h"
#include "..\PhysicalNetwork\CPhysicalNetwork.h"


CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LobbyDataStore, CLobbyDataStore)
	OBJECT_ENTRY(CLSID_ZoneShell, CZoneShell)
	OBJECT_ENTRY(CLSID_ResourceManager, CResourceManager)
	OBJECT_ENTRY(CLSID_WindowManager, CWindowManager)
	OBJECT_ENTRY(CLSID_LobbyWindow, CLobbyWindow)
	OBJECT_ENTRY(CLSID_ChatCtl, CChatCtl )
	OBJECT_ENTRY(CLSID_MillCommand, CMillCommand )
	OBJECT_ENTRY(CLSID_NetworkManager, CNetworkManager )
    OBJECT_ENTRY(CLSID_PhysicalNetwork, CPhysicalNetwork )
	OBJECT_ENTRY(CLSID_TimerManager, CTimerManager )
    OBJECT_ENTRY(CLSID_InputManager, CInputManager )
    OBJECT_ENTRY(CLSID_AccessibilityManager, CAccessibilityManager )
    OBJECT_ENTRY(CLSID_GraphicalAccessibility, CGraphicalAccessibility )
	OBJECT_ENTRY(CLSID_MillEngine, CMillEngine )
	OBJECT_ENTRY(CLSID_MillNetworkCore, CMillNetworkCore )
	OBJECT_ENTRY(CLSID_MillCore, CMillCore )	
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
/////////////////////////////////////////////////////////////////////////////

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		//DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecli\zxlate.cpp ===
/*******************************************************************************

	ZXlate.c
	
		Zone(tm) translation routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on Tuesday, 25, 1995.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		12/12/96	HI		Remove MSVCRT.DLL dependency.
	1		04/08/96	HI		Modified prototype of ZTranslateText() to
								include conversion parameter. Also added
								functionality to convert ascii value from/to
								standard (unix/pc) and platform.
	0		07/25/95	HI		Created.
	 
*******************************************************************************/


#include <windows.h>

#include "zone.h"
#include "zonemem.h"

#if 0


#define zCharLineFeed			_T('\n')
#define zCharReturn				_T('\r')

#define GetNext(p)				(*(p)++)
#define PeekNext(p)				(*(p))


/* -------- Globals -------- */
#ifdef __ZWindows__
static uchar				gToSystemTable[] =
		{
			0x00,	0x01,	0x02,	0x03,	0x04,	0x05,	0x06,	0x07,
			0x08,	0x09,	0x0A,	0x0B,	0x0C,	0x0D,	0x0E,	0x0F,
			0x10,	0x11,	0x12,	0x13,	0x14,	0x15,	0x16,	0x17,
			0x18,	0x19,	0x1A,	0x1B,	0x1C,	0x1D,	0x1E,	0x1F,
			0x20,	0x21,	0x22,	0x23,	0x24,	0x25,	0x26,	0x27,
			0x28,	0x29,	0x2A,	0x2B,	0x2C,	0x2D,	0x2E,	0x2F,
			0x30,	0x31,	0x32,	0x33,	0x34,	0x35,	0x36,	0x37,
			0x38,	0x39,	0x3A,	0x3B,	0x3C,	0x3D,	0x3E,	0x3F,
			0x40,	0x41,	0x42,	0x43,	0x44,	0x45,	0x46,	0x47,
			0x48,	0x49,	0x4A,	0x4B,	0x4C,	0x4D,	0x4E,	0x4F,
			0x50,	0x51,	0x52,	0x53,	0x54,	0x55,	0x56,	0x57,
			0x58,	0x59,	0x5A,	0x5B,	0x5C,	0x5D,	0x5E,	0x5F,
			0x60,	0x61,	0x62,	0x63,	0x64,	0x65,	0x66,	0x67,
			0x68,	0x69,	0x6A,	0x6B,	0x6C,	0x6D,	0x6E,	0x6F,
			0x70,	0x71,	0x72,	0x73,	0x74,	0x75,	0x76,	0x77,
			0x78,	0x79,	0x7A,	0x7B,	0x7C,	0x7D,	0x7E,	0x7F,
			0x80,	0x81,	0x82,	0x83,	0x84,	0x85,	0x86,	0x87,
			0x88,	0x89,	0x8A,	0x8B,	0x8C,	0x8D,	0x8E,	0x8F,
			0x90,	0x91,	0x92,	0x93,	0x94,	0x95,	0x96,	0x97,
			0x98,	0x99,	0x9A,	0x9B,	0x9C,	0x9D,	0x9E,	0x9F,
			0xA0,	0xA1,	0xA2,	0xA3,	0xA4,	0xA5,	0xA6,	0xA7,
			0xA8,	0xA9,	0xAA,	0xAB,	0xAC,	0xAD,	0xAE,	0xAF,
			0xB0,	0xB1,	0xB2,	0xB3,	0xB4,	0xB5,	0xB6,	0xB7,
			0xB8,	0xB9,	0xBA,	0xBB,	0xBC,	0xBD,	0xBE,	0xBF,
			0xC0,	0xC1,	0xC2,	0xC3,	0xC4,	0xC5,	0xC6,	0xC7,
			0xC8,	0xC9,	0xCA,	0xCB,	0xCC,	0xCD,	0xCE,	0xCF,
			0xD0,	0xD1,	0xD2,	0xD3,	0xD4,	0xD5,	0xD6,	0xD7,
			0xD8,	0xD9,	0xDA,	0xDB,	0xDC,	0xDD,	0xDE,	0xDF,
			0xE0,	0xE1,	0xE2,	0xE3,	0xE4,	0xE5,	0xE6,	0xE7,
			0xE8,	0xE9,	0xEA,	0xEB,	0xEC,	0xED,	0xEE,	0xEF,
			0xF0,	0xF1,	0xF2,	0xF3,	0xF4,	0xF5,	0xF6,	0xF7,
			0xF8,	0xF9,	0xFA,	0xFB,	0xFC,	0xFD,	0xFE,	0xFF
		};
static uchar				gToStandardTable[] =
		{
			0x00,	0x01,	0x02,	0x03,	0x04,	0x05,	0x06,	0x07,
			0x08,	0x09,	0x0A,	0x0B,	0x0C,	0x0D,	0x0E,	0x0F,
			0x10,	0x11,	0x12,	0x13,	0x14,	0x15,	0x16,	0x17,
			0x18,	0x19,	0x1A,	0x1B,	0x1C,	0x1D,	0x1E,	0x1F,
			0x20,	0x21,	0x22,	0x23,	0x24,	0x25,	0x26,	0x27,
			0x28,	0x29,	0x2A,	0x2B,	0x2C,	0x2D,	0x2E,	0x2F,
			0x30,	0x31,	0x32,	0x33,	0x34,	0x35,	0x36,	0x37,
			0x38,	0x39,	0x3A,	0x3B,	0x3C,	0x3D,	0x3E,	0x3F,
			0x40,	0x41,	0x42,	0x43,	0x44,	0x45,	0x46,	0x47,
			0x48,	0x49,	0x4A,	0x4B,	0x4C,	0x4D,	0x4E,	0x4F,
			0x50,	0x51,	0x52,	0x53,	0x54,	0x55,	0x56,	0x57,
			0x58,	0x59,	0x5A,	0x5B,	0x5C,	0x5D,	0x5E,	0x5F,
			0x60,	0x61,	0x62,	0x63,	0x64,	0x65,	0x66,	0x67,
			0x68,	0x69,	0x6A,	0x6B,	0x6C,	0x6D,	0x6E,	0x6F,
			0x70,	0x71,	0x72,	0x73,	0x74,	0x75,	0x76,	0x77,
			0x78,	0x79,	0x7A,	0x7B,	0x7C,	0x7D,	0x7E,	0x7F,
			0x80,	0x81,	0x82,	0x83,	0x84,	0x85,	0x86,	0x87,
			0x88,	0x89,	0x8A,	0x8B,	0x8C,	0x8D,	0x8E,	0x8F,
			0x90,	0x91,	0x92,	0x93,	0x94,	0x95,	0x96,	0x97,
			0x98,	0x99,	0x9A,	0x9B,	0x9C,	0x9D,	0x9E,	0x9F,
			0xA0,	0xA1,	0xA2,	0xA3,	0xA4,	0xA5,	0xA6,	0xA7,
			0xA8,	0xA9,	0xAA,	0xAB,	0xAC,	0xAD,	0xAE,	0xAF,
			0xB0,	0xB1,	0xB2,	0xB3,	0xB4,	0xB5,	0xB6,	0xB7,
			0xB8,	0xB9,	0xBA,	0xBB,	0xBC,	0xBD,	0xBE,	0xBF,
			0xC0,	0xC1,	0xC2,	0xC3,	0xC4,	0xC5,	0xC6,	0xC7,
			0xC8,	0xC9,	0xCA,	0xCB,	0xCC,	0xCD,	0xCE,	0xCF,
			0xD0,	0xD1,	0xD2,	0xD3,	0xD4,	0xD5,	0xD6,	0xD7,
			0xD8,	0xD9,	0xDA,	0xDB,	0xDC,	0xDD,	0xDE,	0xDF,
			0xE0,	0xE1,	0xE2,	0xE3,	0xE4,	0xE5,	0xE6,	0xE7,
			0xE8,	0xE9,	0xEA,	0xEB,	0xEC,	0xED,	0xEE,	0xEF,
			0xF0,	0xF1,	0xF2,	0xF3,	0xF4,	0xF5,	0xF6,	0xF7,
			0xF8,	0xF9,	0xFA,	0xFB,	0xFC,	0xFD,	0xFE,	0xFF
		};
#endif

#ifdef __ZMacintosh__
static uchar				gToSystemTable[] =
		{
			0x00,	0x01,	0x02,	0x03,	0x04,	0x05,	0x06,	0x07,
			0x08,	0x09,	0x0D,	0x0B,	0x0C,	0x0D,	0x0E,	0x0F,
			0x10,	0x11,	0x12,	0x13,	0x14,	0x15,	0x16,	0x17,
			0x18,	0x19,	0x1A,	0x1B,	0x1C,	0x1D,	0x1E,	0x1F,
			0x20,	0x21,	0x22,	0x23,	0x24,	0x25,	0x26,	0x27,
			0x28,	0x29,	0x2A,	0x2B,	0x2C,	0x2D,	0x2E,	0x2F,
			0x30,	0x31,	0x32,	0x33,	0x34,	0x35,	0x36,	0x37,
			0x38,	0x39,	0x3A,	0x3B,	0x3C,	0x3D,	0x3E,	0x3F,
			0x40,	0x41,	0x42,	0x43,	0x44,	0x45,	0x46,	0x47,
			0x48,	0x49,	0x4A,	0x4B,	0x4C,	0x4D,	0x4E,	0x4F,
			0x50,	0x51,	0x52,	0x53,	0x54,	0x55,	0x56,	0x57,
			0x58,	0x59,	0x5A,	0x5B,	0x5C,	0x5D,	0x5E,	0x5F,
			0x60,	0x61,	0x62,	0x63,	0x64,	0x65,	0x66,	0x67,
			0x68,	0x69,	0x6A,	0x6B,	0x6C,	0x6D,	0x6E,	0x6F,
			0x70,	0x71,	0x72,	0x73,	0x74,	0x75,	0x76,	0x77,
			0x78,	0x79,	0x7A,	0x7B,	0x7C,	0x7D,	0x7E,	0x7F,
			0xA5,	0xAA,	0xAD,	0xB0,	0xB3,	0xB7,	0xBA,	0xBD,
			0xC3,	0xC5,	0xC9,	0xD1,	0xD4,	0xD9,	0xDA,	0xB6,
			0xC6,	0xCE,	0xE2,	0xE3,	0xE4,	0xF0,	0xF6,	0xF7,
			0xF9,	0xFA,	0xFB,	0xFD,	0xFE,	0xFF,	0xF5,	0xC4,
			0xCA,	0xC1,	0xA2,	0xA3,	0xDB,	0xB4,	0xCF,	0xA4,
			0xAC,	0xA9,	0xBB,	0xC7,	0xC2,	0xD0,	0xA8,	0xF8,
			0xA1,	0xB1,	0xD3,	0xD2,	0xAB,	0xB5,	0xA6,	0xE1,
			0xFC,	0xD5,	0xBC,	0xC8,	0xB9,	0xB8,	0xB2,	0xC0,
			0xCB,	0xE7,	0xE5,	0xCC,	0x80,	0x81,	0xAE,	0x82,
			0xE9,	0x83,	0xE6,	0xE8,	0xED,	0xEA,	0xEB,	0xEC,
			0xDC,	0x84,	0xF1,	0xEE,	0xEF,	0xCD,	0x85,	0xD7,
			0xAF,	0xF4,	0xF2,	0xF3,	0x86,	0xA0,	0xDE,	0xA7,
			0x88,	0x87,	0x89,	0x8B,	0x8A,	0x8C,	0xBE,	0x8D,
			0x8F,	0x8E,	0x90,	0x91,	0x93,	0x92,	0x94,	0x95,
			0xDD,	0x96,	0x98,	0x97,	0x99,	0x9B,	0x9A,	0xD6,
			0xBF,	0x9D,	0x9C,	0x9E,	0x9F,	0xE0,	0xDF,	0xD8
		};
static uchar				gToStandardTable[] =
		{
			0x00,	0x01,	0x02,	0x03,	0x04,	0x05,	0x06,	0x07,
			0x08,	0x09,	0x0A,	0x0B,	0x0C,	0x0A,	0x0E,	0x0F,
			0x10,	0x11,	0x12,	0x13,	0x14,	0x15,	0x16,	0x17,
			0x18,	0x19,	0x1A,	0x1B,	0x1C,	0x1D,	0x1E,	0x1F,
			0x20,	0x21,	0x22,	0x23,	0x24,	0x25,	0x26,	0x27,
			0x28,	0x29,	0x2A,	0x2B,	0x2C,	0x2D,	0x2E,	0x2F,
			0x30,	0x31,	0x32,	0x33,	0x34,	0x35,	0x36,	0x37,
			0x38,	0x39,	0x3A,	0x3B,	0x3C,	0x3D,	0x3E,	0x3F,
			0x40,	0x41,	0x42,	0x43,	0x44,	0x45,	0x46,	0x47,
			0x48,	0x49,	0x4A,	0x4B,	0x4C,	0x4D,	0x4E,	0x4F,
			0x50,	0x51,	0x52,	0x53,	0x54,	0x55,	0x56,	0x57,
			0x58,	0x59,	0x5A,	0x5B,	0x5C,	0x5D,	0x5E,	0x5F,
			0x60,	0x61,	0x62,	0x63,	0x64,	0x65,	0x66,	0x67,
			0x68,	0x69,	0x6A,	0x6B,	0x6C,	0x6D,	0x6E,	0x6F,
			0x70,	0x71,	0x72,	0x73,	0x74,	0x75,	0x76,	0x77,
			0x78,	0x79,	0x7A,	0x7B,	0x7C,	0x7D,	0x7E,	0x7F,
			0xC4,	0xC5,	0xC7,	0xC9,	0xD1,	0xD6,	0xDC,	0xE1,
			0xE0,	0xE2,	0xE4,	0xE3,	0xE5,	0xE7,	0xE9,	0xE8,
			0xEA,	0xEB,	0xED,	0xEC,	0xEE,	0xEF,	0xF1,	0xF3,
			0xF2,	0xF4,	0xF6,	0xF5,	0xFA,	0xF9,	0xFB,	0xFC,
			0xDD,	0xB0,	0xA2,	0xA3,	0xA7,	0x80,	0xB6,	0xDF,
			0xAE,	0xA9,	0x81,	0xB4,	0xA8,	0x82,	0xC6,	0xD8,
			0x83,	0xB1,	0xBE,	0x84,	0xA5,	0xB5,	0x8F,	0x85,
			0xBD,	0xBC,	0x86,	0xAA,	0xBA,	0x87,	0xE6,	0xF8,
			0xBF,	0xA1,	0xAC,	0x88,	0x9F,	0x89,	0x90,	0xAB,
			0xBB,	0x8A,	0xA0,	0xC0,	0xC3,	0xD5,	0x91,	0xA6,
			0xAD,	0x8B,	0xB3,	0xB2,	0x8C,	0xB9,	0xF7,	0xD7,
			0xFF,	0x8D,	0x8E,	0xA4,	0xD0,	0xF0,	0xDE,	0xFE,
			0xFD,	0xB7,	0x92,	0x93,	0x94,	0xC2,	0xCA,	0xC1,
			0xCB,	0xC8,	0xCD,	0xCE,	0xCF,	0xCC,	0xD3,	0xD4,
			0x95,	0xD2,	0xDA,	0xDB,	0xD9,	0x9E,	0x96,	0x97,
			0xAF,	0x98,	0x99,	0x9A,	0xB8,	0x9B,	0x9C,	0x9D
		};
#endif


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/
/*
	ZTranslateText()
	
	Translates the given null-terminated text into the platform format. It
	basically handles the conversion of line feed and carriage return characters
	into the text.
	
	It returns a new pointer to the translated text.
	
	Mac:	\r
	Unix:	\n
	PC:		\r\n
	
	Method: Since it does not know the eventual length of the text, it simply
	allocates a buffer twice the size of the given text (assuming the worst
	case of every character converting to 2 characters). After the translation,
	it reallocates the buffer to the correct size. (WINDOWS ONLY)
*/
char* ZTranslateText(char* text, int16 conversion)
{
	int16			len, len2;
	char*			dst;
	char*			src;
	char*			newText;
	char			curByte;
	
	
	/* Allocate the temporary buffer. */
	len2 = lstrlen(text) + 1;
#ifdef __ZWindows__
	len2 *= 2;
#endif
	newText = ZMalloc(len2);
	
	dst = newText;
	src = text;
	len = 0;
	while ((curByte = GetNext(src)) != '\0')
	{
		if (curByte == zCharLineFeed || curByte == zCharReturn)
		{
#ifdef __ZMacintosh__
			/*
				Convert all line feeds and carriage returns into carriage returns.
			*/
			*dst++ = zCharReturn;
			len++;
#endif

#ifdef __ZUnix__
			/*
				Convert all line feeds and carriage returns into line feeds.
			*/
			*dst++ = zCharLineFeed;
			len++;
#endif

#ifdef __ZWindows__
			/*
				Convert all line feeds and carriage returns into line feed and
				carriage return combination.
			*/
			*dst++ = zCharReturn;
			len++;
			*dst++ = zCharLineFeed;
			len++;
#endif
			
			/*
				If it is a carriage return and the next character is a line feed,
				then consume the next character.
			*/
			if (curByte == zCharReturn && PeekNext(src) == zCharLineFeed)
				curByte = GetNext(src);
		}
		else
		{
			if (conversion == zToSystem)
				*dst++ = (char) gToSystemTable[(uchar) curByte];
			else
				*dst++ = (char) gToStandardTable[(uchar) curByte];
			len++;
		}
	}
	*dst = '\0';
	len++;
	
	/* Reallocate the buffer. */
	if (len != len2)
		newText = ZRealloc(newText, len);
	
	return (newText);
}


#endif // 0 - commented out (no one uses it)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\test\module\basicatl.h ===
#define _ATL_NO_UUIDOF
#define _ATL_NO_CONNECTION_POINTS
#define _ATL_STATIC_REGISTRY
#define _ATL_MIN_CRT

#define _ATL_NO_DEBUG_CRT
#define _ASSERTE(X) (void)(0)

#include <atlbase.h>

extern CComModule _Module;

#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zoneclient\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ZoneClient.rc
//
#define IDD_EVENTSPY                    2302
#define IDD_DSVIEWER                    2303
#define IDR_DEBUG_MENU                  2400
#define IDSPY_CLEAR                     2523
#define IDSPY_EVENT                     2524
#define IDSPY_EVENTS                    2525
#define IDSPY_FIRE                      2526
#define IDSPY_GROUP                     2527
#define IDSPY_LIST                      2528
#define IDSPY_PRIORITY                  2529
#define IDSPY_USER                      2530
#define IDC_DSVIEWER_LIST               2550
#define IDC_DSVIEWER_TREE               2551
#define ID_DEBUG_DATASTOREVIEWER        2650
#define ID_DEBUG_EVENTSPY               2651

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        236
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\test\module\testinterface.h ===
#ifndef _TestInterface_H
#define _TestInterface_H


// {D93D5C61-8829-11d2-A421-000000000000}
DEFINE_GUID(CLSID_CTestObj, 
0xd93d5c61, 0x8829, 0x11d2, 0xa4, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);


// {D93D5C60-8829-11d2-A421-000000000000}
DEFINE_GUID(IID_ITest, 
0xd93d5c60, 0x8829, 0x11d2, 0xa4, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0);


interface ITest : public IUnknown
{
public:
	STDMETHOD(TestMethod)() = 0;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\zonecom.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneCom.cpp
 * 
 * Contents:	CZoneComManger implementaion.
 *
 *****************************************************************************/

#include <windows.h>
#include <initguid.h>
#include "ZoneDebug.h"
#include "ZoneCom.h"


///////////////////////////////////////////////////////////////////////////////
// CZoneComManager
///////////////////////////////////////////////////////////////////////////////

ZONECALL CZoneComManager::CZoneComManager()
{
	m_pDllList = NULL;
	m_pClassFactoryList = NULL;
	m_pIResourceManager = NULL;
}


ZONECALL CZoneComManager::~CZoneComManager()
{
	// remove remaining class factories
	{
		for ( ClassFactoryInfo *p = m_pClassFactoryList, *next = NULL; p; p = next )
		{
			next = p->m_pNext;
			RemoveClassFactory( p );
		}
	}

	// ignore busy dlls
	{
		for ( DllInfo *p = m_pDllList, *next = NULL; p; p = next )
		{
			ASSERT( p->m_dwRefCnt == 0 );
			next = p->m_pNext;
			p->m_pNext = NULL;
			delete p;
		}
		m_pDllList = NULL;
	}
}


HRESULT ZONECALL CZoneComManager::Create( const TCHAR* szDll, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid, LPVOID* ppv )
{
	HRESULT				hr = S_OK;
	DllInfo*			pDll = NULL;
	ClassFactoryInfo*	pCF = NULL;
	bool				bNewDll = false;
	bool				bNewCF = false;

	// verify calling parameters
	if ( !szDll || !szDll[0] || !ppv )
		return E_INVALIDARG;

	// find class factory
	pCF = FindClassFactory( szDll, rclsid );
	if ( !pCF )
	{
		// find dll
		pDll = FindDll( szDll );
		if ( !pDll )
		{
			// create dll instance
			bNewDll = true;
			pDll = new DllInfo;
			if ( !pDll )
			{
				hr = E_OUTOFMEMORY;
				goto done;
			}
			
			hr = pDll->Init( szDll, m_pIResourceManager );
			if ( FAILED(hr) )
				goto done;
		}

		// create class factory
		bNewCF = true;
		pCF = new ClassFactoryInfo;
		if ( !pCF )
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}
		hr = pCF->Init( pDll, rclsid );
		if ( FAILED(hr) )
			goto done;

		// add new dll to list
		if ( bNewDll )
		{
			pDll->m_pNext = m_pDllList;
			m_pDllList = pDll;
		}

		// add class factory to list
		pCF->m_pNext = m_pClassFactoryList;
		m_pClassFactoryList = pCF;
	}

	// create object
	hr = pCF->m_pIClassFactory->CreateInstance( pUnkOuter, riid, ppv );
	if ( FAILED(hr) )
	{
		// no clean up on fail
		return hr;
	}

	hr = S_OK;
done:
	if ( FAILED(hr) )
	{
		if ( bNewCF && pCF )
			delete pCF;
		if ( bNewDll && pDll )
			delete pDll;
	}
	return hr;
}


HRESULT ZONECALL CZoneComManager::Unload( const TCHAR* szDll, REFCLSID rclsid )
{
	// verify calling parameters
	if ( !szDll || !szDll[0] )
		return E_INVALIDARG;

	RemoveClassFactory( FindClassFactory( szDll, rclsid ) );
	return S_OK;
}


HRESULT ZONECALL CZoneComManager::SetResourceManager( void* pIResourceManager )
{
	// remember resource manager
	m_pIResourceManager = pIResourceManager;
	if ( !pIResourceManager )
		return S_OK;

	// call SetResourceManager for all DLLs
	for ( DllInfo* p = m_pDllList; p; p = p->m_pNext )
	{
		if ( !p->m_pfSetResourceManager || p->m_bSetResourceManager )
			continue;
		p->m_pfSetResourceManager( pIResourceManager );
		p->m_bSetResourceManager = true;
	}
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
// CZoneComManager internal functions
///////////////////////////////////////////////////////////////////////////////

CZoneComManager::DllInfo* ZONECALL CZoneComManager::FindDll( const TCHAR* szDll )
{
	for ( DllInfo* p = m_pDllList; p; p = p->m_pNext )
	{
		if ( lstrcmpi( szDll, p->m_szName ) == 0 )
			return p;
	}
	return NULL;
}


void ZONECALL CZoneComManager::RemoveDll( DllInfo* pDll )
{
	// parameter paranoia
	if ( !pDll )
		return;

	// check reference count
	if ( --(pDll->m_dwRefCnt) > 0 )
		return;

	// punt if dll is busy
	if ( pDll->m_pfCanUnloadNow && (pDll->m_pfCanUnloadNow() == S_FALSE) )
		return;

	// free library
	FreeLibrary( pDll->m_hLib );
	pDll->m_hLib = NULL;

	// remove dll from list
	if ( m_pDllList == pDll )
	{
		m_pDllList = pDll->m_pNext;
		pDll->m_pNext = NULL;
	}
	else
	{
		DllInfo* p = m_pDllList;
		while ( p && p->m_pNext != pDll )
			p = p->m_pNext;
		if ( p )
		{
			p->m_pNext = pDll->m_pNext;
			pDll->m_pNext = NULL;
		}
	}

	delete pDll;
}


CZoneComManager::ClassFactoryInfo* ZONECALL CZoneComManager::FindClassFactory( const TCHAR* szDll, REFCLSID clsidObject )
{
	for ( ClassFactoryInfo* p = m_pClassFactoryList; p; p = p->m_pNext )
	{
		if ( (clsidObject == p->m_clsidObject) && (lstrcmpi( szDll, p->m_pDll->m_szName ) == 0) )
			return p;
	}
	return NULL;
}


void ZONECALL CZoneComManager::RemoveClassFactory( ClassFactoryInfo* pClassFactory )
{
	// parameter paranoia
	if ( !pClassFactory )
		return;

	// remove class factory from list
	if ( m_pClassFactoryList == pClassFactory )
	{
		m_pClassFactoryList = pClassFactory->m_pNext;
		pClassFactory->m_pNext = NULL;
	}
	else
	{
		ClassFactoryInfo* p = m_pClassFactoryList;
		while ( p && p->m_pNext != pClassFactory )
			p = p->m_pNext;
		if ( p )
		{
			p->m_pNext = pClassFactory->m_pNext;
			pClassFactory->m_pNext = NULL;
		}
	}

	// release class factory interface
	if ( pClassFactory->m_pIClassFactory )
	{
		pClassFactory->m_pIClassFactory->Release();
		pClassFactory->m_pIClassFactory = NULL;
	}

	// update class factory's dll
	if ( pClassFactory->m_pDll )
	{
		RemoveDll( pClassFactory->m_pDll );
		pClassFactory->m_pDll = NULL;
	}

	delete pClassFactory;
}


ZONECALL CZoneComManager::DllInfo::DllInfo()
{
	ZeroMemory( this, sizeof(DllInfo) );
}


ZONECALL CZoneComManager::DllInfo::~DllInfo()
{
	ASSERT( m_dwRefCnt == 0 );
	ASSERT( m_pNext == NULL );

	if ( m_szName )
	{
		delete [] m_szName;
		m_szName = NULL;
	}

	// If hLib is valid in the destructor then the dll is busy and
	// can't be freed yet.  We'll just let the OS clean up when the
	// app exits.
#if 0
	if ( m_hLib )
	{
		if ( !m_pfCanUnloadNow || (m_pfCanUnloadNow() == S_OK) )
			FreeLibrary( m_hLib );
		m_hLib = NULL;
	}
#endif

	m_pfGetClassObject = NULL;
	m_pfCanUnloadNow = NULL;
}


HRESULT ZONECALL CZoneComManager::DllInfo::Init( const TCHAR* szName, void* pIResourceManager )
{
	HRESULT hr = S_OK;

	// parameter paranoia
	if ( !szName || !szName[0] )
	{
		hr = E_INVALIDARG;
		goto done;
	}

	// load library
	m_hLib = LoadLibrary( szName );
	if ( !m_hLib )
	{
		hr = ZERR_FILENOTFOUND;
		goto done;
	}

	// load functions
	m_pfSetResourceManager = (PFDLLSETRESOURCEMGR) GetProcAddress( m_hLib, "SetResourceManager" );
	m_pfCanUnloadNow = (PFDLLCANUNLOADNOW) GetProcAddress( m_hLib, "DllCanUnloadNow" );
	m_pfGetClassObject = (PFDLLGETCLASSOBJECT) GetProcAddress( m_hLib, "DllGetClassObject" );
	if ( !m_pfGetClassObject )
	{
		hr = ZERR_MISSINGFUNCTION;
		goto done;
	}

	// copy name
	m_szName = new TCHAR [ lstrlen(szName) + 1 ];
	if ( !m_szName )
	{
		hr = E_OUTOFMEMORY;
		goto done;
	}
	lstrcpy( m_szName, szName );

	// set resource manager
	if ( m_pfSetResourceManager && pIResourceManager )
	{
		m_pfSetResourceManager( pIResourceManager );
		m_bSetResourceManager = true;
	}

	hr = S_OK;
done:
	if ( FAILED(hr) )
	{
		m_dwRefCnt = 0;
		m_pfGetClassObject = NULL;
		m_pfCanUnloadNow = NULL;
		if ( m_szName )
		{
			delete [] m_szName;
			m_szName = NULL;
		}
		if ( m_hLib )
		{
			FreeLibrary( m_hLib );
			m_hLib = NULL;
		}
	}
	return hr;
}


ZONECALL CZoneComManager::ClassFactoryInfo::ClassFactoryInfo()
{
	ZeroMemory( this, sizeof(ClassFactoryInfo) );
}


ZONECALL CZoneComManager::ClassFactoryInfo::~ClassFactoryInfo()
{
	ASSERT( m_pNext == NULL );
	ASSERT( m_pDll == NULL );
	ASSERT( m_pIClassFactory == NULL );
}


HRESULT ZONECALL CZoneComManager::ClassFactoryInfo::Init( DllInfo* pDll, REFCLSID rclsid )
{
	HRESULT hr;

	// parameter paranoia
	if ( !pDll )
		return E_INVALIDARG;

	// copy dll and clsid
	m_pDll = pDll;
	m_pDll->m_dwRefCnt++;
	m_clsidObject = rclsid;

	// get class factory from dll
	hr = m_pDll->m_pfGetClassObject( m_clsidObject, IID_IClassFactory, (void**) &m_pIClassFactory );
	if ( FAILED(hr) )
	{
		m_pDll->m_dwRefCnt--;
		m_pDll = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\test\app\testapp.cpp ===
#define INITGUID

#include "ZoneDebug.h"
#include "ZoneCom.h"
#include "..\Module\TestInterface.h"

void __cdecl main()
{
	HRESULT hr;
	CZoneComManager* pManager = NULL;
	ITest* pObj = NULL;
	
	pManager = new CZoneComManager;
	hr = pManager->Create( "..\\..\\Module\\debug\\TestModule.dll", NULL, CLSID_CTestObj, IID_ITest, (void**) &pObj );
	if ( FAILED(hr) )
		goto done;

done:
	if ( pObj )
		pObj->Release();
	if ( pManager )
	delete pManager;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\test\module\testobj.cpp ===
#include "BasicATL.h"
#include "TestInterface.h"
#include "TestObj.h"

STDMETHODIMP CTestObj::TestMethod()
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\test\module\main.cpp ===
#include "BasicATL.h"
#include <initguid.h>
#include "TestInterface.h"
#include "TestObj.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CTestObj, CTestObj)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		//DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecore\main.cpp ===
#include "BasicATL.h"

#include <EventQueue.h>
#include "..\EventQueue\CEventQueue.h"

#include <DataStore.h>
#include "..\DataStore\CDataStore.h"

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_EventQueue, CEventQueue)
	OBJECT_ENTRY(CLSID_DataStoreManager, CDataStoreManager)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
/////////////////////////////////////////////////////////////////////////////

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{        
		_Module.Init(ObjectMap, hInstance);
		//DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonelib\init.cpp ===
#include <windows.h>


/****************************************************************************
   FUNCTION: DllMain(HANDLE, DWORD, LPVOID)

   PURPOSE:  DllMain is called by Windows when
             the DLL is initialized, Thread Attached, and other times.
             Refer to SDK documentation, as to the different ways this
             may be called.


*******************************************************************************/
BOOL APIENTRY DllMain( HMODULE hMod, DWORD dwReason, LPVOID lpReserved )
{
    BOOL bRet = TRUE;

    switch( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls( hMod );
            break;


        case DLL_PROCESS_DETACH:
            break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\sharedguids\main.cpp ===
#include <windows.h>
#include <initguid.h>
#include <ZoneDef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zonecom\test\module\testobj.h ===
class CTestObj :
	public ITest,
	public CComObjectRoot,
	public CComCoClass<CTestObj,&CLSID_CTestObj>
{
public:


BEGIN_COM_MAP(CTestObj)
	COM_INTERFACE_ENTRY(ITest)
END_COM_MAP()

// making not aggregatable reduces size
DECLARE_NOT_AGGREGATABLE(CTestObj)

// with this macro you can put the object in the object map evan though
// it does not have any self registration capabilities (in our case we
// use an external REG file.
DECLARE_NO_REGISTRY()

// IMinObj
public:
	STDMETHOD(TestMethod)();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\containers\containers.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Containers.h
 *
 * Contents:	Implementation of shared container stuff
 *
 *****************************************************************************/

#include <windows.h>
#include "Pool.h"
#include "Containers.h"
#include "Queue.h"
#include "Hash.h"
#include "zonestring.h"

//
// Global variables used by containers classes
//
CPoolVoid* gListNodePool = NULL;
CPoolVoid* gMTListNodePool = NULL;

//
// Local variables 
//
static long gListNodeRefCnt = -1;
static long gMTListNodeRefCnt = -1;

static bool volatile gListNodeInit = false;
static bool volatile gMTListNodeInit = false;

//
// Initialize queue's container node pool
//
void ZONECALL InitListNodePool( int PoolSize )
{
    CPoolVoid* pool;

    if (InterlockedIncrement( (long*) &gListNodeRefCnt ) == 0)
    {
        while ( gListNodeInit )
            Sleep(0);

        pool = new CPoolVoid( sizeof(CListNode), PoolSize, FALSE );
        if ( !pool || FAILED(pool->Init()) )
        {
            delete pool;
            InterlockedDecrement( (long*) &gListNodeRefCnt );
            return;
        }
        pool = (CPoolVoid*) InterlockedExchange( (long*) &gListNodePool, (long) pool );

        gListNodeInit = TRUE;

        ASSERT( pool == NULL );
    }
    else
    {
        while ( !gListNodeInit )
            Sleep(0);
    }
}

void ZONECALL ExitListNodePool()
{
    CPoolVoid* pool;

    if (InterlockedDecrement( (long*) &gListNodeRefCnt ) < 0)
    {
        pool = (CPoolVoid*) InterlockedExchange( (long*) &gListNodePool, NULL );

        gListNodeInit = FALSE;

        ASSERT( pool != NULL );
        delete pool;
    }
}


//
// Initialize MT queue's and hash's container node pool
//
void ZONECALL InitMTListNodePool( int PoolSize )
{
    CPoolVoid* pool;

    if (InterlockedIncrement( (long*) &gMTListNodeRefCnt ) == 0)
    {
        while ( gMTListNodeInit )
            Sleep(0);

        pool = new CPoolVoid( sizeof(CMTListNode), PoolSize, FALSE );
        if ( !pool || FAILED(pool->Init()) )
        {
            delete pool;
            InterlockedDecrement( (long*) &gListNodeRefCnt );
            return;
        }
        pool = (CPoolVoid*) InterlockedExchange( (long*) &gMTListNodePool, (long) pool );

        gMTListNodeInit = TRUE;

        ASSERT( pool == NULL );
    }
    else
    {
        while ( !gMTListNodeInit )
            Sleep(0);
    }
}

void ZONECALL ExitMTListNodePool()
{
    CPoolVoid* pool;

    if (InterlockedDecrement( (long*) &gMTListNodeRefCnt ) < 0)
    {
        pool = (CPoolVoid*) InterlockedExchange( (long*) &gMTListNodePool, NULL );

        gMTListNodeInit = FALSE;

        ASSERT( pool != NULL );
        delete pool;
    }
}

//
// Common compare functions
//
bool ZONECALL CompareUINT32( unsigned long* p, unsigned long key )
{
	return ((unsigned long) p) == key;
}


//
// Common hash functions
//
DWORD ZONECALL HashInt( int Key )
{
    return Key;
}


DWORD ZONECALL HashUINT32( unsigned long Key )
{
    return Key;
}


DWORD ZONECALL HashGuid( const GUID& Key )
{
    return ( Key.Data1 + *((DWORD*) &Key.Data2) );
}

DWORD ZONECALL HashLPSTR( LPSTR szKey )
{
    return HashLPCSTR((LPCSTR)szKey);
}

DWORD ZONECALL HashLPCSTR( LPCSTR szKey )
{
    DWORD hash = 0;
    
    if ( szKey )
    {
        int i = 0;
        while( *szKey && ( i++ < 16 ) )
        {
			// multiple by 17 to get a good bit distribution
            hash = (hash<<4) + hash + *szKey;
			szKey++;
        }
    }
    return hash;
}

DWORD ZONECALL HashLPWSTR( LPWSTR szKey )
{
    return HashLPCWSTR((LPCWSTR)szKey);
}


DWORD ZONECALL HashLPCWSTR( LPCWSTR szKey )
{
    DWORD hash = 0;
    
    if ( szKey )
    {
        int i = 0;
        while( *szKey && ( i++ < 16 ) )
        {
			// multiple by 17 to get a good bit distribution
            hash = (hash<<4) + hash + *szKey;
			szKey++;
        }
    }
    return hash;
}

DWORD HashLPSTRLower( LPSTR Key)
{
    DWORD hash = 0;
    
    if ( Key )
    {
        int i = 0;
        while( *Key && ( i++ < 16 ) )
        {
            hash = (hash<<4)+hash+TOLOWER(*Key);  // multiple by 17 to get a good bit distribution
            Key++;
        }
    }
    return hash;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zoneshell\czoneshell.h ===
#include "ZoneDef.h"
#include "Hash.h"
#include <Queue.h>
#include "DataStore.h"
#include "ZoneShell.h"
#include "ClientIdl.h"
#include <ATLgdi.h>
#include "ZDialogImpl.h"
#include <ZoneString.h>
#include <ZoneResource.h>
#include "ZoneShellEx.h"
#include "EventQueue.h"
#include <ZoneEvent.h>

struct AlertContext
{
	HWND m_hDlg;			// if not NULL, a dialog provided for the alert
	ZoneString m_Caption;	// these are all only if m_hDlg NULL
	ZoneString m_Text;
    ZoneString m_szButton[3];  // text for Yes, No, and Cancel buttons, or NULL if button should not appear.
    long m_nDefault;       // array index (0-2) of default button

	DWORD m_dwEventId;		// event to send when dialog dismissed
	DWORD m_dwGroupId;
	DWORD m_dwUserId;
    DWORD m_dwCookie;

    bool m_fUsed;           // whether or not it's been shown
    bool m_fSentinel;       // used to loop the Q

	HWND m_hWndParent;
};

class CAlertQ : public CList<AlertContext>
{
public:
	~CAlertQ()
	{
		// empty all the alerts from the Q
		while ( AlertContext* pAlert = PopHead() )
		{
			if ( pAlert->m_hDlg )
				DestroyWindow(pAlert->m_hDlg);
			delete pAlert;
		}
	}
};


class ATL_NO_VTABLE CZoneShell :
	public IZoneShell,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CZoneShell, &CLSID_ZoneShell>
{
// ATL definitions
public:

	DECLARE_NO_REGISTRY()

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CZoneShell)
		COM_INTERFACE_ENTRY(IZoneShell)
	END_COM_MAP()


// CZoneShell
public:
	ZONECALL CZoneShell();
	ZONECALL ~CZoneShell();

// IZoneShell
public:

	// initialize & close objects
	STDMETHOD(Init)( TCHAR** arBootDlls, DWORD nBootDlls, HINSTANCE* arDlls, DWORD nElts );
	STDMETHOD(LoadPreferences)( CONST TCHAR* szInternalName, CONST TCHAR* szUserName );
	STDMETHOD(Close)();

    // message loop & command functions
	STDMETHOD(HandleWindowMessage)(MSG *pMsg);
	STDMETHOD(SetZoneFrameWindow)(IZoneFrameWindow *pZFW, IZoneFrameWindow **ppZFW = NULL);
	STDMETHOD(SetInputTranslator)(IInputTranslator *pIT, IInputTranslator **ppIT = NULL);
	STDMETHOD(SetAcceleratorTranslator)(IAcceleratorTranslator *pAT, IAcceleratorTranslator **ppAT = NULL);
	STDMETHOD(SetCommandHandler)(ICommandHandler *pCH, ICommandHandler **ppCH = NULL);
	STDMETHOD(ReleaseReferences)(IUnknown *pUnk);
	STDMETHOD(CommandSink)(WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	// attach external object to shell
	STDMETHOD(Attach)( const GUID& srvid, IUnknown* pIUnk);

	// dialog functions
	STDMETHOD(AddDialog)(HWND hDlg, bool fOwned = false);
	STDMETHOD(RemoveDialog)(HWND hDlg, bool fOwned = false);
	STDMETHOD_(bool,IsDialogMessage)( MSG* pMsg );

	// other window functions
	STDMETHOD(ExitApp)();
	STDMETHOD(AddTopWindow)( HWND hWnd );
	STDMETHOD(RemoveTopWindow)( HWND hWnd );
	STDMETHOD_(void, EnableTopWindow)( HWND hWnd, BOOL fEnable );
    STDMETHOD_(HWND, FindTopWindow)(HWND hWnd);
    STDMETHOD(AddOwnedWindow)(HWND hWndTop, HWND hWnd);
    STDMETHOD(RemoveOwnedWindow)(HWND hWndTop, HWND hWnd);
    STDMETHOD_(HWND, GetNextOwnedWindow)(HWND hWndTop, HWND hWnd);
	STDMETHOD_(HWND, GetFrameWindow)();
	STDMETHOD_(void, SetPalette)( HPALETTE hPalette );
	STDMETHOD_(HPALETTE, GetPalette)();
	STDMETHOD_(HPALETTE, CreateZonePalette)();
    STDMETHOD_(LCID, GetApplicationLCID)();

	// contained objects
	STDMETHOD(QueryService)( const GUID& srvid, const GUID& iid, void** ppObject );
	STDMETHOD(CreateService)( const GUID& srvid, const GUID& iid, void** ppObject, DWORD dwGroupId, bool bInitialize );

	// alert message function
	STDMETHOD(AlertMessage)(
			HWND		hWndParent,
			LPCTSTR		lpszText,
			LPCTSTR		lpszCaption,
            LPCTSTR     szYes,
            LPCTSTR     szNo = NULL,
            LPCTSTR     szCancel = NULL,
            long        nDefault = 0,
			DWORD		dwEventId = 0,
			DWORD		dwGroupId = ZONE_NOGROUP,
			DWORD		dwUserId  = ZONE_NOUSER,
            DWORD       dwCookie = 0 );

	STDMETHOD(AlertMessageDialog)(
			HWND		hWndParent,
			HWND		hDlg, 
			DWORD		dwEventId = 0,
			DWORD		dwGroupId = ZONE_NOGROUP,
			DWORD		dwUserId  = ZONE_NOUSER,
            DWORD       dwCookie = 0 );

	STDMETHOD_(void,DismissAlertDlg)( HWND hWndParent, DWORD dwCtlID, bool bDestoryDlg );
	STDMETHOD_(void,ActivateAlert)( HWND hWndParent);
    STDMETHOD_(void,ClearAlerts)(HWND hWndParent);

	// accessor functions
	IResourceManager* ResourceManager() { return m_pIResourceManager; }

private:

	struct FactoryInfo
	{
		GUID	m_srvid;
		GUID	m_clsid;
		TCHAR	m_dll[ MAX_PATH ];
		TCHAR	m_name[ 128 ];

		FactoryInfo();
		FactoryInfo( const GUID& clsid, const GUID& srvid, TCHAR* szName, TCHAR* szDll );

		static bool ZONECALL Cmp( FactoryInfo* p, const GUID& srvid)	{ return ZIsEqualGUID(p->m_srvid,srvid); }
		static void ZONECALL Del( FactoryInfo* p, void* )				{ delete p; }
	};

    struct OwnedWindowInfo
    {
        HWND m_hWnd;
        OwnedWindowInfo* m_pNext;

        OwnedWindowInfo(HWND hWnd) : m_hWnd(hWnd), m_pNext(NULL) { }
    };

	struct TopWindowInfo
	{
		HWND			m_hWnd;
		int				m_DisabledCount;
		CAlertQ			m_AlertQ;
        OwnedWindowInfo *m_pFirstOwnedWindow;

		TopWindowInfo( HWND hWnd ) :
			m_hWnd(hWnd),
			m_DisabledCount(0),
            m_pFirstOwnedWindow(NULL)
			{}

        ~TopWindowInfo()
        {
            OwnedWindowInfo *pInfo = m_pFirstOwnedWindow;
            OwnedWindowInfo *p;

            while(pInfo)
            {
                p = pInfo->m_pNext;
                delete pInfo;
                pInfo = p;
            }
        }

		static bool ZONECALL Cmp( TopWindowInfo* p, HWND hWnd)		{ return hWnd == p->m_hWnd; }
		static void ZONECALL Del( TopWindowInfo* p, void* )			{ delete p; }
		
		BOOL Enable(BOOL bEnable)
		{	
			if ( ( bEnable && !--m_DisabledCount ) ||
				 (!bEnable && !m_DisabledCount++ ) )
				return ::EnableWindow(m_hWnd, bEnable);
			return TRUE;
		}
	};

	struct ObjectInfo
	{
		GUID			m_srvid;
		IUnknown*		m_pIUnk;
		FactoryInfo*	m_pFactory;

		ObjectInfo();
		ObjectInfo( const GUID& srvid, IUnknown* pIUnk, FactoryInfo* pFactory );
		~ObjectInfo();

		static bool ZONECALL Cmp( ObjectInfo* p, const GUID& srvid)	{ return ZIsEqualGUID(p->m_srvid,srvid); }
		static void ZONECALL Del( ObjectInfo* p, void* )			{ delete p; }
	};

	struct ObjectContext
	{
		IDataStore*		pIDS;
		CZoneShell*		pObj;
		const TCHAR*	szRoot;
	};

// why are these public?
public:
	CAlertQ      m_GlobalAlertQ;		// Q of all global (everything disabled) alerts
    CAlertQ      m_ChildAlertQ;         // Q of all secondary global alerts (not everything disabled, not parented by a top window)
	CAlertQ* FindAlertQ(HWND hWndParent);
	void AddAlert( HWND hWndParent, AlertContext* pAlert);
	void DisplayAlertDlg( CAlertQ* pAlertQ );

private:

	static DWORD ZONECALL HashHWND( HWND hWnd )				{ return (DWORD) hWnd; }
	static bool ZONECALL CmpHWND( HWND* obj, HWND key )		{ return (((HWND) obj) == key); }
	
	static HRESULT ZONECALL LoadCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT	pVariant, DWORD dwSize, LPVOID pContext );
	static HRESULT ZONECALL FactoryCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext );
	static bool ZONECALL InitCallback( ObjectInfo* pInfo, MTListNodeHandle, void* pContext );
	static bool ZONECALL CloseCallback( ObjectInfo* pInfo, MTListNodeHandle, void* pContext );
	static bool ZONECALL TopWindowCallback( TopWindowInfo* pInfo, MTListNodeHandle, void* pContext );
	static bool ZONECALL TopWindowSearchCallback( TopWindowInfo* pInfo, MTListNodeHandle, void* pContext );
	static bool ZONECALL TopWindowDialogCallback( TopWindowInfo* pInfo, MTListNodeHandle, void* pContext );

	HRESULT ZONECALL LoadClassFactories( IDataStore* pIDS );
	HRESULT ZONECALL GetObjectInfo( IDataStore* pIDS, const TCHAR* szRoot, ObjectInfo** ppInfo );
	HRESULT ZONECALL LoadObject( IDataStore* pIDS, const TCHAR* szRoot, ObjectInfo* pInfo );
	HRESULT ZONECALL CreateServiceInternal( const GUID& srvid, const GUID& iid, void** ppObject, FactoryInfo** ppFactory );
	void	ZONECALL ConstructAlertTitle( LPCTSTR lpszCaption, TCHAR* szOutput, DWORD cbOutput );

	HPALETTE						m_hPalette;
	CComPtr<IResourceManager>		m_pIResourceManager;
	CComPtr<IZoneFrameWindow>		m_pIZoneFrameWindow;
	CComPtr<IInputTranslator>		m_pIInputTranslator;
	CComPtr<IAcceleratorTranslator>	m_pIAcceleratorTranslator;
	CComPtr<ICommandHandler>		m_pICommandHandler;
	TCHAR							m_szUserName[ZONE_MaxUserNameLen];
	TCHAR							m_szInternalName[64];
    LCID                            m_lcid;

	CHash<HWND,HWND>				m_hashDialogs;
	CHash<TopWindowInfo,HWND>		m_hashTopWindows;
	CHash<ObjectInfo, const GUID&>	m_hashObjects;
	CHash<FactoryInfo, const GUID&>	m_hashFactories;
};

class CAlertDialog : public ZDialogImpl<CAlertDialog>
{
public:
	enum { IDD = IDD_ALERTBOX };

BEGIN_MSG_MAP(CAlertDialog)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
	COMMAND_ID_HANDLER(IDYES, OnButton)
    COMMAND_ID_HANDLER(IDNO, OnButton)
	COMMAND_ID_HANDLER(IDCANCEL, OnButton)
	COMMAND_ID_HANDLER(IDHELP, OnHelp)
END_MSG_MAP()

	LRESULT	OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT	OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT	OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
	LRESULT	OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

	LRESULT OnButton(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
	{
		m_pIZoneShell->DismissAlertDlg(m_pAlert->m_hWndParent, wID, true);
		return 0;
	}


	LRESULT OnHelp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
	{
		CComPtr<IEventQueue> pIEventQueue;
		HRESULT hr = m_pIZoneShell->QueryService(SRVID_EventQueue, IID_IEventQueue, (void **) &pIEventQueue);
		if(SUCCEEDED(hr))
			pIEventQueue->PostEvent(PRIORITY_NORMAL, EVENT_LAUNCH_HELP, ZONE_NOGROUP, ZONE_NOUSER, 0, 0);
		return 0;
	}


	virtual void OnFinalMessage( HWND hWnd )
	{
		delete this;
	}

public:
	CAlertDialog( IZoneShell* pZoneShell, AlertContext* pAlert ) :
		m_pIZoneShell(pZoneShell),
		m_pAlert(pAlert), m_font(NULL), m_fontu(NULL)
	{}
	
	~CAlertDialog() {}

private:
	CComPtr<IZoneShell>	m_pIZoneShell;
	AlertContext*		m_pAlert;
    HFONT               m_font;
    HFONT               m_fontu;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\client\shell\zoneshell\czoneshell.cpp ===
#include "ClientIdl.h"
#include "ZoneDef.h"
#include "ZoneUtil.h"
#include "ZoneResource.h"
#include "ZoneString.h"
#include "BasicATL.h"
#include "EventQueue.h"
#include "LobbyDataStore.h"
#include "KeyName.h"
#include "CZoneShell.h" 
#include <ZoneEvent.h>

const TCHAR* gszPreferencesKey	= _T("SOFTWARE\\Microsoft\\zone.com\\Free Games 1.0\\Preferences");
static HRESULT GetModuleLocale(HMODULE hMod, LCID *plcid);

// whistler hack - need to call weird unpublished APIs to get MUI versions
typedef ULONG NTSTATUS;
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)
#define STATUS_NOT_IMPLEMENTED           ((NTSTATUS)0xC0000002L)
#define NT_SUCCESS(x) (((x) & 0xC0000000L) ? FALSE : TRUE)
#define LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION    (0x00000008)
inline DECLARE_MAYBE_FUNCTION(NTSTATUS, LdrFindResourceEx_U, (ULONG Flags, PVOID DllHandle, ULONG *ResourceIdPath, ULONG ResourceIdPathLength, PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry), (Flags, DllHandle, ResourceIdPath, ResourceIdPathLength, ResourceDataEntry), ntdll, STATUS_NOT_IMPLEMENTED);
inline DECLARE_MAYBE_FUNCTION(NTSTATUS, LdrAccessResource, (PVOID DllHandle, PIMAGE_RESOURCE_DATA_ENTRY ResourceDataEntry, PVOID *Address, ULONG *Size), (DllHandle, ResourceDataEntry, Address, Size), ntdll, STATUS_NOT_IMPLEMENTED)

inline DECLARE_MAYBE_FUNCTION_1(BOOL, SetProcessDefaultLayout, DWORD);
inline DECLARE_MAYBE_FUNCTION_2(HWND, GetAncestor, HWND, UINT);

#pragma pack(push, 1)
typedef struct
{
	BYTE red;
	BYTE green;
	BYTE blue;
} RGBTriplet;
#pragma pack(pop)


LRESULT	CAlertDialog::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    if(m_font)
        ::DeleteObject(m_font);
    m_font = NULL;
    if(m_fontu)
        ::DeleteObject(m_fontu);
    m_fontu = NULL;
    return false;
}

LRESULT	CAlertDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
	CDC dc( GetDC(), FALSE );

    int nButtons = 0;
    int i;
    for(i = 0; i < 3; i++)
        if(!m_pAlert->m_szButton[i].IsEmpty())
            nButtons++;

    ASSERT(nButtons);

	SetWindowText( m_pAlert->m_Caption );
	SetDlgItemText( IDC_ALERTBOX_TEXT, m_pAlert->m_Text );
	
	CRect dialogRect;
	CRect textRect;
	CRect helpRect;
    CRect iconRect;
	CRect rgButtonRect[3];

    // put in icon - gets deleted automatically by the static control
    HICON hIcon;
    CComPtr<IResourceManager> pIResourceManager;
    HRESULT hr = m_pIZoneShell->QueryService(SRVID_ResourceManager, IID_IResourceManager, (void **) &pIResourceManager);
    if(SUCCEEDED(hr))
        hIcon = pIResourceManager->LoadImage(MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
    if(hIcon)
        SendDlgItemMessage(IDC_ALERTBOX_ICON, STM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM) hIcon);

	HWND hwndText = GetDlgItem(IDC_ALERTBOX_TEXT);
	HWND rghwndButton[3];
    rghwndButton[0] = GetDlgItem(IDYES);
    rghwndButton[1] = GetDlgItem(IDNO);
    rghwndButton[2] = GetDlgItem(IDCANCEL);

    // get whole dialog rect
	GetClientRect(&dialogRect);

    // get rect of text
	::GetClientRect(hwndText, &textRect);
	::MapWindowPoints(hwndText, m_hWnd, (POINT *) &textRect, 2);

    // get button rects
    for(i = 0; i < 3; i++)
    {
	    ::GetClientRect(rghwndButton[i], &rgButtonRect[i]);
	    ::MapWindowPoints(rghwndButton[i], m_hWnd, (POINT *) &rgButtonRect[i], 2);
    }

    // get help rect
	::GetClientRect(GetDlgItem(IDHELP), &helpRect);
	::MapWindowPoints(GetDlgItem(IDHELP), m_hWnd, (POINT *) &helpRect, 2);

    // get icon rect
	::GetClientRect(GetDlgItem(IDC_ALERTBOX_ICON), &iconRect);
	::MapWindowPoints(GetDlgItem(IDC_ALERTBOX_ICON), m_hWnd, (POINT *) &iconRect, 2);

	// Calc x, y offset from dialog edge to text control
	int textOffsetX = textRect.left - dialogRect.left;
	int textOffsetY = textRect.top - dialogRect.top;

	// Calc y offset from help to button
	int buttonOffsetY = rgButtonRect[0].top - helpRect.bottom;

	// Offset from bottom of button to bottom of dialog
	int buttonOffsetToBottom = dialogRect.bottom - rgButtonRect[0].bottom;

    // Offset between buttons
    int buttonOffsetButton = rgButtonRect[1].left - rgButtonRect[0].right;

    // find the messagebox font
    NONCLIENTMETRICSA oNCM;
    oNCM.cbSize = sizeof(NONCLIENTMETRICSA);
    SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICSA), (void *) &oNCM, 0);
    m_font = CreateFontIndirectA(&oNCM.lfMessageFont);
    ::SendMessage(hwndText, WM_SETFONT, (WPARAM) m_font, 0);

    // get the size of the text
	dc.SelectFont(m_font);
	DrawTextEx(dc, (LPTSTR) (LPCTSTR) m_pAlert->m_Text, -1, &textRect, DT_CALCRECT | DT_WORDBREAK | DT_EXPANDTABS | DT_NOPREFIX, NULL);

    // center text on the icon if it's smaller (plus mive it a little high)
    if(textRect.Height() < iconRect.Height() - 4)
        textOffsetY += iconRect.top - textRect.top + (iconRect.Height() - 4 - textRect.Height()) / 2;

	// Move text window to final location
	::MoveWindow(hwndText, textOffsetX, textOffsetY, textRect.Width(), textRect.Height(), FALSE);

    // re-get text rect
	::GetClientRect(hwndText,&textRect);
	::MapWindowPoints(hwndText, m_hWnd, (POINT*) &textRect, 2);

    // find bottom of text/icon/help
    int stuffBottom = helpRect.bottom;
    if(textRect.bottom > helpRect.bottom)
        stuffBottom = textRect.bottom;

	GotoDlgCtrl(hwndText);

	// Move buttons to final location
    int y = stuffBottom + buttonOffsetY;
	int x0 = (dialogRect.Width() - rgButtonRect[0].Width() * nButtons - buttonOffsetButton * (nButtons - 1)) / 2;
    int dx = rgButtonRect[0].Width() + buttonOffsetButton;
    for(i = 0; i < 3; i++)
    {
        if(!m_pAlert->m_szButton[i].IsEmpty())
        {
	        ::MoveWindow(rghwndButton[i], x0, y, rgButtonRect[i].Width(), rgButtonRect[i].Height(), FALSE);
            ::SetWindowText(rghwndButton[i], m_pAlert->m_szButton[i]);
            if(m_pAlert->m_nDefault == i)
                GotoDlgCtrl(rghwndButton[i]);
            x0 += dx;
        }
        else
            ::ShowWindow(rghwndButton[i], SW_HIDE);
    }

	// Resize dialog
	dialogRect.bottom = y + rgButtonRect[0].Height() + buttonOffsetToBottom;
	MoveWindow(0,0, dialogRect.Width()+2*GetSystemMetrics(SM_CXDLGFRAME), 
		dialogRect.Height()+2*GetSystemMetrics(SM_CXDLGFRAME)+GetSystemMetrics(SM_CYCAPTION),FALSE);

    // set font on help
    oNCM.lfMessageFont.lfUnderline = TRUE;
    m_fontu = CreateFontIndirectA(&oNCM.lfMessageFont);
    ::SendMessage(GetDlgItem(IDHELP), WM_SETFONT, (WPARAM) m_fontu, 0);

	// Center over parent
	CenterWindow( GetParent() );

	dc.RestoreAllObjects();
	ReleaseDC( dc.Detach() );
	
	return 0; // Don't set focus to default
}


LRESULT CAlertDialog::OnDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TCHAR sz[ZONE_MAXSTRING];
    CRect r;
    CRect tmp;
    HBRUSH hBrush;
    DRAWITEMSTRUCT *pDrawItem = (DRAWITEMSTRUCT *) lParam;
    COLORREF fore;

    if(pDrawItem->CtlType != ODT_BUTTON || pDrawItem->CtlID != IDHELP)
        return FALSE;

    GetDlgItemText(pDrawItem->CtlID, sz, NUMELEMENTS(sz));
    r = pDrawItem->rcItem;

    COLORREF colBack = GetBkColor(pDrawItem->hDC);
    COLORREF colFore = GetTextColor(pDrawItem->hDC);
    hBrush = (HBRUSH) SendMessage(WM_CTLCOLORDLG, (WPARAM) pDrawItem->hDC, 0);
    FillRect(pDrawItem->hDC, &r, hBrush);
    SetTextColor(pDrawItem->hDC, colFore);
    colBack = SetBkColor(pDrawItem->hDC, colBack);

    if(colBack != RGB(0, 0, 255))
        fore = RGB(0, 0, 255);
    else
        fore = RGB(255, 255, 255);
    SetTextColor(pDrawItem->hDC, fore);

    // draw 'Help' and figger out text dimensions for focus rect
    r.left += 3;
    tmp = r;
    DrawText(pDrawItem->hDC, sz, lstrlen(sz), &r, DT_LEFT | DT_SINGLELINE | DT_VCENTER);
    DrawText(pDrawItem->hDC, sz, lstrlen(sz), &r, DT_CALCRECT | DT_LEFT | DT_SINGLELINE | DT_VCENTER);
    DrawText(pDrawItem->hDC, sz, lstrlen(sz), &tmp, DT_CALCRECT | DT_LEFT | DT_SINGLELINE | DT_TOP);
    r.top = r.bottom - tmp.Height();

    if(GetFocus() == pDrawItem->hwndItem)
    {
        HPEN hPen = CreatePen(PS_DOT, 0, fore);
        HPEN hPenOld = SelectObject(pDrawItem->hDC, hPen);
        HBRUSH hBrushOld = SelectObject(pDrawItem->hDC, GetStockObject(NULL_BRUSH));
        RoundRect(pDrawItem->hDC, r.left - 3, r.top - 1, r.right + 2, r.bottom + 3, 3, 3);
        SelectObject(pDrawItem->hDC, hPenOld);
        SelectObject(pDrawItem->hDC, hBrushOld);
        DeleteObject(hPen);
    }

    bHandled = TRUE;
    return TRUE;
}


ZONECALL CZoneShell::CZoneShell() :
	m_hPalette( NULL ),
	m_hashDialogs( HashHWND, CmpHWND, NULL, 8, 2 ),
	m_hashTopWindows( HashHWND, TopWindowInfo::Cmp, NULL, 8, 2 ),
	m_hashObjects( HashGuid, ObjectInfo::Cmp, NULL, 8, 2 ),
	m_hashFactories( HashGuid, FactoryInfo::Cmp, NULL, 8, 2 ),
    m_lcid(LOCALE_NEUTRAL)
{
	ZeroMemory( m_szInternalName, sizeof(m_szInternalName) );
	ZeroMemory( m_szUserName, sizeof(m_szUserName) );
}


ZONECALL CZoneShell::~CZoneShell()
{
	m_hashDialogs.RemoveAll();
	m_hashTopWindows.RemoveAll();
	m_hashObjects.RemoveAll( ObjectInfo::Del );
	m_hashFactories.RemoveAll( FactoryInfo::Del );
}


STDMETHODIMP CZoneShell::HandleWindowMessage(MSG *pMsg)
{
    if(m_pIZoneFrameWindow && m_pIZoneFrameWindow->ZPreTranslateMessage(pMsg))
        return S_FALSE;

    if(m_pIInputTranslator && m_pIInputTranslator->TranslateInput(pMsg))
        return S_FALSE;

    if(m_pIAcceleratorTranslator && m_pIAcceleratorTranslator->TranslateAccelerator(pMsg))
        return S_FALSE;

    if(IsDialogMessage(pMsg))
        return S_FALSE;

    ::TranslateMessage(pMsg);
    ::DispatchMessage(pMsg);
    return S_OK;
}


STDMETHODIMP CZoneShell::SetZoneFrameWindow(IZoneFrameWindow *pZFW, IZoneFrameWindow **ppZFW)
{
    if(ppZFW)
    {
        *ppZFW = m_pIZoneFrameWindow;
        if(*ppZFW)
            (*ppZFW)->AddRef();
    }

    m_pIZoneFrameWindow.Release();
    if(pZFW)
        m_pIZoneFrameWindow = pZFW;
    return S_OK;
}


STDMETHODIMP CZoneShell::SetInputTranslator(IInputTranslator *pIT, IInputTranslator **ppIT)
{
    if(ppIT)
    {
        *ppIT = m_pIInputTranslator;
        if(*ppIT)
            (*ppIT)->AddRef();
    }

    m_pIInputTranslator.Release();
    if(pIT)
        m_pIInputTranslator = pIT;
    return S_OK;
}


STDMETHODIMP CZoneShell::SetAcceleratorTranslator(IAcceleratorTranslator *pAT, IAcceleratorTranslator **ppAT)
{
    if(ppAT)
    {
        *ppAT = m_pIAcceleratorTranslator;
        if(*ppAT)
            (*ppAT)->AddRef();
    }

    m_pIAcceleratorTranslator.Release();
    if(pAT)
        m_pIAcceleratorTranslator = pAT;
    return S_OK;
}


STDMETHODIMP CZoneShell::SetCommandHandler(ICommandHandler *pCH, ICommandHandler **ppCH)
{
    if(ppCH)
    {
        *ppCH = m_pICommandHandler;
        if(*ppCH)
            (*ppCH)->AddRef();
    }

    m_pICommandHandler.Release();
    if(pCH)
        m_pICommandHandler = pCH;
    return S_OK;
}


STDMETHODIMP CZoneShell::ReleaseReferences(IUnknown *pUnk)
{
    if(m_pIZoneFrameWindow.IsEqualObject(pUnk))
        m_pIZoneFrameWindow.Release();

    if(m_pIInputTranslator.IsEqualObject(pUnk))
        m_pIInputTranslator.Release();

    if(m_pIAcceleratorTranslator.IsEqualObject(pUnk))
        m_pIAcceleratorTranslator.Release();

    if(m_pICommandHandler.IsEqualObject(pUnk))
        m_pICommandHandler.Release();

    return S_OK;
}


STDMETHODIMP CZoneShell::CommandSink(WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;
    bHandled = false;

    // the Accelerator Translator is inherently interested in commands as well
    if(m_pIAcceleratorTranslator)
    {
        hr = m_pIAcceleratorTranslator->Command(HIWORD(wParam), LOWORD(wParam), (HWND) lParam, bHandled);
        if(bHandled)
            return hr;
    }

    if(m_pICommandHandler)
    {
        hr = m_pICommandHandler->Command(HIWORD(wParam), LOWORD(wParam), (HWND) lParam, bHandled);
        if(bHandled)
            return hr;
    }

    return S_FALSE;
}


STDMETHODIMP CZoneShell::AddDialog(HWND hDlg, bool fOwned)
{
	HWND hWnd = (HWND) m_hashDialogs.Get( hDlg );
	if ( !hWnd )
	{
		if ( !m_hashDialogs.Add( hDlg, (HWND*) hDlg ) )
			return E_OUTOFMEMORY;
	}

    // for convenience, also do the AddOwnedWindow
    if(fOwned)
    {
        HWND hWndTop = FindTopWindow(hDlg);
        if(hWndTop)
            AddOwnedWindow(hWndTop, hDlg);
    }

	return S_OK;
}

STDMETHODIMP CZoneShell::RemoveDialog(HWND hDlg, bool fOwned)
{
	m_hashDialogs.Delete( hDlg );

    if(fOwned)
    {
        HWND hWndTop = FindTopWindow(hDlg);
        if(hWndTop)
            RemoveOwnedWindow(hWndTop, hDlg);
    }

	return S_OK;
}


STDMETHODIMP CZoneShell::AddTopWindow( HWND hWnd )
{
	TopWindowInfo* pInfo = m_hashTopWindows.Get( hWnd );
	if ( !pInfo )
	{
		pInfo = new TopWindowInfo( hWnd );
		if ( !pInfo )
			return E_OUTOFMEMORY;
		if ( !m_hashTopWindows.Add( pInfo->m_hWnd, pInfo ) )
		{
			delete pInfo;
			return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}

STDMETHODIMP CZoneShell::RemoveTopWindow( HWND hWnd )
{
	TopWindowInfo* pInfo = m_hashTopWindows.Delete( hWnd );

	ASSERT( pInfo );
    if(pInfo)
	    delete pInfo;

	return S_OK;
}

STDMETHODIMP_(void) CZoneShell::EnableTopWindow(HWND hWnd, BOOL fEnable)
{
	if ( hWnd )
	{
		TopWindowInfo* pInfo = m_hashTopWindows.Get( hWnd );
		// If this is a top window, en/disable through our refcounted mechanism.
		// Otherwise, just en/disable the window directly
		
//!! does this mess with our refcount?
		if( pInfo )
			pInfo->Enable(fEnable);
		else
			::EnableWindow(hWnd, fEnable);
	} else
	{
		m_hashTopWindows.ForEach(TopWindowCallback, (void*)fEnable);
	}
}

STDMETHODIMP_(HWND) CZoneShell::FindTopWindow(HWND hWnd)
{
    HWND hWndTop;
    TopWindowInfo *pInfo = NULL;
    for(hWndTop = hWnd; hWndTop; hWndTop = GetParent(hWndTop))
        if(m_hashTopWindows.Get(hWndTop))
            return hWndTop;

    return NULL;
}

STDMETHODIMP CZoneShell::AddOwnedWindow(HWND hWndTop, HWND hWnd)
{
	TopWindowInfo* pInfoTop = m_hashTopWindows.Get(hWndTop);

    if(!pInfoTop || !hWnd)
        return E_INVALIDARG;

    OwnedWindowInfo* pInfo = new OwnedWindowInfo(hWnd);

	if(!pInfo)
		return E_OUTOFMEMORY;

    pInfo->m_pNext = pInfoTop->m_pFirstOwnedWindow;
    pInfoTop->m_pFirstOwnedWindow = pInfo;

	return S_OK;
}

STDMETHODIMP CZoneShell::RemoveOwnedWindow(HWND hWndTop, HWND hWnd)
{
	TopWindowInfo* pInfoTop = m_hashTopWindows.Get(hWndTop);

    if(!pInfoTop || !hWnd)
        return E_INVALIDARG;

    OwnedWindowInfo** ppInfo;

    for(ppInfo = &pInfoTop->m_pFirstOwnedWindow; *ppInfo; ppInfo = &(*ppInfo)->m_pNext)
        if((*ppInfo)->m_hWnd == hWnd)
        {
            OwnedWindowInfo* pToDelete = *ppInfo;
            *ppInfo = (*ppInfo)->m_pNext;
            delete pToDelete;
            return S_OK;
        }
            
	return S_FALSE;
}

STDMETHODIMP_(HWND) CZoneShell::GetNextOwnedWindow(HWND hWndTop, HWND hWnd)
{
	TopWindowInfo* pInfoTop = m_hashTopWindows.Get(hWndTop);

    if(!pInfoTop || !hWnd)
        return NULL;

    if(hWnd == hWndTop)
        if(pInfoTop->m_pFirstOwnedWindow)
            return pInfoTop->m_pFirstOwnedWindow->m_hWnd;
        else
            return hWnd;

    OwnedWindowInfo *pInfo;
    for(pInfo = pInfoTop->m_pFirstOwnedWindow; pInfo; pInfo = pInfo->m_pNext)
        if(pInfo->m_hWnd == hWnd)
            if(pInfo->m_pNext)
                return pInfo->m_pNext->m_hWnd;
            else
                return hWndTop;

    return NULL;
}

bool ZONECALL CZoneShell::TopWindowCallback( TopWindowInfo* pInfo, MTListNodeHandle, void* pContext )
{
	pInfo->Enable((BOOL)pContext);
	return true;
}

bool ZONECALL IsDialogMessageCallback( HWND* pObject, MTListNodeHandle hNode, void* Cookie )
{
	if ( ::IsDialogMessage( (HWND) pObject, (MSG*) Cookie ) )
		return false;
	else
		return true;
}


STDMETHODIMP_(bool) CZoneShell::IsDialogMessage( MSG* pMsg )
{
	if ( m_hashDialogs.ForEach( IsDialogMessageCallback, pMsg) )
		return false;
	else
		return true;
}


STDMETHODIMP_(HWND) CZoneShell::GetFrameWindow()
{
    if(m_pIZoneFrameWindow)
        return m_pIZoneFrameWindow->ZGetHWND();
	return NULL;
}


STDMETHODIMP_(void) CZoneShell::SetPalette( HPALETTE hPalette )
{
	m_hPalette = hPalette;
}


STDMETHODIMP_(HPALETTE) CZoneShell::GetPalette()
{
	// assert that if we have a palette, it is still valid.
	ASSERT( !m_hPalette || GetObjectType(m_hPalette) == OBJ_PAL );
	return m_hPalette;
}


STDMETHODIMP_(HPALETTE) CZoneShell::CreateZonePalette()
{
	BOOL		bRet = FALSE;
	HPALETTE	hPal = NULL;
	BYTE		buff[ sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 256) ];
	LOGPALETTE*	pLogPalette = (LOGPALETTE*) buff;

	// get resource manager
	CComPtr<IResourceManager> pRes;
	HRESULT hr = QueryService( SRVID_ResourceManager, IID_IResourceManager, (void**) &pRes );
	if ( FAILED(hr) )
		return NULL;

	// create palette
	ZeroMemory( buff, sizeof(buff) );
	HINSTANCE hInstance = pRes->GetResourceInstance(MAKEINTRESOURCE(IDR_ZONE_PALETTE), _T("PALETTE") );
	HRSRC  hrsrc = FindResource(hInstance, MAKEINTRESOURCE(IDR_ZONE_PALETTE), _T("PALETTE") );
	if ( hrsrc )
	{
		HGLOBAL hMem = LoadResource(hInstance, hrsrc);
		if ( hMem )
		{
			DWORD TotalSize = SizeofResource( hInstance, hrsrc );
            if ( TotalSize == 256 * 3 )
            {
				RGBTriplet* pResPalette = (RGBTriplet*) LockResource( hMem );

                pLogPalette->palVersion = 0x300;
                pLogPalette->palNumEntries = 256;
                for ( int i = 0; i < 256; i++ )
                {
                    pLogPalette->palPalEntry[i].peRed = pResPalette[i].red;
                    pLogPalette->palPalEntry[i].peGreen = pResPalette[i].green;
                    pLogPalette->palPalEntry[i].peBlue = pResPalette[i].blue;
                    pLogPalette->palPalEntry[i].peFlags = 0;
                }

                hPal = CreatePalette( pLogPalette );
				UnlockResource( hMem );
            }
			FreeResource( hMem );
        }
    }

	return hPal;
}


STDMETHODIMP_(LCID) CZoneShell::GetApplicationLCID()
{
    return m_lcid;
}


STDMETHODIMP CZoneShell::ExitApp()
{
	// disable event queue, we shouldn't be processing messages
	// since were trying to shutdown.
	IEventQueue* pIEventQueue = NULL;
	QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &pIEventQueue );
	if ( pIEventQueue )
	{
		pIEventQueue->EnableQueue( false );
		pIEventQueue->ClearQueue();
		pIEventQueue->Release();
	}

	// post close to top-level window
	HWND hWnd = GetFrameWindow();
	if ( hWnd && ::IsWindow(hWnd) )
		::DestroyWindow(hWnd);
	else
		PostMessage( NULL, WM_QUIT, 0, 0 );
	return S_OK;
}


STDMETHODIMP CZoneShell::QueryService( const GUID& srvid, const GUID& iid, void** ppObject )
{
	// find object
	ObjectInfo* pInfo = m_hashObjects.Get( srvid );
	if ( !pInfo )
		return E_NOINTERFACE;

	// get requested interface
	return pInfo->m_pIUnk->QueryInterface( iid, (void**) ppObject );
}


STDMETHODIMP CZoneShell::CreateService( const GUID& srvid, const GUID& iid, void** ppObject, DWORD dwGroupId, bool bInitialize )
{
	// find class factory
	FactoryInfo* pInfo = m_hashFactories.Get( srvid );
	if ( !pInfo )
	{
		return E_NOINTERFACE;
	}

	// create requested object
	HRESULT hr = _Module.Create( pInfo->m_dll, pInfo->m_clsid, iid, ppObject );
	if ( FAILED(hr) )
		return hr;

	// initialize object
	if ( bInitialize )
	{
		// does object have IZoneShellClient
		CComQIPtr<IZoneShellClient>	pClient = *((IUnknown**) ppObject);
		if ( !pClient )
			return S_OK;

		// initialize object
		CComQIPtr<IZoneShell> pShell = GetUnknown();
		hr = pClient->Init( pShell, dwGroupId, pInfo->m_name );
	}

	return hr;
}


void ZONECALL CZoneShell::ConstructAlertTitle( LPCTSTR lpszCaption, TCHAR* szOutput, DWORD cchOutput )
{
	TCHAR	szName[ZONE_MAXSTRING];
	TCHAR	szCaption[ZONE_MAXSTRING];
    TCHAR   szFormat[ZONE_MAXSTRING];
	DWORD	cbName = sizeof(szName);
	
	// initialize strings
	szCaption[0] = _T('\0');
	szName[0] = _T('\0');

	// load caption string
	if ( !lpszCaption )
	{
		szCaption[0] = _T('\0');
		lpszCaption = szCaption;
	}
	else if ( !HIWORD(lpszCaption) )
	{
		int len = ResourceManager()->LoadString( (DWORD)lpszCaption, szCaption, NUMELEMENTS(szCaption) );
		lpszCaption = szCaption;
	}

	// get lobby friendly name
    szName[0] = '\0';
    ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName));

    lstrcpy(szFormat, _T("%1 - %2"));
    ResourceManager()->LoadString(IDS_ALERT_TITLE_FMT, szFormat, NUMELEMENTS(szFormat));

	// construct title (Friendly Name: Caption)
	if ( *szName && *lpszCaption )
		ZoneFormatMessage( szFormat, szOutput, cchOutput, szName, lpszCaption );
	else if ( *szName )
		lstrcpyn( szOutput, szName, cchOutput );
	else
		lstrcpyn( szOutput, lpszCaption, cchOutput );
}


STDMETHODIMP CZoneShell::AlertMessage(HWND hWndParent,
											LPCTSTR lpszText, 
											LPCTSTR lpszCaption,
                                            LPCTSTR szYes,
                                            LPCTSTR szNo,
                                            LPCTSTR szCancel,
                                            long nDefault,
											DWORD dwEventId,
											DWORD dwGroupId,
											DWORD dwUserId,
                                            DWORD dwCookie )
{
	AlertContext* pAlert = new AlertContext;
	pAlert->m_hDlg = NULL;

	pAlert->m_hWndParent = hWndParent;
	pAlert->m_dwEventId = dwEventId;
	pAlert->m_dwGroupId = dwGroupId;
	pAlert->m_dwUserId = dwUserId;
    pAlert->m_dwCookie = dwCookie;

	TCHAR buf[ZONE_MAXSTRING];
    TCHAR sz[ZONE_MAXSTRING];
    TCHAR szName[ZONE_MAXSTRING];

	// if someone specified a MAKEINTRESOURCE type value, load it through the ResourceManager()
	if ( lpszText && !HIWORD(lpszText) )
	{
		int len = ResourceManager()->LoadString((DWORD)lpszText, buf, NUMELEMENTS(buf));
		lpszText = buf;
	}
    lstrcpy(szName, _T("This game"));   // for emergencies
    ResourceManager()->LoadString(IDS_GAME_NAME, szName, NUMELEMENTS(szName));
    if(ZoneFormatMessage(lpszText, sz, NUMELEMENTS(sz), szName))
	    pAlert->m_Text = sz;
    else
        pAlert->m_Text = lpszText;

	ConstructAlertTitle( lpszCaption, buf, NUMELEMENTS(buf) );
	pAlert->m_Caption = buf;

    // do button names
	if ( szYes && !HIWORD(szYes) )
	{
		ResourceManager()->LoadString((DWORD)szYes, buf, NUMELEMENTS(buf));
		szYes = buf;
	}
	pAlert->m_szButton[0] = szYes;
	if ( szNo && !HIWORD(szNo) )
	{
		ResourceManager()->LoadString((DWORD)szNo, buf, NUMELEMENTS(buf));
		szNo = buf;
	}
	pAlert->m_szButton[1] = szNo;
	if ( szCancel && !HIWORD(szCancel) )
	{
		ResourceManager()->LoadString((DWORD)szCancel, buf, NUMELEMENTS(buf));
		szCancel = buf;
	}
	pAlert->m_szButton[2] = szCancel;

    pAlert->m_nDefault = nDefault;

	// Q up and display this alert 
	AddAlert(hWndParent, pAlert);

	return S_OK;
}

STDMETHODIMP CZoneShell::AlertMessageDialog(HWND hWndParent,
											HWND hDlg,
											DWORD dwEventId,
											DWORD dwGroupId,
											DWORD dwUserId,
                                            DWORD dwCookie )
{
	AlertContext* pAlert = new AlertContext;
	pAlert->m_hDlg = hDlg;

	pAlert->m_hWndParent = hWndParent;
	pAlert->m_dwEventId = dwEventId;
	pAlert->m_dwGroupId = dwGroupId;
	pAlert->m_dwUserId = dwUserId;
    pAlert->m_dwCookie = dwCookie;

	// Q up and display this alert 
	AddAlert(hWndParent, pAlert);

	return S_OK;
}

CAlertQ* CZoneShell::FindAlertQ(HWND hWndParent)
{
	// Find the appropriate Q to put this alert on

	// if the alert is global (hWndParent is NULL), then use the global Q
	// otherwise find the queue assoicated with that parent
	CAlertQ* pAlertQ = &m_GlobalAlertQ;

	if ( hWndParent )
	{
		TopWindowInfo* pInfo = m_hashTopWindows.Get( hWndParent );
		if ( pInfo )
			pAlertQ = &pInfo->m_AlertQ;
        else
            pAlertQ = &m_ChildAlertQ;
	}

	return pAlertQ;
}

void CZoneShell::AddAlert( HWND hWndParent, AlertContext* pAlert)
{
	// Add an alert to the Q associated with hWndParent. Display
	// that alert right away if no other alert active.

	CAlertQ* pAlertQ = FindAlertQ(hWndParent);

    pAlert->m_fUsed = false;
    pAlert->m_fSentinel = false;
	pAlertQ->AddTail(pAlert);

	// if this is the first alert, then we can display it right away
    // one new caveat - don't display something subsidiary while something is in the global Q
	if (pAlertQ->Count() == 1 && (pAlertQ == &m_GlobalAlertQ || !m_GlobalAlertQ.Count()))
		DisplayAlertDlg(pAlertQ);
}


bool ZONECALL CZoneShell::TopWindowSearchCallback( TopWindowInfo* pInfo, MTListNodeHandle, void* pContext )
{
    HWND *phWnd = (HWND *) pContext;

    if(::IsWindow(pInfo->m_hWnd) && ::IsWindowVisible(pInfo->m_hWnd))
    {
        *phWnd = pInfo->m_hWnd;
        return false;
    }

	return true;
}


void CZoneShell::DisplayAlertDlg( CAlertQ* pAlertQ )
{
	// display the alert of the head of pAlertQ

	AlertContext* pAlert = pAlertQ->PeekHead();	
	
	// if we're using the stock dialog, create it here
	if ( !pAlert->m_hDlg )
	{
        // get the pointer to the shell from the OUTER unknown, not OUR unknown.
        CComQIPtr<IZoneShell, &IID_IZoneShell> pShell( GetUnknown() );
		// create the dialog. It will self populate itself
		CAlertDialog* pDlg = new CAlertDialog( pShell, pAlert);
        pShell.Release();

        // if no parent, find a parent
        HWND hWndParent = pAlert->m_hWndParent;
        if(!hWndParent)
        {
            hWndParent = GetFrameWindow();

            // make sure it is legal
            if(!::IsWindow(hWndParent) || !::IsWindowVisible(hWndParent))
            {
                // find some other one
                hWndParent = NULL;
		        m_hashTopWindows.ForEach(TopWindowSearchCallback, (void *) &hWndParent);
            }
        }

        // if there's no where to put it, that really sucks
        ASSERT(hWndParent);

		pDlg->Create(hWndParent);
		ASSERT(pDlg->m_hWnd);   // something better should happen here

		// setup the stock dialog as the dialog for this alert
		pAlert->m_hDlg = pDlg->m_hWnd;
	}

	AddDialog(pAlert->m_hDlg, true);
	EnableTopWindow(pAlert->m_hWndParent, FALSE);
	ShowWindow(pAlert->m_hDlg, SW_SHOW);

    pAlert->m_fUsed = true;
}

STDMETHODIMP_(void) CZoneShell::ActivateAlert(HWND hWndParent)
{
	// find the alertQ for this parent HWND
	CAlertQ* pAlertQ = FindAlertQ(hWndParent);

	if (pAlertQ)
	{
		// assert we've found the right alert
		AlertContext* pAlert = pAlertQ->PeekHead();		
		if ( pAlert )
		{
			ASSERT( pAlert->m_hDlg);

			// Bug # 12393 - Dialogs falling behind main window
			SetWindowPos(pAlert->m_hDlg, HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE);
		}
	}
}


bool ZONECALL CZoneShell::TopWindowDialogCallback( TopWindowInfo* pInfo, MTListNodeHandle, void* pContext )
{
    CZoneShell *pThis = (CZoneShell *) pContext;

	if(pInfo->m_AlertQ.Count() && !pInfo->m_AlertQ.PeekHead()->m_fUsed)
        pThis->DisplayAlertDlg(&pInfo->m_AlertQ);
	return true;
}


STDMETHODIMP_(void) CZoneShell::DismissAlertDlg(HWND hWndParent, DWORD dwCtlID, bool bDestoryDlg )
{
	// Dismiss the alert at the head of the Q associated with hWndParent

	// find the alertQ for this parent HWND
	CAlertQ* pAlertQ = FindAlertQ(hWndParent);

	// assert we've found the right alert
	AlertContext* pAlert = pAlertQ->PopHead();		
	ASSERT( pAlert && pAlert->m_hWndParent == hWndParent );
	ASSERT( pAlert->m_hDlg);

	// destroy dialog if request
	if ( bDestoryDlg )
	{
		// Post an event to destroy this window. If we try and destroy here,
		// we may assert on the way out when ATL tries to access some deleted memory.
		CComPtr<IEventQueue> pIEventQueue;
		HRESULT hr = QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &pIEventQueue );
		if ( SUCCEEDED(hr) )
			pIEventQueue->PostEvent( PRIORITY_HIGH, EVENT_DESTROY_WINDOW, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) pAlert->m_hDlg, 0);
	}

	// retore parent window
	EnableTopWindow(pAlert->m_hWndParent, TRUE);

    // bring the root window to the top
    if(::IsWindow(pAlert->m_hWndParent))
    {
        HWND hWndRoot = CALL_MAYBE(GetAncestor)(pAlert->m_hWndParent, GA_ROOTOWNER);
        if(hWndRoot)
            ::BringWindowToTop(hWndRoot);
    }

    // automatically remove as an owned window
    HWND hWndTop = FindTopWindow(pAlert->m_hDlg);
    if(hWndTop)
        RemoveOwnedWindow(hWndTop, pAlert->m_hDlg);
	RemoveDialog(pAlert->m_hDlg, true);
	ShowWindow(pAlert->m_hDlg, SW_HIDE);

	// if required, send out an event indicating this action was completed
	if ( pAlert->m_dwEventId )
	{
		CComPtr<IEventQueue> pIEventQueue;
		QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &pIEventQueue );
		pIEventQueue->PostEvent( PRIORITY_NORMAL, pAlert->m_dwEventId, pAlert->m_dwGroupId, pAlert->m_dwUserId, dwCtlID, pAlert->m_dwCookie);
	}

	// if anything else in the Q, display it now unless we're about to exit
	if(pAlert->m_dwEventId != EVENT_EXIT_APP)
    {
        if(pAlertQ->Count() && (pAlertQ == &m_GlobalAlertQ || !m_GlobalAlertQ.Count()))
		    DisplayAlertDlg(pAlertQ);
        else
            // new - if the global queue is empty, check all the other queues for alerts
            if(pAlertQ == &m_GlobalAlertQ)
            {
                if(m_ChildAlertQ.Count() && !m_ChildAlertQ.PeekHead()->m_fUsed)
                    DisplayAlertDlg(&m_ChildAlertQ);

		        m_hashTopWindows.ForEach(TopWindowDialogCallback, (void *) this);
            }
    }

	// all done with this alert. 
	delete pAlert;
}


STDMETHODIMP_(void) CZoneShell::ClearAlerts(HWND hWndParent)
{
    // find the queue for this window
    CAlertQ *pAlertQ = FindAlertQ(hWndParent);

    // add a sentinel
    AlertContext *pAlert = new AlertContext;
    if(!pAlert)
        return;
    pAlert->m_fSentinel = true;
    pAlertQ->AddTail(pAlert);

    while(1)
    {
        pAlert = pAlertQ->PopHead();
        ASSERT(pAlert);

        // check if we reached the end of the alerts
        if(pAlert->m_fSentinel)
        {
            delete pAlert;
            break;
        }

        // see if this alert belongs to this window
        if(pAlert->m_hWndParent != hWndParent)
        {
            // no - add it back
            pAlertQ->AddTail(pAlert);
            continue;
        }

        // see if this alert has been created -  destroy it if so
        // this may need to be changed to instead not destroy it
        // but it seems to me right now that it generally should
        if(pAlert->m_hDlg)
        {
		    // Post an event to destroy this window. If we try and destroy here,
		    // we may assert on the way out when ATL tries to access some deleted memory.
		    CComPtr<IEventQueue> pIEventQueue;
		    HRESULT hr = QueryService( SRVID_EventQueue, IID_IEventQueue, (void**) &pIEventQueue );
		    if ( SUCCEEDED(hr) )
			    pIEventQueue->PostEvent( PRIORITY_HIGH, EVENT_DESTROY_WINDOW, ZONE_NOGROUP, ZONE_NOUSER, (DWORD) pAlert->m_hDlg, 0);
        }

        // if it was actually up, restore the window.  do not send the ending event for any of the alerts.
        if(pAlert->m_fUsed)
        {
            // automatically remove as an owned window
            HWND hWndTop = FindTopWindow(pAlert->m_hDlg);
            if(hWndTop)
                RemoveOwnedWindow(hWndTop, pAlert->m_hDlg);
	        EnableTopWindow(pAlert->m_hWndParent, TRUE);
	        RemoveDialog(pAlert->m_hDlg, true);
	        ShowWindow(pAlert->m_hDlg, SW_HIDE);
        }

        // that's it
        delete pAlert;
    }

    // if there are any undisplayed leftover alerts, we might want to display one
    if(pAlertQ->Count() && !pAlertQ->PeekHead()->m_fUsed && (pAlertQ == &m_GlobalAlertQ || !m_GlobalAlertQ.Count()))
        DisplayAlertDlg(pAlertQ);

    // if this is the global alert Q and it is empty, try other queues like in DismissAlertDlg
    if(pAlertQ == &m_GlobalAlertQ && !pAlertQ->Count())
    {
        if(m_ChildAlertQ.Count() && !m_ChildAlertQ.PeekHead()->m_fUsed)
            DisplayAlertDlg(&m_ChildAlertQ);

        m_hashTopWindows.ForEach(TopWindowDialogCallback, (void *) this);
    }
}


static HRESULT LoadConfig( IDataStore* pIConfig, int nResourceId, HINSTANCE* arDlls, DWORD nElts )
{
	// load config file from each resource, appending as we go. Note we load
	// them in reverse order and that duplicate entries overwrite, so the most
	// important resource should be listed first.
	HRESULT hr = E_FAIL;
	USES_CONVERSION;
	for ( int i = nElts-1; i >= 0; i-- )
	{
		HRSRC hConfig = FindResource( arDlls[i], MAKEINTRESOURCE(nResourceId), _T("CONFIG") );
		if ( !hConfig )
			continue;
		void* pConfig = LockResource( LoadResource( arDlls[i], hConfig ) );
		if ( !pConfig )
			continue;
		//IMPORTANT: Assumption is config resources is ASCII
		DWORD size=SizeofResource(arDlls[i],hConfig);
		char *pBufferToNULL = (char*)_alloca(size+1);
		if (!pBufferToNULL)
		    return E_FAIL;

        CopyMemory(pBufferToNULL,pConfig,size);
        pBufferToNULL[size]='\0';
		    
		TCHAR *pBuffer= A2T((char*) pBufferToNULL);
		if (!pBuffer)
		    return E_FAIL;
		    
		hr = pIConfig->LoadFromTextBuffer( NULL, pBuffer, lstrlen(pBuffer)*sizeof(TCHAR) );
		if ( FAILED(hr) )
			return hr;
		hr = S_OK;
	}
	return hr;
}


STDMETHODIMP CZoneShell::Init( TCHAR** arBootDlls, DWORD nBootDlls, HINSTANCE* arDlls, DWORD nElts )
{
	ObjectInfo*	pInfo = NULL;
	FactoryInfo* pFactory = NULL;
	ObjectContext ct;

	CComPtr<IDataStoreManager>	pIDataStoreManager;
	CComPtr<IDataStore>			pIConfig;
	CComPtr<IDataStore>			pIUI;
	CComPtr<IDataStore>			pIPreferences;
	CComPtr<IResourceManager>	pIResource;
	
	//
	// create boot strap data store
	//
	HRESULT hr = E_FAIL;
	for ( DWORD i = 0; i < nBootDlls; i++ )
	{
		hr = _Module.Create( arBootDlls[i], CLSID_DataStoreManager, IID_IDataStoreManager, (void**) &pIDataStoreManager );
		if ( SUCCEEDED(hr) )
			break;
	}
	if ( FAILED(hr) )
		return E_FAIL;
	hr = pIDataStoreManager->Init();
	if ( FAILED(hr) )
		return hr;

	//
	// add data store manager to running objects
	//
	pInfo = new ObjectInfo( SRVID_DataStoreManager, pIDataStoreManager, NULL );
	if ( !pInfo )
		return E_OUTOFMEMORY;
	if ( !m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

	//
	// create and initialize object data store
	//
	hr = pIDataStoreManager->Create( &pIConfig );
	if ( FAILED(hr) )
		return hr;
	hr = LoadConfig( pIConfig, IDR_OBJECT_CONFIG, arDlls, nElts );
	if ( FAILED(hr) )
	{
		ASSERT( !_T("Unable to load object config") );
		return E_FAIL;
	}

	//
	// load class factories
	//
	ct.pIDS = pIConfig;
	ct.pObj = this;
	ct.szRoot = NULL;
	hr = pIConfig->EnumKeys( NULL, FactoryCallback, &ct );
	if ( FAILED(hr) )
		return hr;

	//
	// add objects data store to to services
	//
	pInfo = new ObjectInfo( SRVID_DataStoreObjects, pIConfig, NULL );
	if ( !pInfo )
		return E_OUTOFMEMORY;
	if ( !m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

	//
	// create and add resource manager
	//
	hr = CreateServiceInternal( SRVID_ResourceManager, IID_IResourceManager, (void**) &m_pIResourceManager, &pFactory );
	if ( FAILED(hr) )
		return hr;
	pInfo = new ObjectInfo( SRVID_ResourceManager, m_pIResourceManager, pFactory );
	if ( !pInfo )
		return E_OUTOFMEMORY;
	if ( !m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

	// initialize resource manager
	for ( i = 0; i < nElts; i++ )
		m_pIResourceManager->AddInstance( arDlls[i] );
	_Module.SetResourceManager( m_pIResourceManager );

    // also set it into the DataStoreManager which has already been made
    pIDataStoreManager->SetResourceManager(m_pIResourceManager);

	//
	// create and add UI data store to services
	//
	hr = pIDataStoreManager->Create( &pIUI );
	if ( FAILED(hr) )
		return hr;
	hr = LoadConfig( pIUI, IDR_UI_CONFIG, arDlls, nElts );
	if ( FAILED(hr) )
		return hr;
	pInfo = new ObjectInfo( SRVID_DataStoreUI, pIUI, NULL );
	if ( !pInfo )
		return E_OUTOFMEMORY;
	if ( !m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

	//
	// create and add preferences DataStore to services
	//
	hr = pIDataStoreManager->Create( &pIPreferences );
	if ( FAILED(hr) )
		return hr;
	pInfo = new ObjectInfo( SRVID_DataStorePreferences, pIPreferences, NULL );
	if ( !pInfo )
		return E_OUTOFMEMORY;
	if ( !m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

    //
    // determine this app's locale based on the data dll's - the first one to have versioning in it
    //
    for(i = 0; i < nElts; i++)
    {
        m_lcid = LOCALE_NEUTRAL;
        hr = GetModuleLocale(arDlls[i], &m_lcid);
        if(SUCCEEDED(hr))
            break;
    }
    if(PRIMARYLANGID(LANGIDFROMLCID(m_lcid)) == LANG_HEBREW ||
        PRIMARYLANGID(LANGIDFROMLCID(m_lcid)) == LANG_ARABIC)
        CALL_MAYBE(SetProcessDefaultLayout)(LAYOUT_RTL);
    else
        CALL_MAYBE(SetProcessDefaultLayout)(0);

	// load remaing core keys
	ct.pIDS = pIConfig;
	ct.pObj = this;
	ct.szRoot = key_core;
	hr = pIConfig->EnumKeysLimitedDepth( key_core, 1, LoadCallback, &ct );
	if ( FAILED(hr) )
		return hr;

	// initialize objects
	m_hashObjects.ForEach( InitCallback, this );

	return S_OK;
}


STDMETHODIMP CZoneShell::LoadPreferences( CONST TCHAR* szInternalName, CONST TCHAR* szUserName )
{
	TCHAR	szName[ZONE_MAXSTRING];
	HKEY	hKey = NULL;
	HRESULT hr;
	long	ret;

	// verify arguments
	if ( !szInternalName || !szUserName || !szInternalName[0] || !szUserName[0] )
		return E_FAIL;

	// save preferences names
	lstrcpy( m_szInternalName, szInternalName );
	lstrcpy( m_szUserName, GetActualUserName(szUserName) );

	// get preferences data store
	CComPtr<IDataStore> pIDS;
	hr = QueryService( SRVID_DataStorePreferences, IID_IDataStore, (void**) &pIDS );
	if ( FAILED(hr) )
		return hr;

	// load user's zone wide preferences
	wsprintf( szName, _T("%s\\%s\\Zone"), gszPreferencesKey, m_szUserName );
	ret = RegOpenKeyEx( HKEY_CURRENT_USER, szName, 0, KEY_READ, &hKey );
	if ( ret == ERROR_SUCCESS && hKey )
	{
		pIDS->LoadFromRegistry( key_Zone, hKey );
		RegCloseKey( hKey );
		hKey = NULL;
	}

	// load user's lobby preferences
	wsprintf( szName, _T("%s\\%s\\%s"), gszPreferencesKey, m_szUserName, m_szInternalName );
	ret = RegOpenKeyEx( HKEY_CURRENT_USER, szName, 0, KEY_ALL_ACCESS, &hKey );
	if ( ret == ERROR_SUCCESS && hKey )
	{
		pIDS->LoadFromRegistry( key_Lobby, hKey );
		RegCloseKey( hKey );
		hKey = NULL;
	}

	return S_OK;
}


STDMETHODIMP CZoneShell::Close()
{
	TCHAR	szName[ZONE_MAXSTRING];
	HRESULT hr;
	HKEY	hKey = NULL;
	DWORD	dwDisp;
	long	ret;

	// Clear out any alerts in the Q. Clear the global Q here.
	
	while ( AlertContext* pAlert = m_GlobalAlertQ.PopHead() )
	{
		if ( pAlert->m_hDlg )
			DestroyWindow(pAlert->m_hDlg);
		delete pAlert;
	}
	
	// tell all ZoneShell objects we're shutting down
	m_hashObjects.ForEach( CloseCallback, this );

	// After the close, we shouldn't have any alerts (global or top window window).
	ASSERT(!m_GlobalAlertQ.Count());
	ASSERT(!m_hashTopWindows.Count());

	// save user preferences
	if ( m_szInternalName[0] && m_szUserName[0] )
	{
		// get preferences data store
		CComPtr<IDataStore> pIDS;
		hr = QueryService( SRVID_DataStorePreferences, IID_IDataStore, (void**) &pIDS );
		if ( FAILED(hr) )
			return hr;

		// save user's zone wide preferences
		wsprintf( szName, _T("%s\\%s\\Zone"), gszPreferencesKey, m_szUserName );
		ret = RegCreateKeyEx( HKEY_CURRENT_USER, szName, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp );
		if ( ret != ERROR_SUCCESS )
			return E_FAIL;
		pIDS->SaveToRegistry( key_Zone, hKey );
		RegCloseKey( hKey );

		// load user's lobby preferences
		wsprintf( szName, _T("%s\\%s\\%s"), gszPreferencesKey, m_szUserName, m_szInternalName );
		ret = RegCreateKeyEx( HKEY_CURRENT_USER, szName, 0, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &dwDisp );
		if ( ret != ERROR_SUCCESS )
			return E_FAIL;
		pIDS->SaveToRegistry( key_Lobby, hKey );
		RegCloseKey( hKey );
	}

	return S_OK;
}


STDMETHODIMP CZoneShell::Attach( const GUID& srvid, IUnknown* pIUnk )
{
	HRESULT hr = S_OK;

	// verify arguments
	if ( !pIUnk )
		return E_INVALIDARG;

	// wrap object
	ObjectInfo* pInfo = new ObjectInfo( srvid, pIUnk, NULL );
	if ( !pInfo )
		return E_OUTOFMEMORY;

	// add to service list
	if ( !m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// Helper functions
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CZoneShell::CreateServiceInternal( const GUID& srvid, const GUID& iid, void** ppObject, FactoryInfo** ppFactory )
{
	// find class factory
	FactoryInfo* pInfo = m_hashFactories.Get( srvid );
	if ( !pInfo )
	{
		ASSERT( !_T("No class factory registered for service") );
		return E_NOINTERFACE;
	}
	*ppFactory = pInfo;

	// create requested object
	return _Module.Create( pInfo->m_dll, pInfo->m_clsid, iid, ppObject );
}


HRESULT ZONECALL CZoneShell::FactoryCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	TCHAR*  p = NULL;
	GUID	srvid;
	GUID	clsid;
	TCHAR	szTmp[512];
	TCHAR	szGuid[64];
	TCHAR	szDll[MAX_PATH];
	DWORD	cbGuid = sizeof(szGuid);
	DWORD	cbDll = sizeof(szDll);

	ObjectContext* pCT = (ObjectContext*) pContext;
	
	// skip root nodes
	if ( !pVariant )
		return S_OK;

	// does path include srvid?
	p = (TCHAR*) StrInStrI( szKey, _T("srvid") );
	if ( !p || (p == szKey) )
		return S_OK;
	lstrcpyn( szTmp, szKey, (p - szKey) + 1 );
	p = szTmp + (p - szKey);

	// get class factory info
	lstrcpy( p, _T("srvid") );
	HRESULT hr = pCT->pIDS->GetString( szTmp, szGuid, &cbGuid );
	if ( FAILED(hr) )
		return S_OK;
	StringToGuid( szGuid, &srvid );

    // sort of a hack to override loading services.
    // if the service id is GUID_NULL, then don't load it in the first place.
    if ( srvid == GUID_NULL )
        return S_OK;

	lstrcpy( p, _T("clsid") );
	cbGuid = sizeof(szGuid);
	hr = pCT->pIDS->GetString( szTmp, szGuid, &cbGuid );
	if ( FAILED(hr) )
		return S_OK;
	StringToGuid( szGuid, &clsid );
	lstrcpy( p, _T("dll") );
	hr = pCT->pIDS->GetString( szTmp, szDll, &cbDll );
	if ( FAILED(hr) )
		return S_OK;
	*p = _T('\0');

	// add to list
	if ( !pCT->pObj->m_hashFactories.Get( srvid ) )
	{
	    FactoryInfo* info = new FactoryInfo( clsid, srvid, szTmp, szDll );
	    if ( !info )
		    return E_OUTOFMEMORY;
		if ( !pCT->pObj->m_hashFactories.Add( srvid, info ) )
			delete info;
	}

	return S_OK;
}


HRESULT ZONECALL CZoneShell::LoadCallback( CONST TCHAR* szKey, CONST TCHAR* szRelKey, CONST LPVARIANT pVariant, DWORD dwSize, LPVOID pContext )
{
	HRESULT hr;
	GUID	srvid;
	TCHAR	szTmp[512];
	TCHAR	szGuid[64];
	DWORD	cbGuid = sizeof(szGuid);
	CComPtr<IUnknown> pIUnk;

	ObjectInfo*		pInfo = NULL;
	FactoryInfo*	pFactory = NULL;
	ObjectContext*	pCT = (ObjectContext*) pContext;
	
	// skip non-root nodes
	if ( pVariant )
		return S_OK;

	// get srvid
	lstrcpy( szTmp, szKey );
	lstrcat( szTmp, _T("/srvid") );
	hr = pCT->pIDS->GetString( szTmp, szGuid, &cbGuid );
	if ( FAILED(hr) )
		return S_OK;
	StringToGuid( szGuid, &srvid );

    // sort of a hack to override loading services.
    // if the service id is GUID_NULL, then don't load it in the first place.
    if ( srvid == GUID_NULL )
        return S_OK;

	// do we already have this object?
	if ( (srvid == SRVID_DataStoreManager) || (srvid == SRVID_ResourceManager) )
		return S_OK;

	// create object
	hr = pCT->pObj->CreateServiceInternal( srvid, IID_IUnknown, (void**) &pIUnk, &pFactory );
	if ( FAILED(hr) )
	{
#ifdef _DEBUG
		TCHAR szTxt[512];
		if ( !pFactory )
			wsprintf( szTxt, _T("No class factory for %s"), szKey );
		else
			wsprintf( szTxt, _T("Unable to create object %s (%x)"), szKey, hr );
		MessageBox( NULL, szTxt, _T("ZoneShell Error"), MB_OK | MB_TASKMODAL );
#endif
		return hr;
	}

	// add object to running list
	pInfo = new ObjectInfo( srvid, pIUnk, pFactory );
	if ( !pInfo )
		return E_OUTOFMEMORY;
	if ( !pCT->pObj->m_hashObjects.Add( pInfo->m_srvid, pInfo ) )
	{
		delete pInfo;
		return E_OUTOFMEMORY;
	}

	return hr;
}


bool ZONECALL CZoneShell::InitCallback( ObjectInfo* pInfo, MTListNodeHandle, void* pContext )
{
	HRESULT hr;

	// skip dead objects
	if ( !pInfo->m_pIUnk )
		return true;

	// see if object has a IZoneShellClient
	CComQIPtr<IZoneShellClient> pClient = pInfo->m_pIUnk;
	if ( !pClient )
		return true;

	// get IZoneShell from object
	CComQIPtr<IZoneShell> pShell = ((CZoneShell*) pContext)->GetUnknown();
	if ( !pShell )
	{
		ASSERT( !"CZoneShell object in CZoneShell::InitCallback is broken" );
		return true;
	}

	// initialize object
	if ( pInfo->m_pFactory )
		hr = pClient->Init( pShell, ZONE_NOGROUP, pInfo->m_pFactory->m_name );
	else
		hr = pClient->Init( pShell, ZONE_NOGROUP, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( !"CZoneShell object initialization failed" );
	}

	return true;
}


bool ZONECALL CZoneShell::CloseCallback( ObjectInfo* pInfo, MTListNodeHandle, void* pContext )
{
	HRESULT hr;
	CComPtr<IZoneShell>			pShell;
	CComPtr<IZoneShellClient>	pClient;

	// skip dead objects
	if ( !pInfo->m_pIUnk )
		return true;

	// see if object has a IZoneShellClient
	hr = pInfo->m_pIUnk->QueryInterface( IID_IZoneShellClient, (void**) &pClient );
	if ( FAILED(hr) )
		return true;

	// get IZoneShell from object
	hr = ((CZoneShell*) pContext)->GetUnknown()->QueryInterface( IID_IZoneShell, (void**) &pShell );
	if ( FAILED(hr) )
	{
		ASSERT( !"CZoneShell object in CZoneShell::InitCallback is broken or something" );
		return true;
	}

	// close object
	pClient->Close();

	return true;
}

///////////////////////////////////////////////////////////////////////////////
// internal objects
///////////////////////////////////////////////////////////////////////////////

CZoneShell::ObjectInfo::ObjectInfo()
{
	m_pIUnk = NULL;
	m_pFactory = NULL;
	ZeroMemory( &m_srvid, sizeof(m_srvid) );
}


CZoneShell::ObjectInfo::ObjectInfo( const GUID& srvid, IUnknown* pIUnk, FactoryInfo* pFactory )
{
	m_srvid = srvid;
	m_pIUnk = pIUnk;
	m_pFactory = pFactory;
	if ( m_pIUnk )
		m_pIUnk->AddRef();
}


CZoneShell::ObjectInfo::~ObjectInfo()
{
	if ( m_pIUnk )
	{
		m_pIUnk->Release();
		m_pIUnk = NULL;
	}
}


CZoneShell::FactoryInfo::FactoryInfo()
{
	ZeroMemory( &m_srvid, sizeof(m_srvid) );
	ZeroMemory( &m_clsid, sizeof(m_clsid) );
	ZeroMemory( m_dll, sizeof(m_dll) );
	ZeroMemory( m_name, sizeof(m_name) );
}


CZoneShell::FactoryInfo::FactoryInfo( const GUID& clsid, const GUID& srvid, TCHAR* szName, TCHAR* szDll )
{
	m_srvid = srvid;
	m_clsid = clsid;
	lstrcpy( m_dll, szDll );
	lstrcpy( m_name, szName );
}

//////////////////////////////////////////////////////////////////////////////////
//    Little Static Helpers
//////////////////////////////////////////////////////////////////////////////////

static HRESULT GetModuleLocale(HMODULE hMod, LCID *plcid)
{
	DWORD  dwHandle = 0;
	DWORD  dwSize   = 0;
	LPBYTE lpData   = NULL;
    char szFilename[MAX_PATH];

    // first try this hack for MUI Whistler.  we need the MUI dll instead of the english one.
    // based on LpkCheckForMirrorSignature in lpk_init() in the Whistler sources
    // BEGIN HACK
    NTSTATUS                   status = STATUS_UNSUCCESSFUL;
    PVOID                      pImageBase,pResourceData;
    PIMAGE_RESOURCE_DATA_ENTRY pImageResource;
    ULONG                      uResourceSize;
    ULONG                      resIdPath[ 3 ];

    resIdPath[0] = (ULONG) RT_VERSION ;
    resIdPath[1] = (ULONG) 1;
    resIdPath[2] = (ULONG) MAKELANGID( LANG_NEUTRAL , SUBLANG_NEUTRAL );

    status = CALL_MAYBE(LdrFindResourceEx_U)( 
                LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION,
                (PVOID) hMod,
                resIdPath,
                3,
                &pImageResource
                );

    if(NT_SUCCESS(status))
    {
            status = CALL_MAYBE(LdrAccessResource)( (PVOID) hMod ,
                         pImageResource,
                         &pResourceData,
                         &uResourceSize
                         );
    }

    if(NT_SUCCESS(status))
    {
        dwSize = (DWORD) uResourceSize;
        lpData = new BYTE[dwSize];
        if(lpData == NULL)
            return E_OUTOFMEMORY;

        CopyMemory(lpData, (LPBYTE) pResourceData, dwSize);
    }
    else
    {
    // END HACK

    // Get Filename
    if(!GetModuleFileNameA(hMod, szFilename, NUMELEMENTS(szFilename)))
        return E_FAIL;

	//Get size of buffer to hold info
	dwSize = GetFileVersionInfoSizeA(szFilename, &dwHandle);
    if(!dwSize)
        return E_FAIL;

	//Allocate the buffer
	lpData = new BYTE[dwSize];
	if(lpData == NULL)
		return E_OUTOFMEMORY;

	if(!GetFileVersionInfoA(szFilename, dwHandle, dwSize, (LPVOID)lpData))
	{
		delete[] lpData;
		return E_FAIL;
	}

    // BEGIN HACK
    }
    // END HACK

	LPVOID lpvi;
	UINT   iLen = 0;
	if(!VerQueryValueA(lpData, "\\VarFileInfo\\Translation", &lpvi, &iLen) || iLen < 2 )
	{
		delete[] lpData;
		return E_FAIL;
	}

    LANGID langid = *(LANGID *) lpvi;
	*plcid = MAKELCID(langid, SORT_DEFAULT);

	delete[] lpData;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\threadpool\thrdpool.cpp ===
#include <windows.h>
#include "zonedebug.h"
#include "thrdpool.h"

CThreadTask::~CThreadTask()
{
    if ( m_pszDesc )
    {
        delete [] m_pszDesc;
        m_pszDesc = NULL;
    }
}

void CThreadTask::SetDescription( char* pszDesc )
{
    if ( m_pszDesc )
    {
        delete [] m_pszDesc;
        m_pszDesc = NULL;
    }

    if ( pszDesc )
    {
        m_pszDesc = new char[strlen(pszDesc)+1];
        strcpy( m_pszDesc, pszDesc );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\threadpool\compport.cpp ===
// CompPort.cpp : implementation
//

#include <windows.h>
#include "zonedebug.h"
#include "compport.h"

CCompletionPort::CCompletionPort( BOOL bUseCompletionPort ) :
    m_hIoCompPort( NULL ),
    m_hEvent( NULL ),
    m_QueuedCount( 0 ),
    m_queue( NULL ),
    m_pool( NULL )
{
    if ( bUseCompletionPort )
    {
        m_hIoCompPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 );
        ASSERT( m_hIoCompPort );
    }
    else
    {
        m_queue = new CMTList<CPortStatus>;
        m_pool = new CPool<CPortStatus>;

        m_hEvent = ::CreateEvent( NULL, FALSE, FALSE, NULL );
        ASSERT( m_hEvent != NULL );
    }
}


CCompletionPort::~CCompletionPort()
{
    CPortStatus* pNode = NULL;

    if ( m_hIoCompPort )
        ::CloseHandle( m_hIoCompPort );

    if ( m_hEvent )
        ::CloseHandle( m_hEvent );

    if ( m_queue )
    {
        while ( pNode = m_queue->PopTail() )
            delete pNode;

        delete m_queue;
    }

    if ( m_pool )
    {
        delete m_pool;
        m_pool = NULL;
    }
}


BOOL CCompletionPort::Post( LPOVERLAPPED pOverlapped, DWORD cbBytes, DWORD key )
{
    BOOL bRet = TRUE;

    if ( m_hIoCompPort )
    {
        InterlockedIncrement(&m_QueuedCount);
        bRet = PostQueuedCompletionStatus( m_hIoCompPort, cbBytes, key, pOverlapped );
        if ( !bRet )
        {
            ASSERT( bRet );
            InterlockedDecrement(&m_QueuedCount);
        }
    }
    else
    {
        CPortStatus* pNode = new (*m_pool) CPortStatus( cbBytes, key, pOverlapped );
        if ( pNode )
        {
            InterlockedIncrement(&m_QueuedCount);
            if ( !m_queue->AddHead( pNode ) )
            {
                ASSERT( FALSE );
                InterlockedDecrement(&m_QueuedCount);
                bRet = FALSE;
            }

            ::SetEvent( m_hEvent );
        }
        else
        {
            ASSERT( pNode != NULL );
            bRet = FALSE;
        }
    }

    return bRet;
}


BOOL CCompletionPort::Get( LPOVERLAPPED* ppOverlapped, DWORD dwMilliseconds, DWORD* pcbBytes, DWORD* pKey )
{
    ASSERT( ppOverlapped );

    BOOL bRet = TRUE;
    CPortStatus* pNode = NULL;

    if ( m_hIoCompPort )
    {
        DWORD cbBytes = 0;
        DWORD key = 0;
        bRet = GetQueuedCompletionStatus(m_hIoCompPort, &cbBytes, &key, ppOverlapped, dwMilliseconds);

        if ( pcbBytes )
            *pcbBytes = cbBytes;

        if ( pKey )
            *pKey = key;

        pNode = (CPortStatus*)(*ppOverlapped);  // just to let us know we goto something
    }
    else
    {
        DWORD tick = GetTickCount();

        pNode = m_queue->PopTail();

        for (;!pNode;)
        {
            if ( ::WaitForSingleObject( m_hEvent, dwMilliseconds ) != WAIT_OBJECT_0 )
            {
                // we timed out
                ASSERT( dwMilliseconds != INFINITE );
                SetLastError(WAIT_TIMEOUT);
                break;
            }

            // grap a node
            pNode = m_queue->PopTail();
            if ( pNode )
            {
                if ( !m_queue->IsEmpty() )
                    ::SetEvent( m_hEvent );
                break;
            }

            // Hmm, signal but no node.
            if ( dwMilliseconds != INFINITE )
            {
                DWORD now = GetTickCount();
                if ( now - tick < dwMilliseconds )
                {
                    dwMilliseconds -= ( now - tick );
                    tick = now;
                }
            }
        }

        if ( pNode != NULL )
        {
            if ( pcbBytes )
                *pcbBytes = pNode->m_cbBytes;

            if ( pKey )
                *pKey = pNode->m_key;

            *ppOverlapped = pNode->m_pOverlapped;
            delete pNode;
        }
        else
        {
            bRet = FALSE;
        }
    }

    // the user may have enqueued a NULL, so we can not check *ppOverlapped
    if ( bRet || pNode ) // we actually dequeued something
        InterlockedDecrement(&m_QueuedCount);

    return bRet;
}


BOOL CCompletionPort::Associate( HANDLE hFile, DWORD key, DWORD nConcurrentThreads )
{
    BOOL bRet = TRUE;

    if ( m_hIoCompPort )
    {
        bRet = (BOOL) CreateIoCompletionPort( hFile, m_hIoCompPort, key, nConcurrentThreads );
    }
    else
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\coninfo.cpp ===
/*******************************************************************************

    coninfo.cpp
    
        ZSConnection object methods.

    Notes:
    1. When the server receives a message, it sends a message available message
    to the owner. The owner must retrieve the message immediately; otherwise,
    the message is lost.
        
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    1       10/7/96   craigli   Created from zservcon.cpp
     
*******************************************************************************/


#include <windows.h>
#include <winsock.h>
//#include <mswsock.h>
#include <stdio.h>
#include <limits.h>

#define ASSERTE ASSERT
#include <atlbase.h>

#include "zone.h"
#include "zonedebug.h"
#include "zsecurity.h"
#include "zconnint.h"
#include "netstats.h"
#include "zonemsg.h"
#include "eventlog.h"

#include "network.h"
#include "coninfo.h"

#include "protocol.h"

extern CDataPool* g_pDataPool;


//extern BOOL ConIOSetClientSockOpt(SOCKET sock);
//extern BOOL RemoveConnection(ConInfo* con);
//extern BOOL QueueCompletionEvent( HANDLE hEvent, ConInfo* con, CONINFO_OVERLAPPED* lpo );


#if TRACK_IO
extern HANDLE  hLogFile;
#endif

/*****************************************************************/

#define DISABLE_OLD_PROTOCOL    1
#define ACCEPT_TIMEOUT          10000


#define ZRoundUpLenWOFooter(len)        (((len) + 3) & ~0x3)
#define ZRoundUpLenWFooter(len)        (((len) + 3 + sizeof(ZConnInternalGenericFooter)) & ~0x3)
#define ZRoundUpLen(len) (IsAggregateGeneric() ? ZRoundUpLenWFooter(len) : ZRoundUpLenWOFooter(len))

#define MIN_ALLOCATION_SIZE     127



#define zDebugFileName          "zservcon.log"

/*---------------------------------------------------------------*/
/*---------------------------------------------------------------*/


/*
    Global Variables
*/


// we'll allow 5 min for any particular write to complete
/*
DWORD g_RegWriteTimeout = 300000;
DWORD g_DisableEncryption = 0;
DWORD g_MaxRecvSize =  0x08000;
DWORD g_KeepAliveInterval = 120000;
DWORD g_PingInterval = INFINITE;
*/

/*------------------------------------------------------------------------*/






/*********************************************************************************/

void DumpByteStream( char* pBuffer, int len )
{    
    char szBuf[32];
    DWORD bytes;

    for( int ndx = 0; ndx < len; ndx++ )
    {

        if ( (ndx % 16) == 0 )
        {
            lstrcpyA( szBuf, "\n" );
            WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), szBuf, lstrlenA(szBuf)+1, &bytes, NULL );
        }

        //long = (long)*pBuffer++
        wsprintfA( szBuf, "%2.2x ", *(LPBYTE)pBuffer++ );
        WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), szBuf, lstrlenA(szBuf)+1, &bytes, NULL );
    }
    lstrcpyA( szBuf, "\n\n" );
    WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), szBuf, lstrlenA(szBuf)+1, &bytes, NULL );
}

/*********************************************************************************/



/*********************************************************************************/





CPool<ConInfo>* ConInfo::m_pool = NULL;

ACCEPT_EX_PROC ConInfo::m_procAcceptEx;
GET_ACCEPT_EX_SOCKADDRS_PROC ConInfo::m_procGetAcceptExSockaddrs;
HINSTANCE ConInfo::m_hWSock32;
long ConInfo::m_refWSock32;

void ConInfo::SetPool( CPool<ConInfo>* pool )
{
    ASSERT( m_pool == NULL );
    m_pool = pool;
}



ConInfo::ConInfo( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
                  ZSConnectionMessageFunc func, void* conClass, void* userData)
    : ZNetCon( pNet ), m_AccessError(zAccessGranted), m_flags(flags), m_lRefCount(0), m_disconnectLogged(0),
      m_socket(sock), m_addrLocal(addrLocal), m_addrRemote(addrRemote),
      m_messageFunc(func), m_conClass(conClass), m_userData(userData),
      m_dwTimeout(INFINITE), m_dwTimeoutTicks(INFINITE), m_secureKey(0),
      m_initialSequenceID(GetTickCount()),
      m_list(NULL), m_listTimeout(NULL),
      m_rgfProtocolOptions(0),
      m_dwAcceptTick(INFINITE), m_pAccept(NULL), m_qwLastAcceptError(0),
      m_dwPingSentTick(GetTickCount()), m_dwPingRecvTick(0), m_bPingRecv(FALSE), m_dwLatency(INFINITE),
      m_readSequenceID(0), m_readState(zConnReadStateInvalid),
      m_readMessageData(NULL), m_readBuffer(NULL), m_readLen(0), m_readBytesRead(0),
      m_writeSequenceID(0), m_writeState(zConnWriteStateInvalid),
      m_writeBuffer(NULL), m_writeLen(0), m_writeBytesWritten(0), m_sendFilter(NULL),
      m_writeQueue(NULL), m_writeBytesQueued(0), m_writeIssueTick(0), m_writeCompleteTick(GetTickCount())
{
    ASSERT(flags);

#if DBG_CONINFO_REF
    ZeroMemory( m_lDbgRefCount, sizeof(m_lDbgRefCount) );
#endif

    InitializeCriticalSection(m_pCS);

    AddRef( CONINFO_REF );

    m_readSequenceID = m_initialSequenceID;
    m_writeSequenceID = m_initialSequenceID;

    ZeroMemory( m_pGUID, sizeof(m_pGUID) );
    ZeroMemory( m_lpoRead, sizeof( m_lpoRead ) );
    ZeroMemory( m_lpoWrite, sizeof( m_lpoWrite ) );

    if ( !GetNetwork()->IsCompletionPortEnabled() )
    {
        m_lpoRead->o.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        m_lpoWrite->o.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    }

    m_flags = flags | INIT;

    InterlockedIncrement(&(GetNetwork()->m_ConInfoCount));

    if ( IsAcceptedConnection() )  // just accepted connections
    {
        // update stats before completion port since we'll decrement
        // them in the delete if there is an error
        InterlockedIncrement((long*)&g_NetStats.CurrentConnections);

        LockNetStats();
        if ( g_NetStats.CurrentConnections > g_NetStats.MaxConnections )
        {
            g_NetStats.MaxConnections = g_NetStats.CurrentConnections;
        }
        UnlockNetStats();
    }
}


ConInfo::~ConInfo()
{
    ASSERT( m_list == NULL );
    ASSERT( m_listTimeout == NULL );
    ASSERT( m_lRefCount == 0 );

#if DBG_CONINFO_REF
    for ( int ndx = 0; ndx < LAST_REF; ndx++ )
    {
        ASSERT( m_lDbgRefCount[ndx] == 0 );
    }
#endif


    ASSERT(m_flags & CLOSING); 

    ASSERT(m_socket == INVALID_SOCKET );
    ASSERT(m_readMessageData == NULL );
    if ( m_readMessageData )
    {
        LPTSTR ppStr[] = { TEXT("ConInfo::~ConInfo - m_readMessageData was not NULL.  The data is the coninfo object." ) };
        ZoneEventLogReport( ZONE_E_ASSERT, 1, ppStr, sizeof(ConInfo), this );

        g_pDataPool->Free(m_readMessageData, m_readLen );
        m_readMessageData = NULL;
    }    

    ASSERT(m_writeBuffer == NULL );
    ASSERT(m_writeQueue == NULL );

    if ( !GetNetwork()->IsCompletionPortEnabled() )
    {
        CloseHandle(m_lpoRead->o.hEvent);
        CloseHandle(m_lpoWrite->o.hEvent);
    }
    ZeroMemory( m_lpoRead, sizeof( m_lpoRead ) );
    ZeroMemory( m_lpoWrite, sizeof( m_lpoWrite ) );

    // TODO reset each member variable

    m_addrLocal = INADDR_NONE;
    m_addrRemote = INADDR_NONE;
    m_messageFunc     = NULL;
    m_sendFilter      = NULL;
    m_conClass = NULL;
    m_userData = NULL;

    if ( m_pAccept )
    {
        if ( !GetNetwork()->IsCompletionPortEnabled() )
        {
            for ( WORD ndx = 0; ndx < m_pAccept->wNumInst; ndx++ )
            {
                CloseHandle( m_pAccept->pInst[ndx].lpo->o.hEvent );
            }
        }
        delete [] m_pAccept->pInst;
        delete m_pAccept;
        m_pAccept = NULL;
    }

    if ( IsAcceptedConnection() ) 
    {
        InterlockedDecrement((long*)&g_NetStats.CurrentConnections);
    }

    InterlockedDecrement(&(GetNetwork()->m_ConInfoCount));

    DeleteCriticalSection(m_pCS);

    m_flags = FREE;

    m_disconnectLogged = 0;
}



ConInfo* ConInfo::Create(ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags, ZSConnectionMessageFunc func, void* conClass, void* userData)
{
    IF_DBGPRINT( DBG_CONINFO, ("ConInfo::Create: Entering\n") );

    ASSERT(sock != INVALID_SOCKET );

    ConInfo *con;
    if ( m_pool )
    {
        con = new (*m_pool) ConInfo( pNet, sock, addrLocal, addrRemote, flags, func, conClass, userData );
    }
    else
    {
        con = new ConInfo( pNet, sock, addrLocal, addrRemote, flags, func, conClass, userData );
    }

    if (!con)
    {
        ASSERT(con);
        return NULL;
    }

    return con;
}

ConInfo* ConInfo::AcceptCreate(ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags, ZSConnectionMessageFunc func, void* conClass, void* userData)
{
    return ConInfo::Create(pNet,sock, addrLocal, addrRemote, flags|ACCEPTED,func,conClass,userData);
}

void  ConInfo::SendCloseMessage()
{
    EnterCriticalSection(m_pCS);
    if ( !IsCloseMsgSent() )
    {
        m_flags |= CLOSE_MSG_SENT;
        SendMessage(zSConnectionClose);
    }
    LeaveCriticalSection(m_pCS);
}


void  ConInfo::Close()
{
    EnterCriticalSection(m_pCS);

    ASSERT(GetFlags());

    if ( !IsClosing() && (m_socket != INVALID_SOCKET) )
    {
        m_flags |= CLOSING;

        SendCloseMessage();

        if (closesocket(m_socket) == SOCKET_ERROR )
        {
            IF_DBGPRINT(DBG_CONINFO, ("... Error while closing %d (WSAGetLastError = %d).\n", m_socket, WSAGetLastError()) );
        }

        m_socket = INVALID_SOCKET;

        if ( m_list || m_listTimeout )  // since the user processes don't call ZServerConnectionClose...
        {
            GetNetwork()->RemoveConnection(this);
        }

        LeaveCriticalSection(m_pCS);

        ASSERT( m_lRefCount );
        Release(CONINFO_REF);

        LockNetStats();
        g_NetStats.TotalDisconnects.QuadPart++;
        UnlockNetStats();

    }
    else
    {
        LeaveCriticalSection(m_pCS);
    }

}


void ConInfo::Disable()
{
    ASSERT(GetFlags());
    m_flags |= DISABLED;
    SendCloseMessage();
}

BOOL ConInfo::IsTimedOut(DWORD elapsed)
{
    ASSERT(GetFlags());
    if ( m_dwTimeout != INFINITE )
    {
        if ( elapsed >= m_dwTimeout )
        {
            return TRUE;
        }
        else
        {
            m_dwTimeout -= elapsed;
        }
    }
    return FALSE;
}


void ConInfo::SendMessage(uint32 msg)
{ 
    ASSERT(GetFlags());
    ASSERT(m_messageFunc);
    AddRef(USERFUNC_REF);
    (*m_messageFunc)( (ZSConnection)this, msg ,m_userData);
    Release(USERFUNC_REF);
}

BOOL ConInfo::FilterAndQueueSendData(uint32 type, char* data, int32 len, uint32 dwSignature, uint32 dwChannel /* = 0 */)
{
    ASSERT(GetFlags());

    if ( IsDisabled() || IsSuspended() )
    {
        return FALSE;
    }

    BOOL bRet = FALSE;

    EnterCriticalSection(m_pCS);

    BOOL bPassedFilter = TRUE;
    if ( m_sendFilter )
    {
        AddRef(USERFUNC_REF);
        bPassedFilter = (*m_sendFilter)( (ZSConnection)this, m_userData, type, data, len, dwSignature, dwChannel );
        Release(USERFUNC_REF);
    }

    if ( bPassedFilter )
    {
        bRet = QueueSendData( type, data, len, dwSignature, dwChannel );
    }

    LeaveCriticalSection(m_pCS);

    return bRet;
}

BOOL ConInfo::QueueSendData(uint32 type, char* data, int32 len, uint32 dwSignature, uint32 dwChannel /* = 0 */)
{
    ASSERT( data || ( !data && !len ) );

    BOOL  bRet = FALSE;
    char* pBuffer;
    EnterCriticalSection(m_pCS);

    switch (WriteGetState())
    {
        case zConnWriteStateSecureMessage:
            if(WriteFormatMessage(type, data, len, dwSignature, dwChannel))
            {
                Write();
                bRet = TRUE;
            }
            break;

        case zConnWriteStateFirstMessageSC:
            ASSERT(!"Trying to send prematurely on a secure link" );
            break;
        default:
            ASSERT(!"******QueueSendData - Invalid state.******");
            break;
    }
    LeaveCriticalSection(m_pCS);

    return bRet;
}    



char* ConInfo::GetReceivedData(uint32 *type, int32 *len, uint32 *pdwSignature, uint32 *pdwChannel /* = NULL */)
{
    ASSERT( GetFlags() & READ );

    char* m;
    ZConnInternalAppHeader *h;

    if ( IsSecureConnection() ) 
    {
        h  = (ZConnInternalAppHeader *) m_readMessageData;
        m =  m_readMessageData + sizeof(*h);
    } 
    else 
    {
        h = &m_uRead.MessageHeader;
        m = m_readMessageData;
    }

    if (type != NULL)
    {
        *type = h->dwType;
    }
    if (len != NULL)
    {
        *len = h->dwDataLength;
    }
    if(pdwSignature)
        *pdwSignature = h->dwSignature;
    if(pdwChannel)
        *pdwChannel = h->dwChannel;

    return m;
}


void ConInfo::KeepAlive()
{
    USES_CONVERSION;
    if ( ( m_socket != INVALID_SOCKET ) && m_writeIssueTick && !m_disconnectLogged )
    {
        DWORD delta = GetTickDelta( GetTickCount(), m_writeIssueTick );
        if ( delta > GetNetwork()->m_RegWriteTimeout )
        {
#if TRACK_IO
            CloseHandle( hLogFile );
            hLogFile = INVALID_HANDLE_VALUE;
#endif // TRACK_IO

            m_disconnectLogged = 1;

            LockNetStats();
            g_NetStats.TotalDroppedConnections.QuadPart++;
            UnlockNetStats();

            if ( g_LogServerDisconnects )
            {
                TCHAR szBuf[128];
                lstrcpy( szBuf, A2T(GetRemoteName() ));
                LPTSTR ppStr[] = { szBuf };
                ZoneEventLogReport( ZONE_S_TIMED_OUT_WRITE_APC, 1, ppStr, sizeof(delta), &delta );
            }

            Close();
        }
    }
    if ( ( m_socket != INVALID_SOCKET ) && IsEstablishedConnection() && (WriteGetState()==zConnWriteStateSecureMessage) )
    {
        if ( GetTickDelta( GetTickCount(), m_writeCompleteTick ) > GetNetwork()->m_KeepAliveInterval )
        {
            QueueSendData(zConnectionKeepAlive, NULL, 0, zProtocolSigInternalApp);   // could fail... not important i guess
        }
    }
}


BOOL ConInfo::InitiateSecurityHandshake()
{
    ASSERT(GetFlags());
    if ( !WriteSetState(zConnWriteStateFirstMessageSC) )
    {
        return FALSE;
    }


    ZConnInternalHiMsg msg;
    ZeroMemory( &msg, sizeof(msg) );

    msg.oHeader.dwSignature = zConnInternalProtocolSig;
    msg.oHeader.dwTotalLength = sizeof(msg);
    msg.oHeader.weType = zConnInternalHiMsg;
    msg.oHeader.wIntLength = sizeof(msg);
    msg.dwProtocolVersion = zConnInternalProtocolVersion;
    msg.dwOptionFlagsMask = 0;
    msg.dwProductSignature = GetNetwork()->m_ProductSignature;

    // this should move into the network object so that you can do something like GetNetwork()->m_puuLocalMachine;
    TCHAR  szGUID[] = TEXT("GUID");
    DWORD disposition;
    HKEY  hkey = NULL;
    if( ERROR_SUCCESS == RegCreateKeyEx( HKEY_CLASSES_ROOT, TEXT("CLSID\\{32b9f4be-3472-11d1-927d-00c04fc2db04}"),0, NULL, REG_OPTION_NON_VOLATILE,
                                         KEY_READ | KEY_WRITE, NULL,&hkey,&disposition ) && hkey )
    {
        DWORD cbSize = sizeof(msg.uuMachine);
        DWORD type = 0;

        // if we haven't written guid before
        if(!(ERROR_SUCCESS == RegQueryValueEx(hkey,szGUID,0,&type,(LPBYTE) &msg.uuMachine, &cbSize)
            && type == REG_BINARY
            && cbSize == sizeof(msg.uuMachine)))
        {
			// create new signup info
            if(SUCCEEDED(UuidCreate(&msg.uuMachine)))
            {
                RegSetValueEx(hkey, szGUID, 0, REG_BINARY, (LPBYTE) &msg.uuMachine, sizeof(msg.uuMachine));
            }
        }

        RegCloseKey(hkey);
    }

    ZSecurityEncrypt( (char*)&(msg), sizeof(msg), zSecurityDefaultKey);
    // be quick and dirty about this small message... 
    if ( !WriteSync((char*)&msg, sizeof(msg) ) ||
         !ReadSetState(zConnReadStateFirstMessageSC) )
    {
        return FALSE;
    }

    return TRUE;
}


void ConInfo::OverlappedIO( DWORD type, char* pBuffer, int len )
{
    ASSERT( pBuffer );
    ASSERT(GetFlags());
    USES_CONVERSION;
    switch ( type )
    {
        case CONINFO_OVERLAP_READ:
        {
            m_lpoRead->flags = CONINFO_OVERLAP_READ | CONINFO_OVERLAP_ENABLED;
            if ( GetNetwork()->IsCompletionPortEnabled() )
            {
                ZeroMemory(m_lpoRead, sizeof(OVERLAPPED) );
            }
            else
            {
                m_lpoRead->o.Internal = 0;
                m_lpoRead->o.InternalHigh = 0;
                m_lpoRead->o.Offset = 0;
                m_lpoRead->o.OffsetHigh = 0;
                ResetEvent( m_lpoRead->o.hEvent );

                GetNetwork()->QueueCompletionEvent( m_lpoRead->o.hEvent, this, m_lpoRead );
            }

            // update stats
            LockNetStats();
            g_NetStats.TotalReadAPCs.QuadPart++;
            UnlockNetStats();

            AddRef(READ_REF);
            
            IF_DBGPRINT( DBG_CONINFO, ("-> ReadFile(%d) %d bytes\n", m_socket, len ) );

            DWORD cbRead;
            BOOL bRet = ReadFile( (HANDLE)m_socket, pBuffer, len, &cbRead, (LPOVERLAPPED)m_lpoRead );
            if ( !bRet )
            {
                DWORD dwError = GetLastError();
                switch( dwError )
                {
                    case ERROR_IO_PENDING:
                        // we're happy
                        break;
                    case ERROR_INVALID_USER_BUFFER:
                    case ERROR_NOT_ENOUGH_MEMORY:
                        ASSERT( !"TODO Too many APCs. We need to queue this IO for later processing\n" );
                        // fall thru for now
                    default:  // generate an error to close connection by cbTrans being 0
                        if ( ( m_socket != INVALID_SOCKET) && !m_disconnectLogged )
                        {
                            m_disconnectLogged = 1;

                            LockNetStats();
                            g_NetStats.TotalDroppedConnections.QuadPart++;
                            UnlockNetStats();

                            if ( g_LogServerDisconnects )
                            {
                                TCHAR szBuf1[128];
                                TCHAR szBuf2[128];
                                lstrcpy( szBuf1, A2T(GetRemoteName()) );
                                wsprintf( szBuf2, TEXT(" was closed because ReadFile returned error %d"), dwError );
                                LPTSTR ppStr[] = { szBuf1, szBuf2 };
                                ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, 0, NULL );
                            }

                        }
                        if ( GetNetwork()->IsCompletionPortEnabled() )
                        {
                            PostQueuedCompletionStatus( GetNetwork()->m_hIO, 0, (DWORD)this, (LPOVERLAPPED)m_lpoRead );
                        }
                        else
                        {
                            m_lpoRead->flags = m_lpoRead->flags & ~CONINFO_OVERLAP_ENABLED;
                            SetEvent( m_lpoRead->o.hEvent );
                        }
                        break;
                }
            }
            break;
        }

        case CONINFO_OVERLAP_WRITE:
        {
            m_lpoWrite->flags = CONINFO_OVERLAP_WRITE | CONINFO_OVERLAP_ENABLED;
            if ( GetNetwork()->IsCompletionPortEnabled() )
            {
                ZeroMemory(m_lpoWrite, sizeof(OVERLAPPED) );
            }
            else
            {
                m_lpoWrite->o.Internal = 0;
                m_lpoWrite->o.InternalHigh = 0;
                m_lpoWrite->o.Offset = 0;
                m_lpoWrite->o.OffsetHigh = 0;
                ResetEvent( m_lpoWrite->o.hEvent );

                GetNetwork()->QueueCompletionEvent( m_lpoWrite->o.hEvent, this, m_lpoWrite );
            }

            // update statys
            LockNetStats();
            g_NetStats.TotalWriteAPCs.QuadPart++;
            UnlockNetStats();

            AddRef(WRITE_REF);

            m_writeIssueTick = GetTickCount();
            if ( m_writeIssueTick == 0 )  // reserve 0 for now outstanding write
                m_writeIssueTick = 1;

            IF_DBGPRINT( DBG_CONINFO, ("-> WriteFile(%d) %d bytes\n", m_socket, len ) );

            DWORD cbWritten;
            BOOL bRet = WriteFile( (HANDLE)m_socket, pBuffer, len, &cbWritten, (LPOVERLAPPED)m_lpoWrite );
            if ( !bRet )
            {
                DWORD dwError = GetLastError();
                switch( dwError )
                {
                    case ERROR_IO_PENDING:
                        // we're happy
                        break;
                    case ERROR_INVALID_USER_BUFFER:
                    case ERROR_NOT_ENOUGH_MEMORY:
                        ASSERT( !"TODO Too many APCs. We need to queue this IO for later processing\n" );
                        // fall thru for now
                    default:  // generate an error to close connection by cbTrans being 0
                        if ( ( m_socket != INVALID_SOCKET) && !m_disconnectLogged )
                        {
                            m_disconnectLogged = 1;

                            LockNetStats();
                            g_NetStats.TotalDroppedConnections.QuadPart++;
                            UnlockNetStats();

                            if ( g_LogServerDisconnects )
                            {
                                TCHAR szBuf1[128];
                                TCHAR szBuf2[128];
                                lstrcpy( szBuf1, A2T(GetRemoteName()) );
                                wsprintf( szBuf2, TEXT(" was closed because WriteFile returned error %d"), dwError );
                                LPTSTR ppStr[] = { szBuf1, szBuf2 };
                                ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, 0, NULL );
                            }
                        }
                        if ( GetNetwork()->IsCompletionPortEnabled() )
                        {
                            PostQueuedCompletionStatus( GetNetwork()->m_hIO, 0, (DWORD)this, (LPOVERLAPPED)m_lpoWrite );
                        }
                        else
                        {
                            m_lpoWrite->flags = m_lpoWrite->flags & ~CONINFO_OVERLAP_ENABLED;
                            SetEvent( m_lpoWrite->o.hEvent );
                        }
                        break;
                }
            }
            break;
        }

        default:
            ASSERT( !"Invalid type for OverlappedIO" );
            break;
    }
}


/*------------------------------------------------------------------------*/
//                   ConInfo Accept functionality
/*------------------------------------------------------------------------*/

ConInfo* ConInfo::AcceptComplete(WORD ndxAccept, DWORD error)
{    
    IF_DBGPRINT( DBG_CONINFO, ("ConInfoAccept (0x%x): Entering ...\n", this) );

    ASSERT(GetFlags()); 

    if ( !IsServerConnection() )
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConInfo::AcceptComplete with unknown state %d.\n",m_socket) );
        return NULL;
    }

    ASSERT( m_pAccept );
    ASSERT( ndxAccept < m_pAccept->wNumInst );

    // TODO BUGBUG we need to track the accept socket current connections
    if ( (error != NO_ERROR) ||
         (m_pAccept->pInst[ndxAccept].Socket == INVALID_SOCKET) ||
         (g_NetStats.CurrentConnections >= m_pAccept->dwMaxConnections) )
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConInfo::Accept: shutting down\n" ) );
        if ( m_pAccept->pInst[ndxAccept].Socket != INVALID_SOCKET )
        {
            closesocket( m_pAccept->pInst[ndxAccept].Socket );
            m_pAccept->pInst[ndxAccept].Socket = INVALID_SOCKET;
        }

        if(error != ERROR_SHUTDOWN_IN_PROGRESS)
        {
            if(error != NO_ERROR)
            {
                IF_DBGPRINT(DBG_CONINFO, ("ConInfo::AcceptComplete completed with error %d.\n",error));

                ULARGE_INTEGER qwNow;
                GetSystemTimeAsFileTime((LPFILETIME) &qwNow);
                if(qwNow.QuadPart - m_qwLastAcceptError > (ULONGLONG) 3 * 60 * 1000 * 10000)  // only report this every three minutes
                {
                    m_qwLastAcceptError = qwNow.QuadPart;

                    ZoneEventLogReport(ZONE_E_ACCEPT_COMPLETE_ERROR, 0, NULL, sizeof(error), &error);
                }
            }

            AcceptNext(ndxAccept);
        }

        Release(ACCEPT_REF);
        return NULL;
    }

    LockNetStats();
    g_NetStats.ConnectionAttempts.QuadPart++;
    g_NetStats.TotalConnects.QuadPart++;
    UnlockNetStats();

    ConInfo* conNew = NULL;
    HANDLE hIO = NULL;

    if ( !GetNetwork()->ConIOSetClientSockOpt(m_pAccept->pInst[ndxAccept].Socket) )
        goto error;

    // get the peer IP sockaddr from the AcceptEx buffer
    LPSOCKADDR_IN pLocal, pRemote;
    int local, remote;

    (*m_procGetAcceptExSockaddrs) (
        m_pAccept->pInst[ndxAccept].pBuffer,
        0,
        128,
        128,
        (LPSOCKADDR*)&pLocal,
        &local,
        (LPSOCKADDR*)&pRemote,
        &remote    
       );    

    ZEnd32(&(pLocal->sin_addr.s_addr));
    ZEnd32(&(pRemote->sin_addr.s_addr));

    conNew = AcceptCreate(GetNetwork(), m_pAccept->pInst[ndxAccept].Socket,
                          pLocal->sin_addr.s_addr, pRemote->sin_addr.s_addr,
                          READ | WRITE, m_messageFunc, m_conClass, m_userData);

    if (!conNew)  /* out of connection pool structures */
    {
        goto error;        
    }

    IF_DBGPRINT( DBG_CONINFO, ( "Accepting new connection 0x%x %d\n", conNew, conNew->m_socket ) );

    if ( GetNetwork()->IsCompletionPortEnabled() )
    {
        hIO = CreateIoCompletionPort( (HANDLE)m_pAccept->pInst[ndxAccept].Socket, GetNetwork()->m_hIO, (DWORD)conNew, 0 );
        ASSERT( hIO == GetNetwork()->m_hIO );
        if ( !hIO )
        {
            IF_DBGPRINT( DBG_CONINFO, ( "Error associating socket w/ completion port - %d\n", GetLastError() ) );
            conNew->Close();
            conNew = NULL;
            goto error; // don't go to error because close adjust counters
        }
    }

    conNew->m_dwAcceptTick = GetTickCount();

    conNew->SetTimeoutTicks(ACCEPT_TIMEOUT);

    if ( !conNew->ReadSetState(zConnReadStateHiMessageCS) )
    {
        // readsetstate will have performed a close
        conNew = NULL;
        goto error;
    }


    //FilePrint(zDebugFileName, TRUE, "Accepted socket %d", m_pAccept->Socket);

    goto next_accept;

error:
    DebugPrint("ConInfo::Accept: ERROR - %d.\n", GetLastError() );
    LockNetStats();
    g_NetStats.TotalDisconnects.QuadPart++;
    UnlockNetStats();
    closesocket(m_pAccept->pInst[ndxAccept].Socket);
    m_pAccept->pInst[ndxAccept].Socket = INVALID_SOCKET;

next_accept:
    AcceptNext(ndxAccept);

    Release(ACCEPT_REF);
    
    return conNew;
}



BOOL ConInfo::AcceptInit( DWORD dwMaxConnections, WORD wOutstandingAccepts )
{
    ASSERT( IsServerConnection() );
    ASSERT( !m_pAccept );
    ASSERT( wOutstandingAccepts );

    // TODO BUGBUG make this thread safe and callable multiple times
    //      ALSO, clean it up
    InterlockedIncrement( &m_refWSock32 );
    if ( !m_hWSock32 )
    {
        m_hWSock32 = LoadLibrary( TEXT("mswsock.dll" ));
        if ( m_hWSock32 )
        {
            m_procAcceptEx = (ACCEPT_EX_PROC) GetProcAddress( m_hWSock32, "AcceptEx" );
            m_procGetAcceptExSockaddrs = (GET_ACCEPT_EX_SOCKADDRS_PROC) GetProcAddress( m_hWSock32, "GetAcceptExSockaddrs" );
        }
    }

    if ( (BOOL)m_procAcceptEx && (BOOL)m_procGetAcceptExSockaddrs )
    {
        m_pAccept = new AcceptStruct;
        m_pAccept->dwMaxConnections = dwMaxConnections;
        m_pAccept->dwCurrentConnections = 0;
        m_pAccept->wNumInst = wOutstandingAccepts;

        m_pAccept->pInst = new AcceptInst[m_pAccept->wNumInst];

        for ( WORD ndx = 0; ndx < m_pAccept->wNumInst; ndx++ )
        {
            ZeroMemory( m_pAccept->pInst[ndx].lpo, sizeof( m_pAccept->pInst[ndx].lpo ) );
            if ( !GetNetwork()->IsCompletionPortEnabled() )
            {
                m_pAccept->pInst[ndx].lpo->o.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
            }

            if ( !AcceptNext(ndx) )  // bail out if acceptnext fails
            {
                break;
            }
        }

        return ( ndx ) ? TRUE : FALSE; // consider it a success if we queued at least one accept
    }

    return FALSE;

}

BOOL ConInfo::AcceptNext( WORD ndxAccept )
{
    ASSERT( IsServerConnection() );
    ASSERT( m_pAccept );
    ASSERT( ndxAccept < m_pAccept->wNumInst );

    m_pAccept->pInst[ndxAccept].Socket = socket(AF_INET,SOCK_STREAM,0);
    if ( m_pAccept->pInst[ndxAccept].Socket == INVALID_SOCKET )
    {
        int err = WSAGetLastError();
        ZoneEventLogReport( ZONE_E_ACCEPT_SOCKET_FAILED, 0, NULL, sizeof(err), &err );

        DebugPrint( "Unabled to allocate socket for accept - no new connections will be accepted\n" );
        //CloseHandle(GetNetwork()->m_hIO); // leave handle open so existing connections continue
        return FALSE;
    }

    DWORD cbRecv;

    m_pAccept->pInst[ndxAccept].lpo->flags = CONINFO_OVERLAP_ACCEPT | CONINFO_OVERLAP_ENABLED;
    if ( GetNetwork()->IsCompletionPortEnabled() )
    {
        ZeroMemory(m_pAccept->pInst[ndxAccept].lpo, sizeof(OVERLAPPED) );
    }
    else
    {
        m_pAccept->pInst[ndxAccept].lpo->o.Internal = 0;
        m_pAccept->pInst[ndxAccept].lpo->o.InternalHigh = 0;
        m_pAccept->pInst[ndxAccept].lpo->o.Offset = 0;
        m_pAccept->pInst[ndxAccept].lpo->o.OffsetHigh = 0;
        ResetEvent( m_pAccept->pInst[ndxAccept].lpo->o.hEvent );

        GetNetwork()->QueueCompletionEvent( m_pAccept->pInst[ndxAccept].lpo->o.hEvent, this, m_pAccept->pInst[ndxAccept].lpo );
    }

    AddRef(ACCEPT_REF);

    BOOL bRet = ( *m_procAcceptEx )(
        m_socket,    
        m_pAccept->pInst[ndxAccept].Socket,
        m_pAccept->pInst[ndxAccept].pBuffer,
        0,      // data length
        128,    // local addr length
        128,    // remote addr length
        &cbRecv,    
        (LPOVERLAPPED)m_pAccept->pInst[ndxAccept].lpo
       );    
    if ( !bRet )
    {
        DWORD error = GetLastError();
        if ( error != ERROR_IO_PENDING )
        {

            ZoneEventLogReport( ZONE_E_ACCEPT_SOCKET_FAILED, 0, NULL, sizeof(error), &error );

            DebugPrint( "AcceptEx error %d - no long accepting new connections\n", error );
            closesocket(m_pAccept->pInst[ndxAccept].Socket);
            m_pAccept->pInst[ndxAccept].Socket = INVALID_SOCKET;
            //CloseHandle(GetNetwork()->m_hIO);  // leave open for existing connections

            Release(ACCEPT_REF);

        }
    }

    return bRet;
}


/*------------------------------------------------------------------------*/
//                  ConInfo Read functionality
/*------------------------------------------------------------------------*/
BOOL ConInfo::ReadSetState(READ_STATE state)
{
    m_readState = state;
    switch (m_readState) {
        case zConnReadStateHiMessageCS:
            Read( (char*)&m_uRead.InternalHiMsg, sizeof(m_uRead.InternalHiMsg) );
            break;
//        case zConnReadStateRoutingMessageCS:
//            Read( NULL, sizeof(ZConnInternalRoutingMsgType) );
//            break;
        case zConnReadStateSecureMessage:
            Read( (char*)&m_uRead.SecureHeader, sizeof(m_uRead.SecureHeader) );
            break;
        case zConnReadStateSecureMessageData:
            {
                Read( NULL, m_uRead.SecureHeader.oHeader.dwTotalLength - m_uRead.SecureHeader.oHeader.wIntLength );
                break;
            }
        case zConnReadStateFirstMessageSC:
            {
                /*
                // we expect the key message first
                // BUGBUG HACKHACK - we have to read synchronously b/c the room code 
                // expects us to have completed the handshake when we return from 
                // ZSConnectionOpen()
                if ( ReadSync( (char*)&m_uRead.FirstMsg, sizeof(m_uRead.FirstMsg) ) )
                {
                    return ReadHandleFirstMessageSC();
                }
                else
                {
                    return FALSE;
                }
                */ 
                // that bug no longer applies to the room code.
                Read( (char*)&m_uRead.FirstMsg, sizeof(m_uRead.FirstMsg) );
                break;
            }
        default:
            DebugPrint("******ConInfo::ReadSetState - Invalid state.******\n");
            return FALSE;
            break;
    }

    return TRUE;
}



void ConInfo::Read( char* pBuffer, int32 len )
{
    ASSERT(!m_readMessageData);
    ASSERT( m_readLen == 0 );
    ASSERT( len > 0 );

    if ( !pBuffer )
    {
        m_readMessageData = (char*) g_pDataPool->Alloc(len);
        m_readBuffer = m_readMessageData;
    }
    else
    {
        m_readBuffer = pBuffer;
    }
    m_readLen = len;
    m_readBytesRead = 0;

    OverlappedIO( CONINFO_OVERLAP_READ, m_readBuffer, m_readLen );
}


BOOL ConInfo::ReadSync(char* pBuffer, int len)
{

    ASSERT( m_socket != INVALID_SOCKET );
    ASSERT( GetFlags() & READ );

    if ( m_readBuffer )
    {
        ASSERT( !m_readBuffer );           // make sure we're not doing overlapped io
        return FALSE;
    }

    IF_DBGPRINT( DBG_CONINFO, ("entering ConInfo::ReadSync - blocking for %d bytes\n", len ) );

    int bytesRead = 0;    
    while( bytesRead < len )
    {   
        int read = recv( m_socket, pBuffer+bytesRead, len-bytesRead, 0 );
        if ( ( read == SOCKET_ERROR ) || ( read == 0 ) )
        {
            return FALSE;
        }
        bytesRead += read;
    }

    LockNetStats();
    g_NetStats.TotalBytesReceived.QuadPart += (LONGLONG)len;
    UnlockNetStats();

    return TRUE;
}


void ConInfo::ReadComplete(int cbRead, DWORD dwError)
{
    USES_CONVERSION;
    if ( !(GetFlags() & READ) )
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConInfo::ReadComplete with unknown state %d.\n",m_socket) );
        return;
    }

    LockNetStats();
    g_NetStats.TotalReadAPCsCompleted.QuadPart++;
    UnlockNetStats();

    // we have to check for invalid socket, because we may have closed the
    // socket b/c of a timeout, but we just haven't serviced the read yet
    if ( !IsDisabled() && cbRead && (dwError == NO_ERROR) && ( m_socket != INVALID_SOCKET) )
    {
        // update stats
        LockNetStats();
        g_NetStats.TotalBytesReceived.QuadPart += (LONGLONG)cbRead;
        UnlockNetStats();

        ASSERT( m_readBuffer );

        m_readBytesRead += cbRead;
        if ( m_readBytesRead < m_readLen )
        {
            OverlappedIO( CONINFO_OVERLAP_READ, m_readBuffer+m_readBytesRead, m_readLen - m_readBytesRead );
        }
        else
        {
            // when we finish, do what is appropriate based on state 
            // we'll ignore return codes here since closes will happen appropriately
            switch (m_readState)
            {
                case zConnReadStateHiMessageCS:
                    ReadHandleHiMessageCS();
                    break;
//                case zConnReadStateRoutingMessageCS:
//                    ReadHandleRoutingMessageCS();
//                    break;
                case zConnReadStateSecureMessage:
                    // we set this to GetTickCount() when we sent the key
                    if ( m_dwLatency == INFINITE )
                    {
                        m_dwLatency = ConInfo::GetTickDelta( GetTickCount(), m_dwPingSentTick );
                        IF_DBGPRINT( DBG_CONINFO, ("Latency(%d) is %d ms\n", m_socket, m_dwLatency ) );
                    }
                    ReadHandleSecureMessage();
                    break;
                case zConnReadStateSecureMessageData:
                    ReadHandleSecureMessageData();
                    break;
                case zConnReadStateFirstMessageSC:
                    ReadHandleFirstMessageSC();
                    break;
                default:
                    ASSERT("******ConInfo::Read - Invalid state.******");
                    break;
            }
        }
    }
    else
    {
        if ( m_readMessageData )
        {
            g_pDataPool->Free(m_readMessageData, m_readLen );
            m_readMessageData = NULL;
        }
        m_readBuffer = NULL;
        m_readLen = 0;
        m_readBytesRead = 0;

        if ( !IsDisabled() ) // this will happen later
        {
            if ( ( m_socket != INVALID_SOCKET) && !m_disconnectLogged && dwError && (dwError!=ERROR_NETNAME_DELETED) )
            {
                m_disconnectLogged = 1;

                LockNetStats();
                g_NetStats.TotalDroppedConnections.QuadPart++;
                UnlockNetStats();

                if ( g_LogServerDisconnects )
                {
                    TCHAR szBuf1[128];
                    TCHAR szBuf2[128];
                    lstrcpy( szBuf1, A2T(GetRemoteName() ));
                    wsprintf( szBuf2, TEXT(" was closed because a read completed with error %d"), dwError );
                    LPTSTR ppStr[] = { szBuf1, szBuf2 };
                    ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, 0, NULL );
                }
            }
            Close();
        }
    }
    
    Release(READ_REF);
}


BOOL ConInfo::ReadSecureConnection()
{
    if ( GetNetwork()->m_DisableEncryption )
    {
        m_secureKey = 0;
    }
    else if ( !GetNetwork()->m_ClientEncryption )
    {
        BYTE key = (BYTE)GetTickCount();

        // TO aid in RLE compression force all bytes to be the same
        // weaker encryption, but so what...
        m_secureKey = MAKELONG( MAKEWORD(key,key), MAKEWORD(key,key) );
    }
    IF_DBGPRINT( DBG_CONINFO, ("Secure key for %d is %d\n", m_socket, m_secureKey ) );

    m_flags |= SECURE;

    m_readBuffer = NULL;
    ASSERT(!m_readMessageData);
    m_readLen = 0;
    m_readBytesRead = 0;


    SetTimeoutTicks(INFINITE);

    if ( !WriteFirstMessageSC() )
    {
        Close();
        return FALSE;
    }
    else
    {
        SendMessage(zSConnectionOpen);
        return TRUE;
    }
}


BOOL ConInfo::ReadHandleHiMessageCS()
{
    ZConnInternalHiMsg *pMsg = &m_uRead.InternalHiMsg;

    ZSecurityDecrypt((char *) pMsg, sizeof(*pMsg), zSecurityDefaultKey);

    if (pMsg->oHeader.dwSignature == zConnInternalProtocolSig &&
        pMsg->dwProtocolVersion == zConnInternalProtocolVersion &&
        pMsg->oHeader.weType == zConnInternalHiMsg &&
        pMsg->oHeader.wIntLength == pMsg->oHeader.dwTotalLength &&
        pMsg->oHeader.wIntLength == sizeof(*pMsg) &&
        pMsg->dwProductSignature == GetNetwork()->m_ProductSignature)
    {
/*  // setting up the Route handler
        m_readBuffer = NULL;
        ASSERT(!m_readMessageData);
        m_readLen = 0;
        m_readBytesRead = 0;

        return ReadSetState(zConnReadStateRoutingMessageCS);
*/

// stolen from the route handler below
        CopyMemory(m_pGUID, &pMsg->uuMachine, sizeof(pMsg->uuMachine));

        if ( GetNetwork()->m_ClientEncryption )
        {
            m_secureKey = pMsg->dwClientKey;
        }

        m_rgfProtocolOptions &= ~pMsg->dwOptionFlagsMask;
        m_rgfProtocolOptions |= pMsg->dwOptionFlagsMask & pMsg->dwOptionFlags;

        ASSERT(!m_readMessageData);
        return ReadSecureConnection();
    }
    else
    {
        Close();
        return FALSE;
    }
}


#if 0 // routing no longer handled on this level
BOOL ConInfo::ReadHandleRoutingMessageCS()
{
    BOOL bClose = TRUE;

    ZConnInternalRoutingMsg msg = (ZConnInternalRoutingMsg) m_readMessageData;

    ZSecurityDecrypt((char*)msg,m_readLen, zSecurityDefaultKey);
//    ZConnInternalRoutingMsgEndian(msg);

    if (msg->sig == zInternalConnectionSig )
    {
        if ( m_readLen >= sizeof(ZConnInternalRoutingMsgType) )
        {
            CopyMemory( m_pGUID, msg->guid, sizeof( msg->guid ) );
        }

        // Handle connections through proxy.  We currently only
        // trust peer_addr's coming from localhost LOOPBACK addr
        if ( m_addrRemote == INADDR_LOOPBACK &&
             msg->peer_addr != INADDR_ANY &&
             msg->peer_addr != INADDR_NONE )
        {
            BOOL bTrust = TRUE;

            if ( bTrust )
            {
                // STOMP on the address returned from the acceptex call
                m_addrRemote = msg->peer_addr;
                ZEnd32(&(m_addrRemote));
            }
        }

        bClose = FALSE;
    }

    if ( m_readMessageData )
    {
        g_pDataPool->Free(m_readMessageData, m_readLen );
        m_readMessageData = NULL;
    }
    m_readBuffer = NULL;
    m_readLen = 0;
    m_readBytesRead = 0;

    if ( !bClose )
    {
        return ReadSecureConnection();
    }
    else
    {
        Close();
        return FALSE;
    }
}
#endif


BOOL ConInfo::ReadHandleSecureMessage()
{
    USES_CONVERSION;
    ZConnInternalGenericMsg *pMsg = &m_uRead.SecureHeader;

    if(m_secureKey)
        ZSecurityDecrypt((char *) pMsg, sizeof(*pMsg), m_secureKey);

    /* verify the sequence is ok */
    if(zConnInternalProtocolSig != pMsg->oHeader.dwSignature ||
        m_readSequenceID != pMsg->dwSequenceID ||
        pMsg->oHeader.wIntLength != sizeof(*pMsg) ||
        pMsg->oHeader.wIntLength > pMsg->oHeader.dwTotalLength ||
        pMsg->oHeader.dwTotalLength > GetNetwork()->m_MaxRecvSize)
    {
        DebugPrint("******ConInfoRead - bad packet.\n");
        LockNetStats();
        g_NetStats.BadlyFormedPackets.QuadPart++;
        UnlockNetStats();

        if ( ( m_socket != INVALID_SOCKET) && !m_disconnectLogged )
        {
            m_disconnectLogged = 1;

            LockNetStats();
            g_NetStats.TotalDroppedConnections.QuadPart++;
            UnlockNetStats();

            if ( g_LogServerDisconnects )
            {
                TCHAR szBuf1[128];
                TCHAR szBuf2[128];
                lstrcpy( szBuf1, A2T(GetRemoteName() ));
                wsprintf( szBuf2, TEXT(" was closed because an invalid ZConnInternalGenericMsg.  The data is the header" ));
                LPTSTR ppStr[] = { szBuf1, szBuf2 };
                ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, sizeof(m_uRead.SecureHeader), &m_uRead.SecureHeader );
            }
        }
        Close();
        return FALSE;
    }

    m_readSequenceID++;

    m_readBuffer = NULL;
    m_readLen = 0;
    m_readBytesRead = 0;
    if((pMsg->oHeader.dwTotalLength - pMsg->oHeader.wIntLength) >= sizeof(ZConnInternalAppHeader))
    {
        ASSERT(!m_readMessageData);

        m_dwPingRecvTick = GetTickCount();
        if ( m_dwPingRecvTick == 0 )
            m_dwPingRecvTick = 1;

        return ReadSetState(zConnReadStateSecureMessageData);
    }
    else
    {
        return ReadSetState(zConnReadStateSecureMessage);
    }
}

BOOL ConInfo::ReadHandleSecureMessageData()
{
    BOOL   bClosed = FALSE;
    uint32 checksum;
    USES_CONVERSION;
    DWORD dwApplicationLen = m_uRead.SecureHeader.oHeader.dwTotalLength -
        m_uRead.SecureHeader.oHeader.wIntLength - sizeof(ZConnInternalGenericFooter);
    ASSERT(m_uRead.SecureHeader.oHeader.dwTotalLength >= m_uRead.SecureHeader.oHeader.wIntLength);

    // make sure whole message made it through ok
    ZConnInternalGenericFooter *pFoot = (ZConnInternalGenericFooter *) ((char *) m_readMessageData + dwApplicationLen);
    if(pFoot->dweStatus == zConnInternalGenericOk)  // probably should do some logging if fails
    {
        if ( m_secureKey )
            ZSecurityDecrypt((char*)m_readMessageData, dwApplicationLen, m_secureKey);

        checksum = ZSecurityGenerateChecksum(1, &m_readMessageData, &dwApplicationLen);

        /* verify the checksum is ok... */
        if(checksum != m_uRead.SecureHeader.dwChecksum)
        {
            DebugPrint("******ConInfo::Read - Checksum failure %d != %d.\n", checksum, m_uRead.SecureHeader.dwChecksum);
            //FilePrint(zDebugFileName, TRUE, "***Read - Checksum Failed");
            LockNetStats();
            g_NetStats.BadlyFormedPackets.QuadPart++;
            UnlockNetStats();

            if ( ( m_socket != INVALID_SOCKET) && !m_disconnectLogged )
            {
                m_disconnectLogged = 1;

                LockNetStats();
                g_NetStats.TotalDroppedConnections.QuadPart++;
                UnlockNetStats();

                if ( g_LogServerDisconnects )
                {
                    TCHAR szBuf1[128];
                    TCHAR szBuf2[128];
                    lstrcpy( szBuf1, A2T(GetRemoteName() ));
                    wsprintf( szBuf2, TEXT(" was closed because an invalid checksum ( %d != %d )."), checksum, m_uRead.SecureHeader.dwChecksum );
                    LPTSTR ppStr[] = { szBuf1, szBuf2 };
                    ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, 0, NULL );
                }
            }

            Close();
            bClosed = TRUE;
        }
        else
        {
            // we allow batching, we must walk this databuffer in segments
            ZConnInternalAppHeader *pHeader = NULL;
            char* pData = m_readMessageData;
            while(dwApplicationLen >= sizeof(*pHeader))
            {
                pHeader = (ZConnInternalAppHeader *) m_readMessageData;

                if((uint32) sizeof(*pHeader) + pHeader->dwDataLength > dwApplicationLen )
                {
                    // TODO close connection???
                    break;
                }

                DWORD type;
                DWORD sig;
                int32 len;
                DWORD channel;
                LPSTR pBuf = GetReceivedData( &type, &len, &sig, &channel );
                if(sig == zProtocolSigInternalApp)
                {
                    if(!channel)
                    {
                        switch(type)
                        {
                            case zConnectionPing:
                                m_bPingRecv = TRUE;
                                break;
                            case zConnectionPingResponse:
                                if(len == sizeof(DWORD))
                                {
                                    DWORD delay = *((DWORD *) pBuf);
                                    ZEnd32(&delay);
                                    DWORD delta = GetTickDelta(m_dwPingRecvTick, m_dwPingSentTick);
                                    if(delta >= delay)
                                        m_dwLatency = delta - delay;
                                }
                                break;
                            case zConnectionKeepAlive:
                                break;
                            default:
                                break;
                        }
                    }
                }
                else
                    SendMessage(zSConnectionMessage);

                dwApplicationLen -= sizeof(*pHeader) + pHeader->dwDataLength;
                m_readMessageData = pData + m_uRead.SecureHeader.oHeader.dwTotalLength - m_uRead.SecureHeader.oHeader.wIntLength - dwApplicationLen;
            }
            // reset pointer
            m_readMessageData = pData;
        }
    }

    if (m_readMessageData != NULL)
    {
        g_pDataPool->Free(m_readMessageData, m_readLen );
        m_readMessageData = NULL;
    }

    m_readBuffer = NULL;
    m_readLen = 0;
    m_readBytesRead = 0;

    if ( bClosed )
    {
        return FALSE;
    }
    else
    {
        return ReadSetState(zConnReadStateSecureMessage);
    }
}

BOOL ConInfo::ReadHandleFirstMessageSC()
{
    ZConnInternalHelloMsg *m = &m_uRead.FirstMsg;
    ZSecurityDecrypt((char*)&m_uRead.FirstMsg, sizeof(m_uRead.FirstMsg), zSecurityDefaultKey);

    if(m->oHeader.dwSignature == zConnInternalProtocolSig &&
        m->oHeader.weType == zConnInternalHelloMsg &&
        m->oHeader.wIntLength == m->oHeader.dwTotalLength &&
        m->oHeader.dwTotalLength == sizeof(*m))
    {
        // we set this to GetTickCount() when we sent the hi msg
        if ( m_dwLatency == INFINITE )
        {
            m_dwLatency = ConInfo::GetTickDelta( GetTickCount(), m_dwPingSentTick );
            IF_DBGPRINT( DBG_CONINFO, ("Latency(%d) is %d\n", m_socket, m_dwLatency ) );
        }

        /* valid key */
        m_flags |= SECURE;

        m_secureKey = m->dwKey;
        m_initialSequenceID = m->dwFirstSequenceID;
        m_readSequenceID = m->dwFirstSequenceID;
        m_writeSequenceID = m->dwFirstSequenceID;
        m_rgfProtocolOptions = m->dwOptionFlags;
        IF_DBGPRINT( DBG_CONINFO, ("Secure key for %d is %d. seqid:%d\n", m_socket, m_secureKey, m_initialSequenceID ) );

        m_readBuffer = NULL;
        ASSERT(!m_readMessageData);
        m_readLen = 0;
        m_readBytesRead = 0;

        /* begin handling secure messages */
        if ( !WriteSetState(zConnWriteStateSecureMessage) ||
             !ReadSetState(zConnReadStateSecureMessage) )
        {
            Close();
            return FALSE;
        }

        SendMessage(zSConnectionOpen);
        return TRUE;
    } else {
        DebugPrint("******ConInfoReadHandleFirstMessageSC - Invalid Signature ******\n");
        //FilePrint(zDebugFileName, TRUE, "***Read - First: Invalid Signature");
        LockNetStats();
        g_NetStats.BadlyFormedPackets.QuadPart++;
        UnlockNetStats();

        Close();
        return FALSE;
    }

}


/*------------------------------------------------------------------------*/
//                  ConInfo Write functionality
/*------------------------------------------------------------------------*/


BOOL ConInfo::WriteSetState( WRITE_STATE state)
{
    switch (state) 
    {
        case zConnWriteStateFirstMessageSC:
            ASSERT( m_writeState == zConnWriteStateInvalid );
            m_writeState = state;
            break;

        case zConnWriteStateSecureMessage:
            m_flags |= ESTABLISHED;
            m_writeState = state;
            break;

        default:
            ASSERT(!"******ConInfo::WriteSetState - Invalid state.******\n");
            return FALSE;
            break;
    }

    return TRUE;
}

BOOL ConInfo::WriteSetSendBufSize()
{
    int optval = 0;

    ASSERT( m_socket != INVALID_SOCKET );

    setsockopt(m_socket,SOL_SOCKET,SO_SNDBUF,(const char*)&optval, sizeof(optval));

    return TRUE; // always return TRUE.  If we failed, we'll just be happy with the default
}

void ConInfo::WriteComplete(int cbWritten, DWORD dwError )
{
    USES_CONVERSION;
    if ( !(GetFlags() & WRITE) )
    {
        ASSERT(!"ConInfo::WriteComplete with unknown state." );
        return;
    }

    LockNetStats();
    g_NetStats.TotalWriteAPCsCompleted.QuadPart++;
    UnlockNetStats();

    EnterCriticalSection(m_pCS);

    // we have to check for invalid socket, because we may have closed the
    // socket b/c of a timeout, but we just haven't serviced the write yet
    if ( cbWritten && (dwError == NO_ERROR) && ( m_socket != INVALID_SOCKET) )
    {
        // update stats
        LockNetStats();
        g_NetStats.TotalBytesSent.QuadPart += (LONGLONG)cbWritten;
        UnlockNetStats();

        ASSERT( m_writeBuffer );

        m_writeIssueTick = 0;  // reset time of last write
        m_writeCompleteTick = GetTickCount();

        m_writeBytesWritten += cbWritten;
        if ( m_writeBytesWritten < m_writeLen )
        {
            OverlappedIO( CONINFO_OVERLAP_WRITE, m_writeBuffer+m_writeBytesWritten, m_writeLen - m_writeBytesWritten );
        }
        else
        {
            g_pDataPool->Free(m_writeBuffer, max( m_writeLen, MIN_ALLOCATION_SIZE) );

            m_writeBuffer = NULL;
            m_writeBytesWritten = 0;
            m_writeLen = 0;

            Write();
        }
    }
    else
    {
        if ( m_writeBuffer )
        {
            g_pDataPool->Free(m_writeBuffer, max( m_writeLen, MIN_ALLOCATION_SIZE) );
            m_writeBuffer = NULL;
            m_writeLen = 0;
        }
        if ( m_writeQueue )
        {
            g_pDataPool->Free(m_writeQueue, max(ZRoundUpLen(m_writeBytesQueued),MIN_ALLOCATION_SIZE) );
            m_writeQueue = NULL;
            m_writeBytesQueued = 0;
        }

        if ( ( m_socket != INVALID_SOCKET) && !m_disconnectLogged && dwError && (dwError != ERROR_NETNAME_DELETED)  )
        {
            m_disconnectLogged = 1;

            LockNetStats();
            g_NetStats.TotalDroppedConnections.QuadPart++;
            UnlockNetStats();

            if ( g_LogServerDisconnects )
            {
                TCHAR szBuf1[128];
                TCHAR szBuf2[128];
                lstrcpy( szBuf1, A2T(GetRemoteName() ));
                wsprintf( szBuf2, TEXT(" was closed because a write completed with error %d"), dwError );
                LPTSTR ppStr[] = { szBuf1, szBuf2 };
                ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, 0, NULL );
            }
        }
        Close();
    }

    LeaveCriticalSection(m_pCS);

    Release(WRITE_REF);
}

void ConInfo::Write()
{
    //
    // if there are no outstanding writes, we must issue one
    //
    if ( !m_writeBuffer && m_writeQueue ) 
    {
        // to simplify life, we only support pings on secure connections
        DWORD now = GetTickCount();

        if ( IsSecureConnection() )
        {
            if ( IsEstablishedConnection() &&
                 ( GetTickDelta( now, m_dwPingSentTick) > GetNetwork()->m_PingInterval ) )
            {
                m_dwPingSentTick = now;

                ZEnd32( &now );
                WriteFormatMessage( zConnectionPing, (char*)&now, sizeof(now), zProtocolSigInternalApp );  // this could fail...?  doesn't matter i guess.
            }
            else if ( m_bPingRecv )
            {
                // delta is the time betweem recv a ping and sending a response
                DWORD delta = GetTickDelta( now, m_dwPingRecvTick );
                m_bPingRecv = FALSE;

                ZEnd32( &delta );
                WriteFormatMessage( zConnectionPingResponse, (char*)&delta, sizeof(delta), zProtocolSigInternalApp );  // this too
            }
        }

        WritePrepareForSecureWrite();

        m_writeBytesWritten = 0;
        OverlappedIO( CONINFO_OVERLAP_WRITE, m_writeBuffer, m_writeLen );
    }
}

BOOL ConInfo::WriteSync(char* pBuffer, int len)
{

    ASSERT( m_socket != INVALID_SOCKET );
    ASSERT( GetFlags() &  WRITE );

    if ( m_writeBuffer )
    {
        ASSERT( !m_writeBuffer );           // make sure we're not doing overlapped io
        return FALSE;
    }

    int bytesSent = 0;
    while( bytesSent < len )
    {
        int sent = send( m_socket, pBuffer+bytesSent, len-bytesSent, 0 );
        if ( ( sent == SOCKET_ERROR ) || ( sent == 0 ) )
        {
            return FALSE;
        }
        bytesSent += sent;
    }

    LockNetStats();
    g_NetStats.TotalBlockingSends.QuadPart++;
    g_NetStats.TotalBytesSent.QuadPart += (LONGLONG)len;
    UnlockNetStats();

    // we're not going to start the latency timer until the packet's on the wire
    m_dwPingSentTick = GetTickCount();

    return TRUE;
}


BOOL ConInfo::WriteFirstMessageSC()
{
    if ( !WriteSetState(zConnWriteStateFirstMessageSC) )
    {
        return FALSE;
    }

    ZConnInternalHelloMsg msg;

    msg.oHeader.dwSignature = zConnInternalProtocolSig;
    msg.oHeader.weType = zConnInternalHelloMsg;
    msg.oHeader.wIntLength = sizeof(msg);
    msg.oHeader.dwTotalLength = sizeof(msg);
    msg.dwKey = m_secureKey;
    msg.dwFirstSequenceID = m_initialSequenceID;
    msg.dwOptionFlags = m_rgfProtocolOptions;

    ZSecurityEncrypt((char *) &msg, sizeof(msg), zSecurityDefaultKey);

    // be quick and dirty about this small message... 
    if ( !WriteSync((char*)&msg, sizeof(msg) )  ||
         !WriteSetSendBufSize() ||
         !WriteSetState( zConnWriteStateSecureMessage ) ||
         !ReadSetState( zConnReadStateSecureMessage ) )
    {
        return FALSE;
    }

    return TRUE;
}


BOOL ConInfo::WriteFormatMessage(uint32 type, char* pData, int32 len, uint32 dwSignature, uint32 dwChannel /* = 0 */)
{
    char* pBuffer;
    long buflen;

    if(IsAggregateGeneric())
        buflen = len + sizeof(ZConnInternalAppHeader);
    else
        buflen = ZRoundUpLenWOFooter(len + sizeof(ZConnInternalAppHeader) + sizeof(ZConnInternalGenericMsg) + sizeof(ZConnInternalGenericFooter));

    pBuffer = WriteGetBuffer(buflen);
    if ( !pBuffer )
    {
        return FALSE;
    }

    if(!IsAggregateGeneric())
        ZeroMemory(pBuffer + buflen - 8, 4);

    ZConnInternalAppHeader* pHeader = (ZConnInternalAppHeader *) (IsAggregateGeneric() ? pBuffer :
        (char *) ((ZConnInternalGenericMsg *) pBuffer + 1));
    pHeader->dwSignature = dwSignature;
    pHeader->dwChannel = dwChannel;
    pHeader->dwType = type;
    pHeader->dwDataLength = len;

    if(pData && len)
    {
        CopyMemory( pHeader+1, pData, len );
    }

    if(!IsAggregateGeneric())
    {
        ZConnInternalGenericMsg *pSecureHeader = (ZConnInternalGenericMsg *) pBuffer;
        ZConnInternalGenericFooter *pFoot = (ZConnInternalGenericFooter *) (pBuffer + buflen) - 1;

        pSecureHeader->oHeader.dwSignature = zConnInternalProtocolSig;
        pSecureHeader->oHeader.dwTotalLength = buflen;
        pSecureHeader->oHeader.wIntLength = sizeof(*pSecureHeader);
        pSecureHeader->oHeader.weType = zConnInternalGenericMsg;
        pSecureHeader->dwSequenceID = m_writeSequenceID++;

        pFoot->dweStatus = zConnInternalGenericOk;

        len = buflen - sizeof(*pSecureHeader) - sizeof(*pFoot);
        ASSERT(len >= 0);

        char*  buffers[1] = { (char *) (pSecureHeader + 1) };
        uint32 lengths[1] = { len };
        pSecureHeader->dwChecksum = ZSecurityGenerateChecksum(1, buffers, lengths);

        if ( m_secureKey )
        {
            ZSecurityEncrypt((char *) pSecureHeader, sizeof(*pSecureHeader), m_secureKey);
            ZSecurityEncrypt((char *) (pSecureHeader + 1), len, m_secureKey);
        }
    }

    return TRUE;
}


void ConInfo::WritePrepareForSecureWrite()
{
    ASSERT( IsSecureConnection() );

    int32 len = ZRoundUpLen(m_writeBytesQueued);

    m_writeBuffer = m_writeQueue;
    m_writeLen = len;

    // zero out padding bytes
    ZeroMemory( m_writeBuffer+m_writeBytesQueued, m_writeLen-m_writeBytesQueued );

    m_writeQueue = NULL;
    m_writeBytesQueued = 0;

    if(IsAggregateGeneric())
    {
        /* now construct the secure header stuff */
        ZConnInternalGenericMsg* pSecureHeader = (ZConnInternalGenericMsg *) m_writeBuffer;
        ZConnInternalGenericFooter *pFoot = (ZConnInternalGenericFooter *) (m_writeBuffer + m_writeLen) - 1;

        ASSERT(m_writeLen >= 0);
        pSecureHeader->oHeader.dwSignature = zConnInternalProtocolSig;
        pSecureHeader->oHeader.dwTotalLength = m_writeLen;
        pSecureHeader->oHeader.wIntLength = sizeof(*pSecureHeader);
        pSecureHeader->oHeader.weType = zConnInternalGenericMsg;
        pSecureHeader->dwSequenceID = m_writeSequenceID++;

        pFoot->dweStatus = zConnInternalGenericOk;

        len = m_writeLen - sizeof(*pSecureHeader) - sizeof(*pFoot);
        ASSERT(len >= 0);

        char*  buffers[1] = { (char*)(pSecureHeader+1) };
        uint32 lengths[1] = { len };
        pSecureHeader->dwChecksum = ZSecurityGenerateChecksum(1,buffers,lengths);

        if ( m_secureKey )
        {
            ZSecurityEncrypt((char*)pSecureHeader, sizeof(*pSecureHeader), m_secureKey);
            ZSecurityEncrypt((char*)(pSecureHeader+1), len, m_secureKey);
        }
    }
}


char* ConInfo::WriteGetBuffer(int32 len)
{
    // We always allocated it as a m_writeQueue, and let the writer transition
    // it to m_writeBuffer
    // We also save room at the begining of the buffer for an empty header
    // if generic message aggregation is set
    ASSERT(m_writeQueue || !m_writeBytesQueued);

    USES_CONVERSION;
    char* pOffset;

    // if aggregating, need some extra space on the first message for the header
    long cbExtra = 0;
    if(!m_writeQueue && IsAggregateGeneric())
        cbExtra = sizeof(ZConnInternalGenericMsg);

    // calculate new size of buffer - verify not too big & log occurances
    DWORD cbAlloc = max(ZRoundUpLen(m_writeBytesQueued + len + cbExtra), MIN_ALLOCATION_SIZE);
    if(cbAlloc > GetNetwork()->m_MaxSendSize)
    {
        TCHAR szBuf1[128];
        lstrcpy(szBuf1, A2T(GetRemoteName()));
        LPTSTR ppStr[] = { szBuf1 };
        ZoneEventLogReport(ZONE_W_SEND_BUFFER_TOO_BIG, 1, ppStr, 0, NULL);
        return NULL;
    }

    if ( !m_writeQueue )
    {
        m_writeQueue = g_pDataPool->Alloc(cbAlloc);
        if ( !m_writeQueue )
        {
            return NULL;
        }

        pOffset = m_writeQueue + cbExtra;
        m_writeBytesQueued = len + cbExtra;
    }
    else
    {
        char* pNewQueue = g_pDataPool->Realloc(m_writeQueue,
                                               max( ZRoundUpLen(m_writeBytesQueued), MIN_ALLOCATION_SIZE),
                                               cbAlloc);
        if ( !pNewQueue )
        {
            return NULL;
        }

        ASSERT(!cbExtra);
        m_writeQueue = pNewQueue;
        pOffset = m_writeQueue + m_writeBytesQueued;
        m_writeBytesQueued += len;
    }

    return pOffset;
} 


/*------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\consecureclient.h ===
#ifndef _CONSECURECLIENT_H_
#define _CONSECURECLIENT_H_


class ConSecureClient : public ConInfo {
    protected:
        
        ConSecureClient( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
             ZSConnectionMessageFunc func, void* conClass, void* userData,
             ZSecurity* security);

        virtual ~ConSecureClient();
        
        //Server Message function used to do authentication
        //before passing on events to application
        void static MessageFunc(ZSConnection connection, uint32 event,void* userData);

        void NotifyClose();

        void SecurityMsg();
                    
        void HandleSecurityResponse(ZSecurityMsgResp* msg,uint32 len);
                
        void HandleSecurityAccessDenied(ZSecurityMsgAccessDenied* msg,uint32 len);

        void HandleSecurityAccessGranted(ZSecurityMsgResp* msg,uint32 len);
        

        //Security package object
        ZSecurity * m_Security;

        //Context object
        ZSecurityContext m_Context;

        char       m_UserName[zUserNameLen + 1];
        char*      m_pContextStr;

        BOOL       m_bLoginMutexAcquired;

    public:
        
        //has user been authenticated
        ZSConnectionMessageFunc m_CurrentMsgFunc;

        //Override the create used from the ZSConnection functions
        static ConInfo* Create( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
                            ZSConnectionMessageFunc func, void* conClass,
                            void* userData, ZSecurity* security);


        virtual void  SendMessage(uint32 msg);

        virtual BOOL  GetUserName(char* name)
            {
                if (name)
                    {lstrcpyA(name, m_UserName); return TRUE;}
                return FALSE;
            }

        virtual BOOL  GetContextString(char* buf, DWORD len);

};

#endif //CONSECURECLIENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\consecureclient.cpp ===
/*******************************************************************************

    ConSecureClient.cpp
    
        ZSConnection object methods that hide SSPI authentication from application.
        

    Notes:
    1.Pool class not needed on client connections because there shouldn't be that
    many
        
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
      2     2/25/97     johnsm   Created from ConSSPI to handle NT client security
      1       11/8/96   johnsm   Created from ConInfo.cpp and Normandy SDK 
    membership server example
     
*******************************************************************************/


#include <windows.h>
#include <winsock.h>

#include "zone.h"
#include "zservcon.h"
#include "zonedebug.h"
#include "zsecurity.h"
#include "zconnint.h"
#include "netstats.h"

#include "pool.h"
#include "queue.h"
#include "coninfo.h"
#include "zsecobj.h"
#include "consecureclient.h"

#include "protocol.h"

extern CDataPool* g_pDataPool;


ConSecureClient::ConSecureClient( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
        ZSConnectionMessageFunc func, void* conClass, 
        void* userData,ZSecurity * security)
    : ConInfo(pNet, sock,addrLocal,addrRemote,flags,func,conClass,userData)
        
{
    IF_DBGPRINT( DBG_CONINFO, ("ConSecureClient::ConSecureClient: Entering\n") );

    m_AccessError = zAccessDenied;

    m_pContextStr = NULL;

    m_Security=security;

    m_UserName[0] = '\0';

    if (m_Security)
        m_Security->AddRef();

    m_bLoginMutexAcquired = FALSE;

    m_CurrentMsgFunc = MessageFunc;
        
    return;
};

ConSecureClient::~ConSecureClient() 
{
    if (m_bLoginMutexAcquired)
    {
        GetNetwork()->LeaveLoginMutex();
        m_bLoginMutexAcquired = FALSE;
    }

    if (m_Security) {
        m_Security->FreeContext(&m_Context);
        m_Security->Release();
        m_Security = NULL;
    }

    if ( m_pContextStr )
    {
        g_pDataPool->Free( m_pContextStr, lstrlenA( m_pContextStr ) + 1);
        m_pContextStr = NULL;
    }
}


BOOL ConSecureClient::GetContextString(char* buf, DWORD len)
{
    if ( buf )
    {
        buf[0] = '\0';

        if ( m_pContextStr )
        {
            if ( len > (DWORD) lstrlenA( m_pContextStr ) )
            {
                lstrcpyA( buf, m_pContextStr);
            }
            else
            {
                return FALSE;
            }
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}



ConInfo* ConSecureClient::Create(ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags, ZSConnectionMessageFunc func,
                         void* conClass, void* userData, ZSecurity *security)
{
    IF_DBGPRINT( DBG_CONINFO, ("ConSecureClient::Create: Entering\n") );

    ASSERT(sock != INVALID_SOCKET );

    ConSecureClient *con;

    
    con = new ConSecureClient( pNet, sock, addrLocal, addrRemote, flags, func, conClass, userData,security);
    

    if (!con)
    {
        ASSERT(con);
        return NULL;
    }

    return con;
}


void ConSecureClient::SendMessage(uint32 msg)
{ 
    ASSERT(m_CurrentMsgFunc);
    AddRef(USERFUNC_REF);

    //Because the message function is passed to new connections by the
    //base class create/new function no way to get application function
    //to be passed without changing base code so we will do
    //switch statement here. Didn't want to change base class behavior
    m_CurrentMsgFunc((ZSConnection)this, msg ,m_userData);

    Release(USERFUNC_REF);
}


void ConSecureClient::MessageFunc(ZSConnection connection, uint32 event,void* userData) 
{
    ConSecureClient * con = (ConSecureClient *) connection;
    IF_DBGPRINT( DBG_CONINFO, ("ConSecureClient::SSPIFunc: Entering\n") );

    switch(event) {
        case zSConnectionClose:
            con->NotifyClose();
            break;
        case zSConnectionOpen:
            break;
        case zSConnectionMessage:
            con->SecurityMsg();
            break;
        case zSConnectionTimeout:
            break;
        default:
            IF_DBGPRINT( DBG_CONINFO, ("Unknown event %d\n",event));
            break;
    }
    
    
};
void ConSecureClient::NotifyClose()
{
    if (m_bLoginMutexAcquired)
    {
        HWND dlg = FindLoginDialog();
        if ( dlg )
        {
            DWORD procId = 0;
            GetWindowThreadProcessId( dlg, &procId );
            if ( GetCurrentProcessId() == procId )
                ::PostMessage( dlg, WM_COMMAND, 0x2, 0 ); // send message to cancel button
        }

        GetNetwork()->LeaveLoginMutex();
        m_bLoginMutexAcquired = FALSE;
    }

    if ( IsUserConnection() )
    {
        m_CurrentMsgFunc = m_messageFunc;
        // Now send message to user level
        //client connections depend on this
        //because they may close before being opened
        SendMessage(zSConnectionClose);
    }
}

void ConSecureClient::SecurityMsg()
{
    uint32      msgType;
    int32       len;
    uint32      dwSignature;
    void* pBuffer = Receive( &msgType, &len, &dwSignature );
    ASSERT(dwSignature == zProtocolSigSecurity);
    
    IF_DBGPRINT( DBG_CONINFO,("ConSecureClient::SecurityMsg: Entering ...\n"));

    IF_DBGPRINT( DBG_CONINFO,("msgType=%d msgLen=%d\n", msgType, len));

    //
    // Filter out bad client authentication requests
    //
    switch(msgType) {
        case zSecurityMsgResp:
        case zSecurityMsgChallenge:
            HandleSecurityResponse((ZSecurityMsgResp*) pBuffer,len);
            break;
        case zSecurityMsgAccessDenied:
            HandleSecurityAccessDenied((ZSecurityMsgAccessDenied*) pBuffer,len);
            break;
        case zSecurityMsgAccessGranted:
            HandleSecurityAccessGranted((ZSecurityMsgResp*) pBuffer,len);
            break;
        default:
            Close();
            IF_DBGPRINT( DBG_CONINFO,("Unkown msgType=%d msgLen=%d\n", msgType, len));
            break;
    };

};
    
void ConSecureClient::HandleSecurityResponse (
    ZSecurityMsgResp * msg,
    uint32 MsgLen
    )
{
    BYTE * OutMsg;
    uint32          OutMsgType;
    uint32          OutMsgLen;
    BOOL            fDone;
    BYTE *            OutBuffer;
    ZSecurityMsgReq *pReply;
    ULONG cbBufferLen;

    IF_DBGPRINT( DBG_CONINFO,("ConSecureClient::HandleSecurityResponse: Entering ...\n"));

//    ZSecurityMsgRespEndian(msg);

    //Check for anonymous
    //if none needed tell application we are open
    if (msg->SecPkg[0]=='\0') {
        msg->UserName[sizeof(msg->UserName) - 1]='\0';
        lstrcpyA((char*)m_UserName,(char*)msg->UserName);
        m_AccessError = zAccessGranted;
        m_CurrentMsgFunc =m_messageFunc;
        SendMessage(zSConnectionOpen);
        return;
    }
    
    //If there is no security and we are not anonymous
    //then nothing to do but close
    if (!m_Security) 
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSecureClient::Security Package not initialized...\n"));
        m_AccessError = zAccessDeniedBadSecurityPackage;
        Close();
        return;
    }

    //Have we initialized context
    if (m_Context.IsInitialized()) {
        OutMsgType = zSecurityMsgAuthenticate;
    } else {
        OutMsgType = zSecurityMsgNegotiate;
        if (m_Security->Init(msg->SecPkg)) {
            IF_DBGPRINT( DBG_CONINFO,("ConSecureClient::Security Package not initialized...\n"));
            m_AccessError = zAccessDeniedBadSecurityPackage;
            Close();
            return;
        }
    }


    //Outgoing buffer allocation
    OutBuffer = (LPBYTE) g_pDataPool->Alloc(m_Security->GetMaxBuffer() + sizeof(ZSecurityMsgReq));

    if (!OutBuffer)
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSecureClient::Couldn't allocate security outbuffer...\n"));
        m_AccessError = zAccessDenied;
        Close();
        return;
    }

    pReply = (ZSecurityMsgReq *) OutBuffer;
    
    cbBufferLen = m_Security->GetMaxBuffer(); 

    if (!m_bLoginMutexAcquired && !(m_Security->GetFlags() & ZNET_NO_PROMPT))
    {
        m_bLoginMutexAcquired = TRUE;
        GetNetwork()->EnterLoginMutex();
    }

    HWND hwnd = GetNetwork()->GetParentHWND();
    if ( hwnd )
    {
        ::PostMessage( hwnd, UM_ZNET_LOGIN_DIALOG, 1, 0 );
    }

    if (!m_Security->GenerateContext(&m_Context,(BYTE *)msg->SecBuffer,MsgLen - sizeof(ZSecurityMsgReq),
                                    (PBYTE)pReply->SecBuffer, &cbBufferLen,
                                        &fDone))
    {
        if ( hwnd )
        {
            ::PostMessage( hwnd, UM_ZNET_LOGIN_DIALOG, 0, 0 );
        }

        IF_DBGPRINT( DBG_CONINFO,("ConSecureClient::Generate Context Failed...\n"));
        m_AccessError = zAccessDeniedGenerateContextFailed;
        Close();
        if (OutBuffer)
            g_pDataPool->Free( (char*)OutBuffer, m_Security->GetMaxBuffer() + sizeof(ZSecurityMsgReq) );
        return;
    }

    if ( hwnd )
    {
        ::PostMessage( hwnd, UM_ZNET_LOGIN_DIALOG, 0, 0 );
    }

    //If we are done then grant access otherwise
    //send back challenge
    OutMsgLen = sizeof(ZSecurityMsgReq) + cbBufferLen;
    
    pReply->protocolVersion=zSecurityCurrentProtocolVersion;
    pReply->protocolSignature = zProtocolSigSecurity;
    Send(OutMsgType, pReply,OutMsgLen, zProtocolSigSecurity);

    if (OutBuffer)
        g_pDataPool->Free( (char*)OutBuffer, m_Security->GetMaxBuffer() + sizeof(ZSecurityMsgReq) );


}



void ConSecureClient::HandleSecurityAccessDenied(ZSecurityMsgAccessDenied* msg,uint32 len)
{
//    ZSecurityMsgAccessDeniedEndian(msg);

    m_AccessError = msg->reason;
    m_Security->AccessDenied();
    /*
        Close the network connection first so that the server is not held hanging.
    */
    Close();

}


void ConSecureClient::HandleSecurityAccessGranted(ZSecurityMsgResp* msg,uint32 len)
{
    if (m_bLoginMutexAcquired)
    {
        GetNetwork()->LeaveLoginMutex();
        m_bLoginMutexAcquired = FALSE;
    }

//    ZSecurityMsgRespEndian(msg);
    msg->UserName[sizeof(msg->UserName) - 1]='\0';
    lstrcpyA((char*)m_UserName,(char*)msg->UserName);

    m_AccessError = zAccessGranted;

    m_Security->AccessGranted();

    m_Security->GetUserName(&m_Context,(char*)m_UserName);

    if (m_Security) {
        m_Security->FreeContext(&m_Context);
        m_Security->Release();
        m_Security = NULL;
    }

    ASSERT( !m_pContextStr );
    if ( msg->SecBuffer[0] )
    {
        m_pContextStr = g_pDataPool->Alloc(lstrlenA(msg->SecBuffer) + 1);
        ASSERT(m_pContextStr);
        if ( m_pContextStr )
            lstrcpyA( m_pContextStr, msg->SecBuffer );
    }

    m_CurrentMsgFunc =m_messageFunc;
    SendMessage(zSConnectionOpen);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\threadpool\thrdq.cpp ===
// ThrdQ.cpp : implementation
//

#include <windows.h>
#include "zonedebug.h"
#include "ThrdQ.h"

CQueueThread::CQueueThread( CThreadQueue * pQueue ) :
    m_pQueue( pQueue ),
    m_pData(NULL)
{
    DWORD tid;

    ASSERT( m_pQueue );
    
    m_hThread = ::CreateThread(
                        NULL,
                        m_pQueue->m_ThreadStackSize,
                        (LPTHREAD_START_ROUTINE) CQueueThread::ThreadProc,
                        (LPVOID) this,
                        CREATE_SUSPENDED,
                        &tid );
    ASSERT( m_hThread );

    ::SetThreadPriority( m_hThread, m_pQueue->m_ThreadPriority );
    ::ResumeThread( m_hThread );
}


CQueueThread::~CQueueThread()
{
    if ( m_hThread != NULL )
    {
        if ( ::WaitForSingleObject( m_hThread, 180000 ) == WAIT_TIMEOUT )  // 3 minutes grace time
        {
            ASSERT( FALSE /* Thread hung */ );
            ::TerminateThread(m_hThread, (DWORD) -1 );
        }
        ::CloseHandle(m_hThread);
    }
}


DWORD WINAPI CQueueThread::ThreadProc( CQueueThread * pThis )
{
    ASSERT( pThis );
    ASSERT( pThis->m_pQueue );

    pThis->m_pQueue->ThreadProc( &(pThis->m_pData) );

    ExitThread(0);
    return 0;
}


CThreadQueue::CThreadQueue( 
                    LPTHREADQUEUE_PROCESS_PROC ProcessProc,
                    LPTHREADQUEUE_INIT_PROC InitProc,
                    BOOL  bUseCompletionPort,
                    DWORD dwInitialWaitTime,
                    DWORD ThreadCount,
                    DWORD ThreadPriority,
                    DWORD ThreadStackSize ) :
    CCompletionPort( bUseCompletionPort ),
    m_ProcessProc( ProcessProc ),
    m_InitProc( InitProc ),
    m_dwWait( dwInitialWaitTime ),
    m_ThreadPriority( ThreadPriority ),
    m_ThreadStackSize( ThreadStackSize ),
    m_ActiveThreads(ThreadCount)
{
    InitializeCriticalSection( m_pCS );
    m_hStopEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    ASSERT( m_hStopEvent != NULL );

    if ( ThreadCount == 0 )
    {
        SYSTEM_INFO sinfo;
        GetSystemInfo( &sinfo );
        ThreadCount = sinfo.dwNumberOfProcessors*2;
        ASSERT(ThreadCount);
        // TODO maybe use page granularity as default for stack size
    }

    m_ThreadCount = ThreadCount;
    m_ThreadArray = new CQueueThread*[ThreadCount];
    ASSERT( m_ThreadArray );

    for( DWORD ndx = 0; ndx < ThreadCount; ndx++ )
    {
        m_ThreadArray[ndx] = new CQueueThread( this );
        ASSERT( m_ThreadArray[ndx] );
    }

}

CThreadQueue::~CThreadQueue()
{
    DWORD ndx;
    
    // first wake up all the threads
    ::SetEvent( m_hStopEvent );

    // then enqueue special code telling threads
    // to exit.  All nodes enqueued previously
    // will have a cancel to be serviced
    EnterCriticalSection( m_pCS );
    for ( ndx = 0; ndx < m_ThreadCount; ndx++ )
    {
        BOOL bRet = Post( NULL, (DWORD) -1 );  // our special code
        ASSERT( bRet );
    }
    
    // now delete them
    for( ndx = 0; ndx < m_ThreadCount; ndx++ )
        delete m_ThreadArray[ndx];

    delete [] m_ThreadArray;
    LeaveCriticalSection( m_pCS );

    ::CloseHandle( m_hStopEvent );

    DeleteCriticalSection( m_pCS );
}


BOOL CThreadQueue::SetThreadCount( DWORD ThreadCount )
{
    BOOL bRet = FALSE;

    if ( ThreadCount == 0 )
    {
        SYSTEM_INFO sinfo;
        GetSystemInfo( &sinfo );
        ThreadCount = sinfo.dwNumberOfProcessors;
        ASSERT( ThreadCount );
    }

    EnterCriticalSection( m_pCS );
    if ( ThreadCount < m_ThreadCount )  // we want fewer threads so free some
    {
        // this isn't as simple as just posting the special code
        // since we don't know which threads are servicing the requests.
        // we could just leave the thread objects around until we go away
        // but that wouldn't be a proper solution, so we'll wait for the correct one
        //assert_str(0,"Not Implemented");
    }

    if ( ThreadCount > m_ThreadCount )  // we want more threads so create some
    {
        CQueueThread** pThreads = new CQueueThread*[ThreadCount];
        ASSERT( pThreads );
        for( DWORD ndx = 0; ndx < ThreadCount; ndx++ )
        {
            if ( ndx < m_ThreadCount )
            {
                pThreads[ndx] = m_ThreadArray[ndx];
            }
            else
            {
                InterlockedIncrement(&m_ActiveThreads);
                pThreads[ndx] = new CQueueThread( this );
                ASSERT( pThreads[ndx] );
            }
        }
        delete [] m_ThreadArray;
        m_ThreadArray = pThreads;
        m_ThreadCount = ThreadCount;
        bRet = TRUE;
    }
    else                                // we're just happy with the number we have
    {
        bRet = TRUE;
    }
    LeaveCriticalSection( m_pCS );

    return bRet;
}

void CThreadQueue::ThreadProc(LPVOID* ppData)
{
    if ( m_InitProc )
    {
        (*m_InitProc)( ppData, TRUE );
    }

    LONG notLastThread = 1;   // set to 0 for the last thread which was told to stop

    DWORD dwWait = m_dwWait;
    for(;;)
    {
        LPVOID pNode = NULL;
        DWORD  cbBytes = 0;
        DWORD  key = 0;
        DWORD  dwError = NO_ERROR;

        BOOL   bRet = Get( (LPOVERLAPPED*) &pNode, dwWait, &cbBytes, &key );
        if ( !bRet )
        {
            dwError = GetLastError();
        }

        if ( !(bRet && cbBytes == -1) )  // our special code to signal that we're exiting
        {
            ASSERT( pNode || (!bRet && !pNode && (dwError == WAIT_TIMEOUT) ) );
            (*m_ProcessProc)( pNode, dwError, cbBytes, key, m_hStopEvent, *ppData, &dwWait );
        }
        
        //
        // Check to see if we're exiting
        //
        DWORD dwStop = WaitForSingleObject( m_hStopEvent, 0 );
        if ( dwStop == WAIT_OBJECT_0 )
        {
            if ( notLastThread ) // will be non-0 if we haven't been here before
                notLastThread = InterlockedDecrement( &m_ActiveThreads );

            if ( notLastThread )
            {
                break;
            }
            else
            {
                if ( m_QueuedCount == 0 )
                {
                    break;
                }
            }
        }
    }

    if ( m_InitProc )
    {
        (*m_InitProc)( ppData, FALSE );
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\coninfo.h ===
#ifndef _CONINFO_H_
#define _CONINFO_H_


#define TRACK_IO 0  // turn on to create a log file of events

/*---------------------------------------------------------------*/
/* ConInfo IO completion types */


#define CONINFO_OVERLAP_ENABLED     0x80000000

#define CONINFO_OVERLAP_APC         0x00000000
#define CONINFO_OVERLAP_ACCEPT      0x00010000
#define CONINFO_OVERLAP_READ        0x00100000
#define CONINFO_OVERLAP_WRITE       0x01000000

#define CONINFO_OVERLAP_TYPE_MASK   0x01110000
#define CONINFO_OVERLAP_ACCEPT_MASK 0x0000FFFF

//struct CONINFO_OVERLAPPED {
//    OVERLAPPED o;
//    DWORD flags;
//};

struct AcceptInst
{
    SOCKET Socket;
    BYTE   pBuffer[256];
    CONINFO_OVERLAPPED lpo[1];

    AcceptInst() : Socket(INVALID_SOCKET) {}
};

struct AcceptStruct
{
    DWORD  dwCurrentConnections;
    DWORD  dwMaxConnections;
    WORD   wNumInst;
    AcceptInst* pInst;

    AcceptStruct() :
        dwCurrentConnections(0),
        dwMaxConnections(INFINITE),
        wNumInst(0),
        pInst(NULL)
    {}
};


#ifdef __cplusplus
extern "C" {
#endif

typedef BOOL ( WINAPI * ACCEPT_EX_PROC )(
    IN SOCKET sListenSocket,
    IN SOCKET sAcceptSocket,
    IN PVOID lpOutputBuffer,
    IN DWORD dwReceiveDataLength,
    IN DWORD dwLocalAddressLength,
    IN DWORD dwRemoteAddressLength,
    OUT LPDWORD lpdwBytesReceived,
    IN LPOVERLAPPED lpOverlapped
    );

typedef VOID ( WINAPI * GET_ACCEPT_EX_SOCKADDRS_PROC )(
    IN PVOID lpOutputBuffer,
    IN DWORD dwReceiveDataLength,
    IN DWORD dwLocalAddressLength,
    IN DWORD dwRemoteAddressLength,
    OUT struct sockaddr **LocalSockaddr,
    OUT LPINT LocalSockaddrLength,
    OUT struct sockaddr **RemoteSockaddr,
    OUT LPINT RemoteSockaddrLength
    );

#ifdef __cplusplus
}
#endif


#define DBG_CONINFO_REF 1

#include "netcon.h"

class ConInfo : public ZNetCon {
  protected:
    static CPool<ConInfo>* m_pool;

    CRITICAL_SECTION m_pCS[1];

    long        m_lRefCount;

    SOCKET      m_socket;
    DWORD       m_addrLocal;
    DWORD       m_addrRemote;
    DWORD       m_flags;     /* type of connection */
    void*       m_conClass;
    void*       m_userData;
    GUID        m_pGUID[1];

    DWORD       m_dwTimeout;
    DWORD       m_dwTimeoutTicks;
    uint32      m_secureKey;

    DWORD       m_rgfProtocolOptions;

    DWORD       m_dwLatency;
    DWORD       m_dwPingSentTick;
    DWORD       m_dwPingRecvTick;
    BYTE        m_bPingRecv;
    BYTE        m_disconnectLogged;
    int         m_AccessError;

    DWORD       m_initialSequenceID;

    ZSConnectionMessageFunc m_messageFunc;
    ZSConnectionSendFilterFunc m_sendFilter;

    ConInfo( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
             ZSConnectionMessageFunc func, void* conClass, void* userData);

    virtual ~ConInfo();

    void OverlappedIO( DWORD type, char* pBuffer, int len );
    BOOL QueueSendData(uint32 type, char* data, int32 len, uint32 dwSignature, uint32 dwChannel = 0);

    static ACCEPT_EX_PROC m_procAcceptEx;
    static GET_ACCEPT_EX_SOCKADDRS_PROC m_procGetAcceptExSockaddrs;
    static HINSTANCE m_hWSock32;
    static long m_refWSock32;


  public:


    MTListNodeHandle m_list;
    MTListNodeHandle m_listTimeout;


    enum  REFTYPE { INVALID_REF, CONINFO_REF, LIST_REF, TIMEOUT_REF, READ_REF, WRITE_REF, ACCEPT_REF, USERFUNC_REF, USER_REF, SECURITY_REF, USER_APC_REF, LAST_REF };
#if DBG_CONINFO_REF
    long  m_lDbgRefCount[LAST_REF];
#endif
    inline void  AddRef(REFTYPE dbgRefType=INVALID_REF);
    inline void  Release(REFTYPE dbgRefType=INVALID_REF);

    static void SetPool( CPool<ConInfo>* pool );
    static BOOL StaticInit();

    static ConInfo* Create( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
                            ZSConnectionMessageFunc func, void* conClass, void* userData);

    void  Close();
    void  SendCloseMessage();
    void  Disable();

    virtual void  Suspend() { m_flags |= SUSPENDED; }
    virtual void  Resume() { m_flags &= ~SUSPENDED; }

    void  AddUserRef() { m_flags |= USER; AddRef(ConInfo::USER_REF); }

    void  SetTimeoutTicks(DWORD ticks) { m_dwTimeoutTicks = ticks; ResetTimeout(); }
    void  ResetTimeout() { m_dwTimeout = m_dwTimeoutTicks; }
    BOOL  IsTimedOut(DWORD elapsed);
    DWORD GetRemainingTimeout() { return m_dwTimeout; }

    static inline DWORD GetTickDelta( DWORD now, DWORD then)
        {
            if ( now >= then )
                return now - then;
            else
                return INFINITE - then + now;
        }


    virtual GUID* GetUserGUID() { return m_pGUID; }

    virtual BOOL  GetUserName(char* name) {return FALSE;}
    virtual BOOL  SetUserName(char* name) {return FALSE;}

    virtual DWORD GetUserId() {return 0;}
    virtual BOOL  GetContextString(char* buf, DWORD len) {return FALSE;}

    virtual BOOL  HasToken(char* token) {return FALSE;}
    virtual BOOL  EnumTokens(ZSConnectionTokenEnumFunc func, void* userData) { return FALSE; }

    virtual void  SetUserData( void* UserData ) { ASSERT(m_flags); m_userData = UserData; }
    virtual void* GetUserData() { ASSERT(m_flags); return m_userData; }

    virtual void  SetClass( void* conClass ) { ASSERT(m_flags); m_conClass = conClass; }
    virtual void* GetClass() { ASSERT(m_flags); return m_conClass; }

    // Nagling may affect this buy up to 200ms!
    virtual DWORD GetLatency() { return m_dwLatency; }

    virtual uint32 GetLocalAddress() { return m_addrLocal; }
    virtual char*  GetLocalName() { return ZNetwork::AddressToStr(GetLocalAddress()); }
    virtual uint32 GetRemoteAddress() { return m_addrRemote; }
    virtual char*  GetRemoteName() { return ZNetwork::AddressToStr(GetRemoteAddress()); }

    virtual void  SendMessage(uint32 msg);

    BOOL  FilterAndQueueSendData(uint32 type, char* data, int32 len, uint32 dwSignature, uint32 dwChannel = 0);
    char* GetReceivedData(uint32 *type, int32 *len, uint32 *pdwSignature, uint32 *pdwChannel);


    BOOL  InitiateSecurityHandshake();

    virtual int   GetAccessError() { return m_AccessError; }

    virtual void  SetSendFilter( ZSConnectionSendFilterFunc filter ) { ASSERT(m_flags); m_sendFilter = filter; }
    virtual ZSConnectionSendFilterFunc  GetSendFilter() { ASSERT(m_flags); return m_sendFilter; }

    SOCKET     GetSocket() { return m_socket; }

    enum CON_FLAGS { FREE = 0x0, INIT=0x1, SECURE=0x2, CLOSING=0x4, ESTABLISHED=0x8,
                     READ = 0x10, WRITE = 0x20, ACCEPTING = 0x40, ACCEPTED = 0x80,
                     DISABLED=0x100, CLOSE_MSG_SENT=0x200, SUSPENDED=0x400, USER=0x8000 };
    DWORD GetFlags() { return m_flags;}

    BOOL IsSecureConnection() { return (BOOL)(GetFlags() & SECURE); }
    BOOL IsServerConnection() { return (BOOL)(GetFlags() & (ACCEPTING) );}
    BOOL IsUserConnection() { return (BOOL)(GetFlags() & (USER) );}
    BOOL IsAcceptedConnection() { return (BOOL)(GetFlags() & (ACCEPTED) );}
    BOOL IsReadWriteConnection() { return (BOOL)(GetFlags() & (READ|WRITE) );}
    BOOL IsClosing() { return (BOOL)(GetFlags() & CLOSING );}
    BOOL IsSuspended() { return (BOOL)(GetFlags() & SUSPENDED );}
    BOOL IsEstablishedConnection() { return (BOOL)(GetFlags() & ESTABLISHED );}
    BOOL IsCloseMsgSent() { return (BOOL)(GetFlags() & CLOSE_MSG_SENT );}
    BOOL IsDisabled() { return (BOOL)(GetFlags() & DISABLED );}

    BOOL IsAggregateGeneric() { return (m_rgfProtocolOptions & zConnInternalOptionAggGeneric) ? TRUE : FALSE; }

    void KeepAlive();

    //////////// Accept members ///////////////////
  protected:
    AcceptStruct* m_pAccept;
    DWORD m_dwAcceptTick;
    ULONGLONG m_qwLastAcceptError;

  public:
    virtual ConInfo* AcceptCreate( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
                            ZSConnectionMessageFunc func, void* conClass, void* userData);

    ConInfo* AcceptComplete(WORD ndxAccept, DWORD dwError = NO_ERROR);
    BOOL  AcceptInit(DWORD dwMaxConnection = INFINITE, WORD wOutstandingAccepts = 1);
    BOOL  AcceptNext( WORD ndxAccept );
    virtual DWORD GetAcceptTick() { return m_dwAcceptTick; }


    //////////// Read members /////////////////////
  public:
    void ReadComplete(int cbRead, DWORD dwError = NO_ERROR);

    enum READ_STATE 
    {
        zConnReadStateInvalid,
        zConnReadStateHiMessageCS,
//        zConnReadStateRoutingMessageCS,
        zConnReadStateSecureMessage,
        zConnReadStateSecureMessageData,
        zConnReadStateFirstMessageSC,
    };
    READ_STATE ReadGetState() { return m_readState; }

  protected:
    READ_STATE  m_readState;
    BOOL ReadSetState(READ_STATE state);

    uint32 m_readSequenceID;

    CONINFO_OVERLAPPED m_lpoRead[1];

    union{
        ZConnInternalHiMsg       InternalHiMsg;
        ZConnInternalHelloMsg    FirstMsg;
        ZConnInternalGenericMsg  SecureHeader;
        ZConnInternalAppHeader   MessageHeader;
        } m_uRead;
    char* m_readMessageData;

    char* m_readBuffer;
    int32 m_readLen;
    int32 m_readBytesRead;

    void Read( char* pBuffer, int32 len );
    BOOL ReadSync(char* pBuffer, int len);
    BOOL ReadSecureConnection();

    BOOL ReadHandleHiMessageCS();        // client to server
//    BOOL ReadHandleRoutingMessageCS();   // client to server
    BOOL ReadHandleSecureMessage();
    BOOL ReadHandleSecureMessageData();
    BOOL ReadHandleFirstMessageSC();     // server to client


    //////////// Write members ////////////////////
  public:
    void WriteComplete(int cbWritten, DWORD dwError = NO_ERROR);

    enum WRITE_STATE
    {
        zConnWriteStateInvalid,
        zConnWriteStateSecureMessage,
        zConnWriteStateFirstMessageSC
    };
    WRITE_STATE WriteGetState() { return m_writeState; }

  protected:
    WRITE_STATE  m_writeState;
    BOOL WriteSetState(WRITE_STATE state);
    BOOL WriteSetSendBufSize();

    uint32 m_writeSequenceID;

    CONINFO_OVERLAPPED m_lpoWrite[1];

    char* m_writeBuffer;
    int32 m_writeLen;
    int32 m_writeBytesWritten;

    char* m_writeQueue;
    int32 m_writeBytesQueued;

    DWORD m_writeIssueTick;
    DWORD m_writeCompleteTick;

    char* WriteGetBuffer(int32 len);
        
    void Write();
    BOOL WriteSync(char* pBuffer, int len);
    BOOL WriteFirstMessageSC();

    BOOL WriteFormatMessage(uint32 type, char* pData, int32 len, uint32 dwSignature, uint32 dwChannel = 0);
    void WritePrepareForSecureWrite();


};


inline void ConInfo::AddRef(REFTYPE dbgRefType)
{
    ASSERT(m_flags); 
    ASSERT( InterlockedIncrement(&m_lRefCount) >0 );
#if DBG_CONINFO_REF
    ASSERT(dbgRefType);
    ASSERT( InterlockedIncrement(m_lDbgRefCount+dbgRefType) >0 );
#endif
}

inline void ConInfo::Release(REFTYPE dbgRefType)
{
#if DBG_CONINFO_REF
    ASSERT(dbgRefType);
    ASSERT( InterlockedDecrement(m_lDbgRefCount+dbgRefType) >=0 );
#endif
    ASSERT(m_lRefCount>0);
    if ( InterlockedDecrement(&m_lRefCount) == 0 )
    {        
        ::delete this;
    }

}


#endif //ndef _CONINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\consspi.h ===
#ifndef _CONSSPI_H_
#define _CONSSPI_H_

//This class binds together the Zone protocol
//for lobbies, the server security provider
//object and the clients security context and enables
//the security calls to be made on seperate thread
//Also maintains standard interface for legacy lobby code to continue
//to work 

class ConSSPI : public ConInfo, public CThreadTask {
    protected:
        
        ConSSPI( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
             ZSConnectionMessageFunc func, void* conClass, void* userData,
             ZServerSecurityEx* security);

        virtual ~ConSSPI();
        
        //Server Message function used to do authentication
        //before passing on events to application
        void static MessageFunc(ZSConnection connection, uint32 event,void* userData);

        void SecurityMsg(ZSConnection connection);
        void SecurityMsgResponse (ZSConnection connection,uint32 msgType,ZSecurityMsgReq * msg,int MsgLen);
        void AccessDeniedMsg(ZSConnection connection, int16 reason);


        //Security object, has package to use to authenticate
        //pointer set to shared security object inherited from
        //accept socket
        //
        ZServerSecurityEx * m_Security;

        ZSecurityContextEx m_Context;

        DWORD m_tickQueued;

        //objects needed to communicate with threaded queue
        //access serialized by code 
        ZSecurityMsgReq* m_pMsg;
        size_t m_MsgLen;
        int16 m_Reason;

        //State variable used to detect invalid code paths
        long m_InQueue;

        static void AccessDeniedAPC(void* data);
        static void OpenAPC(void* data);
        void QueueAccessDeniedAPC(int16 reason);
                
        
    public:
        static CPool<ConSSPI>* m_poolSSPI;
        static void SetPool( CPool<ConSSPI>* pool ) { m_poolSSPI = pool; }

        //has user been authenticated
        ZSConnectionMessageFunc m_CurrentMsgFunc;

        //Override the create used from the ZSConnection functions
        static ConInfo* Create( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
                            ZSConnectionMessageFunc func, void* conClass,
                            void* userData, ZServerSecurityEx* security);

        //Override the create done within the base class accept function
        //we need to allocate from our own pool
        virtual ConInfo* AcceptCreate( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
                            ZSConnectionMessageFunc func, void* conClass, 
                            void* userData);

        virtual void  SendMessage(uint32 msg);

        virtual BOOL  HasToken(char* token) { return m_Context.HasToken(token); }
        virtual BOOL  EnumTokens(ZSConnectionTokenEnumFunc func, void* userData) { return m_Context.EnumTokens(func, userData); }

        virtual DWORD GetUserId() { return m_Context.GetUserId(); }
        virtual BOOL  GetUserName(char* name) { return m_Context.GetUserName(name); }
        virtual BOOL  GetContextString(char* buf, DWORD len) { return m_Context.GetContextString(buf, len); }

        // only allow upper layers to change username if no security -  anonymous
        virtual BOOL  SetUserName(char* name);

        //Methods called by the thread pool proc
        virtual void Invoke(); 
        virtual void Ignore(); 
        virtual void Discard();

        
   
};

#endif //_CONSSPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\consspi.cpp ===
/*******************************************************************************

    ConSSPI.cpp
    
        ZSConnection object methods that hide SSPI authentication from application.
        

    Notes:
    1. When the server receives a message, it sends a message available message
    to the owner. The owner must retrieve the message immediately; otherwise,
    the message is lost.
    2. Implementation makes assumption that client is first to send to server
        
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    1       11/8/96   johnsm   Created from ConSSPI.cpp and Normandy SDK 
    membership server example
     
*******************************************************************************/


#include <windows.h>
#include <winsock.h>

#include "zone.h"
//#include "zservcon.h"
#include "zonedebug.h"
#include "zsecurity.h"
#include "zconnint.h"
#include "netstats.h"

#include "network.h"
#include "coninfo.h"
#include "zsecobj.h"
#include "consspi.h"
#include "eventlog.h"
#include "zonemsg.h"
#include "protocol.h"

#define zSecurityCloseTimeout       15000

#define zSecurityTypeBadUser    ((void*) 1)

extern CDataPool* g_pDataPool;

CPool<ConSSPI>* ConSSPI::m_poolSSPI = NULL;


ConSSPI::ConSSPI( ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags,
        ZSConnectionMessageFunc func, void* conClass, 
        void* userData,ZServerSecurityEx * security)
    : ConInfo(pNet,sock,addrLocal,addrRemote,flags,func,conClass,userData)
        
{
    IF_DBGPRINT( DBG_CONINFO, ("ConSSPI::ConSSPI: Entering\n") );

    m_InQueue=0;

    m_Security=security;

    if (m_Security)
        m_Security->AddRef();

    m_pMsg=NULL;


    //Don't need to authenticate an accept socket
    //application owns everything about this socket
    if (IsServerConnection())  {
        m_CurrentMsgFunc =m_messageFunc;
    } else {
        m_CurrentMsgFunc = MessageFunc;
    }
    
    return;
};

ConSSPI::~ConSSPI() 
{
    ASSERT(!m_InQueue);

    if (m_Security) {
        m_Security->FreeContext(&m_Context);
        m_Security->Release();
    }

    ASSERT( !m_pMsg );
    if (m_pMsg) 
    {
        g_pDataPool->Free( (char*)m_pMsg, m_MsgLen) ;
        m_pMsg=NULL;
    }


}

ConInfo* ConSSPI::Create(ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags, ZSConnectionMessageFunc func,
                         void* conClass, void* userData, ZServerSecurityEx *security)
{
    IF_DBGPRINT( DBG_CONINFO, ("ConSSPI::Create: Entering\n") );

    ASSERT(sock != INVALID_SOCKET );

    ConSSPI *con;

    
    if ( m_poolSSPI )
    {
        con = ::new (*m_poolSSPI) ConSSPI( pNet,  sock, addrLocal, addrRemote, flags, func, conClass, userData,security);
    }
    else

    {
        con = new ConSSPI( pNet, sock, addrLocal, addrRemote, flags, func, conClass, userData,security);
    }

    if (!con)
    {
        ASSERT(con);
        return NULL;
    }


    return con;
}

ConInfo* ConSSPI::AcceptCreate(ZNetwork* pNet, SOCKET sock, DWORD addrLocal, DWORD addrRemote, DWORD flags, ZSConnectionMessageFunc func, void* conClass, void* userData)
{
    IF_DBGPRINT( DBG_CONINFO, ("ConSSPI::AcceptCreate: Entering\n") );

    return ConSSPI::Create( pNet, sock, addrLocal, addrRemote,flags|ACCEPTED,func,conClass,userData,m_Security);
}




void ConSSPI::SendMessage(uint32 msg)
{ 
    ASSERT(m_CurrentMsgFunc);
    AddRef(USERFUNC_REF);

    //Because the message function is passed to new connections by the
    //base class create/new function no way to get application function
    //to be passed without changing base code so we will do
    //switch statement here. Didn't want to change base class behavior
    m_CurrentMsgFunc((ZSConnection)this, msg ,m_userData);

    Release(USERFUNC_REF);
}


void ConSSPI::MessageFunc(ZSConnection connection, uint32 event,void* userData) 
{
    ConSSPI * con = (ConSSPI *) connection;
    IF_DBGPRINT( DBG_CONINFO, ("ConSSPI::SSPIFunc: Entering\n") );

    switch(event) {
        case zSConnectionClose:
            if ( con->IsUserConnection() )
            {
                con->GetNetwork()->DeleteConnection(con);
            }
            break;
        case zSConnectionOpen:
            break;
        case zSConnectionMessage:
            con->SecurityMsg(connection);
            break;
        case zSConnectionTimeout:
            if (con->GetClass() == zSecurityTypeBadUser)
            {
                con->GetNetwork()->CloseConnection(con);
            }
            break;
        default:
            IF_DBGPRINT( DBG_CONINFO, ("Unknown event %d\n",event));
            break;
    }
    
    
};

void ConSSPI::SecurityMsg(ZSConnection connection)
{
    static long userId = 1;

    IF_DBGPRINT( DBG_CONINFO,("ConSSPI::SecurityMsg: Entering ...\n"));


    ConSSPI * con = (ConSSPI *) connection;
    uint32      msgType;
    int32       msgLen;
    uint32      dwSignature;
    ZSecurityMsgResp reply;
    ZSecurityMsgReq * msg = (ZSecurityMsgReq *) con->Receive( &msgType, &msgLen, &dwSignature);

    // is client even attempting security protocol?
    if(dwSignature != zProtocolSigSecurity)
    {
        // if a secure connection, you lose
        if(m_Security)
        {
            AccessDeniedMsg(connection, zAccessDeniedProtocolError);
            return;
        }

        // if not secure, who cares
        //For anonymous use the current address as the user name
        char buf[65];
        wsprintfA(buf, "user%x@%x", this, con->GetRemoteAddress());

        m_Context.SetUserName(buf);
        m_Context.SetUserId(0x8000000 | (DWORD)InterlockedIncrement(&userId) );

        con->m_AccessError = zAccessGranted;

        //send before telling application is open in case it sends packets
        // to clients first
        m_CurrentMsgFunc = m_messageFunc;
        SendMessage(zSConnectionOpen);
        SendMessage(zSConnectionMessage);  // pass this message through
        return;
    }

    IF_DBGPRINT( DBG_CONINFO,("msgType=%d msgLen=%d\n", msgType, msgLen));


    //
    // Filter out bad client authentication requests
    //
    
    switch(msgType) {
        case zSecurityMsgNegotiate:
        case zSecurityMsgAuthenticate:
        case zSecurityMsgReq:
//            ZSecurityMsgReqEndian(msg);

            if (msg->protocolSignature != zProtocolSigSecurity) {
                AccessDeniedMsg(connection,zAccessDeniedProtocolError);
                return;
            }
            //
            // Check to make sure the client is using same Zone Security verions
            // which is based on the SICILY SSPI version
            //
            if (msg->protocolVersion != zSecurityCurrentProtocolVersion)
            {
                AccessDeniedMsg(connection,zAccessDeniedOldVersion);
                return;
            }

            break;
        default:
            IF_DBGPRINT( DBG_CONINFO, ("Unknown msg %d %d\n", msgType, msgLen));
            AccessDeniedMsg(connection,zAccessDeniedProtocolError);
            break;
    
    }

    // If server is anonymous then only request message needs reply
    switch(msgType) {
        case zSecurityMsgNegotiate:
        case zSecurityMsgAuthenticate:
            if (!m_Security) {
                IF_DBGPRINT( DBG_CONINFO, ("Server is anonymous but received negotiate and authenticate messages\n"));
                AccessDeniedMsg(connection,zAccessDeniedProtocolError);
            }
    }
    

    //
    // Process client authentication request
    // Won't use state machine to make sure client is using correct protocol
    // ordering because they will be denied access if they don't
    //
    
    switch(msgType) {
        // First message is what package to use
        case zSecurityMsgReq:
                    
            //If we don't have a security package then anonymous ok
            if (!m_Security) {
                    //For anonymous use the current address as the user name
                    reply.protocolVersion=zSecurityCurrentProtocolVersion;
                    reply.SecPkg[0]='\0';

                    wsprintfA((char *) reply.UserName,"user%x@%x",this, con->GetRemoteAddress() );
                    reply.SecBuffer[0]='\0';

                    m_Context.SetUserName((char *)reply.UserName);
                    m_Context.SetUserId(0x8000000 | (DWORD)InterlockedIncrement(&userId) );

//                    ZSecurityMsgRespEndian(&reply);
                    
                    con->Send( zSecurityMsgAccessGranted, &reply,sizeof(ZSecurityMsgResp), zProtocolSigSecurity);

                    con->m_AccessError = zAccessGranted;

                    //send before telling application is open in case it sends packets
                    // to clients first
                    m_CurrentMsgFunc =m_messageFunc;
                    SendMessage(zSConnectionOpen);
                    return;
            
            } 
            
            
            //we have to authenticate and so tell client which package we want
            reply.protocolVersion=zSecurityCurrentProtocolVersion;
            m_Security->GetSecurityName(reply.SecPkg);
            reply.UserName[0]='\0';
//            ZSecurityMsgRespEndian(&reply);
            con->Send(zSecurityMsgResp,&reply,sizeof(ZSecurityMsgResp), zProtocolSigSecurity);
            break;

        //Negotiate and create challenge
        case zSecurityMsgNegotiate:
            SecurityMsgResponse (connection, msgType, msg, msgLen);
            break;
        //Final security communication yes or no
        case zSecurityMsgAuthenticate:
            SecurityMsgResponse (connection, msgType, msg, msgLen);
            break;

        default:
            IF_DBGPRINT( DBG_CONINFO, ("Unknown msg %d %d\n", msgType, msgLen));
            AccessDeniedMsg(connection,zAccessDeniedProtocolError);
            break;
    
    }
    
}

     


//+----------------------------------------------------------------------------
//
//  Function:   SecurityMsgResponse
//
//  Synopsis:   This function generates and sends an authentication response 
//              to the client.  It will generate and send either a challenge 
//              or the final authentication result to client depending on 
//              the type of client message (pointed to by pInMsg) passed 
//              to this function.
//
//-----------------------------------------------------------------------------
void
ConSSPI::SecurityMsgResponse (
    ZSConnection connection,
    uint32 msgType,
    ZSecurityMsgReq * msg,
    int MsgLen
    )
{

    IF_DBGPRINT( DBG_CONINFO,("ConSSPI::SecurityMsgResponse: Entering ...\n"));

    if (!m_Security) 
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Security Package not initialized...\n"));
        AccessDeniedMsg(connection,zAccessDenied);
        return;
    }

    if (MsgLen < sizeof(ZSecurityMsgReq))
    {
        AccessDeniedMsg(connection,zAccessDeniedProtocolError);
        return;
    }

    if (m_InQueue)
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Already Enqueued Task Failed \n"));    
        {
            LPTSTR ppStr[] = { TEXT("ConSSPI::Already Enqueued Task Failed." ) };
            ZoneEventLogReport( ZONE_S_DEVASSERT, 1, ppStr, sizeof(ConSSPI), this );
        }

        AccessDeniedMsg(connection,zAccessDeniedProtocolError);
        return;
    }

    ASSERT( !m_pMsg );
    m_MsgLen= MsgLen;
    m_pMsg  = (ZSecurityMsgReq *) g_pDataPool->Alloc(m_MsgLen);
    
    if (!m_pMsg)
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Failed to allocate memory\n"));    
        AccessDeniedMsg(connection,zAccessDeniedSystemFull);
        return;
    }


    memcpy(m_pMsg,msg,m_MsgLen);
    InterlockedIncrement((PLONG) &m_InQueue);
    InterlockedExchange((PLONG) &m_tickQueued, GetTickCount() );

    AddRef(SECURITY_REF);
    if (!m_Security->EnqueueTask(this))
    {
        InterlockedDecrement((PLONG) &m_InQueue);
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::EnqueueTask Failed \n"));
        g_pDataPool->Free( (char*)m_pMsg, m_MsgLen);
        m_pMsg=NULL;
        Release(SECURITY_REF);

        AccessDeniedMsg(connection,zAccessDeniedSystemFull);
    }
    else
    {
        LockNetStats();
        g_NetStats.TotalQueuedConSSPI.QuadPart++;
        UnlockNetStats();
    }


   
}

void ConSSPI::AccessDeniedMsg(ZSConnection connection, int16 reason)
{

    
    IF_DBGPRINT( DBG_CONINFO,("ConSSPI::AccessDeniedMsg: Entering ... reason[%d]\n",reason));

    ConSSPI * con = (ConSSPI *) connection;

    con->m_AccessError = reason;

    ZSecurityMsgAccessDenied        msg;
    msg.reason = reason;
    msg.protocolVersion = zSecurityCurrentProtocolVersion;


//    ZSecurityMsgAccessDeniedEndian(&msg);

    con->Send( zSecurityMsgAccessDenied, &msg, sizeof(msg), zProtocolSigSecurity);
    con->SetClass( zSecurityTypeBadUser);
    con->GetNetwork()->DelayedCloseConnection( con, zSecurityCloseTimeout);

}

void ConSSPI::AccessDeniedAPC(void* data)
{
    ConSSPI* pThis = (ConSSPI*) data;

    InterlockedDecrement((PLONG) &(pThis->m_InQueue) );

    pThis->AccessDeniedMsg((ZSConnection) pThis, pThis->m_Reason);

    pThis->Release(USER_APC_REF);

}

void ConSSPI::OpenAPC(void* data)
{
    ConSSPI* pThis = (ConSSPI*) data;

    InterlockedDecrement((PLONG) &(pThis->m_InQueue) );

    pThis->m_AccessError = zAccessGranted;

    if ( !pThis->IsClosing() )
    {

        pThis->m_CurrentMsgFunc = pThis->m_messageFunc;
        pThis->SendMessage(zSConnectionOpen);


        char buf[sizeof(ZSecurityMsgResp)+256];
        ZSecurityMsgResp* pReply=(ZSecurityMsgResp*) buf;

        pThis->m_Security->GetSecurityName(pReply->SecPkg);
        pThis->m_Context.GetUserName((char*)pReply->UserName);
        pThis->m_Context.GetContextString(pReply->SecBuffer, sizeof(buf)-sizeof(ZSecurityMsgResp) );

        pReply->protocolVersion=zSecurityCurrentProtocolVersion;

        pThis->Send(zSecurityMsgAccessGranted, pReply, sizeof(ZSecurityMsgResp)+lstrlenA(pReply->SecBuffer), zProtocolSigSecurity);
    }

    pThis->Release(USER_APC_REF);
}

void ConSSPI::QueueAccessDeniedAPC(int16 reason)
{
    ASSERT(m_InQueue);

    if (m_pMsg)
    {
        g_pDataPool->Free( (char*)m_pMsg, m_MsgLen);
        m_pMsg=NULL;
    }

    m_Reason = reason;

    AddRef(USER_APC_REF);
    if (!GetNetwork()->QueueAPCResult( ConSSPI::AccessDeniedAPC, this))
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Queue APC failed...\n"));
        GetNetwork()->CloseConnection(this);
        Release(USER_APC_REF);
        InterlockedDecrement((PLONG) &m_InQueue);
    }

}; 




BOOL ConSSPI::SetUserName(char* name)
{
    if (m_Security)
    {
        return FALSE;
    }
    else
    {
        m_Context.SetUserName(name);
        return TRUE;
    }
}


void ConSSPI::Invoke()
{
    BOOL              fDone;
    uint32            OutMsgType;
    uint32            OutMsgLen;
    BYTE *            OutBuffer;
    ZSecurityMsgResp* pReply;
    ULONG             cbBufferLen;
    ZSConnection      connection = (ZSConnection ) this;

    IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Invoke Entering ...\n"));

    ASSERT(m_InQueue);

    if ( IsClosing() )
    {
        Ignore();
        return;
    }

    //Allocate buffer for outgoing message
    OutBuffer = (LPBYTE) g_pDataPool->Alloc(m_Security->GetMaxBuffer() + sizeof(ZSecurityMsgResp));
    if (!OutBuffer)
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Couldn allocate security outbuffer...\n"));
        QueueAccessDeniedAPC(zAccessDenied);
        goto exit;
    }

    pReply = (ZSecurityMsgResp *) OutBuffer;
    m_Security->GetSecurityName(pReply->SecPkg);
    pReply->UserName[0]='\0';

    cbBufferLen = m_Security->GetMaxBuffer(); 
    
    ASSERT( m_pMsg );
    if ( !m_pMsg || !m_Security->GenerateContext( &m_Context,
                                                  (LPBYTE)m_pMsg->SecBuffer, m_MsgLen - sizeof(ZSecurityMsgReq),
                                                  (LPBYTE)pReply->SecBuffer, &cbBufferLen,
                                                  &fDone,
                                                  GetUserGUID() )

       )
    {
        IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Generate Context Failed...\n"));
        QueueAccessDeniedAPC(zAccessDenied);
        goto exit;
    }

    if (m_pMsg)
    {
        g_pDataPool->Free( (char*)m_pMsg, m_MsgLen);
        m_pMsg=NULL;
    }

    if (fDone)
    {
        AddRef(USER_APC_REF);
        if (!GetNetwork()->QueueAPCResult( ConSSPI::OpenAPC, this))
        {
            IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Queue of OpenAPC failed...\n"));
            GetNetwork()->CloseConnection(this);
            Release(USER_APC_REF);
            InterlockedDecrement((PLONG) &m_InQueue);
        }

    }
    else
    {
        pReply->protocolVersion=zSecurityCurrentProtocolVersion;
//        ZSecurityMsgRespEndian(pReply);

        //Send response to client
        InterlockedDecrement((PLONG) &m_InQueue);
        Send( zSecurityMsgChallenge, pReply,sizeof(ZSecurityMsgResp) + cbBufferLen, zProtocolSigSecurity);
    }

  exit:
    if (OutBuffer)
        g_pDataPool->Free( (char*)OutBuffer, m_Security->GetMaxBuffer() + sizeof(ZSecurityMsgResp) );

};


void ConSSPI::Ignore()
{

    IF_DBGPRINT( DBG_CONINFO,("ConSSPI::Queued Security Request Ignored...\n"));

    QueueAccessDeniedAPC(zAccessDeniedSystemFull);

}; 


void ConSSPI::Discard()
{

    LockNetStats();
    g_NetStats.TotalQueuedConSSPICompleted.QuadPart++;
    g_NetStats.TotalQueuedConSSPITicks.QuadPart += ConInfo::GetTickDelta(GetTickCount(), m_tickQueued);
    UnlockNetStats();

    Release(SECURITY_REF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\netserv.cpp ===
#include <windows.h>
#include <atlbase.h>

#include "zone.h"
#include "zonedebug.h"
#include "network.h"

#include "netstats.h"
#include "eventlog.h"
#include "zonemsg.h"

#include "zsecurity.h"
#include "zconnint.h"

#include "coninfo.h"
#include "zsecobj.h"
#include "consspi.h"
#include "consecureclient.h"
#include "zservcon.h"


// pool free connection structures
extern CPool<ConSSPI>*            g_pFreeConPool;
extern CPool<CONAPC_OVERLAPPED>*  g_pFreeAPCPool;

extern CDataPool* g_pDataPool;


/////////////////////////////////////////////////////////////////////////
//
//  Network Layer Implementation
/////////////////////////////////////////////////////////////////////////


ZError ZNetwork::InitLibrary( BOOL EnablePools /*= TRUE*/ )
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::InitLibrary: Entering\n") );

    ZError ret = zErrNone;

    if ( InterlockedIncrement( &m_refCount ) == 0 )
    {
        while( m_bInit )
        {
            Sleep(0);
        }

        if ( EnablePools )
        {
            g_pFreeAPCPool = new CPool<CONAPC_OVERLAPPED>(25);

            g_pFreeConPool = new CPool<ConSSPI>(25);
            ConSSPI::SetPool(g_pFreeConPool);

            g_pDataPool = new CDataPool( 1<<14, 1<<5, FALSE );
        }
        else
        {
            g_pDataPool = new CDataPool(0);
        }

        ret = InitLibraryCommon();
    }
    else
    {
        while( !m_bInit )
        {
            Sleep(0);
        }
    }
    return ret;
}


ZNetCon* ZNetwork::CreateSecureServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* conClass, char* serverName, char* serverType,
                                     char* ODBC, void *data,char *SecPkg, uint32 Anonymous, uint32 saddr )
{
    ZServerSecurityEx* security=NULL;
    USES_CONVERSION;
    
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::CreateServer: Entering\n") );

    if (!Anonymous && ( !SecPkg || (SecPkg[0]=='\0') ) )
    {
        DebugPrint("No security package or anonymous specified\n");
        return NULL;
    }
    ConInfo *con;
    SOCKET sock;

    // TODO: get rid of the security protocol. Make this an option somewhere
    if ( 0 )
    {
        //If anonymous not allowed create security package
        if (!Anonymous && SecPkg && (SecPkg[0]!='\0') ) {

            //If this is a server socket then initialize security now
            security=ZCreateServerSecurityEx(SecPkg,serverName, serverType,ODBC);
            if (!security)
            {
                LPTSTR ppStr[] = { A2T(SecPkg )};
                ZoneEventLogReport( ZONE_E_CANNOT_INIT_SECURITY, 1, ppStr, 0, NULL );
                IF_DBGPRINT( DBG_CONINFO, ("Couldn't InitSecurityPackage %s\n",SecPkg) );
                return NULL;
            }
    
            security->AddRef();
        }
    
        sock = ConIOServer(saddr, pPort, range, SOCK_STREAM);
        if (sock == INVALID_SOCKET)
        {
            if (security)
                security->Release();
            return NULL; 
        }

        ZEnd32(&saddr);
        con = ConSSPI::Create(this, sock, saddr, INADDR_NONE, ConInfo::ACCEPTING | ConInfo::ESTABLISHED,
                                       func, conClass, data, security);

        if (security)
            security->Release();
    }
    else
    {
        sock = ConIOServer(saddr, pPort, range, SOCK_STREAM);
        if (sock == INVALID_SOCKET)
        {
            if (security)
                security->Release();
            return NULL; 
        }


        ZEnd32(&saddr);
        con = ConInfo::Create(this, sock, saddr, INADDR_NONE, ConInfo::ACCEPTING | ConInfo::ESTABLISHED,
                                       func, conClass, data);
    }
    
    if ( con )
    {

        if ( IsCompletionPortEnabled() )
        {
            // associate accept socket with IO completion port
            HANDLE hIO = CreateIoCompletionPort( (HANDLE)sock, m_hIO, (DWORD)con, 0 );
            ASSERT( hIO == m_hIO );
            if ( !hIO )
            {
                con->Close();
                return NULL;
            }
        }

        con->AddRef( ConInfo::CONINFO_REF );

        if ( !AddConnection(con) )
        {
            con->Release(ConInfo::CONINFO_REF);
            con->Close();
            return NULL;        
        }

        con->AddUserRef();  // b/c we're returning it to the user
        InterlockedIncrement(&m_ConInfoUserCount);

        con->Release(ConInfo::CONINFO_REF);

    }

    return con;

}

/* Create a server for this port and receive connections on it */
/* connections will be sent to the MessageFunc */
ZNetCon* ZNetwork::CreateServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* conClass, void *data, uint32 saddr)
{
    return CreateSecureServer(pPort, range, func, conClass, NULL,NULL,NULL,  data, NULL,1, saddr);
}



BOOL ZNetwork::StartAccepting( ZNetCon* connection, DWORD dwMaxConnections, WORD wOutstandingAccepts )
{
    ASSERT(connection);

    ConInfo* con = (ConInfo*)connection;
    if ( con )
    {
        // issue the first accept
        return con->AcceptInit(dwMaxConnections, wOutstandingAccepts);
    }
    return FALSE;
}



////////////////////////////////////////////////////////////////////
// Local Rountines
////////////////////////////////////////////////////////////////////
/*
*  port = port number to bind to.
*  type = SOCK_STREAM or SOCK_DGRAM.
*
*  return:
*/
SOCKET ZNetwork::ConIOServer(uint32 saddr, uint16* pPort, uint16 range, int type)
{

    IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Entering ...\n") );
    IF_DBGPRINT( DBG_CONINFO, ("  Binding to port %d, range %d\n", *pPort, range ) );

    SOCKET sock = socket(AF_INET,type,0);
    if( sock == INVALID_SOCKET )
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Exiting(1).\n") );
        return INVALID_SOCKET;
    }

    if ( !ConIOSetServerSockOpt(sock) )
    {
        closesocket(sock);
        IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Exiting(2.5).\n") );
        return(INVALID_SOCKET);
    }

    struct sockaddr_in addr;
    addr.sin_family=AF_INET;
    addr.sin_addr.s_addr=saddr;
    addr.sin_port=htons(*pPort);

    while( range &&
           ( bind(sock,(struct sockaddr*)&addr,sizeof(addr)) == SOCKET_ERROR ) )
    {
        range--;
        *pPort = *pPort + 1;
        addr.sin_port=htons(*pPort);
    }
    if( range == 0 )
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Binding failed, WSAGetLastError() = %d\n", WSAGetLastError()) );
        closesocket(sock);
        IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Exiting(2).\n") );
        return(INVALID_SOCKET);
    }

    if(type==SOCK_STREAM) 
    {
        if( listen(sock, m_SocketBacklog) == SOCKET_ERROR )
        {
            closesocket(sock);
            IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Exiting(3).\n") );
            return(INVALID_SOCKET);
        }
    }
    
    IF_DBGPRINT( DBG_CONINFO, ("ConIOServer: Exiting(0).\n") );

    return(sock);
}


BOOL ZNetwork::ConIOSetServerSockOpt(SOCKET sock)
{
    int optval;



    /*
     * this setting will no cause a hard close
     */
    static struct linger arg = {1,0};
    if(setsockopt(sock,SOL_SOCKET,SO_LINGER,(char*)&arg,
          sizeof(struct linger))<0) {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOClient: Exiting(4).\n") );
        return FALSE;
    }

    /*
        Set the socket option to reuse local addresses. This should help
        resolve problems rerunning the server due to local address being
        bound to an inactive remote process.
    */
#if 0  // don't reuse addr since we do dynamic binding to a range of ports
    optval = 1;
    if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(const char*)&optval,
            sizeof(optval))<0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(4).\n") );
        return FALSE;
    }
#endif

    /*
        Set the socket option to keep the connection alive. It sends
        periodic messages to the peer and determines that the connection
        is broken if no replies are received. It sends a SIGPIPE signal
        if an attempt to write is made.

        KEEPALIVE does not work if the remote host does not support it and
        unnecessarily causes clients to be disconnected.
    */
    optval = m_EnableTcpKeepAlives;
    if(setsockopt(sock,SOL_SOCKET,SO_KEEPALIVE,(const char*)&optval,
            sizeof(optval))<0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(4).\n") );
        return FALSE;
    }


    /*
        since we're using overlapped IO
        can not set send buf size here, b/c we do a sync write
    */
#if 0
    optval = 0;
    if(setsockopt(sock,SOL_SOCKET,SO_SNDBUF,(const char*)&optval,
            sizeof(optval))<0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(4).\n") );
        return FALSE;
    }
#endif

    /*
        since we're using overlapped IO
    */
    optval = 1024;
    if(setsockopt(sock,SOL_SOCKET,SO_RCVBUF,(const char*)&optval,
            sizeof(optval))<0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(4).\n") );
        return FALSE;
    }



#if 0
    /*
        Disabling TCP_NODELAY since it doesn't really seem necessary.
    */
    /*
        TCP_NODELAY is used to disable what's called Nagle's Algorithm in the
        TCP transmission. Nagle's Algorithm is used to reduce the number of
        tiny packets transmitted by collecting a bunch of them into one
        segment -- mainly used for telnet sessions. This algorithm may also
        cause undue delays in transmission.

        Hence, we set this option in order to avoid unnecessary delays.
    */
    optval = 1;
    if(setsockopt(sock,IPPROTO_TCP,TCP_NODELAY,&optval,sizeof(int))<0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(5).\n") );
        return FALSE;
    }
#endif

    return TRUE;
}






////////////////////////////////////////////////////////////////////////
//
//  ZSConnection code
//
// this server side of the code is here to avoid clients linking with ODBC
//

extern ZNetwork* g_pNet;

ZError ZSConnectionLibraryInit()
{
    return ZSConnectionLibraryInit(TRUE);
}

ZError ZSConnectionLibraryInit(BOOL bEnablePools)
{
    ZError err = ZNetwork::InitLibrary(bEnablePools);

    if ( err == zErrNone )
    {
        ASSERT( !g_pNet );
        g_pNet = new ZNetwork;
        g_pNet->InitInst();
    }

    return err;
}


ZSConnection ZSConnectionCreateSecureServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* conClass, char* serverName, char* serverType, char* ODBC, void *data,char *SecPkg,uint32 Anonymous, uint32 saddr)
{
    return (ZSConnection) g_pNet->CreateSecureServer( pPort, range, func, conClass, serverName, serverType, ODBC, data, SecPkg, Anonymous, saddr);
}

ZSConnection ZSConnectionCreateServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* conClass, void *data, uint32 saddr)
{
    return (ZSConnection) g_pNet->CreateServer( pPort, range, func, conClass, data, saddr );
}


BOOL ZSConnectionStartAccepting( ZSConnection connection, DWORD dwMaxConnections, WORD wOutstandingAccepts )
{
    return g_pNet->StartAccepting( (ZNetCon*) connection, dwMaxConnections, wOutstandingAccepts );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\netstats.cpp ===
/*******************************************************************************

    NetStats.cpp
    
        Manages server statistic objects for performance counters
    
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    0        09/09/96    craigli    Created.
     
*******************************************************************************/



#include <windows.h>
#include "netstats.h"

CRITICAL_SECTION        g_csNetStats[1];
ZONE_STATISTICS_NET     g_NetStats;

void InitializeNetStats()
{
    InitializeCriticalSection( g_csNetStats );

    LockNetStats();
    ZeroMemory(&g_NetStats, sizeof(g_NetStats) );

    SYSTEMTIME systime;
    GetSystemTime( &systime );

    SystemTimeToFileTime( &systime, &(g_NetStats.TimeOfLastClear) );

    UnlockNetStats();

}


void ResetNetStats()
{
    LockNetStats();

    // preserve the non-ever increasing stats
    DWORD CurrentConnections = g_NetStats.CurrentConnections;
    DWORD CurrentBytesAllocated = g_NetStats.CurrentBytesAllocated;
    ZeroMemory(&g_NetStats, sizeof(g_NetStats) );
    g_NetStats.CurrentConnections = CurrentConnections;
    g_NetStats.MaxConnections = g_NetStats.CurrentConnections;
    g_NetStats.CurrentBytesAllocated = CurrentBytesAllocated;

    SYSTEMTIME systime;
    GetSystemTime( &systime );

    SystemTimeToFileTime( &systime, &(g_NetStats.TimeOfLastClear) );

    UnlockNetStats();
}

void GetNetStats( ZONE_STATISTICS_NET* pDst )
{
    LockNetStats();
    CopyMemory( pDst, &g_NetStats, sizeof(g_NetStats) );
    UnlockNetStats();
}



void DeleteNetStats()
{
    DeleteCriticalSection( g_csNetStats );
    ZeroMemory(&g_NetStats, sizeof(g_NetStats) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zodbc.h ===
#ifndef __ODBC_LIB_H__
#define __ODBC_LIB_H__

#include <windows.h>
#include <sql.h>
#include <sqlext.h>

class CODBC
{
public:
    CODBC();
    ~CODBC();

    // Reference counting
    ULONG AddRef();
    ULONG Release();

    // Rather than relying on CRT to initialize class' static
    // variables, an application can call this procedure.
    static BOOL Init();

    // Open ODBC connection
    BOOL Open( LPSTR szDSN, LPSTR szUserName, LPSTR szPassword, INT32 nTimeoutSec = -1 );

    // Close connection
    void Close();

    // wrappers
    SQLRETURN Reset();
    SQLRETURN SetTimeOut( DWORD dwTimeOut );
    SQLRETURN Prepare( TCHAR* szStmt );
    SQLRETURN Execute()                            { return SQLExecute( m_hstmt ); }
    SQLRETURN ExecuteDiscardRows();
    SQLRETURN ExecDirect( TCHAR* szStmt );
    SQLRETURN Fetch()                            { return SQLFetch( m_hstmt ); }
    SQLRETURN MoreResults()                        { return SQLMoreResults( m_hstmt ); }

    // wrappers for SQLBindParameter
    void ResetParamCount()                      { m_ParamCnt = 1; }

    SQLRETURN AddInParamInt( int* pValue );
    SQLRETURN AddInParamDWORD( DWORD* pValue ) { return AddInParamInt( (int*)pValue ); }
    SQLRETURN AddInParamShort( short* pValue );
    SQLRETURN AddInParamTiny( char* pValue );
    SQLRETURN AddInParamString( char* szValue, DWORD dwColSize );
    SQLRETURN AddOutParamInt( int* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamShort( short* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamTiny( char* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamString( char* szValue, DWORD dwColSize, DWORD cbMaxSize, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamDateTime( TIMESTAMP_STRUCT* pTimestamp, SDWORD* pcbValue = &gm_DummyParamBytes );

    // wrappers for SQLBindCol
    SQLRETURN AddColInt( int* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddColString( char* szValue, DWORD cbMaxSize, SDWORD* pcbValue = &gm_DummyParamBytes );

    // adjust column number
    void SkipColumn( int col )                { m_ColCnt++; }
    void SetColumn( int col )                { ASSERT( col >=  m_ColCnt ); m_ColCnt = col; }

    // Retrieves ODBC error description.
    TCHAR* GetError( SQLRETURN nResult, SWORD fHandleType, BOOL fIncludePrepareString = TRUE );

    // called after calling GetError
    TCHAR* GetErrorState() { return m_szSQLErrorState; }

    // Writes ODBC error to event log
    void LogError( SQLRETURN nResult, SWORD fHandleType, BOOL fIncludePrepareString = TRUE );
    
    // variable wrappers
    HENV hstmt()    { return m_hstmt; }
    HENV hdbc()        { return m_hdbc; }
    HENV henv()        { return m_henv; }
    
private:
    // ODBC handles
    HSTMT    m_hstmt;
    HDBC    m_hdbc;
    HENV    m_henv;

    // error string buffer
    TCHAR m_szError[ 1024 ];
    TCHAR m_szSQLErrorState[SQL_SQLSTATE_SIZE + 1];

    // prepare string buffer
    TCHAR m_szPrepare[ 512 ];

    // next parameter number
    SQLUSMALLINT m_ParamCnt;

    // next column number
    SQLUSMALLINT m_ColCnt;

    // reference count
    ULONG m_RefCnt;

    // Dummy  bytes for AddOutParam calls
    static SQLINTEGER gm_DummyParamBytes;
};


#ifndef NO_CODBC_POOLS
#include "queue.h"


class CODBCPool
{
public:
    CODBCPool();
    ~CODBCPool();

    // Initialize connection pool
    HRESULT Init( LPSTR szDSN, LPSTR szUserName, LPSTR szPassword, long iInitial, long iMax, BOOL fLogError = TRUE );

    // Retrieve connection from pool
    CODBC* Alloc( BOOL fLogError = TRUE );

    // Return connection to pool
    void Free( CODBC* pConnection, BOOL fConnectionOk = TRUE );

private:
    // free connections
    CMTList<CODBC> m_Idle;

    // login strings
    char m_szDSN[512];
    char m_szUserName[512];
    char m_szPassword[512];

    // connection counts
    long m_iMax;
    long m_iCount;
    
    // Last connection ok?  Prevents event log spamming.
    BOOL m_bLastConnectOk;
};

#endif

///////////////////////////////////////////////////////////////////////////////
// Inlines
///////////////////////////////////////////////////////////////////////////////

inline ULONG CODBC::AddRef()
{
    return ++m_RefCnt;
}


inline SQLRETURN CODBC::Prepare( TCHAR* szStmt )
{
	lstrcpyn( m_szPrepare, szStmt, sizeof(m_szPrepare) );
    return SQLPrepare( m_hstmt, (SQLTCHAR*) szStmt, SQL_NTS );
}



inline SQLRETURN CODBC::ExecDirect( TCHAR* szStmt )
{
    lstrcpyn( m_szPrepare, szStmt, sizeof(m_szPrepare) );
    return SQLExecDirect( m_hstmt, (SQLTCHAR*) szStmt, SQL_NTS );
}


inline SQLRETURN CODBC::Reset()
{
    SQLRETURN nResult;
    m_szPrepare[0] = '\0';
    m_ParamCnt = 1;
    m_ColCnt = 1;

    nResult = SQLFreeStmt( m_hstmt, SQL_CLOSE );
    if ( nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO)
        return nResult;

    nResult = SQLFreeStmt( m_hstmt, SQL_UNBIND );
    if ( nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO)
        return nResult;

    return SQLFreeStmt( m_hstmt, SQL_RESET_PARAMS );
}


inline SQLRETURN CODBC::AddInParamInt( int* pValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, pValue, 0, NULL );
}


inline SQLRETURN CODBC::AddInParamShort( short* pValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_SMALLINT, 0, 0, pValue, 0, NULL );
}


inline SQLRETURN CODBC::AddInParamTiny( char* pValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_TINYINT, 0, 0, pValue, 0, NULL );
}


inline SQLRETURN CODBC::AddInParamString( char* szValue, DWORD dwColSize )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, dwColSize, 0, szValue, 0, NULL );
}


inline SQLRETURN CODBC::AddOutParamInt( int* pValue, SDWORD* pcbValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, pValue, 0, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamShort( short* pValue, SDWORD* pcbValue  )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_SMALLINT, 0, 0, pValue, 0, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamTiny( char* pValue, SDWORD* pcbValue  )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_TINYINT, 0, 0, pValue, 0, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamString( char* szValue, DWORD dwColSize, DWORD cbMaxSize, SDWORD* pcbValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_CHAR, SQL_VARCHAR, dwColSize, 0, szValue, cbMaxSize, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamDateTime( TIMESTAMP_STRUCT* pTimestamp, SDWORD* pcbValue  )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_TYPE_TIMESTAMP, SQL_TYPE_TIMESTAMP, 0, 0, pTimestamp, 0, pcbValue );
}


inline SQLRETURN CODBC::SetTimeOut( DWORD dwTimeOut )
{
    return SQLSetStmtAttr( m_hstmt, SQL_ATTR_QUERY_TIMEOUT, (void*) dwTimeOut, 0 );
}


inline SQLRETURN CODBC::AddColInt( int* pValue, SDWORD* pcbValue )
{
    return SQLBindCol( m_hstmt, m_ColCnt++, SQL_C_SLONG, pValue, sizeof(int), pcbValue );
}


inline SQLRETURN CODBC::AddColString( char* szValue, DWORD cbMaxSize, SDWORD* pcbValue )
{
    return SQLBindCol( m_hstmt, m_ColCnt++, SQL_C_CHAR, szValue, cbMaxSize, pcbValue );
}


#endif //!__ODBC_LIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zsecobj.cpp ===
#include <windows.h>
#include <winsock.h>
#include <atlbase.h>


#include "zone.h"
#include "zonedebug.h"
#include "pool.h"
#include "queue.h"
#include "hash.h"
#include "zservcon.h"
#include "zsecurity.h"
#include "zconnint.h"
#include "thrdpool.h"
#include "coninfo.h"
#include "zsecobj.h"
#include "consspi.h"
#include "eventlog.h"
#include "zonemsg.h"
#include "registry.h"
#include "netstats.h"

#define SEC_SUCCESS(Status) ((Status) >= 0)



///////////////////////////////////////////////////////////////////////////////////
// Zone Security class Implementation
//
///////////////////////////////////////////////////////////////////////////////////

ZSecurity::ZSecurity(int Flags)
{
    m_cRef=0;
    m_cbMaxToken=0;

    m_pFuncs= NULL;
    m_phCredential=NULL;
    
    m_CredUse = SECPKG_CRED_OUTBOUND;

    m_pAuthDataPtr = NULL;

    m_SecPkg[0]='\0';

    m_fContextReq1=0;
    m_fContextReq2=0;     

    m_Flags=Flags;
}


ZSecurity::~ZSecurity()
{
    ASSERT(m_cRef==0);

    if (m_phCredential)
    {
        m_pFuncs->FreeCredentialHandle(m_phCredential);
        m_phCredential = NULL;
    }

    if ( m_pFuncs )
    {
        ZUnloadSSPS();
        m_pFuncs = NULL;
    }
}



int ZSecurity::Init(char* SecPkg) 
{
    SECURITY_STATUS ss;
    TimeStamp tsLifeTime;
    USES_CONVERSION;
    
    unsigned long cbOutBufferLen=0;
    //See what pkgSize is for now
    PSecPkgInfo pspInfo;

    IF_DBGPRINT( DBG_CONINFO,("ZSecurity::Init Entering\n") );
    
    ASSERT(SecPkg);

    if (!SecPkg)
        return -1;

    if (SecPkg[0]=='\0') {
        return -1;
    }

    
    //can't specify more than one option
    ASSERT(m_Flags == ZNET_NO_PROMPT || m_Flags == ZNET_PROMPT_IF_NEEDED || m_Flags == ZNET_FORCE_PROMPT);

    m_fContextReq1=ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;
    m_fContextReq2=ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;

    if (m_Flags & ZNET_NO_PROMPT )
    {
        if ( m_pAuthDataPtr && m_pAuthDataPtr->Password )
        {
            m_fContextReq1 |= ISC_REQ_USE_SUPPLIED_CREDS;
            m_fContextReq2 |= ISC_REQ_USE_SUPPLIED_CREDS;
        }
    }
    else if (m_Flags & ZNET_PROMPT_IF_NEEDED )
    {
        if ( m_pAuthDataPtr && m_pAuthDataPtr->Password )
        {
            m_fContextReq1 |= ISC_REQ_USE_SUPPLIED_CREDS;
        }

        m_fContextReq2 |= ISC_REQ_PROMPT_FOR_CREDS;
    }
    else if (m_Flags & ZNET_FORCE_PROMPT)
    {
        m_fContextReq1 |= ISC_REQ_PROMPT_FOR_CREDS;
        m_fContextReq2 |= ISC_REQ_PROMPT_FOR_CREDS;
    }

    if (lstrcmpA(SecPkg,"NTLM") == 0)
    {
        m_fContextReq1=0;
        m_fContextReq2=0;     
    }

    if (lstrlenA(SecPkg) > zSecurityNameLen)
        return -1;

    lstrcpyA(m_SecPkg,SecPkg);
                
    //  Load security DLL
    //
    m_pFuncs = ZLoadSSPS();
    if (m_pFuncs == NULL)
    {    
        IF_DBGPRINT( DBG_CONINFO,("ZSecurity: Cannot load security library\n"));
        return -1;
    }

        
    if (ss = m_pFuncs->QuerySecurityPackageInfo(A2T(SecPkg), &pspInfo)
            != SEC_E_OK)
    {
        ZUnloadSSPS();
        m_pFuncs = NULL;

        IF_DBGPRINT( DBG_CONINFO,("ZSecurity:: QuerySecurityPackageInfo Failed [%d]\n", ss));
        return -1;
    }

    IF_DBGPRINT( DBG_CONINFO,("ZSecurity:: QuerySecurityPackageInfo Version [%d]\n", pspInfo->wVersion));

    m_cbMaxToken=pspInfo->cbMaxToken;

    return NO_ERROR;
}


int ZSecurity::GetUserName(ZSecurityContext *context,char * UserName)
{
    
    SECURITY_STATUS ss;
    SecPkgContext_Names     pkgName;
    TCHAR * pName;
    USES_CONVERSION;
    
    ASSERT(context);
    ASSERT(UserName);
    
    if (!m_pFuncs)
        return -1;

    if (!UserName)
        return -1;

    if (!context->IsComplete())
        return -1;

    // Assumes The client has been successfully authenticated
    //
    ss = m_pFuncs->QueryContextAttributes (context->Context(), 
                                    SECPKG_ATTR_NAMES, &pkgName);
    if (ss != SEC_E_OK )
    {
        IF_DBGPRINT( DBG_CONINFO, ("Cannot Query Account Attributes [%d]\n",
            ss));
        return -1;
    }

    if (!pkgName.sUserName)
        return -1;
    
    //Get rid of Zone/Realm/Domain prefix from user name
    pName = pkgName.sUserName;
    while (1) {
        if (*pName == '\0') {
            pName = pkgName.sUserName;
            break;
        }
        if (*pName == '\\') {
            pName++;
            break;
        }
        pName++;
    }

    if ( *pName != '\0' )
    {
        //Make sure the length of the name to be copied is ok
        if (lstrlen(pName) < zUserNameLen)  // for sysop symbol reasons we want this to be less than 31
        {
            lstrcpyA(UserName,T2A(pName));
            m_pFuncs->FreeContextBuffer(pkgName.sUserName);
            return 0;
        }
        else
        {
            IF_DBGPRINT( DBG_CONINFO, ("Account Name Too Large\n"));
            return -1;
        }
    }
    else
    {
        m_pFuncs->FreeContextBuffer(pkgName.sUserName);
        return -1;
    }


}




BOOL ZSecurity::GenerateContext (
            ZSecurityContext *context,
            BYTE *pIn,
            DWORD cbIn,
            BYTE *pOut,
            DWORD *pcbOut,
            BOOL *pfDone,
            GUID* )
/*++

 Routine Description:

    Optionally takes an input buffer coming from the server and returns
    a buffer of information to send back to the server.  Also returns
    an indication of whether or not the context is complete.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
    SECURITY_STATUS    ss;
    TimeStamp        Lifetime;
    SecBufferDesc    OutBuffDesc;
    SecBuffer        OutSecBuff;
    SecBufferDesc    InBuffDesc;
    SecBuffer        InSecBuff;
    USES_CONVERSION;


    ASSERT(m_pFuncs);

    if (!m_pFuncs)
        return FALSE;

    //If the credentials handle is NULL then this is the first client call
    BOOL  bRet = FALSE;
    DWORD tickStart = GetTickCount();

    if (!m_phCredential)  {
        ss = m_pFuncs->AcquireCredentialsHandle (
                            NULL,    // principal
                            A2T(m_SecPkg),
                            m_CredUse,
                            NULL,    // LOGON id
                            m_pAuthDataPtr,    // auth data
                            NULL,    // get key fn
                            NULL,    // get key arg
                            &m_hCredential,
                            &Lifetime
                            );
        if (SEC_SUCCESS (ss))
            m_phCredential = &m_hCredential;
        else {
            IF_DBGPRINT( DBG_CONINFO,("AcquireCreds failed: %u\n", ss));
            goto exit;
        }
    }

    // prepare output buffer
    //
    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers = 1;
    OutBuffDesc.pBuffers = &OutSecBuff;

    OutSecBuff.cbBuffer = *pcbOut;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer = pOut;

    // prepare input buffer
    
    
    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers = 1;
    InBuffDesc.pBuffers = &InSecBuff;

    InSecBuff.cbBuffer = cbIn;
    InSecBuff.BufferType = SECBUFFER_TOKEN;
    InSecBuff.pvBuffer = pIn;
    

    ss = SecurityContext (context, &InBuffDesc,&OutBuffDesc);

    if (!SEC_SUCCESS (ss))  {
        IF_DBGPRINT( DBG_CONINFO,("Init context failed: %u\n", ss));
        goto exit;
    }

    // Complete token -- if applicable
    //
    if ((SEC_I_COMPLETE_NEEDED == ss) || (SEC_I_COMPLETE_AND_CONTINUE == ss))  {
        if (m_pFuncs->CompleteAuthToken) {
            ss = m_pFuncs->CompleteAuthToken (context->Context(), &OutBuffDesc);
            if (!SEC_SUCCESS(ss))  {
                IF_DBGPRINT( DBG_CONINFO,("Complete failed: %u\n", ss));
                goto exit;
            }
        }
        else {
            IF_DBGPRINT( DBG_CONINFO,("Complete not supported.\n"));
            goto exit;
        }
    }

    *pcbOut = OutSecBuff.cbBuffer;

    context->Initialize();

    *pfDone = !((SEC_I_CONTINUE_NEEDED == ss) ||
                (SEC_I_COMPLETE_AND_CONTINUE == ss));

    if (*pfDone)
        context->Complete();

    bRet = TRUE;

  exit:
    LockNetStats();
    g_NetStats.TotalGenerateContexts.QuadPart ++;
    g_NetStats.TotalGenerateContextsTicks.QuadPart += ConInfo::GetTickDelta(GetTickCount(), tickStart);
    UnlockNetStats();

    return bRet;
}


ZSecurity * ZCreateClientSecurity(char * Name,char *Password, char * Domain, int Flags)
{
    return new ZClientSecurity(Name,Password,Domain, Flags);
}


ZClientSecurity::ZClientSecurity(char * Name,char *Password, char * Domain, int Flags) : ZSecurity(Flags) {
    m_CredUse = SECPKG_CRED_OUTBOUND;
    m_User[0]='\0';
    m_Password[0]='\0';
    m_Domain[0]='\0';
    USES_CONVERSION;
    
    m_AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    if (Name) {
        lstrcpyn(m_User,A2T(Name),sizeof(m_User));
        m_AuthData.User = (PBYTE)m_User;
        m_AuthData.UserLength = lstrlen (m_User);
    }
    else
    {
        m_AuthData.User = (PBYTE)NULL;
        m_AuthData.UserLength = 0;
    }

    if (Password) {
        lstrcpyn(m_Password,A2T(Password),sizeof(m_Password));
        m_AuthData.Password = (PBYTE)m_Password;
        m_AuthData.PasswordLength = lstrlen (m_Password);
    }
    else
    {
        m_AuthData.Password = (PBYTE)NULL;
        m_AuthData.PasswordLength = 0;
    }

    if (Domain) {
        lstrcpyn(m_Domain,A2T(Domain),sizeof(m_Domain));
        m_AuthData.Domain = (PBYTE)m_Domain;
        m_AuthData.DomainLength = lstrlen (m_Domain);
    }
    else
    {
        m_AuthData.Domain = (PBYTE)NULL;
        m_AuthData.DomainLength = 0;
    }

    //if name is not NULL then we will authenticate with name
    //and not default credentials
    if (Name && *Name)
        m_pAuthDataPtr = &m_AuthData;

}

SECURITY_STATUS ZClientSecurity::SecurityContext(
        ZSecurityContext *context,
         PSecBufferDesc pInput,                  
        PSecBufferDesc pOutput)

{

    ULONG ContextAttributes;
    TimeStamp        Lifetime;
    SEC_CHAR        *pszTargetName;
    SECURITY_STATUS ss1,ss2;

    ss1 = m_pFuncs->InitializeSecurityContext (
                        &m_hCredential,
                        context->IsInitialized() ? context->Context() : NULL ,
                        TEXT("AuthSamp"), //TOKEN_SOURCE_NAME, for NTLM
                        m_fContextReq1,    // context requirements
                        0L,    // reserved1
                        SECURITY_NATIVE_DREP,
                        context->IsInitialized() ? pInput : NULL ,
                        0L,    // reserved2
                        context->Context() ,
                        pOutput,
                        &ContextAttributes,
                        &Lifetime
                        );

    if (m_fContextReq1 & ISC_REQ_PROMPT_FOR_CREDS)
        return ss1;

    if (ss1 != SEC_E_NO_CREDENTIALS )
        return ss1;

    //try again and prompt for credentials
    //not in the case of NTLM though   
    
    ss2 = m_pFuncs->InitializeSecurityContext (
                        &m_hCredential,
                        context->IsInitialized() ? context->Context() : NULL ,
                        NULL, //TOKEN_SOURCE_NAME, for NTLM
                        m_fContextReq2,    // context requirements
                        0L,    // reserved1
                        SECURITY_NATIVE_DREP,
                        context->IsInitialized() ? pInput : NULL ,
                        0L,    // reserved2
                        context->Context() ,
                        pOutput,
                        &ContextAttributes,
                        &Lifetime
                        );

    if (ss2 == SEC_E_UNSUPPORTED_FUNCTION)
        return ss1;
            
    return ss2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zsecobj.h ===
#ifndef _ZSECOBJ_H_
#define _ZSECOBJ_H_

#include "containers.h"
#include "pool.h"
#include "queue.h"
#include "hash.h"
#include "thrdq.h"
#include "thrdpool.h"
#include "zodbc.h"


///////////////////////////////////////////////////////////////////////////////////
//ZSecurityContext
//Base security class encapsulating the SSPI APIs
//
class ZSecurityContext {
public:
    ZSecurityContext() {m_Initialized=FALSE;m_Complete=FALSE;};
    friend class ZSecurity;
    friend class ZServerSecurity;
    friend class ZClientSecurity;

    BOOL IsInitialized() {return m_Initialized;};
    
    BOOL IsComplete() {return m_Complete;};

protected:
    //per connection context information for client
    CtxtHandle    m_hContext;
    BOOL m_Initialized;
    BOOL m_Complete;
    
    PCtxtHandle Context() {return &m_hContext;};
        
    void Initialize() {m_Initialized=TRUE;};

    void Complete() {m_Complete=TRUE;};
};




///////////////////////////////////////////////////////////////////////////////////
//ZSecurity
//Base security class encapsulating the SSPI APIs
//
class ZSecurity {
public:

    ZSecurity(int Flags=ZNET_NO_PROMPT);
    virtual ~ZSecurity();

    void AddRef() {InterlockedIncrement(&m_cRef);}
    void Release() { if (!InterlockedDecrement(&m_cRef)) delete this; }

    virtual BOOL GenerateContext (
            ZSecurityContext * context,
            BYTE *pIn,
            DWORD cbIn,
            BYTE *pOut,
            DWORD *pcbOut,
            BOOL *pfDone,
            GUID* pGUID = NULL);
    
    void FreeContext(ZSecurityContext * context)
        {
            if (context->IsInitialized())
                m_pFuncs->DeleteSecurityContext(context->Context());
        }

    
    int Init(char * SecPkg);

    //Can be called after successful init
    int GetMaxBuffer() {return m_cbMaxToken;}

    //Can be called after authentication done
    int GetUserName(ZSecurityContext *context, char* UserName);

    int Impersonate(ZSecurityContext *context) { return  m_pFuncs->ImpersonateSecurityContext(context->Context()); }

    int Revert(ZSecurityContext *context) { return m_pFuncs->RevertSecurityContext(context->Context()); }

    int GetFlags() { return m_Flags; }

    int GetSecurityName(char* SecPkg)
        {
            ASSERT(SecPkg);
            lstrcpyA(SecPkg,m_SecPkg);
            return FALSE;
        }

    virtual void AccessGranted() { };

    virtual void AccessDenied() { };

protected:

    virtual SECURITY_STATUS SecurityContext(
        ZSecurityContext * context,
        PSecBufferDesc pInput,                  // Input buffer
        PSecBufferDesc pOutput                 // (inout) Output buffers
        )=0;

    //SSPI function table 
    PSecurityFunctionTable m_pFuncs;
        
    //global credential handle for server
    CredHandle m_hCredential;
    PCredHandle m_phCredential;

    //max token size
    unsigned long m_cbMaxToken;

    ULONG m_CredUse;

    //reference count
    LONG m_cRef;    
    
    //security package
    char m_SecPkg[zSecurityNameLen];


    //Authentication data
    PSEC_WINNT_AUTH_IDENTITY_A m_pAuthDataPtr ;

    ULONG m_fContextReq1;
    ULONG m_fContextReq2; 

    int m_Flags;
    
};

///////////////////////////////////////////////////////////////////////////////////
//ZCreateClientSecurity
//
//Creates client security object
//If no user name or password given then will assume to prompt for logon
//if GenerateContext fails then it may be because of a bad password


ZSecurity * ZCreateClientSecurity(char * Name,char *Password, char * Domain, int Flags);

///////////////////////////////////////////////////////////////////////////////////
//ZSecurityClient
//Class to implement client SSPI security

class ZClientSecurity : public ZSecurity {
public:
    ZClientSecurity(char * Name,char *Password, char * Domain, int Flags);

protected:
    virtual SECURITY_STATUS SecurityContext(
        ZSecurityContext * context,
        PSecBufferDesc pInput,                  
        PSecBufferDesc pOutput                 
        );
          
protected:
    TCHAR m_User[zUserNameLen+1];
    TCHAR m_Password[zUserNameLen+1];
    TCHAR m_Domain[zSecurityNameLen];

    SEC_WINNT_AUTH_IDENTITY_A m_AuthData;
    
};


#include "zservsec.h"

#endif //ZSECOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zodbc.cpp ===
#include <windows.h>
#include <atlbase.h>

#include "zonedebug.h"
//#include "zone.h"
#include "eventlog.h"
#include "zonemsg.h"
#include "zodbc.h"


///////////////////////////////////////////////////////////////////////////////
// ODBC connection wrapper
///////////////////////////////////////////////////////////////////////////////

SQLINTEGER CODBC::gm_DummyParamBytes = 0;


BOOL CODBC::Init()
{
    gm_DummyParamBytes = 0;
    return TRUE;
}


CODBC::CODBC()
{
    m_RefCnt = 1;
    m_hstmt = SQL_NULL_HSTMT;
    m_hdbc = SQL_NULL_HDBC;
    m_henv = SQL_NULL_HENV;
    m_szPrepare[0] = '\0';
    m_szError[0] = '\0';
    m_szSQLErrorState[0] = '\0';
}


CODBC::~CODBC()
{
    Close();
}


ULONG CODBC::Release()
{
    if ( --m_RefCnt == 0 )
    {
        delete this;
        return 0;
    }
    return m_RefCnt;
}


// justin: added nTimeoutSec parameter - since m_hdbc is unavailble until allocated within this call, no way to set the
// connection timeout externally.  only affects timeout for initial connection to the db.  (SQL_ATTR_LOGIN_TIMEOUT)
// ignored if negative (which is the default).
BOOL CODBC::Open(LPSTR szDSN, LPSTR szUserName, LPSTR szPassword, INT32 nTimeoutSec)
{
    SQLRETURN  status;
    USES_CONVERSION;
    // paranoia
    if (!szDSN || !szUserName || !szPassword )
        return FALSE;

    // allocate environment handle
    if (SQLAllocHandle( SQL_HANDLE_ENV, SQL_NULL_HANDLE, &m_henv) != SQL_SUCCESS)
        return FALSE;
    if (SQLSetEnvAttr( m_henv, SQL_ATTR_ODBC_VERSION, (SQLPOINTER) SQL_OV_ODBC3, SQL_IS_INTEGER) != SQL_SUCCESS)
    {
        Close();
        return FALSE;
    }
    if (SQLSetEnvAttr( m_henv, SQL_ATTR_CONNECTION_POOLING, (SQLPOINTER) SQL_CP_ONE_PER_HENV, SQL_IS_INTEGER) != SQL_SUCCESS)
    {
        Close();
        return FALSE;
    }


    // Experimentation with Microsoft's SQL Server ODBC Driver v2.65.0186
    // indicates that we only get one pending query per connection.
    // This behavior isn't acceptable, so we use one connection
    // per statement.
    status = SQLAllocHandle( SQL_HANDLE_DBC, m_henv, &m_hdbc );
    if (status != SQL_SUCCESS && status != SQL_SUCCESS_WITH_INFO)
    {
        Close();
        return FALSE;
    }

	if(nTimeoutSec >= 0)
	{
		if (SQLSetConnectAttr( m_hdbc, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER) nTimeoutSec, SQL_IS_INTEGER) != SQL_SUCCESS)
		{
			Close();
			return FALSE;
		}
	}

    status = SQLConnect( m_hdbc,  (SQLTCHAR*)A2T(szDSN), SQL_NTS,
                                  (SQLTCHAR*)A2T(szUserName), SQL_NTS,
                                  (SQLTCHAR*)A2T(szPassword), SQL_NTS );
    if (status != SQL_SUCCESS && status != SQL_SUCCESS_WITH_INFO)
    {
        Close();
        return FALSE;
    }

    status = SQLAllocHandle( SQL_HANDLE_STMT, m_hdbc, &m_hstmt );
    if ( (status != SQL_SUCCESS && status != SQL_SUCCESS_WITH_INFO ) || (m_hstmt == SQL_NULL_HSTMT) )
    {
        GetError( status, SQL_HANDLE_STMT, FALSE );
        Close();
        return FALSE;
    }

    return TRUE;
}


void CODBC::Close()
{
    if (m_hstmt != SQL_NULL_HSTMT )
    {
        SQLFreeStmt( m_hstmt, SQL_DROP );
        m_hstmt = SQL_NULL_HSTMT;
    }
    if (m_hdbc != SQL_NULL_HDBC)
    {
        SQLDisconnect( m_hdbc );
        SQLFreeHandle( SQL_HANDLE_DBC, m_hdbc );
        m_hdbc = SQL_NULL_HDBC;
    }
    if (m_henv != SQL_NULL_HENV)
    {
        SQLFreeHandle( SQL_HANDLE_ENV, m_henv );
        m_henv = SQL_NULL_HENV;
    }
}


TCHAR* CODBC::GetError( SQLRETURN nResult, SWORD fHandleType, BOOL fIncludePrepareString )
{
    const TCHAR SQLERR_FORMAT[]=TEXT( "SQL Error State:%s, Native Error Code: %lX, ODBC Error: %s");

    TCHAR       szBuff[ 1024 ];                                // String buffer
    TCHAR       szErrText[ SQL_MAX_MESSAGE_LENGTH + 1 ];    // SQL Error Text string
    UDWORD        dwErrCode;                                    // Native Error code
    SWORD        wErrMsgLen;                                    // Error message length
    SQLRETURN    result;
    SQLHANDLE    handle;
    SWORD        sMsgNum = 1;
    int            iBuffLen;

    // get appropriate handle
    switch ( fHandleType )
    {
    case SQL_HANDLE_ENV:
        handle = henv();
        break;
    case SQL_HANDLE_DBC:
        handle = hdbc();
        break;
    case SQL_HANDLE_STMT:
        handle = hstmt();
        break;
    default:
        return NULL;
    }

    // prepend prepare string so we know what failed
    ZeroMemory( m_szError, sizeof(m_szError) );
    if ( fIncludePrepareString && m_szPrepare[0] )
        wsprintf( m_szError, TEXT("%s\n"), m_szPrepare );
    else
        m_szError[0] = '\0';

    // get error messages
    for (int i = sizeof(m_szError) - lstrlen(m_szError) - 1; i > 0; i -= iBuffLen )
    {
        result = SQLGetDiagRec(
                            fHandleType,
                            handle,
                            sMsgNum++,
                            (SQLTCHAR*)m_szSQLErrorState,
                            (long*) &dwErrCode,
                            (SQLTCHAR*)szErrText,
                            SQL_MAX_MESSAGE_LENGTH - 1,
                            &wErrMsgLen);
        if ( result == SQL_NO_DATA || result == SQL_ERROR || result == SQL_INVALID_HANDLE )
            break;
        wsprintf( szBuff, SQLERR_FORMAT, (LPTSTR) m_szSQLErrorState, dwErrCode, (LPTSTR) szErrText );
        iBuffLen = lstrlen( szBuff );
        if ( iBuffLen <= i )
            lstrcat( m_szError, szBuff );
    }

    return m_szError;
}


void CODBC::LogError( SQLRETURN nResult, SWORD fHandleType, BOOL fIncludePrepareString )
{
    LPTSTR ppStr[1];

    ppStr[0] = GetError( nResult, fHandleType, fIncludePrepareString );
    ZoneEventLogReport( ZONE_E_SQL_ERROR, 1, ppStr, 0, NULL );
}


SQLRETURN CODBC::ExecuteDiscardRows()
{
    SQLRETURN nResult = SQL_SUCCESS;

    // execute query
    nResult = SQLExecute( m_hstmt );
    if (nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO && nResult != SQL_NO_DATA_FOUND)
        return nResult;

    // get all result sets
    for (;;)
    {
        nResult = SQLMoreResults( m_hstmt );
        if (nResult == SQL_NO_DATA_FOUND || (nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO) )
            break;
    }
    if ( nResult == SQL_NO_DATA_FOUND )
        nResult = SQL_SUCCESS;

    return nResult;
}


///////////////////////////////////////////////////////////////////////////////
// Connection pool
///////////////////////////////////////////////////////////////////////////////

CODBCPool::CODBCPool()
{
    m_szDSN[0] = '\0';
    m_szUserName[0] = '\0';
    m_szPassword[0] = '\0';
    m_iMax = 0;
    m_iCount = 0;
    m_bLastConnectOk = TRUE;
}


CODBCPool::~CODBCPool()
{
    CODBC* p;

    // release idle connections
    while ( p = m_Idle.PopHead() )
        p->Release();
}


HRESULT CODBCPool::Init( LPSTR szDSN, LPSTR szUserName, LPSTR szPassword, long iInitial, long iMax, BOOL fLogError )
{
    USES_CONVERSION;
    // stash login info
    lstrcpyA( m_szDSN, szDSN );
    lstrcpyA( m_szUserName, szUserName );
    lstrcpyA( m_szPassword, szPassword );

    // stash pool size
    m_iMax = iMax;
    m_iCount = 0;

    // we want an error reported
    m_bLastConnectOk = TRUE;

    // allocate initial connections
    for ( int i = 0; i < iInitial; i++ )
    {
        CODBC* p = new CODBC;
        if ( !p )
            return E_OUTOFMEMORY;

        if ( !p->Open( m_szDSN, m_szUserName, m_szPassword ) )
        {
            p->Release();
            if ( fLogError && m_bLastConnectOk )
            {
                LPTSTR ppStr[] = { A2T(m_szDSN), A2T(m_szUserName), A2T(m_szPassword)  };
                ZoneEventLogReport( ZONE_E_INIT_SQL_FAILED, 3, ppStr, 0, NULL );
                m_bLastConnectOk = FALSE;
            }
            return E_FAIL;
        }

        if ( !m_Idle.AddHead( p ) )
        {
            p->Release();
            return E_FAIL;
        }
    }
    m_iCount = iInitial;

    return NOERROR;
}


CODBC* CODBCPool::Alloc( BOOL fLogError )
{
    CODBC* p;
    USES_CONVERSION;
    p = m_Idle.PopHead();
    if ( !p )
    {
        if ( m_iCount >= m_iMax )
            return NULL;

        p = new CODBC;
        if ( !p )
            return NULL;

        if ( !p->Open( m_szDSN, m_szUserName, m_szPassword ) )
        {
            p->Release();
            if ( fLogError && m_bLastConnectOk )
            {
                LPTSTR ppStr[] = { A2T(m_szDSN), A2T(m_szUserName), A2T(m_szPassword  )};
                ZoneEventLogReport( ZONE_E_INIT_SQL_FAILED, 3, ppStr, 0, NULL );
                m_bLastConnectOk = FALSE;
            }
            return NULL;
        }

        InterlockedIncrement( &m_iCount );
        m_bLastConnectOk = TRUE;
    }
    p->AddRef();
    p->Reset();
    return p;
}


void CODBCPool::Free( CODBC* pConnection, BOOL fConnectionOk )
{
    // release client's ref count
    if ( pConnection->Release() == 0 )
        return;

    if ( !fConnectionOk || !m_Idle.AddHead( pConnection ) )
    {
        // get rid of it
        pConnection->Release();
        InterlockedDecrement( &m_iCount );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\network.cpp ===
#include <windows.h>
#include <atlbase.h>

#include "zone.h"
#include "zonedebug.h"
#include "network.h"

#include "netstats.h"
#include "eventlog.h"
#include "zonemsg.h"

#include "zsecurity.h"
#include "zconnint.h"

#include "coninfo.h"
#include "zsecobj.h"
#include "consspi.h"
#include "consecureclient.h"

#include "protocol.h"

DWORD  g_EnableTickStats = FALSE; // set from registry
DWORD  g_LogServerDisconnects = 0;  // set from registry
DWORD  g_PoolCleanupHighTrigger = 80;
DWORD  g_PoolCleanupLowTrigger = 0;


static bool TimeoutCallback( ZNetCon* con, MTListNodeHandle h, void* elapsed );
static bool KeepAliveCallback( ZNetCon* con, MTListNodeHandle h, void* );
static bool ClassEnumCallback( ZNetCon* con, MTListNodeHandle h, void* Cookie );
static bool TerminateCallback( ZNetCon* con, MTListNodeHandle h, void* Cookie );



// pool free connection structures
CPool<ConSSPI>*            g_pFreeConPool = NULL;
CPool<CONAPC_OVERLAPPED>*  g_pFreeAPCPool = NULL;

CDataPool* g_pDataPool = NULL;

// Hash table for all connections - so we can terminate a single connection quickly
CMTList<ConInfo> g_Connections;
CMTList<ConInfo> g_TimeoutList;

#if TRACK_IO
HANDLE hLogFile = INVALID_HANDLE_VALUE;
#endif

/////////////////////////////////////////////////////////////////////////
//
//  Network Layer Implementation
/////////////////////////////////////////////////////////////////////////

long          ZNetwork::m_refCount = -1;
BOOL volatile ZNetwork::m_bInit = FALSE;
HANDLE        ZNetwork::m_hClientLoginMutex = NULL;



ZNetwork::ZNetwork() :
    m_Exit(FALSE), m_hIO(NULL), m_bEnableCompletionPort(TRUE),

    m_SocketBacklog( 5 ),
    m_EnableTcpKeepAlives( 0 ),
    m_WaitForCompletionTimeout( 250 ),
    m_RegWriteTimeout( 300000 ),
    m_DisableEncryption( 0 ),
    m_MaxSendSize( 0x40000 ),  // 256 KB
    m_MaxRecvSize( 0x40000 ),  // 256 KB
    m_KeepAliveInterval( 180000 ),
    m_PingInterval( INFINITE ),
    m_ProductSignature( zProductSigZone ),
    m_ClientEncryption( FALSE ),

    m_ConInfoUserCount( 0 ),
    m_ConInfoCount( 0 ),

    m_hWakeUpEvent(NULL),
    m_hTerminateEvent(NULL),

    m_nCompletionEvents(0),

    m_LastTick(0)

{}


ZError ZNetwork::InitLibraryCommon()
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::InitLibraryCommon: Entering\n") );

    // initialize sockets
    {
        WSADATA wsaData;
        int i = WSAStartup(MAKEWORD(1,1) ,&wsaData);
        if (i!=0)
        {
            i = WSAGetLastError();
            ZoneEventLogReport( ZONE_E_CANNOT_INIT_WINSOCK, 0, NULL, sizeof(i), &i );
            return zErrNetworkGeneric;
        }
    }

    char buf[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)buf;
    SECURITY_ATTRIBUTES  sa;
    SECURITY_ATTRIBUTES* pSA = NULL;

    if ( InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION ) )
    {
        if ( SetSecurityDescriptorDacl( pSD, TRUE, (PACL) NULL, FALSE ) )
        {
            sa.nLength = sizeof(sa);
            sa.lpSecurityDescriptor = pSD;
            sa.bInheritHandle = TRUE;
            pSA = &sa;
        }
    }
    m_hClientLoginMutex = CreateMutex( pSA, FALSE, TEXT("ZoneNetworkLoginMutex") );
 //   ASSERT(m_hClientLoginMutex);

    // initialize statistic gathering
    InitializeNetStats();

#if TRACK_IO
    hLogFile = CreateFile( "coninfo.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
#endif

    m_bInit = TRUE;

    return zErrNone;
}

ZError ZNetwork::InitLibraryClientOnly( BOOL EnablePools /*= FALSE*/ )
{
    ZError ret = zErrNone;

    if ( InterlockedIncrement( &m_refCount ) == 0 )
    {
        while( m_bInit )
        {
            Sleep(0);
        }

        if ( EnablePools )
        {
            g_pDataPool = new CDataPool( 1<<14, 1<<5, FALSE );
        }
        else
        {
            g_pDataPool = new CDataPool(0);
        }

        ret = InitLibraryCommon();
    }
    else
    {
        while( !m_bInit )
        {
            Sleep(0);
        }
    }
    return ret;
}


ZError ZNetwork::InitInst(BOOL EnableCompletionPort /* = TRUE */ )
{
    if ( m_refCount < 0 )
    {
        return zErrBadObject;
    }

    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::InitInst: Entering\n") );
    InitializeCriticalSection( m_pcsGetQueueCompletion );
    InitializeCriticalSection( m_pcsCompletionQueue );

    m_bEnableCompletionPort = EnableCompletionPort;

    if ( IsCompletionPortEnabled() )
        m_hIO = CreateIoCompletionPort( INVALID_HANDLE_VALUE, NULL, 0, 0 );

    if ( !m_hIO )
    {
        m_bEnableCompletionPort = FALSE;
        m_hCompletionEvents[0] = m_hWakeUpEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        m_hCompletionEvents[1] = m_hTerminateEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        m_nCompletionEvents = 2;
    }

    return zErrNone;
}

void ZNetwork::CleanUpInst()
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::Cleanup: Entering\n") );
    if ( m_hIO )
    {
        CloseHandle( m_hIO );
        m_hIO = NULL;
    }

    if ( m_hWakeUpEvent )
    {
        CloseHandle( m_hWakeUpEvent );
        m_hWakeUpEvent = NULL;
    }

    if ( m_hTerminateEvent )
    {
        CloseHandle( m_hTerminateEvent );
        m_hTerminateEvent = NULL;
    }

    // TODO all list should be clean

    DeleteCriticalSection( m_pcsCompletionQueue );
    DeleteCriticalSection( m_pcsGetQueueCompletion );
}

void ZNetwork::CleanUpLibrary()
{
    ASSERT( m_refCount >= 0 );

    if ( InterlockedDecrement(&m_refCount) < 0)
    {

        g_pDataPool->PrintStats();

        // cleanup statistic gathering
        DeleteNetStats();

        WSACleanup();

        if ( m_hClientLoginMutex )
        {
            CloseHandle( m_hClientLoginMutex );
            m_hClientLoginMutex = NULL;
        }

        if ( g_pFreeAPCPool )
        {
            delete g_pFreeAPCPool;
            g_pFreeAPCPool = NULL;
        }

        if ( g_pFreeConPool )
        {
            delete g_pFreeConPool;
            g_pFreeConPool = NULL;
        }

        delete g_pDataPool;
        g_pDataPool = NULL;


        m_bInit = FALSE;
    }
}



void ZNetwork::SetOptions( ZNETWORK_OPTIONS* opt )
{
    m_SocketBacklog           = opt->SocketBacklog;
    m_EnableTcpKeepAlives      = opt->EnableTcpKeepAlives;
    m_WaitForCompletionTimeout = opt->WaitForCompletionTimeout;
    m_RegWriteTimeout          = opt->RegWriteTimeout;
    m_DisableEncryption        = opt->DisableEncryption;
    m_MaxSendSize              = opt->MaxSendSize;
    m_MaxRecvSize              = opt->MaxRecvSize;
    m_KeepAliveInterval        = opt->KeepAliveInterval;
    m_PingInterval             = opt->PingInterval;
    m_ProductSignature         = opt->ProductSignature;
    m_ClientEncryption         = opt->ClientEncryption;
}

void ZNetwork::GetOptions( ZNETWORK_OPTIONS* opt )
{
    opt->SocketBacklog            = m_SocketBacklog;
    opt->EnableTcpKeepAlives      = m_EnableTcpKeepAlives;
    opt->WaitForCompletionTimeout = m_WaitForCompletionTimeout;
    opt->RegWriteTimeout          = m_RegWriteTimeout;
    opt->DisableEncryption        = m_DisableEncryption;
    opt->MaxSendSize              = m_MaxSendSize;
    opt->MaxRecvSize              = m_MaxRecvSize;
    opt->KeepAliveInterval        = m_KeepAliveInterval;
    opt->PingInterval             = m_PingInterval;
    opt->ProductSignature         = m_ProductSignature;
    opt->ClientEncryption         = m_ClientEncryption;
}




/*
    Open connection as a client to the the given host and port.
*/
ZNetCon* ZNetwork::CreateSecureClient(char* hostname, int32 *ports, ZSConnectionMessageFunc func,
                                void* conClass, void* userData,
                                char *User, char*Password, char*Domain,
                                int Flags)
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::CreateSecureClient: Entering\n") );

    if ( m_Exit )
    {
        return NULL;
    }

    ConInfo *con = NULL;
    DWORD addrLocal, addrRemote;
    SOCKET sock;
    if(0)  // need to make this some kind of setting
    {
        ZSecurity* security;
        security= ZCreateClientSecurity(User,Password,Domain,Flags);
        if (!security)
            return NULL;

        security->AddRef();

        sock = ConIOClient(ports,SOCK_STREAM,hostname,&addrLocal,&addrRemote);
        if (sock == INVALID_SOCKET ) 
        {
            security->Release();
            return NULL;
        }

        con = ConSecureClient::Create(this, sock, addrLocal, addrRemote, ConInfo::READ | ConInfo::WRITE| ConInfo::ESTABLISHED,
                                               func, conClass, userData, security);
        security->Release();
    }
    else
    {
        sock = ConIOClient(ports,SOCK_STREAM,hostname,&addrLocal,&addrRemote);
        if (sock == INVALID_SOCKET ) 
            return NULL;

        con = ConInfo::Create(this, sock, addrLocal, addrRemote, ConInfo::READ | ConInfo::WRITE| ConInfo::ESTABLISHED,
                                               func, conClass, userData);
    }

    if( con )
    {
        if ( IsCompletionPortEnabled() )
        {
            HANDLE hIO = CreateIoCompletionPort( (HANDLE)sock, m_hIO, (DWORD)con, 0 );
            ASSERT( hIO == m_hIO );
            if ( !hIO )
            {
                DebugPrint( "Error associating socket w/ completion port - %d\n", GetLastError() );
                con->Close();
                return NULL;
            }
        }


        con->AddRef( ConInfo::CONINFO_REF );

        if ( !AddConnection(con) )
        {
            con->Close();
            con->Release(ConInfo::CONINFO_REF);
            return NULL;
        }


        /* to use new security type, must send the request for the key */
        if ( !con->InitiateSecurityHandshake() )
        {
            con->Close();
            con->Release(ConInfo::CONINFO_REF);
            return NULL;
        }

        con->AddUserRef();  // b/c we're returning it to the user
        InterlockedIncrement(&m_ConInfoUserCount);

        //Initiate security protocol on connection
        //Have to put this here otherwise application will send its data first
        if ( 0 )
        {
            ZSecurityMsgReq msg;
            msg.protocolSignature = zProtocolSigSecurity;
            msg.protocolVersion = zSecurityCurrentProtocolVersion;
            con->Send( zSecurityMsgReq, &msg,sizeof(msg), zProtocolSigSecurity);
        }

        con->Release(ConInfo::CONINFO_REF);

    }

    return con;
}

ZNetCon* ZNetwork::CreateClient(char* hostname, int32 *ports, ZSConnectionMessageFunc func, void* conClass, void* userData)
{
    return CreateSecureClient(hostname, ports, func, conClass, userData,NULL,NULL,NULL);
}

void ZNetwork::CloseConnection(ZNetCon* connection)
{
    IF_DBGPRINT( DBG_ZSCONN, ("ZNetwork::CloseConnection: Entering\n") );

    ASSERT( connection );

    ConInfo* con= (ConInfo*) connection;
    if ( !con->IsDisabled() )
    {
        con->Close();
    }
}

void ZNetwork::DelayedCloseConnection(ZNetCon* connection, uint32 delay)
{
    IF_DBGPRINT( DBG_ZSCONN, ("ZNetwork::DelayedCloseConnection: Entering\n") );

    ASSERT( connection );

    ConInfo* con= (ConInfo*) connection;

    con->SetTimeout(delay);

    con->Disable();

}

void ZNetwork::DeleteConnection(ZNetCon* connection)
{
    IF_DBGPRINT( DBG_ZSCONN, ("ZNetwork::DeleteConnection: Entering\n") );

    ASSERT( connection );

    ConInfo* con= (ConInfo*) connection;
    ASSERT( con->IsClosing() || con->IsDisabled() );

    // if the socket we created by the user we have an extra ref count to release
    ASSERT(con->IsUserConnection());
    if ( con->IsUserConnection() )
    {
        InterlockedDecrement(&m_ConInfoUserCount);
        con->Release(ConInfo::USER_REF);
    }

}


void ZNetwork::AddRefConnection(ZNetCon* connection)
{
    ConInfo* con= (ConInfo*) connection;

    con->AddUserRef();
    InterlockedIncrement(&m_ConInfoUserCount);
}

void ZNetwork::ReleaseConnection(ZNetCon* connection)
{
    ConInfo* con= (ConInfo*) connection;

    // if the socket we created by the user we have an extra ref count to release
    ASSERT(con->IsUserConnection());
    if ( con->IsUserConnection() )
    {
        InterlockedDecrement(&m_ConInfoUserCount);
        con->Release(ConInfo::USER_REF);
    }
}


BOOL ZNetwork::QueueAPCResult( ZSConnectionAPCFunc func, void* data )
{
    CONAPC_OVERLAPPED* lpo;
    if ( g_pFreeAPCPool )
    {
        lpo = new (*g_pFreeAPCPool) CONAPC_OVERLAPPED;
    }
    else
    {
        lpo = new CONAPC_OVERLAPPED;
    }

    ASSERT(lpo);
    ASSERT(func);
    ZeroMemory(lpo, sizeof(OVERLAPPED) );
    lpo->flags = CONINFO_OVERLAP_APC;
    lpo->func = func;
    lpo->data = data;

    // Fake a coninfo here and
    // increment before queueing since
    // we use this variable for a terminate condition
    InterlockedIncrement(&m_ConInfoCount);

    if ( IsCompletionPortEnabled() )
    {

        if ( PostQueuedCompletionStatus( m_hIO, 0, 0, (LPOVERLAPPED)lpo ) )
        {
            LockNetStats();
            g_NetStats.TotalUserAPCs.QuadPart++;
            UnlockNetStats();
            return TRUE;
        }
        else
        {
            InterlockedDecrement(&m_ConInfoCount);
            delete lpo;
            return FALSE;
        }
    }
    else
    {
        // TODO cache events
        lpo->o.hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );  // set the event
        return QueueCompletionEvent( lpo->o.hEvent, NULL, lpo );
    }

}


BOOL ZNetwork::QueueCompletionEvent( HANDLE hEvent, ZNetCon* con, CONINFO_OVERLAPPED* lpo )
{
#if TRACK_IO
    char log[256];
    DWORD written;
    wsprintf( log, "event queued: 0x%x\n", hEvent );
    ASSERT( WriteFile( hLogFile, log, lstrlen(log), &written, NULL ) );
#endif

    BOOL bRet = FALSE;
    EnterCriticalSection( m_pcsCompletionQueue );

    ASSERT( m_nCompletionEvents < MAXIMUM_WAIT_OBJECTS );

    if ( m_nCompletionEvents < MAXIMUM_WAIT_OBJECTS )
    {
        m_hCompletionEvents[m_nCompletionEvents] = hEvent;
        m_CompletionQueue[m_nCompletionEvents].con = con;
        m_CompletionQueue[m_nCompletionEvents].lpo = lpo;
        m_nCompletionEvents++;
        SetEvent( m_hWakeUpEvent );
        bRet = TRUE;
    }

    LeaveCriticalSection( m_pcsCompletionQueue );
    return bRet;
}

/* Call this function to enter an infinite loop waiting for connections */
/* and data */
void ZNetwork::Wait( ZSConnectionMsgWaitFunc func /* = NULL */ , void* data /* = NULL */, DWORD dwWakeMask /*= QS_ALLINPUT*/ )
{

    //DebugPrint("ZNetwork::Wait: Entering\n");

    if ( func )
    {
        ASSERT( !m_bEnableCompletionPort );
        (*func)(data);
    }

    m_Exit = FALSE;

    m_LastTick = GetTickCount();
    DWORD last_timeout = m_LastTick;
    DWORD last_keepalive = m_LastTick;

    EnterCriticalSection( m_pcsGetQueueCompletion );

    DWORD tickExecute = GetTickCount();

    while ( !m_Exit || (m_ConInfoCount > m_ConInfoUserCount) )
    {
        DWORD cbTrans = 0;
        ConInfo* con = NULL;
        DWORD dwError = NO_ERROR;
        CONINFO_OVERLAPPED* lpo = NULL;

        //
        // Wait here for a overlapped completion or timeout
        //

        //DebugPrint( "Blocking on GetQueuedCompletionStatus - %d\n", GetTickCount() );
        LeaveCriticalSection( m_pcsGetQueueCompletion );

        if ( g_EnableTickStats )
        {
            LockNetStats();
            g_NetStats.TotalTicksExecuting.QuadPart += ConInfo::GetTickDelta(GetTickCount(), tickExecute);
            UnlockNetStats();
        }

        BOOL bRet = FALSE;
        if ( IsCompletionPortEnabled() )
        {
            bRet = GetQueuedCompletionStatus( m_hIO, &cbTrans, (DWORD*)&con, (LPOVERLAPPED*)&lpo, m_WaitForCompletionTimeout );
        }
        else
        {

/*
            for ( int ndx = 0; ndx < m_nCompletionEvents; ndx++ )
            {
                //ASSERT( m_hCompletionEvents[ndx] );
                DebugPrint( "%d ", m_hCompletionEvents[ndx]);
            }
            DebugPrint( "\n" );
*/

            DWORD dwWait;
            if ( func )
            {
//                (*func)(data);
                dwWait = MsgWaitForMultipleObjects(m_nCompletionEvents, m_hCompletionEvents, FALSE, m_WaitForCompletionTimeout, dwWakeMask );
            }
            else
            {
                dwWait = WaitForMultipleObjects(m_nCompletionEvents, m_hCompletionEvents, FALSE, m_WaitForCompletionTimeout );
            }

            switch( dwWait )
            {
                case WAIT_FAILED:
                    break;
                case WAIT_OBJECT_0:  // generic event to wake up
                    ResetEvent( m_hWakeUpEvent );
                    // fall thru
                case WAIT_TIMEOUT:
                    if ( func )
                    {
                        (*func)(data);  // do this just incase MsgWait is flaky
                    }
                    SetLastError( WAIT_TIMEOUT );
                    break;
                case WAIT_OBJECT_0+1:  // terminate event
                    ResetEvent( m_hTerminateEvent );
                    bRet = TRUE;
                    break;
                default:
					
                    if ( dwWait == WAIT_OBJECT_0 + m_nCompletionEvents )
                    {
                        if ( func )
						{
                            (*func)(data);
                        }

                        SetLastError( WAIT_TIMEOUT );
                    }
                    else
                    {
						bRet = TRUE;

                        ASSERT( (dwWait-WAIT_OBJECT_0) <= m_nCompletionEvents );

#if TRACK_IO
                        char log[256];
                        DWORD written;
                        wsprintf( log, "event signaled: 0x%x\n", m_hCompletionEvents[dwWait-WAIT_OBJECT_0] );
                        ASSERT( WriteFile( hLogFile, log, lstrlen(log), &written, NULL ) );
#endif

                        con = (ConInfo*) m_CompletionQueue[dwWait-WAIT_OBJECT_0].con;
                        lpo = m_CompletionQueue[dwWait-WAIT_OBJECT_0].lpo;
                        if ( con && lpo && (lpo->flags & CONINFO_OVERLAP_ENABLED) )
                        {
                            bRet = GetOverlappedResult( (HANDLE)con->GetSocket(), (LPOVERLAPPED)lpo, &cbTrans, TRUE );
                        }

                        EnterCriticalSection( m_pcsCompletionQueue );

                        if ( lpo && ( (lpo->flags & CONINFO_OVERLAP_TYPE_MASK) == CONINFO_OVERLAP_APC ) )
                        {
                            CloseHandle( m_hCompletionEvents[dwWait-WAIT_OBJECT_0] );
                            m_hCompletionEvents[dwWait-WAIT_OBJECT_0] = 0;
                            CONAPC_OVERLAPPED* lpco = (CONAPC_OVERLAPPED*)lpo;
                            lpco->o.hEvent = NULL;
                        }

                        {
                            for ( DWORD ndx = dwWait-WAIT_OBJECT_0+1; ndx < m_nCompletionEvents; ndx++ )
                            {
                                m_hCompletionEvents[ndx-1] = m_hCompletionEvents[ndx];
                                m_CompletionQueue[ndx-1].con = m_CompletionQueue[ndx].con;
                                m_CompletionQueue[ndx-1].lpo = m_CompletionQueue[ndx].lpo;
                            }
                            m_nCompletionEvents--;

                            m_hCompletionEvents[m_nCompletionEvents] = NULL;
                            m_CompletionQueue[m_nCompletionEvents].con = NULL;
                            m_CompletionQueue[m_nCompletionEvents].lpo = NULL;

                        }
                        LeaveCriticalSection( m_pcsCompletionQueue );
                    }
                    break;

            }
        }
        tickExecute = GetTickCount();  // start before entering to capture any other execution time

        EnterCriticalSection( m_pcsGetQueueCompletion );
        //DebugPrint( "Returned from GetQueuedCompletionStatus - %d\n", GetTickCount() );

        if ( !bRet )
        {
            dwError = GetLastError();
        }
        else if ( !con )  // user queued APC
        {
            DWORD tickAPC = GetTickCount();

            if ( lpo )
            {
                InterlockedDecrement(&m_ConInfoCount);
                LockNetStats();
                g_NetStats.TotalUserAPCsCompleted.QuadPart++;
                UnlockNetStats();

                CONAPC_OVERLAPPED* lpco = (CONAPC_OVERLAPPED*)lpo;
                lpco->func( lpco->data );
                ASSERT( !lpco->o.hEvent );
                delete lpco;

            }
            else // our condition to terminate
            {                
                ASSERT( !cbTrans );
                TerminateAllConnections();
            }

            if ( g_EnableTickStats )
            {
                LockNetStats();
                g_NetStats.TotalTicksAPC.QuadPart += ConInfo::GetTickDelta(GetTickCount(), tickAPC);
                UnlockNetStats();
            }

            continue;
        }

    
        DWORD tickConInfo = GetTickCount();
        if ( lpo )
        {
            ASSERT(con);
            if ( con )
            {
                switch( lpo->flags & CONINFO_OVERLAP_TYPE_MASK )
                {
                    case CONINFO_OVERLAP_ACCEPT:
                        ASSERT(cbTrans==0);
                        {
                            // keep from accepting new connections if we're exiting or have too many sessions
                            if( m_Exit )
                                dwError = ERROR_SHUTDOWN_IN_PROGRESS;

                            ConInfo* conNew = con->AcceptComplete( (WORD)(lpo->flags & CONINFO_OVERLAP_ACCEPT_MASK),dwError );
                            if ( conNew )
                            {
                                if ( !AddConnection(conNew) )
                                {
                                    conNew->Close();
                                }
                            }
                        }
                        if ( g_EnableTickStats )
                        {
                            LockNetStats();
                            g_NetStats.TotalTicksAccept.QuadPart += ConInfo::GetTickDelta(GetTickCount(), tickConInfo);
                            UnlockNetStats();
                        }
                        break;

                    case CONINFO_OVERLAP_READ:
                        con->ReadComplete(cbTrans, dwError);
                        if ( g_EnableTickStats )
                        {
                            LockNetStats();
                            g_NetStats.TotalTicksRead.QuadPart += ConInfo::GetTickDelta(GetTickCount(), tickConInfo);
                            UnlockNetStats();
                        }
                        break;

                    case CONINFO_OVERLAP_WRITE:
                        con->WriteComplete(cbTrans, dwError);
                        if ( g_EnableTickStats )
                        {
                            LockNetStats();
                            g_NetStats.TotalTicksWrite.QuadPart += ConInfo::GetTickDelta(GetTickCount(), tickConInfo);
                            UnlockNetStats();
                        }
                        break;

                    default:
                        ASSERT( !"CONINFO_OVERLAPPED with unknown type" );
                        break;
                }

            }
        }
        else if ( dwError != WAIT_TIMEOUT )  
        {   // critical failure - what to do?
            DebugPrint("*** GetQueuedCompletionStatus failed %d.\n", dwError );
        }
        
        m_LastTick = GetTickCount();
        DWORD tickTimeout = m_LastTick;

        DWORD elapsed = ConInfo::GetTickDelta( tickTimeout, last_timeout );
        if ( ( elapsed > m_WaitForCompletionTimeout ) || dwError == WAIT_TIMEOUT )
        {
            last_timeout = tickTimeout;
            m_TimeoutList.ForEach(TimeoutCallback, (void*)elapsed);
        }

        DWORD tickKeepAlive = GetTickCount();
        if ( g_EnableTickStats )
        {
            LockNetStats();
            g_NetStats.TotalTicksTimeouts.QuadPart += ConInfo::GetTickDelta(tickKeepAlive, tickTimeout);
            UnlockNetStats();
        }

        if ( m_KeepAliveInterval != INFINITE )
        {
            elapsed = ConInfo::GetTickDelta( tickKeepAlive, last_keepalive );
            if ( elapsed > ( m_KeepAliveInterval >> 1 ) )
            {
                m_Connections.ForEach(KeepAliveCallback, NULL);
                last_keepalive = tickKeepAlive;
            }
        }


        DWORD tickPoolCleanup = GetTickCount();
        if ( g_EnableTickStats )
        {
            LockNetStats();
            g_NetStats.TotalTicksKeepAlives.QuadPart += ConInfo::GetTickDelta(tickPoolCleanup, tickKeepAlive);
            UnlockNetStats();
        }

        static BOOL bShrink = TRUE;
        DWORD acceptCount = m_ConInfoCount - m_ConInfoUserCount;
        if ( acceptCount > g_PoolCleanupHighTrigger )
        {
            bShrink = TRUE;
        }
        if ( bShrink && acceptCount <= g_PoolCleanupLowTrigger )
        {
            bShrink = FALSE;
            g_pDataPool->Shrink();

            if ( g_pFreeConPool )
                g_pFreeConPool->Shrink();

            if ( g_pFreeAPCPool )
                g_pFreeAPCPool->Shrink();

            SetProcessWorkingSetSize( GetCurrentProcess(), (DWORD)-1, (DWORD)-1 );
        }

    }

    LeaveCriticalSection( m_pcsGetQueueCompletion );
}


void ZNetwork::Exit()
{

    if ( !InterlockedExchange((long*)&m_Exit, TRUE ) )
    {
        // post our condition to exit
        if ( IsCompletionPortEnabled() )
        {
            PostQueuedCompletionStatus( m_hIO, 0, 0, NULL );
        }
        else
        {
            SetEvent( m_hTerminateEvent );
        }
    }
}


struct ClassEnumStruct
{
    void* conClass;
    void* data;
    ZSConnectionEnumFunc func;
};

static bool ClassEnumCallback( ZNetCon* connection, MTListNodeHandle h, void* Cookie )
{
    ConInfo* con = (ConInfo*)connection;
    ASSERT(con);

    if ( !con->IsDisabled() && con->IsReadWriteConnection() )
    {
        ClassEnumStruct* ces = (ClassEnumStruct*)Cookie;

        if (ces->conClass == con->GetClass() ) 
        {
            ces->func( (ZSConnection)con, ces->data );
        }
    }

    return TRUE;
}

/* enumerate all connections of a particular conClass */
ZError ZNetwork::ClassEnumerate(void* conClass, ZSConnectionEnumFunc func, void* data)
{

    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::ClassEnumerate: Entering ...\n") );

    ClassEnumStruct ces = { conClass, data, func };

    m_Connections.ForEach( ClassEnumCallback, &ces );

    return zErrNone;
}


struct SendDataStruct
{
    int32 type;
    void* buffer;
    int32 len;
    uint32 dwSignature;
    uint32 dwChannel;
};

static void SendToClassFunc( ZSConnection connection, void* data )
{
    ASSERT(connection);
    ConInfo* con = (ConInfo*) connection;
    SendDataStruct* sds = (SendDataStruct*)data;

    con->Send( sds->type, sds->buffer, sds->len, sds->dwSignature, sds->dwChannel );
}

/* send to all connections of a particular conClass.  can be used to broadcast */
ZError ZNetwork::SendToClass(void* conClass, int32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel /* = 0 */)
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::SendToClass: Entering ...\n") );

    SendDataStruct sds = { type, buffer, len, dwSignature, dwChannel };

    ZError err = ClassEnumerate( conClass, SendToClassFunc, &sds);


    return err;
}





BOOL ZNetwork::AddConnection(ZNetCon *connection)
{
    ConInfo* con = (ConInfo*)connection;
    ASSERT(con);

    ASSERT( con->m_list == NULL );
    con->AddRef(ConInfo::LIST_REF);
    con->m_list = m_Connections.AddTail( con );

//    VERIFY( InterlockedIncrement( &(long)m_ConnectionCount ) );

    // initially add to the timeout list - clients will have an accept timeout list
    // others will have a timeout of INFINITE and be removed from the list
    // after the first iteration
    ASSERT( con->m_listTimeout == NULL );
    con->AddRef(ConInfo::TIMEOUT_REF);
    con->m_listTimeout = m_TimeoutList.AddTail( con );

    return TRUE;
}

BOOL ZNetwork::RemoveConnection(ZNetCon* connection)
{
    ConInfo* con = (ConInfo*)connection;
    ASSERT(con);

    if ( con->m_listTimeout )
    {
        m_TimeoutList.MarkNodeDeleted(con->m_listTimeout);
        con->m_listTimeout = NULL;
        con->Release(ConInfo::TIMEOUT_REF);
    }

    if ( con->m_list )
    {
        m_Connections.MarkNodeDeleted(con->m_list);

        con->m_list = NULL;
        con->Release(ConInfo::LIST_REF);

        return TRUE;
    }
    else
    {
        return FALSE;
    }

}


static bool TerminateCallback( ZNetCon* connection, MTListNodeHandle h, void* Cookie )
{
    ConInfo* con = (ConInfo*)connection;
    ASSERT(con);

    con->Close();

    return TRUE;
}

void ZNetwork::TerminateAllConnections(void)
{
    
    m_Connections.ForEach( TerminateCallback, NULL );

}


static bool KeepAliveCallback( ZNetCon* connection, MTListNodeHandle h, void* )
{
    ConInfo* con = (ConInfo*)connection;
    ASSERT(con);
    con->KeepAlive();
    return TRUE;
}




/////////////////////////////////////////////////////////////////////////
//
//  Network Connection Implementation
/////////////////////////////////////////////////////////////////////////

DWORD  ZNetCon::Send(uint32 messageType, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel)
{
    if (  ((ConInfo*)this)->FilterAndQueueSendData( messageType, (char*)buffer, len, dwSignature, dwChannel ) )
    {
        return zErrNone;
    }
    else
    {
        return zErrNetworkGeneric;
    }
}

void*  ZNetCon::Receive(uint32 *messageType, int32* len, uint32 *pdwSignature, uint32 *pdwChannel /* = NULL */)
{
    return ((ConInfo*)this)->ConInfo::GetReceivedData( messageType, len, pdwSignature, pdwChannel );
}

BOOL   ZNetCon::IsDisabled()
{
    return ((ConInfo*)this)->ConInfo::IsDisabled();
}

BOOL   ZNetCon::IsServer()
{
    return ((ConInfo*)this)->ConInfo::IsServerConnection();
}

BOOL   ZNetCon::IsClosing()
{
    return ((ConInfo*)this)->ConInfo::IsClosing();
}

void ZNetCon::SetTimeout(DWORD timeout)
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetwork::SetTimeout: Entering\n") );

    ConInfo* con = (ConInfo*)this;
    if ( !con->IsDisabled() && !con->IsClosing() )
    {
        con->SetTimeoutTicks(timeout);
        if ( !con->m_listTimeout )
        {
            ASSERT( con->m_list ); // sanity check
            con->AddRef(ConInfo::TIMEOUT_REF);
            // add to the head so we don't re-encounter ourselves in a ForEach
            con->m_listTimeout = con->GetNetwork()->m_TimeoutList.AddHead( con );
        }
    }
}

void ZNetCon::ClearTimeout()
{
    IF_DBGPRINT( DBG_CONINFO, ("ZNetCon::ClearTimeout: Entering\n") );

    ConInfo* con = (ConInfo*)this;
    if ( !con->IsDisabled() )
    {
        con->SetTimeoutTicks(INFINITE);
    }
}

DWORD ZNetCon::GetTimeoutRemaining()
{
    ConInfo* con = (ConInfo*)this;

    DWORD ticks = con->GetRemainingTimeout();
    if ( ticks == INFINITE )
    {
        return zSConnectionNoTimeout;
    }
    else
    {
        DWORD elapsed = ConInfo::GetTickDelta( GetTickCount(), GetNetwork()->m_LastTick );

        if ( ticks < elapsed )
        {
            return 0;
        }
        else
        {
            return (ticks-elapsed) / 1000;
        }
    }
    return (zSConnectionNoTimeout);
}



static bool TimeoutCallback( ZNetCon* connection, MTListNodeHandle h, void* elapsed )
{
    USES_CONVERSION;
    ASSERT(connection);
    ConInfo* con = (ConInfo*) connection;
    if ( con->GetRemainingTimeout() == INFINITE )
    {
        if ( con->m_listTimeout )
        {
            con->GetNetwork()->m_TimeoutList.MarkNodeDeleted(con->m_listTimeout);
            con->m_listTimeout = NULL;
            con->Release(ConInfo::TIMEOUT_REF);
        }
    }
    else if ( con->IsTimedOut( (DWORD) elapsed ) )
    {

        if ( con->IsDisabled() )
        {
            if ( g_LogServerDisconnects )
            {
                TCHAR szBuf1[128];
                TCHAR szBuf2[128];
                lstrcpy( szBuf1, A2T(con->GetRemoteName() ));
                lstrcpy( szBuf2, TEXT(" was closed because of a coninfo timeout" ));
                LPTSTR ppStr[] = { szBuf1, szBuf2 };
                ZoneEventLogReport( ZONE_S_CLOSED_SOCKET_LOG, 2, ppStr, 0, NULL );
            }
            con->Close();
        }
        else if ( con->IsEstablishedConnection() )
        {   // timeout occured, send message and reset timeout

            con->SendMessage(zSConnectionTimeout);
            con->ResetTimeout();
        }
        else  // we never received any data on the socket - time it out
        {
            con->Close();
        }
    }

    return TRUE;
}



char* ZNetwork::AddressToStr(uint32 addr)
{
    ZEnd32(&addr);
    in_addr a;
    a.s_addr = addr;
    return inet_ntoa(a);
}

uint32 ZNetwork::AddressFromStr( char* pszAddr )
{
    uint32 addr = inet_addr( pszAddr );
    ZEnd32(&addr);
    return addr;
}

////////////////////////////////////////////////////////////////////
// Local Rountines
////////////////////////////////////////////////////////////////////

/*
*  ports = zero-terminated list of ports to try
*  type = SOCK_STREAM or SOCK_DGRAM.
*  host = hostname to connect to.  If NULL host assumed to be INADDR_ANY.  can be a comma list.
*/
SOCKET ZNetwork::ConIOClient(int32 *ports,int type,char *host, DWORD* paddrLocal, DWORD* paddrRemote)
{
    IF_DBGPRINT( DBG_CONINFO, ("ConIOClient: Entering ...\n") );
    IF_DBGPRINT( DBG_CONINFO, ("  Binding to host %s  port %d\n", ((host) ? host : "local host"), ports[0]) );

    struct sockaddr_in saddr;
    saddr.sin_family=AF_INET;
    saddr.sin_addr.s_addr=INADDR_ANY;

    struct hostent* he = NULL;

    DWORD addr = INADDR_NONE;
    char*  ppAddrs[2] = { (char*)&addr, 0 };
    char**  ppAddr = ppAddrs;

    DWORD heLen = sizeof( addr );

    SOCKET sock = INVALID_SOCKET;
    char *thishost = host;

    while(true)
    {
        char *pEnd;

        if(thishost)
        {
            // mark the end
            for(pEnd = thishost; *pEnd && *pEnd != ','; pEnd++);
                if(!*pEnd)
                    pEnd = NULL;
                else
                    *pEnd = '\0';

            // first see if we have a IP4 address
            addr = inet_addr(thishost);

            if(addr == INADDR_NONE)
            {
                // must be a hostname
                he = gethostbyname(thishost);
                if(he == NULL)  // bad name - abort
                {
                    IF_DBGPRINT(DBG_CONINFO, ("ConIOClient: Exiting(1).\n"));
                    return INVALID_SOCKET;
                }

                saddr.sin_family = he->h_addrtype;
                ppAddr = he->h_addr_list;
                heLen = he->h_length;
            }
        }

        while ( *ppAddr && (sock == INVALID_SOCKET) )
        {
            CopyMemory( (char*)&saddr.sin_addr, *ppAddr, heLen );
            ppAddr++;

            int port_index;
            for(port_index = 0; ports[port_index]; port_index++)
            {
                saddr.sin_port=htons((uint16)ports[port_index]);
                sock = socket(saddr.sin_family,type,0);
                if( sock == INVALID_SOCKET )
                {
                    continue;
                }

                if ( !ConIOSetClientSockOpt(sock) )
                {
                    closesocket(sock);
                    sock = INVALID_SOCKET;
                    continue;
                }

                if(connect(sock,(struct sockaddr*)&saddr, sizeof(saddr)) == SOCKET_ERROR )
                {
                    closesocket(sock);
                    sock = INVALID_SOCKET;
                    continue;
                }

                if(sock != INVALID_SOCKET)
                    break;
            }
        }

        if(!thishost || !pEnd)
            break;

        thishost = pEnd + 1;
        *pEnd = ',';
    }

    if ( sock != INVALID_SOCKET )
    {
        *paddrRemote = saddr.sin_addr.s_addr;
        ZEnd32(paddrRemote);

        int    namelen = sizeof(saddr);
        ZeroMemory( &saddr, sizeof(saddr) );

        if ( SOCKET_ERROR != getsockname( sock, (LPSOCKADDR)&saddr, &namelen ) )
        {
            *paddrLocal = saddr.sin_addr.s_addr;
            ZEnd32(paddrLocal);
        }
        else
        {
            *paddrLocal = INADDR_ANY;
        }
    }

    IF_DBGPRINT( DBG_CONINFO, ("ConIOClient: Exiting(0).\n") );

    return(sock);
}


BOOL ZNetwork::ConIOSetClientSockOpt(SOCKET sock)
{
    int optval;
    static struct linger arg = {1, 0};


    /*
        Turn lingering off so that all sockets are closed immediately.
    */
    if (setsockopt(sock, SOL_SOCKET, SO_LINGER, (char*)&arg,
          sizeof(struct linger)) < 0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOClient: Exiting(4).\n") );
        return FALSE;
    }

    /*
        Set the socket option to keep the connection alive. It sends
        periodic messages to the peer and determines that the connection
        is broken if no replies are received. It sends a SIGPIPE signal
        if an attempt to write is made.

        KEEPALIVE does not work if the remote host does not support it and
        unnecessarily causes clients to be disconnected.
    */
    optval = m_EnableTcpKeepAlives;
    if(setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, (char*) &optval, sizeof(optval)) < 0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(4).\n") );
        return  FALSE;
    }

#if 0
    /*
        TCP_NODELAY is used to disable what's called Nagle's Algorithm in the
        TCP transmission. Nagle's Algorithm is used to reduce the number of
        tiny packets transmitted by collecting a bunch of them into one
        segment -- mainly used for telnet sessions. This algorithm may also
        cause undue delays in transmission.

        Hence, we set this option in order to avoid unnecessary delays.
    */
    optval = 1;
    if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(int)) < 0)
    {
        IF_DBGPRINT( DBG_CONINFO, ("ConIOSetSockOpt: Exiting(5).\n") );
        return FALSE;
    }
#endif

    return TRUE;
}


HWND FindLoginDialog()
{
    HWND dlg = FindWindow( TEXT("#32770"), TEXT("Sign In") );
    if ( dlg )
    {
        TCHAR szRealm[32];
        if ( GetDlgItemText( dlg, 0x7A, szRealm, sizeof(szRealm) ) )  // get static text for Realm
        {
            szRealm[4] = '\0';
            if ( lstrcmp( szRealm, TEXT("Zone") ) == 0 )
            {
                return dlg;
            }
        }
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zservcon.cpp ===
/*******************************************************************************

    ZNetwork.cpp
    
        ZSConnection object methods.

    Notes:
    1. When the server receives a message, it sends a message available message
    to the owner. The owner must retrieve the message immediately; otherwise,
    the message is lost.
    
    Copyright  Electric Gravity, Inc. 1994. All rights reserved.
    Written by Kevin Binkley, Hoon Im
    Created on Saturday, November 12, 1994 03:51:47 PM
    
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    35      11/14/96  craigli   Added ZSConnectionQueueAPCResult
    34      10/22/96  craigli   Fixed  endianing of the ip addresses
    33      10/22/96    HI      Disabled endianing of the ip addresses in
                                ZSConnectionGetHostAddress().
    32      10/7/96   craigli   gutted
     
*******************************************************************************/


/*
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/types.h>
#include <time.h>
#include <sys/timeb.h>
#include <io.h>
#include <string.h>
#include <memory.h>
*/

#include <windows.h>
#include <winsock.h>
//#include <aclapi.h>

#include "zone.h"
#include "zservcon.h"
#include "zonedebug.h"
#include "zsecurity.h"
#include "zconnint.h"
#include "netstats.h"
#include "eventlog.h"
#include "zonemsg.h"

//#include "network.h"
#include "coninfo.h"
#include "zsecobj.h"
#include "consspi.h"
#include "consecureclient.h"





extern DWORD  g_LogServerDisconnects;
extern DWORD  g_PoolCleanupHighTrigger;
extern DWORD  g_PoolCleanupLowTrigger;





////////////////////////////////////////////////////////////////////////////////
//
//  ZSConnection ...

ZNetwork* g_pNet = NULL;

/* performs one time initialization */
ZError ZSConnectionLibraryInitClientOnly()
{
    return ZSConnectionLibraryInitClientOnly(FALSE);
}

ZError ZSConnectionLibraryInitClientOnly(BOOL bEnablePools)
{
    ZError err = ZNetwork::InitLibraryClientOnly(bEnablePools);

    if ( err == zErrNone )
    {
        ASSERT( !g_pNet );
        g_pNet = new ZNetwork;
        g_pNet->InitInst();
    }

    return err;
}

/* closes all connections, cleans up all resources */
void ZSConnectionLibraryCleanUp()
{
    if ( g_pNet )
    {
        g_pNet->CleanUpInst();
        delete g_pNet;
        g_pNet = NULL;
    }

    ZNetwork::CleanUpLibrary();
}

void ZSConnectionLibrarySetOptions( ZNETWORK_OPTIONS* opt )
{
    ASSERT( g_pNet );
    g_pNet->SetOptions( opt );
}

void ZSConnectionLibraryGetOptions( ZNETWORK_OPTIONS* opt )
{
    ASSERT( g_pNet );
    g_pNet->GetOptions( opt );
}

void ZSConnectionLibraryEnterCS()
{
    ASSERT( g_pNet );
    g_pNet->EnterCS();
}
void ZSConnectionLibraryLeaveCS()
{
    ASSERT( g_pNet );
    g_pNet->LeaveCS();
}





ZSConnection ZSConnectionOpenSecure(char* hostname, int32 *ports, ZSConnectionMessageFunc func,
                                    void* conClass, void* userData,
                                    char *User,char*Password,char*Domain,
                                    int Flags)
{
    return g_pNet->CreateSecureClient( hostname, ports, func,
                                     conClass, userData,
                                     User, Password, Domain,Flags);
}

ZSConnection ZSConnectionOpen(char* hostname, int32 *ports, ZSConnectionMessageFunc func, void* conClass, void* userData)
{
    return g_pNet->CreateClient( hostname, ports, func,
                                 conClass, userData );
}

void ZSConnectionClose(ZSConnection connection)
{
    g_pNet->CloseConnection( (ZNetCon*) connection );
}

void ZSConnectionDelayedClose(ZSConnection connection, uint32 delay)
{
    g_pNet->DelayedCloseConnection( (ZNetCon*) connection, delay);
}

void ZSConnectionDelete(ZSConnection connection)
{
    g_pNet->DeleteConnection( (ZNetCon*) connection );
}


void  ZSConnectionSetParentHWND(HWND hwnd)
{
    g_pNet->SetParentHWND(hwnd);
}

void ZSConnectionSuspend(ZSConnection connection )
{
    ASSERT( connection );

    ZNetCon* con= (ZNetCon*) connection;
    con->Suspend();
}
void ZSConnectionResume(ZSConnection connection )
{
    ASSERT( connection );

    ZNetCon* con= (ZNetCon*) connection;
    con->Resume();
}


BOOL ZSConnectionIsDisabled(ZSConnection connection)
{
    ZNetCon* con= (ZNetCon*) connection;
    return con->IsDisabled();
}

BOOL ZSConnectionIsServer(ZSConnection connection)
{
    ZNetCon* con= (ZNetCon*) connection;
    return con->IsServer();
}


void ZSConnectionAddRef(ZSConnection connection)
{
    ZNetCon* con= (ZNetCon*) connection;
    g_pNet->AddRefConnection(con);
}

void ZSConnectionRelease(ZSConnection connection)
{
    ZNetCon* con= (ZNetCon*) connection;
    g_pNet->ReleaseConnection(con);
}


ZError ZSConnectionSetTimeout(ZSConnection connection, uint32 timeout)
{
    ZNetCon* con = (ZNetCon*)connection;
    con->SetTimeout(timeout);
    return zErrNone;
}

void ZSConnectionClearTimeout(ZSConnection connection)
{
    ZNetCon* con = (ZNetCon*)connection;
    con->ClearTimeout();
}

uint32 ZSConnectionGetTimeoutRemaining(ZSConnection connection)
{
    ZNetCon* con = (ZNetCon*)connection;
    return con->GetTimeoutRemaining();
}


BOOL ZSConnectionQueueAPCResult( ZSConnectionAPCFunc func, void* data )
{
    return g_pNet->QueueAPCResult( func, data );
}



void ZSConnectionWait()
{
    g_pNet->Wait();
}


void ZSConnectionExit(ZBool immediate)
{
    g_pNet->Exit();
}



/* enumerate all connections of a particular conClass */
ZError ZSConnectionClassEnumerate(void* conClass, ZSConnectionEnumFunc func, void* data)
{
    return g_pNet->ClassEnumerate( conClass, func, data );
}


/* send to all connections of a particular conClass.  can be used to broadcast */
ZError ZSConnectionSendToClass(void* conClass, int32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel /* = 0 */)
{
    return g_pNet->SendToClass( conClass, type, buffer, len, dwSignature, dwChannel );
}





////////////////////////////////////////////////////////////////////////






void ZSConnectionSetSendFilter(ZSConnection connection, ZSConnectionSendFilterFunc filter)
{
    ASSERT(connection);
    ((ZNetCon*)connection)->SetSendFilter( filter );
}

ZSConnectionSendFilterFunc ZSConnectionGetSendFilter(ZSConnection connection)
{
    ASSERT(connection);
    return ((ZNetCon*)connection)->GetSendFilter();
}

ZError ZSConnectionSend(ZSConnection connection, uint32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel /* = 0 */)
{
    //ASSERT(connection);  // since the caller doesn't check the value before
                           // before calling, we can not assert this...

    ZNetCon* con = (ZNetCon*)connection;
    if (  con )
    {
        return con->Send(type, buffer, len, dwSignature, dwChannel);
    }
    else
    {
        return zErrNetworkGeneric;
    }
}

void* ZSConnectionReceive(ZSConnection connection, uint32 *type, int32 *len, uint32 *pdwSignature, uint32 *pdwChannel)
{
    return ((ZNetCon*)connection)->Receive( type, len, pdwSignature, pdwChannel );
}




void ZSConnectionSetUserData(ZSConnection connection, void* userdata)
{
    ((ZNetCon*)connection)->SetUserData( userdata );
}

void* ZSConnectionGetUserData(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetUserData();
}

void ZSConnectionSetClass(ZSConnection connection, void* conClass)
{
    ((ZNetCon*)connection)->SetClass( conClass );
}

void* ZSConnectionGetClass(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetClass();
}


uint32 ZSConnectionGetLatency(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetLatency();
}

uint32 ZSConnectionGetAcceptTick(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetAcceptTick();
}


BOOL ZSConnectionHasToken(ZSConnection connection, char* token)
{
    return ((ZNetCon*)connection)->HasToken(token);
};


GUID* ZSConnectionGetUserGUID(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetUserGUID();
}

BOOL ZSConnectionGetUserName(ZSConnection connection, char* name)
{
    return ((ZNetCon*)connection)->GetUserName(name);
}

BOOL ZSConnectionSetUserName(ZSConnection connection, char* name)
{
    return ((ZNetCon*)connection)->SetUserName(name);
}

DWORD ZSConnectionGetUserId(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetUserId();
}


BOOL ZSConnectionGetContextStr(ZSConnection connection, char* buf, DWORD len)
{
    return ((ZNetCon*)connection)->GetContextString(buf, len);
}

int  ZSConnectionGetAccessError(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetAccessError();
}


char* ZSConnectionGetLocalName(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetLocalName();
}

uint32 ZSConnectionGetLocalAddress(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetLocalAddress();
}


char* ZSConnectionGetRemoteName(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetRemoteName();
}

uint32 ZSConnectionGetRemoteAddress(ZSConnection connection)
{
    return ((ZNetCon*)connection)->GetRemoteAddress();
}


uint32 ZSConnectionGetHostAddress()
{
    uint32 addr;
    struct hostent *h;
    struct sockaddr_in addrin;
    char name[128];


    gethostname(name, sizeof(name)-1);
    h=gethostbyname(name);
    memcpy((char*)&addrin.sin_addr, h->h_addr, h->h_length);
    addr = (uint32) addrin.sin_addr.s_addr;
    ZEnd32(&addr);
    return (addr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zsecurity.c ===
/*******************************************************************************

	ZSecurity.c
	
		Security routines.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Kevin Binkley
	Created on 04-22-96
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	1		03/17/97	HI		Added ZUnloadSSPS().
	0		04/22/96	KJB		Created.
	 
*******************************************************************************/

#include "zone.h"
#include "zsecurity.h"


/* -------- Globals -------- */


/* -------- Internal Routines -------- */


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

#define zChecksumStart 0x12344321
uint32 ZSecurityGenerateChecksum(uint16 numDataBuffers, char *data[], uint32 len[])
{
	uint32 i,j;
	uint32 checksum = zChecksumStart;

	ZEnd32(&checksum);
	for (j = 0; j < numDataBuffers; j++) {
        uint32 dwordLen = len[j]>>2;
		uint32* dwordPointer = (uint32*)(data[j]);
		for (i = 0;i < dwordLen; i++) {
			checksum ^= *dwordPointer++;
		}
	}
	ZEnd32(&checksum);

	return checksum;
}

#define zSecurityDataAddition ((uint32)0x87654321)

void ZSecurityEncrypt(char *data, uint32 len, uint32 key)
{
	uint32 i;
    uint32 dwordLen = len>>2;
	uint32* dwordPointer = (uint32*)data;

	ZEnd32(&key);
	for (i = 0;i < dwordLen; i++) {
		*dwordPointer++ ^= key; 
	}
}

void ZSecurityDecrypt(char *data, uint32 len, uint32 key)
{
	uint32 i;
    uint32 dwordLen = len>>2;
	uint32* dwordPointer = (uint32*)data;

	ZEnd32(&key);
	for (i = 0;i < dwordLen; i++) {
		*dwordPointer++ ^= key; 
	}
}

void ZSecurityEncryptToBuffer(char *data, uint32 len, uint32 key, char* dest)
{
	uint32 i;
    uint32 dwordLen = len>>2;
	uint32* dwordPointer = (uint32*)data;
	uint32* dwordDestPointer = (uint32*)dest;

#ifdef _DEBUG
    if ( (uint32)dest > (uint32)data )
        ZASSERT( (uint32)(dest - data) >= (uint32)4 );
    else
        ZASSERT( (uint32)(data - dest) >= (uint32)4 );
#endif

	ZEnd32(&key);
	for (i = 0;i < dwordLen; i++) 
    {
		*dwordDestPointer++ = *dwordPointer++ ^ key; 
	}
}

void ZSecurityDecryptToBuffer(char *data, uint32 len, uint32 key, char* dest)
{
	uint32 i;
    uint32 dwordLen = len>>2;
	uint32* dwordPointer = (uint32*)data;
	uint32* dwordDestPointer = (uint32*)dest;

#ifdef _DEBUG
    if ( (uint32)dest > (uint32)data )
        ZASSERT( (uint32)(dest - data) >= (uint32)4 );
    else
        ZASSERT( (uint32)(data - dest) >= (uint32)4 );
#endif

	ZEnd32(&key);
	for (i = 0;i < dwordLen; i++) {
		*dwordDestPointer++ = *dwordPointer++ ^ key; 
	}
}


/*******************************************************************************
	Win32 SSPI ROUTINES
*******************************************************************************/

#if 0
void ZSecurityMsgReqEndian(ZSecurityMsgReq* msg)
{
	ZEnd32(&msg->protocolSignature);
	ZEnd32(&msg->protocolVersion);

};


void ZSecurityMsgRespEndian(ZSecurityMsgResp* msg)
{
	ZEnd32(&msg->protocolVersion);

};



void ZSecurityMsgAccessDeniedEndian(ZSecurityMsgAccessDenied *msg)
{
	ZEnd32(&msg->protocolVersion);
	ZEnd16(&msg->reason);
};
#endif

//+----------------------------------------------------------------------------
//
//  Function:   LoadSSPS
//
//  Synopsis:   This function loads MSN SSPI DLL through the security DLL
//
//  Arguments:  void
//
//  Returns:    Pointer to the security function table if successful.
//              Otherwise, NULL is returned.
//
//  History:    LucyC       Created                             17 July 1995
//
//-----------------------------------------------------------------------------
PSecurityFunctionTable
ZLoadSSPS (
    VOID
    )
{
    OSVERSIONINFO   VerInfo;
    UCHAR lpszDLL[SSP_DLL_NAME_SIZE];
    HINSTANCE hSecLib;
    PSecurityFunctionTable	pFuncTbl = NULL;
    INIT_SECURITY_INTERFACE	addrProcISI = NULL;
	
    //
    //  If loading msapssps dll through security dll
    //
    
    //
    //  Find out which security DLL to use, depending on 
    //  whether we are on NT or Win95
    //
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (!GetVersionEx (&VerInfo))   // If this fails, something gone wrong
    {
	    return NULL;
    }

    if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        lstrcpyA (lpszDLL, SSP_NT_DLL);
    }
    else if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        lstrcpyA (lpszDLL, SSP_WIN95_DLL);
    }
    else
    {
		SetLastError(ERROR_OLD_WIN_VERSION);
        return NULL;
    }

    //
    //  Load Security DLL
    //
    hSecLib = LoadLibraryA (lpszDLL);

	if (hSecLib == NULL)
    {
        return NULL;
    }

//with .c file and #defines in SSPI this was simplest solution
#ifdef UNICODE
    addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                    "InitSecurityInterfaceW");       
#else
	addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress( hSecLib, 
                  "InitSecurityInterfaceA");       
#endif

    if (addrProcISI == NULL)
    {
        return NULL;
    }

    //
    // Get the SSPI function table
    //
    pFuncTbl = (*addrProcISI)();
    
    return (pFuncTbl);
}


/*
	Unloads the SSPI DLL.
*/
void ZUnloadSSPS(void)
{
    OSVERSIONINFO verInfo;
    UCHAR lpszDLL[SSP_DLL_NAME_SIZE];
    HINSTANCE hSecLib;


    //
    //  Find out which security DLL to use, depending on 
    //  whether we are on NT or Win95
    //
    verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&verInfo))   // If this fails, something gone wrong
	    return;

    if (verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
        lstrcpyA (lpszDLL, SSP_NT_DLL);
	}
    else if (verInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
	{
        lstrcpyA (lpszDLL, SSP_WIN95_DLL);
	}
    else
	{
		SetLastError(ERROR_OLD_WIN_VERSION);
        return;
    }

	hSecLib = GetModuleHandleA(lpszDLL);
	if (hSecLib)
		FreeLibrary(hSecLib);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zservsec.h ===
#ifndef _ZSERVSEC_H_
#define _ZSERVSEC_H_

class CODBC;


///////////////////////////////////////////////////////////////////////////////////
// ZServerSecurity
// Implements server side of SSPI security
//

class ZServerSecurity : public ZSecurity {
public:
    ZServerSecurity();
protected:
    virtual SECURITY_STATUS SecurityContext(
        ZSecurityContext * context,
        PSecBufferDesc pInput,                  
        PSecBufferDesc pOutput                 
        );

};

ZSecurity * ZCreateServerSecurity(char *SecPkg);


#define  zTokenLen  20 //Current value of the Sicily database

struct TokenStruct
{
    long  secTokenEnd;
    char  pszToken[zTokenLen+1];
};

///////////////////////////////////////////////////////////////////////////////////
//ZSecurityContextEx
//Extended security class for non SSPI Zone specific 
//implementation which includes Zone alias mapping
class ZSecurityContextEx:  public ZSecurityContext 
{
public:
    ZSecurityContextEx() ;
    ~ZSecurityContextEx();
    
    BOOL HasToken(char* token);
    BOOL EnumTokens(ZSConnectionTokenEnumFunc func, void* userData);

    BOOL  GetContextString(char* buf, DWORD len);
    BOOL  GetUserName(char* name) { if (name) {lstrcpyA(name, m_UserName);} return TRUE; }
    DWORD GetUserId() { return m_UserId; }

    friend class ZServerSecurityEx;
    friend class ConSSPI;

protected:

    void ResetTokenStartTick() { m_TokenStartTick = GetTickCount(); }
    void AddToken(char *name, long secTokenEnd );
    void SetUserName(char *name);
    void SetUserId(DWORD id) { m_UserId = id; }
    void SetContextString(char* str);

    //need both a numeric and 
    //string id to identify user
    //From DPA we can get string or hAcct
    //From MSN we only want hAcct
    //From NTLM we get name have to make up  id
    DWORD m_UserId;
    char  m_UserName[zUserNameLen+1];

    DWORD m_TokenStartTick;

    //Security token information
    CHash<TokenStruct,char*> m_tokens;

    char* m_pContextStr;

    static bool __stdcall TokenEnumCallback(TokenStruct* Token, MTListNodeHandle hNode, void* Cookie);

};




///////////////////////////////////////////////////////////////////////////////////
// ZServerSecurityEx
// Extended server security class 
// created to compensate for working with MSN data center
// which includes slow response times, can't modify 
// their security database quickly or easily. 
// Zone alias mapping
// Zones test data centers being different than
// production etc.
//
// Implements server side of SSPI security
// but with thread queue as opposed to a
// synchronous model
// Why implement here, because this object
// has the correct scope and lifetime in the server
// 
// Because we are on seperate thread we cann continue
// to retry ODBC connection if it fails or changes
// Retry assumes only single worker thread active

class ZServerSecurityEx : public ZServerSecurity, public CThreadPool {
public:
    ZServerSecurityEx() ;
    ~ZServerSecurityEx() ;

    int InitApplication(char *ServerName,char *ServerType,char *ServerRegistry);
    int InitODBC(LPSTR*registries, DWORD numRegistries );

    BOOL IsFailing() {return m_Failing;};
    
    CODBC* GetOdbc();
    
    virtual BOOL GenerateContext (
            ZSecurityContextEx * context,
            BYTE *pIn,
            DWORD cbIn,
            BYTE *pOut,
            DWORD *pcbOut,
            BOOL *pfDone,
            GUID* pGUID = NULL );
protected:

    void Failing()  {InterlockedExchange((PLONG) &m_Failing,TRUE);};
    void NotFailing() {InterlockedExchange((PLONG) &m_Failing,FALSE);};
    void LookupUserInfo(ZSecurityContextEx * context, GUID* pGUID );

    char m_ServerName[31 + 1];
    char m_ServerType[31 + 1];
    char m_ServerRegistry[MAX_PATH + 1];


    CHAR m_szOdbcDSN[MAX_PATH];
    CHAR m_szOdbcUser[32];
    CHAR m_szOdbcPassword[32];
    DWORD m_dwOdbcNumThreads;

    static const char m_szDefaultRegistry[];

    //To make database connection more robust we will retry connection
    //on failure every approx 10 seconds. Retrying for every user might result
    //in queue overloading as it takes 20 seconds for ODBC to get a connection.
    
    BOOL m_Failing;
    DWORD m_RetryTime;
    DWORD m_LastFailed;

};

ZServerSecurityEx * ZCreateServerSecurityEx(char *SecPkg,char *ServerName,char *ServerType,char *ServerRegistry);



#endif //ZSECOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zservsec.cpp ===
#include <windows.h>
#include <winsock.h>
#include <atlbase.h>


#include "zone.h"
#include "zonedebug.h"
#include "pool.h"
#include "queue.h"
#include "hash.h"
#include "zservcon.h"
#include "zsecurity.h"
#include "zconnint.h"
#include "thrdpool.h"
#include "coninfo.h"
#include "zsecobj.h"
#include "consspi.h"
#include "eventlog.h"
#include "zonemsg.h"
#include "registry.h"
#include "netstats.h"
#include "zonestring.h"

extern CDataPool* g_pDataPool;

static CODBCPool g_OdbcPool;

#define SEC_SUCCESS(Status) ((Status) >= 0)

const char g_szDefaultRegistry[]="SYSTEM\\CurrentControlSet\\Services\\ZoneAccountServices\\Parameters";
const char ZServerSecurityEx::m_szDefaultRegistry[]="SYSTEM\\CurrentControlSet\\Services\\ZoneAccountServices\\Parameters";

struct BindParameter
{
    SQLSMALLINT    IOType;
    SQLSMALLINT    ValueType;
    SQLSMALLINT    ParameterType;
    SQLUINTEGER ColSize;
    SQLSMALLINT DecimalDigits;
    SQLPOINTER    Parameter;
    SQLINTEGER  BufferLength;
    SQLINTEGER* pBufferLength;
};

///////////////////////////////////////////////////////////////////////////////////
// Zone Security class Implementation
//
///////////////////////////////////////////////////////////////////////////////////

static inline long GetTickDeltaInSec( DWORD now, DWORD then)
{
    if ( now >= then )
        return (now - then)/1000;
    else
        return (INFINITE - then + now)/1000;
}



//Create a server security object
//that will use a particular package to authenticate all users

ZSecurity * ZCreateServerSecurity(char *SecPkg)
{
    ZServerSecurity *security;

    IF_DBGPRINT( DBG_CONINFO,("ZCreateServerSecurity Entering\n") );

    ASSERT(SecPkg);

    if (!SecPkg) {
        return NULL;
    }

    if (SecPkg[0]=='\0') {
        return NULL;
    }

    security = new ZServerSecurity;

    if (!security)    {
        IF_DBGPRINT( DBG_CONINFO,("Can't allocate ZServerSecurity object\n"));
        return NULL;
    }
    
    if (security->Init(SecPkg)) {
        IF_DBGPRINT( DBG_CONINFO,("Couldn't initialize security package %s\n",SecPkg));
        delete security;
        return NULL;
    }

    return security;
    

}


ZServerSecurity::ZServerSecurity()
{
    m_CredUse  =  SECPKG_CRED_INBOUND;
}



SECURITY_STATUS ZServerSecurity::SecurityContext(
        ZSecurityContext * context,
         PSecBufferDesc pInput,                  
        PSecBufferDesc pOutput)

{
    
    ULONG ContextAttributes;
    TimeStamp        Lifetime;
    ULONG         fContextReq;

    fContextReq = ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;


    return m_pFuncs->AcceptSecurityContext (
                        &m_hCredential,
                        context->IsInitialized() ? context->Context() : NULL,
                        pInput,
                        fContextReq,    // context requirements
                        SECURITY_NATIVE_DREP,
                        context->Context(),
                        pOutput,
                        &ContextAttributes,
                        &Lifetime);
    
}



ZServerSecurityEx::ZServerSecurityEx() : CThreadPool(1)
{

    m_ServerName[0]='\0';
    m_ServerType[0]='\0';
    m_ServerRegistry[0]='\0';

    m_Failing=TRUE;

    m_RetryTime = 10000; //default is 10s till retry of ODBC

    m_LastFailed = GetTickCount() - (10*m_RetryTime);  // for a retry at start

};

ZServerSecurityEx::~ZServerSecurityEx() 
{
    
}

int ZServerSecurityEx::InitApplication(char *ServerName,char *ServerType,char *ServerRegistry)
{

    if (ServerName)
        lstrcpynA(m_ServerName,ServerName, sizeof(m_ServerName) );

    if (ServerType)
        lstrcpynA(m_ServerType,ServerType, sizeof(m_ServerType) );

    if (ServerRegistry)
        lstrcpynA(m_ServerRegistry,ServerRegistry, sizeof(m_ServerRegistry) );

    return NOERROR;
};

int ZServerSecurityEx::InitODBC(LPSTR*registries, DWORD numRegistries )
{
    BOOL bRet = FALSE;
    USES_CONVERSION;
    CRegistry reg;
    if ( reg.SetKeyRoots( registries, numRegistries ) )
    {
        reg.AddValueLPSTR( NULL, "OdbcDSN", m_szOdbcDSN, sizeof(m_szOdbcDSN) );
        reg.AddValueLPSTR( NULL, "OdbcUsername", m_szOdbcUser, sizeof(m_szOdbcUser) );
        reg.AddValueLPSTR( NULL, "OdbcPassword", m_szOdbcPassword, sizeof(m_szOdbcPassword) );
        reg.AddValueDWORD( NULL, "OdbcNumThreads", &m_dwOdbcNumThreads );
        reg.AddValueDWORD( NULL, "RetryTime", &m_RetryTime );

        bRet = reg.ReadValues();

    }

    if ( !bRet )
    {
        LPTSTR ppsz[] = { A2T(reg.GetErrorValueName()), A2T(reg.GetErrorReason() )};
        ZoneEventLogReport( ZONE_E_REGISTRY_VALUE, 2, ppsz, 0, NULL );

        DebugPrint( "Error starting game service %s %s\n", reg.GetErrorValueName(), reg.GetErrorReason() );
        return E_FAIL;
    }

    m_LastFailed = GetTickCount() - m_RetryTime;

	// CHB 8/4/99 - MDAC 2.1sp2 hangs on SqlConnect while service is initializing.  Workaround for
	// now is to postpone sql connection until we actually need it.
	if ( FAILED( g_OdbcPool.Init( m_szOdbcDSN, m_szOdbcUser, m_szOdbcPassword, 0 /* m_dwOdbcNumThreads */, m_dwOdbcNumThreads ) ) )
	{
		LPTSTR ppsz[] = { TEXT("ODBC Pool failed to initialize")};
        ZoneEventLogReport( ZONE_E_ASSERT, 1, ppsz, 0, NULL );
        
        return E_FAIL;
	}

	SetThreadCount(m_dwOdbcNumThreads);

    return NOERROR;

};

BOOL ZServerSecurityEx::GenerateContext (
            ZSecurityContextEx * context,
            BYTE *pIn,
            DWORD cbIn,
            BYTE *pOut,
            DWORD *pcbOut,
            BOOL *pfDone,
            GUID* pGUID )

{
    char Name[zUserNameLen +1] = "";
    
    BOOL bReturn = ZServerSecurity::GenerateContext(
                     context, pIn,cbIn,
                      pOut,pcbOut,pfDone );

    if (!*pfDone || !bReturn)
        return bReturn;

    //Get user name from security package for context
    if ( GetUserName(context,Name) != 0 )
    {
        return FALSE;
    }

    //By default name of context is that provided
    //by security package
    context->SetUserName(Name);

    DWORD userid = atol(Name);
    if ( userid )
    {
        context->SetUserId(userid);

        //Lookup name and security tokens from zone database
        LookupUserInfo(context, pGUID );
    }
    return TRUE;
    
}


CODBC* ZServerSecurityEx::GetOdbc()
{
    USES_CONVERSION;
    CODBC* pDB = NULL;

    //If ODBC connection is failing periodically retry
    if ( IsFailing() )
    {
        if ( (GetTickCount() - m_LastFailed) > m_RetryTime)
        {
            pDB = g_OdbcPool.Alloc();
			if (!pDB)
            {
                LPTSTR ppStr[] = { A2T(m_szOdbcDSN), A2T(m_szOdbcUser), A2T(m_szOdbcPassword)  };
                ZoneEventLogReport( ZONE_E_INIT_SQL_FAILED, 3, ppStr, 0, NULL );
            }
			else
			{
                NotFailing();
            }

        }
        else
        {
            DebugPrint("GetODBC FAILED: %d - %d >= %d\n", GetTickCount(), m_LastFailed, m_RetryTime );
        }
    }
    else
    {
        pDB = g_OdbcPool.Alloc();
    }

    return pDB;
}


void ZServerSecurityEx::LookupUserInfo(ZSecurityContextEx * context, GUID* pGUID)
{
    BOOL        status = TRUE;

    CODBC*      pDB;

    int                hAcct = 0;
    unsigned char*     pszMac = NULL;
    char               szNameOut[zUserNameLen + 1] = "";
    int                secTokenEnd = 0;
    int                Error = 0;
    TCHAR              szErrorMessage[256] = TEXT("");
    char               szToken[zTokenLen + 1] = "";


    SQLRETURN   nResult;

    SQLINTEGER  cbhAcct     = sizeof(hAcct);

    SQLINTEGER  cbMac    = SQL_NTS;
    SQLINTEGER  cbNameOut = sizeof(szNameOut)-1;

    SQLINTEGER  cbError        = sizeof(Error);
    SQLINTEGER  cbErrorMessage = sizeof(szErrorMessage)-1;
    SQLINTEGER  cbServerName   = SQL_NTS;
    SQLINTEGER  cbServerType   = SQL_NTS;
    SDWORD      cbToken        = sizeof(szToken);
    SDWORD      cbSecTokenEnd  = sizeof(secTokenEnd);

    char  buff[256];
    TCHAR  *sp = TEXT("{call p_authorize_for_znetwork  (?, ?, 'ALL', NULL, ?, ?, ?, ?, ?)}");


    hAcct = context->GetUserId();
    ASSERT(hAcct);

    GUID mac;
    if ( !pGUID )
    {
        pGUID = &mac;
        UuidCreateNil( pGUID );
    }

    if ( !pGUID || ( RPC_S_OK != UuidToStringA( pGUID, &pszMac ) ) )
    {
        status = FALSE;
        goto done;
    }

    //Check if odbc is failing if it is still let user in
    //you will see number with name however
    pDB = GetOdbc();
    if ( !pDB )
    {
        if ( !IsFailing() )
        {
            LPTSTR ppsz[] = { TEXT("ODBC Pool failed to allocate")};
            ZoneEventLogReport( ZONE_E_ASSERT, 1, ppsz, 0, NULL );
        }
		status = FALSE;
        goto done;
	}

	pDB->Reset();

    nResult = SQLPrepare( pDB->hstmt(),  (SQLTCHAR*)sp, SQL_NTS );
    if (nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO)
    {
        LPTSTR ppStr[1];
        ppStr[0] = pDB->GetError( nResult, SQL_HANDLE_STMT );
        ZoneEventLogReport( ZONE_E_SQL_ERROR, 1, ppStr, sizeof(nResult), &nResult );
        status = FALSE;
        goto done;
    }

    SQLBindParameter( pDB->hstmt(), 1, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &hAcct, 0, &cbhAcct );
    SQLBindParameter( pDB->hstmt(), 2, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_CHAR, lstrlenA(m_ServerName), 0, m_ServerName, 0, &cbServerName );

    SQLBindParameter( pDB->hstmt(), 3, SQL_PARAM_OUTPUT, SQL_C_CHAR, SQL_CHAR, cbNameOut, 0, szNameOut, cbNameOut, &cbNameOut);

    SQLBindParameter( pDB->hstmt(), 4, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, &Error, 0, &cbError );
    SQLBindParameter( pDB->hstmt(), 5, SQL_PARAM_OUTPUT, SQL_C_CHAR, SQL_VARCHAR, cbErrorMessage, 0, szErrorMessage, cbErrorMessage, &cbErrorMessage );

    SQLBindParameter( pDB->hstmt(), 6, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, lstrlenA(m_ServerName), 0, m_ServerName, 0, &cbServerName );
    SQLBindParameter( pDB->hstmt(), 7, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, lstrlenA(m_ServerType), 0, m_ServerType, 0, &cbServerType );

    nResult = SQLExecute( pDB->hstmt() );
    if (nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO && nResult != SQL_NO_DATA_FOUND)
    {
        LPTSTR ppStr[1];
        ppStr[0] = pDB->GetError( nResult, SQL_HANDLE_STMT );
        ZoneEventLogReport( ZONE_E_SQL_ERROR, 1, ppStr, sizeof(nResult), &nResult );
        status = FALSE;
        goto done;
    }

    if (Error && szErrorMessage[0] )
    {
        LPTSTR ppStr[1];
        szErrorMessage[sizeof(szErrorMessage)-1]='\0';
        ppStr[0] = szErrorMessage;
        ZoneEventLogReport( ZONE_E_SQL_SP_ERROR, 1, ppStr, sizeof(Error), &Error );
        status = FALSE;
        goto done;
    }

    context->ResetTokenStartTick();

    SQLBindCol( pDB->hstmt(), 1, SQL_C_CHAR, &szToken, zUserNameLen, &cbToken );
    SQLBindCol( pDB->hstmt(), 2, SQL_C_SLONG, &secTokenEnd, 0, &cbSecTokenEnd );
    while (TRUE) {
        nResult= SQLFetch(pDB->hstmt());
        
        if (nResult == SQL_NO_DATA)
            break;

        if (nResult == SQL_SUCCESS || nResult == SQL_SUCCESS_WITH_INFO)
        {
            szToken[sizeof(szToken)-1]='\0';
            char* psz = szToken;
            while( *psz )
            {
                if ( ISSPACE(*psz) )
                {
                    *psz = '\0';
                    break;
                }
                *psz++;
            }
            context->AddToken(szToken, secTokenEnd);
        }
        else
        {
            LPTSTR ppStr[1];
            ppStr[0] = pDB->GetError( nResult, SQL_HANDLE_STMT );

            // check for no rows returned
            if ( lstrcmp( TEXT("24000"), pDB->GetErrorState() ) == 0 )
            {
                break;
            }
            else
            {
                ZoneEventLogReport( ZONE_E_SQL_SP_ERROR, 1, ppStr, 0, NULL );
                status = FALSE;
                goto done;
            }
        }
        
    }

    // requires for QDBC 3.5 and greater.
    while( SQLMoreResults( pDB->hstmt() ) != SQL_NO_DATA_FOUND );

    if ( szNameOut[0] )
    {
        szNameOut[sizeof(szNameOut)-2]='\0'; // guarentee that the name has room for a sysop token
        szNameOut[sizeof(szNameOut)-1]='\0';
        char* psz = szNameOut;
        while( *psz )
        {
            if ( ISSPACE(*psz) )
            {
                *psz = '\0';
                break;
            }
            *psz++;
        }

        context->SetUserName(szNameOut);
        context->SetUserId(hAcct);
    }
    else
    {
        hAcct = context->GetUserId();
    }

    // TIM and HOON made me do this, because the wouldn't conform the standard URL format
    wsprintfA( buff, "UserID=<%d>", hAcct );
    context->SetContextString(buff);

done:
    if ( pszMac )
    {
        RpcStringFreeA(&pszMac );
    }

    if ( pDB )
    {
        pDB->Reset();

        if (!status)
        {
            InterlockedExchange((PLONG) &m_LastFailed, GetTickCount());
            Failing();
            pDB->Close();
        }

        g_OdbcPool.Free( pDB, status);
    }
};


//Create a server security object
//that will use a particular package to authenticate all users

ZServerSecurityEx * ZCreateServerSecurityEx(char *SecPkg,char *ServerName,char *ServerType,char *ServerRegistry)
{
    ZServerSecurityEx *security;

    IF_DBGPRINT( DBG_CONINFO,("ZCreateServerSecurity Entering\n") );

    ASSERT(SecPkg);

    if (!SecPkg) {
        return NULL;
    }

    if (SecPkg[0]=='\0') {
        return NULL;
    }

    security = new ZServerSecurityEx;

    if (!security)    {
        IF_DBGPRINT( DBG_CONINFO,("Can't allocate ZServerSecurity object\n"));
        return NULL;
    }
    
    if (security->Init(SecPkg)) {
        IF_DBGPRINT( DBG_CONINFO,("Couldn't initialize security package %s\n",SecPkg));
        delete security;
        return NULL;
    }

     //Try given server instance registry for parameters
    LPSTR pRegistries[] = { ServerRegistry, (LPSTR)g_szDefaultRegistry};
    if (security->InitODBC(pRegistries, (sizeof(pRegistries)/sizeof(pRegistries[0])) ))
    {
        return NULL;
    }


    security->InitApplication(ServerName,ServerType,ServerRegistry);
    return security;
    

}




static bool CompareToken(TokenStruct* Token,char * Key)
{
    return (!lstrcmpiA(Token->pszToken,Key));
}

bool TokenDeleteCallback(TokenStruct* Token, MTListNodeHandle hNode, void* Cookie)
{
    g_pDataPool->Free( (char*)Token, sizeof(*Token) );
    return TRUE;
}

ZSecurityContextEx::ZSecurityContextEx() :
    m_tokens(::HashLPSTRLower,::CompareToken)
{
    m_UserId=0;
    m_UserName[0]='\0';
    m_pContextStr = NULL;
    m_TokenStartTick = GetTickCount();
};



ZSecurityContextEx::~ZSecurityContextEx()
{    
    m_tokens.ForEach(TokenDeleteCallback,NULL);
    m_tokens.RemoveAll();

    if ( m_pContextStr )
    {
        g_pDataPool->Free( m_pContextStr, lstrlenA( m_pContextStr ) + 1);
        m_pContextStr = NULL;
    }
}


BOOL  ZSecurityContextEx::HasToken(char *Token )
{
    TokenStruct* newToken = m_tokens.Get(Token);

    return (newToken != NULL);
}


struct TokenEnumStruct
{
    ZSecurityContextEx* context;
    ZSConnectionTokenEnumFunc func;
    void* userData;
    long  delta;
};

bool __stdcall ZSecurityContextEx::TokenEnumCallback(TokenStruct* Token, MTListNodeHandle hNode, void* Cookie)
{
    TokenEnumStruct* pTES = (TokenEnumStruct*) Cookie;

    long delta = Token->secTokenEnd - pTES->delta;
    if ( delta > 0 )
    {
        return (*pTES->func)(pTES->userData, Token->pszToken, delta) ? true : false;
    }
    else
    {
        pTES->context->m_tokens.MarkNodeDeleted( hNode );
        return TRUE;
    }
}

BOOL ZSecurityContextEx::EnumTokens(ZSConnectionTokenEnumFunc func, void* userData)
{
    TokenEnumStruct tes;
    tes.context = this;
    tes.func = func;
    tes.userData = userData;
    tes.delta = GetTickDeltaInSec(GetTickCount(), m_TokenStartTick );
    m_tokens.ForEach(TokenEnumCallback,&tes);

    return TRUE;
}

void  ZSecurityContextEx::AddToken(char *Token, long secTokenEnd )
{
    if (!Token)
        return;

    if ( secTokenEnd < 0 )
        return;

    int len = lstrlenA(Token);
    if (len > zTokenLen)
        return;

    TokenStruct* newToken = m_tokens.Get(Token);
    if ( newToken )
    {
        newToken->secTokenEnd = max(newToken->secTokenEnd, secTokenEnd);
        return;
    }

    newToken = (TokenStruct*) g_pDataPool->Alloc(sizeof(*newToken));
    if (newToken)
    {
        CopyMemory(newToken->pszToken,Token, len+1);
        newToken->secTokenEnd = secTokenEnd;

        if (!m_tokens.Add(newToken->pszToken,newToken))
        {
            g_pDataPool->Free( (char*)newToken, sizeof(*newToken) );
        }
    }

}

void  ZSecurityContextEx::SetUserName(char *name)
{
    if (!name)
        return;

    if ( lstrlenA(name) < sizeof(m_UserName) )
    {
        lstrcpyA(m_UserName,name);
    }
    else
    {
        ASSERT( lstrlenA(name) < sizeof(m_UserName) );
    }
}


void ZSecurityContextEx::SetContextString(char* str)
{
    if (!str)
        return;

    ASSERT( !m_pContextStr );
    m_pContextStr = g_pDataPool->Alloc(lstrlenA(str) + 1);
    ASSERT(m_pContextStr);
    if ( m_pContextStr )
        lstrcpyA(m_pContextStr, str);

};


BOOL ZSecurityContextEx::GetContextString(char* buf, DWORD len)
{
    if ( buf )
    {
        buf[0] = '\0';

        if ( m_pContextStr )
        {
            if ( len > (DWORD) lstrlenA( m_pContextStr ) )
            {
                lstrcpyA( buf, m_pContextStr);
            }
            else
            {
                return FALSE;
            }
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zerror.c ===
/*******************************************************************************

	ZError.c
	
		Zone(tm) error lib.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Friday, April 21, 1995 04:15:34 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		04/21/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>

#include "zone.h"

#if 0 // removed for Millennium
/* -------- Globals -------- */
static TCHAR*		gSystemErrStr[] = 
							{
								_T("No error."),
								_T("An unknown error has occurred."),
								_T("Out of memory."),
								_T("Failed to launch the program."),
								_T("Bad font object."),
								_T("Bad color object."),
								_T("Bad directory specification."),
								_T("A duplicate error?"),
								_T("File read error."),
								_T("File write error."),
								_T("Unknown file error."),
								_T("Bad object."),
								_T("NULL object."),
								_T("Resource not found."),
								_T("File not found."),
								_T("Bad parameter.")
							};
static TCHAR*		gNetworkErrStr[] = 
							{
								_T("An unknown network error occurred."),
								_T("Network read error."),
								_T("Network write error."),
								_T("Another generic network error."),
								_T("Local network problem."),
								_T("Unknown host."),
								_T("Specified host not found."),
								_T("Server ID not found.")
							};
static TCHAR*		gWindowsSystemErrStr[] = 
							{
								_T("Windows system error.",)
								_T("Generic Windows system error.")
							};


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/
TCHAR* GetErrStr(int32 error)
{
	if (error >= zErrWindowSystem && error <= zErrWindowSystemGeneric)
		return (gWindowsSystemErrStr[error - zErrWindowSystem]);
	if (error >= zErrNetwork && error <= zErrServerIdNotFound)
		return (gNetworkErrStr[error - zErrNetwork]);
	if (error >= zErrNone && error <= zErrNotFound)
		return (gSystemErrStr[error]);
	return (gSystemErrStr[zErrGeneric]);
}
#endif

// Temporary for Millennium - badly hardcoded
TCHAR *GetErrStr(int32 error)
{
    if(error =! zErrOutOfMemory);
        return NULL;
    return (TCHAR *) MAKEINTRESOURCE(1313);
}

#ifdef SVR4PC
/* Garbage -- clean up sometime. */
ErrorSys(fmt,p1,p2,p3,p4,p5,p6,p7)
char *fmt;
int p1,p2,p3,p4,p5,p6,p7;
{
     fprintf(stderr,fmt,p1,p2,p3,p4,p5,p6,p7);
     exit(1);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\znetwork\zservsimple.cpp ===
/*******************************************************************************

    ZServCon.cpp
    
        ZSConnection object methods.


    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------

*******************************************************************************/



#include <windows.h>
#include <winsock.h>
#include <aclapi.h>

#include "zone.h"
#include "zservcon.h"
#include "zonedebug.h"


char* ZSConnectionAddressToStr(uint32 addr)
{
    ZEnd32(&addr);
    in_addr a;
    a.s_addr = addr;
    return inet_ntoa(a);
}

uint32 ZSConnectionAddressFromStr( char* pszAddr )
{
    uint32 addr = inet_addr( pszAddr );
    ZEnd32(&addr);
    return addr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zgame1.c ===
/*******************************************************************************

	ZGame1.c
	
		Zone(tm) game endian conversion routines.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im
	Created on November, 28, 1995 
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		11/28/95	HI		Created.
	 
*******************************************************************************/


#include "zone.h"
#include "zgame.h"


void ZGameMsgCheckInEndian(ZGameMsgCheckIn* msg)
{
	ZEnd32(&msg->protocolSignature);
	ZEnd32(&msg->protocolVersion);
	ZEnd32(&msg->clientVersion);
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
	ZEnd16(&msg->playerType);
}


void ZGameMsgReplacePlayerEndian(ZGameMsgReplacePlayer* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}


void ZGameMsgTableOptionsEndian(ZGameMsgTableOptions* msg)
{
	ZEnd16(&msg->seat);
	ZEnd32(&msg->options);
}


void ZGameMsgGameStateRequestEndian(ZGameMsgGameStateRequest* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}


void ZGameMsgGameStateResponseEndian(ZGameMsgGameStateResponse* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zllist.cpp ===
/*******************************************************************************

	ZLList.c
	
		Zone(tm) LinkList module.
		
		This link list module allows the user to maintain a link list of
		non-homogeneous objects through type specifications.
	
	Copyright (c) Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Tuesday, March 07, 1995 08:35:54 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		03/07/95	HI		Created.
	 
*******************************************************************************/


#include <stdio.h>
#include <stdlib.h>

#include "zone.h"
#include "zonedebug.h"
#include "pool.h"


#define IL(object)				((ILList) (object))
#define ZL(object)				((ZLList) (object))

#define II(object)				((ILListItem) (object))
#define ZI(object)				((ZLListItem) (object))


typedef struct ILListItemStruct
{
    struct ILListItemStruct*	next;
    struct ILListItemStruct*	prev;
    void*						type;
    void*						data;
} ILListItemType, *ILListItem;

typedef struct
{
    ILListItem					head;
    ILListItem					tail;
    ZLListDeleteFunc			deleteFunc;
    int32                       count;
    CRITICAL_SECTION            pCS[1];
} ILListType, *ILList;


CPool<ILListItemType> g_ItemPool(256);

/* -------- Internal Routines -------- */


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

/*
	ZLListNew()
	
	Creates a new link list object. deleteFunc provided by the caller is
	called when deleting the object.
	
	If deleteFunc is NULL, then no delete function is called when an
	object is removed.
*/
ZLList		ZLListNew(ZLListDeleteFunc deleteFunc)
{
	ILList			obj;
	
	
	obj = IL(ZMalloc(sizeof(ILListType)));
	if (obj != NULL)
	{
		obj->head = NULL;
		obj->tail = NULL;
		obj->deleteFunc = deleteFunc;
        obj->count = 0;
        InitializeCriticalSection(obj->pCS);
	}
	
	return (ZL(obj));
}
	

/*
	ZLListDelete()
	
	Tears down the link list by deleting all link list objects.
*/
void		ZLListDelete(ZLList list)
{
    ILList          pThis = IL(list);
	
	
    if (pThis != NULL)
    {
        /* Delete all entries. */
        EnterCriticalSection(pThis->pCS);
        while (pThis->head != NULL)
            ZLListRemove(pThis, pThis->head);
        LeaveCriticalSection(pThis->pCS);


        /* Delete the link list object. */
        DeleteCriticalSection(pThis->pCS);
        ZFree(pThis);
	}
}

	
/*
	ZLListAdd()
	
	Adds objectData of objectType to the link list using fromItem as a
	reference entry. addOption determines where the new objects gets added.
	If adding to the front or end of the link list, then fromItem is unused.
	If fromItem is NULL, then it is equivalent to the head of the list.
	
	Returns the link list item after adding the object is added to the list.
	
	The given object is not copied! Hence, the caller must not dispose of
	the object until the object is removed from the list first.
	
	Use zLListNoType when object type is not used.
*/
ZLListItem	ZLListAdd(ZLList list, ZLListItem fromItem, void* objectType,
					void* objectData, int32 addOption)
{
    ILList          pThis = IL(list);
	ILListItem		item = II(fromItem), obj;
	
	
    if (pThis == NULL)
		return (NULL);
	
    obj = new (g_ItemPool) ILListItemType;
	if (obj != NULL)
	{
		obj->next = NULL;
		obj->prev = NULL;
		obj->type = objectType;
		obj->data = objectData;
		
        EnterCriticalSection(pThis->pCS);
        if (addOption != zLListAddFirst && addOption != zLListAddLast)
		{
			if (item == NULL)
				addOption = zLListAddFirst;
            else if (item == pThis->head && addOption == zLListAddBefore)
				addOption = zLListAddFirst;
            else if (item == pThis->tail && addOption == zLListAddAfter)
				addOption = zLListAddLast;
		}

        if (pThis->head == NULL)
		{
            pThis->head = obj;
            pThis->tail = obj;
		}
		else if (addOption == zLListAddFirst)
		{
            obj->next = pThis->head;
            pThis->head->prev = obj;
            pThis->head = obj;
		}
		else if (addOption == zLListAddLast)
		{
            obj->prev = pThis->tail;
            pThis->tail->next = obj;
            pThis->tail = obj;
		}
		else if (addOption == zLListAddBefore)
		{
			obj->prev = item->prev;
			obj->next = item;
			item->prev->next = obj;
			item->prev = obj;
		}
		else
		{
			obj->prev = item;
			obj->next = item->next;
			item->next->prev = obj;
			item->next = obj;
		}

        pThis->count++;
        LeaveCriticalSection(pThis->pCS);
    }
	
	return (ZI(obj));
}
	

/*
	ZLListGetData()
	
	Returns the object of the given link list entry. Also returns the object
	type in objectType. Does not return the object type if objectType parameter
	is NULL.
*/
void*		ZLListGetData(ZLListItem listItem, void** objectType)
{
    ILListItem          pThis = II(listItem);
	void*				data = NULL;
	
	
    if (pThis != NULL)
	{
		if (objectType != NULL)
            *objectType = pThis->type;
        data = pThis->data;
	}
	
	return (data);
}
	

/*
	ZLListRemove()
	
	Removes the link list entry from the list and calls the user supplied
	delete function to delete the object.
	
	Assumes that the given list item is in the list. If the item is not in the
	list, then we could be in for a big surprise.
*/
void		ZLListRemove(ZLList list, ZLListItem listItem)
{
    ILList          pThis = IL(list);
	ILListItem		item = II(listItem);
	
	
    if (pThis == NULL)
		return;
	
	if (item != NULL)
	{
        EnterCriticalSection(pThis->pCS);

        /* Remove the item from the list. */
        if (item == pThis->head)
            pThis->head = item->next;
        if (item == pThis->tail)
            pThis->tail = item->prev;
		if (item->next != NULL)
			item->next->prev = item->prev;
		if (item->prev != NULL)
			item->prev->next = item->next;
		
		/* Call the user supplied delete function to dispose of the object. */
        if (pThis->deleteFunc != NULL)
            pThis->deleteFunc(item->type, item->data);

        pThis->count--;
        if (pThis->count < 0)
		{
            pThis->count = 0;
            ZASSERT( "List count is less than 0 -- Should not occur!\n" );
		}
        LeaveCriticalSection(pThis->pCS);

        /* Dispose of the list item. */
        item->prev = NULL;
        item->next = NULL;
        item->type = NULL;
        item->data = NULL;
        delete item;

    }
}


/*
	ZLListFind()
	
	Finds and returns a link list entry containing the object data of the
	objectType. The search is done starting at fromItem using the findOption
	flag. Returns NULL if an object of the specified type is not found.
	
	If fromItem is NULL, then the find starts from the front if the findOption
	is set to zLListFindForward or from the end if the findOption is set to
	zLListFindBackward.
	
	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListFind(ZLList list, ZLListItem fromItem, void* objectType,
					int32 findOption)
{
    ILList          pThis = IL(list);
	ILListItem		item = II(fromItem);

	
    if (pThis == NULL)
		return (NULL);

    EnterCriticalSection(pThis->pCS);

	/*
		If no starting point is specified, then start either from the head or tail
		depending on the find option.
	*/
	if (item == NULL)
	{
		if (findOption == zLListFindForward)
            item = pThis->head;
		else
            item = pThis->tail;
	}
	else
	{
		/* Start past the specified staring point. */
		if (findOption == zLListFindForward)
			item = item->next;
		else
			item = item->prev;
	}
		
	if (item != NULL)
	{
		/* Go find the specified object type. */
		if (objectType != zLListAnyType)
		{
			/* Are we at the requested object? */
			if (item->type != objectType)
			{
				if (findOption == zLListFindForward)
				{
					/* Search forward. */
					item = item->next;
					while (item != NULL)
					{
						if (item->type == objectType)
							break;
						item = item->next;
					}
				}
				else
				{
					/* Search backward. */
					item = item->prev;
					while (item != NULL)
					{
						if (item->type == objectType)
							break;
						item = item->prev;
					}
				}
			}
		}
	}
	
    LeaveCriticalSection(pThis->pCS);

    return (ZI(item));
}


/*
	ZLListGetNth()
	
	Returns the nth object of objectType in the list. Returns NULL if
	such an entry does not exist.
	
	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListGetNth(ZLList list, int32 index, void* objectType)
{
	ZLListItem		item = NULL;
	

	if (list == NULL)
		return (NULL);

    EnterCriticalSection(IL(list)->pCS);

	/* If the index is greater than the total count, then it does not exist. */
	if (index > IL(list)->count)
		return (NULL);

	item = ZLListFind(list, NULL, objectType, zLListFindForward);
	if (item != NULL)
	{
		while (--index >= 0 && item != NULL)
			item = ZLListFind(list, item, objectType, zLListFindForward);
	}

    LeaveCriticalSection(IL(list)->pCS);

	return (item);
}


/*
	ZLListGetFirst()
	
	Returns the first object of objectType in the list. Returns NULL if the
	list is empty or if an object of the specified type does not exist.
	
	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListGetFirst(ZLList list, void* objectType)
{
	return (ZLListFind(list, NULL, objectType, zLListFindForward));
}


/*
	ZLListGetLast()
	
	Returns the last object of objectType in the list. Returns NULL if the
	list is empty or if an object of the specified type does not exist.
	
	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListGetLast(ZLList list, void* objectType)
{
	return (ZLListFind(list, NULL, objectType, zLListFindBackward));
}


/*
	ZLListGetNext()
	
	Returns the next object of the objectType in the list after the listItem
	entry. Returns NULL if no more objects exist in the list.
	
	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListGetNext(ZLList list, ZLListItem listItem, void* objectType)
{
	return (ZLListFind(list, listItem, objectType, zLListFindForward));
}


/*
	ZLListGetPrev()
	
	Returns the previous object of the objectType in the list before the
	listItem entry. Returns NULL if no more objects exist in the list.
	
	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListGetPrev(ZLList list, ZLListItem listItem, void* objectType)
{
	return (ZLListFind(list, listItem, objectType, zLListFindBackward));
}


/*
	ZLListEnumerate()
	
	Enumerates through all the objects in the list of objectType through the
	caller supplied enumFunc enumeration function. It passes along to the
	enumeration function the caller supplied userData parameter. It stops
	enumerating when the user supplied function returns TRUE and returns
	the list item in which the enumeration stopped.

	Use zLListAnyType as the object type when type is not important.
*/
ZLListItem	ZLListEnumerate(ZLList list, ZLListEnumFunc enumFunc,
					void* objectType, void* userData, int32 findOption)
{
	ZLListItem			item;
	
	
	if (list == NULL)
		return (NULL);
	
    EnterCriticalSection(IL(list)->pCS);

    item = ZLListFind(list, NULL, objectType, findOption);
	while (item != NULL)
	{
		if (enumFunc(item, II(item)->type, II(item)->data, userData) == TRUE)
			break;
		item = ZLListFind(list, item, objectType, findOption);
	}
	
    LeaveCriticalSection(IL(list)->pCS);

    return (item);
}


/*
	Returns the number of list items of the given type in the list. If
	objectType is zLListAnyType, it returns the total number of items in
	the list.
*/
int32		ZLListCount(ZLList list, void* objectType)
{
    ILList          pThis = IL(list);
	ILListItem		item;
	int32			count;


    if (pThis == NULL)
		return (0);
	
    EnterCriticalSection(pThis->pCS);

    if (objectType == zLListAnyType)
	{
        count = pThis->count;
	}
	else
	{
        count = 0;

        item = (ILListItem) ZLListGetFirst(list, objectType);
		while (item != NULL)
		{
			count++;
            item = (ILListItem) ZLListGetNext(list, item, objectType);
        }

    }

    LeaveCriticalSection(IL(list)->pCS);

    return (count);
}


/*
	Removes all objects of the given type from the list.
*/
void ZLListRemoveType(ZLList list, void* objectType)
{
	ZLListItem		item, next;


	if (list == NULL)
		return;
	
    EnterCriticalSection(IL(list)->pCS);

    item = ZLListGetFirst(list, objectType);
	while (item != NULL)
	{
		next = ZLListGetNext(list, item, objectType);
		ZLListRemove(list, item);
		item = next;
    }

    LeaveCriticalSection(IL(list)->pCS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonedebug\zdebug.c ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZDebug.c
 * Contents:	Implementation of debugging helper functions
 *
 *****************************************************************************/
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif


#include "ZoneDebug.h"


///////////////////////////////////////////////////////////////////////////////
// Debug level 
///////////////////////////////////////////////////////////////////////////////

BOOL                gDebugging = FALSE;

int __iDebugLevel = 0;

void __cdecl SetDebugLevel( int i )
{
    __iDebugLevel = i;
}


///////////////////////////////////////////////////////////////////////////////
// Assert functions
///////////////////////////////////////////////////////////////////////////////

static PFZASSERTHANDLER gpfAssertHandler = ZAssertDefaultHandler;


PFZASSERTHANDLER __stdcall ZAssertSetHandler( PFZASSERTHANDLER pHandler )
{
	PFZASSERTHANDLER pfOldHandler = gpfAssertHandler;
	gpfAssertHandler = pHandler;
	return pfOldHandler;
}


PFZASSERTHANDLER __stdcall ZAssertGetHandler()
{
	return gpfAssertHandler;
}


#ifdef _DEBUG
BOOL __stdcall ZAssertDefaultHandler( LPTSTR pAssertString )
{
    int ret;

    lstrcat( pAssertString, TEXT("\n\nClick...\n  Abort to exit\n  Retry to break\n  Ignore to continue") );
    ret = MessageBox(
			NULL,
			pAssertString,
			TEXT("Assertion failure"),
			MB_TASKMODAL | MB_ABORTRETRYIGNORE | MB_DEFBUTTON2 | MB_ICONSTOP | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION );
    switch (ret)
    {
    case IDABORT:
        ExitProcess(0);
        break;
    case IDRETRY:
        return TRUE;
        break;
    case IDIGNORE:
        return FALSE;
        break;
    }
    return TRUE;
}
#else
BOOL __stdcall ZAssertDefaultHandler( LPTSTR pAssertString )
{
    return TRUE;
}
#endif


BOOL __stdcall __AssertMsg( LPTSTR exp, LPSTR file, int line )
{
    TCHAR buf[1024];

	// note: the file is always an ANSI string
    wsprintf( buf, TEXT("Assertion Failed: %s\r\n\r\nFile: %hs, Line %d"), exp, file, line );

	if ( gpfAssertHandler )
		return gpfAssertHandler( buf );
	else
		return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Debug printing
//
// Note: There were extensive problems linking function when not compiled in .C
// file regardless of identitifiers used
///////////////////////////////////////////////////////////////////////////////

void __cdecl DbgOut( LPCSTR lpFormat, ... ) 
{
    CHAR szBuffer[1024];
    wvsprintfA( szBuffer, lpFormat, (LPSTR)(&lpFormat+1) );
    OutputDebugStringA( szBuffer );
}

void _DebugPrint(const char *format, ...)
{
    char szBuf[1024];
    char szFor[1024];
    DWORD bytes;
    HANDLE console;

    if ( !gDebugging )
        return;

    console = GetStdHandle( STD_OUTPUT_HANDLE );
    if ( INVALID_HANDLE_VALUE == console )
        return;

    //lstrcpy( szFor, &format[1] );
    wvsprintfA(szBuf, format, (LPSTR)(&format+1) );
    WriteConsoleA( console, szBuf, lstrlenA(szBuf), &bytes, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zmticket.h ===
/*******************************************************************************

	Zmticket.h
	
		Zone(tm) System Message.
	
	Copyright  Microsoft, Inc. 1997. All rights reserved.
	Written by John Smith
	
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
    ----------------------------------------------------------------------------
		0		06/29/97	JWS		Created.
		1		07/21/97	JWS	Added Two fields for Status
	 
*******************************************************************************/

// @doc ZONE

#ifndef _ZMTICKET_
#define _ZMTICKET_

#include "ztypes.h"

#ifdef __cplusplus
extern "C" {
#endif


/* Server -> Client */
typedef struct
{
	int			ErrorCode;
	int			AccountStatus;
	int			LastLogin;  
	int			ExpiryTime;
	uchar		UserName[zUserNameLen + 1];
	char		Ticket[1]; 		//Null terminated string for ticket
} ZMTicket;


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zhash.cpp ===
/*******************************************************************************

	ZHash.c
	
		Zone(tm) hash table module.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Thursday, March 16, 1995 03:58:26 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		03/16/95	HI		Created.
	 
*******************************************************************************/


#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "zone.h"
#include "zonedebug.h"
#include "pool.h"

#define I(object)				((IHashTable) (object))
#define Z(object)				((ZHashTable) (object))


typedef struct HashElementStruct
{
    struct HashElementStruct*	next;		/* Next key in hash chain */
    void*						key;		/* Pointer to key */
    void*						data;		/* Pointer to data */
} HashElementType, *HashElement;

typedef struct
{
    uint32					numBuckets;		/* Number of buckets */
    ZHashTableHashFunc		hashFunc;		/* Hash function */
    ZHashTableCompFunc		compFunc;		/* Comparator function */
    ZHashTableDelFunc		delFunc;		/* Delete function */
    CRITICAL_SECTION        pCS[1];
    HashElement*            table;          /* Actual hash table */
} IHashTableType, *IHashTable;

CPool<HashElementType> g_ElementPool(256);


/* -------- Internal Routines -------- */
static int32	HashKeyString(uint32 numBuckets, uchar* key);
static int32	HashKeyInt32(uint32 numBuckets, int32 key);
static int32	HashKey(IHashTable hashTable, void* key);
static ZBool    HashKeyComp(IHashTable hashTable, void* key1, void* key2);


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/
ZHashTable		ZHashTableNew(uint32 numBuckets, ZHashTableHashFunc hashFunc,
						ZHashTableCompFunc compFunc, ZHashTableDelFunc delFunc)
{
	IHashTable		obj = NULL;
	
	
	if (hashFunc != NULL && compFunc != NULL)
	{
		obj = (IHashTable) ZCalloc(1, sizeof(IHashTableType));
		if (obj != NULL)
		{
			obj->table = (HashElement*) ZCalloc(numBuckets,
					sizeof(HashElementType));
			if (obj->table != NULL)
			{
				obj->numBuckets = numBuckets;
				obj->hashFunc = hashFunc;
				obj->compFunc = compFunc;
				obj->delFunc = delFunc;
                InitializeCriticalSection(obj->pCS);
            }
			else
			{
				ZFree(obj);
				obj = NULL;
			}
		}
	}
	
	return (Z(obj));
}


void			ZHashTableDelete(ZHashTable hashTable)
{
    IHashTable      pThis = I(hashTable);
	HashElement		item, next;
	uint32			i;
	
	
    if (pThis == NULL)
		return;
		
    for (i = 0; i < pThis->numBuckets; i++)
    {
        EnterCriticalSection(pThis->pCS);
        if ((item = pThis->table[i]) != NULL)
		{
			while (item != NULL)
			{
				next = item->next;
                if (pThis->delFunc != NULL)
                    pThis->delFunc(item->key, item->data);

                item->next = NULL;
                delete item;
				item = next;
			}
		}
        LeaveCriticalSection(pThis->pCS);
    }
    DeleteCriticalSection(pThis->pCS);
    ZFree(pThis->table);
    ZFree(pThis);
}


ZError			ZHashTableAdd(ZHashTable hashTable, void* key, void* data)
{
    IHashTable      pThis = I(hashTable);
	HashElement		item;
	ZError			err = zErrNone;
	int32			bucket;
	
	
    if (pThis == NULL)
		return (zErrGeneric);

    item = new ( g_ElementPool ) HashElementType;
    bucket = HashKey(pThis, key);

	/* Check whether the key already exists in the table. */
    EnterCriticalSection(pThis->pCS);
    if (ZHashTableFind(hashTable, key) == NULL)
	{
        if (item != NULL)
		{
            item->next = pThis->table[bucket];
			item->key = key;
			item->data = data;

            pThis->table[bucket] = item;
            item = NULL;
		}
		else
		{
			err = zErrOutOfMemory;
		}
	}
	else
	{
		err = zErrDuplicate;
	}
    LeaveCriticalSection(pThis->pCS);

    // free it up if it wasn't inserted
    if ( item )
        delete item;

	return (err);
}


BOOL            ZHashTableRemove(ZHashTable hashTable, void* key)
{
    IHashTable      pThis = I(hashTable);
	HashElement		item, prev;
	int32			bucket;
	
	
    if (pThis == NULL)
        return FALSE;
	
    prev = NULL;
    bucket = HashKey(pThis, key);

    EnterCriticalSection(pThis->pCS);
    item = pThis->table[bucket];
	while (item != NULL)
	{
        if (HashKeyComp(pThis, item->key, key))
		{
            if (pThis->delFunc != NULL)
                pThis->delFunc(item->key, item->data);
			if (prev == NULL)
                pThis->table[bucket] = item->next;
			else
				prev->next = item->next;

            item->next = NULL;
            break;
		}
		prev = item;
		item = item->next;
	}
    LeaveCriticalSection(pThis->pCS);

    // free it up if it was found
    if ( item )
    {
        delete item;
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}


void*			ZHashTableFind(ZHashTable hashTable, void* key)
{
    IHashTable      pThis = I(hashTable);
    HashElement     item;
    int32           bucket;
    void*           data = NULL;
	
	
    if (pThis == NULL)
		return (NULL);

    bucket = HashKey(pThis, key);

    EnterCriticalSection(pThis->pCS);
    item = pThis->table[bucket];
	while (item != NULL)
	{
        if (HashKeyComp(pThis, item->key, key))
        {
            data = item->data;
            break;
        }
		item = item->next;
	}
    LeaveCriticalSection(pThis->pCS);

    return data;
}


void*			ZHashTableEnumerate(ZHashTable hashTable,
						ZHashTableEnumFunc enumFunc, void* userData)
{
    IHashTable      pThis = I(hashTable);
	HashElement		item;
    uint32          i;
    void*           data = NULL;
	
	
    if (pThis == NULL)
		return (NULL);

    // only lock a bucket at a time
    for (i = 0; i < pThis->numBuckets; i++)
	{
        EnterCriticalSection(pThis->pCS);
        if ((item = pThis->table[i]) != NULL)
		{
			while (item != NULL)
			{
                if (enumFunc(item->key, item->data, userData) == TRUE)
                {
                    data = item->data;
                    break;
                }
				item = item->next;
			}
		}
        LeaveCriticalSection(pThis->pCS);

        if ( data )
            break;
    }
	
    return data;
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/
static int32	HashKeyString(uint32 numBuckets, uchar* key)
{
    DWORD hash = 0;
	
    if ( key )
    {
        int i = 0;
        while( *key && ( i++ < 16 ) )
        {
            hash = (hash<<4)+hash+*key;  // multiple by 17 to get a good bit distribution
        }
	}
    return ( hash % numBuckets);

}


static int32	HashKeyInt32(uint32 numBuckets, int32 key)
{
	return (key % numBuckets);
}


static int32	HashKey(IHashTable hashTable, void* key)
{
	int32		keyValue;
	
	
	if (hashTable->hashFunc == zHashTableHashString)
		keyValue = HashKeyString(hashTable->numBuckets, (uchar*) key);
	else if (hashTable->hashFunc == zHashTableHashInt32)
		keyValue = HashKeyInt32(hashTable->numBuckets, (int32) key);
	else
		keyValue = hashTable->hashFunc(hashTable->numBuckets, key);
		
	return (keyValue);
}


static ZBool		HashKeyComp(IHashTable hashTable, void* key1, void* key2)
{
	ZBool		equal = FALSE;
	
	
	if (hashTable->compFunc == zHashTableCompString)
	{
        if (lstrcmp( (TCHAR*)key1,  (TCHAR*)key2) == 0)
			equal = TRUE;
	}
	else if (hashTable->compFunc == zHashTableCompInt32)
	{
		if ((int32) key1 == (int32) key2)
			equal = TRUE;
	}
	else
	{
		equal = hashTable->compFunc(key1, key2);
	}
	
	return (equal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zonecrt.c ===
/*******************************************************************************

	ZoneCRT.c
	
		Zone C RunTime.
	
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 13, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
    ----------------------------------------------------------------------------
	0		12/13/96	HI		Created.
	 
*******************************************************************************/
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
//#include <string.h>

#include "zonecrt.h"


/*******************************************************************************
		EXPORTED ROUTINES
*******************************************************************************/

void*	z_memcpy(void* dst, const void* src, size_t len)
{
    return (CopyMemory(dst, src, len));
}


int		z_memcmp(const void* dst, const void* src, size_t len)
{
	return (memcmp(dst, src, len));
}


void*	z_memset(void* dst, int c, size_t len)
{
    return (FillMemory(dst,len, (BYTE)c));
}


void*	z_memmove(void* dst, const void* src, size_t len)
{
    return (MoveMemory(dst, src, len));
}


char*	z_strcpy(char* dst, const char* src)
{
    return (lstrcpyA(dst, src));
}


char*	z_strcat(char* dst, const char* src)
{
    return (lstrcatA(dst, src));
}


int		z_strcmp(const char* dst, const char* src)
{
    return (lstrcmpA(dst, src));
}


size_t	z_strlen(const char* src)
{
    return (lstrlenA(src));
}


int		z_abs(int n)
{
	return (abs(n));
}


double	z_atof(const char* str)
{
	return (atof(str));
}


int		z_atoi(const char* str)
{
	return (atoi(str));
}


long	z_atol(const char* str)
{
	return (atol(str));
}


char*	z_itoa(int n, char* buf, int radix)
{
	return (itoa(n, buf, radix));
}


char*	z_ltoa(long n, char* buf, int radix)
{
	return (ltoa(n, buf, radix));
}


FILE*	z_fopen(const char* filename, const char* mode)
{
	return (fopen(filename, mode));
}


size_t	z_fread(void* buf, size_t size, size_t count, FILE* fd)
{
	return (fread(buf, size, count, fd));
}


int		z_fseek(FILE* fd, long offset, int origin)
{
	return (fseek(fd, offset, origin));
}


long	z_ftell(FILE* fd)
{
	return (ftell(fd));
}


size_t	z_fwrite(const void* buf, size_t size, size_t count, FILE* fd)
{
	return (fwrite(buf, size, count, fd));
}


int		z_fclose(FILE* fd)
{
	return (fclose(fd));
}


int		z_feof(FILE* fd)
{
	return (feof(fd));
}


char*	z_fgets(char* buf, int len, FILE* fd)
{
	return (fgets(buf, len, fd));
}


clock_t	z_clock(void)
{
	return (clock());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zoneint.h ===
/*******************************************************************************

	ZoneInt.h
	
		Zone(tm) Internal System API.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, April 29, 1995 06:26:45 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		04/29/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZONEINT_
#define _ZONEINT_


#ifndef _ZTYPES_
#include "ztypes.h"
#endif

#ifndef _ZONE_
#include "zone.h"
#endif


/* -------- Processor Types -------- */
enum
{
	zProcessor68K = 1,						/* Motorola 680x0 */
	zProcessorPPC,							/* PowerPC RISC */
	zProcessor80x86							/* Intel 80x86 */
};

/* -------- OS Types -------- */
enum
{
	zOSMacintosh = 1,						/* Macintosh OS */
	zOSWindows31,							/* Microsoft Windows3.1 */
	zOSWindowsNT,
	zOSWindows95,
	zOSUnixLinux
};

/* -------- Group IDs -------- */
#include "user_prefix.h"


#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
		Private File Routines
*******************************************************************************/
ZImage ZCreateImageFromFileOffset(char* fileName, int32 fileOffset);
ZAnimation ZCreateAnimationFromFileOffset(char* fileName, int32 fileOffset);
ZSound ZCreateSoundFromFileOffset(char* fileName, int32 fileOffset);
	/*
		The above routines create an object from the existing object descriptor
		at fileOffset in the given file. If fileOffset is -1, then it creates
		the object from the first object descriptor found in the file.
	*/


/*******************************************************************************
		Private ZAnimation Routines
*******************************************************************************/
ZAnimation ZAnimationCreateFromFile(char* fileName, int32 fileOffset);


/*******************************************************************************
		Private System Routines
*******************************************************************************/
ZError ZLaunchProgram(char* programName, char* programFileName, uchar* commandLineData);
	/*
		Runs the program called programName from the file programFileName. If programName
		is already running, it simply brings this process to the foreground. Otherwise,
		it runs an instance of programFileName as programName and passes commandLineData
		as command line.
	*/

ZError ZTerminateProgram(char* programName, char* programFileName);
	/*
		Terminates the program called programName, an instance of programFileName.
	*/

ZBool ZProgramExists(char* programFileName);
	/*
		Determines whether the given program exists and returns TRUE if so.
	*/

ZBool ZProgramIsRunning(char* programName, char* programFileName);
	/*
		Returns TRUE if the program programName is already running from programFileName.
		This call is system dependent on whether the system supports multiple instances of
		a program or not (ZSystemHasMultiInstanceSupport). If it does, then it checks for
		the programName of the instance. If not, it checks for an instance of programFileName.
		
		If programName is NULL, then it checks for an instance of programFileName only.
	*/

ZBool ZSystemHasMultiInstanceSupport(void);
	/*
		Returns TRUE if the system can spawn multiple instances of a program from one
		program file.
	*/

uint16 ZGetProcessorType(void);
	/*
		Returns the processor type of the running machine.
	*/

uint16 ZGetOSType(void);
	/*
		Returns the running OS type.
	*/

char* ZGenerateDataFileName(char* programName, char* dataFileName);
	/*
		Returns a file path name to the specified program and data file within the
		Zone(tm) directory structure.
		
		NOTE: The caller must not free the returned pointer. The returned pointer
		is a static global within the system library.
	*/



/*******************************************************************************
		Common Library Routines
*******************************************************************************/
typedef void (*ZCommonLibExitFunc)(void* userData);
	/*
		Function called by ZCommonLibExit() to clean up common library storage.
	*/

typedef void (*ZCommonLibPeriodicFunc)(void* userData);
	/*
		Function called regularly for common library to do periodic processing.
	*/

ZError ZCommonLibInit(void);
	/*
		Called by the system lib to initialize the common library. If it returns
		an error, then the system lib terminates the program.
	*/
	
void ZCommonLibExit(void);
	/*
		Called by the system lib just before quitting to clean up the common library.
	*/
	
void ZCommonLibInstallExitFunc(ZCommonLibExitFunc exitFunc, void* userData);
	/*
		Installs an exit function to be called by ZCommonLibExit(). It allows
		common lib modules to easily clean themselves up.
	*/
	
void ZCommonLibRemoveExitFunc(ZCommonLibExitFunc exitFunc);
	/*
		Removes an installed exit function.
	*/
	
void ZCommonLibInstallPeriodicFunc(ZCommonLibPeriodicFunc periodicFunc,
		void* userData);
	/*
		Installs a periodic function to be called at regular intervals. This
		simply makes it easier for common lib modules to do periodic processing
		without the need to implement one of their own.
	*/
	
void ZCommonLibRemovePeriodicFunc(ZCommonLibPeriodicFunc periodicFunc);
	/*
		Removes an installed periodic function.
	*/



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zping.h ===
#ifndef _ZPING_H
#define _ZPING_H

#ifdef __cplusplus
extern "C" {
#endif

BOOL ZonePingStartupServer( );

BOOL ZonePingStartupClient( DWORD ping_interval_sec );

BOOL ZonePingShutdown( );

BOOL ZonePingAdd( DWORD inet );

BOOL ZonePingNow( DWORD inet );

BOOL ZonePingRemove( DWORD inet );

BOOL ZonePingLookup( DWORD inet, DWORD* pLatency );

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zping.cpp ===
#include <windows.h>
#include "zone.h"
#include "zonedebug.h"
#include "pool.h"

#include "stdio.h"

const DWORD ZONE_PING_SENDS   = 1;
const DWORD ZONE_PING_TIMEOUT = 2000;
const short ZONE_PING_PORT = 28800;

#define ZONE_PING_SIG    2
#define ZONE_PING_VER    1

#define ZONE_PING_TYPE_PING                  0
#define ZONE_PING_TYPE_PING_RESPONSE         1
#define ZONE_PING_TYPE_RESPONSE_RESPONSE     2
#define ZONE_PING_TYPE_PING_NO_RESPONSE      3


// Ping info is stuffed into 1 DWORD as follow
//              3                   2                   1
//            1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
// Pinger-Pingee tick                               |-----------------------|
// Pingee-Pinger tick     |-----------------------|
// type               |-|
// ver            |-|
// sig(10)    |-|

typedef DWORD ZonePingPacket;

const DWORD PrePingSigVerPacket = (ZONE_PING_SIG << 30) | (ZONE_PING_VER << 28 );
const DWORD PrePingPacket = PrePingSigVerPacket | ( ZONE_PING_TYPE_PING << 26 );
const DWORD PrePingResponsePacket = PrePingSigVerPacket | ( ZONE_PING_TYPE_PING_RESPONSE << 26 );
const DWORD PrePingNoResponsePacket = PrePingSigVerPacket | ( ZONE_PING_TYPE_PING_NO_RESPONSE << 26 );
const DWORD PreResponseResponsePacket = PrePingSigVerPacket | ( ZONE_PING_TYPE_RESPONSE_RESPONSE << 26 );

#define MAKE_PING_PACKET( StartTick ) \
    ( (ZonePingPacket) ( PrePingPacket | ( StartTick & 0x1FFF ) ) )

#define MAKE_PING_RESPONSE_PACKET( packet, StartTick ) \
    ( (ZonePingPacket) ( PrePingResponsePacket | ( ( StartTick & 0x1FFF ) << 13 ) | (packet & 0x000001FFF ) ) )

#define MAKE_PING_NO_RESPONSE_PACKET( packet, StartTick ) \
    ( (ZonePingPacket) ( PrePingNoResponsePacket | ( ( StartTick & 0x1FFF ) << 13 ) | (packet & 0x000001FFF ) ) )

#define MAKE_RESPONSE_RESPONSE_PACKET( packet, measuredTick, adjustedTick ) \
    ( (ZonePingPacket) ( PreResponseResponsePacket | ( (adjustedTick & 0x1FFF) << 13 ) | (measuredTick & 0x000001FFF ) ) )

#define PING_PACKET_SIG_VER_OK( packet ) \
    ( ( packet & 0xF0000000 ) == PrePingSigVerPacket )

#define PING_PACKET_PINGER_PINGEE_TICK( packet ) \
    ( packet & 0x1FFF )

#define PING_PACKET_PINGEE_PINGER_TICK( packet ) \
    ( ( packet >> 13 ) & 0x1FFF )

#define PING_PACKET_TYPE( packet ) \
    ( ( packet >> 26 ) & 0x3 )


class ZonePing
{
    public: 
        ZonePing(DWORD inet = 0);

        DWORD     m_inet;
        DWORD     m_latency;
        DWORD     m_samples;
        DWORD     m_tick;
        long      m_refCount;

        enum PINGSTATE { UNKNOWN, PINGER, PINGEE };
        PINGSTATE m_state;

        ZonePing* m_pNext;
};

ZonePing::ZonePing(DWORD inet /*= 0*/) :
    m_inet(inet), m_latency(INFINITE),
    m_samples(0), m_tick(0), m_refCount(1),
    m_pNext(NULL), m_state(UNKNOWN)
{
}

CPool <ZonePing> g_PingPool(10);

class CPing
{
    public:
        CPing();
        ~CPing();

        BOOL StartupServer( );
        BOOL StartupClient( DWORD ping_interval_sec );
        BOOL Shutdown( );

        // TODO figure out where hight byte or low byte is x.x.x.XXX
        BOOL Add( DWORD inet );
        BOOL Ping( DWORD inet );
        BOOL Remove( DWORD inet );
        BOOL Lookup( DWORD inet, DWORD* pLatency );
                
    protected:
        inline DWORD  GetListIndex(DWORD inet) { return ( inet & 0x000000FF ) % m_PingIntervalSec; }
        inline DWORD  GetTickDelta( DWORD now, DWORD then )
            {
                if ( now >= then )
                {
                    return now - then;
                }
                else
                {
                    return INFINITE - then + now;
                }
            }

        inline DWORD  Get13BitTickDelta( DWORD now, DWORD then )
            {
                if ( now >= then )
                {
                    return now - then;
                }
                else
                {
                    return 0x1FFF - then + now;
                }
            }

        inline BOOL    IsLocal( DWORD inet )
            {
                for ( int ndx = 0; ndx < sizeof(m_inetLocal)/sizeof(*m_inetLocal); ndx++ )
                {
                    if ( inet == m_inetLocal[ndx] )
                        return TRUE;
                }
                return FALSE;
            }

        BOOL    CreateSocket();

        ZonePing* m_PingArray;
        DWORD     m_PingEntries;

        DWORD*    m_inetArray;
        DWORD     m_inetAlloc;

        DWORD  m_PingIntervalSec;
        DWORD  m_CurInterval;

        SOCKET m_Socket;
        BOOL   m_bWellKnownPort;
        HANDLE m_hWellKnownPortEvent;

        HANDLE m_hStopEvent;
        CRITICAL_SECTION m_pCS[1];

        HANDLE m_hPingerThread;
        HANDLE m_hPingeeThread;

        static DWORD WINAPI PingerThreadProc( LPVOID p );
        static DWORD WINAPI PingeeThreadProc( LPVOID p );

        void PingerThread();
        void PingeeThread();

        HANDLE m_hStartupMutex;
        long   m_refCountStartup;

        DWORD  m_inetLocal[4];  // allow up to 4 ip address
};

CPing g_Ping;

CPing::CPing() :
    m_PingArray(NULL), m_PingEntries(0),
    m_PingIntervalSec(0), m_CurInterval(0),
    m_Socket(INVALID_SOCKET), m_bWellKnownPort(TRUE), m_hStopEvent(NULL),
    m_hPingerThread(NULL), m_hPingeeThread(NULL),
    m_hStartupMutex(NULL),
    m_refCountStartup(0),
    m_inetArray(NULL), m_inetAlloc( 0 )
{
}

CPing::~CPing()
{
    if ( m_hStartupMutex )
    {
        CloseHandle( m_hStartupMutex );
    }
}

BOOL CPing::CreateSocket()
{
    SOCKADDR_IN sin;
    BOOL bRet = FALSE;

    m_Socket = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( m_Socket != INVALID_SOCKET )
    {

        // if we can not bind to the port, the user probably has an other
        // process instance open using the port, so remote clients are
        // able to successfully ping us.  So we can get our latency measurement
        // to them by using another port - of course if the first instance
        // goes away, the remote users are hosed...
            m_bWellKnownPort = TRUE;
            sin.sin_port = htons(ZONE_PING_PORT);
            sin.sin_family = AF_INET;
            sin.sin_addr.s_addr = INADDR_ANY;
        retry:
            if ( SOCKET_ERROR == bind( m_Socket,
                                       (const struct sockaddr FAR *) &sin,	
                                       sizeof(sin) ) )
            {
                if ( m_bWellKnownPort )
                {
                    m_bWellKnownPort = FALSE;
                    sin.sin_port = htons(0);
                    goto retry;
                }
            }
            else
            {
                bRet = TRUE;
            }
    }
    return bRet;
}

BOOL CPing::StartupServer( )
{

    HANDLE hStartupMutex = CreateMutex( NULL, FALSE, _T("ZonePingStartupMutex") );
    if ( !hStartupMutex )
        return FALSE;

    WaitForSingleObject( hStartupMutex, INFINITE );
    if ( !m_hStartupMutex )
        m_hStartupMutex = hStartupMutex;
    else
        CloseHandle( hStartupMutex ); // use m_hStartupMutex from now on

    m_refCountStartup++;
    if ( m_refCountStartup == 1 )
    {
        InitializeCriticalSection( m_pCS );

        WSADATA wsa;
        if ( WSAStartup(MAKEWORD(1,1), &wsa ) != 0 )
            goto shutdown;


        ZeroMemory( m_inetLocal, sizeof(m_inetLocal) );
        char hostname[256] = "localhost";
        gethostname( hostname, sizeof(hostname) );
        struct hostent* host = gethostbyname( hostname );
        if ( host )
        {
            for ( int ndx = 0; host->h_addr_list[ndx]; ndx++ )
            {
                if ( ndx >= sizeof(m_inetLocal)/sizeof(*m_inetLocal) )
                    break;

                m_inetLocal[ndx] = ntohl( *((unsigned long*)(host->h_addr_list[ndx])) );
            }
        }


        m_hStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if ( !m_hStopEvent )
            goto shutdown;

        if ( !CreateSocket() )
            goto shutdown;

        m_hWellKnownPortEvent = CreateEvent(NULL, TRUE, FALSE, _T("ZonePingWellKnownPortEvent") );
        if ( !m_hWellKnownPortEvent )
            goto shutdown;

        DWORD tid;
        m_hPingeeThread = CreateThread(NULL, 4096, PingeeThreadProc, this, 0, &tid);
        if ( !m_hPingeeThread )
            goto shutdown;

    }

    ReleaseMutex(m_hStartupMutex);
    return TRUE;

  shutdown:
    Shutdown();
    ReleaseMutex(m_hStartupMutex);
    return FALSE;
} 

BOOL CPing::StartupClient( DWORD ping_interval_sec )
{
    if ( !m_hStartupMutex )
        return FALSE;

    WaitForSingleObject( m_hStartupMutex, INFINITE );

    if ( ( ping_interval_sec ) && ( m_PingIntervalSec == 0 ) )
    {

        m_PingIntervalSec = ping_interval_sec;
        if ( m_PingIntervalSec / (ZONE_PING_TIMEOUT/1000) == 0 )
        {
            m_PingIntervalSec = ZONE_PING_TIMEOUT/1000;
        }

        m_CurInterval = m_PingIntervalSec;
        m_PingArray = new ZonePing[m_PingIntervalSec];
        if ( !m_PingArray )
            goto shutdown;

        DWORD tid;
        m_hPingerThread = CreateThread(NULL, 4096, PingerThreadProc, this, 0, &tid);
        if ( !m_hPingerThread )
            goto shutdown;
    }

    ReleaseMutex(m_hStartupMutex);
    return TRUE;

  shutdown:
    Shutdown();
    ReleaseMutex(m_hStartupMutex);
    return FALSE;
} 

BOOL CPing::Shutdown()
{
    if ( m_hStartupMutex )
    {
        WaitForSingleObject( m_hStartupMutex, INFINITE );
        m_refCountStartup--;

        if ( m_refCountStartup == 0 )
        {
            EnterCriticalSection(m_pCS);

            if ( m_hStopEvent )
            {
                SetEvent( m_hStopEvent );

                closesocket( m_Socket );
                m_Socket = INVALID_SOCKET;

                if ( m_hPingerThread )
                {
                    WaitForSingleObject( m_hPingerThread, 5000 );
                    CloseHandle( m_hPingerThread );
                    m_hPingerThread = NULL;

                    if ( m_inetArray )
                    {
                        delete [] m_inetArray;
                        m_inetArray = NULL;
                    }
                    m_inetAlloc = 0;
                }

                if ( m_hPingeeThread )
                {
                    WaitForSingleObject( m_hPingeeThread, 5000 );
                    CloseHandle( m_hPingeeThread );
                    m_hPingeeThread = NULL;
                }

                CloseHandle( m_hStopEvent );
                m_hStopEvent = NULL;

            }

            if ( m_hWellKnownPortEvent )
            {
                if ( m_bWellKnownPort )
                {
                    //printf( "Setting wellknown event\n" );
                    SetEvent( m_hWellKnownPortEvent );
                }
                CloseHandle( m_hWellKnownPortEvent );
                m_hWellKnownPortEvent = NULL;
            }

            if ( m_PingArray )
            {
                for ( DWORD ndx = 0; ndx < m_PingIntervalSec; ndx++ )
                {
                    ZonePing* pPing = m_PingArray[ndx].m_pNext;
                    while ( pPing )
                    {
                        ZonePing* pThis = pPing;
                        pPing = pPing->m_pNext;
                        delete pThis;
                    }
                }
                delete [] m_PingArray;
                m_PingArray = NULL;
            }
            m_PingEntries = 0;
            m_PingIntervalSec = 0;

            LeaveCriticalSection(m_pCS);
            DeleteCriticalSection( m_pCS );

            WSACleanup();
        }

        ReleaseMutex(m_hStartupMutex);
    }
    return TRUE;
}


BOOL CPing::Add( DWORD inet )
{

    if ( IsLocal( inet ) )
        return TRUE;

    DWORD ndx = GetListIndex( inet );

    // we'll create one assuming that we're going to us it.
    // Do it hear so we don't do it in the critical section
    ZonePing* pPingNew = new (g_PingPool) ZonePing( inet );

    if ( pPingNew  )
    {
        EnterCriticalSection(m_pCS);

        if ( m_PingArray )
        {
            // first check to see if we already exist
            ZonePing* pPing = m_PingArray[ndx].m_pNext;
            while ( pPing )
            {
                if ( pPing->m_inet == inet )
                {
                    pPing->m_refCount++;
                    break;
                }
                pPing = pPing->m_pNext;
            }

            if ( !pPing ) // only null if we don't already exist
            {
                // ref count set in constructor
                pPingNew->m_pNext = m_PingArray[ndx].m_pNext;
                m_PingArray[ndx].m_pNext = pPingNew;
                m_PingEntries++;
                pPingNew = NULL; // be sure to null out local point so we don't delete it later
            }

            LeaveCriticalSection(m_pCS);

            if ( pPingNew )
                delete pPingNew;

            return TRUE;
        }
        else
        {
            LeaveCriticalSection(m_pCS);
        }
    }
    return FALSE;
}

BOOL CPing::Ping( DWORD inet )
{
    if ( IsLocal( inet ) )
        return TRUE;

    SOCKADDR_IN sin;
    sin.sin_port = htons(ZONE_PING_PORT);
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(inet);

    for ( DWORD ndx = 0; ndx < ZONE_PING_SENDS; ndx++ )
    {
        if ( ndx != 0 )
            Sleep(20); // provide a slight delay between iterations

        ZonePingPacket packet = MAKE_PING_PACKET( GetTickCount() );
        int len = sendto (
            m_Socket,
            (const char FAR *) &packet,
            sizeof(packet),
            0,
            (const struct sockaddr FAR *) &sin,
            sizeof(sin)
           );

        if ( len == SOCKET_ERROR )
            return FALSE;

    }

    return TRUE;
}

BOOL CPing::Remove( DWORD inet )
{

    BOOL  bRet = FALSE;
    DWORD ndx  = GetListIndex( inet );

    EnterCriticalSection(m_pCS);

    if ( m_PingArray )
    {
        ZonePing* pPrev = &(m_PingArray[ndx]);
        ZonePing* pPing = m_PingArray[ndx].m_pNext;
        while ( pPing )
        {
            if ( pPing->m_inet == inet )
            {
                pPing->m_refCount--;
                if ( pPing->m_refCount <= 0 )
                {
                    pPrev->m_pNext = pPing->m_pNext;
                    delete pPing;
                    m_PingEntries--;
                }
                bRet = TRUE;
                break;
            }
            pPrev = pPing;
            pPing = pPing->m_pNext;
        }
    }

    LeaveCriticalSection(m_pCS);

    if ( !bRet && IsLocal( inet ) )
        bRet = TRUE;

    return bRet;

}

BOOL CPing::Lookup( DWORD inet, DWORD* pLatency )
{
    BOOL  bRet = FALSE;
    DWORD ndx  = GetListIndex( inet );

    EnterCriticalSection(m_pCS);

    if ( m_PingArray )
    {
        ZonePing* pPing = m_PingArray[ndx].m_pNext;
        while ( pPing )
        {
            if ( pPing->m_inet == inet )
            {
                if ( pLatency )
                {
                    // give a grace period of 4*m_PingIntervalSec secs
                    DWORD now = GetTickCount();
                    if ( pPing->m_samples != 0 &&
                         (GetTickDelta( now, pPing->m_tick ) >
                           ((1000*m_PingIntervalSec)<<2) ) )
                    {
                        pPing->m_samples = 0;
                        pPing->m_latency = INFINITE;
                    }
                    *pLatency = pPing->m_latency;

                    //printf( "Lookup - %x  now:%x  then:%x  delta:%d latency:%d\n", inet, now, pPing->m_tick, GetTickDelta( now, pPing->m_tick ), *pLatency );
                    bRet = TRUE;
                }
                break;
            }
            pPing = pPing->m_pNext;
        }
    }

    LeaveCriticalSection(m_pCS);

    if ( !bRet && IsLocal( inet ) && pLatency )
    {
        *pLatency = 0;
        bRet = TRUE;
    }

    return bRet;
}
                

DWORD WINAPI CPing::PingerThreadProc( LPVOID p )
{
    ((CPing*)p)->PingerThread();
    ExitThread(0);
    return 0;
}

void CPing::PingerThread()
{
    HANDLE hEvents[] = { m_hStopEvent, m_hWellKnownPortEvent };

    SOCKADDR_IN sin;
    sin.sin_port = htons(ZONE_PING_PORT);
    sin.sin_family = AF_INET;

    DWORD dwWait = WAIT_OBJECT_0; // default to the stop event
  loop:
    do
    {

        // we want to allow a zone ping timeout between ping sends to try
        // avoiding significant contention on the critical section        
        for ( DWORD interval = 0; interval < ZONE_PING_TIMEOUT/1000; interval++ )
        {
            m_CurInterval++;
            if ( m_CurInterval >= m_PingIntervalSec )
                m_CurInterval = 0;

            for ( DWORD ndx = 0; ndx < ZONE_PING_SENDS; ndx++ )
            {
                if ( ndx != 0 )
                    Sleep(20); // provide a slight delay between iterations

                EnterCriticalSection(m_pCS);

                if ( m_PingArray )
                {
                    ZonePing* pPing = m_PingArray[m_CurInterval].m_pNext;
                    DWORD nInet = 0;
                    while ( pPing )
                    {
                        if ( pPing->m_state != ZonePing::PINGEE )
                        {
                            if ( nInet >= m_inetAlloc )
                            {
                                DWORD* array = new DWORD[m_inetAlloc+25];
                                if ( m_inetArray )
                                {
                                    CopyMemory( array, m_inetArray, m_inetAlloc*sizeof(DWORD) );
                                    delete [] m_inetArray;
                                }
                                m_inetArray = array;
                                m_inetAlloc += 25;
                            }
                            m_inetArray[nInet++] = pPing->m_inet;
                        }
                        pPing = pPing->m_pNext;
                    }
                    LeaveCriticalSection(m_pCS);

                    while( nInet )
                    {
                        nInet--;
                        sin.sin_addr.s_addr = htonl(m_inetArray[nInet]);
                        ZonePingPacket packet = MAKE_PING_PACKET( GetTickCount() );
                        int len = sendto (
                                m_Socket,
                                (const char FAR *) &packet,
                                sizeof(packet),
                                0,
                                (const struct sockaddr FAR *) &sin,
                                sizeof(sin)
                               );

                        if ( len == SOCKET_ERROR ) // stop event will be set, so let terminate end there
                            break;
                    }
                }
                else
                {
                    LeaveCriticalSection(m_pCS);
                    return;
                }

            }

        }

        dwWait = WaitForMultipleObjects( sizeof(hEvents)/sizeof(*hEvents), hEvents, FALSE, ZONE_PING_TIMEOUT );
    } while( dwWait == WAIT_TIMEOUT );


    // see if we are being signaled to take of the well known port
    if ( !m_bWellKnownPort && (dwWait == WAIT_OBJECT_0+1) )
    {
        //printf( "attempting to take over wellknown port\n" );
           
        DWORD tid;     
        ResetEvent( m_hWellKnownPortEvent );

        closesocket( m_Socket );
        m_Socket = INVALID_SOCKET;

        if ( m_hPingeeThread )
        {
            WaitForSingleObject( m_hPingeeThread, 5000 );
            CloseHandle( m_hPingeeThread );
            m_hPingeeThread = NULL;
        }

        if ( !CreateSocket() )
            goto shutdown;

        m_hPingeeThread = CreateThread(NULL, 4096, PingeeThreadProc, this, 0, &tid);
        if ( !m_hPingeeThread )
            goto shutdown;

        goto loop;

    }

  shutdown:
    ;
}


DWORD WINAPI CPing::PingeeThreadProc( LPVOID p )
{
    ((CPing*)p)->PingeeThread();
    ExitThread(0);
    return 0;
}

void CPing::PingeeThread()
{
    char buf[100];
    ZonePingPacket* packetIn = (ZonePingPacket*)buf;
    ZonePingPacket  packetOut;
    SOCKADDR_IN sin;
    int sin_len = sizeof(sin);

    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );
    
    while (1)
    {
        BOOL bSendResponse = TRUE;
        int len = recvfrom ( 
                            m_Socket,	
                            buf,
                            sizeof(buf),
                            0,
                            (struct sockaddr FAR *) &sin,	
                            &sin_len 
                           ); 	

        if ( len == sizeof(*packetIn) &&
             PING_PACKET_SIG_VER_OK( (*packetIn) ) )
        {
            switch( PING_PACKET_TYPE( (*packetIn) ) )
            {
                case ZONE_PING_TYPE_PING:
                    if ( m_PingEntries )
                    {
                        packetOut = MAKE_PING_RESPONSE_PACKET( (*packetIn), GetTickCount() );
                    }
                    else
                    {
                        packetOut = MAKE_PING_NO_RESPONSE_PACKET( (*packetIn), GetTickCount() );
                    }
                    // don't worry about error condition
                    // recv will catch the socket close
                    sendto (
                        m_Socket,
                        (const char FAR *) &packetOut,
                        sizeof(packetOut),
                        0,	
                        (const struct sockaddr FAR *) &sin,	
                        sin_len 
                       );	
                    //OutputDebugString("ZONE_PING_TYPE_PING\n");
                    break;

                case ZONE_PING_TYPE_PING_NO_RESPONSE:
                    bSendResponse = FALSE;
                    // fall thru
                case ZONE_PING_TYPE_PING_RESPONSE:
                {
                    DWORD inet = ntohl(sin.sin_addr.s_addr);
                    DWORD now  = GetTickCount();
                    DWORD latencyOld, latencyNew;
                    EnterCriticalSection(m_pCS);
                    if ( m_PingArray )
                    {
                        DWORD ndx  = GetListIndex( inet );

                        ZonePing* pPing = m_PingArray[ndx].m_pNext;
                        while ( pPing )
                        {
                            if ( pPing->m_inet == inet )
                            {
                                latencyOld = pPing->m_latency;
                                if ( GetTickDelta(now, pPing->m_tick) > ZONE_PING_TIMEOUT )
                                {
                                    pPing->m_latency = 0;
                                    pPing->m_samples = 0;
                                }

                                latencyNew = ((pPing->m_latency*pPing->m_samples)+Get13BitTickDelta( (now & 0x1FFF), PING_PACKET_PINGER_PINGEE_TICK( (*packetIn) ) ))/(++pPing->m_samples);
                                if ( (pPing->m_samples == 1) && ( latencyNew > latencyOld ) ) // we've gotten worse
                                {
                                    // so bias for graceful degradation
                                    pPing->m_latency = ((latencyNew*pPing->m_samples)+latencyOld ) / (pPing->m_samples+1);
                                }
                                else
                                {
                                    pPing->m_latency = latencyNew;
                                }
                                pPing->m_tick = now;
                                
                                pPing->m_state = ZonePing::PINGER;

                                if ( bSendResponse )
                                {
                                    packetOut = MAKE_RESPONSE_RESPONSE_PACKET( (*packetIn),
                                                                                (pPing->m_latency),
                                                                                ( PING_PACKET_PINGEE_PINGER_TICK( (*packetIn) ) + GetTickDelta( GetTickCount(), now) ),
                                                                               );
                                }

                                LeaveCriticalSection(m_pCS);

                                if ( bSendResponse )
                                {
                                    // don't worry about error condition
                                    // recv will catch the socket close
                                    sendto (
                                        m_Socket,
                                        (const char FAR *) &packetOut,
                                        sizeof(packetOut),
                                        0,
                                        (const struct sockaddr FAR *) &sin,
                                        sin_len
                                       );
                                }

                                break;
                            }

                            pPing = pPing->m_pNext;

                        }
                        if ( pPing == NULL )
                        {
                            LeaveCriticalSection(m_pCS);
                        }
                    }
                    else
                    {
                        LeaveCriticalSection(m_pCS);
                    }
                    //OutputDebugString("ZONE_PING_TYPE_PING_RESPONSE\n");
                    break;
                }

                case ZONE_PING_TYPE_RESPONSE_RESPONSE:
                {    
                    DWORD inet = ntohl(sin.sin_addr.s_addr);
                    DWORD now  = GetTickCount();

                    EnterCriticalSection(m_pCS);
                    if ( m_PingArray )
                    {
                        DWORD ndx  = GetListIndex( inet );

                        ZonePing* pPing = m_PingArray[ndx].m_pNext;
                        while ( pPing )
                        {
                            if ( pPing->m_inet == inet )
                            {
                                if ( GetTickDelta(now, pPing->m_tick) > ZONE_PING_TIMEOUT )
                                {
                                    pPing->m_latency = 0;
                                    pPing->m_samples = 0;
                                }

                                pPing->m_samples += 2;
                                pPing->m_latency = ((pPing->m_latency*pPing->m_samples) +
                                              Get13BitTickDelta( (now & 0x1FFF), PING_PACKET_PINGEE_PINGER_TICK( (*packetIn) ) ) +
                                              PING_PACKET_PINGER_PINGEE_TICK( (*packetIn) )  )/(pPing->m_samples);
                                pPing->m_tick = now;

                                if ( pPing->m_state == ZonePing::UNKNOWN )
                                    pPing->m_state = ZonePing::PINGEE;
                                break;
                            }

                            pPing = pPing->m_pNext;

                        }
                    }
                    LeaveCriticalSection(m_pCS);

                    //OutputDebugString("ZONE_PING_TYPE_RESPONSE_RESPONSE\n");
                    break;
                }

            }
        }
        else if ( len == SOCKET_ERROR )
        {
            break;
        }

    }

}


#include "zping.h"

BOOL ZonePingStartupServer( )
{
    return g_Ping.StartupServer();
}

BOOL ZonePingStartupClient( DWORD ping_interval_sec )
{
    return g_Ping.StartupClient(ping_interval_sec);
}

BOOL ZonePingShutdown( )
{
    return g_Ping.Shutdown();
}

BOOL ZonePingAdd( DWORD inet )
{
    return g_Ping.Add(inet);
}

BOOL ZonePingNow( DWORD inet )
{
    return g_Ping.Ping(inet);
}

BOOL ZonePingRemove( DWORD inet )
{
    return g_Ping.Remove( inet );
}

BOOL ZonePingLookup( DWORD inet, DWORD* pLatency )
{
    return g_Ping.Lookup(inet, pLatency);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zutils.h ===
/*******************************************************************************

	zutils.h
	
	Copyright (c) Microsoft Corp. 1997. All rights reserved.
	Written by Hoon Im
	Created on 12/10/97

	Header file for zutils.c.
	 
*******************************************************************************/


#ifndef ZUTILS_H
#define ZUTILS_H

//#include "username.h"
#ifdef __cplusplus
extern "C" {
#endif


//char* GetActualUserName(char* userName);

BOOL FileExists(LPSTR fileName);


#ifdef __cplusplus
}
#endif


#endif // ZUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonelib\zutils.c ===
/*******************************************************************************

	ZUtils.c
	
		Utility routines.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im
	Created on Tuesday, September 5, 1995
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	1		10/23/96	RK		Added ZNetworkStrToAddr().
	0		09/05/95	HI		Created.
	 
*******************************************************************************/

#include <windows.h>
#include <ctype.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "zoneint.h"
#include "zutils.h"


/* -------- Globals -------- */


/* -------- Internal Routines -------- */


/*******************************************************************************
	EXPORTED ROUTINES
*******************************************************************************/

/*
	ZRandom()
	
	Returns a random number from 0 to range-1 inclusive.
*/
uint32 ZRandom(uint32 range)
{
	uint32			i, j;


	i = RAND_MAX / range;
	i *= range;
	while ((j = rand()) >= i)
		;
	
	return ((j % i) % range);
}


void ZStrCpyToLower(char* dst, char* src)
{
	while (*src)
		*dst++ = tolower(*src++);
	*dst = *src;
}


void ZStrToLower(char* str)
{
	ZStrCpyToLower(str, str);
}


DWORD ComputeTickDelta( DWORD now, DWORD then )
{
    if ( now < then )
    {
        return INFINITE - then + now;
    }
    else
    {
        return then - now;
    }
}

// now in ZoneString.lib
//char* GetActualUserName(char* userName)
//{
//    return ZGetActualUserName( userName );
//}

BOOL FileExists(LPSTR fileName)
{
	HANDLE hFile;


	// Try to open the file.
	if ((hFile = CreateFileA(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
		return (TRUE);
	}

	return (FALSE);
}


/*******************************************************************************
	INTERNAL ROUTINES
*******************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonemem\pool.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Pool.cpp
 *
 * Contents:	Implementation of fixed sized memory allocator
 *
 *****************************************************************************/

#include <windows.h>
#include "ZoneDebug.h"
#include "ZoneMem.h"
#include "Pool.h"
#include "Sentinals.h"


///////////////////////////////////////////////////////////////////////////////
// Implementation of CPoolVoid
///////////////////////////////////////////////////////////////////////////////

#define ZMallocPadding  (sizeof(DWORD) * 3)


ZONECALL CPoolVoid::CPoolVoid( DWORD ObjectSize, DWORD IncrementCnt, BOOL DebugMode )
{
    SYSTEM_INFO SystemInfo;
    DWORD TotalBytes, Pages, TotalPageBytes;

    // Verify and adjust arguments
    //
    if ( ObjectSize < sizeof(Link) )
    {
        ASSERT( ObjectSize >= sizeof(Link) );
        ObjectSize = sizeof(Link);
    }
    if ( IncrementCnt <= 0 )
    {
        ASSERT( IncrementCnt > 0 );
        IncrementCnt = 1;
    }

    // make object size a multiple of 4 to align on dword boundaries
    //
    ObjectSize = (ObjectSize + 3) & ~3;

    m_ObjectsAllocated = 0;
    m_BlockList = NULL;
    m_ExtraFreeLink = NULL;
    m_FreeList = NULL;
    m_DebugMode = DebugMode;
    if ( m_DebugMode )
    {
        m_ObjectSize = ObjectSize + (sizeof(DWORD) * 2);
        m_TrailerOffset = ObjectSize;
    }
    else
    {
        m_ObjectSize = ObjectSize;
        m_TrailerOffset = 0;
    }
    InitializeCriticalSection( &m_Lock );

    // Adjust ObjectsPerGrow (IncrementCnt) to match page size
    //
    GetSystemInfo( &SystemInfo );
    TotalBytes = sizeof(Block) + ZMallocPadding + (m_ObjectSize * IncrementCnt);
    Pages = TotalBytes / SystemInfo.dwPageSize;
    while ((Pages * SystemInfo.dwPageSize) < TotalBytes)
        Pages++;

    TotalPageBytes = Pages * SystemInfo.dwPageSize;

    m_ObjectsPerBlock = (TotalPageBytes - sizeof(Block) - ZMallocPadding) / m_ObjectSize;
    ASSERT( m_ObjectsPerBlock > 0 );
    m_BytesPerBlock = sizeof(Block) + ZMallocPadding + (m_ObjectsPerBlock * m_ObjectSize);
    ASSERT( m_BytesPerBlock <= TotalPageBytes );
}


ZONECALL CPoolVoid::~CPoolVoid( )
{
    Block* pBlock;
    Block* pNext;

    ASSERT( m_ObjectsAllocated == 0 );
    EnterCriticalSection( &m_Lock );
        for( pBlock = m_BlockList; pBlock; pBlock = pNext )
        {
            pNext = pBlock->m_pNext;
            ZFree( pBlock );
        }
    DeleteCriticalSection( &m_Lock );
}


HRESULT ZONECALL CPoolVoid::Init()
{
    EnterCriticalSection( &m_Lock );
        if ( !_GrowAlreadyLocked() )
        {
            LeaveCriticalSection( &m_Lock );
            return E_OUTOFMEMORY;
        }
    LeaveCriticalSection( &m_Lock );
    return NOERROR;
}


void* ZONECALL CPoolVoid::Alloc()
{
    Link* p = (Link*) InterlockedExchange( (LPLONG) &m_ExtraFreeLink, NULL );
    if ( p == NULL )
    {
        EnterCriticalSection( &m_Lock );
            if ( !m_FreeList )
            {
                // pool empty, need more objects
                if ( !_GrowAlreadyLocked() )
                {
                    LeaveCriticalSection( &m_Lock );
                    return NULL;
                }
            }
            p = m_FreeList;
            m_FreeList = p->m_pNext;
            p->m_pNext = (Link*)0xeeeeeeee;  // reset debug memory stamp
        LeaveCriticalSection( &m_Lock );
    }
    InterlockedIncrement( (LPLONG) &m_ObjectsAllocated );

    if ( m_DebugMode )
    {
        if ( *((DWORD*)(((BYTE*) p) - sizeof(DWORD))) != POOL_FREE )
        {
            ASSERT( !"CPoolVoid: Bad object in free list." );
            return NULL;
        }
        if ( *((DWORD*)(((BYTE*) p) + m_TrailerOffset)) != POOL_TRAILER )
        {
            ASSERT( !"CPoolVoid: Bad object in free list" );
            return NULL;
        }
        *((DWORD*)(((BYTE*) p) - sizeof(DWORD))) = POOL_HEADER;
        *((DWORD*)(((BYTE*) p) + m_TrailerOffset)) = POOL_TRAILER;
    }

    return p;
}


void ZONECALL CPoolVoid::Free( void* pInstance )
{
    Link* p = (Link*) pInstance;

    if ( m_DebugMode )
    {
        if ( *((DWORD*)(((BYTE*) p) - sizeof(DWORD))) != POOL_HEADER )
        {
            ASSERT( !"CPoolVoid: Double delete or memory overrun error" );
            return;
        }
        if ( *((DWORD*)(((BYTE*) p) + m_TrailerOffset)) != POOL_TRAILER )
        {
            ASSERT( !"CPoolVoid: Memory overrun error" );
            return;
        }
        *((DWORD*)(((BYTE*) p) - sizeof(DWORD))) = POOL_FREE;
    }

    p = (Link*) InterlockedExchange( (LPLONG) &m_ExtraFreeLink, (LONG) p);
    if ( p != NULL )
    {
        EnterCriticalSection( &m_Lock );
            p->m_pNext = m_FreeList;
            m_FreeList = p;
        LeaveCriticalSection( &m_Lock );
    }
    InterlockedDecrement( (LPLONG) &m_ObjectsAllocated );    
}


void ZONECALL CPoolVoid::_FreeWithHeader( void* pInstance )
{
    GenericPoolBlobHeader* pBlob = ((GenericPoolBlobHeader*) pInstance) - 1;
        
    ASSERT( pBlob->m_Tag == POOL_POOL_BLOB );
    ASSERT( pBlob->m_Val == (long) this );

    pBlob->m_Tag = POOL_ALREADY_FREED;
    pBlob->m_Val = 0;
    Free( (void *) pBlob );
}


BOOL ZONECALL CPoolVoid::Grow()
{
    EnterCriticalSection( &m_Lock );
        BOOL status = _GrowAlreadyLocked();
    LeaveCriticalSection( &m_Lock );
    return status;
}


void ZONECALL CPoolVoid::Shrink()
{
    // removed for now
}


//////////////////////////////////////////////////////////////////////////
// Private functions
//
// Note: These functions assume the pool has been locked by
//       the calling procedure.
//////////////////////////////////////////////////////////////////////////

BOOL ZONECALL CPoolVoid::_GrowAlreadyLocked()
{
    Block* pBlock;
    BYTE* pByte;
    Link* pLink;

    // allocate new block of memory
    pBlock = (Block *) ZMalloc( m_BytesPerBlock );
    if (!pBlock)
    {
        dprintf( "ZMalloc error: %d\n", GetLastError() );
        return FALSE;
    }
    FillMemory( pBlock, m_BytesPerBlock, 0xEE );
    pBlock->m_pNext = m_BlockList;
    m_BlockList = pBlock;

    // turn remaining memory into objects
    pByte = (BYTE *)(pBlock + 1);

    if ( m_DebugMode )
    {
        for (DWORD cnt = 0; cnt < m_ObjectsPerBlock; cnt++)
        {
            *((DWORD*) pByte) = POOL_FREE;
            *((DWORD*) (pByte + sizeof(DWORD) + m_TrailerOffset)) = POOL_TRAILER;
            
            pLink = (Link *)(pByte + sizeof(DWORD));
            pLink->m_pNext = m_FreeList;
            m_FreeList = pLink;
            pByte += m_ObjectSize;
        }
    }
    else
    {
        for (DWORD cnt = 0; cnt < m_ObjectsPerBlock; cnt++)
        {
            pLink = (Link *) pByte;
            pLink->m_pNext = m_FreeList;
            m_FreeList = pLink;
            pByte += m_ObjectSize;
        }
    }
    ASSERT( pByte <= (((BYTE*) pBlock) + m_BytesPerBlock) );

    return TRUE;
}



//////////////////////////////////////////////////////////////////////////
// CDataPool class implementation
//////////////////////////////////////////////////////////////////////////

ZONECALL CDataPool::CDataPool( size_t largest, size_t smallest /*= 32*/, BOOL bDebug /*= FALSE*/  ) :
    m_numPools(0),
    m_pools(NULL),
    m_smallest2(0),
    m_largest2(0)
{
    if ( largest != 0 )  // setting largest to 0 turns off pooling
    {

        while( smallest > 1)
        {
            m_smallest2++;
            smallest = smallest >> 1;
        }
        ASSERT( m_smallest2 );

        while( largest )
        {
            m_largest2++;
            largest = largest >> 1;
        }
        ASSERT( m_largest2 >= m_smallest2 );


        m_numPools = m_largest2-m_smallest2+1;
        m_pools = new CPoolVoid*[m_numPools];
        ASSERT( m_pools );

        for ( BYTE ndx = 0; ndx< m_numPools; ndx++ )
        {
            DWORD size = 1<<(ndx+m_smallest2);
            DWORD numObj = (4096-16)/size;
            if ( numObj <= 8 )
                 numObj = max( 2, ((8192-16)/size) );

            m_pools[ndx] = new CPoolVoid( size, numObj, bDebug );
            ASSERT( m_pools[ndx] );
        }
    }

#if POOL_STATS
    ZeroMemory(m_stats, sizeof(m_stats) );
    m_allocs = 0;
    m_frees = 0;
#endif
}

ZONECALL CDataPool::~CDataPool()
{
    if ( m_pools )
    {
        for ( BYTE ndx = 0; ndx < m_numPools; ndx++ )
        {
            delete m_pools[ndx];
        }
        delete [] m_pools;
        m_pools = NULL;
    }

    m_numPools = 0;

}


char* ZONECALL CDataPool::Alloc( size_t sz )
{
#if POOL_STATS  
    m_allocs++;

    if ( sz >= (64<<6) )
    {
        m_stats[64]++;
    }
    else
    {
        m_stats[sz>>6]++;
    }
#endif

    char* ptr = NULL;



    if ( (sz >= (size_t)(1<<m_largest2)) || (m_numPools==0) )
    {
        ptr = (char*) ZMalloc( sz+1 );
    }
    else
    {
        size_t size = sz >> m_smallest2;
        int ndx = 0;
        while( size )
        {
            ndx++;
            size = size>>1;
        }
        ptr = (char*) m_pools[ndx]->Alloc();
    }

    if ( ptr )
    {
        ptr[sz] = (char)-1; // we're guarenteed to have at least 1 free byte, so why not use a sentinal
    }

    return ptr;
}


char* ZONECALL CDataPool::Realloc(char* pBuf, size_t szOld, size_t szNew)
{
    char* pNew = NULL;


    ASSERT( (!pBuf && !szOld ) || (pBuf[szOld] == (char)-1) );  // check to make sure sentinal is intact

    if ( pBuf && (szNew <= szOld) )
    {
        // don't allocate from a smaller pool
        pNew = pBuf;
    }
    else
    {

        if ( (szOld >= (size_t)(1<<m_largest2)) || (m_numPools==0) )
        {
            pNew = (char*) ZRealloc( pBuf, szNew+1 );
        }
        else
        {
            // we now know that the new buffer is larger than the old
            // but how much larger is the question?

            size_t sizeOld = szOld >> m_smallest2;
            size_t sizeNew = szNew >> m_smallest2;

            int ndx = 0;
            while( sizeOld )
            {
                ndx++;
                sizeOld = sizeOld>>1;
                sizeNew = sizeNew>>1;
            }

            if ( ( pBuf ) && ( sizeOld == sizeNew ) )
            {
                pNew = pBuf;
            }
            else
            {
                pNew = Alloc(szNew);
                if ( pNew && pBuf )
                {
                    CopyMemory( pNew, pBuf, szOld );
                    Free( pBuf, szOld );
                }
            }
        }
    }


    if ( pNew )
    {
        pNew[szNew] = (char)-1;  // move sentinal
    }

    return pNew;
}


void ZONECALL CDataPool::Free( char* pInst, size_t sz )
{
#if POOL_STATS
    m_frees++;
    ASSERT ( m_frees <= m_allocs );
#endif
    ASSERT( pInst[sz] == (char)-1 );  // check to make sure sentinal is intact

    if ( (sz >= (size_t)(1<<m_largest2)) || (m_numPools==0) )
    {
        ZFree( pInst );
    }
    else
    {
        size_t size = sz >> m_smallest2;
        int ndx = 0;
        while( size )
        {
            ndx++;
            size = size>>1;
        }
        m_pools[ndx]->Free( pInst );
    }

}

void ZONECALL CDataPool::Grow()
{
    for ( BYTE ndx = 0; ndx< m_numPools; ndx++ )
    {
        m_pools[ndx]->Grow();
    }
}

void ZONECALL CDataPool::Shrink()
{
    for ( BYTE ndx = 0; ndx< m_numPools; ndx++ )
    {
        m_pools[ndx]->Shrink();
    }
}


void ZONECALL CDataPool::PrintStats()
{
#if POOL_STATS
    char szBuf[256];
    lstrcpyA( szBuf, "\n" );
    WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), szBuf, lstrlen(szBuf)+1, &bytes, NULL );

    for ( int ndx = 0; ndx <64; ndx++ )
    {
        wsprintfA( szBuf, "<%d - allocs %d\n", (ndx+1) << 6, m_stats[ndx] );
        WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), szBuf, lstrlen(szBuf)+1, &bytes, NULL );
    }

    wsprintfA( szBuf, ">=%d - allocs %d\n", (ndx+1) << 6, m_stats[ndx] );
    WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), szBuf, lstrlen(szBuf)+1, &bytes, NULL );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonemem\new.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		new.cpp
 *
 * Contents:	New & delete wrappers for pools and debugging
 *
 *****************************************************************************/


#include <windows.h>
#include "ZoneDebug.h"
#include "ZoneMem.h"
#include "Pool.h"
#include "Sentinals.h"


void* ZONECALL _zone_new( size_t sz )
{
    GenericPoolBlobHeader* p;

    if ( sz == 0 )
        return NULL;
	
	if (p = (GenericPoolBlobHeader*) ZMalloc( sizeof(GenericPoolBlobHeader) + sz ))
	{
		p->m_Tag = POOL_HEAP_BLOB;
		return (p + 1);
	}
	else
		return NULL;
}


//
// C++ only has one delete operator so it has to deal with
// all of our allocation methods.
//
void __cdecl operator delete (void * pInstance )
{
    GenericPoolBlobHeader* p;

    if (!pInstance)
        return;

    p = ((GenericPoolBlobHeader*) pInstance) - 1;
    switch( p->m_Tag )
    {
	case POOL_HEAP_BLOB:
        p->m_Tag = POOL_ALREADY_FREED;
        ZFree(p);
        break;

    case POOL_POOL_BLOB:
        ((CPoolVoid*) p->m_Val)->_FreeWithHeader( pInstance );
        break;

    case POOL_ALREADY_FREED:
        ASSERT( !"delete: Double delete error" );
        break;

    default:
        ASSERT( !"delete: Unknown memory type, possible double delete error" );
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonemem\sentinals.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		sentials.h (private)
 *
 * Contents:	Zone's memory sentials
 *
 *****************************************************************************/

#ifndef _SENTINALS_H_
#define _SENTINALS_H_


//
// Memory block sentinals
//
#define ZMEMORY_BLOCK_BEGIN_SIG		'meMZ'
#define ZMEMORY_BLOCK_END_SIG		'dnEZ'
#define ZMEMORY_BLOCK_FREE_SIG		'erFZ'
#define ZMEMORY_PREBLOCK_SIZE		(2 * sizeof(DWORD))
#define ZMEMORY_POSTBLOCK_SIZE		(sizeof(DWORD))

//
// Pool block sentinals
//
#define POOL_HEADER		'LOOP'
#define POOL_TRAILER	'DNEP'
#define POOL_FREE		'ERFP'


#endif //_SENTINALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonemem\zmemory.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		zmemory.cpp
 * Contents:	Debug wrappers for memory allocation
 *
 *****************************************************************************/


#include "ZoneDebug.h"
#include "ZoneMem.h"
#include "sentinals.h"

 
//
// Performance counters
//
extern "C" _int64 g_TotalMalloc = 0;
extern "C" DWORD  g_CurrentMalloc = 0;


void* ZONECALL ZMalloc( size_t size )
{
    char* pMalloc = (char*) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE);
    if (pMalloc)
    {
#ifdef DEBUG
        g_TotalMalloc   += size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE;
        g_CurrentMalloc += size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE;
#endif
        ((DWORD*) pMalloc)[0] = ZMEMORY_BLOCK_BEGIN_SIG;
        ((DWORD*) pMalloc)[1] = size;
        ((DWORD*) (pMalloc + size + ZMEMORY_PREBLOCK_SIZE))[0] = ZMEMORY_BLOCK_END_SIG;
        return (void*)( pMalloc + ZMEMORY_PREBLOCK_SIZE );
    }
    else
    {
		ASSERT(!"ZMalloc: HeapAlloc returned NULL");
        return (NULL);
    }
}


void* ZONECALL ZCalloc( size_t num, size_t size )
{
    DWORD sz = num*size;
    void* pCalloc = ZMalloc(sz);
    if (pCalloc)
        ZeroMemory(pCalloc, sz);
    return pCalloc;
}


void* ZONECALL ZRealloc( void* ptr, size_t size )
{
    char* pOld;
    char* pRealloc;

    if ( ptr )
    {
        pOld = (char*)ptr-ZMEMORY_PREBLOCK_SIZE;
        ASSERT( *((DWORD*)(pOld)) == ZMEMORY_BLOCK_BEGIN_SIG );
        ASSERT( *((DWORD*)((char*)ptr+((DWORD*)pOld)[1])) == ZMEMORY_BLOCK_END_SIG );
    }
    else
    {
        pOld = NULL;
    }

    if ( pOld )
    {
#ifdef DEBUG
        g_TotalMalloc   += size-((DWORD*)pOld)[1];
        g_CurrentMalloc += size-((DWORD*)pOld)[1];
#endif
        pRealloc = (char*) HeapReAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, pOld, size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE);
    }
    else
    {
#ifdef DEBUG
        g_TotalMalloc   += size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE;
        g_CurrentMalloc += size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE;
#endif
        pRealloc = (char*) HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE);
    }

    ASSERT(pRealloc);
    if (pRealloc)
    {
        ((DWORD*) pRealloc)[0] = ZMEMORY_BLOCK_BEGIN_SIG;
        ((DWORD*) pRealloc)[1] = size;
        ((DWORD*) (pRealloc+size+ZMEMORY_PREBLOCK_SIZE))[0] = ZMEMORY_BLOCK_END_SIG;
        return (void*)(pRealloc+ZMEMORY_PREBLOCK_SIZE);
    }
    else
    {
		ASSERT( !"ZRealloc: HeapAlloc returned NULL" );
        return (NULL);
    }
}


void ZONECALL ZFree( void* ptr )
{
    ASSERT(ptr);
    if (ptr)
    {
        ptr = (char*)ptr-ZMEMORY_PREBLOCK_SIZE;
        ASSERT( *((DWORD*)(ptr)) == ZMEMORY_BLOCK_BEGIN_SIG );
        ASSERT( *((DWORD*)((char*)ptr+((DWORD*)ptr)[1]+ZMEMORY_PREBLOCK_SIZE)) == ZMEMORY_BLOCK_END_SIG );

        if ( *((DWORD*)(ptr)) == ZMEMORY_BLOCK_BEGIN_SIG )
        {
#ifdef DEBUG
            g_CurrentMalloc -= ((DWORD*)ptr)[1]+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE;
#endif
            *((DWORD*) ptr) = ZMEMORY_BLOCK_FREE_SIG;
            *((DWORD*)((char*)ptr+((DWORD*)ptr)[1]+ZMEMORY_PREBLOCK_SIZE)) = 0;
            HeapFree(GetProcessHeap(), 0, ptr );
        }
    }
}


void ZONECALL ZMemValidate( void* ptr )
{
    ASSERT(ptr);
    if (ptr)
    {
        ptr = (char*)ptr-ZMEMORY_PREBLOCK_SIZE;
        ASSERT( *((DWORD*)(ptr)) == ZMEMORY_BLOCK_BEGIN_SIG );
        ASSERT( *((DWORD*)((char*)ptr+((DWORD*)ptr)[1]+ZMEMORY_PREBLOCK_SIZE)) == ZMEMORY_BLOCK_END_SIG );
    }
}


size_t ZONECALL ZMemSize(void* ptr)
{
    ASSERT(ptr);
    if (ptr)
    {
        ptr = (char*)ptr-ZMEMORY_PREBLOCK_SIZE;
        ASSERT( *((DWORD*)(ptr)) == ZMEMORY_BLOCK_BEGIN_SIG );
        ASSERT( *((DWORD*)((char*)ptr+((DWORD*)ptr)[1]+ZMEMORY_PREBLOCK_SIZE)) == ZMEMORY_BLOCK_END_SIG );
        size_t sz = ((DWORD*) ptr)[1];
        ASSERT( (sz+ZMEMORY_PREBLOCK_SIZE+ZMEMORY_POSTBLOCK_SIZE) == HeapSize( GetProcessHeap(), 0, ptr ) );
        return sz;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonestring\locale.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Locale.cpp
 *
 * Contents:	Locale aware string functions
 *
 *****************************************************************************/

#include "ZoneString.h"


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Character type checking routines that use the Windows GetStringTypeEx API
// rather than the CRT's.  All functions are locale aware.
//
//	Return Values
//		true/false
//
//////////////////////////////////////////////////////////////////////////////////////////////

bool ZONECALL IsWhitespace( TCHAR c, LCID Locale )
{
	WORD wType;
	GetStringTypeEx(Locale, CT_CTYPE1, &c, 1, &wType);
	return (wType & (C1_SPACE | C1_BLANK)) != 0;
}

bool ZONECALL IsDigit( TCHAR c, LCID Locale )
{
	WORD wType;
	GetStringTypeEx(Locale, CT_CTYPE1, &c, 1, &wType);
	return (wType & C1_DIGIT) != 0;
}

bool ZONECALL IsAlpha(TCHAR c, LCID Locale )
{
	WORD wType;
	GetStringTypeEx(Locale, CT_CTYPE1, &c, 1, &wType);
	return (wType & C1_ALPHA) != 0;
}

///////////////////////////////////////////////////////////////////////////////
// 
// Convert string to guid
//
///////////////////////////////////////////////////////////////////////////////

HRESULT ZONECALL StringToGuid( const char* mbszGuid, GUID* pGuid )
{
	wchar_t wszGuid[ 128 ];
	MultiToWide( wszGuid, mbszGuid, sizeof(wszGuid) / 2 );
	return CLSIDFromString( wszGuid, pGuid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonestring\ascii.cpp ===
#include "ZoneString.h"
#include "UserPrefix.h"


/////////////////////////////////////////////////////////////////////////////////////////
//
//	HashUserName (ASCII)
//
//	Hash user name, ignoring leading character
//
//	Parameters
//		szUserName
//
//	Return Values
//		hash value for string
//
///////////////////////////////////////////////////////////////////////////////////////////
DWORD ZONECALL HashUserName( const char* szUserName )
{
	DWORD hash = 0;

	if ( szUserName )
	{
		// skip leading characters
		szUserName = GetActualUserNameA( szUserName );

		// hash next 16 characters of string
		for ( int i = 0; *szUserName && ( i++ < 16 ); szUserName++ )
		{
			// multiple by 17 to get a good bit distribution
			hash = (hash<<4) + hash + TOLOWER(*szUserName);
		}
	}
    return hash;

}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	CompareUserNames (ASCII)
//
//	Compare two user names, ignoring prefix characters and case
//
///////////////////////////////////////////////////////////////////////////////////////////
bool ZONECALL CompareUserNamesA( const char* szUserName1, const char* szUserName2 )
{
	// skip leading characters
	if ( ClassIdFromUserNameA(szUserName1) != zUserGroupID )
		szUserName1++;
	if ( ClassIdFromUserNameA(szUserName2) != zUserGroupID )
		szUserName2++;

	// finish with case-insensitive string compare
	return ( lstrcmpiA( szUserName1, szUserName2 ) == 0 );
}

bool ZONECALL CompareUserNamesW( const WCHAR* szUserName1, const WCHAR* szUserName2 )
{
	// skip leading characters
	if ( ClassIdFromUserNameW(szUserName1) != zUserGroupID )
		szUserName1++;
	if ( ClassIdFromUserNameW(szUserName2) != zUserGroupID )
		szUserName2++;

	// finish with case-insensitive string compare
	return ( lstrcmpiW( szUserName1, szUserName2 ) == 0 );
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	zatol (ASCII)
//
//	Converts string pointed to by nptr to binary. Overflow is not detected.
//
//	Parameters
//		nptr = ptr to string to convert
//
//	Return Values
//		return long int value of the string
//
///////////////////////////////////////////////////////////////////////////////////////////
long ZONECALL zatolW(LPCWSTR nptr)
{
    WCHAR c;            // current char
    long total = 0;		// current total
    WCHAR sign;         // if '-', then negative, otherwise positive
    long base = 10;

    // skip whitespace
	while ( ISSPACE(*nptr) )
        ++nptr;

	// save sign if present
    c = *nptr++;
    sign = c;
    if (c == '-' || c == '+')
        c = *nptr++;

    // find base
    if(c == '0')
    {
//      base = 8;    might be nice, but afraid to add it because i don't know if leading zeros are already in use
        c = *nptr++;
        if(c == 'x' || c == 'X')
        {
            base = 16;
            c = *nptr++;
        }
    }

	// accumulate number
    while(base == 16 ? ISXDIGIT(c) : ISDIGIT(c))
	{
        total = base * total + (ISDIGIT(c) ? c - '0' : TOLOWER(c) - 'a' + 10);
        c = *nptr++;
    }

	// return result, negated if necessary
    if (sign == '-')
        return -total;
    else
        return total;
}


long ZONECALL zatolA(LPCSTR nptr)
{
    CHAR c;            // current char
    long total = 0;		// current total
    CHAR sign;         // if '-', then negative, otherwise positive
    long base = 10;

    // skip whitespace
	while ( ISSPACE(*nptr) )
        ++nptr;

	// save sign if present
    c = *nptr++;
    sign = c;
    if (c == '-' || c == '+')
        c = *nptr++;

    // find base
    if(c == '0')
    {
//      base = 8;    might be nice, but afraid to add it because i don't know if leading zeros are already in use
        c = *nptr++;
        if(c == 'x' || c == 'X')
        {
            base = 16;
            c = *nptr++;
        }
    }

	// accumulate number
    while(base == 16 ? ISXDIGIT(c) : ISDIGIT(c))
	{
        total = base * total + (ISDIGIT(c) ? c - '0' : TOLOWER(c) - 'a' + 10);
        c = *nptr++;
    }

	// return result, negated if necessary
    if (sign == '-')
        return -total;
    else
        return total;
}


///////////////////////////////////////////////////////////////////////////////
//
// strtrim (ASCII)
//
// Removes leading and trailing whitespace.  Returns pointer to first
// non-whitespace chatacter.
//
///////////////////////////////////////////////////////////////////////////////
char* ZONECALL strtrim(char *str)
{
  if ( !str )
	  return NULL;

  // skip leading spaces
  while ( ISSPACE(*str) )
	  str++;

  // find last non-whitespace character
  for ( char *last = NULL, *p = str; *p; p++ )
  {
	  if ( !ISSPACEA(*p) )
		  last = p;
  }
  if ( last )
	  *(last + 1) = '\0';

  return str;
}


WCHAR* ZONECALL strtrim(WCHAR *str)
{
  if ( !str )
	  return NULL;

  // skip leading spaces
  while ( ISSPACEW(*str) )
	  str++;

  // find last non-whitespace character
  for ( WCHAR *last = NULL, *p = str; *p; p++ )
  {
	  if ( !ISSPACEW(*p) )
		  last = p;
  }
  if ( last )
	  *(last + 1) = '\0';

  return str;
}


///////////////////////////////////////////////////////////////////////////////
//
// strrtrim (ASCII)
//
// Removes trailing whitespace.  Returns pointer to last non-whitespace
// character.
//
///////////////////////////////////////////////////////////////////////////////
char* ZONECALL strrtrimA(char *str)
{
  if ( !str )
	  return NULL;

  // find last non-whitespace character
  for ( char* last = NULL, *p = str; *p; p++ )
  {
	  if ( !ISSPACEA(*p) )
		  last = p;
  }

  // truncate string
  if ( last )
  {
	  *(last + 1) = '\0';
	  return last;
  }
  else
  {
	  *str = '\0';
	  return str;
  }
}


WCHAR* ZONECALL strrtrimW(WCHAR *str)
{
  if ( !str )
	  return NULL;

  // find last non-whitespace character
  for ( WCHAR* last = NULL, *p = str; *p; p++ )
  {
	  if ( !ISSPACEW(*p) )
		  last = p;
  }

  // truncate string
  if ( last )
  {
	  *(last + 1) = '\0';
	  return last;
  }
  else
  {
	  *str = '\0';
	  return str;
  }
}


///////////////////////////////////////////////////////////////////////////////
//
// strltrim (ASCII)
//
// remove leading whitespace, returns pointer to first non-whitespace character
//
///////////////////////////////////////////////////////////////////////////////
char* ZONECALL strltrimA(char *str)
{
    if( !str )
		return NULL;

	// skip leading spaces
	while ( ISSPACEA(*str) )
		str++;

	return str;
}

WCHAR* ZONECALL strltrimW(WCHAR *str)
{
    if( !str )
		return NULL;

	// skip leading spaces
	while ( ISSPACEW(*str) )
		str++;

	return str;
}

bool ZONECALL stremptyA(char *str)
{
    if( !str )
		return TRUE;

	// skip leading spaces
	while ( ISSPACEA(*str) )
		str++;

	return *str==NULL ? true:false;
}

bool ZONECALL stremptyW(WCHAR *str)
{
    if( !str )
		return TRUE;

	// skip leading spaces
	while ( ISSPACEW(*str) )
		str++;

	return *str==NULL ? true:false;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//	ClassIdFromUserName (ASCII)
//
//	Determine group id from user name prefix character
//
//	Parameters
//		szUserName
//
//	Return Values
//		GroupId
//
///////////////////////////////////////////////////////////////////////////////////////////
long ZONECALL ClassIdFromUserNameA( const char* szUserName )
{
	switch ( szUserName[0] )
	{
	case gcRootGroupNamePrefix:
		return zRootGroupID;
	case gcSysopGroupNamePrefix:
		return zSysopGroupID;
	case gcMvpGroupNamePrefix:
		return zMvpGroupID;
	case gcSupportGroupNamePrefix:
		return zSupportGroupID;
	case gcHostGroupNamePrefix:
		return zHostGroupID;
	case gcGreeterGroupNamePrefix:
		return zGreeterGroupID;
	default:
		return zUserGroupID;
	}
}

long ZONECALL ClassIdFromUserNameW( const WCHAR* szUserName )
{
	switch ( szUserName[0] )
	{
	case gcRootGroupNamePrefix:
		return zRootGroupID;
	case gcSysopGroupNamePrefix:
		return zSysopGroupID;
	case gcMvpGroupNamePrefix:
		return zMvpGroupID;
	case gcSupportGroupNamePrefix:
		return zSupportGroupID;
	case gcHostGroupNamePrefix:
		return zHostGroupID;
	case gcGreeterGroupNamePrefix:
		return zGreeterGroupID;
	default:
		return zUserGroupID;
	}
}


///////////////////////////////////////////////////////////////////////////////
//
// GetActualUserName (ASCII)
//
// return username without leading special characters ex. +Bear becomes Bear
//
///////////////////////////////////////////////////////////////////////////////
const char* ZONECALL GetActualUserNameA( const char* userName )
{
    while (		*userName
			&&	!(		(*userName == '_')
					||	(*userName >= 0 && *userName <= 9)
					||	(*userName >= 'A' && *userName <= 'Z')
					||	(*userName >= 'a' && *userName <= 'z') ) )
	{
		userName++;
	}

	return (userName);
}

const WCHAR* ZONECALL GetActualUserNameW( const WCHAR* userName )
{
    while (		*userName
			&&	!(		(*userName == '_')
					||	(*userName >= 0 && *userName <= 9)
					||	(*userName >= 'A' && *userName <= 'Z')
					||	(*userName >= 'a' && *userName <= 'z') ) )
	{
		userName++;
	}

	return (userName);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	FindChar (ASCII,UNICODE)		
//
//	Parameters
//		pString		String to search for char
//		ch			character to search for
//
//	Return Values
//		Pointer to first occurance of character.  NULL if the
//		end of data reached before character.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CHAR* ZONECALL FindCharA(CHAR* pString, const CHAR ch)
{
	while ( *pString && *pString != ch )
		pString++;
	return *pString ? pString : NULL;
}

WCHAR* ZONECALL FindCharW(WCHAR* pString, const WCHAR ch)
{
	while ( *pString && *pString != ch )
		pString++;
	return *pString ? pString : NULL;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	FindLastChar (ASCII,UNICODE)
//
//	Parameters
//		pString		String to search for char
//		ch			character to search for
//
//	Return Values
//		Pointer to last occurance of character.  NULL if the
//		end of data reached before character.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
CHAR* ZONECALL FindLastCharA(CHAR* pString, const CHAR ch)
{
	CHAR* pLast = NULL;
	while ( *pString )
	{
		if ( *pString == ch )
			pLast = pString;
		pString++;
	}
	return pLast;
}

WCHAR* ZONECALL FindLastCharW(WCHAR* pString, const WCHAR ch)
{
	WCHAR* pLast = NULL;
	while ( *pString )
	{
		if ( *pString == ch )
			pLast = pString;
		pString++;
	}
	return pLast;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	StrInStrI (ASCII,UNICODE)
//
//	Case insensitive substring search		
//
//	Parameters
//		mainStr	Main string to search in
//		subStr	Substring to search for
//
//	Return Values
//		The address of the first occurrence of the matching 
//		substring if successful, or NULL otherwise. 
//
////////////////////////////////////////////////////////////////////////////////////////////////////////
const TCHAR* ZONECALL StrInStrI(const TCHAR* mainStr, const TCHAR* subStr)
{
	int lenMain = lstrlen(mainStr);
	int lenSub = lstrlen(subStr);
	
	if(lenSub > lenMain)
		return NULL;


	for (int i = 0; i < (lenMain - lenSub + 1); i++)
	{
		if (CompareString(LOCALE_SYSTEM_DEFAULT,NORM_IGNORECASE,&mainStr[i],lenSub,subStr,lenSub) == CSTR_EQUAL)
		{
			return &mainStr[i];
		}
	}
	return NULL;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Copy(ASCII,UNICODE)
//
//	Copy from Unicode to ANSI 
//	Parameters
//		dest string 
//		src  string
//
//	Return Values
//		The address of the first occurrence of the matching 
//		substring if successful, or NULL otherwise. 
//
//  Notes that these are in this file rather than zonestring so CrtDbgReport or CLSIDFromString isnt dragged in
//
////////////////////////////////////////////////////////////////////////////////////////////////////////


int CopyW2A( LPSTR pszDst, LPCWSTR pszSrc )
{
    int cch = WideCharToMultiByte( CP_ACP, 0, pszSrc, -1, pszDst, 0, NULL, NULL );
    return WideCharToMultiByte( CP_ACP, 0, pszSrc, -1, pszDst, cch, NULL, NULL );
}

int CopyA2W( LPWSTR pszDst, LPCSTR pszStr )
{
    int cch = MultiByteToWideChar( CP_ACP, 0, pszStr, -1, pszDst, 0 );
    return MultiByteToWideChar( CP_ACP, 0, pszStr, -1, pszDst, cch );
}



///////////////////////////////////////////////////////////////////////////////
// ASCII lookup tables
///////////////////////////////////////////////////////////////////////////////

__declspec(selectany) char g_ToLowerLookupTable[] =
{
    (char) 0,
    (char) 1,
    (char) 2,
    (char) 3,
    (char) 4,
    (char) 5,
    (char) 6,
    (char) 7,
    (char) 8,
    (char) 9,
    (char) 10,
    (char) 11,
    (char) 12,
    (char) 13,
    (char) 14,
    (char) 15,
    (char) 16,
    (char) 17,
    (char) 18,
    (char) 19,
    (char) 20,
    (char) 21,
    (char) 22,
    (char) 23,
    (char) 24,
    (char) 25,
    (char) 26,
    (char) 27,
    (char) 28,
    (char) 29,
    (char) 30,
    (char) 31,
    (char) 32,
    (char) 33,
    (char) 34,
    (char) 35,
    (char) 36,
    (char) 37,
    (char) 38,
    (char) 39,
    (char) 40,
    (char) 41,
    (char) 42,
    (char) 43,
    (char) 44,
    (char) 45,
    (char) 46,
    (char) 47,
    (char) 48,    (char)  // 0 -> 0
    (char) 49,    (char)  // 1 -> 1
    (char) 50,    (char)  // 2 -> 2
    (char) 51,    (char)  // 3 -> 3
    (char) 52,    (char)  // 4 -> 4
    (char) 53,    (char)  // 5 -> 5
    (char) 54,    (char)  // 6 -> 6
    (char) 55,    (char)  // 7 -> 7
    (char) 56,    (char)  // 8 -> 8
    (char) 57,    (char)  // 9 -> 9
    (char) 58,
    (char) 59,
    (char) 60,
    (char) 61,
    (char) 62,
    (char) 63,
    (char) 64,
    (char) 97,    (char)  // A -> a
    (char) 98,    (char)  // B -> b
    (char) 99,    (char)  // C -> c
    (char) 100,   (char)  // D -> d
    (char) 101,   (char)  // E -> e
    (char) 102,   (char)  // F -> f
    (char) 103,   (char)  // G -> g
    (char) 104,   (char)  // H -> h
    (char) 105,   (char)  // I -> i
    (char) 106,   (char)  // J -> j
    (char) 107,   (char)  // K -> k
    (char) 108,   (char)  // L -> l
    (char) 109,   (char)  // M -> m
    (char) 110,   (char)  // N -> n
    (char) 111,   (char)  // O -> o
    (char) 112,   (char)  // P -> p
    (char) 113,   (char)  // Q -> q
    (char) 114,   (char)  // R -> r
    (char) 115,   (char)  // S -> s
    (char) 116,   (char)  // T -> t
    (char) 117,   (char)  // U -> u
    (char) 118,   (char)  // V -> v
    (char) 119,   (char)  // W -> w
    (char) 120,   (char)  // X -> x
    (char) 121,   (char)  // Y -> y
    (char) 122,   (char)  // Z -> z
    (char) 91,
    (char) 92,
    (char) 93,
    (char) 94,
    (char) 95,
    (char) 96,
    (char) 97,     (char) // a -> a
    (char) 98,     (char) // b -> b
    (char) 99,     (char) // c -> c
    (char) 100,    (char) // d -> d
    (char) 101,    (char) // e -> e
    (char) 102,    (char) // f -> f
    (char) 103,    (char) // g -> g
    (char) 104,    (char) // h -> h
    (char) 105,    (char) // i -> i
    (char) 106,    (char) // j -> j
    (char) 107,    (char) // k -> k
    (char) 108,    (char) // l -> l
    (char) 109,    (char) // m -> m
    (char) 110,    (char) // n -> n
    (char) 111,    (char) // o -> o
    (char) 112,    (char) // p -> p
    (char) 113,    (char) // q -> q
    (char) 114,    (char) // r -> r
    (char) 115,    (char) // s -> s
    (char) 116,    (char) // t -> t
    (char) 117,    (char) // u -> u
    (char) 118,    (char) // v -> v
    (char) 119,    (char) // w -> w
    (char) 120,    (char) // x -> x
    (char) 121,    (char) // y -> y
    (char) 122,    (char) // z -> z
    (char) 123,
    (char) 124,
    (char) 125,
    (char) 126,
    (char) 127,
    (char) 128,
    (char) 129,
    (char) 130,
    (char) 131,
    (char) 132,
    (char) 133,
    (char) 134,
    (char) 135,
    (char) 136,
    (char) 137,
    (char) 138,
    (char) 139,
    (char) 140,
    (char) 141,
    (char) 142,
    (char) 143,
    (char) 144,
    (char) 145,
    (char) 146,
    (char) 147,
    (char) 148,
    (char) 149,
    (char) 150,
    (char) 151,
    (char) 152,
    (char) 153,
    (char) 154,
    (char) 155,
    (char) 156,
    (char) 157,
    (char) 158,
    (char) 159,
    (char) 160,
    (char) 161,
    (char) 162,
    (char) 163,
    (char) 164,
    (char) 165,
    (char) 166,
    (char) 167,
    (char) 168,
    (char) 169,
    (char) 170,
    (char) 171,
    (char) 172,
    (char) 173,
    (char) 174,
    (char) 175,
    (char) 176,
    (char) 177,
    (char) 178,
    (char) 179,
    (char) 180,
    (char) 181,
    (char) 182,
    (char) 183,
    (char) 184,
    (char) 185,
    (char) 186,
    (char) 187,
    (char) 188,
    (char) 189,
    (char) 190,
    (char) 191,
    (char) 192,
    (char) 193,
    (char) 194,
    (char) 195,
    (char) 196,
    (char) 197,
    (char) 198,
    (char) 199,
    (char) 200,
    (char) 201,
    (char) 202,
    (char) 203,
    (char) 204,
    (char) 205,
    (char) 206,
    (char) 207,
    (char) 208,
    (char) 209,
    (char) 210,
    (char) 211,
    (char) 212,
    (char) 213,
    (char) 214,
    (char) 215,
    (char) 216,
    (char) 217,
    (char) 218,
    (char) 219,
    (char) 220,
    (char) 221,
    (char) 222,
    (char) 223,
    (char) 224,
    (char) 225,
    (char) 226,
    (char) 227,
    (char) 228,
    (char) 229,
    (char) 230,
    (char) 231,
    (char) 232,
    (char) 233,
    (char) 234,
    (char) 235,
    (char) 236,
    (char) 237,
    (char) 238,
    (char) 239,
    (char) 240,
    (char) 241,
    (char) 242,
    (char) 243,
    (char) 244,
    (char) 245,
    (char) 246,
    (char) 247,
    (char) 248,
    (char) 249,
    (char) 250,
    (char) 251,
    (char) 252,
    (char) 253,
    (char) 254,
    (char) 255
};


__declspec(selectany) unsigned char g_IsTypeLookupTableA[] = {
        _CONTROL,               /* 00 (NUL) */
        _CONTROL,               /* 01 (SOH) */
        _CONTROL,               /* 02 (STX) */
        _CONTROL,               /* 03 (ETX) */
        _CONTROL,               /* 04 (EOT) */
        _CONTROL,               /* 05 (ENQ) */
        _CONTROL,               /* 06 (ACK) */
        _CONTROL,               /* 07 (BEL) */
        _CONTROL,               /* 08 (BS)  */
        _SPACE|_CONTROL,        /* 09 (HT)  */
        _SPACE|_CONTROL,        /* 0A (LF)  */
        _SPACE|_CONTROL,        /* 0B (VT)  */
        _SPACE|_CONTROL,        /* 0C (FF)  */
        _SPACE|_CONTROL,        /* 0D (CR)  */
        _CONTROL,               /* 0E (SI)  */
        _CONTROL,               /* 0F (SO)  */
        _CONTROL,               /* 10 (DLE) */
        _CONTROL,               /* 11 (DC1) */
        _CONTROL,               /* 12 (DC2) */
        _CONTROL,               /* 13 (DC3) */
        _CONTROL,               /* 14 (DC4) */
        _CONTROL,               /* 15 (NAK) */
        _CONTROL,               /* 16 (SYN) */
        _CONTROL,               /* 17 (ETB) */
        _CONTROL,               /* 18 (CAN) */
        _CONTROL,               /* 19 (EM)  */
        _CONTROL,               /* 1A (SUB) */
        _CONTROL,               /* 1B (ESC) */
        _CONTROL,               /* 1C (FS)  */
        _CONTROL,               /* 1D (GS)  */
        _CONTROL,               /* 1E (RS)  */
        _CONTROL,               /* 1F (US)  */
        _SPACE+_BLANK,          /* 20 SPACE */
        _PUNCT,                 /* 21 !     */
        _PUNCT,                 /* 22 "     */
        _PUNCT,                 /* 23 #     */
        _PUNCT,                 /* 24 $     */
        _PUNCT,                 /* 25 %     */
        _PUNCT,                 /* 26 &     */
        _PUNCT,                 /* 27 '     */
        _PUNCT,                 /* 28 (     */
        _PUNCT,                 /* 29 )     */
        _PUNCT,                 /* 2A *     */
        _PUNCT,                 /* 2B +     */
        _PUNCT,                 /* 2C ,     */
        _PUNCT,                 /* 2D -     */
        _PUNCT,                 /* 2E .     */
        _PUNCT,                 /* 2F /     */
        _DIGIT|_HEX,            /* 30 0     */
        _DIGIT|_HEX,            /* 31 1     */
        _DIGIT|_HEX,            /* 32 2     */
        _DIGIT|_HEX,            /* 33 3     */
        _DIGIT|_HEX,            /* 34 4     */
        _DIGIT|_HEX,            /* 35 5     */
        _DIGIT|_HEX,            /* 36 6     */
        _DIGIT|_HEX,            /* 37 7     */
        _DIGIT|_HEX,            /* 38 8     */
        _DIGIT|_HEX,            /* 39 9     */
        _PUNCT,                 /* 3A :     */
        _PUNCT,                 /* 3B ;     */
        _PUNCT,                 /* 3C <     */
        _PUNCT,                 /* 3D =     */
        _PUNCT,                 /* 3E >     */
        _PUNCT,                 /* 3F ?     */
        _PUNCT,                 /* 40 @     */
        _UPPER|_HEX,            /* 41 A     */
        _UPPER|_HEX,            /* 42 B     */
        _UPPER|_HEX,            /* 43 C     */
        _UPPER|_HEX,            /* 44 D     */
        _UPPER|_HEX,            /* 45 E     */
        _UPPER|_HEX,            /* 46 F     */
        _UPPER,                 /* 47 G     */
        _UPPER,                 /* 48 H     */
        _UPPER,                 /* 49 I     */
        _UPPER,                 /* 4A J     */
        _UPPER,                 /* 4B K     */
        _UPPER,                 /* 4C L     */
        _UPPER,                 /* 4D M     */
        _UPPER,                 /* 4E N     */
        _UPPER,                 /* 4F O     */
        _UPPER,                 /* 50 P     */
        _UPPER,                 /* 51 Q     */
        _UPPER,                 /* 52 R     */
        _UPPER,                 /* 53 S     */
        _UPPER,                 /* 54 T     */
        _UPPER,                 /* 55 U     */
        _UPPER,                 /* 56 V     */
        _UPPER,                 /* 57 W     */
        _UPPER,                 /* 58 X     */
        _UPPER,                 /* 59 Y     */
        _UPPER,                 /* 5A Z     */
        _PUNCT,                 /* 5B [     */
        _PUNCT,                 /* 5C \     */
        _PUNCT,                 /* 5D ]     */
        _PUNCT,                 /* 5E ^     */
        _PUNCT,                 /* 5F _     */
        _PUNCT,                 /* 60 `     */
        _LOWER|_HEX,            /* 61 a     */
        _LOWER|_HEX,            /* 62 b     */
        _LOWER|_HEX,            /* 63 c     */
        _LOWER|_HEX,            /* 64 d     */
        _LOWER|_HEX,            /* 65 e     */
        _LOWER|_HEX,            /* 66 f     */
        _LOWER,                 /* 67 g     */
        _LOWER,                 /* 68 h     */
        _LOWER,                 /* 69 i     */
        _LOWER,                 /* 6A j     */
        _LOWER,                 /* 6B k     */
        _LOWER,                 /* 6C l     */
        _LOWER,                 /* 6D m     */
        _LOWER,                 /* 6E n     */
        _LOWER,                 /* 6F o     */
        _LOWER,                 /* 70 p     */
        _LOWER,                 /* 71 q     */
        _LOWER,                 /* 72 r     */
        _LOWER,                 /* 73 s     */
        _LOWER,                 /* 74 t     */
        _LOWER,                 /* 75 u     */
        _LOWER,                 /* 76 v     */
        _LOWER,                 /* 77 w     */
        _LOWER,                 /* 78 x     */
        _LOWER,                 /* 79 y     */
        _LOWER,                 /* 7A z     */
        _PUNCT,                 /* 7B {     */
        _PUNCT,                 /* 7C |     */
        _PUNCT,                 /* 7D }     */
        _PUNCT,                 /* 7E ~     */
        _CONTROL,               /* 7F (DEL) */

        /* and the rest are 0... */

        0,                      // 128,
        0,                      // 129,
        0,                      // 130,
        0,                      // 131,
        0,                      // 132,
        0,                      // 133,
        0,                      // 134,
        0,                      // 135,
        0,                      // 136,
        0,                      // 137,
        0,                      // 138,
        0,                      // 139,
        0,                      // 140,
        0,                      // 141,
        0,                      // 142,
        0,                      // 143,
        0,                      // 144,
        0,                      // 145,
        0,                      // 146,
        0,                      // 147,
        0,                      // 148,
        0,                      // 149,
        0,                      // 150,
        0,                      // 151,
        0,                      // 152,
        0,                      // 153,
        0,                      // 154,
        0,                      // 155,
        0,                      // 156,
        0,                      // 157,
        0,                      // 158,
        0,                      // 159,
        0,                      // 160,
        0,                      // 161,
        0,                      // 162,
        0,                      // 163,
        0,                      // 164,
        0,                      // 165,
        0,                      // 166,
        0,                      // 167,
        0,                      // 168,
        0,                      // 169,
        0,                      // 170,
        0,                      // 171,
        0,                      // 172,
        0,                      // 173,
        0,                      // 174,
        0,                      // 175,
        0,                      // 176,
        0,                      // 177,
        0,                      // 178,
        0,                      // 179,
        0,                      // 180,
        0,                      // 181,
        0,                      // 182,
        0,                      // 183,
        0,                      // 184,
        0,                      // 185,
        0,                      // 186,
        0,                      // 187,
        0,                      // 188,
        0,                      // 189,
        0,                      // 190,
        0,                      // 191,
        0,                      // 192,
        0,                      // 193,
        0,                      // 194,
        0,                      // 195,
        0,                      // 196,
        0,                      // 197,
        0,                      // 198,
        0,                      // 199,
        0,                      // 200,
        0,                      // 201,
        0,                      // 202,
        0,                      // 203,
        0,                      // 204,
        0,                      // 205,
        0,                      // 206,
        0,                      // 207,
        0,                      // 208,
        0,                      // 209,
        0,                      // 210,
        0,                      // 211,
        0,                      // 212,
        0,                      // 213,
        0,                      // 214,
        0,                      // 215,
        0,                      // 216,
        0,                      // 217,
        0,                      // 218,
        0,                      // 219,
        0,                      // 220,
        0,                      // 221,
        0,                      // 222,
        0,                      // 223,
        0,                      // 224,
        0,                      // 225,
        0,                      // 226,
        0,                      // 227,
        0,                      // 228,
        0,                      // 229,
        0,                      // 230,
        0,                      // 231,
        0,                      // 232,
        0,                      // 233,
        0,                      // 234,
        0,                      // 235,
        0,                      // 236,
        0,                      // 237,
        0,                      // 238,
        0,                      // 239,
        0,                      // 240,
        0,                      // 241,
        0,                      // 242,
        0,                      // 243,
        0,                      // 244,
        0,                      // 245,
        0,                      // 246,
        0,                      // 247,
        0,                      // 248,
        0,                      // 249,
        0,                      // 250,
        0,                      // 251,
        0,                      // 252,
        0,                      // 253,
        0,                      // 254,
        0,                      // 255
};



__declspec(selectany) WCHAR g_IsTypeLookupTableW[] = {
        _CONTROL,               /* 00 (NUL) */
        _CONTROL,               /* 01 (SOH) */
        _CONTROL,               /* 02 (STX) */
        _CONTROL,               /* 03 (ETX) */
        _CONTROL,               /* 04 (EOT) */
        _CONTROL,               /* 05 (ENQ) */
        _CONTROL,               /* 06 (ACK) */
        _CONTROL,               /* 07 (BEL) */
        _CONTROL,               /* 08 (BS)  */
        _SPACE|_CONTROL,        /* 09 (HT)  */
        _SPACE|_CONTROL,        /* 0A (LF)  */
        _SPACE|_CONTROL,        /* 0B (VT)  */
        _SPACE|_CONTROL,        /* 0C (FF)  */
        _SPACE|_CONTROL,        /* 0D (CR)  */
        _CONTROL,               /* 0E (SI)  */
        _CONTROL,               /* 0F (SO)  */
        _CONTROL,               /* 10 (DLE) */
        _CONTROL,               /* 11 (DC1) */
        _CONTROL,               /* 12 (DC2) */
        _CONTROL,               /* 13 (DC3) */
        _CONTROL,               /* 14 (DC4) */
        _CONTROL,               /* 15 (NAK) */
        _CONTROL,               /* 16 (SYN) */
        _CONTROL,               /* 17 (ETB) */
        _CONTROL,               /* 18 (CAN) */
        _CONTROL,               /* 19 (EM)  */
        _CONTROL,               /* 1A (SUB) */
        _CONTROL,               /* 1B (ESC) */
        _CONTROL,               /* 1C (FS)  */
        _CONTROL,               /* 1D (GS)  */
        _CONTROL,               /* 1E (RS)  */
        _CONTROL,               /* 1F (US)  */
        _SPACE+_BLANK,          /* 20 SPACE */
        _PUNCT,                 /* 21 !     */
        _PUNCT,                 /* 22 "     */
        _PUNCT,                 /* 23 #     */
        _PUNCT,                 /* 24 $     */
        _PUNCT,                 /* 25 %     */
        _PUNCT,                 /* 26 &     */
        _PUNCT,                 /* 27 '     */
        _PUNCT,                 /* 28 (     */
        _PUNCT,                 /* 29 )     */
        _PUNCT,                 /* 2A *     */
        _PUNCT,                 /* 2B +     */
        _PUNCT,                 /* 2C ,     */
        _PUNCT,                 /* 2D -     */
        _PUNCT,                 /* 2E .     */
        _PUNCT,                 /* 2F /     */
        _DIGIT|_HEX,            /* 30 0     */
        _DIGIT|_HEX,            /* 31 1     */
        _DIGIT|_HEX,            /* 32 2     */
        _DIGIT|_HEX,            /* 33 3     */
        _DIGIT|_HEX,            /* 34 4     */
        _DIGIT|_HEX,            /* 35 5     */
        _DIGIT|_HEX,            /* 36 6     */
        _DIGIT|_HEX,            /* 37 7     */
        _DIGIT|_HEX,            /* 38 8     */
        _DIGIT|_HEX,            /* 39 9     */
        _PUNCT,                 /* 3A :     */
        _PUNCT,                 /* 3B ;     */
        _PUNCT,                 /* 3C <     */
        _PUNCT,                 /* 3D =     */
        _PUNCT,                 /* 3E >     */
        _PUNCT,                 /* 3F ?     */
        _PUNCT,                 /* 40 @     */
        _UPPER|_HEX,            /* 41 A     */
        _UPPER|_HEX,            /* 42 B     */
        _UPPER|_HEX,            /* 43 C     */
        _UPPER|_HEX,            /* 44 D     */
        _UPPER|_HEX,            /* 45 E     */
        _UPPER|_HEX,            /* 46 F     */
        _UPPER,                 /* 47 G     */
        _UPPER,                 /* 48 H     */
        _UPPER,                 /* 49 I     */
        _UPPER,                 /* 4A J     */
        _UPPER,                 /* 4B K     */
        _UPPER,                 /* 4C L     */
        _UPPER,                 /* 4D M     */
        _UPPER,                 /* 4E N     */
        _UPPER,                 /* 4F O     */
        _UPPER,                 /* 50 P     */
        _UPPER,                 /* 51 Q     */
        _UPPER,                 /* 52 R     */
        _UPPER,                 /* 53 S     */
        _UPPER,                 /* 54 T     */
        _UPPER,                 /* 55 U     */
        _UPPER,                 /* 56 V     */
        _UPPER,                 /* 57 W     */
        _UPPER,                 /* 58 X     */
        _UPPER,                 /* 59 Y     */
        _UPPER,                 /* 5A Z     */
        _PUNCT,                 /* 5B [     */
        _PUNCT,                 /* 5C \     */
        _PUNCT,                 /* 5D ]     */
        _PUNCT,                 /* 5E ^     */
        _PUNCT,                 /* 5F _     */
        _PUNCT,                 /* 60 `     */
        _LOWER|_HEX,            /* 61 a     */
        _LOWER|_HEX,            /* 62 b     */
        _LOWER|_HEX,            /* 63 c     */
        _LOWER|_HEX,            /* 64 d     */
        _LOWER|_HEX,            /* 65 e     */
        _LOWER|_HEX,            /* 66 f     */
        _LOWER,                 /* 67 g     */
        _LOWER,                 /* 68 h     */
        _LOWER,                 /* 69 i     */
        _LOWER,                 /* 6A j     */
        _LOWER,                 /* 6B k     */
        _LOWER,                 /* 6C l     */
        _LOWER,                 /* 6D m     */
        _LOWER,                 /* 6E n     */
        _LOWER,                 /* 6F o     */
        _LOWER,                 /* 70 p     */
        _LOWER,                 /* 71 q     */
        _LOWER,                 /* 72 r     */
        _LOWER,                 /* 73 s     */
        _LOWER,                 /* 74 t     */
        _LOWER,                 /* 75 u     */
        _LOWER,                 /* 76 v     */
        _LOWER,                 /* 77 w     */
        _LOWER,                 /* 78 x     */
        _LOWER,                 /* 79 y     */
        _LOWER,                 /* 7A z     */
        _PUNCT,                 /* 7B {     */
        _PUNCT,                 /* 7C |     */
        _PUNCT,                 /* 7D }     */
        _PUNCT,                 /* 7E ~     */
        _CONTROL,               /* 7F (DEL) */

        /* and the rest are 0... */

        0,                      // 128,
        0,                      // 129,
        0,                      // 130,
        0,                      // 131,
        0,                      // 132,
        0,                      // 133,
        0,                      // 134,
        0,                      // 135,
        0,                      // 136,
        0,                      // 137,
        0,                      // 138,
        0,                      // 139,
        0,                      // 140,
        0,                      // 141,
        0,                      // 142,
        0,                      // 143,
        0,                      // 144,
        0,                      // 145,
        0,                      // 146,
        0,                      // 147,
        0,                      // 148,
        0,                      // 149,
        0,                      // 150,
        0,                      // 151,
        0,                      // 152,
        0,                      // 153,
        0,                      // 154,
        0,                      // 155,
        0,                      // 156,
        0,                      // 157,
        0,                      // 158,
        0,                      // 159,
        0,                      // 160,
        0,                      // 161,
        0,                      // 162,
        0,                      // 163,
        0,                      // 164,
        0,                      // 165,
        0,                      // 166,
        0,                      // 167,
        0,                      // 168,
        0,                      // 169,
        0,                      // 170,
        0,                      // 171,
        0,                      // 172,
        0,                      // 173,
        0,                      // 174,
        0,                      // 175,
        0,                      // 176,
        0,                      // 177,
        0,                      // 178,
        0,                      // 179,
        0,                      // 180,
        0,                      // 181,
        0,                      // 182,
        0,                      // 183,
        0,                      // 184,
        0,                      // 185,
        0,                      // 186,
        0,                      // 187,
        0,                      // 188,
        0,                      // 189,
        0,                      // 190,
        0,                      // 191,
        0,                      // 192,
        0,                      // 193,
        0,                      // 194,
        0,                      // 195,
        0,                      // 196,
        0,                      // 197,
        0,                      // 198,
        0,                      // 199,
        0,                      // 200,
        0,                      // 201,
        0,                      // 202,
        0,                      // 203,
        0,                      // 204,
        0,                      // 205,
        0,                      // 206,
        0,                      // 207,
        0,                      // 208,
        0,                      // 209,
        0,                      // 210,
        0,                      // 211,
        0,                      // 212,
        0,                      // 213,
        0,                      // 214,
        0,                      // 215,
        0,                      // 216,
        0,                      // 217,
        0,                      // 218,
        0,                      // 219,
        0,                      // 220,
        0,                      // 221,
        0,                      // 222,
        0,                      // 223,
        0,                      // 224,
        0,                      // 225,
        0,                      // 226,
        0,                      // 227,
        0,                      // 228,
        0,                      // 229,
        0,                      // 230,
        0,                      // 231,
        0,                      // 232,
        0,                      // 233,
        0,                      // 234,
        0,                      // 235,
        0,                      // 236,
        0,                      // 237,
        0,                      // 238,
        0,                      // 239,
        0,                      // 240,
        0,                      // 241,
        0,                      // 242,
        0,                      // 243,
        0,                      // 244,
        0,                      // 245,
        0,                      // 246,
        0,                      // 247,
        0,                      // 248,
        0,                      // 249,
        0,                      // 250,
        0,                      // 251,
        0,                      // 252,
        0,                      // 253,
        0,                      // 254,
        0,                      // 255
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonestring\zonestring.cpp ===
#include "ZoneString.h"
#include <atlbase.h>


// Globals
static TCHAR zChNil = '\0'; 

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
static int zInitData[] = { -1, 0, 0, 0 };
static ZoneStringData* zDataNil = (ZoneStringData*)&zInitData; 
static LPCTSTR zPchNil = (LPCTSTR)(((BYTE*)&zInitData)+sizeof(ZoneStringData));

inline const ZoneString& __stdcall ZGetEmptyString() { return *(ZoneString*)&zPchNil; }
#define zEmptyString ZGetEmptyString()

// Compare helpers
inline bool __stdcall operator==(const ZoneString& s1, const ZoneString& s2)	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const ZoneString& s1, LPCTSTR s2)	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const ZoneString& s2)	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const ZoneString& s1, const ZoneString& s2)	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const ZoneString& s1, LPCTSTR s2)	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const ZoneString& s2)	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const ZoneString& s1, const ZoneString& s2)	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const ZoneString& s1, LPCTSTR s2)	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const ZoneString& s2)	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const ZoneString& s1, const ZoneString& s2){ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const ZoneString& s1, LPCTSTR s2)	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const ZoneString& s2)	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const ZoneString& s1, const ZoneString& s2)	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const ZoneString& s1, LPCTSTR s2)	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const ZoneString& s2)	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const ZoneString& s1, const ZoneString& s2)	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const ZoneString& s1, LPCTSTR s2)	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const ZoneString& s2)	{ return s2.Compare(s1) <= 0; }


///////////////////////////////////////////////////////////////////////////////
// AddressToString 
//
// Converts IP address in x86 byte order to string. szOut needs to
// be at least 16 characters wide.
//
////////////////////////////////////////////////////////////////////////////////
TCHAR* ZONECALL AddressToString( DWORD dwAddress, TCHAR* szOut )
{
	BYTE* bytes = (BYTE*) &dwAddress;
	wsprintf( szOut, TEXT("%d.%d.%d.%d"), bytes[3], bytes[2], bytes[1], bytes[0] );
	return szOut;
}


///////////////////////////////////////////////////////////////////////////////
// ZoneString conversion helpers (these use the current system locale)
///////////////////////////////////////////////////////////////////////////////
int ZONECALL WideToMulti(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

int ZONECALL MultiToWide(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1, wcstr, count);
	ASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString	Constructor
//
//	Parameters
//		NONE
//
//	Return Values
//		NONE
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{
	Init();
	if (pBuffer)
		InitBuffer(pBuffer, nLen);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString	Constructor
//
//	Parameters
//		NONE
//
//	Return Values
//		NONE
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(const unsigned char* lpsz, void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{ 
	Init(); 
	if (pBuffer)
		InitBuffer(pBuffer, nLen);
	*this = (LPCSTR)lpsz; 
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString		Contructor
//
//	Parameters	
//		ZoneString& stringSrc	Source string to set new string to.
//
//	Return Values
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(const ZoneString& stringSrc, void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{
	ASSERT(stringSrc.GetData()->nRefs != 0);
	
	if (pBuffer)
	{
		Init();
		InitBuffer(pBuffer, nLen);
		*this = stringSrc.m_pchData;
	}
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ASSERT(stringSrc.GetData() != zDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString		Contructor
//
//	Parameters	
//		LPCTSTR lpsz	Source string to set new string to.
//
//	Return Values
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(LPCTSTR lpsz, void * pBuffer, int nLen): m_bZoneStringAllocMemory(true)
{
	Init();
	if (pBuffer)
		InitBuffer(pBuffer, nLen);

	int nStrLen = SafeStrlen(lpsz);
	if (nStrLen != 0)
	{
		if(AllocBuffer(nStrLen))
			CopyMemory(m_pchData, lpsz, nStrLen*sizeof(TCHAR));
	}
}

#ifdef _UNICODE
///////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString		Contructor
//
//	Parameters	
//		LPCSTR lpsz	Source string to set new string to.
//
//	Return Values
//		None
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(LPCSTR lpsz, void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{
    USES_CONVERSION;
	Init();
	if (pBuffer)
		InitBuffer(pBuffer, nLen);
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			lstrcpyn(m_pchData, A2T(lpsz), nSrcLen+1);
			ReleaseBuffer();
		}
	}
}

#else //_UNICODE

///////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString		Contructor
//
//	Parameters	
//		LPCWSTR lpsz	Source string to set new string to.
//
//	Return Values
//		None
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(LPCWSTR lpsz, void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{
	Init();
	if (pBuffer)
		InitBuffer(pBuffer, nLen);
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen*2))
		{
			WideToMulti(m_pchData, lpsz, (nSrcLen*2)+1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

///////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString		Contructor - Fill style
//
//	Parameters	
//		TCHAR ch	Character with which to fill string
//		int nLenght	Number of characters to fill
//
//	Return Values
//		None
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(TCHAR ch, int nLength, void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{
	Init();
	if (pBuffer)
		InitBuffer(pBuffer, nLen);
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			FillMemory(m_pchData, nLength, ch);
#endif
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////
//
//	ZoneString		Contructor
//
//	Parameters	
//		LPCTSTR lpch	Source string to set new string to.
//		int nLength		Amound of source string to copy to THIS
//	Return Values
//		None
//
///////////////////////////////////////////////////////////////////////////////////////////
ZoneString::ZoneString(LPCTSTR lpch, int nLength, void * pBuffer, int nLen):m_bZoneStringAllocMemory(true)
{
	Init();
	if (pBuffer)
		InitBuffer(pBuffer, nLen);
	if (nLength != 0)
	{
		ASSERT(ZIsValidAddress(lpch, nLength, false));
		if(AllocBuffer(nLength))
			CopyMemory(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	~ZoneString		Destructor - free any attached data
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
ZoneString::~ZoneString()
{
	if (GetData() != zDataNil)
	{
		if ((InterlockedDecrement(&GetData()->nRefs) <= 0) && (m_bZoneStringAllocMemory))
			delete[] (BYTE*)GetData();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	GetData		Description
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
ZoneStringData* ZoneString::GetData() const
{ 
	ASSERT(m_pchData != NULL); 
	return ((ZoneStringData*)m_pchData)-1; 
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Init		Description
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::Init()
{
	if (!m_bZoneStringAllocMemory)
		InitBuffer(GetData(),GetAllocLength());
	else
		m_pchData = zEmptyString.m_pchData; 
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	InitBuffer		Initialize memory passed into String class
//
//	Parameters
//		int nLen		Size of memory to allocate
//	Return Values
//		true/false	Success/Failure
//
/////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::InitBuffer(void * pBuffer, int nLen)
{
	ASSERT(pBuffer != NULL);

	ZoneStringData* pData = (ZoneStringData*)pBuffer;

	m_bZoneStringAllocMemory = false;
	pData->nRefs = -1;  // This memory is to be Locked to others
	pData->data()[nLen] = '\0';
	pData->nDataLength = nLen;
	pData->nAllocLength = nLen;
	m_pchData = pData->data();
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	AllocBuffer		Internally used memory allocation function
//					always allocate one extra character for '\0' termination
//					assumes [optimistically] that data length will equal allocation length
//	Parameters
//		int nLen		Size of memory to allocate
//	Return Values
//		true/false	Success/Failure
//
/////////////////////////////////////////////////////////////////////////////////////////////
bool ZoneString::AllocBuffer(int nLen)
{
	ASSERT(nLen >= 0);
	ASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else if (!m_bZoneStringAllocMemory)
	{
		ASSERT(GetAllocLength() >= nLen);
		if (GetAllocLength() >= nLen)
		{   // Reinitialize buffer setting new nDataLength
			ZoneStringData* pData = GetData();
			pData->data()[nLen] = '\0';
			pData->nDataLength = nLen;
			return true;
		}
		return false;
	}
	else
	{
		ZoneStringData* pData = NULL;


		pData = (ZoneStringData*)new BYTE[sizeof(ZoneStringData) + (nLen+1)*sizeof(TCHAR)];
		if(pData == NULL)
			return false;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}

	return true;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Release		Decrement ref count and if ref's = 0, release allocated memory 
//			
//
//	Parameters
//		None
//	Return Values
//		None
//
/////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::Release()
{
	if (GetData() != zDataNil)
	{
		ASSERT(GetData()->nRefs != 0);
		if ((InterlockedDecrement(&GetData()->nRefs) <= 0) && m_bZoneStringAllocMemory)
			delete[] (BYTE*)GetData();
		Init();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Release		Decrement ref count and if ref's = 0, release allocated memory 
//				for specified ZoneStringData
//
//	Parameters
//		ZoneStringData* pData	ZoneStringData on which to release memory for.
//
//	Return Values
//
/////////////////////////////////////////////////////////////////////////////////////////////
void PASCAL ZoneString::Release(ZoneStringData* pData, bool bZoneStringAllocMem)
{
	if (pData != zDataNil)
	{
		ASSERT(pData->nRefs != 0);
		if ((InterlockedDecrement(&pData->nRefs) <= 0) && bZoneStringAllocMem)
			delete[] (BYTE*)pData;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Empty		Free up data associated with object
//
//	Parameters
//		None
//
//	Return Values
//		None
//
/////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &zChNil;
	ASSERT(GetData()->nDataLength == 0);
	ASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	CopyBeforeWrite		Description
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		ZoneStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			CopyMemory(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ASSERT(GetData()->nRefs <= 1);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	AllocBeforeWrite		Allocate a new buffer for the object
//
//	Parameters
//		int nLen
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
bool ZoneString::AllocBeforeWrite(int nLen)
{
	bool bRet = true;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ASSERT(GetData()->nRefs <= 1);
	return bRet;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	AllocCopy		will clone the data attached to this string
//					allocating 'nExtraLen' characters
//					Places results in uninitialized string 'dest'
//					Will copy the part or all of original data to start of new string
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::AllocCopy(ZoneString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const
{
	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			CopyMemory(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const ZoneString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	AssignCopy		Allocate new memory and then copy data
//
//	Parameters
//		int nSrcLen
//		LPCTSTR lpszSrcData
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		CopyMemory(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Collate		Collate is often slower than Compare but is MBSC/Unicode
//				aware as well as locale-sensitive with respect to sort order.
//
//	Parameters
//		LPCTSTR lpsz	String to compare THIS against
//
//	Return Values
//		CSTR_LESS_THAN            1           // string 1 less than string 2
//		CSTR_EQUAL                2           // string 1 equal to string 2
//		CSTR_GREATER_THAN         3           // string 1 greater than string 2
//
//////////////////////////////////////////////////////////////////////////////////////////////
int ZoneString::Collate(LPCTSTR lpsz) const
{ 
	return CompareString( LOCALE_SYSTEM_DEFAULT, 0, m_pchData, -1, lpsz, -1);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	ConcatCopy		Concatenation
//				NOTE:	"operator+" is done as friend functions for simplicity
//						There are three variants:
//						ZoneString + ZoneString
//						and for ? = TCHAR, LPCTSTR
//           			ZoneString + ?
//						? + ZoneString
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::ConcatCopy(int nSrc1Len, LPCSTR lpszSrc1Data,
	int nSrc2Len, LPCSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new ZoneString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		if(AllocBuffer(nNewLen))
		{
			CopyMemory(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(char));
			CopyMemory(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(char));
		}
	}
}
void ZoneString::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
	int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new ZoneString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		if(AllocBuffer(nNewLen))
		{
			CopyMemory(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
			CopyMemory(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
//	ConcatInPlace		String concatination in place
//						-- the main routine for += operators
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		ZoneStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ASSERT(pOldData != NULL);
		ZoneString::Release(pOldData, m_bZoneStringAllocMemory);
	}
	else
	{
		// fast concatenation when buffer big enough
		CopyMemory(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	GetBuffer		Returns a pointer to the internal character buffer for the 
//					ZoneString object. The returned LPTSTR is not const and thus 
//					allows direct modification of CString contents.
//
//	Parameters
//		int nMinBufLength	Minimum buffer length
//
//	Return Values
//		pointer to the internal character buffer
//
//////////////////////////////////////////////////////////////////////////////////////////////
LPTSTR ZoneString::GetBuffer(int nMinBufLength)
{
	ASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		ZoneStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		if(AllocBuffer(nMinBufLength))
		{
			CopyMemory(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
			GetData()->nDataLength = nOldLen;
			ZoneString::Release(pOldData, m_bZoneStringAllocMemory);
		}
	}
	ASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	ReleaseBuffer		Use ReleaseBuffer to end use of a buffer allocated by GetBuffer.
//						If you know that the string in the buffer is null-terminated, you 
//						can omit the nNewLength argument. If your string is not 
//						null-terminated, then use nNewLength to specify its length.
//
//	Parameters
//		int nNewLength	Length to null terminate string at 
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	SetBuffer		Sets the internal character buffer for the ZoneString object
//
//	Parameters
//		void *pBuffer	Buffer to use
//		int nLen		Length of buffer
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::SetBuffer(void *pBuffer, int nLen)
{
	if (GetData()->nRefs > 1)
		Release();

	InitBuffer(pBuffer, nLen);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Empty		Description
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
LPTSTR ZoneString::GetBufferSetLength(int nNewLength)
{
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	FreeExtra		Description
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::FreeExtra()
{
	ASSERT(m_bZoneStringAllocMemory);
	
	// Free memory not supported in passed in memory model
	if (!m_bZoneStringAllocMemory) 
		return;

	ASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		ZoneStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			CopyMemory(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
			ASSERT(m_pchData[GetData()->nDataLength] == '\0');
			ZoneString::Release(pOldData, m_bZoneStringAllocMemory);
		}
	}
	ASSERT(GetData() != NULL);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	LockBuffer		Lock character buffer from read/writes
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
LPTSTR ZoneString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	UnlockBuffer		Unlock character buffer for read/writes
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::UnlockBuffer()
{
	ASSERT(GetData()->nRefs == -1);
	if (!m_bZoneStringAllocMemory) // Leave buffer locked, so not shared
		return;
	
	if (GetData() != zDataNil)
		GetData()->nRefs = 1;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	GetAt		Get character in string at nIndex
//
//	Parameters
//		int nIndex	Index of char to get
//
//	Return Values
//		TCHAR	char at Index
//
//////////////////////////////////////////////////////////////////////////////////////////////
TCHAR ZoneString::GetAt(int nIndex) const
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Find		find the first occurance of character
//
//	Parameters
//		None
//
//	Return Values
//		index of first character found or -1 if char not found
//
//////////////////////////////////////////////////////////////////////////////////////////////
int ZoneString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = FindChar(m_pchData, (_TUCHAR)ch); 

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	MakeUpper		Convert string to upper case
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::MakeUpper()
{
	CopyBeforeWrite();
	CharUpper(m_pchData);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	MakeLower		Convert string to lower case
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::MakeLower()
{
	CopyBeforeWrite();
	CharLower(m_pchData);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	MakeReverse		Reverse string
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::MakeReverse()
{
	CopyBeforeWrite();
	
	TCHAR chTemp;
	int nLength = GetData()->nDataLength;
	int nMid = nLength/2;
	
	for (int i = 0; i < nMid; i++)
	{
		nLength--;
		chTemp = m_pchData[i];
		m_pchData[i] = m_pchData[nLength];
		m_pchData[nLength] = chTemp;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	SetAt		Set character and nIndex to ch
//
//	Parameters
//		int nIndex	Index of char to set
//		TCHAR ch	value to set char
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::SetAt(int nIndex, TCHAR ch)
{
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
/////////////////////////////////////////////////////////////////////////////////////////////
//
//	AnsiToOem		Converts all the characters in this CString object 
//					from the ANSI character set to the OEM character set
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	AnsiToOem		Converts all the characters in this CString object 
//					from the OEM character set to the ANSI character set
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Mid		Extracts a substring of characters from this CString object, 
//			starting at position nFirst (zero-based) ending at end of string. 
//			The function returns a copy of the extracted substring. 
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
ZoneString ZoneString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Mid		Extracts a substring of length nCount characters from this CString object, 
//			starting at position nFirst (zero-based). The function returns a copy of 
//			the extracted substring. 
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
ZoneString ZoneString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	ZoneString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Right		Get string of the right most nCount chars
//
//	Parameters
//		int nCount	Number of chars to get
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
ZoneString ZoneString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	ZoneString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Left		Get string of the left most nCount chars
//
//	Parameters
//		int nCount	Number of chars to get
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
ZoneString ZoneString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	ZoneString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	ReverseFind		Searches this CString object for the last match of a substring. 
//				Similar to the run-time function strrchr.
//
//	Parameters
//		None
//
//	Return Values
//		The index of the last character in this CString object that matches the 
//		requested character; -1 if the character is not found.
//
//////////////////////////////////////////////////////////////////////////////////////////////
int ZoneString::ReverseFind(TCHAR ch) const
{
	int nLenth = GetData()->nDataLength;
	
	for (int i = --nLenth; i >= 0; i--)
	{
		if ( m_pchData[i] == ch)
			break;
	}

	// return -1 if not found, index otherwise
	return (i < 0) ? -1 : (int)(i);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	Find		Find a sub-string (like strstr)
//
//	Parameters
//		LPCTSTR lpszSub
//
//	Return Values
//		The zero-based index of the first character in this CString object that matches the 
//		requested substring or characters; -1 if the substring or character is not found.
//
//////////////////////////////////////////////////////////////////////////////////////////////
int ZoneString::Find(LPCTSTR lpszSub) const
{
	ASSERT(ZIsValidString(lpszSub, false));

	// find first matching substring
	LPCTSTR lpsz = StrInStrI(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	TrimRight		Remove trailing spaces
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (IsWhitespace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = CharNext(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = lpszLast - m_pchData;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	TrimLeft		Remove leading whitespace
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (IsWhitespace(*lpsz))
		++lpsz;

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (lpsz - m_pchData);
	MoveMemory(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	RemoveDirInfo		Remove directory information from string
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
void ZoneString::RemoveDirInfo()
{
	CopyBeforeWrite();

	// Remove Dir info from Url filename
	int len = GetLength();
	while (len >= 0)
	{
		if (m_pchData[len] == '\\')
			break;
		len--;
	}
	len++;

	// fix up data and length
	int nDataLength = GetData()->nDataLength - len;
	LPCTSTR lpsz = m_pchData + len;

	MoveMemory(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

#ifdef _UNICODE
#define CHAR_SPACE 1    // one TCHAR unused is good enough
#else
#define CHAR_SPACE 2    // two BYTES unused for case of DBC last char
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	LoadString		Load a string from a resource - needs to implement calls to 
//					Resource manager
//
//	Parameters
//		UINT		Id of resource to load
//
//	Return Values
//		true/false	Success/Failure
//
//////////////////////////////////////////////////////////////////////////////////////////////
bool ZoneString::LoadString(HINSTANCE hInstance, UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = ZResLoadString(hInstance, nID, szTemp, nCount);
	if (nCount - nLen > CHAR_SPACE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = ZResLoadString(hInstance, nID, GetBuffer(nSize-1), nSize);
	} while (nSize - nLen <= CHAR_SPACE);
	ReleaseBuffer();

	return nLen > 0;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator[]		[] Operator overload
//
//	Parameters
//		int nIndex	Index at which to retrieve char
//
//	Return Values
//		 TCHAR at index
//
//////////////////////////////////////////////////////////////////////////////////////////////
TCHAR ZoneString::operator[](int nIndex) const
{
	// same as GetAt
	ASSERT(nIndex >= 0);
	ASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}

#ifdef _UNICODE
/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=		= Operator overload
//
//	Parameters
//		ZoneString&	stringSrc - Reference to ZoneString, right side of assignment	
//
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
const ZoneString& ZoneString::operator=(char ch)
{ 
	*this = (TCHAR)ch; 
	return *this; 
}
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=		= Operator overload
//
//	Parameters
//		ZoneString&	stringSrc - Reference to ZoneString, right side of assignment	
//
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
const ZoneString& ZoneString::operator=(const unsigned char* lpsz)
{ 
	*this = (LPCSTR)lpsz; 
	return *this; 
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=		= Operator overload
//
//	Parameters
//		ZoneString&	stringSrc - Reference to ZoneString, right side of assignment	
//
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
const ZoneString& ZoneString::operator=(const ZoneString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != zDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ASSERT(stringSrc.GetData() != zDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=			= Operator overload 
//
//	Parameters
//		LPCTSTR lpsz	Pointer to null terminated string, right side of assignment
//						LPCTSTR = An LPCWSTR ifUNICODE is defined, an LPCSTR otherwise
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
const ZoneString& ZoneString::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || ZIsValidString(lpsz, false));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=			= Operator overload
//
//	Parameters
//		LPCSTR lpsz		Pointer to null terminated string, right side of assignment
//
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
const ZoneString& ZoneString::operator=(LPCSTR lpsz)
{
    USES_CONVERSION;
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		lstrcpyn(m_pchData, A2T(lpsz), nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}

#else //!_UNICODE

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=		= Operator overload
//
//	Parameters
//		LPCWSTR lpsz	Pointer to null terminated string, right side of assignment
//
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
const ZoneString& ZoneString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen*2))
	{
		WideToMulti(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zoneutil\eventlog.cpp ===
#include <windows.h>
#include "eventlog.h"
#include "zonemsg.h"
#include "zonedebug.h"

#ifndef ASSERT
#define ASSERT(X)
#endif


CEventLog::CEventLog() :
    m_hLog(NULL),
    m_RefCnt(0)
{
}


CEventLog::~CEventLog()
{
    Deregister( TRUE );
}


BOOL CEventLog::Register( LPCTSTR pSource )
{
    BOOL bRet = FALSE;

    if ( m_RefCnt == 0 )
    {
        ASSERT( !m_hLog );
        m_hLog = RegisterEventSource( NULL, pSource );
        if ( m_hLog )
        {
            InterlockedIncrement( &m_RefCnt );
            bRet = TRUE;
        }
    }
    else
    {
        ASSERT( m_hLog );
        InterlockedIncrement( &m_RefCnt );
        bRet = TRUE;
    }
    return bRet;
}


void CEventLog::Deregister( BOOL bForceUnregister )
{
    InterlockedDecrement( &m_RefCnt );
    if ( bForceUnregister || (m_RefCnt <= 0) )
    {
        if ( m_hLog )
            DeregisterEventSource( m_hLog );
        m_hLog = NULL;
        InterlockedExchange( &m_RefCnt, 0 );
    }
}


WORD CEventLog::EventTypeFromID( DWORD dwEventID )
{
    switch ( dwEventID >> 30 )
    {
    case STATUS_SEVERITY_ERROR:
        return EVENTLOG_ERROR_TYPE;

    case STATUS_SEVERITY_WARNING:
        return EVENTLOG_WARNING_TYPE;

    case STATUS_SEVERITY_SUCCESS:
    case STATUS_SEVERITY_INFORMATIONAL:
        return EVENTLOG_INFORMATION_TYPE;

    default:
        ASSERT( !"Invalid Severity" );
        return 0;
    };
}


BOOL CEventLog::Report( DWORD dwEventID, WORD wNumStrings, LPTSTR* lpStrings, DWORD dwDataSize, LPVOID lpData )
{
    if( m_hLog )
        return ReportEvent( m_hLog, EventTypeFromID( dwEventID ), 0, dwEventID, NULL, wNumStrings, dwDataSize, (LPCTSTR *)lpStrings, lpData );
    else
        return FALSE;
}



CEventLog gLog;

BOOL ZoneEventLogStartup(LPCTSTR pSource)
{
    return gLog.Register( pSource );
}


void ZoneEventLogShutdown()
{
    gLog.Deregister();
}

BOOL ZoneEventLogReport( DWORD dwEventID,
                         WORD wNumStrings, LPTSTR* lpStrings,
                         DWORD dwDataSize, LPVOID lpData )
{
    return gLog.Report( dwEventID, wNumStrings, lpStrings,
                        dwDataSize, lpData );
}



BOOL EventLogAssertHandler( TCHAR* buf )
{
    LPTSTR ppStr[] = { buf };
    ZoneEventLogReport( ZONE_E_ASSERT, 1, ppStr, 0, NULL );
    return TRUE;
}


BOOL EventLogAssertWithDialogHandler( TCHAR* buf )
{
	EventLogAssertHandler( buf );
	return ZAssertDefaultHandler( buf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zoneutil\main.cpp ===
#include "BasicATL.h"

#include <EventQueue.h>
#include "..\EventQueue\CEventQueue.h"

#include <DataStore.h>
#include "..\..\Shared\DataStore\CDataStore.h"

#include <LobbyDataStore.h>
#include "..\LobbyDataStore\CLobbyDataStore.h"

CZoneComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_EventQueue, CEventQueue)
	OBJECT_ENTRY(CLSID_DataStoreManager, CDataStoreManager)
	OBJECT_ENTRY(CLSID_LobbyDataStore, CLobbyDataStore)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
/////////////////////////////////////////////////////////////////////////////

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{

//!!
//MessageBox(NULL, "ZoneClient::DllMain", NULL, MB_OK);

	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		//DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
/////////////////////////////////////////////////////////////////////////////

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
/////////////////////////////////////////////////////////////////////////////

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zoneutil\readline.cpp ===
#include <windows.h>
#include "ZoneUtil.h"


BOOL ZONECALL ReadLine( HANDLE hFile, LPVOID pBuffer, DWORD cbBufferSize, LPDWORD pcbNumBytesRead )
{
    if ( cbBufferSize <= 1 )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    if ( ReadFile( hFile, pBuffer, cbBufferSize-1, pcbNumBytesRead, NULL ) )
    {
        long cbRead = *((long*)pcbNumBytesRead);
        if ( !cbRead )
        {
            // EOF
            return TRUE;
        }
        else  // find end of line
        {
            LPSTR psz = (LPSTR)pBuffer;
            while( cbRead )
            {
                if ( *psz == '\n' )
                {
                    break;
                }
                psz++;
                cbRead--;
            }

            if ( !cbRead )
            {
				// either file ended with no <cr> or buffer was too small
				if( (cbBufferSize-1) != *pcbNumBytesRead) // eof
				{
					((TCHAR*)pBuffer)[cbBufferSize-1] = NULL; 
					return TRUE;
				}
                // buffer to small
                SetFilePointer( hFile, -(* ((long*)pcbNumBytesRead)), NULL, FILE_CURRENT );
                *pcbNumBytesRead = 0;
                SetLastError( ERROR_INSUFFICIENT_BUFFER );
                return FALSE;
            }
            else
            {
                *psz = '\0';
                if ( psz != pBuffer )
                {
                    psz--;
                    if ( *psz == '\r' )
                        *psz = '\0';
                }
                SetFilePointer( hFile, 1-cbRead, NULL, FILE_CURRENT );
                return TRUE;
            }
        }

    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zoneutil\zoleaut32.cpp ===
#include "zoleaut32.h"

typedef HRESULT (WINAPI *pUnTypeLibFunc)(REFGUID  libID, unsigned short  wVerMajor, unsigned short  wVerMinor, LCID  lcid, SYSKIND  syskind ); 

HRESULT WINAPI ZUnRegisterTypeLib( 
  REFGUID  libID,             
  unsigned short  wVerMajor,  
  unsigned short  wVerMinor,  
  LCID  lcid,                 
  SYSKIND  syskind)
{
    HRESULT hResult = E_FAIL;
    HINSTANCE h = LoadLibrary(TEXT("oleaut32.dll")); 
    if (h) 
    { 
        pUnTypeLibFunc pUnRegisterTypeLib = (pUnTypeLibFunc)GetProcAddress(h, "UnRegisterTypeLib"); 
        if (pUnRegisterTypeLib) 
            hResult = pUnRegisterTypeLib(libID, wVerMajor, wVerMinor, lcid, syskind);
        FreeLibrary(h); 
    }

    return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zonestring\zparse.cpp ===
#include <ZoneString.h>


enum parseStates
{
    LOOKING_FOR_KEY,
    LOOKING_FOR_VALUE
};


///////////////////////////////////////////////////////////////////////////////
//
//	TokenGetKeyValue (ASCII,UNICODE)
//
///////////////////////////////////////////////////////////////////////////////
bool ZONECALL TokenGetKeyValue(const TCHAR* szKey, const TCHAR* szInput, TCHAR* szOut, int cchOut )
{
	// verify arguments
    if( !szKey || !szInput || !szOut || cchOut <= 0)
        return false;

	// zero output buffer
	ZeroMemory( szOut, cchOut );

    const TCHAR* p = szInput;
    const TCHAR* startToken = NULL;
	int bracketOpenCount = 0;
    int endBracketCount = 0;
	int numChars = 0;
	int keyLen = lstrlen(szKey);
	int state = LOOKING_FOR_KEY;

    while( *p != _T('\0') )
	{
        switch (*p)
		{
		case _T('['):
        case _T('<'):
            if ( state == LOOKING_FOR_KEY )
			{
				// if looking for key open bracket means start of new key
                startToken = 0;
                numChars = 0;
            }
			else
			{
				// otherwise looking for value - if no chars yet lets start a new value
                if( !numChars )
					startToken = p;
                numChars++;
            }
            bracketOpenCount++;
            break;

		case _T(']'):
        case _T('>'):
            bracketOpenCount--;
            if ( state == LOOKING_FOR_KEY )
			{
				// if looking for key close bracket means start of new key
                startToken = 0;
                numChars = 0;
            }
			else if (	state == LOOKING_FOR_VALUE
					 && endBracketCount == bracketOpenCount )
			{
				// if looking for value and we get a close bracket that terminates
				// the value token includes initial bracket so make sure there's
				// something in there to copy
                int n = min( numChars -1, cchOut ); // length of buf without bracket
                if(n>0)
				{
                    lstrcpyn( szOut,startToken + 1,n + 1); // copy all but initial bracket
                    szOut[n]=0;
                }
                return TRUE;
            }
			else
                numChars++;
            break;

        case _T('='):
            if( startToken && (state==LOOKING_FOR_KEY))
			{
				// if looking for token, we've found one
                if(numChars == keyLen)
				{
					// make sure matches key length before we do expensive compare
					int ret = CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, startToken, keyLen, szKey, keyLen);
                    if( ret == CSTR_EQUAL )
					{
                        state = LOOKING_FOR_VALUE;            // then start looking for value
                        endBracketCount = bracketOpenCount;    // set end condition
                        numChars = 0;                
                    }
                }
            }
			else
                numChars++;
            break;

        default:
			// not currently scanning a token so start a new one
            if (!numChars)
                startToken = p;
            numChars++;
            break;
        }
        p++;        
    }
    return FALSE;
}


bool ZONECALL TokenGetKeyValueA(const char* szKey, const char* szInput, char* szOut, int cchOut )
{
	// verify arguments
    if( !szKey || !szInput || !szOut || cchOut <= 0)
        return false;

	// zero output buffer
	ZeroMemory( szOut, cchOut );

    const char* p = szInput;
    const char* startToken = NULL;
	int bracketOpenCount = 0;
    int endBracketCount = 0;
	int numChars = 0;
	int keyLen = lstrlenA(szKey);
	int state = LOOKING_FOR_KEY;

    while( *p != '\0' )
	{
        switch (*p)
		{
		case '[':
        case '<':
            if ( state == LOOKING_FOR_KEY )
			{
				// if looking for key open bracket means start of new key
                startToken = 0;
                numChars = 0;
            }
			else
			{
				// otherwise looking for value - if no chars yet lets start a new value
                if( !numChars )
					startToken = p;
                numChars++;
            }
            bracketOpenCount++;
            break;

		case ']':
        case '>':
            bracketOpenCount--;
            if ( state == LOOKING_FOR_KEY )
			{
				// if looking for key close bracket means start of new key
                startToken = 0;
                numChars = 0;
            }
			else if (	state == LOOKING_FOR_VALUE
					 && endBracketCount == bracketOpenCount )
			{
				// if looking for value and we get a close bracket that terminates
				// the value token includes initial bracket so make sure there's
				// something in there to copy
                int n = min( numChars -1, cchOut ); // length of buf without bracket
                if(n>0)
				{
                    lstrcpynA( szOut,startToken + 1,n + 1); // copy all but initial bracket
                    szOut[n]=0;
                }
                return TRUE;
            }
			else
                numChars++;
            break;

        case '=':
            if( startToken && (state==LOOKING_FOR_KEY))
			{
				// if looking for token, we've found one
                if(numChars == keyLen)
				{
					// make sure matches key length before we do expensive compare
					int ret = CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, startToken, keyLen, szKey, keyLen);
                    if( ret == CSTR_EQUAL )
					{
                        state = LOOKING_FOR_VALUE;            // then start looking for value
                        endBracketCount = bracketOpenCount;    // set end condition
                        numChars = 0;                
                    }
                }
            }
			else
                numChars++;
            break;

        default:
			// not currently scanning a token so start a new one
            if (!numChars)
                startToken = p;
            numChars++;
            break;
        }
        p++;        
    }
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
//	TokenGetServer (ASCII,UNICODE)
//
///////////////////////////////////////////////////////////////////////////////
bool ZONECALL TokenGetServer(const TCHAR* szInput, TCHAR* szServer, DWORD cchServer, DWORD* pdwPort )
{
	TCHAR	szData[256];
	TCHAR*	szPort;

	// verify aruguments
	if ( !szInput || !szServer || !pdwPort )
		return false;

	// get server string
    if ( !TokenGetKeyValue( _T("server"), szInput, szData, NUMELEMENTS(szData) ) )
        return false;

	// get port
    szPort = FindChar( szData, _T(':') );
    if ( szPort == NULL )
		return false;
    *szPort++ = _T('\0');
    *pdwPort = zatol( szPort );

    // copy server address.
    lstrcpyn( szServer, szData, cchServer );
    return true;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	StringToArray (ASCII)
//
//	Convert comma delimited list into an array of pointers.  The input string is
//	modified in place.
//
//	Parameters
//		szInput		String containing comma deliminated list.
//		arItems		Array of charater pointers to receive items
//		pnElts		pointer to number of elements in list, reset to number added
//
//	Return Values
//		true successful, otherwise false
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

bool ZONECALL StringToArrayA( char* szInput, char** arItems, DWORD* pnElts )
{
	DWORD n = 0;
	for ( char *start = szInput, *p = szInput; *p; p++ )
	{
		if ( ISSPACEA(*p) )
		{
			*p = '\0';
			if ( start == p )
				start++;
		}
		else if ( *p == ',' )
		{
			*p = '\0';
			if ( n < *pnElts )
				arItems[n++] = start;
			start = p + 1;
		}
	}
	if ( start != p )
	{
		if ( n < *pnElts )
			arItems[n++] = start;
	}
	*pnElts = n;
	return true;
}

bool ZONECALL StringToArrayW( WCHAR* szInput, WCHAR** arItems, DWORD* pnElts )
{
	DWORD n = 0;
	for ( WCHAR *start = szInput, *p = szInput; *p; p++ )
	{
		if ( ISSPACEW(*p) )
		{
			*p = _T('\0');
			if ( start == p )
				start++;
		}
		else if ( *p == _T(',') )
		{
			*p = _T('\0');
			if ( n < *pnElts )
				arItems[n++] = start;
			start = p + 1;
		}
	}
	if ( start != p )
	{
		if ( n < *pnElts )
			arItems[n++] = start;
	}
	*pnElts = n;
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zoneutil\registry.cpp ===
#include "windows.h"
#include "winreg.h"

#include "zonemem.h"
#include "zonedebug.h"
#include "registry.h"
#include "eventlog.h"
#include "zonemsg.h"


CRegistry::ErrorCode CRegistry::m_pErrors[] = 
{
    { ErrOk,                " no error\r\n" },
    { ErrUnknown,            " unknown\r\n" },
    { ErrRegOpenFailed,        " - unable to open specified registry key\r\n" },
    { ErrNotFound,            " not found\r\n" },
    { ErrNotDword,            " is not a REG_DWORD\r\n" },
    { ErrNotSZ,                " is not a REG_SZ\r\n" },
    { ErrNotMultiSZ,        " is not a REG_MULTI_SZ\r\n" },
    { ErrUnsupported,        " is a unsupported reg type\r\n" },
    { ErrInvalid,            " is invalid\r\n" }
};


LPSTR CRegistry::GetError( DWORD ErrCode )
{
    for ( int i = 0; i < (sizeof(m_pErrors) / sizeof(ErrorCode)); i++ )
    {
        if ( m_pErrors[i].Code == ErrCode )
            break;
    }
    if ( i < (sizeof(m_pErrors) / sizeof(ErrorCode)) )
    {
        m_dwErrCode = ErrCode;
        m_pErr = m_pErrors[ i ].String;
    }
    else
    {
        m_dwErrCode = ErrUnknown;
        m_pErr = m_pErrors[ ErrUnknown ].String;
    }
    return m_pErr;
}


CRegistry::CRegistry() :
    m_Static(NULL), m_numStatic(0), m_allocStatic(0),
    m_Dynamic(NULL), m_numDynamic(0), m_allocDynamic(0),
    m_StrBuf(NULL), m_cbStrBuf(0), m_cbStrBufRemaining(0),
    m_pErr(NULL), m_pValue(NULL), m_dwErrCode(ErrOk), m_bChanged(0),
    m_numRoots(0), m_phkeyRoots(NULL), m_phRootEvents(NULL),
    m_bStaticRead(FALSE)
{
    InitializeCriticalSection( m_pCS );
}

CRegistry::~CRegistry()
{
    Close();
    DeleteCriticalSection( m_pCS );
}

BOOL CRegistry::SetKeyRoots( LPSTR* pszRootArray, DWORD numRoots )
{

    if ( m_phkeyRoots )
        return FALSE;

    if ( !pszRootArray || ( numRoots < 1 ) )
        return FALSE;

    DWORD dwError = NO_ERROR;
    m_numRoots = numRoots;
    m_phkeyRoots = new HKEY[m_numRoots];

    BOOL bFound = FALSE;
    for ( DWORD ndx = 0; ndx < m_numRoots; ndx++ )
    {
        dwError = RegOpenKeyExA( HKEY_LOCAL_MACHINE, pszRootArray[ndx], 0, KEY_READ, m_phkeyRoots+ndx );
        if ( dwError == NO_ERROR && m_phkeyRoots[ndx] )
        {
            bFound = TRUE;
        }

    }

    if ( !bFound )
    {
        m_pValue = AllocStr( pszRootArray[ndx-1] );
        GetError( ErrRegOpenFailed );
        return FALSE;
    }

    return bFound;
}

BOOL CRegistry::SetRoomRoots( LPCSTR pszRoom )
{
	char szRegInst[256];
    wsprintfA( szRegInst, "SYSTEM\\CurrentControlSet\\Services\\%s\\Parameters", pszRoom );

	char szClass[6];
	lstrcpynA( szClass, pszRoom, sizeof(szClass) );
	char szRegClass[256];
	wsprintfA( szRegClass, "SYSTEM\\CurrentControlSet\\Services\\ZoneGameServices\\Templates\\%s\\Parameters", szClass );

	
	LPSTR pRoots[] = { szRegInst,
	                   szRegClass,
	                   "SYSTEM\\CurrentControlSet\\Services\\ZoneGameServices\\Parameters",
	                   "SYSTEM\\CurrentControlSet\\Services\\_Zone\\Room",
	                   "SYSTEM\\CurrentControlSet\\Services\\_Zone",
	                   };

	return SetKeyRoots( pRoots, sizeof(pRoots)/sizeof(pRoots[0]) ) ;
}


void CRegistry::Close()
{
    for ( DWORD ndx = 0; ndx < m_numRoots; ndx++ )
    {
        if ( m_phkeyRoots[ndx] )
        {
            RegCloseKey( m_phkeyRoots[ndx] );
        }

        if ( m_phRootEvents )
        {
            if ( m_phRootEvents[ndx] )
            {
                CloseHandle( m_phRootEvents[ndx] );
            }
        }
    }

    if ( m_phkeyRoots )
    {
        delete [] m_phkeyRoots;
        m_phkeyRoots = NULL;
    }

    if ( m_phRootEvents )
    {
        delete [] m_phRootEvents;
        m_phRootEvents = NULL;
    }

    m_numRoots = 0;

    if ( m_Static )
    {
        ZFree( m_Static );
        m_Static = NULL;
    }
    m_numStatic = 0;
    m_allocStatic = 0;

    if ( m_Dynamic )
    {
        ZFree( m_Dynamic );
        m_Dynamic = NULL;
    }
    m_numDynamic = 0;
    m_allocDynamic = 0;

    if ( m_StrBuf )
    {
        ZFree( m_StrBuf );
        m_StrBuf = NULL;
    }
    m_cbStrBuf = 0;
    m_cbStrBufRemaining = 0;

    m_pErr = NULL;
    m_pValue = NULL;

    m_bStaticRead = FALSE;

}

BOOL CRegistry::AddValue( LPSTR pszSubKey, LPSTR pszValue, DWORD dwType, LPBYTE pData, DWORD cbData, READ_TYPE type, BOOL bRequired, REGENTRY_CONV_PROC proc )
{
    if ( m_numRoots )
    {
        switch ( type )
        {
            case STATIC:
                return Add( &m_Static, &m_numStatic, &m_allocStatic, pszSubKey, pszValue, dwType, pData, cbData, bRequired, proc );
                break;
            case DYNAMIC:
                if ( !m_phRootEvents )
                {
                    m_phRootEvents = new HANDLE[m_numRoots];
                    if ( !m_phRootEvents )
                        return FALSE;

                    for ( DWORD ndx = 0; ndx < m_numRoots; ndx++ )
                    {
                        // we need to create the event no matter what, or the waitfor logic fails
                        m_phRootEvents[ndx] = CreateEvent( NULL, TRUE, FALSE, NULL );
                        if ( !m_phRootEvents[ndx] )
                            return FALSE;

                        if ( m_phkeyRoots[ndx] )
                        {

                            if ( NO_ERROR != RegNotifyChangeKeyValue(
                                m_phkeyRoots[ndx], TRUE, REG_NOTIFY_CHANGE_LAST_SET, m_phRootEvents[ndx], TRUE ) )
                                return FALSE;
                        }
                    }
                }
                return Add( &m_Dynamic, &m_numDynamic, &m_allocDynamic, pszSubKey, pszValue, dwType, pData, cbData, bRequired, proc );
                break;
        }
    }
    return FALSE;
}

BOOL CRegistry::Add( RegEntry** ppEntries, DWORD* pnumEntries, DWORD* pAllocEntries,
                     LPSTR pszSubKey, LPSTR pszValue, DWORD dwType, LPBYTE pData, DWORD cbData, BOOL bRequired, REGENTRY_CONV_PROC proc  )
{
    Lock();
    if ( *pnumEntries >= *pAllocEntries )
    {
        (*pAllocEntries) += 10; // grow by size
        RegEntry* reg = (RegEntry*) ZRealloc( *ppEntries, sizeof(RegEntry)* (*pAllocEntries) );
        if ( !reg )
        {
            Unlock();
            return FALSE;
        }
        *ppEntries = reg;
    }

    RegEntry* pEntry = (*ppEntries)+(*pnumEntries);

    if ( pszSubKey )
    {
        pEntry->pSubKey = AllocStr( pszSubKey );
        ASSERT( pEntry->pSubKey );
    }
    else
    {
        pEntry->pSubKey = NULL;
    }

    pEntry->pValue = AllocStr( pszValue );
    ASSERT( pEntry->pValue );

    pEntry->type = dwType;
    pEntry->pBuf = pData;
    ASSERT( pData || proc );

    pEntry->size = cbData;
    pEntry->required = (BYTE) bRequired;
    pEntry->conversionProc = (FARPROC) proc;

    (*pnumEntries)++;

    Unlock();
    return TRUE;
}



BOOL CRegistry::AddKey( LPSTR pszSubKey, REGENTRY_ENUM_PROC pfnEnum, READ_TYPE type /*= STATIC*/, BOOL bRequired /*= TRUE*/ )
{
	ASSERT( pszSubKey );
	ASSERT( pfnEnum );

	HKEY hkey;
	// I could have done something fancy so these arrays could be reallocated if they 
	// needed to be, but I decided to go the easy way and statically allocated
	// obscenely high maximums.
	char pszName[512];
    DWORD cchNameLen = sizeof(pszName);
	LPSTR ppszAddedNames[512];
	DWORD cAddedNames = 0;

	BOOL bFound = FALSE, bAdded = FALSE; // did the key show up anywhere?
	DWORD dwType, dwRet, iValue = 0;

    LPBYTE pData;
	DWORD cbData, i;
	REGENTRY_CONV_PROC proc;

	for ( i=0; i < m_numRoots; i++ )
	{
		if ( RegOpenKeyExA( m_phkeyRoots[i], pszSubKey, 0, KEY_READ, &hkey ) != ERROR_SUCCESS )
		{
			continue;
		}
		bFound = TRUE;

		// Start the value enumeration.
		iValue = 0;
		
		while ( 1 )
		{
			cbData = 0;	  
            cchNameLen = sizeof(pszName);
			if ( RegEnumValueA( hkey, iValue, pszName, &cchNameLen, NULL, &dwType, NULL, &cbData ) != ERROR_SUCCESS )
			{
				break;
			}

			bAdded = FALSE;
			// has this already been added?
			for ( DWORD j=0; j < cAddedNames; j++ )
			{
				if ( !lstrcmpiA(	ppszAddedNames[j], pszName ) )
				{
					bAdded = TRUE;
					break;
				}
			}
			if ( !bAdded )
			{
				// get the storage for it.
                pData = NULL;
				proc = NULL;
                if ( (*pfnEnum)( pszName, dwType, &pData, &cbData, &proc ) )
				{
                    if ( AddValue( pszSubKey, pszName, dwType, pData, cbData, type, FALSE, proc ) )
					{
						// add the name to the added names list.
                        ASSERT( cAddedNames < sizeof(ppszAddedNames) ); // oops. better make the buffer larger.
						ppszAddedNames[cAddedNames] = new char[lstrlenA( pszName )+1];
						lstrcpyA( ppszAddedNames[cAddedNames], pszName );
						cAddedNames++;
					}
					else
					{
						// report an error or something?
						break;
					}
				}
			}
			iValue++;
		}

		RegCloseKey( hkey );
	}

    for ( i = 0 ; i < cAddedNames; i++ )
    {
        delete[] ppszAddedNames[i];
        ppszAddedNames[i] = NULL;
    }

	// if we didn't find the key anywhere and it's a required key, then there's a problem.
	if ( !bFound && bRequired )
	{
        m_pValue = AllocStr( pszSubKey );
        GetError( ErrRegOpenFailed );
        return FALSE;
	}
	return TRUE;
}



BOOL CRegistry::HasChangeOccurred()
{
    if ( !m_bChanged && m_phRootEvents )
    {
        DWORD dwWait = WaitForMultipleObjects( m_numRoots, m_phRootEvents, FALSE, 0 );

        DWORD ndxRoot = dwWait-WAIT_OBJECT_0;
        if ( (ndxRoot >= 0) && (ndxRoot < m_numRoots) )
        {
            ResetEvent(m_phRootEvents[ndxRoot]);
            RegNotifyChangeKeyValue( m_phkeyRoots[ndxRoot], TRUE, REG_NOTIFY_CHANGE_LAST_SET, m_phRootEvents[ndxRoot], TRUE );
            m_bChanged = TRUE;
        }
    }
    return m_bChanged;
}

BOOL CRegistry::ReadValues()
{
    m_bChanged = FALSE;

    Lock();

    BOOL bRet = TRUE;
    BOOL bFirst = !m_bStaticRead;
    if ( bFirst )
    {
        m_bStaticRead = TRUE;
        bRet = Read( m_Static, m_numStatic );
    }

    if ( bRet )
    {
        bRet = Read( m_Dynamic, m_numDynamic );
    }

    if ( !bRet )
    {
        char buf[1024];
        ComposeErrorString( buf, sizeof(buf) );
        DebugPrint( buf );
    }
    else
    {
        if(!bFirst)
            ZoneEventLogReport(ZONE_S_REGISTRY_READ, 0, NULL, 0, NULL);
    }

    Unlock();

    return bRet;
}



BOOL CRegistry::Read( RegEntry* pEntries, DWORD numEntries )
{
    m_pErr = NULL;
    m_pValue = NULL;

    if ( !pEntries )
        return TRUE;

    HKEY* phkeySub = NULL;
    LPSTR pSubKey = NULL;


    phkeySub = new HKEY[m_numRoots];
    ZeroMemory( phkeySub, sizeof(HKEY)*m_numRoots );

    Lock();

    for ( DWORD entry = 0; entry < numEntries; entry++ )
    {
        BYTE pBuf[4000];
        DWORD type;
        BOOL bFound = FALSE;

        m_pErr = NULL;
        m_pValue = NULL;

        pSubKey = NULL;

        for( DWORD ndx = 0; !bFound && (ndx < m_numRoots); ndx++ )
        {
            if ( !m_phkeyRoots[ndx] )
                continue;

            HKEY hkey;
            if ( pEntries[entry].pSubKey == NULL )  // root
            {
                hkey = m_phkeyRoots[ndx];
            }
            else
            {

                if ( phkeySub[ndx] && pSubKey && ( pSubKey == pEntries[entry].pSubKey ) )
                {
                    // do nothing special
                }
                else
                {
                    for( DWORD key = ndx; key < m_numRoots; key++ )
                    {
                        if ( phkeySub[key] )
                        {
                            RegCloseKey( phkeySub[key] );
                            phkeySub[key] = NULL;
                        }
                    }

                    pSubKey = pEntries[entry].pSubKey;

                    DWORD dwError = RegOpenKeyExA( m_phkeyRoots[ndx], pSubKey, 0, KEY_READ, phkeySub+ndx );
                    if ( dwError || !phkeySub[ndx] )
                    {
                        continue;
                    }
                }
                hkey = phkeySub[ndx];
            }


            m_pValue = pEntries[entry].pValue;
            DWORD size = pEntries[entry].size;
            if ( pEntries[entry].conversionProc )
            {
                size = sizeof(pBuf);
            }
            if ( ERROR_SUCCESS == RegQueryValueExA(hkey, m_pValue, NULL, &type, pBuf, &size) )
            {
                if ( type != pEntries[entry].type &&
                     !( ( pEntries[entry].type == REG_SZ ) && ( type == REG_EXPAND_SZ ) )
                   )
                {
                    switch( pEntries[entry].type )
                    {
                        case REG_DWORD:
                            GetError( ErrNotDword );
                            break;
                        case REG_SZ:
                            GetError( ErrNotSZ );
                            break;
                        case REG_MULTI_SZ:
                            GetError( ErrNotMultiSZ );
                            break;
                        default:
                            GetError( ErrUnsupported );
                            break;
                    }
                    goto exit;
                }
                else
                {
                    if ( type == REG_EXPAND_SZ )
                    {
                        BYTE pBuf2[sizeof(pBuf)];
                        ExpandEnvironmentStrings( (LPCTSTR) pBuf, (LPTSTR) pBuf2, sizeof(pBuf2) );
                        CopyMemory( pBuf, pBuf2, sizeof( pBuf ) );
                    }

                    if ( pEntries[entry].conversionProc )
                    {
                        bFound = (*(REGENTRY_CONV_PROC)(pEntries[entry].conversionProc))( m_pValue, pEntries[entry].pBuf, pBuf, size );
                        if ( !bFound )
                            GetError( ErrInvalid );
                    }
                    else
                    {
                        ASSERT( size <= pEntries[entry].size );
                        ASSERT( pEntries[entry].pBuf );
                        CopyMemory( pEntries[entry].pBuf, pBuf, size );
                        bFound = TRUE;
                    }

                }
            }

        }

        if ( bFound )
        {
            switch( type )
            {
                case REG_DWORD:
                    DebugPrint( "%d\\%s\\%s: %d\n", ndx-1, (pSubKey)?pSubKey:"", m_pValue, *(DWORD*)pBuf );
                    break;
                case REG_SZ:
                case REG_MULTI_SZ:  // just print the first line
                    DebugPrint( "%d\\%s\\%s: %s\n", ndx-1, (pSubKey)?pSubKey:"" , m_pValue, pBuf );
                    break;
            }
        }
        else if ( pEntries[entry].required ) // not found, but required
        {
            if ( !m_pValue )
            {
                if ( pSubKey )
                    m_pValue = AllocStr( pSubKey );
                GetError( ErrRegOpenFailed );
            }
            else if ( m_pErr == NULL )
            {
                GetError( ErrNotFound );
            }
            goto exit;
        }
    }
  exit:
    Unlock();

    if ( phkeySub )
    {
        for( DWORD ndx = 0; ndx < m_numRoots; ndx++ )
        {
            if ( phkeySub[ndx] )
            {
                RegCloseKey( phkeySub[ndx] );
                phkeySub[ndx] = NULL;
            }
        }
        delete [] phkeySub;
    }

    return ( m_pErr == NULL );

}


void CRegistry::OffsetStrPtrs( RegEntry* pEntries, DWORD numEntries, long offset )
{
    for ( DWORD ndx = 0; ndx < numEntries; ndx++ )
    {
        pEntries[ndx].pSubKey += offset;
        pEntries[ndx].pValue += offset;
    }
}

LPSTR CRegistry::AllocStr( LPSTR str )
{
    ASSERT(str);

    LPSTR pstr = NULL;
    DWORD len = lstrlenA( str ) + 1;
    if ( len >= m_cbStrBufRemaining )
    {
        m_cbStrBuf += 4000;
        m_cbStrBufRemaining += 4000;
        ASSERT( len <= m_cbStrBuf - 2 );
        LPSTR pBuf = (LPSTR) ZRealloc( m_StrBuf, m_cbStrBuf );
        if ( !pBuf )
            return NULL;


        long offset = pBuf - m_StrBuf;
        if ( offset != 0 )
        {
            OffsetStrPtrs( m_Static, m_numStatic, offset );
            OffsetStrPtrs( m_Dynamic, m_numDynamic, offset );
        }

        m_StrBuf = pBuf;
        ZeroMemory( m_StrBuf+ m_cbStrBuf-m_cbStrBufRemaining ,m_cbStrBufRemaining );

    }

    pstr = m_StrBuf;
    while( *pstr )
    {
        if ( lstrcmpiA( pstr, str ) == 0 )
            goto exit;
        pstr += lstrlenA( pstr ) + 1;
    }

    lstrcpyA( pstr, str );
    pstr[len+1] = '\0';  // add double null terminator
    m_cbStrBufRemaining -= len;

  exit:
    return pstr;

}


BOOL CRegistry::ComposeErrorString( LPSTR pszBuf, DWORD len )
{
    pszBuf[0] = '\0';
    if ( m_pErr && m_pValue )
    {
        if ( len > (DWORD)( lstrlenA( m_pErr ) + lstrlenA( m_pValue ) + 1 ) )
        {
            lstrcpyA( pszBuf, m_pValue );
            lstrcatA( pszBuf, m_pErr );
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\games\checkers\check1.cpp ===
/*******************************************************************************
  
  check1.c
  
  ZCheckers game server endian routines. 

  Copyright  Electric Gravity, Inc. 1994. All rights reserved.
  Written by Kevin Binkley, Hoon Im
  Created on Saturday, November 12, 1994 03:51:47 PM
  
  Change History (most recent first):
  ----------------------------------------------------------------------------
  Rev	 |	Date	 |	Who	 |	What
  ----------------------------------------------------------------------------
  0		03/09/95	KJB		Created.
  
*******************************************************************************/


#include "zone.h"
#include "checklib.h"
#include "checkers.h"

/*
         client -> server messages
*/

void ZCheckersMsgNewGameEndian(ZCheckersMsgNewGame* m)
{
  ZEnd32(&m->protocolSignature);
  ZEnd32(&m->protocolVersion);
  ZEnd32(&m->clientVersion);
  ZEnd16(&m->seat);
  ZEnd32(&m->playerID);
}

void ZCheckersMsgMovePieceEndian(ZCheckersMsgMovePiece* m)
{
  ZEnd16(&m->seat);
}

void ZCheckersMsgTalkEndian(ZCheckersMsgTalk* m)
{
	ZEnd32(&m->userID);
 	ZEnd16(&m->seat);
	ZEnd16(&m->messageLen);
}

void ZCheckersMsgGameStateEndian(ZCheckersMsgGameState* m)
{
	ZEnd32(&m->gameOptions);
}

void ZCheckersMsgEndGameEndian(ZCheckersMsgEndGame* m)
{
	ZEnd16(&m->seat);
	ZEnd32(&m->flags);
}

void ZCheckersMsgFinishMoveEndian(ZCheckersMsgFinishMove* m)
{
	ZEnd16(&m->seat);
	ZEnd16(&m->drawSeat);
	ZEnd32(&m->time);
}

void ZCheckersMsgGameStateReqEndian(ZCheckersMsgGameStateReq* m)
{
    ZEnd32(&m->userID);
    ZEnd16(&m->seat);
}

void ZCheckersMsgGameStateRespEndian(ZCheckersMsgGameStateResp* m)
{
	int16 i;

    ZEnd32(&m->userID);
    ZEnd16(&m->seat);
	ZEnd16(&m->gameState);
	ZEnd16(&m->finalScore);
	for (i = 0;i < 2;i++) {
		ZEnd16(&m->newGameVote[i]);
		ZEnd32(&m->players[i].userID);
	}
}

void ZCheckersMsgEndLogEndian(ZCheckersMsgEndLog* m)
{

}

void ZCheckersMsgOfferDrawEndian(ZCheckersMsgDraw*m)
{
	ZEnd16(&m->seat);
	ZEnd16(&m->vote);
}

void ZCheckersMsgVoteNewGameEndian(ZCheckersMsgVoteNewGame* m)
{
	ZEnd16(&m->seat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\components\zoneutil\zoneutil.cpp ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneUtil.cpp
 * 
 * Contents:	Utility functions
 *
 *****************************************************************************/
#include "ZoneUtil.h"
#include "ZoneString.h"

//		VER_PLATFORM_WIN32s             
//		VER_PLATFORM_WIN32_WINDOWS      
//		VER_PLATFORM_WIN32_NT          
 
DWORD ZONECALL GetOSType(void)
{
	OSVERSIONINFO ver;
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&ver);
	return ver.dwPlatformId;
}


//////////////////////////////////////////////////////////////////////////////////////
//	StrVerCmp
//	pszCurrVer		Version string of file
//	pszVersion		Version string to compare to
//
//	Return Values
//	If pszCurrVer is less than the pszStrVer, the return value is negative. 
//	If pszCurrVer is greater than the pszStrVer, the return value is positive. 
//	If pszCurrVer is equal to the pszStrVer, the return value is zero.
//
//////////////////////////////////////////////////////////////////////////////////////
int ZONECALL StrVerCmp(const char * pszCurrVer, const char * pszStrVer)
{
	DWORD	dwFileVer[5] = {0,0,0,0,0};
	DWORD	dwSZVer[5] = {0,0,0,0,0};
	char	pszCurrentVersion[64];
	char	pszVersion[64];

	lstrcpyA(pszCurrentVersion, pszCurrVer);
	lstrcpyA(pszVersion, pszStrVer);
	
	// Do it for the file string
	int nIdx = 5;
	int len = lstrlenA(pszCurrentVersion);
	while (nIdx > 0 && len >= 0)
	{
		while (len )
		{
			if (pszCurrentVersion[len] == '.' || pszCurrentVersion[len] == ',')
			{
				len++;
				break;
			}	
			len--;
		}
		dwFileVer[--nIdx] = zatolA(&pszCurrentVersion[len]);
		if (--len > 0) // See if we need to term at last . or ,
			pszCurrentVersion[len] = '\0';
		// Start searching before
		len--;
	}
	// Now do it for the other string
	nIdx = 5;
	len = lstrlenA(pszVersion);
	while (nIdx > 0 && len >= 0)
	{
		while (len )
		{
			if (pszVersion[len] == '.' || pszVersion[len] == ',')
			{
				len++;
				break;
			}	
			len--;
		}
		dwSZVer[--nIdx] = zatolA(&pszVersion[len]);
		if (--len > 0) // See if we need to term at last . or ,
			pszVersion[len] = '\0';
		// Start searching before
		len--;
	}
	
	// Now compare results, return same values as lstrcmp
	int nDif;
	for (nIdx =0; nIdx < 5; nIdx++)
	{
		nDif = dwFileVer[nIdx] - dwSZVer[nIdx];
		if (nDif != 0)
			break;
	}

	return nDif;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\games\hearts\hearts1.c ===
/*******************************************************************************
	
	game1.c
	
	ZHearts game server endian routines. 

	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Kevin Binkley, Hoon Im
	Created on Saturday, November 12, 1994 03:51:47 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		03/09/95	KJB		Created.
	
*******************************************************************************/


#include "zone.h"
#include "hearts.h"


void ZHeartsMsgStartGameEndian(ZHeartsMsgStartGame* m)
{
	int16			i;
	
	
	ZEnd16(&m->numCardsInPass);
	ZEnd16(&m->numCardsInHand);
	ZEnd16(&m->numPointsInGame);
	ZEnd32(&m->gameOptions);
	
	for (i = 0; i < zHeartsMaxNumPlayers; i++)
		ZEnd32(&m->players[i]);
}

void ZHeartsMsgReplacePlayerEndian(ZHeartsMsgReplacePlayer* m)
{
	ZEnd32(&m->playerID);
	ZEnd16(&m->seat);
	ZEnd16(&m->fPrompt);
}

void ZHeartsMsgStartHandEndian(ZHeartsMsgStartHand* m)
{
	ZEnd16(&m->passDir);
}

void ZHeartsMsgStartPlayEndian(ZHeartsMsgStartPlay* m)
{
	ZEnd16(&m->seat);
}

void ZHeartsMsgEndHandEndian(ZHeartsMsgEndHand* m)
{
	int16 i;


	for (i = 0;i < zHeartsMaxNumPlayers; i++)
		ZEnd16(&m->score[i]);
	ZEnd16(&m->runPlayer);
}

void ZHeartsMsgEndGameEndian(ZHeartsMsgEndGame *m)
{
	ZEnd16(&m->forfeiter);
}


/*
				 client -> server messages
*/

void ZHeartsMsgClientReadyEndian(ZHeartsMsgClientReady* m)
{
    ZEnd32(&m->protocolSignature);
	ZEnd32(&m->protocolVersion);
	ZEnd32(&m->version);
    ZEnd16(&m->seat);
}

void ZHeartsMsgPassCardsEndian(ZHeartsMsgPassCards* m)
{
	ZEnd16(&m->seat);
}

void ZHeartsMsgPlayCardEndian(ZHeartsMsgPlayCard* m)
{
	ZEnd16(&m->seat);
}

void ZHeartsMsgNewGameEndian(ZHeartsMsgNewGame* m)
{
	ZEnd16(&m->seat);
}

void ZHeartsMsgTalkEndian(ZHeartsMsgTalk* m)
{
	ZEnd32(&m->userID);
	ZEnd16(&m->seat);
	ZEnd16(&m->messageLen);
}

void ZHeartsMsgGameStateRequestEndian(ZHeartsMsgGameStateRequest* m)
{
	ZEnd32(&m->userID);
	ZEnd16(&m->seat);
}

void ZHeartsMsgGameStateResponseEndian(ZHeartsMsgGameStateResponse* m, int16 conversion)
{
    int16           i, j;
    int16           numScores;
	
	
	ZEnd32(&m->gameOptions);
	ZEnd16(&m->numCardsToPass);
	ZEnd16(&m->numCardsInDeal);
	ZEnd16(&m->numPointsForGame);
	ZEnd16(&m->playerToPlay);
	ZEnd16(&m->passDirection);
	ZEnd16(&m->numCardsInHand);
	ZEnd16(&m->leadPlayer);
	ZEnd16(&m->state);

	for (i = 0; i < zHeartsMaxNumPlayers; i++)
	{
		ZEnd16(&m->scores[i]);
		ZEnd16(&m->playerPassed[i]);
		ZEnd16(&m->tricksWon[i]);
		ZEnd32(&m->players[i]);
		ZEnd32(&m->playersToJoin[i]);
		ZEnd32(&m->tableOptions[i]);
		ZEnd16(&m->newGameVotes[i]);
	}

	ZEnd16(&m->nCloseStatus);
	ZEnd16(&m->nCloserSeat);

    if ( conversion == zEndianToStandard )
    {
        numScores = m->numHandsPlayed;
        ZEnd16(&m->numHandsPlayed);
    }
    else
    {
        ZEnd16(&m->numHandsPlayed);
        numScores = m->numHandsPlayed;
    }

    for (i = 0; i < numScores; i++)
        for (j = 0; j < zHeartsMaxNumPlayers; j++)
            ZEnd16(&m->scoreHistory[i*zHeartsMaxNumPlayers+j]);
}


void ZHeartsMsgOptionsEndian(ZHeartsMsgOptions* m)
{
	ZEnd16(&m->seat);
	ZEnd32(&m->options);
}


void ZHeartsMsgCheckInEndian(ZHeartsMsgCheckIn* m)
{
	ZEnd32(&m->userID);
	ZEnd16(&m->seat);
}


void ZHeartsMsgRemovePlayerRequestEndian(ZHeartsMsgRemovePlayerRequest* msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->targetSeat);
	ZEnd16(&msg->ratedGame);
}


void ZHeartsMsgRemovePlayerResponseEndian(ZHeartsMsgRemovePlayerResponse* msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->requestSeat);
	ZEnd16(&msg->targetSeat);
	ZEnd16(&msg->response);
}

void ZHeartsMsgDossierDataEndian(ZHeartsMsgDossierData *msg)
{
	ZEnd16(&msg->seat);
	ZEnd32(&msg->user);
	ZEnd16(&msg->message);
}

void ZHeartsMsgDossierVoteEndian(ZHeartsMsgDossierVote *msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->vote);
}


void ZHeartsMsgCloseRequestEndian(ZHeartsMsgCloseRequest *msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->nClose);
}


void ZHeartsMsgCloseDeniedEndian(ZHeartsMsgCloseDenied *msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->reason);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\games\backgammon\backgammon1.c ===
/*******************************************************************************
  
  backgammon1.c
  
  Backgammon endian routines

  Change History (most recent first):
  ----------------------------------------------------------------------------
  Rev	 |	Date	 |	Who	 |	What
  ----------------------------------------------------------------------------
  0			10/30/96	CHB		Created
  
*******************************************************************************/


#include "zone.h"
#include "bgmsgs.h"

void ZBGMsgTalkEndian( ZBGMsgTalk* m )
{
	ZEnd32(&m->userID);
	ZEnd16(&m->seat);
	ZEnd16(&m->messageLen);
}


void ZBGMsgTurnNotationEndian( ZBGMsgTurnNotation* m )
{
	ZEnd16(&m->seat);
	ZEnd16(&m->type);
	ZEnd32(&m->nChars);
}


void ZBGMsgTimestampEndian( ZBGMsgTimestamp* m )
{
	ZEnd32( &m->dwLoTime );
	ZEnd32( &m->dwHiTime );
}

//Backgammon dice roll fix: New endian functions needed for clients.
void ZBGMsgRollRequestEndian(ZBGMsgRollRequest *m)
{
	ZEnd16(&m->seat);
}

void ZBGMsgDiceRollEndian(ZBGMsgDiceRoll *m)
{
	
	ZEnd16( &m->seat );
	ZEnd32( &(m->d1.EncodedValue) );
	ZEnd16( &(m->d1.EncoderAdd)   );
	ZEnd16( &(m->d1.EncoderMul)   );
	ZEnd32( &(m->d1.numUses)      );
	ZEnd16( &(m->d1.Value)        );
	ZEnd32( &(m->d2.EncodedValue) );
	ZEnd16( &(m->d2.EncoderAdd)   );
	ZEnd16( &(m->d2.EncoderMul)   );
	ZEnd32( &(m->d2.numUses)      );
	ZEnd16( &(m->d2.Value)        );
	

}

void ZBGMsgEndLogEndian(ZBGMsgEndLog *m)
{}

void ZBGMsgFirstMoveEndian(ZBGMsgFirstMove *m)
{
	ZEnd32(&m->numPoints);
}

void ZBGMsgCheaterEndian(ZBGMsgCheater *m)
{
	
	ZEnd16(&m->seat);

	//TODO::Dice endians
	//ZEnd16(&m->dice1);
	//ZEnd16(&m->dice2);

	ZEnd16(&m->move);
}

DICEINFO EncodeDice(int16 Dice)
{
	DICEINFO DiceInfo;

	//Not really sure if this is the best scheme.. Having a large encoded value as the result means having little effect on the 
	//reduced result if the value is slightly changed.
	DiceInfo.EncoderMul		= (int16)ZRandom(1123) + 37;
	DiceInfo.EncoderAdd		= (int16)ZRandom(1263) + 183;
	DiceInfo.EncodedValue   = ( (((int32)Dice * (int32)DiceInfo.EncoderMul) + (int32)DiceInfo.EncoderAdd) * 384 ) + 47;
	DiceInfo.Value			= Dice;

	return  DiceInfo;
}

int32 DecodeDice(LPDICEINFO pDiceInfo)
{
	return (int32) ( ((pDiceInfo->EncodedValue - 47) / 384) - (int32)pDiceInfo->EncoderAdd) / (int32)pDiceInfo->EncoderMul;
}

BOOL DiceValid(LPDICEINFO pDiceInfo)
{
	if ( DecodeDice(pDiceInfo) != pDiceInfo->Value )
	{

		//If the value is lower then the encoded value then test if the value was changed
		//on the client.  This can occur iff the opponent was bearing off a peice with a roll
		//that was higher then required as they had no other moves.
		if ( pDiceInfo->Value < DecodeDice(pDiceInfo) ) 														
		{
			if ( ClientNewDecode(pDiceInfo) != pDiceInfo->Value )
			{
				//If the client decode fails then the player that sent the message is probably cheating not %100
				return FALSE;
			}
		}

		return FALSE;
	}
		
	return TRUE;
}


void ClientNewEncode(LPDICEINFO pDice, int16 newValue)
{
	pDice->EncoderMul		= (int16)ZRandom(13) + 1;
	pDice->EncoderAdd		= (int16)ZRandom(18) + 1;
	pDice->EncodedValue     = ( (((int32)newValue * (int32)pDice->EncoderMul) + (int32)pDice->EncoderAdd) * 12 ) + 7;
	pDice->Value			= newValue;
}

int32 ClientNewDecode(LPDICEINFO pDiceInfo)
{
	return (int32) ( ((pDiceInfo->EncodedValue - 7) / 12) - (int32)pDiceInfo->EncoderAdd) / (int32)pDiceInfo->EncoderMul;
}

void EncodeUses(LPDICEINFO pDice, int32 numUses)
{
	pDice->numUses = (int32)(((numUses * 16 ) + 31) * (int32)(pDice->EncoderMul+3)) + (int32)(pDice->EncoderAdd+4);	
}

int32 DecodeUses( LPDICEINFO pDice )
{
	return (((pDice->numUses - (int32)(pDice->EncoderAdd+4)) / (int32)(pDice->EncoderMul+3)) - 31) / 16;
}

int32 EncodedUsesAdd(LPDICEINFO pDice)
{
	EncodeUses( pDice, DecodeUses(pDice) + 1 );
	return DecodeUses( pDice );
}


int32 EncodedUsesSub(LPDICEINFO pDice)
{
	EncodeUses( pDice, DecodeUses(pDice) - 1 );
	return DecodeUses( pDice );
}


BOOL IsValidUses(LPDICEINFO pDice)
{
	if ( DecodeUses( pDice ) < 0 || DecodeUses( pDice ) > 2 )
		return FALSE;

	return TRUE;
}


// from gamelib (zgame1.cpp)
void ZGameMsgCheckInEndian(ZGameMsgCheckIn* msg)
{
	ZEnd32(&msg->protocolSignature);
	ZEnd32(&msg->protocolVersion);
	ZEnd32(&msg->clientVersion);
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
	ZEnd16(&msg->playerType);
}


void ZGameMsgReplacePlayerEndian(ZGameMsgReplacePlayer* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}


void ZGameMsgTableOptionsEndian(ZGameMsgTableOptions* msg)
{
	ZEnd16(&msg->seat);
	ZEnd32(&msg->options);
}


void ZGameMsgGameStateRequestEndian(ZGameMsgGameStateRequest* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}


void ZGameMsgGameStateResponseEndian(ZGameMsgGameStateResponse* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\games\reversi\rever1.cpp ===
/*******************************************************************************
  
  rever1.c
  
  ZReversi game server endian routines. 

  Copyright  Electric Gravity, Inc. 1994. All rights reserved.
  Written by Kevin Binkley, Hoon Im
  Created on Saturday, November 12, 1994 03:51:47 PM
  
  Change History (most recent first):
  ----------------------------------------------------------------------------
  Rev	 |	Date	 |	Who	 |	What
  ----------------------------------------------------------------------------
  0		03/09/95	KJB		Created.
  
*******************************************************************************/


#include "zone.h"
#include "reverlib.h"
#include "reversi.h"

/*
         client -> server messages
*/

void ZReversiMsgNewGameEndian(ZReversiMsgNewGame* m)
{
  ZEnd32(&m->protocolSignature);
  ZEnd32(&m->protocolVersion);
  ZEnd32(&m->clientVersion);
  ZEnd32(&m->playerID);
  ZEnd16(&m->seat);
}

void ZReversiMsgMovePieceEndian(ZReversiMsgMovePiece* m)
{
  ZEnd16(&m->seat);
}

void ZReversiMsgTalkEndian(ZReversiMsgTalk* m)
{
	ZEnd32(&m->userID);
 	ZEnd16(&m->seat);
	ZEnd16(&m->messageLen);
}

void ZReversiMsgGameStateEndian(ZReversiMsgGameState* m)
{
	ZEnd32(&m->gameOptions);
}

void ZReversiMsgEndGameEndian(ZReversiMsgEndGame* m)
{
	ZEnd16(&m->seat);
	ZEnd32(&m->flags);
}

void ZReversiMsgFinishMoveEndian(ZReversiMsgFinishMove* m)
{
	ZEnd16(&m->seat);
	ZEnd32(&m->time);
}

void ZReversiMsgGameStateReqEndian(ZReversiMsgGameStateReq* m)
{
    ZEnd32(&m->userID);
    ZEnd16(&m->seat);
}

void ZReversiMsgGameStateRespEndian(ZReversiMsgGameStateResp* m)
{
	int16 i;

    ZEnd32(&m->userID);
    ZEnd16(&m->seat);
	ZEnd16(&m->gameState);
	ZEnd16(&m->finalScore);
	ZEnd16(&m->whiteScore);
	ZEnd16(&m->blackScore);
	for (i = 0;i < 2;i++) {
		ZEnd16(&m->newGameVote[i]);
		ZEnd32(&m->players[i].userID);
	}
}

void ZReversiMsgEndLogEndian(ZReversiMsgEndLog* m)
{
}

void ZReversiMsgVoteNewGameEndian(ZReversiMsgVoteNewGame* m)
{
	ZEnd16(&m->seat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\apiutil.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    apiutil.h

Abstract:

    Common internet server functions.

Author:

    Murali R. Krishnan  (MuraliK)    15-Sept-1995

Environment:

    Win32 User Mode

Project:

    Common Code for Internet Services

Revision History:

--*/


#ifndef _APIUTIL_HXX_
#define _APIUTIL_HXX_


# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus


#ifdef MIDL_PASS
# define RPC_STATUS   long
#else 
# include <rpc.h>
#endif // MIDL_PASS


//
//  RPC utilities
//


# define PROT_SEQ_NP_OPTIONS_A     "Security=Impersonation Dynamic False"
# define PROT_SEQ_NP_OPTIONS_W    L"Security=Impersonation Dynamic False"

#ifdef UNICODE
#define PROT_SEQ_NP_OPTIONS PROT_SEQ_NP_OPTIONS_W
#else
#define PROT_SEQ_NP_OPTIONS PROT_SEQ_NP_OPTIONS_A
#endif

/*
extern PVOID
MIDL_user_allocate( IN size_t Size);

extern VOID
MIDL_user_free( IN PVOID pvBlob);
*/



extern RPC_STATUS
RpcBindHandleForServerA( OUT handle_t * pBindingHandle,
                       IN LPSTR      pszServerName,
                       IN LPSTR      pszInterfaceName,
                       IN LPSTR      pszOptions
                       );


extern RPC_STATUS
RpcBindHandleFree( IN OUT handle_t * pBindingHandle);


# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _APIUTIL_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\basicatl.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		BasicATL.h
 *
 * Contents:	Simplest possible ATL object.
 *
 *****************************************************************************/

#pragma once

#include <Windows.h>
#include <ZoneDebug.h>

// Turn off unused options
// #define _ATL_NO_CONNECTION_POINTS
#define _ATL_STATIC_REGISTRY

// Eliminate CRT dependencies
//#define _ATL_MIN_CRT
#define _ATL_NO_DEBUG_CRT

// we now define ASSERT to __assume in retail
// this breaks ATLASSERT because they assume it to be compiled out in retail
// for example, atlwin.h line 2365, an ATLASSERT references a debug-only member
#ifdef _DEBUG
#define _ASSERTE(X)	ASSERT(X)
#else
#define _ASSERTE(X) ((void)0)
#endif

	
//!! WIN95GOLD
#define VarUI4FromStr	ulVal = 0;			// used in statreg.h

// Define ATL global variables
#include <atlbase.h>

//!! WIN95GOLD
#define OleCreateFontIndirect		// used in atlhost
#define OleCreatePropertyFrame		// used in atlctl.h

#include <ZoneATL.h>

extern CZoneComModule _Module;



#include <atlcom.h>
#include <atltmp.h>
#include <atlctl.h>
#include <atlhost.h>

#include "ZoneWin.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\games\spades\spades1.c ===
/*******************************************************************************
	
	spades1.c
	
	Spades endian routines. 

	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on Thursday, February 8, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		02/08/96	HI		Created.
	1		05/19/98	leonp	added dossier messages	
*******************************************************************************/


#include "zone.h"
#include "spades.h"


void ZSpadesMsgClientReadyEndian(ZSpadesMsgClientReady* msg)
{
    ZEnd32(&msg->protocolSignature);
	ZEnd32(&msg->protocolVersion);
	ZEnd32(&msg->version);
    ZEnd32(&msg->playerID);
    ZEnd16(&msg->seat);
}


void ZSpadesMsgStartGameEndian(ZSpadesMsgStartGame* msg)
{
	int16			i;
	
	
	for (i = 0; i < zSpadesNumPlayers; i++)
		ZEnd32(&msg->players[i]);

	ZEnd16(&msg->numPointsInGame);
	ZEnd32(&msg->gameOptions);
}


void ZSpadesMsgReplacePlayerEndian(ZSpadesMsgReplacePlayer* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
	ZEnd16(&msg->fPrompt);
}


void ZSpadesMsgStartBidEndian(ZSpadesMsgStartBid* msg)
{
	ZEnd16(&msg->boardNumber);
	ZEnd16(&msg->dealer);
}


void ZSpadesMsgStartPassEndian(ZSpadesMsgStartPass* msg)
{
}


void ZSpadesMsgStartPlayEndian(ZSpadesMsgStartPlay* msg)
{
	ZEnd16(&msg->leader);
}


void ZSpadesMsgEndHandEndian(ZSpadesMsgEndHand* msg)
{
	int16			i;
	
	
	for (i = 0; i < zSpadesNumTeams; i++)
		ZEnd16(&msg->bags[i]);
}


void ZSpadesMsgEndGameEndian(ZSpadesMsgEndGame* msg)
{
}


void ZSpadesMsgBidEndian(ZSpadesMsgBid* msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->nextBidder);
}


void ZSpadesMsgPassEndian(ZSpadesMsgPass* msg)
{
	ZEnd16(&msg->seat);
}


void ZSpadesMsgPlayEndian(ZSpadesMsgPlay* msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->nextPlayer);
}


void ZSpadesMsgNewGameEndian(ZSpadesMsgNewGame* msg)
{
	ZEnd16(&msg->seat);
}


void ZSpadesMsgTalkEndian(ZSpadesMsgTalk* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->messageLen);
}


void ZSpadesMsgGameStateRequestEndian(ZSpadesMsgGameStateRequest* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}


void ZSpadesMsgGameStateResponseEndian(ZSpadesMsgGameStateResponse* msg, int16 conversion)
{
	int16			i, j, count;
	
	
	ZEnd32(&msg->gameOptions);
	ZEnd16(&msg->numPointsInGame);
	ZEnd16(&msg->minPointsInGame);
	ZEnd16(&msg->numHandsPlayed);
	ZEnd16(&msg->numGamesPlayed);
	ZEnd16(&msg->playerToPlay);
	ZEnd16(&msg->numCardsInHand);
	ZEnd16(&msg->leadPlayer);
	ZEnd16(&msg->state);
	ZEnd16(&msg->trumpsBroken);
	
	for (i = 0; i < zSpadesNumPlayers; i++)
	{
		ZEnd32(&msg->players[i]);
		ZEnd32(&msg->playersToJoin[i]);
		ZEnd32(&msg->tableOptions[i]);
		ZEnd16(&msg->tricksWon[i]);
		ZEnd16(&msg->toPass[i]);
		ZEnd16(&msg->fShownCards[i]);
	}
	
	for (i = 0; i < zSpadesNumTeams; i++)
		ZEnd16(&msg->bags[i]);

	/* Convert total scores. */
	if (conversion == zEndianToStandard)
		count = msg->totalScore.numScores;
		
	ZEnd16(&msg->totalScore.numScores);
	
	if (conversion == zEndianFromStandard)
		count = msg->totalScore.numScores;
	
	for (i = 0; i < zSpadesNumTeams; i++)
		ZEnd16(&msg->totalScore.totalScore[i]);
	for (j = 0; j < count; j++)
	{
		ZEnd16(&msg->totalScore.scores[j].boardNumber);
		for (i = 0; i < zSpadesNumTeams; i++)
		{
			ZEnd16(&msg->totalScore.scores[j].scores[i]);
			ZEnd16(&msg->totalScore.scores[j].bonus[i]);
		}
	}
	
	/* Convert wins. */
	if (conversion == zEndianToStandard)
		count = msg->wins.numGames;
		
	ZEnd16(&msg->wins.numGames);
	
	if (conversion == zEndianFromStandard)
		count = msg->wins.numGames;
	
	for (i = 0; i < zSpadesNumTeams; i++)
	{
		ZEnd16(&msg->wins.wins[i]);
		for (j = 0; j < count; j++)
			ZEnd16(&msg->wins.gameScores[j][i]);
	}
}


void ZSpadesMsgOptionsEndian(ZSpadesMsgOptions* msg)
{
	ZEnd16(&msg->seat);
	ZEnd32(&msg->options);
}


void ZSpadesMsgCheckInEndian(ZSpadesMsgCheckIn* msg)
{
	ZEnd32(&msg->playerID);
	ZEnd16(&msg->seat);
}


void ZSpadesMsgTeamNameEndian(ZSpadesMsgTeamName* msg)
{
	ZEnd16(&msg->seat);
}


void ZSpadesMsgRemovePlayerRequestEndian(ZSpadesMsgRemovePlayerRequest* msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->targetSeat);
	ZEnd16(&msg->ratedGame);
}


void ZSpadesMsgRemovePlayerResponseEndian(ZSpadesMsgRemovePlayerResponse* msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->requestSeat);
	ZEnd16(&msg->targetSeat);
	ZEnd16(&msg->response);
}

//dossier
void ZSpadesMsgDossierDataEndian(ZSpadesMsgDossierData *msg)
{
	ZEnd16(&msg->seat);
	ZEnd32(&msg->user);
	ZEnd16(&msg->message);
}

void ZSpadesMsgDossierVoteEndian(ZSpadesMsgDossierVote *msg)
{
	ZEnd16(&msg->seat);
	ZEnd16(&msg->vote);
}

void ZSpadesMsgShownCardsEndian(ZSpadesMsgShownCards *msg)
{
	ZEnd16(&msg->seat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\datacenter.h ===
#ifndef DATACENTER_H
#define DATACENTER_H

BOOL SetDataCenterPath(const char* pStr);
// make sure your string is at least INTERNET_MAX_PATH_LENGTH
BOOL GetDataCenterPath(char* pStr);
BOOL SetDataFileSite(char* pStr);
BOOL GetDataFileSite(char* pStr);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\compport.h ===
// CompPort.h : interface of the CCompPort class
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _COMPPORT_H
#define _COMPPORT_H

#include "queue.h"
#include "pool.h"

struct CPortStatus
{
    CPortStatus( DWORD cbBytes, DWORD key, LPOVERLAPPED pOverlapped ) :
        m_cbBytes( cbBytes ),
        m_key( key ),
        m_pOverlapped( pOverlapped )
    {
    }

    DWORD m_cbBytes;
    DWORD m_key;
    LPOVERLAPPED m_pOverlapped;
};


class CCompletionPort
{
protected:
    CMTList<CPortStatus>*    m_queue;
    CPool<CPortStatus>*      m_pool;

    HANDLE m_hIoCompPort;
    HANDLE m_hEvent;

    LONG   m_QueuedCount;

public:
    CCompletionPort( BOOL bUseCompletePort = TRUE );
    ~CCompletionPort();

    BOOL Post( LPOVERLAPPED pOverlapped, DWORD cbBytes = 0, DWORD key = 0 );
    BOOL Get( LPOVERLAPPED* ppOverlapped, DWORD dwMilliseconds = INFINITE, DWORD* pcbBytes = NULL, DWORD* pKey = NULL );
    BOOL Associate( HANDLE hFile, DWORD key = 0, DWORD nConcurrentThreads = 0);
    
    // QueuedOverlappedIO should be called before every overlapped ReadFile / WriteFile call
    void QueueOverlappedIO() { InterlockedIncrement(&m_QueuedCount); }

    // FailedOverlappedIO should be called after any failed overlapped ReadFile / WriteFile calls
    void FailedOverlappedIO() { InterlockedDecrement(&m_QueuedCount); }
    
    LONG GetQueuedCount() { return m_QueuedCount; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\containers.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Containers.h
 *
 * Contents:	Common functions and structures for container classes
 *
 *****************************************************************************/

#ifndef __CONTAINERS_H__
#define __CONTAINERS_H__

#pragma comment(lib, "Containers.lib")

//
// Node structures
//
#pragma pack( push, 4 )

struct CListNode
{
	CListNode*	m_Next;        // next item in list
	CListNode*	m_Prev;        // previous item in list
	void*		m_Data;        // user's blob
};


struct CMTListNode
{
	CMTListNode*	m_Next;				// next item in list
	CMTListNode*	m_Prev;				// previous item in list
	void*			m_Data;				// user's blob
	long			m_DeletedAndIdx;	// node's index & high bit is lazy delete flag
};


#define DELETED_MASK	0x80000000
#define IDX_MASK		0x7fffffff

#define MARK_NODE_DELETED( pNode )	( pNode->m_DeletedAndIdx |= DELETED_MASK )
#define CLEAR_NODE_DELETED( pNode )	( pNode->m_DeletedAndIdx &= IDX_MASK )
#define IS_NODE_DELETED( pNode )	( pNode->m_DeletedAndIdx & DELETED_MASK )
#define GET_NODE_IDX( pNode )		( pNode->m_DeletedAndIdx & IDX_MASK )
#define SET_NODE_IDX( pNode, idx )	( pNode->m_DeletedAndIdx = (pNode->m_DeletedAndIdx & DELETED_MASK) | idx )

#pragma pack( pop )


//
// Handle typedefs
//
typedef CMTListNode*	MTListNodeHandle;
typedef CListNode*		  ListNodeHandle;


//
// Global pools for node allocation
//
class CPoolVoid;
extern CPoolVoid* gListNodePool;
extern CPoolVoid* gMTListNodePool;

void ZONECALL InitListNodePool(int PoolSize = 254 );
void ZONECALL ExitListNodePool();
void ZONECALL InitMTListNodePool(int PoolSize = 254 );
void ZONECALL ExitMTListNodePool();

//
// Common compare functions
//
bool ZONECALL CompareUINT32( unsigned long* p, unsigned long key );

#define CompareDWORD	CompareUINT32

//
// Common hash functions
//
DWORD ZONECALL HashInt( int Key );
DWORD ZONECALL HashUINT32( unsigned long Key );
DWORD ZONECALL HashGuid( const GUID& Key );
DWORD ZONECALL HashLPCSTR( LPCSTR szKey );
DWORD ZONECALL HashLPCWSTR( LPCWSTR szKey );

DWORD ZONECALL HashLPSTR( LPSTR szKey );
DWORD ZONECALL HashLPWSTR( LPWSTR szKey );


DWORD ZONECALL HashLPSTRLower( LPSTR );


typedef DWORD (ZONECALL *PFHASHLPSTR)( TCHAR* );

#ifdef UNICODE
#define HashLPCTSTR		HashLPCWSTR

#else //ifdef UNICODE
#define HashLPCTSTR		HashLPCSTR
#define HashLPTSTR		HashLPSTR
#define HashLPTSTRLower HashLPSTRLower
#endif //def UNICODE

#define HashDWORD	HashUINT32
#define HashString	HashLPCTSTR


DWORD __declspec(selectany) g_dwUniquenessCounter = 0;

// since T has no bearing on CUniqueness at the moment, this should be moved into the containers lib
template <class T>
class CUniqueness
{
public:
    CUniqueness() { RefreshQ(); }

    DWORD GetQ() { return m_qID; }
    bool IsQ(DWORD q) { return q == m_qID && q; }
    void RefreshQ() { m_qID = (DWORD) InterlockedIncrement((long *) &g_dwUniquenessCounter); }

private:
    DWORD m_qID;
};


#endif //!__CONTAINERS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\eventlog.h ===
#ifndef _EVENTLOG_H
#define _EVENTLOG_H


#ifdef __cplusplus

class CEventLog
{
    protected:
        HANDLE m_hLog;
        long m_RefCnt;    // reference count for m_hLog handle

    public:
        CEventLog();
       ~CEventLog();

        BOOL Register( LPCTSTR pSource );
        void Deregister( BOOL bForceUnregister = FALSE );

        WORD EventTypeFromID( DWORD dwEventID );

        BOOL Report( DWORD dwEventID,
                WORD wNumStrings = 0, LPTSTR* lpStrings = NULL,
                DWORD dwDataSize = 0, LPVOID lpData = NULL );


};

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

BOOL ZoneEventLogStartup(LPCTSTR pSource);
void ZoneEventLogShutdown();
BOOL ZoneEventLogReport( DWORD dwEventID,
                         WORD wNumStrings, LPTSTR* lpStrings,
                         DWORD dwDataSize, LPVOID lpData );

BOOL EventLogAssertHandler( TCHAR* buf );
BOOL EventLogAssertWithDialogHandler( TCHAR* buf );

#ifdef __cplusplus
};
#endif // __cplusplus

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\netcon.h ===
#ifndef _NETCON_H_
#define _NETCON_H_


typedef void* ZSConnection;
typedef BOOL (*ZSConnectionSendFilterFunc)(ZSConnection connection, void* userData, uint32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel);
typedef BOOL (*ZSConnectionTokenEnumFunc)(void* userData, char* pszToken, long secTokenEnd );


class ZNetwork;

class ZNetCon
{
  protected:
    friend ZNetwork;

    ZNetwork* m_pNetwork;

  public:
    ZNetCon( ZNetwork* pNet ) : m_pNetwork(pNet) {}
    virtual ~ZNetCon() { m_pNetwork = NULL; }

    ZNetwork* GetNetwork() { return m_pNetwork; }

    DWORD  Send(uint32 messageType, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel = 0);
    void*  Receive(uint32 *messageType, int32* len, uint32 *pdwSignature, uint32 *pdwChannel = NULL);

    BOOL   IsDisabled();
    BOOL   IsServer(); 
	BOOL   IsClosing();


    virtual void SetSendFilter(ZSConnectionSendFilterFunc func) = 0;
    virtual ZSConnectionSendFilterFunc GetSendFilter() = 0;


    virtual void   Suspend() = 0;
    virtual void   Resume() = 0;

    virtual uint32 GetLocalAddress() = 0;
    virtual char*  GetLocalName() = 0;
    virtual uint32 GetRemoteAddress() = 0;
    virtual char*  GetRemoteName() = 0;

    virtual GUID* GetUserGUID() = 0;

    virtual BOOL  GetUserName(char* name) = 0;
    virtual BOOL  SetUserName(char* name) = 0;

    virtual DWORD GetUserId() = 0;
    virtual BOOL  GetContextString(char* buf, DWORD len) = 0;

    virtual BOOL  HasToken(char* token) = 0;
    virtual BOOL  EnumTokens(ZSConnectionTokenEnumFunc func, void* userData) = 0;

    virtual int   GetAccessError() = 0;

    virtual void  SetUserData( void* UserData ) = 0;
    virtual void* GetUserData() = 0;

    virtual void  SetClass( void* conClass ) = 0;
    virtual void* GetClass() = 0;


    virtual DWORD GetLatency() = 0;
    virtual DWORD GetAcceptTick() = 0;


    void  SetTimeout(DWORD timeout);
    void  ClearTimeout();
    DWORD GetTimeoutRemaining();

};

#endif // NETCON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\netstats.h ===
#ifndef _NetSTATS_H
#define _NetSTATS_H

#include "zdef.h"  // for the stats definition

#ifdef __cplusplus
extern "C" {
#endif

extern CRITICAL_SECTION       g_csNetStats[];
extern ZONE_STATISTICS_NET    g_NetStats;

#define LockNetStats()   EnterCriticalSection(g_csNetStats)
#define UnlockNetStats() LeaveCriticalSection(g_csNetStats)

void InitializeNetStats();
void ResetNetStats();
void GetNetStats(ZONE_STATISTICS_NET* pDst);
void DeleteNetStats();

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\property.h ===
#ifndef __PROPERTY_H__
#define __PROPERTY_H__

#include <windows.h>
#include <tchar.h>
#include <objbase.h>
#include "zone.h"
#include "zonedebug.h"
#include "queue.h"
#include "hash.h"



class CProperty
{
public:
	// constructor and destructor
	CProperty();
	~CProperty();

	// initialize property
	HRESULT Set( DWORD player, const GUID& guid, void* buffer, DWORD size );

	// owner
	GUID  m_Guid;
	DWORD m_Player;

	// proerty value
	DWORD	m_Size;
	BYTE*	m_Buffer;
	DWORD	m_BufferSz;

	static int Cmp( CProperty* pObj, GUID& guid ) { return pObj->m_Guid == guid; }
};

#endif	//!__PROPERTY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\hash.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Hash.h
 *
 * Contents:	Hash table containers
 *
 *****************************************************************************/


#ifndef __HASH_H__
#define __HASH_H__

#include <ZoneDebug.h>
#include <ZoneDef.h>
#include <Containers.h>
#include <Pool.h>


///////////////////////////////////////////////////////////////////////////////
// Basic hash table (NOT thread safe)
///////////////////////////////////////////////////////////////////////////////

template <class T, class K> class CHash
{
public:

	//
	// Callback typedefs
	// 
    typedef DWORD	(ZONECALL *PFHASHFUNC)( K );
    typedef bool	(ZONECALL *PFCOMPAREFUNC)( T*, K );
    typedef bool	(ZONECALL *PFITERCALLBACK)( T*, MTListNodeHandle, void*);
    typedef void    (ZONECALL *PFDELFUNC)( T*, void* );
	typedef void	(ZONECALL *PFGETFUNC)( T* );

    //
    // Constructor and destructor
    //
    ZONECALL CHash(
				PFHASHFUNC		HashFunc,
				PFCOMPAREFUNC	CompareFunc,
				PFGETFUNC		GetFunc = NULL,
				WORD			NumBuckets = 256,
				WORD			NumLocks = 16 );
    ZONECALL ~CHash();

    //
    // Adds object into hash table using the specified key.
    // It does not check for duplicate keys.
    //
    MTListNodeHandle ZONECALL Add( K Key, T* Object );

    //
    // Returns the number of objects in the hash table
    //
    long ZONECALL Count() { return m_NumObjects; }

    //
    // Returns first object it finds associated with the specified key.
    //
    T* ZONECALL Get( K Key );

    //
    // Removes and returns first object it finds associated with the specified key.
    //
    T* ZONECALL Delete( K Key );

    //
    // Removes specified node from table.
    //
    void ZONECALL DeleteNode( MTListNodeHandle node, PFDELFUNC pfDelete = NULL, void* Cookie = NULL );

    //
    // Marks node as deleted without locking the table.  It can be
    // called from within the iterator callback (see ForEach).
    //
    void ZONECALL MarkNodeDeleted( MTListNodeHandle node, PFDELFUNC pfDelete = NULL, void* Cookie = NULL );
    
    //
    // Callback iterator.  Returns false if the iterator was prematurely
    // ended by the callback function, otherwise true.
    //
    //  Callback:
    //        Form:
    //            bool ZONECALL callback_function( T* pObject, MTListNodeHandle hNode, void* Cookie )
    //        Behavior:
    //            If the callback returns false, the iterator immediately stops.
    //            If the callback returns true, the iterator continues on to the next node.
    //        Restrictions:
    //            (1) Using any CMTHash function other than MarkNodeDeleted may result in a deadlock.
    //
    bool ZONECALL ForEach( PFITERCALLBACK pfCallback, void* Cookie );

    //
    // Removed all nodes from hash table.
    //
    void ZONECALL RemoveAll( PFDELFUNC pfDelete = NULL, void* Cookie = NULL );

    //
    // Removes nodes marked as deleted
    //
    void ZONECALL TrashDay();

protected:
    typedef DWORD	(ZONECALL *PFHASHFUNC)( K );
    typedef bool	(ZONECALL *PFCOMPAREFUNC)( T*, K );
    typedef bool	(ZONECALL *PFITERCALLBACK)( T*, MTListNodeHandle, void*);
    typedef void    (ZONECALL *PFDELFUNC)( T*, void* );

    WORD			m_NumBuckets;
    WORD			m_BucketMask;
    CMTListNode*	m_Buckets;
    PFCOMPAREFUNC	m_CompareFunc;
    PFHASHFUNC		m_HashFunc;
	PFGETFUNC       m_GetFunc;
    CMTListNode		m_PreAllocatedBuckets[1];
    long			m_NumObjects;
    long            m_Recursion;
};


///////////////////////////////////////////////////////////////////////////////
// Thread safe hash table, supports multiple readers
///////////////////////////////////////////////////////////////////////////////

template <class T, class K> class CMTHash
{
public:
	//
	// Callback typedefs
	//
    typedef DWORD	(ZONECALL *PFHASHFUNC)( K );
    typedef bool	(ZONECALL *PFCOMPAREFUNC)( T*, K );
    typedef bool	(ZONECALL *PFITERCALLBACK)( T*, MTListNodeHandle, void*);
    typedef void    (ZONECALL *PFDELFUNC)( T*, void* );
	typedef void	(ZONECALL *PFGETFUNC)( T* );

    //
    // Constructor and destructor
    //
    ZONECALL CMTHash(
				PFHASHFUNC		HashFunc,
				PFCOMPAREFUNC	CompareFunc,
				PFGETFUNC		GetFunc = NULL,
				WORD			NumBuckets = 256,
				WORD			NumLocks = 16 );
    ZONECALL ~CMTHash();


    //
    // Returns the number of objects in the hash table
    //
    long ZONECALL Count() { return m_NumObjects; }


    //
    // Adds object into hash table using the specified key.
    // It does not check for duplicate keys.
    //
    MTListNodeHandle ZONECALL Add( K Key, T* Object );

    //
    // Returns first object it finds associated with the specified key.
    //
    T* ZONECALL Get( K Key );


    //
    // Removes and returns first object it finds associated with the specified key.
    //
    T* ZONECALL Delete( K Key );

    //
    // Removes specified node from table
    //
    void ZONECALL DeleteNode( MTListNodeHandle node, PFDELFUNC pfDelete = NULL, void* Cookie = NULL );

    //
    // Marks node as deleted without locking the table.  It can be
    // called from within the iterator callback (see ForEach).
    //
    // Note: fDeleteObject flag is not available since it would require a writer lock
    // thus breaking ability to call from iterator.
    //
    void ZONECALL MarkNodeDeleted( MTListNodeHandle node );
    
    //
    // Callback iterator.  Returns false if the iterator was prematurely
    // ended by the callback function, otherwise true.
    //
    //  Callback:
    //        Form:
    //            int callback_function( T* pObject, MTListNodeHandle hNode, void* Cookie )
    //        Behavior:
    //            If the callback returns false, the iterator immediately stops.
    //            If the callback returns true, the iterator continues on to the next node.
    //        Restrictions:
    //            (1) Using any CMTHash function other than MarkNodeDeleted may result in a deadlock.
    //
    bool ZONECALL ForEach( PFITERCALLBACK pfCallback, void* Cookie );

    //
    // Removed all nodes from hash table.
    //
    void ZONECALL RemoveAll( PFDELFUNC pfDelete = NULL, void* Cookie = NULL );

    //
    // Removes nodes marked as deleted
    //
    void ZONECALL TrashDay();

protected:
    struct HashLock
    {
		ZONECALL HashLock()		{ InitializeCriticalSection( &m_Lock ); }
		ZONECALL ~HashLock()	{ DeleteCriticalSection( &m_Lock ); }

        CRITICAL_SECTION	m_Lock;
        HANDLE				m_ReaderKick;
        ULONG				m_NumReaders;
    };

    inline void ZONECALL WriterLock( HashLock* pLock )
    {
        EnterCriticalSection( &(pLock->m_Lock) );
        while ( pLock->m_NumReaders > 0 )
        {
            WaitForSingleObject( pLock->m_ReaderKick, 100 );
        }
    }

    inline void ZONECALL WriterRelease( HashLock* pLock )
    {
        LeaveCriticalSection( &(pLock->m_Lock) );
    }

    inline void ZONECALL ReaderLock( HashLock* pLock )
    {
        EnterCriticalSection( &(pLock->m_Lock) );
        InterlockedIncrement( (long*) &pLock->m_NumReaders );
		LeaveCriticalSection( &(pLock->m_Lock) );
    }

    inline void ZONECALL ReaderRelease( HashLock* pLock )
    {
        InterlockedDecrement( (long*) &pLock->m_NumReaders );
        SetEvent( pLock->m_ReaderKick );
    }
    
    WORD			m_NumBuckets;
    WORD			m_BucketMask;
    WORD			m_NumLocks;
    WORD			m_LockMask;
    CMTListNode*	m_Buckets;
    HashLock*		m_Locks;
    PFCOMPAREFUNC	m_CompareFunc;
    PFHASHFUNC		m_HashFunc;
	PFGETFUNC       m_GetFunc;
    long			m_NumObjects;
    long            m_Recursion;
};


///////////////////////////////////////////////////////////////////////////////
// Inline implementation of CHash
///////////////////////////////////////////////////////////////////////////////

template<class T, class K> inline
ZONECALL CHash<T,K>::CHash( PFHASHFUNC HashFunc, PFCOMPAREFUNC CompareFunc, PFGETFUNC GetFunc, WORD NumBuckets, WORD NumLocks )
{
    CMTListNode* pBucket;
    WORD i;

    InitMTListNodePool();

	//
    // Set callback functions
    //
    m_HashFunc = HashFunc;
	m_CompareFunc = CompareFunc;
	m_GetFunc = GetFunc;
    ASSERT( HashFunc != NULL );
    ASSERT( CompareFunc != NULL );

    m_NumObjects = 0;
    m_Recursion = 0;

	//
    // Force the number of buckets to a power of 2 so we can replace
    // MOD with an AND.
    //
    for (i = 15; i >= 0; i--)
    {
        m_BucketMask = (1 << i);
        if (NumBuckets & m_BucketMask)
        {
            if (NumBuckets ^ m_BucketMask)
            {    
                i++;
                m_BucketMask = (1 << i);
            }
            break;
        }
    }
    ASSERT( i < 16);
    m_NumBuckets = m_BucketMask;
    m_BucketMask--;

	//
    // Allocate and initialize buckets
    //
    if ( m_NumBuckets <= (sizeof(m_PreAllocatedBuckets) / sizeof(CMTListNode)) )
        m_Buckets = m_PreAllocatedBuckets;
    else
        m_Buckets = new CMTListNode[ m_NumBuckets ];
    ASSERT( m_Buckets != NULL );
    for ( i = 0; i < m_NumBuckets; i++ )
    {
        pBucket = &m_Buckets[i];
        pBucket->m_Next = pBucket;
        pBucket->m_Prev = pBucket;
        pBucket->m_Data = NULL;
        SET_NODE_IDX( pBucket, i );
        MARK_NODE_DELETED( pBucket ); // unusual but it simplifies the lookup routines
    }
}


template<class T, class K> inline 
ZONECALL CHash<T,K>::~CHash()
{
    ASSERT(!m_NumObjects);

    CMTListNode* pBucket;
    CMTListNode* node;
    CMTListNode* next;
    WORD i;

    // delete buckets
    for (i = 0; i < m_NumBuckets; i++)
    {
        pBucket = &m_Buckets[i];
        for (node = pBucket->m_Next; node != pBucket; node = next)
        {
            next = node->m_Next;
            gMTListNodePool->Free( node );
        }
    }
    if ( m_NumBuckets > (sizeof(m_PreAllocatedBuckets) / sizeof(CMTListNode)) )
        delete [] m_Buckets;
    m_Buckets = NULL;

    ExitMTListNodePool();
}


template<class T, class K> inline 
MTListNodeHandle ZONECALL CHash<T,K>::Add( K Key, T* Object )
{
    CMTListNode* node;
    WORD idx = (WORD) m_HashFunc( Key ) & m_BucketMask;
    CMTListNode* pBucket = &m_Buckets[ idx ];

    node = (CMTListNode*) gMTListNodePool->Alloc();
    if ( !node )
        return NULL;
    node->m_Data = Object;
    CLEAR_NODE_DELETED( node );
    SET_NODE_IDX( node, idx );
    node->m_Prev = pBucket;
    node->m_Next = pBucket->m_Next;
    pBucket->m_Next = node;
    node->m_Next->m_Prev = node;
    m_NumObjects++;
    return node;
}


template<class T, class K> inline 
T* ZONECALL CHash<T,K>::Get( K Key )
{
    T* Object;
    T* Found;
    CMTListNode* node;
        
    WORD idx = (WORD) m_HashFunc( Key ) & m_BucketMask;
    CMTListNode* pBucket = &m_Buckets[ idx ];

    // look for object in bucket list
    Found = NULL;
    for ( node = pBucket->m_Next; node != pBucket; node = node->m_Next )
    {
        ASSERT( GET_NODE_IDX(node) == idx );

        // skip deleted nodes
        if ( IS_NODE_DELETED( node ) )
            continue;

        // node we're looking for?
        Object = (T*)( node->m_Data );
        if ( m_CompareFunc( Object, Key ) )
        {
			if ( m_GetFunc )
			{
				m_GetFunc( Object );
			}
            Found = Object;
            break;
        }
    }
        
    return Found;
}


template<class T, class K> inline 
T* ZONECALL CHash<T,K>::Delete( K Key )
{
    T* Object;
    T* Found;
    CMTListNode* node;
    CMTListNode* next;

    WORD idx = (WORD)m_HashFunc( Key ) & m_BucketMask;
    CMTListNode* pBucket = &m_Buckets[ idx ];

    Found = NULL;
    for ( node = pBucket->m_Next; node != pBucket; node = next )
    {
        ASSERT( GET_NODE_IDX(node) == idx );
        next = node->m_Next;

        // remove deleted objects
        if ( IS_NODE_DELETED( node ) )
        {
            node->m_Prev->m_Next = next;
            next->m_Prev = node->m_Prev;
            node->m_Prev = NULL;
            node->m_Next = NULL;
            gMTListNodePool->Free( node );
            continue;
        }
        
        // node we're looking for?
        Object = (T*)( node->m_Data );
        if ( m_CompareFunc( Object, Key ) )
        {
            Found = Object;
            if ( m_Recursion == 0 )
            {
                node->m_Prev->m_Next = next;
                next->m_Prev = node->m_Prev;
                node->m_Prev = NULL;
                node->m_Next = NULL;
                gMTListNodePool->Free( node );
                m_NumObjects--;
            }
            else
            {
                MarkNodeDeleted( node );
            }
            break;
        }
    }

    return Found;
}


template<class T, class K> inline 
void ZONECALL CHash<T,K>::DeleteNode( MTListNodeHandle node, PFDELFUNC pfDelete, void* Cookie )
{
    ASSERT( GET_NODE_IDX(node) < m_NumBuckets );

    if ( pfDelete && node->m_Data )
    {
        pfDelete( (T*) node->m_Data, Cookie ); 
        node->m_Data = NULL;
    }

    node->m_Prev->m_Next = node->m_Next;
    node->m_Next->m_Prev = node->m_Prev;
    node->m_Prev = NULL;
    node->m_Next = NULL;
    gMTListNodePool->Free( node );
    m_NumObjects--;
}


template<class T, class K> inline 
void ZONECALL CHash<T,K>::MarkNodeDeleted( MTListNodeHandle node, PFDELFUNC pfDelete, void* Cookie )
{
    if ( !IS_NODE_DELETED( node ) )
    {
        MARK_NODE_DELETED( node );
        if ( pfDelete && node->m_Data )
        {
            pfDelete( (T*) node->m_Data, Cookie ); 
        }
        node->m_Data = NULL;
        m_NumObjects--;
    }
}


template<class T, class K> inline 
bool ZONECALL CHash<T,K>::ForEach( PFITERCALLBACK pfCallback, void* Cookie )
{
    CMTListNode* pBucket;
    CMTListNode* node;
    WORD idx;

    m_Recursion++;
    for (idx = 0; idx < m_NumBuckets; idx++)
    {
        // step through bucket
        pBucket = &m_Buckets[ idx ];
        for (node = pBucket->m_Next; node != pBucket; node = node->m_Next)
        {
            // skip deleted nodes
            if ( IS_NODE_DELETED( node ) )
                continue;

            if (!pfCallback( (T*) node->m_Data, node, Cookie ))
            {
                m_Recursion--;
                return false;
            }
        }
    }
    m_Recursion--;

    return true;
}


template<class T, class K> inline 
void ZONECALL CHash<T,K>::RemoveAll( PFDELFUNC pfDelete, void* Cookie )
{
    CMTListNode* pBucket;
    CMTListNode* node;
    CMTListNode* next;
    WORD idx;

    for (idx = 0; idx < m_NumBuckets; idx++)
    {
        pBucket = &m_Buckets[ idx ];
        for (node = pBucket->m_Next; node != pBucket; node = next )
        {
            if ( pfDelete && node->m_Data )
            {
                pfDelete( (T*) node->m_Data, Cookie ); 
                node->m_Data = NULL;
            }
            next = node->m_Next;
            node->m_Prev->m_Next = node->m_Next;
            node->m_Next->m_Prev = node->m_Prev;
            node->m_Prev = NULL;
            node->m_Next = NULL;
            gMTListNodePool->Free( node );
        }
    }
    m_NumObjects = 0;;
}


template<class T, class K> inline 
void ZONECALL CHash<T,K>::TrashDay()
{
    CMTListNode* pBucket;
    CMTListNode* node;
    CMTListNode* next;
    WORD idx;

    for (idx = 0; idx < m_NumBuckets; idx++)
    {
        // step through buckets deleting marked nodes
        pBucket = &m_Buckets[ idx ];
        for ( node = pBucket->m_Next; node != pBucket; node = next )
        {
            ASSERT( GET_NODE_IDX(node) == idx );
            next = node->m_Next;
            if ( IS_NODE_DELETED( node ) )
            {
                node->m_Prev->m_Next = next;
                next->m_Prev = node->m_Prev;
                node->m_Prev = NULL;
                node->m_Next = NULL;
                gMTListNodePool->Free( node );
            }
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
// Inline implementation of CMTHash
///////////////////////////////////////////////////////////////////////////////

template<class T, class K> inline
ZONECALL CMTHash<T,K>::CMTHash( PFHASHFUNC HashFunc, PFCOMPAREFUNC CompareFunc, PFGETFUNC GetFunc, WORD NumBuckets, WORD NumLocks )
{
    CMTListNode* pBucket;
    HashLock* pLock;
    WORD i;

    InitMTListNodePool();

	//
    // Set callback functions
    //
	m_HashFunc = HashFunc;
    m_CompareFunc = CompareFunc;
	m_GetFunc = GetFunc;
    ASSERT( HashFunc != NULL );
    ASSERT( CompareFunc != NULL );

    m_NumObjects = 0;
    m_Recursion = 0;

	//
    // It's a waste to have more locks then buckets so
    // adjust the number of locks if appropriate.
    //
    if (NumLocks > NumBuckets)
        NumLocks = NumBuckets;

	//
    // Force the number of buckets to a power of 2 so we can
    // replace MODULO with an AND.
    //
    for (i = 15; i >= 0; i--)
    {
        m_BucketMask = (1 << i);
        if (NumBuckets & m_BucketMask)
        {
            if (NumBuckets ^ m_BucketMask)
            {    
                i++;
                m_BucketMask = (1 << i);
            }
            break;
        }
    }
    ASSERT( i < 16);
    m_NumBuckets = m_BucketMask;
    m_BucketMask--;

    // Allocate and initialize buckets
    //
    m_Buckets = new CMTListNode[m_NumBuckets];
    ASSERT( m_Buckets != NULL );
    for ( i = 0; i < m_NumBuckets; i++ )
    {
        pBucket = &m_Buckets[i];
        pBucket->m_Next = pBucket;
        pBucket->m_Prev = pBucket;
        pBucket->m_Data = NULL;
        SET_NODE_IDX( pBucket, i );
        MARK_NODE_DELETED( pBucket ); // unusual but it simplifies the lookup routines
    }

	//
    // One lock per bucket would result in a lots of events and critical
    // sections.  Instead, we assign multiple buckets per lock such that
    // LockIdx = BucketIdx % NumLocks.  The same power of 2 optimization
    // is used to replace the MOD with an AND.
    //
    for (i = 15; i >= 0; i--)
    {
        m_LockMask = (1 << i);
        if (NumLocks & m_LockMask)
        {
            if (NumLocks ^ m_LockMask)
            {
                i++;
                m_LockMask = (1 << i);
            }
            break;
        }
    }
    ASSERT( i < 16);
    m_NumLocks = m_LockMask;
    m_LockMask--;
    
	//
    // Allocate and initialize locks
    //
    m_Locks = new HashLock [ m_NumLocks ];
    ASSERT( m_Locks != NULL );
    for ( i = 0; i < m_NumLocks; i++)
    {
        pLock = &m_Locks[i];
        pLock->m_NumReaders = 0;
        pLock->m_ReaderKick = CreateEvent( NULL, false, false, NULL );
        ASSERT( pLock->m_ReaderKick != NULL );
    }
}


template<class T, class K> inline 
ZONECALL CMTHash<T,K>::~CMTHash()
{
    ASSERT( !m_NumObjects );

    CMTListNode* pBucket;
    CMTListNode* node;
    CMTListNode* next;
    WORD i;

    // lock everything then delete
    for ( i = 0; i < m_NumLocks; i++ )
    {
        WriterLock( &m_Locks[i] );
        CloseHandle( m_Locks[i].m_ReaderKick );
    }
    delete [] m_Locks;

    // delete buckets
    for (i = 0; i < m_NumBuckets; i++)
    {
        pBucket = &m_Buckets[i];
        for (node = pBucket->m_Next; node != pBucket; node = next)
        {
            next = node->m_Next;
            gMTListNodePool->Free( node );
        }
    }
    delete [] m_Buckets;

    ExitMTListNodePool();
}


template<class T, class K> inline 
MTListNodeHandle ZONECALL CMTHash<T,K>::Add( K Key, T* Object )
{
    CMTListNode* node;
        
    WORD idx = (WORD)m_HashFunc( Key ) & m_BucketMask;
    CMTListNode* pBucket = &m_Buckets[ idx ];
    HashLock* pLock = &m_Locks[ idx & m_LockMask ];

    node = (CMTListNode*) gMTListNodePool->Alloc();
    if ( !node )
        return NULL;

    node->m_Data = Object;
    CLEAR_NODE_DELETED( node );
    SET_NODE_IDX( node, idx );
    node->m_Prev = pBucket;
    WriterLock( pLock );
        node->m_Next = pBucket->m_Next;
        pBucket->m_Next = node;
        node->m_Next->m_Prev = node;
    InterlockedIncrement(&m_NumObjects);
    WriterRelease( pLock );
    return node;
}


template<class T, class K> inline 
T* ZONECALL CMTHash<T,K>::Get( K Key )
{
    T* Object;
    T* Found;
    CMTListNode* node;
        
    WORD idx = (WORD)m_HashFunc( Key ) & m_BucketMask;
    CMTListNode* pBucket = &m_Buckets[ idx ];
    HashLock* pLock = &m_Locks[ idx & m_LockMask ];

    // increment reader count
    ReaderLock( pLock );
    
    // look for object in bucket list
    Found = NULL;
    for ( node = pBucket->m_Next; node != pBucket; node = node->m_Next )
    {
        ASSERT( GET_NODE_IDX(node) == idx );

        // skip deleted nodes
        if ( IS_NODE_DELETED( node ) )
            continue;

        Object = (T*)( node->m_Data );
        if ( m_CompareFunc( Object, Key ) )
        {
			if ( m_GetFunc )
			{
				m_GetFunc( Object );
			}
            Found = Object;
            break;
        }
    }
        
    // decrement reader count
    ReaderRelease( pLock );
    return Found;
}


template<class T, class K> inline 
T* ZONECALL CMTHash<T,K>::Delete( K Key )
{
    T* Object;
    T* Found;
    CMTListNode* node;
    CMTListNode* next;

    WORD idx = (WORD)m_HashFunc( Key ) & m_BucketMask;
    CMTListNode* pBucket = &m_Buckets[ idx ];
    HashLock* pLock = &m_Locks[ idx & m_LockMask ];

    // lock bucket for writing
    WriterLock( pLock );
        
        Found = NULL;
        for ( node = pBucket->m_Next; node != pBucket; node = next )
        {
            ASSERT( GET_NODE_IDX(node) == idx );
            next = node->m_Next;

            // remove deleted objects
            if ( IS_NODE_DELETED( node )  )
            {
                node->m_Prev->m_Next = next;
                next->m_Prev = node->m_Prev;
                node->m_Prev = NULL;
                node->m_Next = NULL;
                gMTListNodePool->Free( node );
                continue;
            }
            
            Object = (T*)( node->m_Data );
            if ( m_CompareFunc( Object, Key ) )
            {
                Found = Object;
                if ( m_Recursion == 0 )
                {
                    node->m_Prev->m_Next = next;
                    next->m_Prev = node->m_Prev;
                    node->m_Prev = NULL;
                    node->m_Next = NULL;
                    gMTListNodePool->Free( node );
                    InterlockedDecrement(&m_NumObjects);
                }
                else
                {
                    MarkNodeDeleted( node );
                }
                break;
            }
        }

    // unlock bucket
    WriterRelease( pLock );
    return Found;
}


template<class T, class K> inline 
void ZONECALL CMTHash<T,K>::DeleteNode( MTListNodeHandle node, PFDELFUNC pfDelete, void* Cookie )
{
    HashLock* pLock = &m_Locks[ GET_NODE_IDX(node) & m_LockMask ];

    ASSERT( GET_NODE_IDX(node) < m_NumBuckets );

    WriterLock( pLock );
        if ( pfDelete && node->m_Data )
        {
            pfDelete( (T*) node->m_Data, Cookie ); 
            node->m_Data = NULL;
        }
        node->m_Prev->m_Next = node->m_Next;
        node->m_Next->m_Prev = node->m_Prev;
        node->m_Prev = NULL;
        node->m_Next = NULL;
        gMTListNodePool->Free( node );
        InterlockedDecrement(&m_NumObjects);
    WriterRelease( pLock );
}


template<class T, class K> inline 
void ZONECALL CMTHash<T,K>::MarkNodeDeleted( MTListNodeHandle node )
{
    if ( !(InterlockedExchange( (long*) &node->m_DeletedAndIdx, node->m_DeletedAndIdx | DELETED_MASK ) & DELETED_MASK) )
        InterlockedDecrement(&m_NumObjects);
}


template<class T, class K> inline 
bool ZONECALL CMTHash<T,K>::ForEach( PFITERCALLBACK pfCallback, void* Cookie )
{
    CMTListNode* pBucket;
    CMTListNode* node;
    HashLock* pLock;

    WORD idx, LockIdx, OldLockIdx;

    // increment reader count for lock index 0
    pLock = &m_Locks[ 0 ];
    OldLockIdx = 0;
    ReaderLock( pLock );

    m_Recursion++;
    for (idx = 0; idx < m_NumBuckets; idx++)
    {
        // deal with locks
        LockIdx = idx & m_LockMask;
        if ( LockIdx != OldLockIdx )
        {
            // decrement reader count of previous lock
            ReaderRelease( pLock );
            
            // increment reader count for new lock        
            pLock = &m_Locks[ LockIdx ];
            ReaderLock( pLock );
            OldLockIdx = LockIdx;
        }

        // step through bucket
        pBucket = &m_Buckets[ idx ];
        for (node = pBucket->m_Next; node != pBucket; node = node->m_Next)
        {
            // skip deleted nodes
            if ( IS_NODE_DELETED( node ) )
                continue;

            if (!pfCallback( (T*) node->m_Data, node, Cookie ))
            {    
                // decrement reader count of current lock
                m_Recursion--;
                ReaderRelease( pLock );
                return false;
            }
        }
    }
    m_Recursion--;

    // decrement reader count of last lock
    ReaderRelease( pLock );

    return true;
}


template<class T, class K> inline 
void ZONECALL CMTHash<T,K>::RemoveAll( PFDELFUNC pfDelete, void* Cookie )
{
    CMTListNode* pBucket;
    CMTListNode* node;
    CMTListNode* next;
    HashLock* pLock;

    WORD idx, LockIdx, OldLockIdx;

    pLock = &m_Locks[ 0 ];
    OldLockIdx = 0;
    WriterLock( pLock );

    for (idx = 0; idx < m_NumBuckets; idx++)
    {
        LockIdx = idx & m_LockMask;
        if ( LockIdx != OldLockIdx )
        {
            WriterRelease( pLock );
            pLock = &m_Locks[ LockIdx ];
            WriterLock( pLock );
            OldLockIdx = LockIdx;
        }

        // step through bucket
        pBucket = &m_Buckets[ idx ];
        for (node = pBucket->m_Next; node != pBucket; node = next)
        {
            if ( pfDelete && node->m_Data && !IS_NODE_DELETED(node) )
            {
                pfDelete( (T*) node->m_Data, Cookie );                 
            }
            next = node->m_Next;
            node->m_Prev->m_Next = node->m_Next;
            node->m_Next->m_Prev = node->m_Prev;
            node->m_Prev = NULL;
            node->m_Next = NULL;
			node->m_Data = NULL;
            gMTListNodePool->Free( node );
        }
    }

    m_NumObjects = 0;

    WriterRelease( pLock );
}


template<class T, class K> inline 
void ZONECALL CMTHash<T,K>::TrashDay()
{
    CMTListNode* pBucket;
    CMTListNode* node;
    CMTListNode* next;
    HashLock* pLock;

    WORD idx, LockIdx, OldLockIdx;

    // lock buckets for writing
    pLock = &m_Locks[ 0 ];
    OldLockIdx = 0;
    WriterLock( pLock );

    for (idx = 0; idx < m_NumBuckets; idx++)
    {
        // deal with locks
        LockIdx = idx & m_LockMask;
        if ( LockIdx != OldLockIdx )
        {
            // unlock previous section
            WriterRelease( pLock );
                
            // lock new section
            pLock = &m_Locks[ LockIdx ];
            WriterLock( pLock );
            OldLockIdx = LockIdx;
        }

        // step through buckets deleting nodes
        pBucket = &m_Buckets[ idx ];
        for ( node = pBucket->m_Next; node != pBucket; node = next )
        {
            ASSERT( GET_NODE_IDX(node) == idx );
            next = node->m_Next;
            if ( IS_NODE_DELETED( node ) )
            {
                node->m_Prev->m_Next = next;
                next->m_Prev = node->m_Prev;
                node->m_Prev = NULL;
                node->m_Next = NULL;
                gMTListNodePool->Free( node );
            }
        }
    }

    // release last lock
    WriterRelease( pLock );
}

#endif //!__HASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\network.h ===
#ifndef _NETWORK_H_
#define _NETWORK_H_

#ifdef __cplusplus
#include "zonedebug.h"
#include "netcon.h"
#include "pool.h"
#include "queue.h"

#define ZNET_NO_PROMPT 0x1
#define ZNET_PROMPT_IF_NEEDED 0x2
#define ZNET_FORCE_PROMPT 0x4

// window messages
// WPARAM is 1 when dialog is shown
//           0 when dialog is closed
#define UM_ZNET_LOGIN_DIALOG   WM_USER+666

extern "C" {
#endif


HWND FindLoginDialog();

enum {
    /* Reasons for denying user access */

    zAccessGranted = 0,                   // success

    zAccessDeniedOldVersion = 1,          // bad protocol version
    zAccessDenied,                        // credential auth failed
    zAccessDeniedNoUser,
    zAccessDeniedBadPassword,
    zAccessDeniedUserLockedOut,
    zAccessDeniedSystemFull,              // out of resources ( i.e. memory )
    zAccessDeniedProtocolError,           // bad protocol signature
    zAccessDeniedBadSecurityPackage,      // SSPI initialization failed on client
    zAccessDeniedGenerateContextFailed,   // user canceled DPA dialog

    zAccessDeniedBlackListed = 1024
    
};

extern DWORD  g_EnableTickStats;
extern DWORD  g_LogServerDisconnects;
extern DWORD  g_PoolCleanupHighTrigger;
extern DWORD  g_PoolCleanupLowTrigger;

/*
    The following messages are sent to the ZSConnectionMessageProc
*/
#define zSConnectionClose    0
#define zSConnectionOpen     1
#define zSConnectionMessage  2
#define zSConnectionTimeout  3

#define zSConnectionNoTimeout       0xffffffff

typedef void* ZSConnection;

typedef struct _ZS_EVENT_APC
{
    HANDLE hEvent;
    void*  pData;
    DWORD  dwError;
} ZS_EVENT_APC;

typedef void (*ZSConnectionAPCFunc)(void* data);

/*
    ZSConnecitonEnumFunc, used to enumerate all connections currently open.
*/

typedef void (*ZSConnectionEnumFunc)(ZSConnection connection, void* data);

/*
    The ZSConnectionMessageFunc is passed into ZSConnectionCreateServer 
    or ZSConnectionOpen
*/
typedef void (*ZSConnectionMessageFunc)(ZSConnection connection, uint32 event,void* userData);

typedef BOOL (*ZSConnectionSendFilterFunc)(ZSConnection connection, void* userData, uint32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel);

/*
    ZSConnectionMsgWaitFunc is passed to ZNetwork::Wait() and is called back
    when the MsgWaitForMultipleObjects is triggered by an input msg event.
    This requires the CompletionPorts be disabled during Instance initialization.
*/
typedef void (*ZSConnectionMsgWaitFunc)(void* data);


typedef struct _ZNETWORK_OPTIONS
{
    DWORD  SocketBacklog;
    DWORD  EnableTcpKeepAlives;
    DWORD  WaitForCompletionTimeout;
    DWORD  RegWriteTimeout;
    DWORD  DisableEncryption;
    DWORD  MaxSendSize;
    DWORD  MaxRecvSize;
    DWORD  KeepAliveInterval;
    DWORD  PingInterval;
    DWORD  ProductSignature;
    DWORD  ClientEncryption;
} ZNETWORK_OPTIONS;

#ifdef __cplusplus
}

struct CONINFO_OVERLAPPED {
    OVERLAPPED o;
    DWORD flags;
};

struct CONAPC_OVERLAPPED : public CONINFO_OVERLAPPED
{
    ZSConnectionAPCFunc func;
    void* data;
};


struct COMPLETION
{
    ZNetCon*            con;
    CONINFO_OVERLAPPED* lpo;
};

class ConInfo;

class ZNetwork
{
  protected:
    static long          m_refCount;
    static BOOL volatile m_bInit;
    static HANDLE        m_hClientLoginMutex;

    BOOL   m_Exit; // = FALSE;

    HANDLE m_hIO; // = NULL;

    DWORD  m_SocketBacklog;        // set from registry
    DWORD  m_EnableTcpKeepAlives;  // set from registry
    DWORD  m_WaitForCompletionTimeout;    // set from registry
    DWORD  m_RegWriteTimeout;      // set from registry
    DWORD  m_DisableEncryption;
    DWORD  m_MaxSendSize;
    DWORD  m_MaxRecvSize;
    DWORD  m_KeepAliveInterval;
    DWORD  m_PingInterval;
    DWORD  m_ProductSignature;
    // specifies that we should use the key in the hello rather than
    // generating our own. This is used by the proxy to tell the lobby
    // server what key to use.
    DWORD  m_ClientEncryption;

    long   m_ConInfoUserCount;
    long   m_ConInfoCount;

    CMTList<ZNetCon> m_Connections;

    BOOL   m_bEnableCompletionPort;

    CRITICAL_SECTION   m_pcsGetQueueCompletion[1];

    HANDLE m_hWakeUpEvent;// = NULL;
    HANDLE m_hTerminateEvent;// = NULL;

    DWORD               m_nCompletionEvents;// = 0;
    HANDLE              m_hCompletionEvents[MAXIMUM_WAIT_OBJECTS];
    COMPLETION          m_CompletionQueue[MAXIMUM_WAIT_OBJECTS];
    CRITICAL_SECTION    m_pcsCompletionQueue[1];

    HWND    m_hwnd;

  public:

    ZNetwork();
   ~ZNetwork() {}

    DWORD m_LastTick;// = 0;
    CMTList<ZNetCon> m_TimeoutList;

    static ZError InitLibrary( BOOL bEnablePools = TRUE );
    static ZError InitLibraryClientOnly( BOOL bEnablePools = FALSE );
    static void   CleanUpLibrary();

    ZError InitInst(BOOL EnableIOCompletionPorts = TRUE); // completion ports can be disabled
                                                          // to use MsgWaitForMultipleObjects during Wait()
                                                          // however you will suffer a IO performance loss
    void   CleanUpInst();

    void SetOptions( ZNETWORK_OPTIONS* opt );
    void GetOptions( ZNETWORK_OPTIONS* opt );

    void EnterCS() { EnterCriticalSection( m_pcsGetQueueCompletion ); }
    void LeaveCS() { LeaveCriticalSection( m_pcsGetQueueCompletion ); }

    DWORD EnterLoginMutex() { return WaitForSingleObject( m_hClientLoginMutex, INFINITE ); }
    void  LeaveLoginMutex() { ReleaseMutex(m_hClientLoginMutex); }

    //
    // general connection maintence
    //
    // the following 2 functions close the socket and trigger the close callback
    // DeleteConnection should be used to free the connection object
    void CloseConnection(ZNetCon* connection);
    void DelayedCloseConnection(ZNetCon* connection, uint32 delay);
    void DeleteConnection(ZNetCon* connection);

    void AddRefConnection(ZNetCon* connection);
    void ReleaseConnection(ZNetCon* connection);

    //
    // server connections
    //
    ZNetCon* CreateServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* serverClass, void* userData, uint32 saddr = INADDR_ANY );
    ZNetCon* CreateSecureServer( uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* serverClass, char* serverName, char* serverType,
                                char* odbcRegistry, void* userData,char *SecPkg,uint32 Anonymous, uint32 saddr = INADDR_ANY );

    BOOL StartAccepting( ZNetCon* connection, DWORD dwMaxConnections, WORD wOutstandingAccepts = 1);

    BOOL StopAccepting( ZNetCon* connection ); // this closes the service side accept socket and will trigger the close callback.
                                               // the creator should then call DeleteServer

    //
    // client connections
    //
    ZNetCon* CreateClient(char* hostname, int32 *ports, ZSConnectionMessageFunc func, void* serverClass, void* userData);
    ZNetCon* CreateSecureClient(char* hostname, int32 *ports, ZSConnectionMessageFunc func,
                                    void* conClass, void* userData,
                                    char *User,char*Password,char*Domain, int Flags=ZNET_PROMPT_IF_NEEDED);




    ZError SendToClass(void* serverClass, int32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel = 0);
    ZError ClassEnumerate(void* serverClass, ZSConnectionEnumFunc func, void* data);


    //
    // Call this function to enter an infinite loop waiting for connections and data
    //
    // if CompletionPorts are disabled ( see InitInst() ), the wait function uses
    // MsgWaitForMultipleObjects with the dwWakeMask parameter.  The MsgWaitFunc is
    // called with the data parameter on a input msg event.
    void Wait( ZSConnectionMsgWaitFunc func = NULL, void* data = NULL, DWORD dwWakeMask = QS_ALLINPUT );

    void Exit();

    BOOL QueueAPCResult( ZSConnectionAPCFunc func, void* data );

    static char* AddressToStr(uint32 address);
    static uint32 AddressFromStr( char* pszAddr );


    void SetParentHWND( HWND hwnd ) { m_hwnd = hwnd; }
    HWND GetParentHWND() { return m_hwnd; }

  protected:
    friend ConInfo;

    BOOL IsCompletionPortEnabled() { return m_bEnableCompletionPort; }

    BOOL AddConnection(ZNetCon *connection);
    BOOL RemoveConnection(ZNetCon* con);
    void TerminateAllConnections(void);
    BOOL QueueCompletionEvent( HANDLE hEvent, ZNetCon* con, CONINFO_OVERLAPPED* lpo );

    SOCKET ConIOServer(uint32 saddr, uint16* pPort, uint16 range, int type);
    BOOL   ConIOSetServerSockOpt(SOCKET sock);

    SOCKET ConIOClient(int32 *ports,int type,char *host, DWORD* paddrLocal, DWORD* paddrRemote );
    BOOL   ConIOSetClientSockOpt(SOCKET sock);

    static ZError InitLibraryCommon();

};


#endif // cplusplus

#endif //def _NETWORK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\pool.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Pool.h
 *
 * Contents:	Fixed sized memory allocator
 *
 *****************************************************************************/

#ifndef _POOL_H_
#define _POOL_H_

#include <windows.h>
#include <wtypes.h>
#include <new.h>
#include "ZoneDebug.h"
#include "ZoneDef.h"
#include "ZoneMem.h"


///////////////////////////////////////////////////////////////////////////////
// Base pool class using void pointers.
///////////////////////////////////////////////////////////////////////////////

class CPoolVoid
{
    friend void  __cdecl ::operator delete( void * pInstance );

public:
    // Constructor and destructor
    //
    ZONECALL CPoolVoid( DWORD ObjectSize, DWORD IncrementCnt = 256, BOOL DebugMode = TRUE );
    ZONECALL ~CPoolVoid();

    // Initialize pool, must be called before using the pool
    //
    HRESULT ZONECALL Init();

    // Alloc object from pool
    //
    void* ZONECALL Alloc();

    // Return object to pool
    //
    void ZONECALL Free( void* pInstance );

    // Grow pool by IncrementCnt specified in constructor
    //
    BOOL ZONECALL Grow();

    // Free unused memory blocks (not currently implemented)
    //
    void ZONECALL Shrink();
    
private:
    // helper functions
    //
    BOOL ZONECALL _GrowAlreadyLocked();
    void ZONECALL _FreeWithHeader( void* pInstance );

#pragma pack( push, 4 )

    // helper structures
    struct Block
    {
        Block*    m_pNext;
    };

    struct Link
    {
        Link*    m_pNext;
    };

#pragma pack( pop )

    DWORD	m_BytesPerBlock;		// block size
    DWORD	m_ObjectsPerBlock;		// user objects per block
    DWORD	m_ObjectSize;			// object + overhead size
    DWORD	m_ObjectsAllocated;		// number of objects allocated to user
    DWORD	m_TrailerOffset;		// debug wrapper offset per object;
    BOOL	m_DebugMode;			// perform validatation checks

    Block*	m_BlockList;
    Link*	m_FreeList;
    Link*	m_ExtraFreeLink;
    CRITICAL_SECTION m_Lock;
};


///////////////////////////////////////////////////////////////////////////////
// Wrapper for CPoolVoid that provides operator new and typechecking
///////////////////////////////////////////////////////////////////////////////

template<class T> class CPool
{
public:
    ZONECALL CPool( DWORD IncrementCnt = 256, BOOL DebugMode = FALSE)
		: m_Pool( sizeof(T) + sizeof(GenericPoolBlobHeader), IncrementCnt, DebugMode )
    {
    }
    
    HRESULT ZONECALL Init()
    {
        return m_Pool.Init();
    }

    T* ZONECALL Alloc()
    {
        GenericPoolBlobHeader* pBlob = (GenericPoolBlobHeader*) m_Pool.Alloc();
        if (!pBlob)
            return NULL;

        pBlob->m_Tag = POOL_POOL_BLOB;
        pBlob->m_Val = (long) &m_Pool;
        return (T*) (pBlob + 1);
    }

    void ZONECALL Free( T* pInstance)
    {
        GenericPoolBlobHeader* pBlob = ((GenericPoolBlobHeader*) pInstance) - 1;
        
        ASSERT( pBlob->m_Tag == POOL_POOL_BLOB );
        ASSERT( pBlob->m_Val == (long) &m_Pool );

        m_Pool.Free( (void *) pBlob );
    }

    BOOL ZONECALL Grow()
    {
        return m_Pool.Grow();
    }

    void ZONECALL Shrink()
    {
        m_Pool.Shrink();
    }

private:
    CPoolVoid m_Pool;

private:
	CPool( CPool& ) {}
};


///////////////////////////////////////////////////////////////////////////////
// Templated new for the pools.
///////////////////////////////////////////////////////////////////////////////

template<class T> void* __cdecl operator new( size_t sz, CPool<T>& pool )
{
    void *p;

    // Can't allocate arrays from the pool
    ASSERT( sz == sizeof(T) );

    for(;;)
    {
        if (p = pool.Alloc())
            return p;
		return NULL;
    }
}


///////////////////////////////////////////////////////////////////////////////
// Variable sized buffers
///////////////////////////////////////////////////////////////////////////////

#define POOL_STATS  0

class CDataPool
{
public:

	// Set Largest to 0 to cause dynamic reallocations to always occur
	ZONECALL CDataPool( size_t largest, size_t smallest = 32, BOOL bDebug = FALSE  );
	ZONECALL ~CDataPool();

	char* ZONECALL Alloc(size_t sz);
	char* ZONECALL Realloc(char* pBuf, size_t szOld, size_t szNew);
	void ZONECALL Free( char* pInst, size_t sz);
	void ZONECALL Grow();
	void ZONECALL Shrink();
	void ZONECALL PrintStats();

protected:
	CPoolVoid**	m_pools;
	BYTE	m_numPools;
	BYTE	m_smallest2;
	BYTE	m_largest2;

#if POOL_STATS
    DWORD	m_allocs;
    DWORD	m_frees;
    DWORD	m_stats[65];
#endif

private:
	CDataPool()	{}
	CDataPool( CDataPool& ) {}
};


#endif //_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\queue.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		Queue.h
 *
 * Contents:	Linked list containers
 *
 *****************************************************************************/

#ifndef __QUEUE_H__
#define __QUEUE_H__

#include <ZoneDebug.h>
#include <ZoneDef.h>
#include <Containers.h>
#include <Pool.h>


// #define QUEUE_DBG
#ifdef QUEUE_DBG
#define QUEUE_ASSERT(x) ASSERT(x)
#else
#define QUEUE_ASSERT(x)
#endif


///////////////////////////////////////////////////////////////////////////////
// Doublely linked list (NOT thread safe)
///////////////////////////////////////////////////////////////////////////////

template <class T> class CList
{
public:
    //
    // Constructor and destructor
    //
    ZONECALL CList();
    ZONECALL ~CList();

    //
    // Returns true if list is empty, otherwise false
    //
    bool ZONECALL IsEmpty();

    //
    // Note: Count is not preserve if AddListXXX is used
    //
    long ZONECALL Count() { return m_NumObjects; }

    //
    // Adds element to front of list and returns node handle (see DeleteNode).
    //
    ListNodeHandle ZONECALL AddHead( T* pObject );

    //
    // Adds element to end of list and returns node handle (see DeleteNode).
    //
    ListNodeHandle ZONECALL AddTail( T* pObject );
    
    //
    // Removes specified node from list.  ListNodeHandle points to the next
    // item in the list when the call returns.
    //
    void ZONECALL DeleteNode( ListNodeHandle& node );
    
    // 
    // Removes a node using the object pointer rather than a node ref.
	// Returns true if successful (found object) or false otherwise
    //
    bool ZONECALL Remove(T* pObject );

    //
    // Returns element from front of list without removing it.
    //
    T* ZONECALL PeekHead();
    
    //
    // Returns element from end of list without removing it.
    //
    T* ZONECALL PeekTail();
    
    //
    // Removes and returns element from front of list.
    //
    T* ZONECALL PopHead();

    //
    // Removes and returns element from end of list.
    //
    T* ZONECALL PopTail();

	//
    // Add element before the specified node handle (see DeleteNode).
    //
    ListNodeHandle ZONECALL InsertBefore( T* pObject, ListNodeHandle node );

    //
    // Add element after the specified node handle (see DeleteNode).
    //
    ListNodeHandle ZONECALL InsertAfter( T* pObject, ListNodeHandle node );


    //
    // Detaches list and returns it as circularly linked list
    // without a sentinal. (see AddListToHead and AddListToTail)
    // 
    CListNode* ZONECALL SnagList();
        
    //
    // Adds circularly linked list (see SnagList) to head of current list
    //
    void ZONECALL AddListToHead( CListNode* node );
    
    //
    // Adds circularly linked list (see SnagList) to tail of current list
    //
    void ZONECALL AddListToTail( CListNode* node );

    //
    // Callback iterator.  Returns false if the iterator was prematurely ended
	// by the callback, otherwise true.
    //
    //  Callback:
    //        Form:
    //            bool ZONECALL callback_function( T* pObject, ListNodeHandle hNode, void* pContext )
    //        Behavior:
    //            If the callback returns false, the iterator immediately stops.
    //            If the callback returns true, the iterator continues on to the next node.
    //        Restrictions:
    //            (1) Do not use any of the pop routines inside the callback
    //            (2) Do not use ForEach inside the callback
    //            (3) Do not delete any node other than the one passed into the callback
    //            (4) Objects added to the list inside the callback may or may not show
    //                up during that ForEach run.
    //
    bool ZONECALL ForEach( bool (ZONECALL *pfCallback)(T*, ListNodeHandle, void*), void* pContext );

    //
    // The inline iterators (GetHeadPosition, GetTailPosition, GetNextPosition,
    // GetPrevPosition) have the same restrictions as the callback iterator
    //

    //
    // Returns ListNodeHandle of the first object
    //
    ListNodeHandle ZONECALL GetHeadPosition();

    //
    // Returns ListNodeHandle of the last object
    //
    ListNodeHandle ZONECALL GetTailPosition();

    //
    // Advances ListNodeHandle to next object
    //
    ListNodeHandle ZONECALL GetNextPosition( ListNodeHandle handle );

    //
    // Advances ListNodeHandle to previous object
    //
    ListNodeHandle ZONECALL GetPrevPosition( ListNodeHandle handle );

    //
    // Returns object associated with handle
    //
    T* ZONECALL GetObjectFromHandle( ListNodeHandle handle );

    //
    // dummy call - there to be similar to CMTList
    //
    void EndIterator() {}


protected:
    CListNode        m_Sentinal;
    CListNode        m_IteratorNode;
    long             m_NumObjects;
};


//////////////////////////////////////////////////////////////////////////////////////
// Doublely linked list (thread-safe)
//////////////////////////////////////////////////////////////////////////////////////

template <class T> class CMTList
{
public:
    //
    // Constructor and destructor
    //
    ZONECALL CMTList();
    ZONECALL ~CMTList();
    
    //
    // Returns true if list is empty, otherwise false
    //
    bool ZONECALL IsEmpty();

    //
    // Note: Count is not preserve if AddListXXX is used
    //
    long ZONECALL Count() { return m_NumObjects; }

    //
    // Add element to front of list and returns node handle (see DeleteNode).
    //
    MTListNodeHandle ZONECALL AddHead( T* pObject );

    //
    // Add element to end of list and returns node handle (see DeleteNode).
    //
    MTListNodeHandle ZONECALL AddTail( T* pObject );

    //
    // Add element before the specified node handle (see DeleteNode).
    //
    MTListNodeHandle ZONECALL InsertBefore( T* pObject, MTListNodeHandle node );

    //
    // Add element after the specified node handle (see DeleteNode).
    //
    MTListNodeHandle ZONECALL InsertAfter( T* pObject, MTListNodeHandle node );

    //
    // Marks node as deleted without locking the list.  It can be
    // called from within the iterator callback (see ForEach).
    //
    void ZONECALL MarkNodeDeleted( MTListNodeHandle node );
    
    //
    // Removes node from list
    //
    void ZONECALL DeleteNode( MTListNodeHandle node );

    // 
    // Removes a node using the object pointer rather than a node ref.
	// Returns true if successful (found object), otherwise false.
    //
    bool ZONECALL Remove(T* pObject );
    
    //
    // Returns element from front of list without removing it.
    //
    T* ZONECALL PeekHead();
    
    //
    // Returns element from end of list without removing it.
    //
    T* ZONECALL PeekTail();

    //
    // Removes and returns element from front of list.
    //
    T* ZONECALL PopHead();

    //
    // Removes and returns element from end of list.
    //
    T* ZONECALL PopTail();

    //
    // Detaches list and returns it as circularly linked list
    // without a sentinal. (see AddListToHead and AddListToTail)
    // 
    CMTListNode* ZONECALL SnagList();

    //
    // Adds circularly linked list (see SnagList) to head of current list
    //
    void ZONECALL AddListToHead( CMTListNode* list);


    //
    // Adds circularly linked list (see SnagList) to tail of current list
    //
    void ZONECALL AddListToTail( CMTListNode* list );

    //
    // Callback iterator.  Returns false if the iterator was prematurely
    // ended by the callback function, otherwise true.
    //
    //  Callback:
    //        Form:
    //            callback_function( T* pObject, MTListNodeHandle hNode, void* pContext )
    //        Behavior:
    //            If the callback returns false, the iterator immediately stops.
    //            If the callback returns TURE, the iterator continues on to the next node.
    //        Restrictions:
    //            (1) Using any MTList function other than MarkNodeDeleted will result in a deadlock.
    //
    bool ZONECALL ForEach( bool (ZONECALL *pfCallback)(T*, MTListNodeHandle, void*), void* pContext );

    //
    // The following inline iterators (GetHeadPosition, GetTailPosition, GetNextPosition,
    // GetPrevPosition) have the same restrictions as the callback iterator
    //

    //
    // Returns ListNodeHandle of the first object.  Must call EndIterator when
    // finished since GetHeadPosition does not unlock the list.
    //
    MTListNodeHandle ZONECALL GetHeadPosition();

    //
    // Returns ListNodeHandle of the last object.  Must call EndIterator when
    // finished since GetHeadPosition does not unlock the list.
    //
    MTListNodeHandle ZONECALL GetTailPosition();

    //
    // Advances ListNodeHandle to next object
    //
    MTListNodeHandle ZONECALL GetNextPosition( MTListNodeHandle handle );

    //
    // Advances ListNodeHandle to previous object
    //
    MTListNodeHandle ZONECALL GetPrevPosition( MTListNodeHandle handle );

    //
    // Returns object associated with handle
    //
    T* ZONECALL GetObjectFromHandle( MTListNodeHandle handle );

    //
    // Unlocks list from previous GetHeadPosition or GetTailPosition call.
    //
    void ZONECALL EndIterator();

    //
    // Removes nodes marked as deleted
    //
    void ZONECALL TrashDay();

protected:
    long				m_Recursion;
    CRITICAL_SECTION	m_Lock;
    CMTListNode			m_Sentinal;
    long				m_NumObjects;

    //
    // Internal helper functions: 
    //
    bool ZONECALL RemoveDeletedNodesFromFront();
    bool ZONECALL RemoveDeletedNodesFromBack();

#ifdef QUEUE_DBG
    CMTListNode* ZONECALL FindDuplicateNode( CMTListNode* object );
#endif
};


///////////////////////////////////////////////////////////////////////////////
// Inline implementation of CList
///////////////////////////////////////////////////////////////////////////////

template <class T> inline 
ZONECALL CList<T>::CList()
{
    InitListNodePool();
    m_Sentinal.m_Next = &m_Sentinal;
    m_Sentinal.m_Prev = &m_Sentinal;
    m_Sentinal.m_Data = NULL;
    m_IteratorNode.m_Next = &m_Sentinal;
    m_IteratorNode.m_Prev = &m_Sentinal;
    m_IteratorNode.m_Data = NULL;
    m_NumObjects = 0;
}

template <class T> inline 
ZONECALL CList<T>::~CList()
{
    CListNode* next;
    CListNode* node;
    
    ASSERT( IsEmpty() );
        
    for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
    {
        next = node->m_Next;
        gListNodePool->Free( node );
    }

    ExitListNodePool();
}

template<class T> inline 
bool ZONECALL CList<T>::IsEmpty()
{
    return (m_Sentinal.m_Next == &m_Sentinal);
}

template<class T> inline 
ListNodeHandle ZONECALL CList<T>::AddHead( T* pObject )
{
    CListNode* node;
        
    node = (CListNode*) gListNodePool->Alloc();
    if ( !node )
        return NULL;

    node->m_Data = pObject;
    node->m_Prev = &m_Sentinal;
    node->m_Next = m_Sentinal.m_Next;
    m_Sentinal.m_Next = node;
    node->m_Next->m_Prev = node;
    m_NumObjects++;
    return node;
}

template<class T> inline 
ListNodeHandle ZONECALL CList<T>::AddTail( T* pObject )
{
    CListNode* node;
    
    node = (CListNode*) gListNodePool->Alloc();
    if ( !node )
        return NULL;

    node->m_Data = pObject;
    node->m_Next = &m_Sentinal;
    node->m_Prev = m_Sentinal.m_Prev;
    m_Sentinal.m_Prev = node;
    node->m_Prev->m_Next = node;
    m_NumObjects++;
    return node;
}

template<class T> inline 
void ZONECALL CList<T>::DeleteNode( ListNodeHandle& node )
{
    ASSERT( node != NULL );
    ASSERT( node != &m_Sentinal );
    ASSERT( node != &m_IteratorNode );
    
    node->m_Prev->m_Next = node->m_Next;
    node->m_Next->m_Prev = node->m_Prev;
    m_IteratorNode.m_Next = node->m_Next;
    m_IteratorNode.m_Prev = node->m_Prev;
    node->m_Prev = NULL;
    node->m_Next = NULL;
    gListNodePool->Free( node );
    node = &m_IteratorNode;
    m_NumObjects--;
}

template<class T> inline 
T* ZONECALL CList<T>::PeekHead()
{
    return (T*) m_Sentinal.m_Next->m_Data;
}

template<class T> inline 
T* ZONECALL CList<T>::PeekTail()
{
    return (T*) m_Sentinal.m_Prev->m_Data;
}

template<class T> inline 
T* ZONECALL CList<T>::PopHead()
{
    T* data;
    CListNode* node;

    node = m_Sentinal.m_Next;
    if ( node == &m_Sentinal )
    {
        ASSERT( m_Sentinal.m_Prev == &m_Sentinal );
        return NULL;
    }
    m_Sentinal.m_Next = node->m_Next;
    node->m_Next->m_Prev = &m_Sentinal;
    data = (T*) node->m_Data;
    node->m_Prev = NULL;
    node->m_Next = NULL;
    gListNodePool->Free( node );
    m_NumObjects--;
    return data;
}

template<class T> inline 
T* ZONECALL CList<T>::PopTail()
{
    T* data;
    CListNode* node;
    
    node = m_Sentinal.m_Prev;
    if (node == &m_Sentinal)
    {
        ASSERT( m_Sentinal.m_Next == &m_Sentinal );
        return NULL;
    }
    m_Sentinal.m_Prev = node->m_Prev;
    node->m_Prev->m_Next = &m_Sentinal;
    data = (T*) node->m_Data;
    node->m_Prev = NULL;
    node->m_Next = NULL;
    gListNodePool->Free( node );
    m_NumObjects--;
    return data;
}

template<class T> inline
ListNodeHandle ZONECALL CList<T>::InsertBefore( T* pObject, ListNodeHandle nodeHandle )
{
    CListNode* node;
    CListNode* next = nodeHandle;
        
    node = (CListNode*) gListNodePool->Alloc();
    if ( !node )
        return NULL;

    node->m_Data = pObject;
    node->m_Next = next;
    node->m_Prev = next->m_Prev;
	node->m_Prev->m_Next = node;
	next->m_Prev = node;
    m_NumObjects++;
    return node;
}

template<class T> inline
ListNodeHandle ZONECALL CList<T>::InsertAfter( T* pObject, ListNodeHandle nodeHandle )
{
    CListNode* node;
    CListNode* next = nodeHandle;
        
    node = (CListNode*) gListNodePool->Alloc();
    if ( !node )
        return NULL;

    node->m_Data = pObject;
	node->m_Next = next->m_Next;
	node->m_Prev = next;
	node->m_Next->m_Prev = node;
	next->m_Next = node;
    m_NumObjects++;
    return node;
}

template<class T> inline 
CListNode* ZONECALL CList<T>::SnagList()
{
    CListNode* node;
        
    node = m_Sentinal.m_Next;
    if (node == &m_Sentinal)
    {
        ASSERT( node->m_Prev == &m_Sentinal );
        return NULL;
    }        
    node->m_Prev = m_Sentinal.m_Prev;
    node->m_Prev->m_Next = node;
    m_Sentinal.m_Next = &m_Sentinal;
    m_Sentinal.m_Prev = &m_Sentinal;
    return node;
}

template<class T> inline 
void ZONECALL CList<T>::AddListToHead( CListNode* node )
{
    if ( !node )
        return;
    node->m_Prev->m_Next = m_Sentinal.m_Next;
    m_Sentinal.m_Next->m_Prev = node->m_Prev;
    m_Sentinal.m_Next = node;
    node->m_Prev = &m_Sentinal;
}

template<class T> inline 
void ZONECALL CList<T>::AddListToTail( CListNode* node )
{
    CListNode* end;
    
    if ( !node )
        return;
    end = node->m_Prev;
    m_Sentinal.m_Prev->m_Next = node;
    node->m_Prev = m_Sentinal.m_Prev;
    m_Sentinal.m_Prev = end;
    end->m_Next = &m_Sentinal;
}

template<class T> inline 
bool ZONECALL CList<T>::ForEach( bool (ZONECALL *pfCallback)(T*, ListNodeHandle, void*), void* pContext )
{
    CListNode* node;
    CListNode* next;

    ASSERT( pfCallback != NULL );

    for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
    {
        next = node->m_Next;
        if ( !pfCallback( (T*) node->m_Data, node, pContext ) )
            return false;
    }
    return true;
}

template<class T> inline
bool ZONECALL CList<T>::Remove( T* pObject )
{
    ASSERT( pObject != NULL );

    CListNode* node;
    CListNode* next;

    for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
    {
        next = node->m_Next;
        if(node->m_Data == pObject)
		{
            DeleteNode(node);
            return true;
        }

    }
    return false;
}

template<class T> inline
ListNodeHandle ZONECALL CList<T>::GetHeadPosition()
{
    m_IteratorNode.m_Next = NULL;
    m_IteratorNode.m_Prev = NULL;
    if (IsEmpty())
        return NULL;
    else
        return m_Sentinal.m_Next;
}

template<class T> inline
ListNodeHandle ZONECALL CList<T>::GetTailPosition()
{
    m_IteratorNode.m_Next = NULL;
    m_IteratorNode.m_Prev = NULL;
    if (IsEmpty())
        return NULL;
    else
        return m_Sentinal.m_Prev;
}

template<class T> inline
ListNodeHandle ZONECALL CList<T>::GetNextPosition( ListNodeHandle handle )
{
    if ( !handle || (handle->m_Next == &m_Sentinal) )
        return NULL;
    else
        return handle->m_Next;
}

template<class T> inline
ListNodeHandle ZONECALL CList<T>::GetPrevPosition( ListNodeHandle handle )
{
    if ( !handle || (handle->m_Prev == &m_Sentinal) )
        return NULL;
    else
        return handle->m_Prev;
}

template<class T> inline
T* ZONECALL CList<T>::GetObjectFromHandle( ListNodeHandle handle )
{
    if (handle == NULL)
        return NULL;
    else
        return (T*) handle->m_Data;
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of CMTList
///////////////////////////////////////////////////////////////////////////////

template <class T>
bool ZONECALL CMTList<T>::RemoveDeletedNodesFromFront()
{
    CMTListNode *node;
    CMTListNode *next;

    for (node = m_Sentinal.m_Next; IS_NODE_DELETED(node); node = next)
    {
        if ( node == &m_Sentinal )
        {
            m_Sentinal.m_Next = &m_Sentinal;
            m_Sentinal.m_Prev = &m_Sentinal;
            return false;
        }

        next = node->m_Next;
        node->m_Prev->m_Next = node->m_Next;
        node->m_Next->m_Prev = node->m_Prev;
        //node->m_Prev = NULL;
        node->m_Next = NULL;
        MARK_NODE_DELETED(node);
        node->m_Data = NULL;
        gMTListNodePool->Free( node );
    }
    return true;
}

template <class T>
bool ZONECALL CMTList<T>::RemoveDeletedNodesFromBack()
{
    CMTListNode *node;
    CMTListNode *next;

    for (node = m_Sentinal.m_Prev; IS_NODE_DELETED(node); node = next)
    {
        if ( node == &m_Sentinal )
        {
            m_Sentinal.m_Next = &m_Sentinal;
            m_Sentinal.m_Prev = &m_Sentinal;
            return false;
        }
        next = node->m_Prev;
        node->m_Prev->m_Next = node->m_Next;
        node->m_Next->m_Prev = node->m_Prev;
        //node->m_Prev = NULL;
        node->m_Next = NULL;
        MARK_NODE_DELETED(node);
        node->m_Data = NULL;
        gMTListNodePool->Free( node );
    }
    return true;
}

template <class T> inline 
ZONECALL CMTList<T>::CMTList()
{
    InitMTListNodePool();
	InitializeCriticalSection( &m_Lock );
    m_Sentinal.m_Next = &m_Sentinal;
    m_Sentinal.m_Prev = &m_Sentinal;
    m_Sentinal.m_Data = NULL;
    MARK_NODE_DELETED((&m_Sentinal));  // unusual but simplifies the pop routines
    m_Recursion = 0;
    m_NumObjects = 0;
}

template <class T> inline 
ZONECALL CMTList<T>::~CMTList()
{
    CMTListNode* next;
    CMTListNode* node;

    ASSERT( IsEmpty() );

    EnterCriticalSection( &m_Lock );
    for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
    {
        next = node->m_Next;
        gMTListNodePool->Free( node );
    }
    DeleteCriticalSection( &m_Lock );
    ExitMTListNodePool();
}

template <class T> inline 
bool ZONECALL CMTList<T>::IsEmpty()
{
    bool empty = false;

    EnterCriticalSection( &m_Lock );
        empty = !RemoveDeletedNodesFromFront();
    LeaveCriticalSection( &m_Lock );
    return empty;
}

template <class T> inline 
MTListNodeHandle ZONECALL CMTList<T>::AddHead( T* pObject )
{
    CMTListNode* node;
#ifdef QUEUE_DBG
    CMTListNode* existing;
#endif
    
    node = (CMTListNode*) gMTListNodePool->Alloc();
    if ( !node )
        return NULL;
 
    QUEUE_ASSERT( !(existing = FindDuplicateNode( node ) ) );

    CLEAR_NODE_DELETED(node);
    node->m_Data = pObject;
    node->m_Prev = &m_Sentinal;
    EnterCriticalSection( &m_Lock );
        node->m_Next = m_Sentinal.m_Next;
        m_Sentinal.m_Next = node;
        node->m_Next->m_Prev = node;

        ASSERT(node->m_Prev);
        ASSERT(node->m_Next);
    LeaveCriticalSection( &m_Lock );
    InterlockedIncrement( &m_NumObjects );
    return node;
}

template <class T> inline 
MTListNodeHandle ZONECALL CMTList<T>::AddTail( T* pObject )
{
    CMTListNode* node;
#ifdef QUEUE_DBG
    CMTListNode* existing;
#endif

    node = (CMTListNode*) gMTListNodePool->Alloc();
    if ( !node )
        return NULL;

    QUEUE_ASSERT( !(existing = FindDuplicateNode( node ) ) );

    CLEAR_NODE_DELETED(node);
    node->m_Data = pObject;
    node->m_Next = &m_Sentinal;
    EnterCriticalSection( &m_Lock );
        node->m_Prev = m_Sentinal.m_Prev;
        m_Sentinal.m_Prev = node;
        node->m_Prev->m_Next = node;

        ASSERT(node->m_Prev);
        ASSERT(node->m_Next);
    LeaveCriticalSection( &m_Lock );
    InterlockedIncrement( &m_NumObjects );
    return node;
}

template <class T> inline
MTListNodeHandle ZONECALL CMTList<T>::InsertBefore( T* pObject, MTListNodeHandle nodeHandle  )
{
    CMTListNode* node;
    CMTListNode* next = nodeHandle;
        
    node = (CMTListNode*) gMTListNodePool->Alloc();
    if ( !node )
        return NULL;

    QUEUE_ASSERT( !(next = FindDuplicateNode( node ) ) );

    CLEAR_NODE_DELETED(node);
    node->m_Data = pObject;
    EnterCriticalSection( &m_Lock );
        node->m_Next = next;
        node->m_Prev = next->m_Prev;
        next->m_Prev = node;
        node->m_Prev->m_Next = node;

        ASSERT(node->m_Prev);
        ASSERT(node->m_Next);
    LeaveCriticalSection( &m_Lock );
    InterlockedIncrement( &m_NumObjects );
    return node;
}

template <class T> inline
MTListNodeHandle ZONECALL CMTList<T>::InsertAfter( T* pObject, MTListNodeHandle nodeHandle  )
{
    CMTListNode* node;
    CMTListNode* prev = nodeHandle;
        
    node = (CMTListNode*) gMTListNodePool->Alloc();
    if ( !node )
        return NULL;

    QUEUE_ASSERT( !(prev = FindDuplicateNode( node ) ) );

    CLEAR_NODE_DELETED(node);
    node->m_Data = pObject;
    EnterCriticalSection( &m_Lock );
        node->m_Prev = prev;
        node->m_Next = prev->m_Next;
        prev->m_Next = node;
        node->m_Next->m_Prev = node;

        ASSERT(node->m_Prev);
        ASSERT(node->m_Next);
    LeaveCriticalSection( &m_Lock );
    InterlockedIncrement( &m_NumObjects );
    return node;
}



template <class T> inline 
void ZONECALL CMTList<T>::MarkNodeDeleted( MTListNodeHandle node )
{
    ASSERT( node != NULL );
    ASSERT( node->m_Next != NULL );
    ASSERT( node->m_Prev != NULL );

    InterlockedExchange( (long*) &node->m_DeletedAndIdx, node->m_DeletedAndIdx | DELETED_MASK );
    InterlockedDecrement( &m_NumObjects );
}

template <class T> inline 
void ZONECALL CMTList<T>::DeleteNode( MTListNodeHandle node )
{
    ASSERT( node != NULL );

    // node already deleted?
    if ( !node || IS_NODE_DELETED(node) )
        return;

    if ( m_Recursion == 0 )
    {
        EnterCriticalSection( &m_Lock );
            ASSERT(node->m_Prev);
            ASSERT(node->m_Next);
            node->m_Prev->m_Next = node->m_Next;
            node->m_Next->m_Prev = node->m_Prev;
        LeaveCriticalSection( &m_Lock );

        //node->m_Prev = NULL;
        node->m_Next = NULL;
        MARK_NODE_DELETED(node);
        node->m_Data = NULL;

        gMTListNodePool->Free( node );
        InterlockedDecrement( &m_NumObjects );

    }
    else
    {
        MarkNodeDeleted(node);
    }
}

template<class T> inline 
T* ZONECALL CMTList<T>::PeekHead()
{
    T* data;

    EnterCriticalSection( &m_Lock );
        RemoveDeletedNodesFromFront();
        data = (T*) m_Sentinal.m_Next->m_Data;
    LeaveCriticalSection( &m_Lock );
    return data;
}

template <class T> inline 
T* ZONECALL CMTList<T>::PeekTail()
{
    T* data;

    EnterCriticalSection( &m_Lock );
        RemoveDeletedNodesFromBack();
        data = (T*) m_Sentinal.m_Prev->m_Data;
    LeaveCriticalSection( &m_Lock );
    return data;
}

template<class T> inline 
T* ZONECALL CMTList<T>::PopHead()
{
    T* data;
    CMTListNode* node;

    EnterCriticalSection( &m_Lock );
        if ( !RemoveDeletedNodesFromFront() )
        {
            LeaveCriticalSection( &m_Lock );
            return NULL;
        }
        node = m_Sentinal.m_Next;
        m_Sentinal.m_Next = node->m_Next;
        node->m_Next->m_Prev = &m_Sentinal;
    LeaveCriticalSection( &m_Lock );
    data = (T*) node->m_Data;

    //node->m_Prev = NULL;
    node->m_Next = NULL;
    MARK_NODE_DELETED(node);
    node->m_Data = NULL;

    gMTListNodePool->Free( node );
    InterlockedDecrement( &m_NumObjects );
    return data;
}

template<class T> inline 
T* ZONECALL CMTList<T>::PopTail()
{    
    T* data;
    CMTListNode* node;

    EnterCriticalSection( &m_Lock );
        if ( !RemoveDeletedNodesFromBack() )
        {
            LeaveCriticalSection( &m_Lock );
            return NULL;
        }
        node = m_Sentinal.m_Prev;
        m_Sentinal.m_Prev = node->m_Prev;
        node->m_Prev->m_Next = &m_Sentinal;
    LeaveCriticalSection( &m_Lock );
    data = (T*) node->m_Data;

    //node->m_Prev = NULL;
    node->m_Next = NULL;
    MARK_NODE_DELETED(node);
    node->m_Data = NULL;

    gMTListNodePool->Free( node );
    InterlockedDecrement( &m_NumObjects );
    return data;
}

template<class T>
CMTListNode* ZONECALL CMTList<T>::SnagList()
{
    CMTListNode* list;
    CMTListNode* node;
    CMTListNode* next;
    CMTListNode* start;

    EnterCriticalSection( &m_Lock );
        list = m_Sentinal.m_Next;
        if (list == &m_Sentinal)
        {
            ASSERT( list->m_Prev == &m_Sentinal );
            LeaveCriticalSection( &m_Lock );
            return NULL;
        }
        list->m_Prev = m_Sentinal.m_Prev;
        list->m_Prev->m_Next = list;
        m_Sentinal.m_Next = &m_Sentinal;
        m_Sentinal.m_Prev = &m_Sentinal;
    LeaveCriticalSection( &m_Lock );

    // remove nodes marked as deleted
    for ( start = NULL, node = list; node != start; node = next )
    {
        next = node->m_Next;
        ASSERT(next);
        QUEUE_ASSERT(next->m_Prev);
        QUEUE_ASSERT(next->m_Next);

        if ( IS_NODE_DELETED(node) )
        {
            if ( node != next )
            {
                node->m_Prev->m_Next = node->m_Next;
                node->m_Next->m_Prev = node->m_Prev;

                //node->m_Prev = NULL;
                node->m_Next = NULL;
                node->m_Data = NULL;
                gMTListNodePool->Free( node );
            }
            else
            {
                //node->m_Prev = NULL;
                node->m_Next = NULL;
                node->m_Data = NULL;
                gMTListNodePool->Free( node );

                ASSERT( start == NULL );
                break;
            }
        }
        else
        {
            if ( !start )
                start = node;
        }
    }

    return start;
}

template<class T> inline 
void ZONECALL CMTList<T>::AddListToHead( CMTListNode* list)
{
    if ( !list )
        return;

    EnterCriticalSection( &m_Lock );
        list->m_Prev->m_Next = m_Sentinal.m_Next;
        m_Sentinal.m_Next->m_Prev = list->m_Prev;
        m_Sentinal.m_Next = list;
        list->m_Prev = &m_Sentinal;
    LeaveCriticalSection( &m_Lock );
}

template<class T> inline 
void ZONECALL CMTList<T>::AddListToTail( CMTListNode* list )
{
    CMTListNode* node;
        
    if ( !list )
        return;

    EnterCriticalSection( &m_Lock );
        node = list->m_Prev;
        m_Sentinal.m_Prev->m_Next = list;
        list->m_Prev = m_Sentinal.m_Prev;
        m_Sentinal.m_Prev = node;
        node->m_Next = &m_Sentinal;
    LeaveCriticalSection( &m_Lock );
}


template<class T> inline 
bool ZONECALL CMTList<T>::ForEach( bool (ZONECALL *pfCallback)(T*, MTListNodeHandle, void*), void* pContext )
{
    CMTListNode* node;
    CMTListNode* next;
    bool bRet  = true;

    ASSERT( pfCallback != NULL );

    EnterCriticalSection( &m_Lock );
        m_Recursion++;
        for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
        {
            next = node->m_Next;
            ASSERT(next);
            QUEUE_ASSERT(next->m_Prev);
            QUEUE_ASSERT(next->m_Next);

            // remove any deleted nodes we run across
            if ( IS_NODE_DELETED(node) )
            {
                if ( m_Recursion == 1 )
                {
                    node->m_Prev->m_Next = node->m_Next;
                    node->m_Next->m_Prev = node->m_Prev;

                    #ifdef QUEUE_DBG
                    CMTListNode* existing;
                    QUEUE_ASSERT( !(existing = FindDuplicateNode( node ) ) );
					#endif

                    //node->m_Prev = NULL;
                    node->m_Next = NULL;
                    node->m_Data = NULL;
                    gMTListNodePool->Free( node );
                }
                continue;
            }
            
            if (!pfCallback( (T*) node->m_Data, node, pContext ))
            {
                bRet = false;
                break;
            }
        }
        m_Recursion--;
    LeaveCriticalSection( &m_Lock );
    return bRet;
}

template<class T> inline
bool ZONECALL CMTList<T>::Remove( T* pObject )
{
    ASSERT( pObject != NULL );

    CMTListNode* node;
    CMTListNode* next;
    bool bRet  = false;

    EnterCriticalSection( &m_Lock );
		m_Recursion++;
		for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
		{

			// remove any deleted nodes we run across
			next = node->m_Next;
			ASSERT(next);
			QUEUE_ASSERT(next->m_Prev);
			QUEUE_ASSERT(next->m_Next);
			if(node->m_Data == pObject)
			{
				MARK_NODE_DELETED(node);
				bRet = true;
			}    
			if ( IS_NODE_DELETED(node) )
			{
				if ( m_Recursion == 1 )
				{
					node->m_Prev->m_Next = node->m_Next;
					node->m_Next->m_Prev = node->m_Prev;
					#ifdef QUEUE_DBG
					CMTListNode* existing;
					QUEUE_ASSERT( !(existing = FindDuplicateNode( node ) ) );
					#endif

					//node->m_Prev = NULL;
					node->m_Next = NULL;
					node->m_Data = NULL;
					gMTListNodePool->Free( node );
				}
				continue;
			}
		}
		m_Recursion--;
    LeaveCriticalSection( &m_Lock );
    return bRet;
}

template<class T> inline 
void ZONECALL CMTList<T>::TrashDay()
{
    CMTListNode* node;
    CMTListNode* next;

	EnterCriticalSection( &m_Lock );
    if ( m_Recursion == 0 )
    {
		for ( node = m_Sentinal.m_Next; node != &m_Sentinal; node = next )
		{
			next = node->m_Next;

			ASSERT(next);
			QUEUE_ASSERT(next->m_Prev);
			QUEUE_ASSERT(next->m_Next);

			if ( IS_NODE_DELETED(node) )
			{
				node->m_Prev->m_Next = node->m_Next;
				node->m_Next->m_Prev = node->m_Prev;
				//node->m_Prev = NULL;
				node->m_Next = NULL;
				node->m_Data = NULL;
				gMTListNodePool->Free( node );
			}
		}
    }
	LeaveCriticalSection( &m_Lock );
}

template<class T> inline
MTListNodeHandle ZONECALL CMTList<T>::GetHeadPosition()
{
    EnterCriticalSection( &m_Lock );
    m_Recursion++;
    if ( !RemoveDeletedNodesFromFront() )
        return NULL;
    else
        return m_Sentinal.m_Next;

    // no unlock, user must call EndIterator
}

template<class T> inline
MTListNodeHandle ZONECALL CMTList<T>::GetTailPosition()
{
    EnterCriticalSection( &m_Lock );
    m_Recursion++;
    if ( !RemoveDeletedNodesFromBack() )
        return NULL;
    else
        return m_Sentinal.m_Prev;

    // no unlock, user must call EndIterator
}

template<class T> inline
MTListNodeHandle ZONECALL CMTList<T>::GetNextPosition( MTListNodeHandle handle )
{
    // List is already locked due to GetHeadPosition or GetTailPosition
    for( handle = handle->m_Next; IS_NODE_DELETED(handle) && (handle != &m_Sentinal); handle = handle->m_Next )
        ;
    if (handle == &m_Sentinal)
        return NULL;
    else
        return handle;
}

template<class T> inline
MTListNodeHandle ZONECALL CMTList<T>::GetPrevPosition( MTListNodeHandle handle )
{
    // List is already locked due to GetHeadPosition or GetTailPosition
    for( handle = handle->m_Prev; IS_NODE_DELETED(handle) && (handle != &m_Sentinal); handle = handle->m_Prev )
        ;
    if (handle == &m_Sentinal)
        return NULL;
    else
        return handle;
}

template<class T> inline
T* ZONECALL CMTList<T>::GetObjectFromHandle( MTListNodeHandle handle )
{
    if (handle == NULL)
        return NULL;
    else
        return (T*) handle->m_Data;
}

template<class T> inline
void ZONECALL CMTList<T>::EndIterator()
{
    m_Recursion--;
    LeaveCriticalSection( &m_Lock );
}

#ifdef QUEUE_DBG
template<class T> inline
CMTListNode* ZONECALL CMTList<T>::FindDuplicateNode( CMTListNode* object )
{
    CMTListNode* node;
    CMTListNode* next;

    EnterCriticalSection( &m_Lock );
        for (node = m_Sentinal.m_Next; node != &m_Sentinal; node = next)
        {
            next = node->m_Next;

            ASSERT(next->m_Prev);
            ASSERT(next->m_Next);

            if ( node == object )
            {
                LeaveCriticalSection( &m_Lock );
                return node;
            }
        }
    LeaveCriticalSection( &m_Lock );
    return NULL;
}
#endif //def QUEUE_DBG

#endif //!__QUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\thrdpool.h ===
#ifndef _THRDPOOL_H_
#define _THRDPOOL_H_

#include "thrdq.h"

// This class provides a pool of threads for processing tasks.
// There is no guarentee on how many tasks are queue and when a
// task will be completed, thus it should only be used for non-time
// dependent tasks

class CThreadTask
{
  private:
    char* m_pszDesc;
    
  public:
    CThreadTask() : m_pszDesc(NULL) {}
    virtual ~CThreadTask();

    // Opjects called by the thread pool proc
    virtual void Invoke() = 0;   // enqueued object is getting a chance to run
    virtual void Ignore() = 0;   // enqueued object is not going to get a chance to run before being deleted
    virtual void Discard() { delete this; } // called by CThreadPool::ThreadPoolProc after processing
                                            // Provided so that use may make a stack of task objects reducing freq. new's


    const char* GetDescription() { return m_pszDesc; }
    void SetDescription( char* pszDesc );

};

class CThreadPool : public CThreadQueue
{
  public:
    CThreadPool(DWORD ThreadCount = 0, // if 0, defaults to number of 2x processors
                DWORD ThreadPriority = THREAD_PRIORITY_NORMAL,
                DWORD ThreadStackSize = 4096 )
        : CThreadQueue( (LPTHREADQUEUE_PROCESS_PROC)ThreadPoolProc, NULL, TRUE, INFINITE,
                        ThreadCount, ThreadPriority, ThreadStackSize ) {}
                                
                                                                    
    BOOL EnqueueTask( CThreadTask* pTask ) { return Post( (LPOVERLAPPED) pTask ); }

  private:
    static DWORD ThreadPoolProc( LPVOID pNode, DWORD /*dwError*/, DWORD /*cbData*/, DWORD /*key*/, HANDLE hStopEvent, LPVOID /*pData*/, DWORD* /*pdwWait*/ )
        {
            CThreadTask* pTask = (CThreadTask*) pNode;
            if ( WaitForSingleObject( hStopEvent, 0 ) == WAIT_OBJECT_0 )
            {
                pTask->Ignore();    
            }
            else
            {
                pTask->Invoke();
            }
            pTask->Discard();

            return 0;            
        }


};
#endif // _THRDPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\thrdq.h ===
// ThrdQ.h : interface of the CThreadQueue class
//
/////////////////////////////////////////////////////////////////////////////

// Note: The threads removing data from the queue do not delete it.  You,
//       as a class user, are responsible for this

#ifndef _THRDQ_H
#define _THRDQ_H

#include "compport.h"

class CThreadQueue;

//
// LPTHREADQUEUE_PROCESS_PROC is called every time data is received on the queue
//
// pNode is the data removed from the queue.  The process proc is responsible for
// deleting it as appropriate
//
// dwError is the Win32 error code set when GetQueuedCompletionStatus returned FALSE
//
// cbData is the amount of data handled by a Overlapped IO call
//
// key is the key assoicate with an IO comp port / file handle
//
// hStopEvent will be set when the thread queue is being deleted.
// The proceedure should check this event ( WaitForSingleObject( hStopEvent, 0 ) == WAIT_OBJECT_0 )
// first thing in the proceedure to see if its just being given a chance to clean up
// items in the queue
//
// pData is a point to thread specific data
//
// pdwWait is the time to wait for a queued Node
//
typedef DWORD ( *LPTHREADQUEUE_PROCESS_PROC)( LPVOID pNode, DWORD dwError, DWORD cbData, DWORD key, HANDLE hStopEvent, LPVOID pData, DWORD* pdwWait );

//
// LPTHREADQUEUE_INIT_PROC is called during thread initialization and deletion
//
// ppData is a pointer to a void pointer that the thread may use to store thread
// specific data
//
// bInit is a TRUE is initialization is occuring, otherwise FALSE for deletion
//
typedef DWORD ( *LPTHREADQUEUE_INIT_PROC)( LPVOID *ppData, BOOL bInit );

class CQueueThread
{
    friend class CThreadQueue;

protected:
    CThreadQueue* m_pQueue;
    HANDLE m_hThread;
    LPVOID m_pData;
    static DWORD WINAPI ThreadProc( CQueueThread* pThis );

public:
    CQueueThread( CThreadQueue* pQueue );
    ~CQueueThread();
};


class CThreadQueue : public CCompletionPort
{
    friend class CQueueThread;
   
protected:
    HANDLE m_hStopEvent;
    CQueueThread** m_ThreadArray;
    
    LPTHREADQUEUE_PROCESS_PROC m_ProcessProc;    // this function is used to process Nodes in queue
    LPTHREADQUEUE_INIT_PROC m_InitProc;
    DWORD m_dwWait;
    DWORD m_ThreadCount;
    DWORD m_ThreadPriority;
    DWORD m_ThreadStackSize;
    LONG  m_ActiveThreads;

    CRITICAL_SECTION m_pCS[1];

    void ThreadProc( LPVOID* ppData );

public:
    CThreadQueue(
            LPTHREADQUEUE_PROCESS_PROC ProcessProc,
            LPTHREADQUEUE_INIT_PROC InitProc = NULL,
            BOOL  bUseCompletionPort = TRUE,
            DWORD dwInitialWaitTime = INFINITE,
            DWORD ThreadCount = 1,                            // ThreadCount == 0 means use 2x number of processors in machine
            DWORD ThreadPriority = THREAD_PRIORITY_NORMAL,
            DWORD ThreadStackSize = 4096 );              

    ~CThreadQueue();

    BOOL SetThreadCount( DWORD ThreadCount );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\registry.h ===
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

#include "winreg.h"

typedef BOOL ( WINAPI* REGENTRY_CONV_PROC)( LPSTR pvalue, LPBYTE pbuf, LPBYTE pdata, DWORD size);
// Used by AddKey to allocate storage for enumerated entries, and also to set per-value options
// for enumerated keys.
// Parameters:
//		pValueName == The name of the enumerated value.
//		dwType == The type of the enumerated value.
//      ppData ==  An out pointer which, on return of the function, contains enough storage
//				   to hold the data for pValueName. If this is set to NULL, then no 
//				   storage is given and ppfnConv must be set to a valid conversion proc.
//		pcbSize == An in/out param. When the function is called, this contains the 
//				   amount of storage needed to completely store the data for pValueName.
//				   When the function returns it should be filled with the amount of memory
//                 actually allocated in ppData.
//		ppfnConv == An out param which is the optional converstion procedure for pValueName.
//					Set this to NULL if you don't want one.
typedef BOOL ( WINAPI* REGENTRY_ENUM_PROC)( LPSTR pValueName, DWORD dwType, 
                                            LPBYTE *ppData, LPDWORD pcbSize,
											REGENTRY_CONV_PROC *ppfnConv );

class CRegistry 
{

  public:
    CRegistry();
   ~CRegistry();


    BOOL SetKeyRoots( LPSTR* pszRootArray, DWORD numRoots );
    BOOL SetKeyRoot( LPSTR pszRoot ) 
        { LPSTR pRoots[1] = { pszRoot }; return SetKeyRoots( pRoots, 1 ); }
    BOOL SetRoomRoots( LPCSTR pszRoom );

    void Close();


    void Lock() { EnterCriticalSection( m_pCS ); }
    void Unlock() { LeaveCriticalSection( m_pCS ); }


    BOOL HasChangeOccurred();

    BOOL ReadValues();

    LPSTR GetErrorValueName()    { return m_pValue; }
    LPSTR GetErrorReason()        { return m_pErr; }
    DWORD GetErrorCode()        { return m_dwErrCode; }

    BOOL ComposeErrorString( LPSTR pszBuf, DWORD len );

    enum READ_TYPE { STATIC, DYNAMIC };
    BOOL AddValue( LPSTR pszSubKey, LPSTR pszValue, DWORD dwType, LPBYTE pData, DWORD cbData, READ_TYPE type = STATIC, BOOL bRequired = TRUE, REGENTRY_CONV_PROC proc = NULL );

    BOOL AddValueLPSTR( LPSTR pszSubKey, LPSTR pszValue, LPSTR pData, DWORD cbData, READ_TYPE type = STATIC, BOOL bRequired = TRUE )
        { return AddValue( pszSubKey, pszValue, REG_SZ, (LPBYTE) pData, cbData, type, bRequired ); }
    BOOL AddValueDWORD( LPSTR pszSubKey, LPSTR pszValue, DWORD* pData, READ_TYPE type = STATIC, BOOL bRequired = TRUE )
        { return AddValue( pszSubKey, pszValue, REG_DWORD, (LPBYTE) pData, sizeof(DWORD), type, bRequired ); }
    BOOL AddValueWORD( LPSTR pszSubKey, LPSTR pszValue, WORD* pData, READ_TYPE type = STATIC, BOOL bRequired = TRUE )
        { return AddValue( pszSubKey, pszValue, REG_DWORD, (LPBYTE) pData, sizeof(WORD), type, bRequired, DWORDtoWORD ); }
    BOOL AddValueBYTE( LPSTR pszSubKey, LPSTR pszValue, BYTE * pData, READ_TYPE type = STATIC, BOOL bRequired = TRUE )
        { return AddValue( pszSubKey, pszValue, REG_DWORD, (LPBYTE) pData, sizeof(BYTE), type, bRequired, DWORDtoBYTE ); }

	// Enumerates through each subkey under each root key and adds all the values to the read list.
	// Parameters:
	//		pszSubKey == The subkey to enumerate. Must not be NULL.
	//		pfnEnum == The enumeration callback function. Must not be NULL.
	//		type == The read type of the Key--and therefore all the values in the key.
	//		bRequired = Whether the key itself is required. If bRequired == TRUE and the key doesn't exist, the function
	//					returns FALSE and the error info is set.
	BOOL AddKey( LPSTR pszSubKey, REGENTRY_ENUM_PROC pfnEnum, READ_TYPE type = STATIC, BOOL bRequired = TRUE );

    static BOOL WINAPI DWORDtoWORD( LPSTR pvalue, LPBYTE pbuf, LPBYTE pdata, DWORD size)
        { *(WORD*)pbuf = (WORD)(*(DWORD*)pdata); return TRUE; }
    static BOOL WINAPI DWORDtoBYTE( LPSTR pvalue, LPBYTE pbuf, LPBYTE pdata, DWORD size)
        { *(BYTE*)pbuf = (BYTE)(*(DWORD*)pdata); return TRUE; }

    enum
    {
        ErrOk = 0,
        ErrUnknown,
        ErrRegOpenFailed,
        ErrNotFound,
        ErrNotDword,
        ErrNotSZ,
        ErrNotMultiSZ,
        ErrUnsupported,
        ErrInvalid,
    };

  protected:

    CRITICAL_SECTION m_pCS[1];


    struct ErrorCode
    {
        DWORD    Code;
        LPSTR    String;
    };

    LPSTR GetError( DWORD ErrCode );


    struct RegEntry
    {
        LPSTR   pSubKey;
        LPSTR   pValue;
        DWORD   type;
        LPBYTE  pBuf;
        DWORD   size;
        BYTE    required;
        FARPROC conversionProc;  // typedef BOOL ( WINAPI* REGENTRY_CONV_PROC)( LPSTR pvalue, LPBYTE pbuf, LPBYTE pdata, DWORD size);
    };

    BOOL Add( RegEntry** ppEntries, DWORD* pnumEntries, DWORD* pAllocEntries, LPSTR pszSubKey, LPSTR pszValue, DWORD dwType, LPBYTE pData, DWORD cbData, BOOL bRequired, REGENTRY_CONV_PROC proc );
    BOOL Read( RegEntry* pEntries, DWORD numEntries );

    RegEntry* m_Static;
    DWORD     m_numStatic;
    DWORD     m_allocStatic;

    RegEntry* m_Dynamic;
    DWORD     m_numDynamic;
    DWORD     m_allocDynamic;

    LPSTR     m_StrBuf;
    DWORD     m_cbStrBuf;
    DWORD     m_cbStrBufRemaining;
    LPSTR     AllocStr( LPSTR str );
    void      OffsetStrPtrs( RegEntry* pEntries, DWORD numEntries, long offset );

    LPSTR m_pErr;
    LPSTR m_pValue;
    DWORD m_dwErrCode;

    DWORD m_numRoots;
    HKEY* m_phkeyRoots;
    HANDLE* m_phRootEvents;

    BYTE   m_bStaticRead;
    BYTE   m_bChanged;

    static ErrorCode m_pErrors[];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\roommsg.h ===
#ifndef __ROOMMSG_H
#define __ROOMMSG_H

#ifndef _ROOM_
#define _ROOM_
#endif

#include "gamemsg.h"


#endif //__ROOMMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\tstr.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    tstr.h

Abstract:

    This include file contains manifests and macros to be used to integrate
    the TCHAR and LPTSTR definitions

    Note that our naming convention is that a "size" indicates a number of
    bytes whereas a "length" indicates a number of characters.

Author:

    Richard Firth (rfirth) 02-Apr-1991

Environment:

    Portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names,
    _ultoa() routine.

Revision History:

    22-May-1991 Danl
        Added STRSIZE macro
    19-May-1991 JohnRo
        Changed some parm names to make things easier to read.
    15-May-1991 rfirth
        Added TCHAR_SPACE and MAKE_TCHAR() macro
    15-Jul-1991 RFirth
        Added STRING_SPACE_REQD() and DOWN_LEVEL_STRSIZE
    05-Aug-1991 JohnRo
        Added MEMCPY macro.
    19-Aug-1991 JohnRo
        Added character type stuff: ISDIGIT(), TOUPPER(), etc.
    20-Aug-1991 JohnRo
        Changed strnicmp to _strnicmp to keep PC-LINT happy.  Ditto stricmp.
    13-Sep-1991 JohnRo
        Need UNICODE STRSIZE() too.
    13-Sep-1991 JohnRo
        Added UNICODE STRCMP() and various others.
    18-Oct-1991 JohnRo
        Added NetpCopy routines and WCSSIZE().
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (like strncpy but do conversions as well).
    09-Dec-1991 rfirth
        Added STRREV
    03-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
    09-Jan-1992 JohnRo
        Added ATOL() macro and wtol() routine.
        Ditto ULTOA() macro and ultow() routine.
    16-Jan-1992 Danl
        Cut this info from \net\inc\tstring.h
    30-Jan-1992 JohnRo
        Added STRSTR().
        Use _wcsupr() instead of wcsupr() to keep PC-LINT happy.
        Added STRCMPI() and STRNCMPI().
        Fixed a few definitions which were missing MAKE_STR_FUNCTION etc.
    14-Mar-1992 JohnRo
        Avoid compiler warnings using WCSSIZE(), MEMCPY(), etc.
        Added TCHAR_TAB.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

#ifndef _TSTR_H_INCLUDED
#define _TSTR_H_INCLUDED

#include <ctype.h>              // isdigit(), iswdigit() eventually, etc.
#include <stdlib.h>             // atol(), _ultoa().
#include <string.h>             // memcpy(), strlen(), etc.
#include <wchar.h>
#include <tchar.h>


#ifdef UNICODE
#define _CHAR_TYPE  WCHAR
#define FORMAT_LPTSTR TEXT("%ws")

#else
#define _CHAR_TYPE  TCHAR
#define FORMAT_LPTSTR TEXT("%s")

#endif

//
// function macro prototypes
//

#ifdef UNICODE
#define ATOL           _wtol
#define ATOI           _wtoi
#else
#define ATOL           atol
#define ATOI           atoi
#endif

#define ISALNUM             _istalnum
#define ISALPHA             _istalpha
#define ISCNTRL             _istcntrl
#define ISDIGIT             _istdigit
#define ISGRAPH             _istgraph
#define ISLOWER             _istlower
#define ISPRINT             _istprint
#define ISPUNCT             _istpunct
#define ISSPACE             _istspace
#define ISUPPER             _istupper
#define ISXDIGIT            _istxdigit

#define STRCAT              _tcscat
#define STRCHR              _tcschr
#define STRCPY              _tcscpy
#define STRCSPN             _tcscspn
// STRLEN: Get character count of s.
#define STRLEN              _tcslen
#define STRNCAT             _tcsncat
#define STRNCPY             _tcsncpy
#define STRSPN              _tcsspn
#define STRRCHR             _tcsrchr
#define STRSTR              _tcsstr
#define STRLWR              _tcslwr
#define STRUPR              _tcsupr

// compare functions: len is maximum number of characters being compared.
#define STRCMP              _tcscmp
#define STRCMPI             _tcsicmp
#define STRICMP             _tcsicmp
#define STRNCMP             _tcsncmp
#define STRNCMPI            _tcsnicmp
#define STRNICMP            _tcsnicmp

#define TOLOWER             _totlower
#define TOUPPER             _totupper

#ifdef UNICODE
#define ULTOA               _ultow
#else
#define ULTOA               _ultoa
#endif

#define SPRINTF             _stprintf
#define SSCANF              _stscanf



//
// For the memory routines, the counts are always BYTE counts.
//
#define MEMCPY              memcpy
#define MEMMOVE             memmove

//
// These are used to determine the number of bytes (including the NUL
// terminator) in a string.  This will generally be used when
// calculating the size of a string for allocation purposes.
//

#define STRSIZE(p)      ((STRLEN(p)+1) * sizeof(TCHAR))
#define WCSSIZE(s)      ((wcslen(s)+1) * sizeof(WCHAR))


//
// character literals (both types)
//

#define TCHAR_EOS       ((_CHAR_TYPE)'\0')
#define TCHAR_STAR      ((_CHAR_TYPE)'*')
#define TCHAR_BACKSLASH ((_CHAR_TYPE)'\\')
#define TCHAR_FWDSLASH  ((_CHAR_TYPE)'/')
#define TCHAR_COLON     ((_CHAR_TYPE)':')
#define TCHAR_DOT       ((_CHAR_TYPE)'.')
#define TCHAR_SPACE     ((_CHAR_TYPE)' ')
#define TCHAR_TAB       ((_CHAR_TYPE)'\t')


//
// General purpose macro for casting character types to whatever type in vogue
// (as defined in this file)
//

#define MAKE_TCHAR(c)   ((_CHAR_TYPE)(c))

//
// IS_PATH_SEPARATOR
//
// lifted from curdir.c and changed to use TCHAR_ character literals, checks
// if a character is a path separator i.e. is a member of the set [\/]
//

#ifndef IS_PATH_SEPARATOR
#define IS_PATH_SEPARATOR(ch) ((ch == TCHAR_BACKSLASH) || (ch == TCHAR_FWDSLASH))
#endif

//
// The following 2 macros lifted from I_Net canonicalization files
//

#define IS_DRIVE(c)             ISALPHA(c)
#define IS_NON_ZERO_DIGIT(c)    (((c) >= MAKE_TCHAR('1')) && ((c) <= MAKE_TCHAR('9')))

//
// STRING_SPACE_REQD returns a number (of bytes) corresponding to the space
// required in which (n) characters can be accomodated
//

#define STRING_SPACE_REQD(n)    ((n) * sizeof(_CHAR_TYPE))

//
// DOWN_LEVEL_STRLEN returns the number of single-byte characters necessary to
// store a converted _CHAR_TYPE string. This will be WCHAR (or wchar_t) if
// UNICODE is defined or CHAR (or char) otherwise
//

#define DOWN_LEVEL_STRSIZE(n)   ((n) / sizeof(_CHAR_TYPE))

#endif  // _TSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\scoredll.h ===
/******************************************************************************

  ScoreDll.h

  Copyright (c) Microsoft Corp. 1997.  All rights reserved.
  Written by Chad Barry
  Created on 11/5/97

******************************************************************************/

#ifndef SCORE_DLL_H
#define SCORE_DLL_H

#include <windows.h>
#include <tchar.h>
#include "ztypes.h"
#include "zone.h"
#include "zonedebug.h"
#include "hash.h"
#include "zservcon.h"
#include "property.h"
#include "zodbc.h"


///////////////////////////////////////////////////////////////////////////////
//
// Interface versions
//
#define ISCOREDLL_VERSION	7
#define ILOGDLL_VERSION		6


///////////////////////////////////////////////////////////////////////////////
//
// Error codes
//
#define MAKE_PROPRESULT( code )		MAKE_HRESULT( 1, 0, code )
#define PROPERR_OK					S_OK
#define	PROPERR_FAIL				E_FAIL
#define PROPERR_OUTOFMEMORY			E_OUTOFMEMORY
#define	PROPERR_INVALIDARG			E_INVALIDARG
#define PROPERR_BUFFERTOOSMALL		MAKE_PROPRESULT( 1 )
#define	PROPERR_NOTFOUND			MAKE_PROPRESULT( 2 )
#define PROPERR_DB					MAKE_PROPRESULT( 3 )
#define PROPERR_BADMESSAGE			MAKE_PROPRESULT( 4 )
#define PROPERR_UNKNOWN_USER		MAKE_PROPRESULT( 5 )



///////////////////////////////////////////////////////////////////////////////
//
// Forward references
//
class IPropertyList;
class IScoreDll;
class ILogDll;
class ILogSrv;



///////////////////////////////////////////////////////////////////////////////
//
// Dll initialization / destruction
//
IScoreDll* WINAPI ScoreDllCreate( const TCHAR* szServiceName );
BOOL WINAPI ScoreDllFree( IScoreDll* pDll );

typedef IScoreDll* ( WINAPI *SCOREDLL_CREATE_PROC )( const TCHAR* szServiceName );
typedef BOOL ( WINAPI *SCOREDLL_FREE_PROC )( IScoreDll* pDll );


ILogDll* WINAPI LogDllCreate( const TCHAR* szServiceName );
BOOL WINAPI LogDllFree( ILogDll* pDll );

typedef ILogDll* ( WINAPI *LOGDLL_CREATE_PROC )( const TCHAR* szServiceName );
typedef BOOL ( WINAPI *LOGDLL_FREE_PROC )( ILogDll* pDll );


///////////////////////////////////////////////////////////////////////////////
//
// Helper initialization functions
//
struct ScoreDllInfo
{
	HANDLE					hDll;
	SCOREDLL_CREATE_PROC	pfCreate;
	SCOREDLL_FREE_PROC		pfFree;
	IScoreDll*				pIScoreDll;
	TCHAR					szArenaAbbrev[32];

	ScoreDllInfo() : hDll( NULL ), pfCreate( NULL ), pfFree( NULL ), pIScoreDll( NULL ) {}
};

extern BOOL LoadScoreDll( const TCHAR* szServiceName, const TCHAR* szClassName, ScoreDllInfo* pDllInfo );
extern BOOL LoadCBScoreDll( const TCHAR* szServiceName, const TCHAR* szClassName, ScoreDllInfo* pDllInfo );
extern void FreeScoreDll( ScoreDllInfo* pDllInfo );



struct LogDllInfo
{
	HANDLE					hDll;
	LOGDLL_CREATE_PROC		pfCreate;
	LOGDLL_FREE_PROC		pfFree;
	ILogDll*				pILogDll;

	LogDllInfo() : hDll( NULL ), pfCreate( NULL ), pfFree( NULL ), pILogDll( NULL ) {}
};

extern BOOL LoadLogDll( const TCHAR* szDllName, const TCHAR* szServiceName, LogDllInfo* pDllInfo );
extern void FreeLogDll( LogDllInfo* pDllInfo );


///////////////////////////////////////////////////////////////////////////////
//
// Lobby -> Log message structues
//

#pragma pack( push, 4 )

// too bad the best way to do this right now is to slap it onto all communication between score and log.  oh well.
// later, when log keeps track of connections, this and other stuff can be sent when the connection is
// established and associated by log with the connection.
struct PervasiveParameters
{
	// should be signed
	int32	IncsTilPenalty;
	int32	PenaltyGames;
	int32	MinimumPenalty;
	int32	GamesTilIncRemoved;

	// unfortunately this is pretty useless because most people just cast a buffer to
	// LogMsgHeader*.  so don't depend on it.
	PervasiveParameters() : IncsTilPenalty(-1), PenaltyGames(-1), MinimumPenalty(-1), GamesTilIncRemoved(-1) { }
};

struct LogMsgHeader
{
	GUID	Guid;
	char	Arena[32];

	PervasiveParameters PParams;

	DWORD	Length;
	BYTE	Data[1];
};

#pragma pack( pop )



///////////////////////////////////////////////////////////////////////////////
//
// Property list
//
class IPropertyList
{
public:
	IPropertyList( IScoreDll* pScoreDll );
	virtual ~IPropertyList();

	// reference counting
	virtual long AddRef();
	virtual long Release();

	// property list
    virtual HRESULT SetProperty( DWORD ZUserId, DWORD DPUserId, const GUID& guid, void* pBuffer, DWORD dwSize ) = 0;
    virtual HRESULT GetProperty( DWORD ZUserId, DWORD DPUserId, const GUID& guid, void* pBuffer, DWORD* pdwSize ) = 0;
    virtual HRESULT ClearProperties() = 0;
	virtual DWORD	GetPropCount() = 0;

	// user list
	virtual HRESULT SetUser( DWORD dwUserId, TCHAR* szUserName ) = 0;
	virtual HRESULT GetUser( TCHAR* szPartialUserName, DWORD* pdwUserId, TCHAR* szUserName ) = 0;
	virtual HRESULT ClearUsers() = 0;
	virtual DWORD   GetUserCount() = 0;

	virtual HRESULT Log( TCHAR* szArenaAbbrev ) = 0;

protected:
	// reference count
	long m_RefCnt;

	// parent interface
	IScoreDll* m_pIScoreDll;
};



///////////////////////////////////////////////////////////////////////////////
//
// Score Dll interface
//

struct SCORE_USER_RATING
{
	DWORD	UserID;
	short	Rating;
	short	GamesPlayed;
	short	GamesAbandoned;
	short	rfu;
	char	UserName[ zUserNameLen + 1 ];
};


struct SCORE_CHAT
{
	DWORD	userID;
	char	text[ 128 ];
};


class IScoreDll
{
public:

	enum Events
	{
		EventLogConnectionLost	= 0,
		EventLogConnectionEstablished,
		EventLogRecvdUserStats,
		EventChat
	};

	// function prototype for server event handler, WARNING it will be called by random threads
	typedef void ( WINAPI *EVENT_PROC )( IScoreDll::Events iEvent, void* Data, void* Cookie );

	// class constructor & destructor
	IScoreDll();
	virtual ~IScoreDll();

	// reference counting
	virtual long AddRef();
	virtual long Release();

	// set debugging level
	virtual HRESULT SetDebugLevel( DWORD level );
	virtual HRESULT GetDebugLevel( DWORD* plevel );

	// interface version
	virtual DWORD GetVersion() = 0;

	// initialize properties from registry keys
	virtual HRESULT Init( const TCHAR* szServiceName, const TCHAR* szClassName, LPSTR* pszRootArray, int numRoots, const TCHAR* szLogIp, const DWORD dwLogPort, const PervasiveParameters *pPParams ) = 0;

	// allows scoredll to save away arena abbrev for use in games where all users may not be returned to lobby
	// before results need to be stored
	virtual void SetArena(TCHAR* szArenaAbbrev){};
	virtual TCHAR* GetArena(){return 0;}

	// allows setting of pervasive parameters (currently: info about scoring incompletes)
	virtual void SetPParams(const PervasiveParameters *pPParams) { m_PParams = *pPParams; }

	// retrieves pervasive parameters
	virtual void GetPParams(PervasiveParameters *pPParams) { if(pPParams) *pPParams = m_PParams; }

	// create property list object
	virtual HRESULT CreatePropertyList( IPropertyList** ppIPropertyList ) = 0;

	// maximum expected property buffer size
	virtual DWORD GetMaxBufferSize() = 0;

	// query if GUID supported
	virtual BOOL IsPropertySupported( const GUID& guid ) = 0;

	// get list of supported GUIDs
	virtual HRESULT GetPropertyList( GUID* pGuids, DWORD* pdwNumGuids ) = 0;

	// send message to log server
	virtual HRESULT SendLogMsg( LogMsgHeader* pMsg ) = 0;

	// event handler
	virtual HRESULT SetEventHandler( IScoreDll::EVENT_PROC pfEventHandler, void* Cookie ) = 0;
	virtual HRESULT GetEventHandler( IScoreDll::EVENT_PROC* ppfEventHandler, void** pCookie ) = 0;
	virtual HRESULT SendEvent( IScoreDll::Events iEvent, void* Data = NULL ) = 0;

	// async rating queries
	virtual HRESULT PostRatingQuery( TCHAR* szArenaAbbrev, DWORD UserId, TCHAR* szUserName ) = 0;
	virtual HRESULT GetRatingResult( void* pData, SCORE_USER_RATING** ppRatings, DWORD* pNumElts ) = 0;

protected:
	// reference count
	long m_RefCnt;

	// event handler
	EVENT_PROC	m_pfEventHandler;
	void*		m_pEventHandlerCookie;

	// registry parameters
	PervasiveParameters m_PParams;

	// debug level
	DWORD		m_dwDebugLevel;
};



///////////////////////////////////////////////////////////////////////////////
//
// Log Server interface
//
class CLogStat
{
public:
	// database fields
	char	Name[ 32 ];
	char	TeamName[ 32 ];
	int		EntityId;
	int		ArenaId;
	int		TeamId;
	int		Rank;
	int		Rating;
	int		Wins;
	int		Losses;
	int		Ties;
	int		Incomplete;
	int		IncPenaltyAcc;
	int		IncPenaltyCnt;
	int		IncTotalDed;
	int		WasIncompleted;
	int		Streak;

	// local fields
	int		Games;
	int		RatingSum;
	int		Results;
	int		Score;
	int		NewRating;  // used by UpdateIncompleteStats

	// construction & destruction
	CLogStat();
	~CLogStat();

	// reference counting
	long AddRef();
	long Release();

	// blob management
	void	 SetBlob( ILogDll* pILogDll, void* pBlob ) {m_pILogDll = pILogDll; m_pBlob = pBlob;}
	void*	 GetBlob() { return m_pBlob; }
	ILogDll* GetLogDll() { return m_pILogDll; }

private:
	// reference count
	long m_RefCnt;

	// blob, delete via m_pILogDll->DeleteBlob
	void* m_pBlob;
	ILogDll* m_pILogDll;
};


class ILogSrv
{
public:

	ILogSrv();
	virtual ~ILogSrv();

	// reference counting
	virtual long AddRef();
	virtual long Release();

	// look up ArenaId
	virtual HRESULT GetArenaId( TCHAR* szArenaAbbrev, int* pArenaId ) = 0;

	// allocate CLogStat objects, ppStats is an array of CLogStat pointers
	// that receives the objects.
	virtual HRESULT AllocLogStats( CLogStat *apStats[], int iStats ) = 0;

	// free CLogStat objects, ppStats is an arrary of CLogStat pointers to
	// be freed.
	virtual HRESULT FreeLogStats( CLogStat *apStats[], int iStats ) = 0;

	// look up list of players and add to server cache
	virtual HRESULT GetAndCachePlayerStats( CLogStat *apStats[], int iNumPlayers, int iDefaultRating  ) = 0;

	// look up list of players
	virtual HRESULT GetPlayerStats( CLogStat *apStats[], int iNumPlayers, int iDefaultRating  ) = 0;

	// save list of players and add to server cache
	virtual HRESULT SetPlayerStats( CLogStat *apStats[], int iNumPlayers ) = 0;

	// record game history, must be called before SetPlayerStats
	virtual HRESULT SetGameData( TCHAR* szGameAbbrev, int ArenaId ) = 0;

	// retreive ODBC pointer for custom queries, must be freed before
	// calling other ILogSrv interfaces
	virtual HRESULT GetOdbc( CODBC** ppOdbc ) = 0;
	virtual HRESULT FreeOdbc( CODBC* pOdbc ) = 0;

protected:
	// reference count
	long m_RefCnt;
};



///////////////////////////////////////////////////////////////////////////////
//
// Log Dll interface
//
class ILogDll
{
public:
	ILogDll();
	virtual ~ILogDll();

	// reference counting
	virtual long AddRef();
	virtual long Release();

	// initialize log interface
	virtual HRESULT Init( const TCHAR* szServiceName ) = 0;

	// get list of supported GUIDs
	virtual HRESULT GetPropertyList( GUID* pGuids, DWORD* pdwNumGuids ) = 0;

	// log score
	virtual HRESULT LogProperty( ILogSrv* pILogSrv, char* szArena, GUID* pGuid, PervasiveParameters *pPParams, void* pBuf, DWORD dwLen ) = 0;

	// delete DLL blob attached to ILogSrv::Stats object
	virtual HRESULT DeleteBlob( void* pBlob ) = 0;

	// interface version
	virtual DWORD GetVersion() = 0;

protected:
	// reference count
	long m_RefCnt;
};


///////////////////////////////////////////////////////////////////////////////
//
// Null implementations
//
class INullPropertyList : public IPropertyList
{
public:
	INullPropertyList( IScoreDll* pScoreDll ) : IPropertyList( pScoreDll ) {}
    virtual HRESULT SetProperty( DWORD ZUserId, DWORD DPUserId, const GUID& guid, void* pBuffer, DWORD dwSize );
    virtual HRESULT GetProperty( DWORD ZUserId, DWORD DPUserId, const GUID& guid, void* pBuffer, DWORD* pdwSize );
    virtual HRESULT ClearProperties();
	virtual DWORD	GetPropCount();
	virtual HRESULT SetUser( DWORD dwUserId, TCHAR* szUserName );
	virtual HRESULT GetUser( TCHAR* szPartialUserName, DWORD* pdwUserId, TCHAR* szUserName );
	virtual HRESULT ClearUsers();
	virtual DWORD   GetUserCount();
	virtual HRESULT Log( TCHAR* szArenaAbbrev );
};


class INullScoreDll : public IScoreDll
{
public:
	virtual DWORD GetVersion();
	virtual HRESULT Init( const TCHAR* szServiceName, const TCHAR* szClassName, LPSTR* pszRootArray, int numRoots, const TCHAR* szLogIp, const DWORD dwLogPort, const PervasiveParameters *pPParams );
		
	virtual HRESULT CreatePropertyList( IPropertyList** ppIPropertyList );

	virtual DWORD GetMaxBufferSize();
	virtual BOOL IsPropertySupported( const GUID& guid );
	virtual HRESULT GetPropertyList( GUID* pGuids, DWORD* pdwNumGuids );

	virtual HRESULT SendLogMsg( LogMsgHeader* pMsg );

	virtual HRESULT SetEventHandler( EVENT_PROC pfEventHandler, void* Cookie );
	virtual HRESULT GetEventHandler( EVENT_PROC* ppfEventHandler, void** pCookie );
	virtual HRESULT SendEvent( Events iEvent, void* Data = NULL );

	virtual HRESULT PostRatingQuery( TCHAR* szArenaAbbrev, DWORD UserId, TCHAR* szUserName );
	virtual HRESULT GetRatingResult( void* pData, SCORE_USER_RATING** ppRatings, DWORD* pNumElts );
};
	

class INullLogDll : public ILogDll
{
public:
	virtual HRESULT Init( const TCHAR* szServiceName );
	virtual HRESULT GetPropertyList( GUID* pGuids, DWORD* pdwNumGuids );
	virtual HRESULT LogProperty( ILogSrv* pILogSrv, char* szArena, GUID* pGuid, PervasiveParameters *pPParams, void* pBuf, DWORD dwLen );
	virtual HRESULT DeleteBlob( void* pBlob );
	virtual DWORD GetVersion();
};



///////////////////////////////////////////////////////////////////////////////
//
// DirectPlay implementations
//
class IDPPropList : public IPropertyList
{
	friend class IDPScoreDll;

public:
	IDPPropList( IScoreDll* pScoreDll );
	virtual ~IDPPropList();

    virtual HRESULT SetProperty( DWORD ZUserId, DWORD DPUserId, const GUID& guid, void* pBuffer, DWORD dwSize );
    virtual HRESULT GetProperty( DWORD ZUserId, DWORD DPUserId, const GUID& guid, void* pBuffer, DWORD* pdwSize );
	virtual HRESULT ClearProperties();
	virtual DWORD	GetPropCount();

	virtual HRESULT SetUser( DWORD dwUserId, TCHAR* szUserName );
	virtual HRESULT GetUser( TCHAR* szPartialUserName, DWORD* pdwUserId, TCHAR* szUserName );
	virtual HRESULT ClearUsers();
	virtual DWORD	GetUserCount();
	
protected:
	// object lock
	CRITICAL_SECTION m_Lock;

	// user list
	struct User
	{
		BOOL	fUsed;
		DWORD	userID;
		TCHAR	userName[ zUserNameLen + 1 ];

		User::User() : fUsed( FALSE ) {}
		static int Cmp( User* p, TCHAR* pName ) { return lstrcmp( p->userName, pName ) == 0; }
		static void Del( User* p, void* ) { delete p; }
	};

	CHash<User,TCHAR*> m_Users;

	// property list
	struct PropKey
	{
		DWORD userId;
		GUID  Guid;

		static int Cmp( CProperty* p, PropKey* k ) { return (p->m_Player == k->userId) && (p->m_Guid == k->Guid); }
		static DWORD Hash( PropKey* k ) { return k->userId; }
		static void Del( CProperty* p, void* ) { delete p; }
	};

	// GetUser helpers
	User*	pFoundUser;
	TCHAR*  pUserName;
	static int FindExactPlayer( User* pUser, MTListNodeHandle, void* Cookie );
	static int FindPartialPlayer( User* pUser, MTListNodeHandle, void* Cookie );
	
	CHash<CProperty,PropKey*> m_Props;
};


class IDPScoreDll : public IScoreDll
{
public:
	IDPScoreDll();
	virtual ~IDPScoreDll();

	virtual HRESULT Init( const TCHAR* szServiceName, const TCHAR* szClassName, LPSTR* pszRootArray, int numRoots, const TCHAR* szLogIp, const DWORD dwLogPort, const PervasiveParameters *pPParams );
	virtual HRESULT SendLogMsg( LogMsgHeader* pMsg );
	virtual HRESULT SetEventHandler( IScoreDll::EVENT_PROC pfEventHandler, void* Cookie );
	virtual HRESULT GetEventHandler( IScoreDll::EVENT_PROC* ppfEventHandler, void** pCookie );
	virtual HRESULT SendEvent( IScoreDll::Events iEvent, void* Data = NULL );
	virtual HRESULT PostRatingQuery( TCHAR* szArenaAbbrev, DWORD UserId, TCHAR* szUserName );
	virtual HRESULT GetRatingResult( void* pData, SCORE_USER_RATING** ppRatings, DWORD* pNumElts );

protected:
	// connection handler
	static void MsgFunc( ZSConnection connection, uint32 event, void* userData );
	static DWORD WINAPI ThreadProc(  LPVOID lpParameter  );
    BOOL ConnectToServer(BOOL ReconnectTry=FALSE);

	// object lock
	CRITICAL_SECTION m_Lock;

	// connection parameters
	TCHAR			m_szLogIp[256];
	DWORD			m_dwLogPort;
	ZSConnection	m_Connection;
	HANDLE			m_ConnThread;

	// event signaling object destruction
	HANDLE			m_hStopEvent;

	// event signaling connection's readiness
	HANDLE			m_hConnReady;
};


#endif // !SCORE_DLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\uapi.h ===
//
// UAPI.h
// This is the header file for a Unicode API. It allows an application to use 
// Unicode on both Windows NT and Windows 9x. See the readme file for details.
// Copyright (c) 1998 Microsoft Systems Journal

#ifndef _UAPIH
#include "UnicodeAPI.h"



// These macro save declaring these globals twice
#ifdef GLOBALS_HERE
#define GLOBAL
#define GLOBALINIT(a) = a
#else
#ifdef __cplusplus
#define GLOBAL extern "C"
#else
#define GLOBAL extern
#endif
#define GLOBALINIT(a)
#endif

#ifdef UNICODE

extern "C" BOOL ConvertMessage(HWND, UINT, WPARAM *, LPARAM *);
extern "C" BOOL InitUnicodeAPI(HINSTANCE hInstance);

#else


// Special cases, with no corresponding Win32 API function
#define ConvertMessage(h, m, w, p)      (TRUE)		    
#define UpdateUnicodeAPI(lang, page)    (TRUE)
#define InitUnicodeAPI(h)               (TRUE)

#endif _UNICODE

#define _UAPIH
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\unicodeapi.h ===
//
// UNIANSI.H
//

#ifndef _UNICODEAPI
#define _UNICODEAPI


/////////////////////////////////////////////////////////////////
//
// Valid Unicode Functions in Windows 
//
// TextOutW
// TextOutExW
// GetCharWidthW
// GetTextExtentPointW
// GetTextExtentPoint32W
// MessageBoxW
// MessageBoxExW
// wcs functions
// GetCommandLine
// FindResource
//
//

////////////////////////////////////////////////////////
//
// Structure to hold Font Data for Enum Font procedure
//
////////////////////////////////////////////////////////

typedef int (CALLBACK* USEFONTENUMPROCW)(CONST LOGFONTW *, CONST TEXTMETRICW *, DWORD, LPARAM);
				        
typedef struct tag_EnumFontFamProcWData
{
	USEFONTENUMPROCW lpEnumFontFamProc;				//Used to hold address of original Unicode function
	LPARAM        	 lParam;							//Holds address of the data that is to be passed to original function
}ENUMFONTFAMPROCDATA, *LPENUMFONTFAMPROCDATA;


////////////////////////
//
//  GDI32.DLL
//
////////////////////////

typedef WINUSERAPI INT   (WINAPI *UAPI_GetTextFace)        (HDC, INT, LPWSTR);
typedef WINUSERAPI HDC   (WINAPI *UAPI_CreateDC)           (LPCWSTR, LPCWSTR, LPCWSTR,  CONST DEVMODEW * );
typedef WINUSERAPI BOOL  (WINAPI *UAPI_GetTextMetrics)     (HDC, LPTEXTMETRICW); 
typedef WINUSERAPI HFONT (WINAPI *UAPI_CreateFont)         (INT, INT, INT, INT, INT, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCWSTR);
typedef WINUSERAPI HFONT (WINAPI *UAPI_CreateFontIndirect) (CONST LOGFONTW *);
typedef WINUSERAPI INT   (WINAPI *UAPI_EnumFontFamilies)   (HDC, LPCWSTR, FONTENUMPROCW, LPARAM);

////////////////////////
//
// WINMM.DLL
//
////////////////////////

typedef WINUSERAPI BOOL  (WINAPI *UAPI_PlaySound)          (LPCWSTR, HMODULE, DWORD);


////////////////////////
//
// SHELL32.DLL
//
////////////////////////

typedef WINUSERAPI HINSTANCE (WINAPI *UAPI_ShellExecute)   (HWND, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, INT);

//////////////////////////////////
//
// COMDLG32.DLL
//
//////////////////////////////////

typedef WINUSERAPI BOOL  (WINAPI *UAPI_ChooseFont)         (LPCHOOSEFONTW);

//////////////////////////////////
//
// KERNEL32.DLL
//
//////////////////////////////////
typedef WINUSERAPI DWORD   (WINAPI *UAPI_GetPrivateProfileString)	  (	LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR , DWORD , LPCWSTR );
typedef WINUSERAPI DWORD   (WINAPI *UAPI_GetProfileString)			  (LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR,DWORD);							 
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_CreateFileMapping)			  (HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCWSTR);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_FindFirstChangeNotification) (LPCWSTR, BOOL, DWORD);

typedef WINUSERAPI DWORD   (WINAPI *UAPI_FormatMessage)			   (DWORD, LPCVOID, DWORD, DWORD, LPWSTR, DWORD, va_list*);
typedef WINUSERAPI INT     (WINAPI *UAPI_lstrcmp)				   (LPCWSTR, LPCWSTR);
typedef WINUSERAPI LPWSTR  (WINAPI *UAPI_lstrcat)				   (LPWSTR,  LPCWSTR);
typedef WINUSERAPI LPWSTR  (WINAPI *UAPI_lstrcpy)				   (LPWSTR,  LPCWSTR);
typedef WINUSERAPI LPWSTR  (WINAPI *UAPI_lstrcpyn)				   (LPWSTR,  LPCWSTR, INT);
typedef WINUSERAPI INT     (WINAPI *UAPI_lstrlen)				   (LPCWSTR);
typedef WINUSERAPI INT     (WINAPI *UAPI_lstrcmpi)				   (LPCWSTR, LPCWSTR);

typedef WINUSERAPI BOOL    (WINAPI *UAPI_GetStringTypeEx)          (LCID, DWORD, LPCWSTR, INT, LPWORD);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_CreateMutex)              (LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR);
typedef WINUSERAPI DWORD   (WINAPI *UAPI_GetShortPathName)         (LPCWSTR, LPWSTR, DWORD);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_CreateFile)			   (LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_WriteConsole)			   (HANDLE, CONST VOID*, DWORD, LPDWORD, LPVOID);
typedef WINUSERAPI VOID    (WINAPI *UAPI_OutputDebugString)        (LPCWSTR);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_GetVersionEx)             (LPOSVERSIONINFOW);
typedef WINUSERAPI INT     (WINAPI *UAPI_GetLocaleInfo)            (LCID, LCTYPE, LPWSTR, INT);
typedef WINUSERAPI INT     (WINAPI *UAPI_GetDateFormat)            (LCID, DWORD, CONST SYSTEMTIME*, LPCWSTR, LPWSTR, INT);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_FindFirstFile)            (LPCWSTR, LPWIN32_FIND_DATAW);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_FindNextFile)             (HANDLE, LPWIN32_FIND_DATAW);
typedef WINUSERAPI HMODULE (WINAPI *UAPI_LoadLibraryEx)            (LPCWSTR, HANDLE, DWORD); 
typedef WINUSERAPI HMODULE (WINAPI *UAPI_LoadLibrary)              (LPCWSTR);
typedef WINUSERAPI DWORD   (WINAPI *UAPI_GetModuleFileName)        (HMODULE, LPWSTR, DWORD);
typedef WINUSERAPI HMODULE (WINAPI *UAPI_GetModuleHandle)		   (LPCWSTR);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_CreateEvent)			   (LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCWSTR);
typedef WINUSERAPI DWORD   (WINAPI *UAPI_GetCurrentDirectory)      (DWORD, LPWSTR);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_SetCurrentDirectory)	   (LPCWSTR);

//////////////////////////////
//
// USER32.DLL
//
//////////////////////////////
typedef WINUSERAPI HWND    (WINAPI *UAPI_CreateDialogParam)			(HINSTANCE ,LPCWSTR ,HWND ,DLGPROC ,LPARAM);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_IsDialogMessage)			(HWND, LPMSG);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_SystemParametersInfo)		(UINT, UINT, PVOID, UINT);
typedef WINUSERAPI UINT    (WINAPI *UAPI_RegisterWindowMessage)		(LPCWSTR);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_SetMenuItemInfo)			(HMENU, UINT, BOOL, LPCMENUITEMINFOW);
typedef WINUSERAPI INT	   (WINAPI *UAPI_GetClassName)				(HWND, LPWSTR, INT);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_InsertMenu)				(HMENU, UINT, UINT, UINT, LPCWSTR);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_IsCharAlphaNumeric)		(WCHAR);
typedef WINUSERAPI LPWSTR  (WINAPI *UAPI_CharNext)					(LPCWSTR);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_DeleteFile)				(LPCWSTR);
typedef WINUSERAPI BOOL    (WINAPI *UAPI_IsBadStringPtr)			(LPCWSTR, UINT);
typedef WINUSERAPI HBITMAP (WINAPI *UAPI_LoadBitmap)				(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HCURSOR (WINAPI *UAPI_LoadCursor)				(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HICON   (WINAPI *UAPI_LoadIcon)					(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_LoadImage)					(HINSTANCE, LPCWSTR, UINT, INT, INT, UINT);
typedef WINUSERAPI BOOL	   (WINAPI *UAPI_SetProp)					(HWND, LPCWSTR, HANDLE);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_GetProp)					(HWND, LPCWSTR);
typedef WINUSERAPI HANDLE  (WINAPI *UAPI_RemoveProp)				(HWND, LPCWSTR);
typedef WINUSERAPI UINT	   (WINAPI *UAPI_GetDlgItemText)			(HWND, INT, LPWSTR, INT);
typedef WINUSERAPI BOOL	   (WINAPI *UAPI_SetDlgItemText)			(HWND, INT, LPCWSTR);
typedef WINUSERAPI LONG	   (WINAPI *UAPI_SetWindowLong)				(HWND, INT, LONG);
typedef WINUSERAPI LONG    (WINAPI *UAPI_GetWindowLong)				(HWND, INT);
typedef WINUSERAPI HWND    (WINAPI *UAPI_FindWindow)				(LPCWSTR, LPCWSTR);
typedef WINUSERAPI INT	   (WINAPI *UAPI_DrawText)					(HDC, LPCWSTR, INT, LPRECT, UINT);
typedef WINUSERAPI INT     (WINAPI *UAPI_DrawTextEx)				(HDC, LPWSTR, INT, LPRECT, UINT, LPDRAWTEXTPARAMS);
typedef WINUSERAPI LRESULT (WINAPI *UAPI_SendMessage)				(HWND, UINT, WPARAM, LPARAM )  ;
typedef WINUSERAPI LONG    (WINAPI *UAPI_SendDlgItemMessage)		(HWND, INT, UINT, WPARAM, LPARAM);
typedef WINUSERAPI BOOL	   (WINAPI *UAPI_SetWindowText)				(HWND, LPCWSTR);
typedef WINUSERAPI INT     (WINAPI *UAPI_GetWindowText)				(HWND, LPWSTR, INT);
typedef WINUSERAPI INT     (WINAPI *UAPI_GetWindowTextLength)		(HWND);
typedef WINUSERAPI INT	   (WINAPI *UAPI_LoadString)				(HINSTANCE, UINT, LPWSTR, INT);
typedef WINUSERAPI BOOL	   (WINAPI *UAPI_GetClassInfoEx)			(HINSTANCE, LPCWSTR, LPWNDCLASSEXW);
typedef WINUSERAPI BOOL	   (WINAPI *UAPI_GetClassInfo)				(HINSTANCE, LPCWSTR, LPWNDCLASSW);
typedef WINUSERAPI INT	   (WINAPI *UAPI_wsprintf)					(LPWSTR, LPCWSTR, ... );
typedef WINUSERAPI INT	   (WINAPI *UAPI_wvsprintf)					(LPWSTR, LPCWSTR, va_list );
typedef WINUSERAPI ATOM    (WINAPI *UAPI_RegisterClassEx)			(CONST WNDCLASSEXW*);
typedef WINUSERAPI ATOM    (WINAPI *UAPI_RegisterClass)				(CONST WNDCLASSW*);
typedef WINUSERAPI HWND	   (WINAPI *UAPI_CreateWindowEx)			(DWORD, LPCWSTR, LPCWSTR, DWORD, INT, INT, INT, INT, HWND, HMENU, HINSTANCE, LPVOID);
typedef WINUSERAPI HACCEL  (WINAPI *UAPI_LoadAccelerators)			(HINSTANCE, LPCWSTR);
typedef WINUSERAPI HMENU   (WINAPI *UAPI_LoadMenu)					(HINSTANCE, LPCWSTR);
typedef WINUSERAPI INT     (WINAPI *UAPI_DialogBoxParam)			(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM);
typedef WINUSERAPI LPWSTR  (WINAPI *UAPI_CharUpper)					(LPWSTR);
typedef WINUSERAPI LPWSTR  (WINAPI *UAPI_CharLower)					(LPWSTR);
typedef WINUSERAPI UINT	   (WINAPI *UAPI_GetTempFileName)			(LPCWSTR, LPCWSTR, UINT, LPWSTR);
typedef WINUSERAPI DWORD   (WINAPI *UAPI_GetTempPath)				(DWORD, LPWSTR);
typedef WINUSERAPI INT     (WINAPI *UAPI_CompareString)				(LCID, DWORD, LPCWSTR, INT, LPCWSTR, INT);

//////////////////////////
//
// ADVAPI32.DLL
//
//////////////////////////
typedef WINUSERAPI LONG	   (WINAPI *UAPI_RegQueryInfoKey)			(HKEY, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, LPDWORD, PFILETIME);
typedef WINUSERAPI LONG    (WINAPI *UAPI_RegEnumValue)				(HKEY, DWORD, LPWSTR, LPDWORD, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef WINUSERAPI LONG	   (WINAPI *UAPI_RegQueryValueEx)			(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);
typedef WINUSERAPI LONG    (WINAPI *UAPI_RegEnumKeyEx)				(HKEY, DWORD, LPWSTR, LPDWORD, LPDWORD, LPWSTR, LPDWORD, PFILETIME);
typedef WINUSERAPI LONG	   (WINAPI *UAPI_RegCreateKeyEx)			(HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM, LPSECURITY_ATTRIBUTES, PHKEY, LPDWORD);
typedef WINUSERAPI LONG	   (WINAPI *UAPI_RegSetValueEx)				(HKEY, LPCWSTR, DWORD, DWORD, CONST BYTE*, DWORD);
typedef WINUSERAPI LONG	   (WINAPI *UAPI_RegOpenKeyEx)				(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
typedef WINUSERAPI LONG	   (WINAPI *UAPI_RegDeleteKey)				(HKEY, LPCWSTR);
typedef WINUSERAPI LONG    (WINAPI *UAPI_RegDeleteValue)			(HKEY, LPCWSTR);
//typedef WINUSERAPI (WINAPI *UAPI_)			();


// Special case function pointers for use with the Unicode API
typedef BOOL (WINAPI *UAPI_ConvertMessage)      (HWND, UINT, WPARAM *, LPARAM *) ;
typedef BOOL (WINAPI *UAPI_UpdateUnicodeAPI)    (LANGID, UINT )                  ;               

typedef struct _tagUAPIInit 
{

	//GDI32.DLL
	UAPI_GetTextFace				*pGetTextFaceU;
	UAPI_CreateDC					*pCreateDCU;
	UAPI_GetTextMetrics				*pGetTextMetricsU;
	UAPI_CreateFont					*pCreateFontU;
	UAPI_CreateFontIndirect			*pCreateFontIndirectU;
	UAPI_EnumFontFamilies			*pEnumFontFamiliesU;
	
	//WINMM.DLL	
	UAPI_PlaySound					*pPlaySoundU;

	//SHELL32.DLL
	UAPI_ShellExecute				*pShellExecuteU;

	//COMDLG32.DLL
	UAPI_ChooseFont					*pChooseFontU;

	//KERNEL32.DLL
	UAPI_FindFirstChangeNotification *pFindFirstChangeNotificationU;
	UAPI_GetPrivateProfileString	 *pGetPrivateProfileStringU;
	UAPI_GetProfileString			 *pGetProfileStringU;
	UAPI_CreateFileMapping			 *pCreateFileMappingU;
	UAPI_FormatMessage				*pFormatMessageU;
	UAPI_lstrcmp					*plstrcmpU;
	UAPI_lstrcat					*plstrcatU;
	UAPI_lstrcpy					*plstrcpyU;
	UAPI_lstrcpyn					*plstrcpynU;
	UAPI_lstrlen					*plstrlenU;
	UAPI_lstrcmpi					*plstrcmpiU;

	UAPI_GetStringTypeEx			*pGetStringTypeExU;
	UAPI_CreateMutex				*pCreateMutexU;
	UAPI_GetShortPathName			*pGetShortPathNameU;
	UAPI_CreateFile					*pCreateFileU;
	UAPI_WriteConsole				*pWriteConsoleU;
	UAPI_OutputDebugString			*pOutputDebugStringU;
	UAPI_GetVersionEx				*pGetVersionExU;
	UAPI_GetLocaleInfo				*pGetLocaleInfoU;
	UAPI_GetDateFormat				*pGetDateFormatU;
	UAPI_FindFirstFile				*pFindFirstFileU;
	UAPI_FindNextFile				*pFindNextFileU;
	UAPI_LoadLibraryEx				*pLoadLibraryExU;
	UAPI_LoadLibrary				*pLoadLibraryU;
	UAPI_GetModuleFileName			*pGetModuleFileNameU;
	UAPI_GetModuleHandle			*pGetModuleHandleU;
	UAPI_CreateEvent				*pCreateEventU;
	UAPI_GetCurrentDirectory		*pGetCurrentDirectoryU;
	UAPI_SetCurrentDirectory		*pSetCurrentDirectoryU;
	
	//USER32.DLL
	UAPI_CreateDialogParam			*pCreateDialogParamU;
	UAPI_IsDialogMessage			*pIsDialogMessageU;
	UAPI_SystemParametersInfo		*pSystemParametersInfoU;
	UAPI_RegisterWindowMessage		*pRegisterWindowMessageU;
	UAPI_SetMenuItemInfo			*pSetMenuItemInfoU;
	UAPI_GetClassName				*pGetClassNameU;
	UAPI_InsertMenu					*pInsertMenuU;
	UAPI_IsCharAlphaNumeric			*pIsCharAlphaNumericU;
	UAPI_CharNext					*pCharNextU;
	UAPI_DeleteFile					*pDeleteFileU;
	UAPI_IsBadStringPtr				*pIsBadStringPtrU;
	UAPI_LoadBitmap					*pLoadBitmapU;
	UAPI_LoadCursor					*pLoadCursorU;
	UAPI_LoadIcon					*pLoadIconU;
	UAPI_LoadImage					*pLoadImageU;
	UAPI_SetProp					*pSetPropU;
	UAPI_GetProp					*pGetPropU;
	UAPI_RemoveProp					*pRemovePropU;
	UAPI_GetDlgItemText				*pGetDlgItemTextU;
	UAPI_SetDlgItemText				*pSetDlgItemTextU;
	UAPI_SetWindowLong				*pSetWindowLongU;
	UAPI_GetWindowLong				*pGetWindowLongU;
	UAPI_FindWindow					*pFindWindowU;
	UAPI_DrawText					*pDrawTextU;
	UAPI_DrawTextEx					*pDrawTextExU;
	UAPI_SendMessage				*pSendMessageU;
	UAPI_SendDlgItemMessage			*pSendDlgItemMessageU;
	UAPI_SetWindowText				*pSetWindowTextU;
	UAPI_GetWindowText				*pGetWindowTextU;
	UAPI_GetWindowTextLength		*pGetWindowTextLengthU;
	UAPI_LoadString					*pLoadStringU;
	UAPI_GetClassInfoEx				*pGetClassInfoExU;
	UAPI_GetClassInfo				*pGetClassInfoU;
	UAPI_wvsprintf					*pwvsprintfU;
	UAPI_wsprintf					*pwsprintfU;
	UAPI_RegisterClassEx			*pRegisterClassExU;
	UAPI_RegisterClass				*pRegisterClassU;
	UAPI_CreateWindowEx				*pCreateWindowExU;
	UAPI_LoadAccelerators			*pLoadAcceleratorsU;
	UAPI_LoadMenu					*pLoadMenuU;
	UAPI_DialogBoxParam				*pDialogBoxParamU;
	UAPI_CharUpper					*pCharUpperU;
	UAPI_CharLower					*pCharLowerU;
	UAPI_GetTempFileName			*pGetTempFileNameU;
	UAPI_GetTempPath				*pGetTempPathU;
	UAPI_CompareString				*pCompareStringU;


	//ADVAPI32.DLL
	UAPI_RegQueryInfoKey			*pRegQueryInfoKeyU;
	UAPI_RegEnumValue				*pRegEnumValueU;
	UAPI_RegQueryValueEx			*pRegQueryValueExU;
	UAPI_RegEnumKeyEx				*pRegEnumKeyExU;
	UAPI_RegSetValueEx				*pRegSetValueExU;
	UAPI_RegCreateKeyEx             *pRegCreateKeyExU;
	UAPI_RegOpenKeyEx				*pRegOpenKeyExU;
	UAPI_RegDeleteKey				*pRegDeleteKeyU;
	UAPI_RegDeleteValue				*pRegDeleteValueU;
	  
    UAPI_ConvertMessage				*pConvertMessage ;
    UAPI_UpdateUnicodeAPI			*pUpdateUnicodeAPI ;

    int								nCount;

} UAPIINIT, *PUAPIINIT ;

BOOL InitUniAnsi(PUAPIINIT) ;

// Macro to get scan code on WM_CHAR
#ifdef _DEBUG
#define LPARAM_TOSCANCODE(_ArglParam) (((_ArglParam) >> 16) & 0x000000FF)
#endif

#endif /* _UNIANSI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\user_prefix.h ===
#ifndef _USER_PREFIX_H
#define _USER_PREFIX_H

//
// be sure to keep both groups in sync !!!
//


//
// single character versions of prefixes
//
#define gcRootGroupNamePrefix                    '.'
#define gcSysopGroupNamePrefix                   '+'
#define gcMvpGroupNamePrefix                     '*'
#define gcSupportGroupNamePrefix                 '?'
#define gcHostGroupNamePrefix                    '%'
#define gcGreeterGroupNamePrefix                 '!'

//
// string versions of prefixes
//
#define zRootGroupNamePrefix                     "."
#define zSysopGroupNamePrefix                    "+"
#define zMvpGroupNamePrefix                      "*"
#define zSupportGroupNamePrefix                  "?"
#define zHostGroupNamePrefix                     "%"
#define zGreeterGroupNamePrefix                  "!"


/* -------- Group IDs -------- */
enum
{
	zUserGroupID = 0,
	zRootGroupID = 1,
	zSysOpGroupID = 2,
    zSysopGroupID = 2,
    zMvpGroupID  = 3,
    zSupportGroupID = 4,
    zHostGroupID = 5,
    zGreeterGroupID = 6,
    zLastGroupID
};

static const char* gGroupNamePrefixArray[] =
    {
        "",
        zRootGroupNamePrefix,
        zSysopGroupNamePrefix,
        zMvpGroupNamePrefix,
        zSupportGroupNamePrefix,
        zHostGroupNamePrefix,
        zGreeterGroupNamePrefix
    };


#endif  //ndef _USER_PREFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zgame.h ===
/*******************************************************************************

	ZGame.h
	
		Game client/server stuff for Zone(tm).
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on November, 28, 1995 
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		11/28/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZGAME_
#define _ZGAME_

//constants
enum
{
    // -------- Game Options -------- 
    zGameOptionsComputerPlayerAvail		= 0x00000001,
    zGameOptionsKibitzerAllowed			= 0x00000002,
    zGameOptionsJoiningAllowed			= 0x00000004,
    zGameOptionsRequiresFullTable		= 0x00000008,
    zGameOptionsChatEnabled				= 0x00000010,
    zGameOptionsOpenLobby				= 0x00000020,
    zGameOptionsHostMigration			= 0x00000040,
    zGameOptionsRatingsAvailable		= 0x00000080,
    zGameOptionsTheater					= 0x00000100,
    zGameOptionsGagUserOnEnter			= 0x00000200,
    zGameOptionsReservedSeatsAvail		= 0x00000400,
    zGameOptionsTournament        		= 0x00000800,
	zGameOptionsStaticChat				= 0x00001000,
	zGameOptionsDynamicChat				= 0x00002000,
	zGameOptionsNoSuspend				= 0x00004000,
};

#define zRoomAllPlayers					0
#define zRoomAllSeats					(-1)
#define zRoomToPlayer					(-2)
#define zRoomToRoom                     (-3)

/* --------- Messages --------- */
enum
{
	zGameMsgCheckIn = 1024,
	zGameMsgReplacePlayer,
	zGameMsgTableOptions,
	zGameMsgGameStateRequest,
	zGameMsgGameStateResponse
};


/* -------- Game Message Structures -------- */

typedef struct
{
	uint32			protocolSignature;
	uint32			protocolVersion;
	uint32			clientVersion;
	ZUserID			playerID;
	int16			seat;
	int16			playerType;
} ZGameMsgCheckIn;


typedef struct
{
	ZUserID			playerID;
	int16			seat;
} ZGameMsgReplacePlayer;


typedef struct
{
	int16			seat;
	int16			rfu;
	uint32			options;
} ZGameMsgTableOptions;


typedef struct
{
	ZUserID			playerID;
	int16			seat;
	int16			rfu;
} ZGameMsgGameStateRequest;

typedef struct
{
	ZUserID			playerID;
	int16			seat;
	int16			rfu;
	/*
		game states ...
	*/
} ZGameMsgGameStateResponse;


#ifdef __cplusplus
extern "C" {
#endif

/* -------- Endian Conversion Routines -------- */
void ZGameMsgCheckInEndian(ZGameMsgCheckIn* msg);
void ZGameMsgReplacePlayerEndian(ZGameMsgReplacePlayer* msg);
void ZGameMsgTableOptionsEndian(ZGameMsgTableOptions* msg);
void ZGameMsgGameStateRequestEndian(ZGameMsgGameStateRequest* msg);
void ZGameMsgGameStateResponseEndian(ZGameMsgGameStateResponse* msg);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zdef.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1996                **/
/**********************************************************************/

/*
    zdef.h

    This file contains constants & type definitions shared between the
    Zone Service, Installer, and Administration UI.


    FILE HISTORY:
        craigli      3-Sep-1996 Created.

*/


#ifndef _ZDEF_H_
#define _ZDEF_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus

#if !defined(MIDL_PASS)
//#include <winsock2.h>
#endif


//
//  structure Field Control defines
//

typedef DWORD FIELD_CONTROL;
typedef DWORD FIELD_FLAG;

//
//  Returns TRUE if the field specified by bitFlag is set
//

#define IsFieldSet(fc, bitFlag) \
    (((FIELD_CONTROL)(fc) & (FIELD_FLAG)(bitFlag)) != 0)

//
//  Indicates the field specified by bitFlag contains a valid value
//

#define SetField(fc, bitFlag) \
    ((FIELD_CONTROL)(fc) |= (FIELD_FLAG)(bitFlag))

//
//  Simple macro that sets the ith bit
//

#define BitFlag(i)                    ((0x1) << (i))



#define ZONE_SERVICE_NAME_A "Zone"
#define ZONE_SERVICE_NAME_W L"Zone"

//
//  Configuration parameters registry key.
//
# define ZONE_SERVICE_KEY_A  \
  "System\\CurrentControlSet\\Services\\" ## ZONE_SERVICE_NAME_A

# define ZONE_SERVICE_KEY_W \
  L"System\\CurrentControlSet\\Services\\" ## ZONE_SERVICE_NAME_W

#define ZONE_PARAMETERS_KEY_A   ZONE_SERVICE_KEY_A ## "\\Parameters"

#define ZONE_PARAMETERS_KEY_W   ZONE_SERVICE_KEY_W ## L"\\Parameters"


//
//  Performance key.
//

#define ZONE_PERFORMANCE_KEY_A  ZONE_SERVICE_KEY_A ## "\\Performance"

#define ZONE_PERFORMANCE_KEY_W  ZONE_SERVICE_KEY_W ## L"\\Performance"


//
//  If this registry key exists under the Parameters key,
//  it is used to validate FTPSVC access.  Basically, all new users
//  must have sufficient privilege to open this key before they
//  may access the FTP Server.
//



//
//  Configuration value names.
//

#define ZONE_LISTEN_BACKLOG_A            "ListenBacklog"
#define ZONE_LISTEN_BACKLOG_W           L"ListenBacklog"


//
//  Handle ANSI/UNICODE sensitivity.
//

#ifdef UNICODE

#define ZONE_SERVICE_NAME               ZONE_SERVICE_NAME_W
#define ZONE_PARAMETERS_KEY             ZONE_PARAMETERS_KEY_W
#define ZONE_PERFORMANCE_KEY            ZONE_PERFORMANCE_KEY_W
#define ZONE_LISTEN_BACKLOG             ZONE_LISTEN_BACKLOG_W
#define ZONE_INTERFACE_NAME             ZONE_SERVICE_NAME
#define ZONE_NAMED_PIPE_W       L"\\PIPE\\" ## ZONE_SERVICE_NAME_W

#else   // !UNICODE

#define ZONE_SERVICE_NAME               ZONE_SERVICE_NAME_A
#define ZONE_PARAMETERS_KEY             ZONE_PARAMETERS_KEY_A
#define ZONE_PERFORMANCE_KEY            ZONE_PERFORMANCE_KEY_A
#define ZONE_LISTEN_BACKLOG             ZONE_LISTEN_BACKLOG_A
#define ZONE_INTERFACE_NAME             ZONE_SERVICE_NAME
#define ZONE_NAMED_PIPE         TEXT("\\PIPE\\") ## ZONE_INTERFACE_NAME


#endif  // UNICODE



//
// Structures for APIs
//

typedef struct _ZONE_USER_INFO
{
    DWORD    idUser;          //  User id
    LPSTR    pszUser;         //  User name
    DWORD    inetHost;        //  Host Address
	DWORD    timeOn;        //  Time logged on for in s
} ZONE_USER_INFO, * LPZONE_USER_INFO;

typedef struct _ZONE_USER_ENUM_STRUCT {
    DWORD   EntriesRead;
#if defined(MIDL_PASS)
    [size_is(EntriesRead)] 
#endif // defined(MIDL_PASS)
    LPZONE_USER_INFO Buffer;
} ZONE_USER_ENUM_STRUCT, *LPZONE_USER_ENUM_STRUCT;


#define ZONE_STAT_TYPE_NET       0
#define ZONE_STAT_TYPE_VILLAGE   1
#define ZONE_STAT_TYPE_ROOM      2
#define ZONE_STAT_TYPE_GAME      2  // old types
#define ZONE_STAT_TYPE_LOBBY     3  // old types
#define ZONE_STAT_TYPE_ZONEDS    10
#define ZONE_STAT_TYPE_DOSSIER	 11


typedef struct _ZONE_STATISTICS_NET
{
    LARGE_INTEGER TotalBytesSent;
    LARGE_INTEGER TotalBytesReceived;
    LARGE_INTEGER TotalConnects;
    LARGE_INTEGER TotalDisconnects;
    LARGE_INTEGER ConnectionAttempts;
    LARGE_INTEGER BadlyFormedPackets;
    LARGE_INTEGER TotalDroppedConnections;
    LARGE_INTEGER TotalReadAPCs;
    LARGE_INTEGER TotalReadAPCsCompleted;
    LARGE_INTEGER TotalWriteAPCs;
    LARGE_INTEGER TotalWriteAPCsCompleted;
    LARGE_INTEGER TotalUserAPCs;
    LARGE_INTEGER TotalUserAPCsCompleted;
    LARGE_INTEGER TotalBlockingSends;
    LARGE_INTEGER TotalBytesAllocated;
    LARGE_INTEGER TotalTicksAPC;
    LARGE_INTEGER TotalTicksAccept;
    LARGE_INTEGER TotalTicksRead;
    LARGE_INTEGER TotalTicksWrite;
    LARGE_INTEGER TotalTicksTimeouts;
    LARGE_INTEGER TotalTicksKeepAlives;
    LARGE_INTEGER TotalTicksExecuting;
    LARGE_INTEGER TotalQueuedConSSPI;
    LARGE_INTEGER TotalQueuedConSSPICompleted;
    LARGE_INTEGER TotalQueuedConSSPITicks;
    LARGE_INTEGER TotalGenerateContexts;
    LARGE_INTEGER TotalGenerateContextsTicks;
    DWORD         CurrentConnections;
    DWORD         MaxConnections;
    DWORD         CurrentBytesAllocated;
    FILETIME      TimeOfLastClear;

} ZONE_STATISTICS_NET, * LPZONE_STATISTICS_NET;

typedef struct _ZONE_STATISTICS_ROOM
{
    ZONE_STATISTICS_NET NetStats;
    LARGE_INTEGER TotalPlayersEntering;
    LARGE_INTEGER TotalPlayersLeaving;
    LARGE_INTEGER TotalGamesServed;
    LARGE_INTEGER TotalGamePlayers;
    LARGE_INTEGER TotalGamePlayTime;
    LARGE_INTEGER TotalConnectTime;
    LARGE_INTEGER TotalChatMessagesRecv;
    LARGE_INTEGER TotalChatMessagesSent;
    LARGE_INTEGER TotalChatBytesRecv;
    LARGE_INTEGER TotalChatBytesSent;
    LARGE_INTEGER TotalGameMessagesRecv;
    LARGE_INTEGER TotalGameMessagesSent;
    LARGE_INTEGER TotalGameBytesRecv;
    LARGE_INTEGER TotalGameBytesSent;
    DWORD         PlayersInRoom;
    DWORD         PlayersAtATable;
    DWORD         PlayersKibitzing;
    DWORD         ActiveGames;
    FILETIME      TimeOfLastClear;
} ZONE_STATISTICS_ROOM, * LPZONE_STATISTICS_ROOM;


typedef struct _ZONE_STATISTICS_ZONEDS
{
    ZONE_STATISTICS_NET NetStats;

    // connserver thread start
    LARGE_INTEGER TotalConnectTime;
    LARGE_INTEGER TotalDisconnectedUsers;    // used to compute average connect time
                                             // connect time / disconnected users

    LARGE_INTEGER TotalZoneDSMsgs;
    LARGE_INTEGER TotalClientMsgs;      // currently not implemented
    LARGE_INTEGER TotalConnectMsgs;
    LARGE_INTEGER TotalDisconnectMsgs;
    LARGE_INTEGER TotalStateMsgs;
    LARGE_INTEGER TotalStateMsgsSent;
    LARGE_INTEGER TotalListMsgs;        // currently not implemented
    LARGE_INTEGER TotalWatchMsgs;
    LARGE_INTEGER TotalFilterMsgs;
    LARGE_INTEGER TotalFilterTypeMsgs;
    LARGE_INTEGER TotalDataMsgs;
    LARGE_INTEGER TotalDataBytes;
    LARGE_INTEGER TotalDataMsgsSent;
    LARGE_INTEGER TotalErrorMsgs;

    LARGE_INTEGER TotalConnectionServerEntries;
    // connserver thread end

    // name server thread start
    LARGE_INTEGER TotalNameServerEntries;
    LARGE_INTEGER TotalStateChanges;

    LARGE_INTEGER TotalDBGetUserID;
    LARGE_INTEGER TotalDBAddUserIDToDB;
    // name server thread end

    // db thread start
    LARGE_INTEGER TotalDBGetUserIDCompleted;
    LARGE_INTEGER TotalDBGetUserIDInvalid;
    LARGE_INTEGER TotalDBAddUserIDToDBCompleted;

    LARGE_INTEGER TotalLRUHits;
    LARGE_INTEGER TotalLRUMisses;
    // db thread end


    DWORD         CurConnectionServerEntries;   // entries in connection hash

    DWORD         CurNameServerEntries;         // entries in nameserver hash - not necessarily registered

    DWORD         CurLRUEntries;
    DWORD         CurInvalidLRUEntries;

    DWORD         CurRegisteredUsers;

    DWORD         CurStateOnlineUsers;       // state of connected users
    DWORD         CurStateOfflineUsers;
    DWORD         CurStateBusyUsers;
    DWORD         CurStateAwayUsers;

    DWORD         CurWatches;                // total number of watches going on
    DWORD         CurWatchedUsers;
    DWORD         CurWatchedUsersRefCount;
    DWORD         CurWatchingUsers;

    DWORD         CurFilteringUsers;
    DWORD         CurFilteredUsersRefCount;

    DWORD         CurFilterTypeGrant;
    DWORD         CurFilterTypeDeny;
    DWORD         CurFilterTypeNone;
    DWORD         CurFilterTypeAll;


    FILETIME      TimeOfLastClear;
} ZONE_STATISTICS_ZONEDS, * LPZONE_STATISTICS_ZONEDS;


typedef struct _ZONE_STATISTICS_DOSSIER
{
	ZONE_STATISTICS_NET NetStats;
	LARGE_INTEGER	TotalMessages;				// messages received
	LARGE_INTEGER	TotalPlayers;				// number of players sent through the system
	LARGE_INTEGER	TotalPlayerContention;		// number of loops spent waiting for a player
	DWORD			CurCacheHits;				// number of cache hits
	DWORD			CurCacheLookups;			// number of cache lookups
	DWORD			CurQueuedMessages;
	FILETIME		TimeOfLastClear;
} ZONE_STATISTICS_DOSSIER, * LPZONE_STATISTICS_DOSSIER;


typedef struct _ZONE_GAME_INFO
{
	long	gameID;
	long	gameAddr;
	short	gamePort;
	short	gameState;
	long	gameVersion; //@field Version of game determined by game
	long  numPlayers;  //@field number of players in game
	long  numGamesServed;  //@field number of games served
	byte    serviceType; //@field either Zone game or lobby for now
} ZONE_GAME_INFO, * LPZONE_GAME_INFO;



#define ZONE_SERVICE_TYPE_UNKNOWN       -1
#define ZONE_SERVICE_TYPE_NONE           0
#define ZONE_SERVICE_TYPE_VILLAGE        1
#define ZONE_SERVICE_TYPE_ROOM           2
#define ZONE_SERVICE_TYPE_GAME           2
#define ZONE_SERVICE_TYPE_LOBBY          3
#define ZONE_SERVICE_TYPE_FIGHTER_ACE    4
#define ZONE_SERVICE_TYPE_LOGGING        5
#define ZONE_SERVICE_TYPE_BILLING        6
#define ZONE_SERVICE_TYPE_2NI_RPG        7
#define ZONE_SERVICE_TYPE_GAMEINFO       8
#define ZONE_SERVICE_TYPE_DWANGO         9
#define ZONE_SERVICE_TYPE_ZONEDS         10
#define ZONE_SERVICE_TYPE_DOSSIER		 11


typedef struct _ZONE_SERVICE_INFO
{
    DWORD type;
    LPSTR pszDisplayName;
} ZONE_SERVICE_INFO, * LPZONE_SERVICE_INFO;




//
//  Manifests for APIs.
//

#define FC_ZONE_LISTEN_BACKLOG           ((FIELD_CONTROL)BitFlag( 0))

#define FC_ZONE_ALL                      (                                 \
                                          FC_ZONE_LISTEN_BACKLOG         | \
                                          0 )


//
//  Structures for APIs.
//



//
// API Prototypes
//
LPBYTE
ZoneAllocBuffer( 
    IN size_t size 
    );

DWORD
ZoneFreeBuffer(
    IN  LPBYTE pBuffer
    );


DWORD
ZoneGetUserCount(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    OUT LPDWORD  lpdwUserCount
    );

DWORD
ZoneEnumerateUsers(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    OUT LPDWORD  lpdwEntriesRead,
    OUT LPZONE_USER_INFO * pBuffer
    );

DWORD
ZoneDisconnectUser(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    IN  DWORD   idUser
    );

DWORD
ZoneDisconnectUserName(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    IN  LPSTR   pszUserName
    );

DWORD
ZoneRoomBroadcastMessage(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    IN  LPSTR   pszMessage
    );


DWORD
ZoneQueryStatistics(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    IN  DWORD   Type,
    OUT LPBYTE * Buffer
    );

DWORD
ZoneClearStatistics(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService
    );


DWORD
ZoneGetServiceInfo(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    OUT LPZONE_SERVICE_INFO * ppInfo
    );


DWORD
ZoneGameInfo(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    IN  LPSTR   pszName,
    OUT LPZONE_GAME_INFO pInfo
    );


DWORD
ZoneServiceStop(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService
    );

DWORD
ZoneServicePause(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService
    );

DWORD
ZoneServiceContinue(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService
    );

DWORD
ZoneFlushUserFromCache(
    IN  LPSTR   pszServer,
    IN  LPSTR   pszService,
    IN  LPSTR   pszUser
    );




#ifdef __cplusplus
}
#endif  // _cplusplus


#endif  // _ZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\userprefix.h ===
#ifndef _USER_PREFIX_H
#define _USER_PREFIX_H

//
// be sure to keep both groups in sync !!!
//


//
// single character versions of prefixes
//
#define gcRootGroupNamePrefix                    '.'
#define gcSysopGroupNamePrefix                   '+'
#define gcMvpGroupNamePrefix                     '*'
#define gcSupportGroupNamePrefix                 '?'
#define gcHostGroupNamePrefix                    '%'
#define gcGreeterGroupNamePrefix                 '!'

//
// string versions of prefixes
//
#define zRootGroupNamePrefix                     "."
#define zSysopGroupNamePrefix                    "+"
#define zMvpGroupNamePrefix                      "*"
#define zSupportGroupNamePrefix                  "?"
#define zHostGroupNamePrefix                     "%"
#define zGreeterGroupNamePrefix                  "!"


/* -------- Group IDs -------- */
enum
{
	zUserGroupID		= 0,
	zRootGroupID		= 1,
	zSysOpGroupID		= 2,
    zSysopGroupID		= 2,
    zMvpGroupID			= 3,
    zSupportGroupID		= 4,
    zHostGroupID		= 5,
    zGreeterGroupID		= 6,
    zLastGroupID
};

static const char* gGroupNamePrefixArray[] =
{
    "",
    zRootGroupNamePrefix,
    zSysopGroupNamePrefix,
    zMvpGroupNamePrefix,
    zSupportGroupNamePrefix,
    zHostGroupNamePrefix,
    zGreeterGroupNamePrefix
};


#endif  //ndef _USER_PREFIX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zgameinfo.h ===
#ifndef __GAMEINFO_H
#define __GAMEINFO_H

#include "ztypes.h"

#ifdef __cplusplus
extern "C" {
#endif

// @doc ZGAMEINFO

// @module ZGAMEINFO.H - Zone Platform GameInfo Protocol |

// Defines protocol and functions for sending game information like
// TPC/IP address and port and game type to client applications. 
// like admin tools and game clients. The game info is how applications 
// are aware of game servers that are running.
//
// Packets are not encrypted because they will be staying in data center.
//
// Copyright (c)1996,97 Microsoft Corporation, All Rights Reserved
//
// @index | ZGAMEINFO
//
// @normal Created by Craig Link, John Smith


#define GAMEINFO_SERVICE_NAME_LEN      31
#define GAMEINFO_INTERNAL_NAME_LEN     15
#define GAMEINFO_ROOM_DESCRIPTION_LEN  31
#define GAMEINFO_SETUP_TOKEN_LEN       63
#define GAMEINFO_FRIENDLY_NAME_LEN     63 // zGameNameLen

#define zGameInfoCurrentProtocolVersion 6

#define    zGameInfoSignature        'guis'

// @enum zGameState | Possible states of game used in structure 
// ZGameServerInfoMsg which is sent via <f ZGameInfoSendTo>
//
enum
{
    zGameStateInit = 0,    //@emem Initializing
    zGameStateActive,      //@emem Game running ok
    zGameStateFull,        //@emem Game cannot accept more connections
    zGameStatePaused       //@emem Game server is paused
};

#define GAMEINFO_SERVICE_TYPE_GAME        2
#define GAMEINFO_SERVICE_TYPE_LOBBY       3
#define GAMEINFO_SERVICE_TYPE_FIGHTER_ACE 4
#define GAMEINFO_SERVICE_TYPE_LOGGING     5
#define GAMEINFO_SERVICE_TYPE_BILLING     6
#define GAMEINFO_SERVICE_TYPE_2NI_RPG     7
#define GAMEINFO_SERVICE_TYPE_GAMEINFO    8
#define GAMEINFO_SERVICE_TYPE_DWANGO      9
#define GAMEINFO_SERVICE_TYPE_ZONEDS      10
#define GAMEINFO_SERVICE_TYPE_DOSSIER     11




// @struct ZGameInstanceInfoMsg | This structure contains
// information to determine the status of Zone application
//
// @comm Member of <t ZGameServerInfoMsg>
//
// @xref <f ZGameInfoSendTo >

typedef struct
{
    uint32  gameAddr;        //@field IP Address of game
    uint16  gamePort;        //@field IP port of game
    uint16  serviceType;     //@field GAMEINFO_SERVICE_TYPE constant value from above
    byte    order;           //@field order to return list of similar games in ascending order
    byte    gameState;       //@field State of game <t zGameState>
    uint32  gameVersion;     //@field Version of game determined by game
    uint32  numPlayers;      //@field number of players in game
    uint32  numGamesServed;  //@field number of games served
    uint16  numTables;       //@field number of tables in lobby
    uint16  numTablesInUse;  //@field number of occupied tables
    char    gameInternalName[GAMEINFO_INTERNAL_NAME_LEN + 1]; //@field Name of game internal to Zone
    char    gameFriendlyName[GAMEINFO_FRIENDLY_NAME_LEN + 1]; //@field Name of game for users
    char    gameRoomDescription[GAMEINFO_ROOM_DESCRIPTION_LEN + 1]; //@field Name of game for users
    char    setupToken[GAMEINFO_SETUP_TOKEN_LEN + 1]; //@field Token used for controlling setup from lobby
    uint16  blobsize;        //@field  size of opaque data blob immediately following message
    uint32  maxPopulation;   //@field  Maximum room population
    uint32  numNotPlaying;   //@field  Number of people in lobby but not playing
    uint32  numSysops;       //@field  Number of sysops in lobby
    FILETIME timeGameStart;
    uint32  timestamp;       //@field  Time packet was sent.  used only by the receiving side
} ZGameInstanceInfoMsg;



// @struct ZGameServerInfoMsg | This structure contains
// information to determine the status of Zone application
//
// @field uint32 | protocolSignature | The string 'guis' which
// helps filter out packets to UDP port from invalid applications.
//
// @field uint32 | protocolVersion | Currently one. Used when
// there is a change in the structure
//
// @field uint32 | numEntries | number of ZGameInstanceInfoMsg entries
//
// @field ZGameInstanceInfoMsg[] | info | array of entries
//
//
// @comm Used in the call to <f ZGameInfoSendTo> 
//
// @xref <f ZGameInfoSendTo >

typedef struct {
    uint32  protocolSignature;
    uint32  protocolVersion;
    uint16  numEntries;
    ZGameInstanceInfoMsg info[1];
} ZGameServerInfoMsg;






// @func int | ZGameInfoInit | This function creates a UDP socket
// that is used by subsequent calls to <f ZGameInfoSendTo> to send updates 
// of GameInfo on.
int ZGameInfoInit(uint16 port);
//
// @parm uint16 | port | Port on receiving machine 
// which calls to <f ZGameInfoSendTo> will send to. To prevent local bind
// on this port which would prevent a local send.
//
// @rdesc Returns one of the following values:
//
// @flag -1 | If init fails it is because of Winsock having a problem
// binding to a local port which is extremely unlikely because API
// searches UDP port space from 10000 to 65536 for a port. Of course this
// may take some time of a lot of UDP ports are used.
//
// @comm This API should only be called once per process
// because it doesn't use a handle and therefore is using a
// global variable to track socket between calls to <f ZGameInfoClose>
// and <f ZGameInfoSendTo>. If called a second time the socket and send to
// port address will be reinitialized.
//
// @xref <f ZGameInfoClose>, <f ZGameInfoSendTo>



// @func int | ZGameInfoClose | This function destroys the UDP socket
// created by <f ZGameInfoInit> 
int ZGameInfoClose();
//
// @rdesc Returns one of the following values:
//
// @flag -1 | If close fails it is because <f ZGameInfoInit> was never
// called.
//



// @func int | ZGameInfoSendTo | This function destroys the UDP socket
// created by <f ZGameInfoInit> 

int ZGameInfoSendTo(
    uint32 addr, //@parm addr on receiving machine could be INADDR_BROADCAST
    uint16 port, //@parm port on receiving machine
    ZGameServerInfoMsg* msg,  //@parm <t ZGameServerInfoMsg> pointer
    uint16 size ); //@parm num of ZGameServerInfoMsgs

// @rdesc Return values are the same as Winsock sendto
//
// @comm This function should only be used every 15 sec or so to avoid
// eating up cycles on sending or receiving machine. Think about
// how often receiving machines really need the data. Note that 
// Pentium 133Mhz machines can handle 3000 - 6000 packets/sec on Ethernet.



// @func int | ZGameServerInfoMsgEndian | This function changes
// the <t ZGameServerInfoMsg> structure to Zone network byte ordering. 
void ZGameServerInfoMsgEndian(ZGameServerInfoMsg* msg);
//
// @parm ZGameServerInfoMsg *| msg | Pointer to a <t ZGameServerInfoMsg>.
//
// @comm To be used before calling <f ZGameInfoSendTo>

// @func int | ZGameInstanceInfoMsgEndian | This function changes
// the <t ZGameInstanceInfoMsg> structure to Zone network byte ordering.
void ZGameInstanceInfoMsgEndian(ZGameInstanceInfoMsg* msg);
//
// @parm ZGameInstanceInfoMsg *| msg | Pointer to a <t ZGameInstanceInfoMsg>.
//
// @comm To be used before calling <f ZGameInfoSendTo>


#define GAMEINFO_SERVICE_NAME_LEN_Z2  30
#define GAMEINFO_INTERNAL_NAME_LEN_Z2 30
#define GAMEINFO_FRIENDLY_NAME_LEN_Z2 63 // zGameNameLen

typedef struct {
    uint32    protocolSignature;
    uint32    protocolVersion;        /* Protocol version */
    uint32    gameID;
    uint32    gameAddr;
    uint16    gamePort;
    uint16    gameState;
    uint32    gameVersion; //@field Version of game determined by game
    uint32  numPlayers;  //@field number of players in game
    uint32  numGamesServed;  //@field number of games served
    byte    serviceType; //@field either Zone game or lobby for now
    char    gameServiceName[GAMEINFO_SERVICE_NAME_LEN_Z2 + 1]; //@field Service name of game machine
    char    gameInternalName[GAMEINFO_INTERNAL_NAME_LEN_Z2 + 1]; //@field Name of game internal to Zone
    char    gameFriendlyName[GAMEINFO_FRIENDLY_NAME_LEN_Z2 + 1]; //@field Name of game for users
    uint32  timestamp;              //@field  Time packet was sent used only by the receiving side
    
} ZGameServerInfoMsgZ2;
#define zGameInfoProtocolVersionZ2 2

// @func int | ZGameInstanceInfoMsgZ2Endian | This function changes
// the <t ZGameInstanceInfoMsg> structure to Zone network byte ordering.
void ZGameServerInfoMsgZ2Endian(ZGameServerInfoMsgZ2* msg);
//
// @parm ZGameServerInfoMsgZ2* msg *| msg | Pointer to a <t ZGameServerInfoMsgZ2>.
//
// @comm To be used before calling <f ZGameInfoSendTo>


#define GAMEINFO_INTERNAL_NAME_LEN_Z3     31

////////////////
//
// Z3 Structures
//
typedef struct
{
    uint32  gameAddr;        //@field IP Address of game
    uint16  gamePort;        //@field IP port of game
    uint16  serviceType;     //@field GAMEINFO_SERVICE_TYPE constant value from above
    byte    order;           //@field order to return list of similar games in ascending order
    byte    gameState;       //@field State of game <t zGameState>
    uint32  gameVersion;     //@field Version of game determined by game
    uint32  numPlayers;      //@field number of players in game
    uint32  numGamesServed;  //@field number of games served
    char    gameServiceName[GAMEINFO_SERVICE_NAME_LEN + 1];   //@field Service name of game machine
    char    gameInternalName[GAMEINFO_INTERNAL_NAME_LEN_Z3 + 1]; //@field Name of game internal to Zone
    char    gameFriendlyName[GAMEINFO_FRIENDLY_NAME_LEN + 1]; //@field Name of game for users
    uint32  timestamp;       //@field  Time packet was sent.  used only by the receiving side
} ZGameInstanceInfoMsgZ3;
#define zGameInfoProtocolVersionZ3 4

// @func int | ZGameInstanceInfoMsgZ2Endian | This function changes
// the <t ZGameInstanceInfoMsg> structure to Zone network byte ordering.
void ZGameInstanceInfoMsgZ3Endian(ZGameInstanceInfoMsgZ3* msg);
//
// @parm ZGameInstanceInfoMsgZ3* msg *| msg | Pointer to a <t ZGameInstanceInfoMsgZ3>.
//
// @comm To be used before calling <f ZGameInfoSendTo>


typedef struct {
    uint32  protocolSignature;
    uint32  protocolVersion;
    uint16  numEntries;
    ZGameInstanceInfoMsgZ3 info[1];
} ZGameServerInfoMsgZ3;


/////////////
//
// Z4 & Z5 structures
//

#define GAMEINFO_SETUP_TOKEN_LEN_Z5 31

typedef struct
{
    uint32  gameAddr;        //@field IP Address of game
    uint16  gamePort;        //@field IP port of game
    uint16  serviceType;     //@field GAMEINFO_SERVICE_TYPE constant value from above
    byte    order;           //@field order to return list of similar games in ascending order
    byte    gameState;       //@field State of game <t zGameState>
    uint32  gameVersion;     //@field Version of game determined by game
    uint32  numPlayers;      //@field number of players in game
    uint32  numGamesServed;  //@field number of games served
    uint16  numTables;       //@field number of tables in lobby
    uint16  numTablesInUse;  //@field number of occupied tables
    char    gameInternalName[GAMEINFO_INTERNAL_NAME_LEN_Z3 + 1]; //@field Name of game internal to Zone
    char    gameFriendlyName[GAMEINFO_FRIENDLY_NAME_LEN + 1]; //@field Name of game for users
    char    gameRoomDescription[GAMEINFO_ROOM_DESCRIPTION_LEN + 1]; //@field Name of game for users
    char    setupToken[GAMEINFO_SETUP_TOKEN_LEN_Z5 + 1]; //@field Token used for controlling setup from lobby
    uint16  blobsize;        //@field  size of opaque data blob immediately following message
    uint32  maxPopulation;   //@field  Maximum room population
    uint32  numNotPlaying;   //@field  Number of people in lobby but not playing
    uint32  numSysops;       //@field  Number of sysops in lobby
    FILETIME timeGameStart;
    uint32  timestamp;       //@field  Time packet was sent.  used only by the receiving side
} ZGameInstanceInfoMsgZ5;
#define zGameInfoProtocolVersionZ5 5

// @func int | ZGameInstanceInfoMsgZ5Endian | This function changes
// the <t ZGameInstanceInfoMsg> structure to Zone network byte ordering.
void ZGameInstanceInfoMsgZ5Endian(ZGameInstanceInfoMsgZ5* msg);
//
// @parm ZGameInstanceInfoMsgZ5* msg *| msg | Pointer to a <t ZGameInstanceInfoMsgZ5>.
//
// @comm To be used before calling <f ZGameInfoSendTo>



#ifdef __cplusplus
}
#endif

#endif //__GAMEINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

#include <windows.h>
#include "zonedebug.h"
//
// String and character manipulation
//

inline int StringCopy( char* dst, const char* src, int dstlen )
{
    char* end = dst + dstlen - 1;
    char* c = dst; 
    
    while (*src && (c < end))
        *c++ = *src++;
    *c = '\0';
    return c - dst;
}

inline BOOL IsNumeric( char c )
{
    if ((c >= '0') && (c <= '9'))
        return TRUE;
    else
        return FALSE;
}


inline BOOL IsSpace( char c )
{
    if ((c == ' ' ) || (c == '\t') || (c == '\n') || (c == '\r'))
        return TRUE;
    else
        return FALSE;
}

//
// Critical section wrapper
//

class CCriticalSection
{
private:
    CRITICAL_SECTION    m_CriticalSection;

public:
    CCriticalSection()        { InitializeCriticalSection( &m_CriticalSection ); }
    ~CCriticalSection()        { DeleteCriticalSection( &m_CriticalSection ); }

    void Lock()                { EnterCriticalSection( &m_CriticalSection ); }
    void Unlock()            { LeaveCriticalSection( &m_CriticalSection ); }

#if 0  // VC41 doesn't support this
#if (_WIN32_WINNT >= 0x0400)

    BOOL TryLock()            { return TryEnterCriticalSection( &m_CriticalSection ); }

#endif //_WIN32_WINNT
#endif // 0
};


class CReadWriteLock
{
private:
    CCriticalSection    m_Lock;
    HANDLE              m_ReaderKick;
    long                m_NumReaders;

public:

    CReadWriteLock() : m_ReaderKick(NULL), m_NumReaders(0) {}
   ~CReadWriteLock() { Delete(); }

    inline BOOL Init()
    {
        if ( !m_ReaderKick )
        {
            m_ReaderKick = CreateEvent( NULL, FALSE, FALSE, NULL );
        }
        return ( m_ReaderKick != NULL );
    }

    inline void Delete()
    {
        if ( m_ReaderKick )
        {
            WriterLock();
            CloseHandle( m_ReaderKick );
            m_ReaderKick = NULL;
            WriterRelease();
        }
    }

    inline void WriterLock()
    {
        m_Lock.Lock();
        while ( m_NumReaders > 0 )
        {
            WaitForSingleObject( m_ReaderKick, 100 );
        }
    }

    inline void WriterRelease()
    {
        m_Lock.Unlock();
    }

    inline void ReaderLock()
    {
        m_Lock.Lock();
        InterlockedIncrement( &m_NumReaders );
        m_Lock.Unlock();
    }

    inline void ReaderRelease( )
    {
        InterlockedDecrement( &m_NumReaders );
        SetEvent( m_ReaderKick );
    }

};



class CCriticalSectionLock
{
private:
    CRITICAL_SECTION    m_CriticalSection;

public:
    CCriticalSectionLock()        { InitializeCriticalSection( &m_CriticalSection ); }
    ~CCriticalSectionLock()        { DeleteCriticalSection( &m_CriticalSection ); }

    void Acquire()                { EnterCriticalSection( &m_CriticalSection ); }
    void Release()            { LeaveCriticalSection( &m_CriticalSection ); }

};


//Like a critical section except lightweight, multiprocessor safe and nonrentrant
//on the same thread. 
//Wastes a little too much CPU if you plan on having a lot
//of conflicts. 
//See some of the variables to see how much conflict you had
//ideally m_nFail=0 m_nWait=0.
//Plus all you have to do is break inside while loop to look for where
//deadlock might be occuring 
class CSpinLock {
    LONG m_nInUse;

    LONG m_nUsed;
    LONG m_nWait;
    LONG m_nFail;
    
public:
    //Constuctor use negative 1 because of return value
    //from interlocked increment is wonky
    CSpinLock() {
        m_nInUse=-1;
        m_nUsed=0;
        m_nWait=0;
        m_nFail=0;
    
    };
    //no copy contructor because you shouldn't use it
    //this way and default should copy work fine

    void Acquire() {
        //Quick try before entering while loop
        //SpinLock not considered used unless we fail once
        if (m_nInUse == -1) {
            if (InterlockedIncrement(&m_nInUse))
                InterlockedDecrement(&m_nInUse);
            else
                return;
        };        
            

        InterlockedIncrement(&m_nUsed);
        while (TRUE) {

            //Wait til it becomes unused or zero
            //Do dirty read and this a dirty deed
            //done dirt cheap
            //ASSERT(m_nInUse >= -1);
            if (m_nInUse == -1) {
                //if this is first increment then 
                //use interlocked increment to increase value
                
                //Make sure no one else got it before we were able to do
                //the interlockedincrement
                if (InterlockedIncrement(&m_nInUse)) {
                    //reduce the number again
                    InterlockedDecrement(&m_nInUse);
                    InterlockedIncrement(&m_nFail);
                }else{
                    break;
                }
            }

            InterlockedIncrement(&m_nWait);
            //if we didn't acquire spinlock be nice and release
            Sleep(0);
        }
        
    }

    void Release() {
        //reduce the number again
        InterlockedDecrement(&m_nInUse);
    }

};

//Thread safe reference count class that determines when containing object is deleted
//only use for objects being allocated on the heap.
//Correct behavior of this class is dependent on correct behavior of the callers of AddRef
//Release not calling Release before AddRef or Release more than once
class CRef {
public:
    CRef() {m_cRef=0xFFFFFFFF;}

    //AddRef returns previous reference count or -1 when its the first time called
    ULONG AddRef(void) {
        ULONG cRef;
        m_Lock.Acquire();
        cRef = m_cRef++;
        //If this is the first time we have add a reference then
        //increment twice. So m_cRef isn't sitting at zero
        if (cRef== 0xFFFFFFFF) {
            m_cRef++;
        }
        m_Lock.Release();
        return cRef;
    };

    //Returns zero when
    ULONG Release(void) {
        int cRef;
        //Increment first so second caller
        //into release won't see
        m_Lock.Acquire();
        cRef = --m_cRef;
        m_Lock.Release();
        return cRef;
    };
    
protected:
    
    ULONG m_cRef;
    CSpinLock m_Lock;

};

//Can use macro in header to simplify 
#define REFMETHOD() \
        protected: \
        CRef m_Ref;    \
        public:        \
        ULONG AddRef(void) {return m_Ref.AddRef();}; \
        ULONG Release(void) { \
            ULONG cRef; \
            if (!(cRef=m_Ref.Release())) delete this; \
            return cRef; \
        }; private: 
        
#endif //!__UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\znet.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZNet.h
 *
 * Contents:	Network interfaces
 *
 *****************************************************************************/

#ifndef _ZNET_H_
#define _ZNET_H_


///////////////////////////////////////////////////////////////////////////////
// INetwork Definitions
///////////////////////////////////////////////////////////////////////////////

#ifndef _STPUID_NETWORK_HACK

#define ZNET_NO_PROMPT			0x1
#define ZNET_PROMPT_IF_NEEDED	0x2
#define ZNET_FORCE_PROMPT		0x4

#define zSConnectionClose		0
#define zSConnectionOpen		1
#define zSConnectionMessage		2
#define zSConnectionTimeout		3

enum {
    /* Reasons for denying user access */

    zAccessGranted = 0,                   // success

    zAccessDeniedOldVersion = 1,          // bad protocol version
    zAccessDenied,                        // credential auth failed
    zAccessDeniedNoUser,
    zAccessDeniedBadPassword,
    zAccessDeniedUserLockedOut,
    zAccessDeniedSystemFull,              // out of resources ( i.e. memory )
    zAccessDeniedProtocolError,           // bad protocol signature
    zAccessDeniedBadSecurityPackage,      // SSPI initialization failed on client
    zAccessDeniedGenerateContextFailed,   // user canceled DPA dialog

    zAccessDeniedBlackListed = 1024
    
};

typedef struct _ZNETWORK_OPTIONS
{
    DWORD  SocketBacklog;
    DWORD  EnableTcpKeepAlives;
    DWORD  WaitForCompletionTimeout;
    DWORD  RegWriteTimeout;
    DWORD  DisableEncryption;
    DWORD  MaxSendSize;
    DWORD  MaxRecvSize;
    DWORD  KeepAliveInterval;
    DWORD  PingInterval;
    DWORD  ProductSignature;
    DWORD  ClientEncryption;
} ZNETWORK_OPTIONS;


typedef void* ZSConnection;
typedef void (__stdcall *ZSConnectionMessageFunc)(ZSConnection connection, DWORD event,void* userData);
typedef void (__stdcall *ZSConnectionMsgWaitFunc)(void* data);
typedef void (__stdcall *ZSConnectionAPCFunc)(void* data);

#endif //!_STPUID_NETWORK_HACK


///////////////////////////////////////////////////////////////////////////////
// Forward references
///////////////////////////////////////////////////////////////////////////////

interface IConnection;


///////////////////////////////////////////////////////////////////////////////
// Callback typedefs
///////////////////////////////////////////////////////////////////////////////

typedef void (__stdcall *INetworkWaitFunc)(void* data);
typedef void (__stdcall *IConnectionMessageFunc)(IConnection* connection, DWORD event,void* userData);


///////////////////////////////////////////////////////////////////////////////
// INetwork
///////////////////////////////////////////////////////////////////////////////

// {CD0AC738-F9E3-11d2-8B6B-00C04F8EF2FF}
DEFINE_GUID(IID_INetwork, 
0xcd0ac738, 0xf9e3, 0x11d2, 0x8b, 0x6b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{CD0AC738-F9E3-11d2-8B6B-00C04F8EF2FF}"))
INetwork : public IUnknown
{
	STDMETHOD(Init)( BOOL bEnablePools = FALSE, BOOL EnableIOCompletionPorts = TRUE ) = 0;

	STDMETHOD(Exit)() = 0;

    STDMETHOD(ShutDown)() = 0;

	STDMETHOD(CloseConnection)(IConnection* connection) = 0;

	STDMETHOD(DeleteConnection)(IConnection* connection) = 0;

	STDMETHOD_(void,SetOptions)( ZNETWORK_OPTIONS* opt ) = 0;

    STDMETHOD_(void,GetOptions)( ZNETWORK_OPTIONS* opt ) = 0;

	STDMETHOD_(IConnection*,CreateClient)(
							char* hostname,
							long *ports,
							IConnectionMessageFunc func,
							void* serverClass,
							void* userData ) = 0;

	STDMETHOD_(IConnection*,CreateSecureClient)(
							char* hostname,
							long *ports,
							IConnectionMessageFunc func,
							void* conClass,
							void* userData,
							char* User,
							char* Password,
							char* Domain,
							int Flags = ZNET_PROMPT_IF_NEEDED) = 0;

	STDMETHOD_(void,Wait)( INetworkWaitFunc func = NULL, void* data = NULL, DWORD dwWakeMask = QS_ALLINPUT ) = 0;

	STDMETHOD_(BOOL,QueueAPCResult)( ZSConnectionAPCFunc func, void* data ) = 0;
};



///////////////////////////////////////////////////////////////////////////////
// Network object
///////////////////////////////////////////////////////////////////////////////

// {CD0AC739-F9E3-11d2-8B6B-00C04F8EF2FF}
DEFINE_GUID(CLSID_Network, 
0xcd0ac739, 0xf9e3, 0x11d2, 0x8b, 0x6b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

class __declspec(uuid("{CD0AC739-F9E3-11d2-8B6B-00C04F8EF2FF}")) CNetwork;


///////////////////////////////////////////////////////////////////////////////
// Connection interface
///////////////////////////////////////////////////////////////////////////////

// {0714C63F-FB7E-11d2-8B6B-00C04F8EF2FF}
DEFINE_GUID(IID_IConnection, 
0x714c63f, 0xfb7e, 0x11d2, 0x8b, 0x6b, 0x0, 0xc0, 0x4f, 0x8e, 0xf2, 0xff);

interface __declspec(uuid("{0714C63F-FB7E-11d2-8B6B-00C04F8EF2FF}"))
IConnection : public IUnknown
{
	STDMETHOD_(DWORD,Send)(DWORD messageType, void* buffer, long len, DWORD dwSignature, DWORD dwChannel = 0) = 0;

	STDMETHOD_(void*,Receive)(DWORD *messageType, long* len, DWORD *pdwSignature, DWORD *pdwChannel = NULL) = 0;

    STDMETHOD_(BOOL,IsDisabled)() = 0;

	STDMETHOD_(BOOL,IsServer)() = 0; 

	STDMETHOD_(BOOL,IsClosing)() = 0;

    STDMETHOD_(DWORD,GetLocalAddress)() = 0;

    STDMETHOD_(char*,GetLocalName)() = 0;

    STDMETHOD_(DWORD,GetRemoteAddress)() = 0;

    STDMETHOD_(char*,GetRemoteName)() = 0;

    STDMETHOD_(GUID*,GetUserGUID)() = 0;

    STDMETHOD_(BOOL,GetUserName)(char* name) = 0;

    STDMETHOD_(BOOL,SetUserName)(char* name) = 0;

    STDMETHOD_(DWORD,GetUserId)() = 0;

    STDMETHOD_(BOOL,GetContextString)(char* buf, DWORD len) = 0;

    STDMETHOD_(BOOL,HasToken)(char* token) = 0;

    STDMETHOD_(int,GetAccessError)() = 0;

	STDMETHOD_(void,SetUserData)( void* UserData ) = 0;

	STDMETHOD_(void*,GetUserData)() = 0;

    STDMETHOD_(void,SetClass)( void* conClass ) = 0;

	STDMETHOD_(void*,GetClass)() = 0;

    STDMETHOD_(DWORD,GetLatency)() = 0;

    STDMETHOD_(DWORD,GetAcceptTick)() = 0;

	STDMETHOD_(void,SetTimeout)(DWORD timeout) = 0;

    STDMETHOD_(void,ClearTimeout)() = 0;

    STDMETHOD_(DWORD,GetTimeoutRemaining)() = 0;

	// hack to implementation
	STDMETHOD_(void*,GetZCon)() = 0;
	STDMETHOD_(void,SetZCon)(void* con) = 0;
	STDMETHOD_(void,SetMessageFunc)(void* func) = 0;
};

#endif // _ZNET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zodbc.h ===
#ifndef __ODBC_LIB_H__
#define __ODBC_LIB_H__

#include <windows.h>
#include <sql.h>
#include <sqlext.h>

class CODBC
{
public:
    CODBC();
    ~CODBC();

    // Reference counting
    ULONG AddRef();
    ULONG Release();

    // Rather than relying on CRT to initialize class' static
    // variables, an application can call this procedure.
    static BOOL Init();

    // Open ODBC connection
    BOOL Open( LPSTR szDSN, LPSTR szUserName, LPSTR szPassword, INT32 nTimeoutSec = -1 );

    // Close connection
    void Close();

    // wrappers
    SQLRETURN Reset();
    SQLRETURN SetTimeOut( DWORD dwTimeOut );
    SQLRETURN Prepare( char* szStmt );
    SQLRETURN Execute()                            { return SQLExecute( m_hstmt ); }
    SQLRETURN ExecuteDiscardRows();
    SQLRETURN ExecDirect( char* szStmt );
    SQLRETURN Fetch()                            { return SQLFetch( m_hstmt ); }
    SQLRETURN MoreResults()                        { return SQLMoreResults( m_hstmt ); }

    // wrappers for SQLBindParameter
    void ResetParamCount()                      { m_ParamCnt = 1; }

    SQLRETURN AddInParamInt( int* pValue );
    SQLRETURN AddInParamDWORD( DWORD* pValue ) { return AddInParamInt( (int*)pValue ); }
    SQLRETURN AddInParamShort( short* pValue );
    SQLRETURN AddInParamTiny( char* pValue );
    SQLRETURN AddInParamString( char* szValue, DWORD dwColSize );
    SQLRETURN AddOutParamInt( int* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamShort( short* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamTiny( char* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamString( char* szValue, DWORD dwColSize, DWORD cbMaxSize, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddOutParamDateTime( TIMESTAMP_STRUCT* pTimestamp, SDWORD* pcbValue = &gm_DummyParamBytes );

    // wrappers for SQLBindCol
    SQLRETURN AddColInt( int* pValue, SDWORD* pcbValue = &gm_DummyParamBytes );
    SQLRETURN AddColString( char* szValue, DWORD cbMaxSize, SDWORD* pcbValue = &gm_DummyParamBytes );

    // adjust column number
    void SkipColumn( int col )                { m_ColCnt++; }
    void SetColumn( int col )                { ASSERT( col >=  m_ColCnt ); m_ColCnt = col; }

    // Retrieves ODBC error description.
    char* GetError( SQLRETURN nResult, SWORD fHandleType, BOOL fIncludePrepareString = TRUE );

    // called after calling GetError
    char* GetErrorState() { return m_szSQLErrorState; }

    // Writes ODBC error to event log
    void LogError( SQLRETURN nResult, SWORD fHandleType, BOOL fIncludePrepareString = TRUE );
    
    // variable wrappers
    HENV hstmt()    { return m_hstmt; }
    HENV hdbc()        { return m_hdbc; }
    HENV henv()        { return m_henv; }
    
private:
    // ODBC handles
    HSTMT    m_hstmt;
    HDBC    m_hdbc;
    HENV    m_henv;

    // error string buffer
    char m_szError[ 1024 ];
    char m_szSQLErrorState[SQL_SQLSTATE_SIZE + 1];

    // prepare string buffer
    char m_szPrepare[ 512 ];

    // next parameter number
    SQLUSMALLINT m_ParamCnt;

    // next column number
    SQLUSMALLINT m_ColCnt;

    // reference count
    ULONG m_RefCnt;

    // Dummy  bytes for AddOutParam calls
    static SQLINTEGER gm_DummyParamBytes;
};


#ifndef NO_CODBC_POOLS
#include "queue.h"


class CODBCPool
{
public:
    CODBCPool();
    ~CODBCPool();

    // Initialize connection pool
    HRESULT Init( LPSTR szDSN, LPSTR szUserName, LPSTR szPassword, long iInitial, long iMax, BOOL fLogError = TRUE );

    // Retrieve connection from pool
    CODBC* Alloc( BOOL fLogError = TRUE );

    // Return connection to pool
    void Free( CODBC* pConnection, BOOL fConnectionOk = TRUE );

private:
    // free connections
    CMTList<CODBC> m_Idle;

    // login strings
    char m_szDSN[512];
    char m_szUserName[512];
    char m_szPassword[512];

    // connection counts
    long m_iMax;
    long m_iCount;
    
    // Last connection ok?  Prevents event log spamming.
    BOOL m_bLastConnectOk;
};

#endif

///////////////////////////////////////////////////////////////////////////////
// Inlines
///////////////////////////////////////////////////////////////////////////////

inline ULONG CODBC::AddRef()
{
    return ++m_RefCnt;
}


inline SQLRETURN CODBC::Prepare( char* szStmt )
{
    lstrcpyn( m_szPrepare, szStmt, sizeof(m_szPrepare) );
    return SQLPrepare( m_hstmt, (UCHAR*) szStmt, SQL_NTS );
}



inline SQLRETURN CODBC::ExecDirect( char* szStmt )
{
    lstrcpyn( m_szPrepare, szStmt, sizeof(m_szPrepare) );
    return SQLExecDirect( m_hstmt, (UCHAR*) szStmt, SQL_NTS );
}


inline SQLRETURN CODBC::Reset()
{
    SQLRETURN nResult;
    m_szPrepare[0] = '\0';
    m_ParamCnt = 1;
    m_ColCnt = 1;

    nResult = SQLFreeStmt( m_hstmt, SQL_CLOSE );
    if ( nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO)
        return nResult;

    nResult = SQLFreeStmt( m_hstmt, SQL_UNBIND );
    if ( nResult != SQL_SUCCESS && nResult != SQL_SUCCESS_WITH_INFO)
        return nResult;

    return SQLFreeStmt( m_hstmt, SQL_RESET_PARAMS );
}


inline SQLRETURN CODBC::AddInParamInt( int* pValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, pValue, 0, NULL );
}


inline SQLRETURN CODBC::AddInParamShort( short* pValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_SMALLINT, 0, 0, pValue, 0, NULL );
}


inline SQLRETURN CODBC::AddInParamTiny( char* pValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_SLONG, SQL_TINYINT, 0, 0, pValue, 0, NULL );
}


inline SQLRETURN CODBC::AddInParamString( char* szValue, DWORD dwColSize )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_INPUT, SQL_C_CHAR, SQL_VARCHAR, dwColSize, 0, szValue, 0, NULL );
}


inline SQLRETURN CODBC::AddOutParamInt( int* pValue, SDWORD* pcbValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_INTEGER, 0, 0, pValue, 0, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamShort( short* pValue, SDWORD* pcbValue  )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_SMALLINT, 0, 0, pValue, 0, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamTiny( char* pValue, SDWORD* pcbValue  )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_SLONG, SQL_TINYINT, 0, 0, pValue, 0, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamString( char* szValue, DWORD dwColSize, DWORD cbMaxSize, SDWORD* pcbValue )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_CHAR, SQL_VARCHAR, dwColSize, 0, szValue, cbMaxSize, pcbValue );
}


inline SQLRETURN CODBC::AddOutParamDateTime( TIMESTAMP_STRUCT* pTimestamp, SDWORD* pcbValue  )
{
    return SQLBindParameter( m_hstmt, m_ParamCnt++, SQL_PARAM_OUTPUT, SQL_C_TYPE_TIMESTAMP, SQL_TYPE_TIMESTAMP, 0, 0, pTimestamp, 0, pcbValue );
}


inline SQLRETURN CODBC::SetTimeOut( DWORD dwTimeOut )
{
    return SQLSetStmtAttr( m_hstmt, SQL_ATTR_QUERY_TIMEOUT, (void*) dwTimeOut, 0 );
}


inline SQLRETURN CODBC::AddColInt( int* pValue, SDWORD* pcbValue )
{
    return SQLBindCol( m_hstmt, m_ColCnt++, SQL_C_SLONG, pValue, sizeof(int), pcbValue );
}


inline SQLRETURN CODBC::AddColString( char* szValue, DWORD cbMaxSize, SDWORD* pcbValue )
{
    return SQLBindCol( m_hstmt, m_ColCnt++, SQL_C_CHAR, szValue, cbMaxSize, pcbValue );
}


#endif //!__ODBC_LIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoleaut32.h ===
#ifndef ZOLEAUT32_H
#define ZOLEAUT32_H

#include <windows.h>
#include <oleauto.h>

HRESULT WINAPI ZUnRegisterTypeLib(
	REFGUID libID,
	unsigned short wVerMajor,
	unsigned short wVerMinor,
	LCID lcid,
	SYSKIND syskind );

#endif //ZOLEAUT32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zone.h ===
/*******************************************************************************

	Zone.h
	
		Zone(tm) System API.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, April 29, 1995 06:26:45 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
    ----------------------------------------------------------------------------
	14		2/09/96		CHB		Added ZLaunchURL().
	13		12/16/96	HI		Removed ZMemCpy() and ZMemSet().
	12		12/11/96	HI		Added ZMemCpy() and ZMemSet().
	11		11/21/96	HI		Cleaned up for ZONECLI_DLL.
	10		11/15/96	HI		More to do with ZONECLI_DLL.
								Modified ZParseVillageCommandLine() parameters.
	9		11/15/96	HI		Changed #ifdef ZONECLI_DLL to #ifndef _ZONECLI_.
	8		11/08/96	HI		Added new definitions for colors and fonts
								for ZONECLI_DLL.
								Conditionalized for ZONECLI_DLL.
								*** Including zonecli.h at end of file.
    7       11/06/96  craigli   removed ZNetworkStrToAddr().
    6       10/23/96    HI      Changed ZParseVillageCommandLine() parameters.
    5       10/23/96    HI      Changed serverAddr from int32 to char* in
                                ZParseVillageCommandLine().
	4		10/23/96	RK		Added ZNetworkStrToAddr().
    3       10/13/96    HI      Fixed compiler warnings.
	2		10/11/96	HI		Added controlhandle parameter to ZClientMain().
								Added ZWindowMoveObject().
    1       10/10/96  craigli   Changes Endian functions to macros
	0		04/29/95	HI		Created.
	 
*******************************************************************************/

// @doc ZONE

#ifndef _ZSYSTEM_
#define _ZSYSTEM_

#include "windows.h"

#ifndef _ZTYPES_
#include "ztypes.h"
#endif

#include <tchar.h>

#define EXPORTME __declspec(dllexport)


/*******************************************************************************
		Public Object Types
*******************************************************************************/

typedef void* ZObject;				/* Any object. */
typedef void* ZGrafPort;			/* ZWindow, ZOffscreenPort */
typedef void* ZWindow;
typedef void* ZCheckBox;
typedef void* ZRadio;
typedef void* ZButton;
typedef void* ZScrollBar;
typedef void* ZEditText;
typedef void* ZPictButton;
typedef void* ZAnimation;
typedef void* ZTimer;
typedef void* ZCursor;
typedef void* ZSound;
typedef void* ZFont;
typedef void* ZImage;
typedef void* ZMask;				/* ZImage w/ only mask data. */
typedef void* ZOffscreenPort;
typedef void* ZInfo;
typedef void* ZResource;
typedef void* ZBrush;
typedef void* ZHelpWindow;
typedef void* ZHelpButton;
typedef void* ZOptionsButton;



/*******************************************************************************
		Graphical Objects
*******************************************************************************/

typedef struct
{
	int16 left;
	int16 top;
	int16 right;
	int16 bottom;
} ZRect;

typedef struct
{
	int16 x;
	int16 y;
} ZPoint;

typedef struct
{
    uchar index;
    uchar red;
    uchar green;
    uchar blue;
} ZColor;

typedef struct
{
	uint32			numColors;
	ZColor			colors[1];			/* Variable length. */
} ZColorTable;

enum
{
	zVersionImageDescriptor = 1
};

typedef struct
{
	uint32			objectSize;			/* Size of the object, including this field. */
	uint32			descriptorVersion;	/* Version of the image descriptor. */
	uint16			width;				/* Width of image in pixels. */
	uint16			height;				/* Height of image in pixels. */
	uint16			imageRowBytes;		/* Bytes per row in image. */
	uint16			maskRowBytes;		/* Bytes per row in mask. */
	uint32			colorTableDataSize;	/* Size of color table in bytes. */
	uint32			imageDataSize;		/* Size of image data in bytes. */
	uint32			maskDataSize;		/* Size of mask data in bytes. */
	uint32			colorTableOffset;	/* Offset to color table. 0 if none. */
	uint32			imageDataOffset;	/* Offset to image data. 0 if none. */
	uint32			maskDataOffset;		/* Offset to mask data. 0 if none. */
	/*
		Quad-aligned packets of data for 8-bit image data and 1-bit image mask.
		
		Offsets are from the beginning of the object and not from the field.
		
		The image is an 8-bit PICT and the mask is a 1-bit PICT.
		
		Both image and mask data are scan line packed in the format:
			[byte count word] [data]
		The word containing the byte count of the packed scan line indicates
		how many of the subsequent bytes are packed data of the scan line.
		
		Pad bytes are added to the end of the color table, image, and mask
		data blocks for quad-byte alignment.
		
		Assumption is that both the image and mask are the same size in
		pixels.
	*/
} ZImageDescriptor;

enum
{
	zVersionAnimationDescriptor = 1
};

typedef struct
{
	uchar			imageIndex;			/* 1 based; 0 = no image. */
	uchar			soundIndex;			/* 1 based; 0 = no sound. */
	uint16			nextFrameIndex;		/* 1 based; 0 = next frame in array. */
} ZAnimFrame;

typedef struct
{
	uint32			objectSize;			/* Size of the object, including this field. */
	uint32			descriptorVersion;	/* Version of this descriptor. */
	uint16			numFrames;			/* Number of frames in the animation. */
	uint16			totalTime;			/* Total animation time in 1/10 seconds. */
	uint16			numImages;			/* Number of image descriptors. */
	uint16			numSounds;			/* Number of sound descriptors. */
	uint32			sequenceOffset;		/* Offset to animation sequence data. */
	uint32			maskDataOffset;		/* Offset to common mask data. */
	uint32			imageArrayOffset;	/* Offset to image descriptor offset array. */
	uint32			soundArrayOffset;	/* Offset to sound descriptor offset array. */
	/*
		Quad-aligned packets of data for animation sequence and images.

		Animation sequence is simply an array of ZAnimFrame objects. Each
		entry indicates the image to display, next image to display, and
		the sound to play, if any.

		Both imageArrayOffset and soundArrayOffset point to an array of
		offsets in the object.
		
		Images are quad-aligned data packets of ZImageDescriptors.
		
		The common mask is used if a given image does not have a mask itself.
		
		One sound channel is allocated per animation object; i.e., only one
		sound can be played at any time. When a frame with a sound index is
		reached, then the currently playing sound, if any, is immediately
		stopped and the corresponding sound is played from the start.
	*/
} ZAnimationDescriptor;

/* -------- Sound Types -------- */
enum
{
	zSoundSampled = 0,
	
	zVersionSoundDescriptor = 1
};

typedef struct 
{
	uint32			objectSize;			/* Size of the object, including this field. */
	uint32			descriptorVersion;	/* Version of the sound descriptor. */
	int16			soundType;			/* Sound data type. */
	int16			rfu;
	uint32			soundDataSize;		/* Size of sound data in bytes. */
	uint32			soundSamplingRate;	/* Sampling rate of the sound. */
	uint32			soundDataOffset;	/* Offset to sound data. */
	/*
		The sampling rate is specified in fixed point:
			5.5K	= 0x15BBA2E8
			11K		= 0x2B7745D1
			22K		= 0x56EE8BA3
			44K		= 0xADDD1746
		
		The sound data consists of values from 0 to 255.
	*/
} ZSoundDescriptor;


/* -------- File Stuff -------- */
enum
{
	zFileSignatureImage = 'FZIM',
	zFileSignatureAnimation = 'FZAM',
	zFileSignatureResource = 'FZRS',
	zFileSignatureGameImage = 'FZGI',
	zFileSignatureSound = 'FZSN'
};

typedef struct
{
	uint32		version;				/* File version. */
	uint32		signature;				/* File data signature. */
	uint32		fileDataSize;			/* File data size not including header. */
} ZFileHeader;


/* -------- Resource Types -------- */
enum
{
	zResourceTypeImage = zFileSignatureImage,
	zResourceTypeAnimation = zFileSignatureAnimation,
	zResourceTypeSound = zFileSignatureSound,
	zResourceTypeText = 'ZTXT',
	zResourceTypeRectList = 'ZRCT'
};



/*******************************************************************************
		Predefined Constants
*******************************************************************************/

/* -------- Predefine Cursors -------- */
#define zCursorArrow			((ZCursor) -1)
#define zCursorBusy				((ZCursor) -2)
#define zCursorCross			((ZCursor) -3)
#define zCursorText				((ZCursor) -4)
#define zCursorOpenHand			((ZCursor) -5)
#define zCursorIndexFinger		((ZCursor) -6)


/* -------- Fonts -------- */
enum
{
	zFontSystem = 0,
	zFontApplication,
	
	zFontStyleNormal		= 0x0000,
	zFontStyleBold			= 0x0001,
	zFontStyleUnderline		= 0x0002,
	zFontStyleItalic		= 0x0004
};


/* -------- Supported Drawing Modes -------- */
enum
{
	zDrawCopy = 0,
	zDrawOr,
	zDrawXor,
	zDrawNotCopy,
	zDrawNotOr,
	zDrawNotXor,
    // unlike the other draw modes, these can be combined..
    zDrawMirrorHorizontal = 0x0100,
    zDrawMirrorVertical = 0x0200
};
#define zDrawModeMask       0x00FF
#define zDrawMirrorModeMask 0xFF00


/* -------- Text Draw Justify Flags -------- */
enum
{
	zTextJustifyLeft = 0,
	zTextJustifyRight,
	zTextJustifyCenter,
	
	zTextJustifyWrap = 0x80000000
};


/* -------- Stock Objects -------- */
enum
{
	/* Colors */
	zObjectColorBlack = 0,
	zObjectColorDarkGray,
	zObjectColorGray,
	zObjectColorLightGray,
	zObjectColorWhite,
	zObjectColorRed,
	zObjectColorGreen,
	zObjectColorBlue,
	zObjectColorYellow,
	zObjectColorCyan,
	zObjectColorMagenta,

	/* Fonts */
	zObjectFontSystem12Normal,
	zObjectFontApp9Normal,
	zObjectFontApp9Bold,
	zObjectFontApp12Normal,
	zObjectFontApp12Bold
};


/* -------- Window Types -------- */
enum
{
	zWindowStandardType = 0,
		/* Standard window with title bar and border. */
	zWindowDialogType,
		/* Standard dialog window -- may or may not have title bar but does have border. */
	zWindowPlainType,
		/* Simple window without title bar or border. */

	zWindowChild,
		/* Simple chid window. Parent will be window handed into UserMainInit*/

	zWindowNoCloseBox = 0x8000
		/* Window without close box. */
};


/* -------- Endian Conversion Types -------- */
enum
{
	zEndianToStandard = FALSE,
	zEndianFromStandard = TRUE
};


/* -------- Other Conversion Types -------- */
enum
{
	zToStandard = 0,
	zToSystem
};


/* -------- Prompt Values -------- */
enum
{
	zPromptCancel	= 1,
	zPromptYes		= 2,
	zPromptNo		= 4
};


/* -------- Graphic Operation Flags -------- */
enum
{
	zCenterBoth = 0,
	zCenterHorizontal = 0x0001,
	zCenterVertical = 0x0002
};

/* -------- Zone Logo Types -------- */
enum
{
	zLogoSmall = 0
};



/*******************************************************************************
		Messaging Protocol
*******************************************************************************/

#define zObjectSystem			(ZObject) NULL


/* -------- Messages -------- */
enum
{
	zMessageAllTypes = 0,
	
	/* System Messages (1-127) */
	zMessageSystemExit = 1,
		/*
			Program exiting. Clean up as necessary.
		*/
	zMessageSystemForeground,
		/*
			Program has been put into the foreground.
		*/
	zMessageSystemBackground,
		/*
			Program has been put into the background. Reduce processing where possible.
		*/

    zMessageSystemDisplayChange,
        /*
            Resolution or color depth has changed.
        */
	
	/* Window Messages (128-1023) */
	zMessageWindowIdle = 128,
		/*
			where field contains the current cursor position.
			message field contains the modifier key states.
		*/
	zMessageWindowActivate,
	zMessageWindowDeactivate,
	zMessageWindowClose,
	zMessageWindowDraw,
	zMessageWindowCursorMovedIn,
	zMessageWindowCursorMovedOut,
	zMessageWindowButtonDown,
	zMessageWindowButtonUp,
	zMessageWindowButtonDoubleClick,
		/*
			For zMessageWindowButtonDown, zMessageWindowButtonUp, and
			zMessageWindowButtonDoubleClick,
				where field contains the current cursor position, and
				message field contains the modifier key states.
		*/
	zMessageWindowChar,
		/* ASCII char value is stored in the low byte of the messageData field. */
	zMessageWindowTalk,
		/*
			messagePtr field contains pointer to the talk message buffer and
			messageLen contains the length of the talk message.
		*/
	zMessageWindowChildWindowClosed,
		/*
			Message sent to the parent window indicating that a child window has been closed.
			messagePtr field contains the child ZWindow value.
		*/
	
	/*
		Window objects will receive the following messages in addition to the window
		messages. Only these windows messages are given to window objects.
			zMessageWindowIdle,
			zMessageWindowActivate,
			zMessageWindowDeactivate,
			zMessageWindowDraw,
			zMessageWindowButtonDown,
			zMessageWindowButtonUp,
			zMessageWindowButtonDoubleClick,
			zMessageWindowChar,
	*/
	zMessageWindowObjectTakeFocus,
		/*
			Message given to window objects by the system window manager for the object
			to accept focus of user inputs. If the object does not handle user inputs or
			does not want focus, it may decline to handle the message and return FALSE.
		*/
	zMessageWindowObjectLostFocus,
		/*
			Message sent by the system window manager to a window object for the object
			to give up focus of user inputs. The object must handle the message.
		*/

	zMessageWindowUser,
		/*
			User defined message
		*/
	
	zMessageWindowMouseClientActivate,   //leonp		

 	zMessageWindowRightButtonDown,
	zMessageWindowRightButtonUp,
	zMessageWindowRightButtonDoubleClick,
    zMessageWindowMouseMove,
		/*
			For zMessageRightWindowButtonDown, zMessageWindowRightButtonUp, and
			zMessageWindowRightButtonDoubleClick,
				where field contains the current cursor position, and
				message field contains the modifier key states.
		*/

    zMessageWindowEnable,
    zMessageWindowDisable,

	/* Program Specific Messages (1024-32767) */
	zMessageProgramMessage = 1024
		/*
			This is the base id for program specific messages. All program specific messages
			should start from this id.
		*/
};

enum
{
	zWantIdleMessage				=	0x0001,
	zWantActivateMessage			=	0x0002,
	zWantCursorMovedMessage			=	0x0004,	/* All cursor moved messages. */
	zWantButtonMessage				=	0x0008,	/* All button messages. */
	zWantCharMessage				=	0x0010,
	zWantDrawMessage				=	0x0020,
    zWantEnableMessages             =   0x0040,
	zWantAllMessages				=	0xFFFF
};
	
enum
{
	zCharMask = 0x000000FF,
	
	/* Modifier key masks. Modifier keys are stored in the messageData field. */
	zCharShiftMask					= 0x01000000,			/* Shift key. */
	zCharControlMask				= 0x02000000,			/* Control key; control on Mac also. */
	zCharAltMask					= 0x04000000			/* Alt key; Option on Mac. */
};

typedef struct
{
	ZObject			object;					/* Object receiving the message. */
	uint16			messageType;			/* Type of message. */
	uint16			rfu;
	ZPoint			where;					/* Position of cursor. */
	ZRect			drawRect;				/* Draw/update rectangle. */
	uint32			message;				/* Message data (for small messages) */
	void*			messagePtr;				/* Pointer to message buffer */
	uint32			messageLen;				/* Length of message in buffer */
	void*			userData;				/* User data. */
} ZMessage;


/* -------- Object Callback Routine -------- */
typedef ZBool (* ZMessageFunc)(ZObject object, ZMessage* message);


#ifdef __cplusplus
extern "C" {
#endif


DWORD ComputeTickDelta( DWORD now, DWORD then );

/*******************************************************************************
		ZWindow
*******************************************************************************/

ZWindow ZWindowNew(void);
ZError ZWindowInit(ZWindow window, ZRect* windowRect,
		int16 windowType, ZWindow parentWindow, 
		TCHAR* title, ZBool visible, ZBool talkSection, ZBool center,
		ZMessageFunc windowFunc, uint32 wantMessages, void* userData);

ZError ZRoomWindowInit(ZWindow window, ZRect* windowRect,
		int16 windowType, ZWindow parentWindow,
		TCHAR* title, ZBool visible, ZBool talkSection, ZBool center,
		ZMessageFunc windowFunc, uint32 wantMessages, void* userData);

void ZWindowDelete(ZWindow window);
void ZWindowGetRect(ZWindow window, ZRect* windowRect);
ZError ZWindowSetRect(ZWindow window, ZRect* windowRect);
ZError ZWindowMove(ZWindow window, int16 left, int16 top);
ZError ZWindowSize(ZWindow window, int16 width, int16 height);
ZError ZWindowShow(ZWindow window);
ZError ZWindowHide(ZWindow window);
ZBool ZWindowIsVisible(ZWindow window);
void ZWindowGetTitle(ZWindow window, TCHAR* title, uint16 len);
ZError ZWindowSetTitle(ZWindow window, TCHAR* title);
ZError ZWindowBringToFront(ZWindow window);
ZError ZWindowDraw(ZWindow window, ZRect* drawRect);
void ZWindowTalk(ZWindow window, _TUCHAR* from, _TUCHAR* talkMessage);
void ZWindowModal(ZWindow window);
void ZWindowNonModal(ZWindow window);
void ZWindowSetDefaultButton(ZWindow window, ZButton button);
void ZWindowSetCancelButton(ZWindow window, ZButton button);
void ZWindowValidate(ZWindow window, ZRect* validRect);
void ZWindowInvalidate(ZWindow window, ZRect* invalRect);
ZMessageFunc ZWindowGetFunc(ZWindow window);
void ZWindowSetFunc(ZWindow window, ZMessageFunc messageFunc);
void* ZWindowGetUserData(ZWindow window);
void ZWindowSetUserData(ZWindow window, void* userData);
void ZWindowMakeMain(ZWindow window);
void ZWindowUpdateControls(ZWindow window);
ZError ZWindowAddObject(ZWindow window, ZObject object, ZRect* bounds,
		ZMessageFunc messageFunc, void* userData);
	/*
		Attaches the given object to the window for event preprocessing.
		
		On a user input, the object is given the user input message. If the
		object handles the message, then it is given the opportunity to take
		the focus.
		
		NOTE: All predefined objects are automatically added to the window.
		Client programs should not add predefined objects to the system -- if
		done so, the client program could crash. This routine should be used
		only when client programs are creating custom objects.
	*/
	
ZError ZWindowRemoveObject(ZWindow window, ZObject object);
ZError ZWindowMoveObject(ZWindow window, ZObject object, ZRect* bounds);
ZObject ZWindowGetFocusedObject(ZWindow window);
	/*
		Returns the object with the current focus. NULL if no object has focus.
	*/
	
ZBool ZWindowSetFocusToObject(ZWindow window, ZObject object);
	/*
		Sets the focus to the given object. Returns whether the object accepted
		the focus or not. Object may refuse to accept the focus if it is not
		responding to user inputs.
		
		Removes focus from the currently focused object if object is NULL.
		
		Removes focus from the currently focused object only if the specified
		object accepts focus.
	*/

void ZWindowTrackCursor(ZWindow window, ZMessageFunc messageFunc, void* userData);
	/*
		Tracks the cursor until the mouse button down/up event occurs. The coordinates
		are local to the specified window. The messageFunc will be called with userData
		for idle, mouseDown and mouseUp events.
	*/


/*
	Only a leaf window (a window which does not have a child window) can be made
	modal.
	
	The window is centered within the parent. If the window is a root window, then
	it is centered within the screen.
	
	The main window is the unique way of corresponding a program with a window. There
	is only one main window per program. By default, the first window created is the
	main window. To make a different window the main window, call ZWindowMakeMain().
*/


HWND ZWindowGetHWND( ZWindow window );
	/*
		Return HWND for the Zone window
	*/

/*******************************************************************************
		ZCheckBox
*******************************************************************************/

typedef void (*ZCheckBoxFunc)(ZCheckBox checkBox, ZBool checked, void* userData);
	/*
		This function is called whenever the checkbox is checked or unchecked.
	*/

ZCheckBox ZCheckBoxNew(void );
ZError ZCheckBoxInit(ZCheckBox checkBox, ZWindow parentWindow,
		ZRect* checkBoxRect, TCHAR* title, ZBool checked, ZBool visible,
		ZBool enabled, ZCheckBoxFunc checkBoxFunc, void* userData);
void ZCheckBoxDelete(ZCheckBox checkBox);
void ZCheckBoxGetRect(ZCheckBox checkBox, ZRect* checkBoxRect);
ZError ZCheckBoxSetRect(ZCheckBox checkBox, ZRect* checkBoxRect);
ZError ZCheckBoxMove(ZCheckBox checkBox, int16 left, int16 top);
ZError ZCheckBoxSize(ZCheckBox checkBox, int16 width, int16 height);
ZBool ZCheckBoxIsVisible(ZCheckBox checkBox);
ZError ZCheckBoxShow(ZCheckBox checkBox);
ZError ZCheckBoxHide(ZCheckBox checkBox);
ZBool ZCheckBoxIsChecked(ZCheckBox checkBox);
ZError ZCheckBoxCheck(ZCheckBox checkBox);
ZError ZCheckBoxUnCheck(ZCheckBox checkBox);
ZBool ZCheckBoxIsEnabled(ZCheckBox checkBox);
ZError ZCheckBoxEnable(ZCheckBox checkBox);
ZError ZCheckBoxDisable(ZCheckBox checkBox);
void ZCheckBoxGetTitle(ZCheckBox checkBox, TCHAR* title, uint16 len);
ZError ZCheckBoxSetTitle(ZCheckBox checkBox, TCHAR* title);
ZCheckBoxFunc ZCheckBoxGetFunc(ZCheckBox checkBox);
void ZCheckBoxSetFunc(ZCheckBox checkBox, ZCheckBoxFunc checkBoxFunc);
void* ZCheckBoxGetUserData(ZCheckBox checkBox);
void ZCheckBoxSetUserData(ZCheckBox checkBox, void* userData);



/*******************************************************************************
		ZRadio
*******************************************************************************/

typedef void (*ZRadioFunc)(ZRadio radio, ZBool selected, void* userData);
	/*
		This function is called whenever the radio button is selected or unselected.
	*/

ZRadio ZRadioNew(void );
ZError ZRadioInit(ZRadio radio, ZWindow parentWindow,
		ZRect* radioRect, TCHAR* title,	ZBool selected, ZBool visible,
		ZBool enabled, ZRadioFunc radioFunc, void* userData);
void ZRadioDelete(ZRadio radio);
void ZRadioGetRect(ZRadio radio, ZRect* radioRect);
ZError ZRadioSetRect(ZRadio radio, ZRect* radioRect);
ZError ZRadioMove(ZRadio radio, int16 left, int16 top);
ZError ZRadioSize(ZRadio radio, int16 width, int16 height);
ZBool ZRadioIsVisible(ZRadio radio);
ZError ZRadioShow(ZRadio radio);
ZError ZRadioHide(ZRadio radio);
ZBool ZRadioIsSelected(ZRadio radio);
ZError ZRadioSelect(ZRadio radio);
ZError ZRadioUnSelect(ZRadio radio);
ZBool ZRadioIsEnabled(ZRadio radio);
ZError ZRadioEnable(ZRadio radio);
ZError ZRadioDisable(ZRadio radio);
void ZRadioGetTitle(ZRadio radio, TCHAR* title, uint16 len);
ZError ZRadioSetTitle(ZRadio radio, TCHAR* title);
ZRadioFunc ZRadioGetFunc(ZRadio radio);
void ZRadioSetFunc(ZRadio radio, ZRadioFunc radioFunc);
void* ZRadioGetUserData(ZRadio radio);
void ZRadioSetUserData(ZRadio radio, void* userData);



/*******************************************************************************
		ZButton
*******************************************************************************/

typedef void (*ZButtonFunc)(ZButton button, void* userData);
	/*
		This function is called whenever the button is clicked on.
	*/

ZButton ZButtonNew(void );
ZError ZButtonInit(ZButton button, ZWindow parentWindow,
		ZRect* buttonRect, TCHAR* title, ZBool visible, ZBool enabled,
		ZButtonFunc buttonFunc, void* userData);
void ZButtonDelete(ZButton button);
void ZButtonGetRect(ZButton button, ZRect* buttonRect);
ZError ZButtonSetRect(ZButton button, ZRect* buttonRect);
ZError ZButtonMove(ZButton button, int16 left, int16 top);
ZError ZButtonSize(ZButton button, int16 width, int16 height);
ZBool ZButtonIsVisible(ZButton button);
ZError ZButtonShow(ZButton button);
ZError ZButtonHide(ZButton button);
ZBool ZButtonIsEnabled(ZButton button);
ZError ZButtonEnable(ZButton button);
ZError ZButtonDisable(ZButton button);
void ZButtonFlash(ZButton button);
void ZButtonGetTitle(ZButton button, TCHAR* title, uint16 len);
ZError ZButtonSetTitle(ZButton button, TCHAR* title);
ZButtonFunc ZButtonGetFunc(ZButton button);
void ZButtonSetFunc(ZButton button, ZButtonFunc buttonFunc);
void* ZButtonGetUserData(ZButton button);
void ZButtonSetUserData(ZButton button, void* userData);



/*******************************************************************************
		ZScrollBar
*******************************************************************************/

typedef void (*ZScrollBarFunc)(ZScrollBar scrollBar, int16 curValue, void* userData);
	/*
		This function is calld whenever the scroll bar is moved with the new value
		of the scroll bar.
	*/

ZScrollBar ZScrollBarNew(void);
ZError ZScrollBarInit(ZScrollBar scrollBar, ZWindow parentWindow, 
		ZRect* scrollBarRect, int16 value, int16 minValue, int16 maxValue,
		int16 singleIncrement, int16 pageIncrement,
		ZBool visible, ZBool enabled,	ZScrollBarFunc scrollBarFunc,
		void* userData);
void ZScrollBarDelete(ZScrollBar scrollBar);
void ZScrollBarGetRect(ZScrollBar scrollBar, ZRect* scrollBarRect);
ZError ZScrollBarSetRect(ZScrollBar scrollBar, ZRect* scrollBarRect);
ZError ZScrollBarMove(ZScrollBar scrollBar, int16 left, int16 top);
ZError ZScrollBarSize(ZScrollBar scrollBar, int16 width, int16 height);
ZBool ZScrollBarIsVisible(ZScrollBar scrollBar);
ZError ZScrollBarShow(ZScrollBar scrollBar);
ZError ZScrollBarHide(ZScrollBar scrollBar);
ZBool ZScrollBarIsEnabled(ZScrollBar scrollBar);
ZError ZScrollBarEnable(ZScrollBar scrollBar);
ZError ZScrollBarDisable(ZScrollBar scrollBar);
int16 ZScrollBarGetValue(ZScrollBar scrollBar);
ZError ZScrollBarSetValue(ZScrollBar scrollBar, int16 value);
void ZScrollBarGetRange(ZScrollBar scrollBar, int16* minValue, int16* maxValue);
ZError ZScrollBarSetRange(ZScrollBar scrollBar, int16 minValue, int16 maxValue);
void ZScrollBarGetIncrements(ZScrollBar scrollBar, int16* singleInc, int16* pageInc);
ZError ZScrollBarSetIncrements(ZScrollBar scrollBar, int16 singleInc, int16 pageInc);
ZScrollBarFunc ZScrollBarGetFunc(ZScrollBar scrollBar);
void ZScrollBarSetFunc(ZScrollBar scrollBar, ZScrollBarFunc scrollBarFunc);
void* ZScrollBarGetUserData(ZScrollBar scrollBar);
void ZScrollBarSetUserData(ZScrollBar scrollBar, void* userData);



/*******************************************************************************
		ZEditText
*******************************************************************************/

typedef ZBool (*ZEditTextFunc)(ZEditText editText, TCHAR newChar, void* userData);
	/*
		This function is called whenever a key has been typed and is about to be
		entered into the edit text box; it is called before adding the character
		into the text. This allows the user to filter characters as desired.
		
		If this function returns FALSE, then newChar is inserted into the text;
		if it returns TRUE, then newChar is not inserted into the text with the
		assumption that the function has filtered the characters appropriately.
		Filtering can consist of inserting the character, ignoring the character,
		substituting for some other character or multiple chacters, and the like.
	*/

ZEditText ZEditTextNew(void);
ZError ZEditTextInit(ZEditText editText, ZWindow parentWindow,
		ZRect* editTextRect, TCHAR* text, ZFont textFont, ZBool scrollBar,
		ZBool locked, ZBool wrap, ZBool drawFrame, ZEditTextFunc editTextFunc,
		void* userData);
void ZEditTextDelete(ZEditText editText);
void ZEditTextGetRect(ZEditText editText, ZRect* editTextRect);
void ZEditTextSetRect(ZEditText editText, ZRect* editTextRect);
void ZEditTextMove(ZEditText editText, int16 left, int16 top);
void ZEditTextSize(ZEditText editText, int16 width, int16 height);
ZBool ZEditTextIsLocked(ZEditText editText);
void ZEditTextLock(ZEditText editText);
void ZEditTextUnlock(ZEditText editText);
uint32 ZEditTextGetLength(ZEditText editText);
TCHAR* ZEditTextGetText(ZEditText editText);
ZError ZEditTextSetText(ZEditText editText, TCHAR* text);
void ZEditTextAddChar(ZEditText editText, TCHAR newChar);
void ZEditTextAddText(ZEditText editText, TCHAR* text);
void ZEditTextClear(ZEditText editText);
uint32 ZEditTextGetInsertionLocation(ZEditText editText);
uint32 ZEditTextGetSelectionLength(ZEditText editText);
TCHAR* ZEditTextGetSelectionText(ZEditText editText);
void ZEditTextGetSelection(ZEditText editText, uint32* start, uint32* end);
void ZEditTextSetSelection(ZEditText editText, uint32 start, uint32 end);
void ZEditTextReplaceSelection(ZEditText editText, TCHAR* text);
void ZEditTextClearSelection(ZEditText editText);
ZEditTextFunc ZEditTextGetFunc(ZEditText editText);
void ZEditTextSetFunc(ZEditText editText, ZEditTextFunc editTextFunc);
void* ZEditTextGetUserData(ZEditText editText);
void ZEditTextSetUserData(ZEditText editText, void* userData);
void ZEditTextSetInputFocus(ZEditText editText);

/*
	When a EditText object is locked, it is not editable. In order to edit it,
	it must be unlocked first.
	
	If wrap is FALSE, then the edit text will all be on one line. It will not
	wrap around to the next line. This also means that the vertical scroll bars
	will not be available. If wrap is TRUE, then all the text will wrap within
	the given width.
	
	ZEditTextGetText() returns a pointer to the text. The caller must dispose of
	the buffer when done. The returned text is null terminated.
	
	ZEditTextGetLength() and ZEditTextGetSelectionLength() return the number of
	characters in the edit text; the length does not include the null terminating
	character added to the returned text.
	
	When the selection is empty (no selection), start and end are the same. Valid
	selection start and end values are 0 to 32767.
	
	These keys are not passed to ZEditText:
		Tab
*/



/*******************************************************************************
		ZPictButton
*******************************************************************************/

typedef void (*ZPictButtonFunc)(ZPictButton pictButton, void* userData);
	/*
		This function is called whenever the picture button is clicked on.
	*/

ZPictButton ZPictButtonNew(void);
ZError ZPictButtonInit(ZPictButton pictButton, ZWindow parentWindow,
		ZRect* pictButtonRect, ZImage normalButtonImage, ZImage selectedButtonImage,
		ZBool visible, ZBool enabled, ZPictButtonFunc pictButtonFunc, void* userData);
void ZPictButtonDelete(ZPictButton pictButton);
void ZPictButtonGetRect(ZPictButton pictButton, ZRect* pictButtonRect);
ZError ZPictButtonSetRect(ZPictButton pictButton, ZRect* pictButtonRect);
ZError ZPictButtonMove(ZPictButton pictButton, int16 left, int16 top);
ZError ZPictButtonSize(ZPictButton pictButton, int16 width, int16 height);
ZBool ZPictButtonIsVisible(ZPictButton pictButton);
ZError ZPictButtonShow(ZPictButton pictButton);
ZError ZPictButtonHide(ZPictButton pictButton);
ZBool ZPictButtonIsEnabled(ZPictButton pictButton);
ZError ZPictButtonEnable(ZPictButton pictButton);
ZError ZPictButtonDisable(ZPictButton pictButton);
void ZPictButtonFlash(ZPictButton pictButton);
ZPictButtonFunc ZPictButtonGetFunc(ZPictButton pictButton);
void ZPictButtonSetFunc(ZPictButton pictButton, ZPictButtonFunc pictButtonFunc);
void* ZPictButtonGetUserData(ZPictButton pictButton);
void ZPictButtonSetUserData(ZPictButton pictButton, void* userData);

/*
	Picture images normalButtonImage and selectedButtonImage are NOT copied.
	The objects are referenced by the ZPictButton object. Hence, destroying
	these images before deleting the picture button is fatal.
*/



/*******************************************************************************
		ZAnimation
*******************************************************************************/

typedef void (*ZAnimationDrawFunc)(ZAnimation animation, ZGrafPort grafPort,
		ZRect* drawRect, void* userData);
	/*
		The drawing function must draw into the current port. It must not
		change graphics port. Assume that the graphics port and clipping
		rectangle has already been set up. Just draw.
	*/

typedef void (*ZAnimationCheckFunc)(ZAnimation animation, uint16 frame, void* userData);
	/*
		A callback function to allow the creator of the object to determine
		the animation object's behavior. The frame parameter indicates
		the current frame of the animation; it is 0 if it has reached the
		end of the animation.
		
		The creator can change the frame of the animation depending on the
		state of the program. This callback function is called everytime it
		advances to the next frame but before drawing the image.
	*/

ZAnimation ZAnimationNew(void);
ZError ZAnimationInit(ZAnimation animation,
		ZGrafPort grafPort, ZRect* bounds, ZBool visible,
		ZAnimationDescriptor* animationDescriptor,
		ZAnimationCheckFunc checkFunc,
		ZAnimationDrawFunc backgroundDrawFunc, void* userData);
void ZAnimationDelete(ZAnimation animation);
int16 ZAnimationGetNumFrames(ZAnimation animation);
void ZAnimationSetCurFrame(ZAnimation animation, uint16 frame);
uint16 ZAnimationGetCurFrame(ZAnimation animation);
void ZAnimationDraw(ZAnimation animation);
void ZAnimationStart(ZAnimation animation);
void ZAnimationStop(ZAnimation animation);
void ZAnimationContinue(ZAnimation animation);
ZBool ZAnimationStillPlaying(ZAnimation animation);
void ZAnimationShow(ZAnimation animation);
void ZAnimationHide(ZAnimation animation);
ZBool ZAnimationIsVisible(ZAnimation animation);
ZError ZAnimationSetParams(ZAnimation animation, ZGrafPort grafPort,
		ZRect* bounds, ZBool visible, ZAnimationCheckFunc checkFunc,
		ZAnimationDrawFunc backgroundDrawFunc, void* userData);
ZBool ZAnimationPointInside(ZAnimation animation, ZPoint* point);

/*
	The frame numbers are 1 based; hence, the first frame is 1 and the last
	frame is n, where there are n frames in the animation.
	
	ZAnimationStart() plays the animation from frame 1.
	ZAnimationContinue() plays the animation from the current frame.
	
	ZAnimationSetParams() must be called after creating an animation object
	through some other means than ZAnimationInit(); for example,
	through ZCreateAnimationFromFile() or ZResourceGetAnimation().
	
	ZAnimationPointInside() checks whether the given point is inside the animation
	object at the called time. It simply calls ZPointInImage() on the current
	object.
*/



/*******************************************************************************
		ZTimer
*******************************************************************************/

typedef void (*ZTimerFunc)(ZTimer timer, void* userData);
	/*
		This timer function is called when a timeout occurs.
	*/

ZTimer ZTimerNew(void);
ZError ZTimerInit(ZTimer timer, uint32 timeout,
		ZTimerFunc timeoutFunc, void* userData);
void ZTimerDelete(ZTimer timer);
uint32 ZTimerGetTimeout(ZTimer timer);
ZError ZTimerSetTimeout(ZTimer timer, uint32 timeout);
ZTimerFunc ZTimerGetFunc(ZTimer timer);
void ZTimerSetFunc(ZTimer timer, ZTimerFunc timeoutFunc);
void* ZTimerGetUserData(ZTimer timer);
void ZTimerSetUserData(ZTimer timer, void* userData);

/*
	Timeout are in 1/100 seconds. The timeout is NOT guaranteed to be exact.
	After the timeout, timeoutFunc will be called but it is not immediate.
	
	A timeout of 0 stops the timer; timeoutFunc will not be called until the
	timeout is set to some positive value.
	
	This timer is not an interrupt timer (i.e. interrupt based). Hence, all
	operations are possible within the timer fuction. However, as such, the
	timer is not very accurate; it is dependent on the system load.
*/



/*******************************************************************************
		ZCursor
*******************************************************************************/

ZCursor ZCursorNew(void);
ZError ZCursorInit(ZCursor cursor, uchar* image, uchar* mask,
		ZPoint hotSpot);
void ZCursorDelete(ZCursor cursor);

/*
	Cursors are 16x16 mono images. It has a mask and a hot spot.
	There are several predefined cursors.
*/



/*******************************************************************************
		ZFont
*******************************************************************************/

ZFont ZFontNew(void);
ZError ZFontInit(ZFont font, int16 fontType, int16 style,
		int16 size);
void ZFontDelete(ZFont font);



/*******************************************************************************
		ZSound
*******************************************************************************/

typedef void (*ZSoundEndFunc)(ZSound sound, void* userData);
	/*
		This end function is called after the end of the sound play.
	*/

ZSound ZSoundNew(void);
ZError ZSoundInit(ZSound sound, ZSoundDescriptor* soundData);
void ZSoundDelete(ZSound sound);
ZError ZSoundStart(ZSound sound, int16 loopCount,
						ZSoundEndFunc endFunc, void* userData);
ZError ZSoundStop(ZSound sound);
ZSoundEndFunc ZSoundGetFunc(ZSound sound);
void ZSoundSetFunc(ZSound sound, ZSoundEndFunc endFunc);
void* ZSoundGetUserData(ZSound sound);
void ZSoundSetUserData(ZSound sound, void* userData);

/*
	The user can provide a loop count to ZSoundStart(); if loopCount is -1, then
	it continuously plays the sound until it is manually stopped with ZSoundStop().
	The endFunc is called after the sound has been played loopCount times. If the
	sound is played indefinitely (loopCount == -1), then endFunc will never be
	called. The endFunc is always called after the end of play or when it is stopped.
*/



/*******************************************************************************
		ZImage
*******************************************************************************/

#define ZImageToZMask(image)			((ZMask) (image))

ZImage ZImageNew(void);
ZError ZImageInit(ZImage image, ZImageDescriptor* imageData,
		ZImageDescriptor* maskData);
void ZImageDelete(ZImage image);
void ZImageDraw(ZImage image, ZGrafPort grafPort, 
		ZRect* bounds, ZMask mask, uint16 drawMode);
void ZImageDrawPartial(ZImage image, ZGrafPort grafPort, 
		ZRect* bounds, ZMask mask, uint16 drawMode, ZPoint* source);
int16 ZImageGetWidth(ZImage image);
int16 ZImageGetHeight(ZImage image);
ZBool ZImagePointInside(ZImage image, ZPoint* point);
	/*
		Returns TRUE if the given point is inside the image. If the image has a mask,
		then it checks whether the point is inside the mask. If the image does not have
		a mask, then it simply checks the image bounds.
	*/

ZError ZImageMake(ZImage image, ZOffscreenPort imagePort, ZRect* imageRect,
		ZOffscreenPort maskPort, ZRect* maskRect);
	/*
		Creates a ZImage object from a ZOffscreenPort object. Both the image and
		mask can be specified. Either can be non-existent but not both. Both
		imageRect and maskRect are in the local coordinates of their respective
		offscreen ports.
	*/
	
ZError ZImageAddMask(ZImage image, ZMask mask);
	/*
		Adds mask data to the image. If the image already has a mask data, then
		the existing mask data is replaced with the new one.
	*/

void ZImageRemoveMask(ZImage image);
	/*
		Remove the mask data in the image.
	*/

ZMask ZImageExtractMask(ZImage image);
	/*
		Copies the mask data in the image and returns a new ZMask object containing
		the copied mask. The original mask in the image is not removed.
	*/

ZError ZImageCopy(ZImage image, ZImage from);
	/*
		Make a copy of the image object from.
	*/
	
ZError ZImageMaskToImage(ZImage image);
	/*
		Makes the mask of the image into the image while deleting the original image
		data.
	*/

ZImage ZImageCreateFromBMPRes(HINSTANCE hInstance, WORD resID, COLORREF transparentColor);
ZImage ZImageCreateFromBMP(HBITMAP hBitmap, COLORREF transparentColor);
ZImage ZImageCreateFromResourceManager(WORD resID, COLORREF transparentColor);

	/*
		Routines to create ZImage objects from BMPs.

		If transparentColor is 0, no mask is generated. Otherwise, the specified color
		is used to generate the mask from the image.
	*/


/*
	Remember that ZImage and ZMask are the same objects. They can be used interchangeably.
	ZMask is specified in those places where only the mask data is relevant and used.
*/



/*******************************************************************************
		ZOffscreenPort
*******************************************************************************/

ZOffscreenPort ZOffscreenPortNew(void);
ZError ZOffscreenPortInit(ZOffscreenPort offscreenPort, ZRect* portRect);
void ZOffscreenPortDelete(ZOffscreenPort offscreenPort);
ZOffscreenPort ZConvertImageToOffscreenPort(ZImage image);
ZOffscreenPort ZConvertImageMaskToOffscreenPort(ZImage image);
ZOffscreenPort ZOffscreenPortCreateFromResourceManager( WORD resID, COLORREF clrTransparent );


	/*
		Converts the given image object into an offscreen port object. The given
		image object is deleted and, hence, becomes unusable. The mask data, if any,
		is ignored. The offscreen port portRect is set to (0, 0, width, height),
		where width and height are the image's width and height, respectively.
		
		This routine is useful in converting a large image object into an
		offscreen port object with minimal additonal memory.
		
		Returns NULL if it fails to convert the image and the image is unchanged.
	*/



/*******************************************************************************
		ZInfo
*******************************************************************************/

ZInfo ZInfoNew(void);
ZError ZInfoInit(ZInfo info, ZWindow parentWindow, TCHAR* infoString,
		uint16 width, ZBool progressBar, uint16 totalProgress);
void ZInfoDelete(ZInfo info);
void ZInfoShow(ZInfo info);
void ZInfoHide(ZInfo info);
void ZInfoSetText(ZInfo info, TCHAR* infoString);
void ZInfoSetProgress(ZInfo info, uint16 progress);
void ZInfoIncProgress(ZInfo info, int16 incProgress);
void ZInfoSetTotalProgress(ZInfo info, uint16 totalProgress);

/*
	Information window object to display the given information string.
	Progress is also displayed below the text if progressBar is true.
	totalProgresss indicates the total accumulation of progress.
	
	The info box is not displayed until ZInfoShow() is called.
	
	Width specifies the width of the information window.
	
	infoString must be null-terminated.
	
	infoString can be changed any time the window is displayed. This allows
	dynamic display of a progress status. However, the position of the
	window does not change even though the height of the window may.
*/



/*******************************************************************************
		ZResources
*******************************************************************************/

ZResource ZResourceNew(void);
ZError ZResourceInit(ZResource resource, TCHAR* fileName);
void ZResourceDelete(ZResource resource);
uint16 ZResourceCount(ZResource resource);
	/*
		Returns the number of resources in the resource file.
	*/
	
void* ZResourceGet(ZResource resource, uint32 resID, uint32* resSize, uint32* resType);
	/*
		Returns the raw data of the specified resource. If the data is
		raw text, then the text is null terminated.
	*/
	
uint32 ZResourceGetSize(ZResource resource, uint32 resID);
	/*
		Returns the size of the specified resource.
	*/
	
uint32 ZResourceGetType(ZResource resource, uint32 resID);
	/*
		Returns the type of the specified resource.
	*/
	
ZImage ZResourceGetImage(ZResource resource, uint32 resID);
	/*
		Returns an image object created from the specified resource.
		Returns NULL if an error occured.
	*/
	
ZAnimation ZResourceGetAnimation(ZResource resource, uint32 resID);
	/*
		Returns an animation object created from the specified resource.
		Returns NULL if an error occured.
	*/
	
ZSound ZResourceGetSound(ZResource resource, uint32 resID);
	/*
		Returns a sound object created from the specified resource.
		Returns NULL if an error occured.
	*/
	
TCHAR* ZResourceGetText(ZResource resource, uint32 resID);
	/*
		Returns a null-terminated text in the specified resource. It is
		converted to the running platform format throught ZTranslateText().
	*/
	
int16 ZResourceGetRects(ZResource resource, uint32 resID, int16 numRects, ZRect* rects);
	/*
		Resource type = zResourceTypeRectList.
		
		Fills in the rect array with the contents of the specified resource.
		Returns the number of rects it filled in.
		
		The rects parameter must have been preallocated and large enough for
		numRects rects.
	*/



/*******************************************************************************
		ZBrush
*******************************************************************************/

ZBrush ZBrushNew(void);
ZError ZBrushInit(ZBrush brush, ZImage image);
void ZBrushDelete(ZBrush brush);

/*
	The brush object is created from the given image object. The width and height
	of the image must be powers of 2.
*/



/*******************************************************************************
		Drawing Routines
*******************************************************************************/

void ZBeginDrawing(ZGrafPort grafPort);
void ZEndDrawing(ZGrafPort grafPort);
	/*
		Nested ZBeginDrawing() and ZEndDrawing() calls can be made. However,
		port states are not preserved. Nesting allows a child routine to
		call ZBeingDrawing() and ZEndDrawing() on the same port as the parent
		without destorying the parent's port when it exits.
		
		When ZBeginDrawing() is called, it sets the clipping rectangle to
		a default rectangle. When it is subsequently called before
		ZEndDrawing() is called, ZBeginDrawing() does not modified the
		clipping rectangle.
	*/

void ZSetClipRect(ZGrafPort grafPort, ZRect* clipRect);
void ZGetClipRect(ZGrafPort grafPort, ZRect* clipRect);
	/*
		Sets and Gets the clipping rectangle for grafPort. ZBeginDrawing()
		must be called first before calling these routines. Must restore
		the old clipping rectangle before calling ZEndDrawing().
	*/

void ZCopyImage(ZGrafPort srcPort, ZGrafPort dstPort, ZRect* srcRect,
		ZRect* dstRect, ZMask mask, uint16 copyMode);
	/*
		Copies a portion of the source of image from the srcPort into
		the destination port. srcRect is in local coordinates of srcPort and
		dstRect is in local coordinates of dstPort. You can specify a
		mask from an image to be used for masking out on the destination.
		
		This routine automatically sets up the drawing ports so the user
		does not have to call ZBeginDrawing() and ZEndDrawing().
	*/

void ZLine(ZGrafPort grafPort, int16 dx, int16 dy);
void ZLineTo(ZGrafPort grafPort, int16 x, int16 y);
void ZMove(ZGrafPort grafPort, int16 dx, int16 dy);
void ZMoveTo(ZGrafPort grafPort, int16 x, int16 y);

void ZRectDraw(ZGrafPort grafPort, ZRect* rect);
void ZRectErase(ZGrafPort grafPort, ZRect* rect);
void ZRectPaint(ZGrafPort grafPort, ZRect* rect);
void ZRectInvert(ZGrafPort grafPort, ZRect* rect);
void ZRectFill(ZGrafPort grafPort, ZRect* rect, ZBrush brush);

void ZRoundRectDraw(ZGrafPort grafPort, ZRect* rect, uint16 radius);
void ZRoundRectErase(ZGrafPort grafPort, ZRect* rect, uint16 radius);
void ZRoundRectPaint(ZGrafPort grafPort, ZRect* rect, uint16 radius);
void ZRoundRectInvert(ZGrafPort grafPort, ZRect* rect, uint16 radius);
void ZRoundRectFill(ZGrafPort grafPort, ZRect* rect, uint16 radius, ZBrush brush);

void ZOvalDraw(ZGrafPort grafPort, ZRect* rect);
void ZOvalErase(ZGrafPort grafPort, ZRect* rect);
void ZOvalPaint(ZGrafPort grafPort, ZRect* rect);
void ZOvalInvert(ZGrafPort grafPort, ZRect* rect);
void ZOvalFill(ZGrafPort grafPort, ZRect* rect, ZBrush brush);

void ZGetForeColor(ZGrafPort grafPort, ZColor* color);
void ZGetBackColor(ZGrafPort grafPort, ZColor* color);
ZError ZSetForeColor(ZGrafPort grafPort, ZColor* color);
ZError ZSetBackColor(ZGrafPort grafPort, ZColor* color);

ZColorTable* ZGetSystemColorTable(void);
	/*
		Returns a copy of the Zone(tm) system color table. The caller must dispose
		of the color table when it through using it via ZFree().
	*/

void ZSetPenWidth(ZGrafPort grafPort, int16 penWidth);

void ZSetDrawMode(ZGrafPort grafPort, int16 drawMode);
	/*
		Draw mode affects all pen drawing (lines and rectangles) and
		text drawings.
	*/

void ZSetFont(ZGrafPort grafPort, ZFont font);

void ZDrawText(ZGrafPort grafPort, ZRect* rect, uint32 justify,
		TCHAR* text);
	/*
		Draws the given text within the rectangle rect (clipped) with the
		text justified according to justify.
	*/
	
int16 ZTextWidth(ZGrafPort grafPort, TCHAR* text);
	/*
		Returns the width of the text in pixels if drawn in grafPort using ZDrawText().
	*/

int16 ZTextHeight(ZGrafPort grafPort, TCHAR* text);
	/*
		Returns the height of the text in pixels if drawn in grafPort using ZDrawText().
	*/

void ZSetCursor(ZWindow window, ZCursor cursor);

void ZGetCursorPosition(ZWindow window, ZPoint* point);
	/*
		Returns the location of the cursor in the local coordinates of
		the given window.
	*/

void ZGetScreenSize(uint32* width, uint32* height);
	/*
		Returns the size of the screen in pixels.
	*/
	
uint16 ZGetDefaultScrollBarWidth(void);
	/*
		Returns the system's default width for a scroll bar. This is made available for
		the user to consistently determine the scroll bar width for all platforms.
	*/

ZBool ZIsLayoutRTL();
    /*
        Returns TRUE if the application has been localized into Hebrew
        or Arabic and therefore should run right to left.
    */

ZBool ZIsSoundOn();
    /*
        Returns TRUE if the application has sound enabled.
    */

/* -------- Rectangle Calculation Routines -------- */
void ZRectOffset(ZRect* rect, int16 dx, int16 dy);
	/*
		Moves the rectangle by dx and dy.
	*/

void ZRectInset(ZRect* rect, int16 dx, int16 dy);
	/*
		Insets the rectangle by dx and dy. It outsets the rectangle if
		dx and dy are negative.
	*/
	
ZBool ZRectIntersection(ZRect* rectA, ZRect* rectB, ZRect* rectC);
	/*
		Returns TRUE if rectA and rectB overlap; otherwise, it returns FALSE.
		
		Also stores the intersection into rectC. If rectC is NULL, then it
		does not return the intersection.
		
		Either rectA or rectB can be specified as rectC.
	*/

void ZRectUnion(ZRect* rectA, ZRect* rectB, ZRect* rectC);
	/*
		Determines the union of rectA and rectB and stores into rectC.
		
		Either rectA or rectB can be specified as rectC.
	*/

ZBool ZRectEmpty(ZRect* rect);
	/*
		Returns TRUE if rect is empty. A rectangle is empty if it does not
		contain a pixel inside it.
	*/

ZBool ZPointInRect(ZPoint* point, ZRect* rect);
	/*
		Returns TRUE if point is inside or on the boundry of rect.
		Otherwise, it returns FALSE.
	*/

void ZCenterRectToRect(ZRect* rectA, ZRect* rectB, uint16 flags);
	/*
		Centers rectA within rectB.
		
		Flags: zCenterVertical and zCenterHorizontal
			0 ==> both
			zCenterVertical ==> only vertically
			zCenterHorizontal ==> only horizontally
			zCenterVertial | zCenterHorizontal ==> both
	*/


/* -------- Point Routines -------- */
void ZPointOffset(ZPoint* point, int16 dx, int16 dy);
	/*
		Moves the point by dx and dy.
	*/



/*******************************************************************************
		Client Program Exported Routines
*******************************************************************************/

#ifndef ZONECLI_DLL

extern ZError ZClientMain(uchar* commandLineData, void* controlHandle);
	/*
		Provided by the user program so that the OS lib can call it to
		initialize the program. The command line data is provided to the
		client program.
	*/

extern void ZClientExit(void);
	/*
		Called by the system to allow the client to clean up (free all memory and
		delete all objects) before the process is killed.
	*/

extern void ZClientMessageHandler(ZMessage* message);
	/*
		This is a user program provided routine for the system lib to call for
		messages which are not object specific, such as system messages and
		program specific messages.
		
		User program is not required handle any messages. This routine can be
		a null routine.
	*/

extern TCHAR* ZClientName(void);
	/*
		Returns a pointer to the client program name. This is the displayed name.
		The caller should not modify the contents of the pointer.
	*/

extern TCHAR* ZClientInternalName(void);
	/*
		Returns a pointer to the client internal program name. This is the name for all
		other purposes than displaying the name. The caller should not modify the
		contents of the pointer.
	*/

extern ZVersion ZClientVersion(void);
	/*
		Returns the version number of the client program.
	*/

#endif



/*******************************************************************************
		System Miscellaneous Routines
*******************************************************************************/

void ZLaunchHelp( DWORD helpID );

void ZEnableAdControl( DWORD setting );

void ZPromptOnExit( BOOL bPrompt );

void ZSetCustomMenu( LPSTR szText );
	/*
		Put up a menu item at the top of the shell's Room menu.
		When selected, calls the Custom Item function registered by the game dll
		on initialization.  NULL szText removes the custom item from the menu.
	*/

ZBool ZLaunchURL( TCHAR* pszURL );
	/*
		Called by the client program to launch specified URL in a new
		instance of the registered browser.
	*/


void ZExit(void);
	/*
		Called by the client program to indicate to the system that it
		wants to exit.
		
		Same as user quitting the program.
	*/

ZVersion ZSystemVersion(void);
	/*
		Returns the system library version number.
	*/

TCHAR* ZGetProgramDataFileName(TCHAR* dataFileName);
TCHAR* ZGetCommonDataFileName(TCHAR* dataFileName);
	/*
		Returns a file path name to the specified game and data file within the
		Zone(tm) directory structure.
		
		NOTE: The caller must not free the returned pointer. The returned pointer
		is a static global within the system library.
	*/

uint32 ZRandom(uint32 range);
	/*
		Returns a random number from 0 to range-1 inclusive.
	*/

void ZDelay(uint32 delay);
 	/*
		Delays the processing for delay time; the delay time is specified in
		1/100 seconds. Simply, this routine does not return until delay of
		1/100 seconds have passed.
		
		Note: This routine is not accurate to 1/100 seconds.
	*/

void ZBeep(void);

void ZAlert(TCHAR* errMessage, ZWindow parentWindow);
	/*
		Displays an alert box with the given message. If a parent window is
		specified, then the alert is attached to the parent window. If there
		is no parent window, then set parentWindow to NULL.
		
		Note:
		- parent windows for alerts are not supported on all platforms.
	*/
	
void ZAlertSystemFailure(TCHAR* errMessage);
	/*
		ZAlert() should be used for recoverable errors or warnings.
		ZAlertSystemFailure() is for non-recoverable error case. It terminates
		the program automatically.
	*/

void ZDisplayText(TCHAR* text, ZRect* rect, ZWindow parentWindow);
	/*
		Displays the given text message in a modal dialog.
		
		Assumes that the text is in the proper platform format. If not, then the
		user must call ZTranslateText() first before calling ZDisplayText().
		
		If rect is NULL, then it automatically determines a proper size for the
		dialog window and also adds a scroll bar.
		
		If parentWindow is not NULL, then the dialog window is centered within
		the parent window; otherwise, it is centered within the screen.
	*/

ZBool ZSendMessage(ZObject theObject, ZMessageFunc messageFunc, uint16 messageType,
		ZPoint* where, ZRect* drawRect, uint32 message, void* messagePtr,
		uint32 messageLen, void* userData);
	/*
		Sends the given message immediately to the object.
		
		Returns TRUE if the object handled the message; else, it returns FALSE.
	*/

void ZPostMessage(ZObject theObject, ZMessageFunc messageFunc, uint16 messageType,
		ZPoint* where, ZRect* drawRect, uint32 message, void* messagePtr,
		uint32 messageLen, void* userData);
	/*
		Posts the given message which will be sent to the object at a later time.
	*/

ZBool ZGetMessage(ZObject theObject, uint16 messageType, ZMessage* message,
		ZBool remove);
	/*
		Retrieves a message of the given type for theObject. It returns TRUE if a
		message of the given type is found and retrieved; otherwise, it returns FALSE.
		If the remove parameter if TRUE, then the given message is also removed from
		the message queue; otherwise, the original message is left in the queue.
	*/

ZBool ZRemoveMessage(ZObject theObject, uint16 messageType, ZBool allInstances);
	/*
		Removes a message of messageType from the message queue. If allInstances is
		TRUE, then all messages of messageType in the queue will be removed. If
		messageType is zMessageAllTypes, then the message queue is emptied. If returns
		TRUE if the specified message was found and removed; otherwise, it returns FALSE.
	*/

ZImageDescriptor* ZGetImageDescriptorFromFile(TCHAR* fileName);
ZAnimationDescriptor* ZGetAnimationDescriptorFromFile(TCHAR* fileName);
ZSoundDescriptor* ZGetSoundDescriptorFromFile(TCHAR* fileName);
	/*
		The above routines read an object from the given file and returns a pointer
		to the object descriptor in memory.
	*/

ZImage ZCreateImageFromFile(TCHAR* fileName);
ZAnimation ZCreateAnimationFromFile(TCHAR* fileName);
ZSound ZCreateSoundFromFile(TCHAR* fileName);
	/*
		The above routines create an object from the existing object descriptor
		in the given file. It returns NULL if it failed to create the object;
		either due to out of memory error or file error.
	*/

ZVersion EXPORTME ZGetFileVersion(TCHAR* fileName);
	/*
		Returns the version of the file.
	*/
	
void ZSystemMessageHandler(int32 messageType, int32 messageLen,
		BYTE* message);
	/*
		Handles all system messages.
		
		It frees the message buffer.
	*/
	
TCHAR* ZTranslateText(TCHAR* text, int16 conversion);
	/*
		Translates the given text into the proper platform format and returns a
		pointer to the new text buffer.
		
		conversion is either zToStandard or zToSystem.
		
		Must use ZFree() to free the returned buffer. The original text is not
		modified.
	*/

typedef void (*ZCreditEndFunc)(void);

void ZDisplayZoneCredit(ZBool timeout, ZCreditEndFunc endFunc);
	/*
		Displays Zone's credit box. If timeout is TRUE, then the dialog box times out
		in few seconds. If the user clicks in the window, then the credit box is
		closed.
		
		The endFunc is called, if not NULL, when the window is closed.
	*/

void ZParseVillageCommandLine(TCHAR* commandLine, TCHAR* programName,
		TCHAR* serverAddr, uint16* serverPort);

	/*
		Parses the command line given by village to a client program.
	*/

ZImage ZGetZoneLogo(int16 logoType);
	/*
		Returns ZImage object of the specified logo.
		
		Returns NULL if it failed to find the logo image or some other error occurred.
	*/



void ZStrCpyToLower(CHAR* dst, CHAR* src);
	/*
		Copies src into dst while converting the characters into lowercase.
		For example, src = "LowerThisString" --> dst = "lowerthisstring".
	*/

void ZStrToLower(CHAR* str);
	/*
		Converts str into lowercase.
		Example: str = "LowerThisString" --> str = "lowerthisstring".
	*/

void* ZGetStockObject(int32 objectID);
	/*
		Returns a pointer to a stock object.
	*/



/*******************************************************************************
		Prompt Dialog
*******************************************************************************/

typedef void (*ZPromptResponseFunc)(int16 result, void* userData);
	/*
		The response function gets called when the user selects one of the
		Yes, No, or Cancel buttons. The result value is one of zPromptCancel,
		zPromptYes, or zPromptNo.
	*/
	
ZError ZPrompt(TCHAR* prompt, ZRect* rect, ZWindow parentWindow, ZBool autoPosition,
		int16 buttons, TCHAR* yesButtonTitle, TCHAR* noButtonTitle,
		TCHAR* cancelButtonTitle, ZPromptResponseFunc responseFunc, void* userData);
	/*
		Displays a modal dialog box with the given prompt. If there is no
		parent window, then set parentWindow to NULL. The dialog box will
		be centered within the parent window.
		
		If autoPosition is TRUE, then the prompt dialog box is automatically
		centered. If it is FALSE, then the given rect is used for the dialog
		prompt box.
		
		The buttons parameter indicates which of the Yes, No, and Cancel
		button will be available to the user.
		
		Custom titles can be given to the buttons.
		
		Once the user selects one of the buttons, the response function
		is called with the selected button. Before the resonse function is
		called, the dialog box is hidden from the user.
	*/





/*******************************************************************************
		Endian Conversion Routines
*******************************************************************************/


#if 1 // #ifdef LITTLEENDIAN
#if 0 //defined(_M_IX86)
#define _ZEnd32( pData )     \
    __asm {                 \
            mov eax, *pData \
            bswap eax       \
            mov *pData, eax \
          }

#else
#define _ZEnd32( pData )   \
{                         \
    char *c;              \
    char temp;            \
                          \
    c = (char *) pData;   \
    temp = c[0];          \
    c[0] = c[3];          \
    c[3] = temp;          \
    temp = c[1];          \
    c[1] = c[2];          \
    c[2] = temp;          \
}
#endif

#define _ZEnd16( pData )   \
{                         \
    char *c;              \
    char temp;            \
                          \
    c = (char *) pData;   \
    temp = c[0];          \
    c[0] = c[1];          \
    c[1] = temp;          \
}

#else  // not LITTLEENDIAN

#define _ZEnd32(pData)
#define _ZEnd16(pData)

#endif // not LITTLEENDIAN

#define ZEnd32(pData) _ZEnd32(pData)
#define ZEnd16(pData) _ZEnd16(pData)


void ZRectEndian(ZRect *rect);
void ZPointEndian(ZPoint *point);
void ZColorTableEndian(ZColorTable* table);
void ZImageDescriptorEndian(ZImageDescriptor *imageDesc, ZBool doAll,
		int16 conversion);
void ZAnimFrameEndian(ZAnimFrame* frame);
void ZAnimationDescriptorEndian(ZAnimationDescriptor *animDesc, ZBool doAll,
		int16 conversion);
void ZSoundDescriptorEndian(ZSoundDescriptor *soundDesc);
void ZFileHeaderEndian(ZFileHeader* header);



/*******************************************************************************
		Error Services
*******************************************************************************/

enum
{
	zErrNone = 0,
	zErrGeneric,
	zErrOutOfMemory,
	zErrLaunchFailure,
	zErrBadFont,
	zErrBadColor,
	zErrBadDir,
	zErrDuplicate,
	zErrFileRead,
	zErrFileWrite,
	zErrFileBad,
	zErrBadObject,
	zErrNilObject,
	zErrResourceNotFound,
	zErrFileNotFound,
	zErrBadParameter,
    zErrNotFound,
    zErrLobbyDllInit,
    zErrNotImplemented,

	zErrNetwork	= 1000,
	zErrNetworkRead,
	zErrNetworkWrite,
	zErrNetworkGeneric,
	zErrNetworkLocal,
	zErrNetworkHostUnknown,
	zErrNetworkHostNotAvailable,
	zErrServerIdNotFound,

	zErrWindowSystem = 2000,
	zErrWindowSystemGeneric
};


/* -------- Routines -------- */
TCHAR* GetErrStr(int32 error);



/*******************************************************************************
		Hash Table
*******************************************************************************/

typedef void* ZHashTable;

/* -------- Callback Function Types -------- */
typedef int32 (*ZHashTableHashFunc)(uint32 numBuckets, void* key);
	/*
		Called to hash a key into a bucket index. Must return a number from 0
		to numBuckets-1.
	*/
	
typedef ZBool (*ZHashTableCompFunc)(void* key1, void* key2);
	/*
		Called to compare two keys. Must return TRUE(1) if the keys are the
		same or FALSE(0) if the keys are different.
	*/
	
typedef void (*ZHashTableDelFunc)(void* key, void* data);
	/*
		Called to delete a key and corresponding data.
	*/
	
typedef ZBool (*ZHashTableEnumFunc)(void* key, void* data, void* userData);
	/*
		Called by ZHashTableEnumerate when traversing through the hash table.
		If it returns TRUE(1), the enumeration stops immediately.
		
		userData is passed through from the caller fo ZHashTableEnumerate().
	*/


/* -------- Predefined Hash and Compare Functions -------- */
#define zHashTableHashString	(ZHashTableHashFunc)(-1)
#define zHashTableHashInt32		(ZHashTableHashFunc)(-2)
#define zHashTableCompString	(ZHashTableCompFunc)(-1)
#define zHashTableCompInt32		(ZHashTableCompFunc)(-2)


/* -------- Hash Functions -------- */
ZHashTable ZHashTableNew(uint32 numBuckets, ZHashTableHashFunc hashFunc,
					ZHashTableCompFunc compFunc, ZHashTableDelFunc delFunc);
	/*
		Creates a new hash table and returns the object.
		
		numBuckets defines the size of table.
		hashFunc must be provided for non-standard types for hashing keys.
		compFunc must be provided for non-standard types for comparing keys.
		delFunc may be provided if special handling is necessary for removing
		keys.
	*/
	
void ZHashTableDelete(ZHashTable hashTable);
	/*
		Deletes the hash table.
	*/
	
ZError ZHashTableAdd(ZHashTable hashTable, void* key, void* data);
	/*
		Adds the given key and corresponding data to the hash table.
	*/
	
BOOL ZHashTableRemove(ZHashTable hashTable, void* key);
	/*
		Removes the key from the hash table. The delete function is called, if
        provided, to properly dispose of the key and data. Returns TRUE if key was found and deleted.
	*/
	
void* ZHashTableFind(ZHashTable hashTable, void* key);
	/*
		Finds and returns the data corresponding to the key.
	*/
	
void* ZHashTableEnumerate(ZHashTable hashTable, ZHashTableEnumFunc enumFunc, void* userData);
	/*
		Enumerates through the hash table by calling the enumFunc.
		
		userData is passed to the enumFunc.
		
		If enumFunc returns TRUE(1), the enumeration stops and it returns
		the data corresponding to the last enumeration object.
	*/



/*******************************************************************************
		Linked List
*******************************************************************************/

enum
{
	zLListAddFirst = 0,
	zLListAddLast,
	zLListAddBefore,
	zLListAddAfter,
	
	zLListFindForward = 0,
	zLListFindBackward
};


#define zLListNoType		((void*) -1)
#define zLListAnyType		zLListNoType


typedef void* ZLListItem;
typedef void* ZLList;

typedef void (*ZLListDeleteFunc)(void* objectType, void* objectData);
	/*
		Function provided by the user for ZLList to call when deleting the
		object.
		
		objectType is the type of objectData object which needs to be deleted.
	*/

typedef ZBool (*ZLListEnumFunc)(ZLListItem listItem, void* objectType,
		void* objectData, void* userData);
	/*
		Function provided by the user for ZLList to use during enumeration of
		the link list objects.
		
		listItem is the link list entry of objectData object of objectType type.
		userData is passed through from the caller of ZLListEnumerate().
	*/


/* -------- Linked List Functions -------- */
ZLList ZLListNew(ZLListDeleteFunc deleteFunc);
	/*
		Creates a new link list object. deleteFunc provided by the caller is
		called when deleting the object.
		
		If deleteFunc is NULL, then no delete function is called when an
		object is removed.
	*/
	
void ZLListDelete(ZLList list);
	/*
		Tears down the link list by deleting all link list objects.
	*/
	
ZLListItem ZLListAdd(ZLList list, ZLListItem fromItem, void* objectType,
					void* objectData, int32 addOption);
	/*
		Adds objectData of objectType to the link list using fromItem as a
		reference entry. addOption determines where the new objects gets added.
		If adding to the front or end of the link list, then fromItem is unused.
		If fromItem is NULL, then it is equivalent to the head of the list.
	
		Returns the link list item after adding the object is added to the list.
		
		The given object is not copied! Hence, the caller must not dispose of
		the object until the object is removed from the list first.
		
		Use zLListNoype when object type is not used.
	*/
	
void* ZLListGetData(ZLListItem listItem, void** objectType);
	/*
		Returns the object of the given link list entry. Also returns the object
		type in objectType. Does not return the object type if objectType
		parameter is NULL.
	*/
	
void ZLListRemove(ZLList list, ZLListItem listItem);
	/*
		Removes the link list entry from the list and calls the user supplied
		delete function to delete the object.
	*/
	
ZLListItem ZLListFind(ZLList list, ZLListItem fromItem, void* objectType, int32 findOption);
	/*
		Finds and returns a link list entry containing the object data of the
		objectType. The search is done starting at fromItem using the findOption
		flag. Returns NULL if an object of the specified type is not found.
		
		Use zLListAnyType as the object type when type is not important.
	*/
	
ZLListItem ZLListGetNth(ZLList list, int32 index, void* objectType);
	/*
		Returns the nth object of objectType in the list. Returns NULL if
		such an entry does not exist.
		
		Use zLListAnyType as the object type when type is not important.
	*/
	
ZLListItem ZLListGetFirst(ZLList list, void* objectType);
	/*
		Returns the first object of objectType in the list. Returns NULL if the
		list is empty or if an object of the specified type does not exist.
		
		Use zLListAnyType as the object type when type is not important.
	*/
	
ZLListItem ZLListGetLast(ZLList list, void* objectType);
	/*
		Returns the last object of objectType in the list. Returns NULL if the
		list is empty or if an object of the specified type does not exist.
		
		Use zLListAnyType as the object type when type is not important.
	*/
	
ZLListItem ZLListGetNext(ZLList list, ZLListItem listItem, void* objectType);
	/*
		Returns the next object of the objectType in the list after the listItem
		entry. Returns NULL if no more objects exist in the list.
		
		Use zLListAnyType as the object type when type is not important.
	*/
	
ZLListItem ZLListGetPrev(ZLList list, ZLListItem listItem, void* objectType);
	/*
		Returns the previous object of the objectType in the list before the
		listItem entry. Returns NULL if no more objects exist in the list.
		
		Use zLListAnyType as the object type when type is not important.
	*/
	
ZLListItem ZLListEnumerate(ZLList list, ZLListEnumFunc enumFunc,
					void* objectType, void* userData, int32 findOption);
	/*
		Enumerates through all the objects in the list of objectType through the
		caller supplied enumFunc enumeration function. It passes along to the
		enumeration function the caller supplied userData parameter. It stops
		enumerating when the user supplied function returns TRUE and returns
		the list item in which the enumeration stopped.

		Use zLListAnyType as the object type when type is not important.

		The findOption is zLListFindForward/Backward. It specifies the direction
		the list will be searched.
	*/

int32 ZLListCount(ZLList list, void* objectType);
	/*
		Returns the number of list items of the given type in the list. If
		objectType is zLListAnyType, it returns the total number of items in
		the list.
	*/

void ZLListRemoveType(ZLList list, void* objectType);
	/*
		Removes all objects of the given type from the list.
	*/



/*******************************************************************************
		Help Module
*******************************************************************************/

typedef TCHAR* (*ZGetHelpTextFunc)(void* userData);
	/*
		Called by the help module to get the help data. The help text should
		be null-terminated and allocated with ZMalloc(). The help module will
		free the text buffer with ZFree() when the help window is deleted.
	*/

typedef void (*ZHelpButtonFunc)(ZHelpButton helpButton, void* userData);
	/*
		Called whenever the help button is clicked.
	*/

ZHelpWindow ZHelpWindowNew(void);
ZError ZHelpWindowInit(ZHelpWindow helpWindow, ZWindow parentWindow, TCHAR* windowTitle,
		ZRect* windowRect, ZBool showCredits, ZBool showVersion,
		ZGetHelpTextFunc getHelpTextFunc, void* userData);
void ZHelpWindowDelete(ZHelpWindow helpWindow);
void ZHelpWindowShow(ZHelpWindow helpWindow);
void ZHelpWindowHide(ZHelpWindow helpWindow);

ZHelpButton ZHelpButtonNew(void);
ZError ZHelpButtonInit(ZHelpButton helpButton, ZWindow parentWindow,
		ZRect* buttonRect, ZHelpWindow helpWindow, ZHelpButtonFunc helpButtonFunc,
		void* userData);
void ZHelpButtonDelete(ZHelpButton helpButton);

/*
	Create a help window to display the standard help window.
	
	A standard help button can be created and a help window linked to it such
	that when the button is clicked, the help window is automatically displayed
	to the user. The helpButtonFunc parameter is not necessary unless additional
	special action is necessary when the button is clicked or unless a help
	window is not linked to the button. The helpButtonFunc is called after the
	help window is displayed, if both are set.
	
	Warning: If a help window is linked to a help button and the help window
	is deleted, then the system may crash when the button is clicked.
	
	Note: Why the getHelpTextFunc instead of just passing in the help text?
	Well, this way we don't have to preload all the data ... load on demand
	concept.
*/



/*******************************************************************************
		TableBox
*******************************************************************************/

typedef void* ZTableBox;
typedef void* ZTableBoxCell;

enum
{
	/* -------- Flags -------- */
	zTableBoxHorizScrollBar = 0x00000001,
	zTableBoxVertScrollBar = 0x00000002,
	zTableBoxDoubleClickable = 0x00000004,			/* ==> zTableBoxSelectable */
	zTableBoxDrawGrids = 0x00000008,
	zTableBoxSelectable = 0x00010000,
	zTableBoxMultipleSelections = 0x00020000		/* ==> zTableBoxSelectable */
};

typedef void (*ZTableBoxDrawFunc)(ZTableBoxCell cell, ZGrafPort grafPort, ZRect* cellRect,
		void* cellData, void* userData);
	/*
		Called to draw a cell. The drawing must occur in the specified graf port. It must
		not draw directly into the window. ZBeginDrawing() and ZEndDrawing() are called
		automatically, so there is no need to call them; the clipping rectangle has also
		been set up properly to the size of the cell width and height. All drawings should
		be done with the top-left corner of the graf port as coordinate (0, 0).
	*/

typedef void (*ZTableBoxDeleteFunc)(ZTableBoxCell cell, void* cellData, void* userData);
	/*
		Function provided by the user for ZTableBox to call when deleting a cell.
	*/

typedef void (*ZTableBoxDoubleClickFunc)(ZTableBoxCell cell, void* cellData, void* userData);
	/*
		Function provided by the user for ZTableBox to call when a double click has
		occurred on a cell object.
	*/

typedef ZBool (*ZTableBoxEnumFunc)(ZTableBoxCell cell, void* cellData, void* userData);
	/*
		Function provided by the user for ZTableBox to use during enumeration of
		the table cell objects. Stops the enumeration if the enumeration function
		returns TRUE.
	*/


/* -------- TableBox Functions -------- */
ZTableBox ZTableBoxNew(void);

ZError ZTableBoxInit(ZTableBox table, ZWindow window, ZRect* boxRect,
		int16 numColumns, int16 numRows, int16 cellWidth, int16 cellHeight, ZBool locked,
		uint32 flags, ZTableBoxDrawFunc drawFunc, ZTableBoxDoubleClickFunc doubleClickFunc,
		ZTableBoxDeleteFunc deleteFunc, void* userData);
	/*
		Initializes the table object. The deleteFunc provided by the caller is
		called when deleting the object.
		
		boxRect specifies the bounding box of the table box. This includes the
		scroll bars if any.
		
		cellWidth and cellHeight specify the width and height of the cell in
		pixels.
		
		drawFunc must be specified. Otherwise, no drawing will take place.
		
		If deleteFunc is NULL, then no delete function is called when an
		object is deleted.
		
		The flags parameter defines special properties of the table box. If it
		is 0, then the default behavior is as defined:
			- No scroll bars,
			- Not selectable, and
			- Double clicks do nothing.
		
		Locked tables cannot be selected -- for viewing items.
	*/
	
void ZTableBoxDelete(ZTableBox table);
	/*
		Destroys the table object by deleting all cell objects.
	*/

void ZTableBoxDraw(ZTableBox table);
	/*
		Draws the table box.
	*/

void ZTableBoxMove(ZTableBox table, int16 left, int16 top);
	/*
		Moves the table box to the specified given location. Size is not changed.
	*/

void ZTableBoxSize(ZTableBox table, int16 width, int16 height);
	/*
		Resizes the table box to the specified width and height.
	*/

void ZTableBoxLock(ZTableBox table);
	/*
		Locks the table box so that the cells are not selectable.
	*/

void ZTableBoxUnlock(ZTableBox table);
	/*
		Unlocks the table box from its locked state so that the cells are selectable.
	*/

void ZTableBoxNumCells(ZTableBox table, int16* numColumns, int16* numRows);
	/*
		Returns the number of rows and columns in the table.
	*/

ZError ZTableBoxAddRows(ZTableBox table, int16 beforeRow, int16 numRows);
	/*
		Adds numRows of rows to the table in front of the beforeRow row.
		
		If beforeRow is -1, then the rows are added to the end.
	*/

void ZTableBoxDeleteRows(ZTableBox table, int16 startRow, int16 numRows);
	/*
		Deletes numRows of rows from the table starting from startRow row.
		
		If numRows is -1, then all the rows starting from startRow to the end
		are deleted.
		
		Calls the delete function to delete each cell's data.
	*/

ZError ZTableBoxAddColumns(ZTableBox table, int16 beforeColumn, int16 numColumns);
	/*
		Adds numColumns of columns to the table in front of the beforeColumn column.
		
		If beforeColumn is -1, then the columns are added to the end.
	*/

void ZTableBoxDeleteColumns(ZTableBox table, int16 startColumn, int16 numColumns);
	/*
		Deletes numColumns of columns from the table starting from startColumn column.
		
		If numColumns is -1, then all the columns starting from startColumn to the
		end are deleted.
		
		Calls the delete function to delete each cell's data.
	*/

void ZTableBoxSelectCells(ZTableBox table, int16 startColumn, int16 startRow,
		int16 numColumns, int16 numRows);
	/*
		Highlights all cells included in the rectangle bounded by
		(startColumn, startRow) and (startColumn + numColumns, startRow + numRows)
		as selected.
		
		If numRows is -1, then all the cells in the column starting from startRow
		are selected. Similarly for numColumns.
	*/

void ZTableBoxDeselectCells(ZTableBox table, int16 startColumn, int16 startRow,
		int16 numColumns, int16 numRows);
	/*
		Unhighlights all cells included in the rectangle bounded by
		(startColumn, startRow) and (startColumn + numColumns, startRow + numRows)
		as deselected.
		
		If numRows is -1, then all the cells in the column starting from startRow
		are deselected. Similarly for numColumns.
	*/

void ZTableBoxClear(ZTableBox table);
	/*
		Clears the whole data. All cells are cleared of any associated data.
		
		Calls the delete function to delete each cell's data.
	*/

ZTableBoxCell ZTableBoxFindCell(ZTableBox table, void* data, ZTableBoxCell fromCell);
	/*
		Searches through the table for a cell associated with the given data.
		It returns the first cell found to contain the data.
		
		If fromCell is not NULL, then it search starting after fromCell.
		
		Search is done from top row to bottom row and from left column to
		right column; i.e. (0, 0), (1, 0), (2, 0), ... (0, 1), (1, 1), ...
	*/

ZTableBoxCell ZTableBoxGetSelectedCell(ZTableBox table, ZTableBoxCell fromCell);
	/*
		Returns the first selected cell. The search order is the same as in
		ZTableBoxFindCell().
	*/

ZTableBoxCell ZTableBoxGetCell(ZTableBox table, int16 column, int16 row);
	/*
		Returns the cell object of the table at the specified location.
		
		The returned cell object is specific to the given table. It cannot
		be used in any other manner except as provided. No two tables can
		share cells.
	*/

void ZTableBoxCellSet(ZTableBoxCell cell, void* data);
	/*
		Sets the given data to the cell.
		
		Calls the delete function to delete the old data.
	*/

void* ZTableBoxCellGet(ZTableBoxCell cell);
	/*
		Gets the data associated with the cell.
	*/

void ZTableBoxCellClear(ZTableBoxCell cell);
	/*
		Clears any data associated with the cell. Same as ZTableBoxCellSet(cell, NULL).
	*/

void ZTableBoxCellDraw(ZTableBoxCell cell);
	/*
		Draws the given cell immediately.
	*/

void ZTableBoxCellLocation(ZTableBoxCell cell, int16* column, int16* row);
	/*
		Returns the location (column, row) of the given cell within its table.
	*/

void ZTableBoxCellSelect(ZTableBoxCell cell);
	/*
		Hilights the given cell as selected.
	*/

void ZTableBoxCellDeselect(ZTableBoxCell cell);
	/*
		Unhilights the given cell as deselected.
	*/

ZBool ZTableBoxCellIsSelected(ZTableBoxCell cell);
	/*
		Returns TRUE if the given cell is selected; otherwise, FALSE.
	*/
	
ZTableBoxCell ZTableBoxEnumerate(ZTableBox table, ZBool selectedOnly,
		ZTableBoxEnumFunc enumFunc, void* userData);
	/*
		Enumerates through all the objects in the table through the
		caller supplied enumFunc enumeration function. It passes along to the
		enumeration function the caller supplied userData parameter. It stops
		enumerating when the user supplied function returns TRUE and returns
		the cell object in which the enumeration stopped.
		
		If selectedOnly is TRUE, then the enumeration is done only through the
		selected cells.
	*/



/*******************************************************************************
		OptionsButton Module
*******************************************************************************/

typedef void (*ZOptionsButtonFunc)(ZOptionsButton optionsButton, void* userData);
	/*
		Called whenever the options button is clicked.
	*/

ZOptionsButton ZOptionsButtonNew(void);
ZError ZOptionsButtonInit(ZOptionsButton optionsButton, ZWindow parentWindow,
		ZRect* buttonRect, ZOptionsButtonFunc optionsButtonFunc, void* userData);
void ZOptionsButtonDelete(ZOptionsButton optionsButton);

/*
	Creates a standard options button. When the button is clicked, optionsButtonFunc
	is called.
*/



/*******************************************************************************
		Useful Macros
*******************************************************************************/

#define MAX(a, b)			((a) >= (b) ? (a) : (b))
#define MIN(a, b)			((a) <= (b) ? (a) : (b))
#define ABS(n)				((n) < 0 ? -(n) : (n))

#define ZSetRect(pRect, l, t, r, b)	{\
										((ZRect*) pRect)->left = (int16) (l);\
										((ZRect*) pRect)->top = (int16) (t);\
										((ZRect*) pRect)->right = (int16) (r);\
										((ZRect*) pRect)->bottom = (int16) (b);\
									}

#define ZSetColor(pColor, r, g, b)		{\
											((ZColor*) pColor)->red = (r);\
											((ZColor*) pColor)->green = (g);\
											((ZColor*) pColor)->blue = (b);\
										}

#define ZDarkenColor(pColor)			{\
											((ZColor*) pColor)->red >>= 1;\
											((ZColor*) pColor)->green >>= 1;\
											((ZColor*) pColor)->blue >>= 1;\
										}

#define ZBrightenColor(pColor)			{\
											((ZColor*) pColor)->red <<= 1;\
											((ZColor*) pColor)->green <<= 1;\
											((ZColor*) pColor)->blue <<= 1;\
										}

#define ZRectWidth(rect)	((int16) ((rect)->right - (rect)->left))
#define ZRectHeight(rect)	((int16) ((rect)->bottom - (rect)->top))


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoneatl.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneATL.h
 *
 * Contents:	Zone's ATL extensions
 *
 *****************************************************************************/

#pragma once

#ifndef __ATLBASE_H__
	#error ZoneATL.h requires atlbase.h to be included first
#endif

#include "ZoneCom.h"
#include "ResourceManager.h"

//
// Zone's standard module definition
//
class CZoneComModule : public CComModule
{
private:
	IResourceManager *	m_pResMgr;
	CZoneComManager		m_zComManager;

public:	

	CZoneComModule() : m_pResMgr(NULL) 
	{
	}

	void SetResourceManager(IResourceManager * pResMgr)
	{
		m_pResMgr = pResMgr;
		m_zComManager.SetResourceManager( pResMgr );
	}

	IResourceManager * 	GetResourceManager()
	{
		return m_pResMgr;
	}

	HINSTANCE GetModuleInstance() 
	{
		return CComModule::GetModuleInstance();
	}

	HINSTANCE GetResourceInstance(LPCTSTR lpszName, LPCTSTR lpszType)
	{
		if (m_pResMgr)
			return (m_pResMgr->GetResourceInstance(lpszName, lpszType));
		else
			return CComModule::GetResourceInstance();
	}

	HINSTANCE GetResourceInstance()
	{
		return CComModule::GetResourceInstance();
	}

	HINSTANCE GetTypeLibInstance(); 

	// create a zCom object - pass through to zCom
	HRESULT Create( const TCHAR* szDll, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid, LPVOID* ppv )
	{
		return m_zComManager.Create( szDll, pUnkOuter, rclsid, riid, ppv);
	}

	// create a zCom object - pass through to zCom
	HRESULT Create( const TCHAR* szDll, REFCLSID rclsid, REFIID riid, LPVOID* ppv )
	{
		return m_zComManager.Create( szDll, NULL, rclsid, riid, ppv);
	}

//!! hmm. If we had a single instance of a zCom manager, we could have users do an zComInit, zComUnInit and
//        would then have a better idea when to free DLLs.
	// unload a zCom object - pass through to zCom
	HRESULT Unload( const TCHAR* szDll, REFCLSID rclsid )
	{
		return m_zComManager.Unload( szDll, rclsid);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonecom.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneCom.h
 * 
 * Contents:	Standard COM is overkill for most of our needs since it is
 *				designed for system-wide objects, multiple threading models,
 *				marshalling, etc.  ZoneCOM skirts these issues by loading
 *				simple COM objects directly from a DLL.
 *
 *****************************************************************************/

#ifndef _ZONECOM_H_
#define _ZONECOM_H_

#include "ZoneDef.h"
#include "ZoneError.h"
#include "ZoneDebug.h"

#pragma comment(lib, "ZoneCom.lib")


class CZoneComManager
{
public:
	ZONECALL CZoneComManager();
	ZONECALL ~CZoneComManager();

	//
	// CZoneComManager::Create
	//
	// Loads specified object and interface from Dll
	//
	// Parameters:
	//	szDll
	//		Path to Dll containing the object to load.
	//	pUnkOuter
	//		Pointer to outer unknown for aggregration.
	//	rclsid
	//		Reference to the class id of object.
	//	riid
	//		Reference to the identifier of the interface.
	//	ppv
	//		Address of output variable that receives the requested interface pointer.
	//
	HRESULT ZONECALL Create( const TCHAR* szDll, LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID riid, LPVOID* ppv );

	//
	// CZoneComManager::Unload
	//
	// Unloads object's class factory.  The Dll is also unloaded if it no
	// longer has any active objects.
	//
	// Parameters:
	//	szDll
	//		Path to Dll containg object to unload.
	//	rclsid
	//		Reference to teh class id of the object.
	//
	HRESULT ZONECALL Unload( const TCHAR* szDll, REFCLSID rclsid );

	//
	// CZoneComManager::SetResourceManager
	//
	// Set resource manager used to intialize Dlls
	//
	HRESULT ZONECALL SetResourceManager( void* pIResourceManager );

protected:

	// Standard COM entry points DllGetClassObject and DllCanUnloadNow
	typedef HRESULT (__stdcall * PFDLLGETCLASSOBJECT)( REFCLSID rclsid, REFIID riid, LPVOID* ppv );
	typedef HRESULT (__stdcall * PFDLLCANUNLOADNOW)( void );

	// ZoneCOM entry point to set Dlls resource manager
	typedef HRESULT (__stdcall * PFDLLSETRESOURCEMGR)( void* pIResourceManager );

	struct DllInfo
	{
		ZONECALL DllInfo();
		ZONECALL ~DllInfo();
		HRESULT ZONECALL Init( const TCHAR* szName, void* pIResourceManager );

		PFDLLGETCLASSOBJECT	m_pfGetClassObject;
		PFDLLCANUNLOADNOW	m_pfCanUnloadNow;
		PFDLLSETRESOURCEMGR	m_pfSetResourceManager;
		HMODULE				m_hLib;
		TCHAR*				m_szName;
		DWORD				m_dwRefCnt;
		DllInfo*			m_pNext;
		bool				m_bSetResourceManager;
	};

	struct ClassFactoryInfo
	{
		ZONECALL ClassFactoryInfo();
		ZONECALL ~ClassFactoryInfo();
		HRESULT ZONECALL Init( DllInfo* pDll, REFCLSID rclsid );

		CLSID				m_clsidObject;
		IClassFactory*		m_pIClassFactory;
		DllInfo*			m_pDll;
		ClassFactoryInfo*	m_pNext;
	};

	// manage Dll list
	DllInfo* ZONECALL FindDll( const TCHAR* szDll );
	void ZONECALL RemoveDll( DllInfo* pDll );

	// manage class factory list
	ClassFactoryInfo* ZONECALL FindClassFactory( const TCHAR* szDll, REFCLSID clsidObject );
	void ZONECALL RemoveClassFactory( ClassFactoryInfo* pClassFactory );

	DllInfo*			m_pDllList;
	ClassFactoryInfo*	m_pClassFactoryList;
	void*				m_pIResourceManager;
};

#endif // _ZONECOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonedebug.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZDebug.h
 *
 * Contents:	Debugging helper functions
 *
 *****************************************************************************/

#ifndef _ZDEBUG_H_
#define _ZDEBUG_H_

#include <windows.h>
#include <tchar.h>

#pragma comment(lib, "ZoneDebug.lib")


#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////
// Asserts
///////////////////////////////////////////////////////////////////////////////

//
// Assert handler is called when an assert is triggered.
// Return TRUE to hit a user breakpoint.
//
typedef BOOL (__stdcall *PFZASSERTHANDLER)( LPTSTR pAssertString );

//
// Transfer control to your assert handler.
// Returns returns pointer to previous assert handler.
//
extern PFZASSERTHANDLER __stdcall ZAssertSetHandler( PFZASSERTHANDLER pHandler );

//
// Returns pointer to current assert handler
//
extern PFZASSERTHANDLER __stdcall ZAssertGetHandler();

//
// Default assert handler that displays a message box with the
// assert string.
//
extern BOOL __stdcall ZAssertDefaultHandler( LPTSTR pAssertString );

//
// Top-level assert handler.  Needs to exist in debug and release
// builds since it is exported.
extern BOOL __stdcall __AssertMsg( LPTSTR exp , LPSTR file, int line );

//
// Assert macro
//
#ifdef _PREFIX_
    #define ASSERT(exp) \
        do \
        {  \
			if ( !(exp) ) \
			{ \
				ExitProcess(0); \
			} \
		} while(0)
#else
#ifdef _DEBUG
	#define ASSERT(exp) \
		do \
		{  \
			if ( !(exp) && __AssertMsg(_T(#exp), __FILE__, __LINE__)) \
			{ \
				__asm int 0x03 \
			} \
		} while(0)
#else
	#define ASSERT(exp) __assume((void *) (exp))
#endif
#endif

//
// Display error message,
// Note:	Macro is NOT disabled in release mode.  It should never be used
//			to display error message to users.
//
#define ERRORMSG(exp) \
		do \
		{  \
			if ( __AssertMsg(_T(exp), __FILE__, __LINE__)) \
			{ \
				__asm int 0x03 \
			} \
		} while(0)


///////////////////////////////////////////////////////////////////////////////
// Debug level 
///////////////////////////////////////////////////////////////////////////////

extern int __iDebugLevel;
void __cdecl SetDebugLevel( int i );


///////////////////////////////////////////////////////////////////////////////
// Debug print functions
///////////////////////////////////////////////////////////////////////////////

void __cdecl DbgOut( const char * lpFormat, ... );
#ifdef _DEBUG
	
	#define dprintf                          DbgOut
	#define dprintf1 if (__iDebugLevel >= 1) DbgOut
	#define dprintf2 if (__iDebugLevel >= 2) DbgOut
	#define dprintf3 if (__iDebugLevel >= 3) DbgOut
	#define dprintf4 if (__iDebugLevel >= 4) DbgOut
#else
    #define dprintf  if (0) ((int (*)(char *, ...)) 0)
    #define dprintf1 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf2 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf3 if (0) ((int (*)(char *, ...)) 0)
    #define dprintf4 if (0) ((int (*)(char *, ...)) 0)
#endif


///////////////////////////////////////////////////////////////////////////////
// Macros to generate compile time messages.  Use these
// with #pragma, example:
//
//		#pragma TODO( CHB, "Add this feature!" )
//		#pragma BUGBUG( CHB, "This feature is broken!" )
//
// The multiple levels of indirection are needed to get
// the line number for some unknown reason.
/////////////////////////////////////////////////////////////////////////////////

#define __PragmaMessage(e,m,t,n)	message(__FILE__ "(" #n ") : " #t ": " #e ": " m)
#define _PragmaMessage(e,m,t,n)		__PragmaMessage(e,m,t,n)

#define TODO(e,m)		_PragmaMessage(e,m,"TODO",__LINE__)
#define BUGBUG(e,m)		_PragmaMessage(e,m,"BUGBUG",__LINE__)


//Server Debug routines
#define DebugPrint _DebugPrint
void _DebugPrint(const char *format, ...);


/* -------- flags for IF_DBGPRINT ---------*/
#define DBG_RPC 0
#define DBG_CONINFO 0
#define DBG_ZSCONN  0

#ifdef _DEBUG

#define IF_DBGPRINT(flag, args)             \
do                                          \
{                                           \
    if( flag )                              \
    {                                       \
        DebugPrint args;                    \
    }                                       \
} while(0) \

#else 
#define IF_DBGPRINT(flag, args)      
#endif // def _DEBUG

extern BOOL                gDebugging ;

#ifdef __cplusplus
}
#endif


#endif // _ZDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonedef.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneDefs.h
 * 
 * Contents:	Standard data types, constants, and macros
 *
 *****************************************************************************/

#ifndef _ZONEDEF_H_
#define _ZONEDEF_H_

#include <windows.h>
#include "ZoneError.h"


///////////////////////////////////////////////////////////////////////////////
// Zone calling convention
///////////////////////////////////////////////////////////////////////////////

#define ZONECALL __stdcall


///////////////////////////////////////////////////////////////////////////////
// Data types
///////////////////////////////////////////////////////////////////////////////

typedef unsigned long		uint32;
typedef long				int32;
typedef unsigned short		uint16;
typedef short				int16;
typedef unsigned char		uchar;


///////////////////////////////////////////////////////////////////////////////
// Data types (old types for backword compatibility)
///////////////////////////////////////////////////////////////////////////////

typedef unsigned long		ZUserID;
typedef unsigned short		ZBool;
typedef long				ZError;
typedef void*				ZSConnection;



///////////////////////////////////////////////////////////////////////////////
// Common zone definitions
///////////////////////////////////////////////////////////////////////////////

#define ZONE_NOGROUP			((DWORD) -1)
#define ZONE_NOUSER				((DWORD) 0)		// consistant with zRoomNoPlayer
#define ZONE_INVALIDUSER		((DWORD) -2)
#define ZONE_INVALIDGROUP		((DWORD) -2)

#define ZONE_MaxVersionLen			16		// retail game version, i.e. version in registry
#define ZONE_MaxUserNameLen			32		// user name
#define ZONE_MaxInternalNameLen		32		// internal server name, e.g. zAEEP_xx_x00
#define ZONE_MaxPasswordLen			32		// group password
#define ZONE_MaxGameNameLen			48		// group / game name
#define ZONE_MaxChatLen				256		// chat string
#define ZONE_MaxGameDescriptionLen	128		// group / game description
#define ZONE_MaxCmdLine				256		// command line length for retail game
#define ZONE_MaxString				1024	// generic max for lazy programmers

#define ZONE_NOLCID (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT))


///////////////////////////////////////////////////////////////////////////////
// Common zone definitions (old versions for backword compatibility)
///////////////////////////////////////////////////////////////////////////////

#define zUserNameLen			31
#define zGameNameLen            63
#define zErrorStrLen            255
#define zPasswordStrLen			31
#define zHostNameLen            16
#define zMaxChatInput           255
#define zGameIDLen              31
#define zDPlayGameNameLen		31
#define zCommandLineLen			127



///////////////////////////////////////////////////////////////////////////////
// Useful inlines and macros
///////////////////////////////////////////////////////////////////////////////

__inline bool ZIsEqualGUID( const GUID& rguid1, const GUID& rguid2)
{
   return (
      ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

__inline DWORD ZEndian32( DWORD dwValue )
{
    char* c = (char *) &dwValue;
    char temp = c[0];
    c[0] = c[3];
    c[3] = temp;
    temp = c[1];
    c[1] = c[2];
    c[2] = temp;
	return *( (DWORD*) c );
}

#define NUMELEMENTS(ar)		( sizeof(ar) / sizeof(ar[0]) )

// some Windows defines that are new and require WINVER >= 0x0500
#if(WINVER < 0x0500)

#define LAYOUT_RTL                          0x00000001L
#define LAYOUT_BITMAPORIENTATIONPRESERVED   0x00000008L

#define WS_EX_LAYOUTRTL                     0x00400000L

#define GA_PARENT                           1
#define GA_ROOT                             2
#define GA_ROOTOWNER                        3

typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

#define FLASHW_STOP         0
#define FLASHW_CAPTION      0x00000001
#define FLASHW_TRAY         0x00000002
#define FLASHW_ALL          (FLASHW_CAPTION | FLASHW_TRAY)
#define FLASHW_TIMER        0x00000004
#define FLASHW_TIMERNOFG    0x0000000C

#endif


// copied straight from KB article Q163236 - UNIMODEM device specific info
// Device setting information.
typedef struct  tagDEVCFGDR  {
    DWORD       dwSize;
    DWORD       dwVersion;
    WORD        fwOptions;
    WORD        wWaitBong;
} DEVCFGHDR;

typedef struct  tagDEVCFG  {
    DEVCFGHDR   dfgHdr;
    COMMCONFIG  commconfig;
} DEVCFG, *PDEVCFG, FAR* LPDEVCFG;


#endif // _ZONEDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonecrt.h ===
/*******************************************************************************

	ZoneCRT.h
	
		Zone C RunTime.
	
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Hoon Im
	Created on December 13, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
    ----------------------------------------------------------------------------
	0		12/13/96	HI		Created.
	 
*******************************************************************************/


#ifndef _ZONECRT_
#define _ZONECRT_


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>


#ifdef __cplusplus
extern "C" {
#endif

/*
	All C RunTime routines defined here are simply wrappers to the standard
	C RunTime library provided by VC. Naming convention is to prefix the
	standard name with a 'z_'.
*/

void*	z_memcpy(void *, const void *, size_t);
int		z_memcmp(const void *, const void *, size_t);
void*	z_memset(void *, int, size_t);
void*	z_memmove(void *, const void *, size_t);
char*	z_strcpy(char *, const char *);
char*	z_strcat(char *, const char *);
int		z_strcmp(const char *, const char *);
size_t	z_strlen(const char *);
int		z_abs(int);
double	z_atof(const char *);
int		z_atoi(const char *);
long	z_atol(const char *);
char*	z_itoa(int, char *, int);
char*	z_ltoa(long, char *, int);
FILE*	z_fopen(const char *, const char *);
size_t	z_fread(void *, size_t, size_t, FILE *);
int		z_fseek(FILE *, long, int);
long	z_ftell(FILE *);
size_t	z_fwrite(const void *, size_t, size_t, FILE *);
int		z_fclose(FILE *);
int		z_feof(FILE *);
char*	z_fgets(char *, int, FILE *);
clock_t	z_clock(void);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonehelpids.h ===
/*******************************************************************************

	ZoneHelpIDs.h

		Zone help IDs.
	
	Copyright (c) Microsoft Corp. 1998. All rights reserved.
	Written by Hoon Im
	Created on 04/06/98
	 
*******************************************************************************/


#ifndef ZONEHELPIDS_H
#define ZONEHELPIDS_H


/*
	0-1023 Lobby Topics
	0 Lobby Default / TOC topic
*/
#define zLobbyHelpID			0

/*
	1024 - 2047 Chat Topics
	1024 Chat Default / TOC
	1535 Dynamic Chat Default / TOC
*/
#define zChatHelpID				1024
#define zDynamicChatHelpID		1535

/*
	2048 -3071 Setup Topics
	2048 Setup Default / TOC
*/
#define zSetupHelpID			2048

/*
	3072 - 4095 Game Topics
	3072 Game Default Topic
*/
#define zGameHelpID				3072


#endif // ZONEHELPIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoneicons.h ===
/*
    ZoneIcons.h

    File describing the Zone Icons and their use.


    Blue    -- default icon; ZoneFriends, ZSetup
    Black   -- reserved
    Brown   -- Chat, TheaterChat
    Green   -- CB Games
    Gray    -- utilities; ZSysmon
    Purple  -- Rooms (CB and retail -- lobby.exe)
    Red     -- Launchpad
    Aqua    -- ZoneMessage
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoneerror.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneError.h
 * 
 * Contents:	Zone's HRESULT definitions
 *
 *****************************************************************************/

#ifndef _ZoneError_H_
#define _ZoneError_H_

#include <windows.h>

#define MAKE_ZONE_HRESULT(code)	\
	MAKE_HRESULT(1,0x800,code)

//
// Specified file does not exist.
//
#define ZERR_FILENOTFOUND			MAKE_ZONE_HRESULT( 1 )

//
// Dll does not export required functions.
//
#define ZERR_MISSINGFUNCTION		MAKE_ZONE_HRESULT( 2 )

//
// Specified object already exisits.
//
#define ZERR_ALREADYEXISTS			MAKE_ZONE_HRESULT( 3 )

//
// Specified object was not found.
//
#define ZERR_NOTFOUND				MAKE_ZONE_HRESULT( 4 )

//
// No more objects to return.
//
#define ZERR_EMPTY					MAKE_ZONE_HRESULT( 5 )

//
// Not owner of specified object.
//
#define ZERR_NOTOWNER				MAKE_ZONE_HRESULT( 6 )

//
// Illegal recursive call.
//
#define ZERR_ILLEGALRECURSION		MAKE_ZONE_HRESULT( 7 )

//
// Class not initialized
//
#define ZERR_NOTINIT				MAKE_ZONE_HRESULT( 8 )

//
// Buffer too small
//
#define ZERR_BUFFERTOOSMALL			MAKE_ZONE_HRESULT( 9 )

//
// The data store string could not be initialized
//
#define ZERR_INIT_STRING_TABLE		MAKE_ZONE_HRESULT( 11 )

//
// The data store is not locked for enumeration.
//
#define ZERR_NOT_ENUM_LOCKED		MAKE_ZONE_HRESULT( 15 )

//
// The data store is locked the operation cannot proceed at this time.
//
#define ZERR_DATASTORE_LOCKED		MAKE_ZONE_HRESULT( 16 )

//
// The data store is already being enumerated.
//
#define ZERR_ENUM_IN_PROGRESS		MAKE_ZONE_HRESULT( 17 )

//
// There was an error reading from the registry
//
#define ZERR_QUERY_REGISTRY_KEY		MAKE_ZONE_HRESULT( 18 )

//
// The support library cannot process the specified key type
//
#define ZERR_UNSUPPORTED_KEY_TYPE	MAKE_ZONE_HRESULT( 19 )

//
// The support library cannot open the file specified.
//
#define ZERR_CANNOT_OPEN_FILE		MAKE_ZONE_HRESULT( 20 )

//
// The support library cannot parse the input text file into the data store.
//
#define ZERR_INVALID_FILE_FORMAT	MAKE_ZONE_HRESULT( 21 )

//
// The support library encountered an error reading the input text file.
//
#define ZERR_READING_FILE			MAKE_ZONE_HRESULT( 22 )

//
// The support library could not create the output text file.
//
#define ZERR_CANNOT_CREATE_FILE		MAKE_ZONE_HRESULT( 23 )

//
// The support library encountered an error writing to the output text file.
//
#define ZERR_WRITE_FILE				MAKE_ZONE_HRESULT( 24 )

//
// The support library encountered an error writing to the registry.
//
#define ZERR_CANNOT_WRITE_REGISTRY	MAKE_ZONE_HRESULT( 25 )

//
// The support library encountered an error trying to create the registry key set.
//
#define ZERR_CREATE_REGISTRY_KEY	MAKE_ZONE_HRESULT( 26 )

//
// Type mismatch
//
#define ZERR_WRONGTYPE				MAKE_ZONE_HRESULT( 27 )

#endif // _ZoneError_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoneint.h ===
/*******************************************************************************

	ZoneInt.h
	
		Zone(tm) Internal System API.
	
	Copyright  Electric Gravity, Inc. 1995. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Saturday, April 29, 1995 06:26:45 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		04/29/95	HI		Created.
	 
*******************************************************************************/


#ifndef _ZONEINT_
#define _ZONEINT_


#ifndef _ZTYPES_
#include "ztypes.h"
#endif

#ifndef _ZONE_
#include "zone.h"
#endif


/* -------- Processor Types -------- */
enum
{
	zProcessor68K = 1,						/* Motorola 680x0 */
	zProcessorPPC,							/* PowerPC RISC */
	zProcessor80x86							/* Intel 80x86 */
};

/* -------- OS Types -------- */
enum
{
	zOSMacintosh = 1,						/* Macintosh OS */
	zOSWindows31,							/* Microsoft Windows3.1 */
	zOSWindowsNT,
	zOSWindows95,
	zOSUnixLinux
};

/* -------- Group IDs -------- */
#include "user_prefix.h"


#ifdef __cplusplus
extern "C" {
#endif


/*******************************************************************************
		Private File Routines
*******************************************************************************/
ZImage ZCreateImageFromFileOffset(char* fileName, int32 fileOffset);
ZAnimation ZCreateAnimationFromFileOffset(char* fileName, int32 fileOffset);
ZSound ZCreateSoundFromFileOffset(char* fileName, int32 fileOffset);
	/*
		The above routines create an object from the existing object descriptor
		at fileOffset in the given file. If fileOffset is -1, then it creates
		the object from the first object descriptor found in the file.
	*/


/*******************************************************************************
		Private ZAnimation Routines
*******************************************************************************/
ZAnimation ZAnimationCreateFromFile(TCHAR* fileName, int32 fileOffset);


/*******************************************************************************
		Private System Routines
*******************************************************************************/
ZError ZLaunchProgram(char* programName, char* programFileName, uchar* commandLineData);
	/*
		Runs the program called programName from the file programFileName. If programName
		is already running, it simply brings this process to the foreground. Otherwise,
		it runs an instance of programFileName as programName and passes commandLineData
		as command line.
	*/

ZError ZTerminateProgram(char* programName, char* programFileName);
	/*
		Terminates the program called programName, an instance of programFileName.
	*/

ZBool ZProgramExists(char* programFileName);
	/*
		Determines whether the given program exists and returns TRUE if so.
	*/

ZBool ZProgramIsRunning(char* programName, char* programFileName);
	/*
		Returns TRUE if the program programName is already running from programFileName.
		This call is system dependent on whether the system supports multiple instances of
		a program or not (ZSystemHasMultiInstanceSupport). If it does, then it checks for
		the programName of the instance. If not, it checks for an instance of programFileName.
		
		If programName is NULL, then it checks for an instance of programFileName only.
	*/

ZBool ZSystemHasMultiInstanceSupport(void);
	/*
		Returns TRUE if the system can spawn multiple instances of a program from one
		program file.
	*/

uint16 ZGetProcessorType(void);
	/*
		Returns the processor type of the running machine.
	*/

uint16 ZGetOSType(void);
	/*
		Returns the running OS type.
	*/

TCHAR* ZGenerateDataFileName(TCHAR* programName, TCHAR* dataFileName);
	/*
		Returns a file path name to the specified program and data file within the
		Zone(tm) directory structure.
		
		NOTE: The caller must not free the returned pointer. The returned pointer
		is a static global within the system library.
	*/



/*******************************************************************************
		Common Library Routines
*******************************************************************************/
typedef void (*ZCommonLibExitFunc)(void* userData);
	/*
		Function called by ZCommonLibExit() to clean up common library storage.
	*/

typedef void (*ZCommonLibPeriodicFunc)(void* userData);
	/*
		Function called regularly for common library to do periodic processing.
	*/

ZError ZCommonLibInit(void);
	/*
		Called by the system lib to initialize the common library. If it returns
		an error, then the system lib terminates the program.
	*/
	
void ZCommonLibExit(void);
	/*
		Called by the system lib just before quitting to clean up the common library.
	*/
	
void ZCommonLibInstallExitFunc(ZCommonLibExitFunc exitFunc, void* userData);
	/*
		Installs an exit function to be called by ZCommonLibExit(). It allows
		common lib modules to easily clean themselves up.
	*/
	
void ZCommonLibRemoveExitFunc(ZCommonLibExitFunc exitFunc);
	/*
		Removes an installed exit function.
	*/
	
void ZCommonLibInstallPeriodicFunc(ZCommonLibPeriodicFunc periodicFunc,
		void* userData);
	/*
		Installs a periodic function to be called at regular intervals. This
		simply makes it easier for common lib modules to do periodic processing
		without the need to implement one of their own.
	*/
	
void ZCommonLibRemovePeriodicFunc(ZCommonLibPeriodicFunc periodicFunc);
	/*
		Removes an installed periodic function.
	*/



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoneresids.h ===
/*******************************************************************************

	ResIDs.h

		Zone resource IDs.
	
	Copyright (c) Microsoft Corp. 1998. All rights reserved.
	Written by Hoon Im
	Created on 02/15/98
	 
*******************************************************************************/


#ifndef RESIDS_H
#define RESIDS_H


/*
	Logo image resource ID.
*/
#define IDB_LOGO			100


/*
	Zone icon resource ID.
*/
#define IDI_ZONE_ICON		100


#endif // RESIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonemem.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneMem.h
 *
 * Contents:	Zone's allocation wrappers
 *
 *****************************************************************************/

#ifndef _ZONEMEM_H_
#define _ZONEMEM_H_

#pragma comment(lib, "ZoneMem.lib")


#include "ZoneDef.h"

#ifdef __cplusplus
extern "C" {
#endif

//
// stdlib wrappers
//
void* ZONECALL ZMalloc( size_t size );
void* ZONECALL ZCalloc( size_t num, size_t size );
void* ZONECALL ZRealloc( void* ptr, size_t size );
void  ZONECALL ZFree(void* ptr);
void  ZONECALL ZMemValidate(void* ptr);
size_t ZONECALL ZMemSize(void* ptr);

#ifdef __cplusplus
}
#endif


//
// c++ wrappers
//
void* ZONECALL _zone_new( size_t sz );
inline void* __cdecl operator new( size_t sz )	{ return _zone_new(sz); }
void  __cdecl operator delete (void * pInstance );


//
// New & delete tags for memory types.  Normally this should be in the
// private sentinal.h, but CPool<T> is inlined for speed and needs
// this information.
//
#pragma pack( push, 4 )

#define POOL_HEAP_BLOB				-1
#define POOL_POOL_BLOB				-2
#define POOL_ALREADY_FREED			-3

struct GenericPoolBlobHeader
{
    long m_Tag;
    long m_Val;
};

#pragma pack( pop )


#endif // _ZONEMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonelocks.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneLocks.h
 * 
 * Contents:	Thread syncronization helper classes
 *
 *****************************************************************************/

#ifndef _ZONELOCKS_H_
#define _ZONELOCKS_H_


///////////////////////////////////////////////////////////////////////////////
// Critical section wrapper
///////////////////////////////////////////////////////////////////////////////

class CCriticalSection
{
public:
	CCriticalSection() : m_nLockCnt( 0 )
	{
		InitializeCriticalSection( &m_csLock );
	}


	~CCriticalSection()
	{
		DeleteCriticalSection( &m_csLock );
	}


    __forceinline void Lock()
	{
		EnterCriticalSection( &m_csLock );
		InterlockedIncrement( &m_nLockCnt );
	}


    __forceinline void Unlock()
	{
		LeaveCriticalSection( &m_csLock );
		InterlockedDecrement( &m_nLockCnt );
	}


	__forceinline bool IsLocked()
	{
		return (m_nLockCnt > 0);
	}

private:
    CRITICAL_SECTION	m_csLock;
	long				m_nLockCnt;
};


///////////////////////////////////////////////////////////////////////////////
// Multiple reader, single writer
///////////////////////////////////////////////////////////////////////////////

class CReaderWriterLock
{
public:
	CReaderWriterLock()	: m_nReaderCount( 0 )	{}

	__forceinline void LockReader()
	{
		m_csWriterLock.Lock();
		InterlockedIncrement( &m_nReaderCount );
		m_csWriterLock.Unlock();
	}


	__forceinline void LockWriter()
	{
		m_csWriterLock.Lock();
		while (m_nReaderCount > 0)
			Sleep( 0 );
	}


	__forceinline void UnlockReader()
	{
		InterlockedDecrement( &m_nReaderCount );
	}


	__forceinline void UnlockWriter()
	{
		m_csWriterLock.Unlock();
	}

private:
	CCriticalSection	m_csWriterLock;
	long				m_nReaderCount;
};


///////////////////////////////////////////////////////////////////////////////
// AutoLock wrappers
///////////////////////////////////////////////////////////////////////////////

class CAutoLockCS
{
public:
	CAutoLockCS( CRITICAL_SECTION* pCS )		{ EnterCriticalSection( m_pLock = pCS ); }
	~CAutoLockCS()								{ LeaveCriticalSection( m_pLock ); }

private:
	CAutoLockCS() {}
	CRITICAL_SECTION*	m_pLock;
};

/////////

class CAutoLock
{
public:
	CAutoLock( CCriticalSection* pLock )	{ (m_pLock = pLock)->Lock(); }
	~CAutoLock()							{ m_pLock->Unlock(); }

private:
	CAutoLock() {}
	CCriticalSection* m_pLock;
};

/////////

class CAutoReaderLock
{
public:
	CAutoReaderLock( CReaderWriterLock* pLock )	{ (m_pLock = pLock)->LockReader(); }
	~CAutoReaderLock()							{ m_pLock->UnlockReader(); }

private:
	CAutoReaderLock() {}
	CReaderWriterLock* m_pLock;
};

class CAutoWriterLock
{
public:
	CAutoWriterLock( CReaderWriterLock* pLock )	{ (m_pLock = pLock)->LockWriter(); }
	~CAutoWriterLock()							{ m_pLock->UnlockWriter(); }

private:
	CAutoWriterLock() {}
	CReaderWriterLock* m_pLock;
};


#endif // _ZONELOCKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonelobby.h ===
/***************************************************************************
 *
 *  Copyright (c) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:    ZoneLobby.h
 *  Content: Internet Gaming Zone supplement to dplobby.h include file.
 *
 *  WARNING: This header file is under development and subject to change.
 *
 ***************************************************************************/


#ifndef __zonescore_h__
#define __zonescore_h__

#ifdef __cplusplus
extern "C" {
#endif

//
// ZONEPROPERTY_LobbyGuid3
//
// Identifying GUID for IGZ Lobby v3.0.  See DPLPROPERTY_LobbyGuid.
//
// {BDD4B95C-D35C-11d0-B625-00C04FC33EA1}
DEFINE_GUID(ZONEPROPERTY_LobbyGuid3, 
0xbdd4b95c, 0xd35c, 0x11d0, 0xb6, 0x25, 0x0, 0xc0, 0x4f, 0xc3, 0x3e, 0xa1);


//
// ZONEPROPERTY_LobbyOptions
//
// Used to set lobby options for the game session.
//
// Property data is a single DWORD.
//
// {33B64CA7-D8EB-11d0-B62B-00C04FC33EA1}
DEFINE_GUID(ZONEPROPERTY_GameOptions, 
0x33b64ca7, 0xd8eb, 0x11d0, 0xb6, 0x2b, 0x0, 0xc0, 0x4f, 0xc3, 0x3e, 0xa1);


//
// Allow players to join the game session. (DEFAULT)
//
#define ZOPTION_ALLOW_JOINERS		0x00000001

//
// Bar any more players to join the game session.
//
#define ZOPTION_DISALLOW_JOINERS	0x00000002


//
// ZONEPROPERTY_GameState
//
// Informs lobby of game's current state.  The lobby uses this
// information to decide when to clear / save game defined
// properties (e.g., scores).
//
// If multiple games are played within a single direct play session, the
// application MUST send this property.  It is optional, although strongly
// recommended, if the game only allows a single play per session.
//
// Property data is a single DWORD.
//
// {BDD4B95F-D35C-11d0-B625-00C04FC33EA1}
DEFINE_GUID(ZONEPROPERTY_GameState, 
0xbdd4b95f, 0xd35c, 0x11d0, 0xb6, 0x25, 0x0, 0xc0, 0x4f, 0xc3, 0x3e, 0xa1);

//
// The Gameplay has actually started should not be confused with ZSTATE_START_STAGING
// 
//
#define ZSTATE_START	0x00000001

//
// Game is over and all the properties (e.g., scores) are final.  Once this
// state has been sent, the application should not send any more game defined
// defined properties until it sends a ZSTART_START property.
//
#define ZSTATE_END		0x00000002

//
// Game has entered the "staging" point. Where all the players "meet" before the game 
// begins after they have been launched from the zone.
// 
//
#define ZSTATE_STARTSTAGING	0x00000004

//
// ZONEPROPERTY_GameNewHost
//
// Informs the lobby of host migration.  The client setting the property
// is assumed to be taking on the role of host.
//
// There is not property data
//
// {058ebd64-1373-11d1-968f-00c04fc2db04}
DEFINE_GUID(ZONEPROPERTY_GameNewHost,
0x058ebd64, 0x1373, 0x11d1, 0x96, 0x8f, 0x0, 0xc0, 0x4f, 0xc2, 0xdb, 0x04);


#ifdef __cplusplus
};
#endif /* __cplusplus */

/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ZoneScore.h
 *  Content:    Internet Gaming Zone Generic Scoring API.
 ***************************************************************************/


/****************************************************************************
 *
 * IZoneScore Constants
 *
 * Various constants used in invoking ZoneScore.
 *
 ****************************************************************************/

#define ZONESCORE_MIN_PLAYERS		2
#define ZONESCORE_MAX_PLAYERS 		255		//max players per game 32 is reasonable high for the internet
#define ZONESCORE_MIN_NAME_LEN  	1		//Minimum length of a user name
#define ZONESCORE_MAX_NAME_LEN 		32		//max zone name length 
#define ZONESCORE_MAX_DESC_LEN 		1024		//description length

//Player status codes
#define ZONESCORE_JOININPROGRESS  	0x001	//The use joined the game inprogress
#define ZONESCORE_WINNER 			0x002	//Game Winner
#define ZONESCORE_LOSER 			0x004	//Game Loser
#define ZONESCORE_TIE 				0x008	//Tie Game
#define ZONESCORE_DISCONNECTED 		0x010	//The user's network connection was lost
#define ZONESCORE_BOOTED 			0x020	//The user was kicked out by the host/other players
#define ZONESCORE_QUITNOTLOGGED     0x040   //The user quick don't log his score
#define ZONESCORE_COMPUTERPLAYER 	0x080	//This player is a bot.
#define ZONESCORE_RESIGNED 			0x100	//This player resigned.
#define ZONESCORE_OBSERVER			0x200	//This player is an observer or kibitzer. Don't rank.
#define ZONESCORE_RANKED_ASCENDING  0x400	//This game is ranked by score - accending order
#define ZONESCORE_RANKED_DESCENDING 0x800	//This game is ranked by score - decending order
#define ZONESCORE_WINLOSSTIE		0x8000  //This game is determined by the win/loss/tie flags

#define ZONESCORE_NO_TEAM 		(-1)		//constant for no teams
#define ZONESCORE_NULL_TIME     ((DWORD)(-1))    //initial value for time

#define ZONESCORE_MAX_EXTBUFF     4096   //maximum amount of appended data. note this is only for the GetMaxBufferSize()
										  //function there is really no maximum

enum {
	ZONESCORE_NO_SCORE= 0,
	ZONESCORE_INTEGER,
	ZONESCORE_FLOATING,
	ZONESCORE_CURRENCY
};

//These constants are used by the SendData function.  Developers can also use the wrapper functions
//SendFinal() And SendStatus() which hide this parameter.
#define ZONESCORE_NOMSG				0x000
#define ZONESCORE_SENDSTATUS		0x001
#define ZONESCORE_SENDFINAL			0x002
#define ZONESCORE_SENDGAMESETTINGS 	0x004  	//Just updates the games settings

/****************************************************************************
 *
 * IZoneScore Interfaces and Structures
 *
 * Various structures used to invoke ZoneScore.
 *
 ****************************************************************************/


/****************************************************************************
 *
 * IZoneScore Internal Constants
 *
 * Internal Constants DO NOT USE
 *
 ****************************************************************************/
#define ZONESCORE_INGAME			0x1000	//Do not use this flag
#define ZONESCORE_NOTINGAME 		0x2000	//Do not use this flag
#define ZONESCORE_INPROGRESS 		0x4000  //The game is in progress


// {3FAF0AFD-B48B-11D2-8A51-00C04F8EF4E9}
DEFINE_GUID(IID_IZoneScore,
0x3FAF0AFD,0xB48B, 0x11D2, 0x8A, 0x51, 0x00, 0xC0, 0x4F, 0x8E, 0xF4, 0xE9);

/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ZoneScoreClient_h__
#define __ZoneScoreClient_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IZoneScore_FWD_DEFINED__
#define __IZoneScore_FWD_DEFINED__
typedef interface IZoneScore IZoneScore;
#endif 	/* __IZoneScore_FWD_DEFINED__ */


#ifndef __ZoneScore_FWD_DEFINED__
#define __ZoneScore_FWD_DEFINED__

#ifdef __cplusplus
typedef class ZoneScore ZoneScore;
#else
typedef struct ZoneScore ZoneScore;
#endif /* __cplusplus */

#endif 	/* __ZoneScore_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IZoneScore_INTERFACE_DEFINED__
#define __IZoneScore_INTERFACE_DEFINED__

/* interface IZoneScore */
/* [unique][helpstring][local][uuid][object] */ 


EXTERN_C const IID IID_IZoneScore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3FAF0AFD-B48B-11D2-8A51-00C04F8EF4E9")
    IZoneScore : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            REFGUID guid,
            DWORD dNumPlayers,
            BOOL bCheatsEnabled,
            BOOL bTeams,
            DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPlayer( 
            DWORD seat,
            LPSTR szName,
            double nScore,
            DWORD team,
            DWORD flags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetGameOptions( 
            DWORD dwTime,
            LPSTR szGameOptions) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetExtended( 
            LPVOID pData,
            DWORD cbSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendData( 
            IUnknown __RPC_FAR *pIDirectPlayLobbySession,
            DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPlayerScore( 
            DWORD dwSeat,
            double nScore) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPlayerTeam( 
            DWORD dwSeat,
            DWORD dwTeam) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPlayerFlags( 
            DWORD dwSeat,
            DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPlayerName( 
            DWORD dwPlayer,
            LPSTR szName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddNewPlayer( 
            LPSTR szName,
            double nScore,
            DWORD team,
            DWORD flags,
            DWORD __RPC_FAR *dwPlayer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendGameState( 
            IUnknown __RPC_FAR *pIDirectPlayLobbySession,
            DWORD dwFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendScoreUpdate( 
            IUnknown __RPC_FAR *pIDirectPlayLobbySession) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendFinalScore( 
            IUnknown __RPC_FAR *pIDirectPlayLobbySession) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendGameOptions( 
            IUnknown __RPC_FAR *pIDirectPlayLobbySession) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IZoneScoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IZoneScore __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IZoneScore __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IZoneScore __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )
( 
            IZoneScore __RPC_FAR * This,
            REFGUID guid,
            DWORD dNumPlayers,
            BOOL bCheatsEnabled,
            BOOL bTeams,
            DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPlayer )( 
            IZoneScore __RPC_FAR * This,
            DWORD seat,
            LPSTR szName,
            double nScore,
            DWORD team,
            DWORD flags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SetGameOptions )( 
            IZoneScore __RPC_FAR * This,
            DWORD dwTime,
            LPSTR szGameOptions);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExtended 
)( 
            IZoneScore __RPC_FAR * This,
            LPVOID pData,
            DWORD cbSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendData )( 
            IZoneScore __RPC_FAR * This,
            IUnknown __RPC_FAR *pIDirectPlayLobbySession,
            DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SetPlayerScore )( 
            IZoneScore __RPC_FAR * This,
            DWORD dwSeat,
            double nScore);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SetPlayerTeam )( 
            IZoneScore __RPC_FAR * This,
            DWORD dwSeat,
            DWORD dwTeam);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SetPlayerFlags )( 
            IZoneScore __RPC_FAR * This,
            DWORD dwSeat,
            DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SetPlayerName )( 
            IZoneScore __RPC_FAR * This,
            DWORD dwPlayer,
            LPSTR szName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
AddNewPlayer )( 
            IZoneScore __RPC_FAR * This,
            LPSTR szName,
            double nScore,
            DWORD team,
            DWORD flags,
            DWORD __RPC_FAR *dwPlayer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SendGameState )( 
            IZoneScore __RPC_FAR * This,
            IUnknown __RPC_FAR *pIDirectPlayLobbySession,
            DWORD dwFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SendScoreUpdate )( 
            IZoneScore __RPC_FAR * This,
            IUnknown __RPC_FAR *pIDirectPlayLobbySession);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SendFinalScore )( 
            IZoneScore __RPC_FAR * This,
            IUnknown __RPC_FAR *pIDirectPlayLobbySession);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *
SendGameOptions )( 
            IZoneScore __RPC_FAR * This,
            IUnknown __RPC_FAR *pIDirectPlayLobbySession);
        
        END_INTERFACE
    } IZoneScoreVtbl;

    interface IZoneScore
    {
        CONST_VTBL struct IZoneScoreVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IZoneScore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IZoneScore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IZoneScore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IZoneScore_Initialize(This,guid,dNumPlayers,bCheatsEnabled,bTeams,
dwFlags)	\
    (This)->lpVtbl -> Initialize(This,guid,dNumPlayers,bCheatsEnabled,bTeams,
dwFlags)

#define IZoneScore_SetPlayer(This,seat,szName,nScore,team,flags)	\
    (This)->lpVtbl -> SetPlayer(This,seat,szName,nScore,team,flags)

#define IZoneScore_SetGameOptions(This,dwTime,szGameOptions)	\
    (This)->lpVtbl -> SetGameOptions(This,dwTime,szGameOptions)

#define IZoneScore_SetExtended(This,pData,cbSize)	\
    (This)->lpVtbl -> SetExtended(This,pData,cbSize)

#define IZoneScore_SendData(This,pIDirectPlayLobbySession,dwFlags)	\
    (This)->lpVtbl -> SendData(This,pIDirectPlayLobbySession,dwFlags)

#define IZoneScore_SetPlayerScore(This,dwSeat,nScore)	\
    (This)->lpVtbl -> SetPlayerScore(This,dwSeat,nScore)

#define IZoneScore_SetPlayerTeam(This,dwSeat,dwTeam)	\
    (This)->lpVtbl -> SetPlayerTeam(This,dwSeat,dwTeam)

#define IZoneScore_SetPlayerFlags(This,dwSeat,dwFlags)	\
    (This)->lpVtbl -> SetPlayerFlags(This,dwSeat,dwFlags)

#define IZoneScore_SetPlayerName(This,dwPlayer,szName)	\
    (This)->lpVtbl -> SetPlayerName(This,dwPlayer,szName)

#define IZoneScore_AddNewPlayer(This,szName,nScore,team,flags,dwPlayer)	\
    (This)->lpVtbl -> AddNewPlayer(This,szName,nScore,team,flags,dwPlayer)

#define IZoneScore_SendGameState(This,pIDirectPlayLobbySession,dwFlags)	\
    (This)->lpVtbl -> SendGameState(This,pIDirectPlayLobbySession,dwFlags)

#define IZoneScore_SendScoreUpdate(This,pIDirectPlayLobbySession)	\
    (This)->lpVtbl -> SendScoreUpdate(This,pIDirectPlayLobbySession)

#define IZoneScore_SendFinalScore(This,pIDirectPlayLobbySession)	\
    (This)->lpVtbl -> SendFinalScore(This,pIDirectPlayLobbySession)

#define IZoneScore_SendGameOptions(This,pIDirectPlayLobbySession)	\
    (This)->lpVtbl -> SendGameOptions(This,pIDirectPlayLobbySession)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_Initialize_Proxy( 
    IZoneScore __RPC_FAR * This,
    REFGUID guid,
    DWORD dNumPlayers,
    BOOL bCheatsEnabled,
    BOOL bTeams,
    DWORD dwFlags);


void __RPC_STUB IZoneScore_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetPlayer_Proxy( 
    IZoneScore __RPC_FAR * This,
    DWORD seat,
    LPSTR szName,
    double nScore,
    DWORD team,
    DWORD flags);


void __RPC_STUB IZoneScore_SetPlayer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetGameOptions_Proxy( 
    IZoneScore __RPC_FAR * This,
    DWORD dwTime,
    LPSTR szGameOptions);


void __RPC_STUB IZoneScore_SetGameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetExtended_Proxy( 
    IZoneScore __RPC_FAR * This,
    LPVOID pData,
    DWORD cbSize);


void __RPC_STUB IZoneScore_SetExtended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SendData_Proxy( 
    IZoneScore __RPC_FAR * This,
    IUnknown __RPC_FAR *pIDirectPlayLobbySession,
    DWORD dwFlags);


void __RPC_STUB IZoneScore_SendData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetPlayerScore_Proxy( 
    IZoneScore __RPC_FAR * This,
    DWORD dwSeat,
    double nScore);


void __RPC_STUB IZoneScore_SetPlayerScore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetPlayerTeam_Proxy( 
    IZoneScore __RPC_FAR * This,
    DWORD dwSeat,
    DWORD dwTeam);


void __RPC_STUB IZoneScore_SetPlayerTeam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetPlayerFlags_Proxy( 
    IZoneScore __RPC_FAR * This,
    DWORD dwSeat,
    DWORD dwFlags);


void __RPC_STUB IZoneScore_SetPlayerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SetPlayerName_Proxy( 
    IZoneScore __RPC_FAR * This,
    DWORD dwPlayer,
    LPSTR szName);


void __RPC_STUB IZoneScore_SetPlayerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_AddNewPlayer_Proxy( 
    IZoneScore __RPC_FAR * This,
    LPSTR szName,
    double nScore,
    DWORD team,
    DWORD flags,
    DWORD __RPC_FAR *dwPlayer);


void __RPC_STUB IZoneScore_AddNewPlayer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SendGameState_Proxy( 
    IZoneScore __RPC_FAR * This,
    IUnknown __RPC_FAR *pIDirectPlayLobbySession,
    DWORD dwFlags);


void __RPC_STUB IZoneScore_SendGameState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SendScoreUpdate_Proxy( 
    IZoneScore __RPC_FAR * This,
    IUnknown __RPC_FAR *pIDirectPlayLobbySession);


void __RPC_STUB IZoneScore_SendScoreUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SendFinalScore_Proxy( 
    IZoneScore __RPC_FAR * This,
    IUnknown __RPC_FAR *pIDirectPlayLobbySession);


void __RPC_STUB IZoneScore_SendFinalScore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IZoneScore_SendGameOptions_Proxy( 
    IZoneScore __RPC_FAR * This,
    IUnknown __RPC_FAR *pIDirectPlayLobbySession);


void __RPC_STUB IZoneScore_SendGameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IZoneScore_INTERFACE_DEFINED__ */



#ifndef __ZONESCORECLIENTLib_LIBRARY_DEFINED__
#define __ZONESCORECLIENTLib_LIBRARY_DEFINED__

/* library ZONESCORECLIENTLib */
/* [helpstring][version][uuid] */ 


//{3FAF0AF1-B48B-11D2-8A51-00C04F8EF4E9}
DEFINE_GUID(LIBID_ZONESCORECLIENTLib, 
0x3FAF0AF1,0xB48B,0x11D2,0x8A,0x51,0x00,0xC0,0x4F,0x8E,0xF4,0xE9);

//{3FAF0AFE-B48B-11D2-8A51-00C04F8EF4E9}
DEFINE_GUID(CLSID_ZoneScore,
0x3FAF0AFE,0xB48B,0x11D2,0x8A,0x51,0x00,0xC0,0x4F,0x8E,0xF4,0xE9);

#ifdef __cplusplus
#endif
#endif /* __ZONESCORECLIENTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif


#endif __zonescore_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zone_ver.inc ===
1.3.614.1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonestring.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneString.h
 *
 * Contents:	String related functions
 *
 *****************************************************************************/

#ifndef ZONESTRING_H_
#define ZONESTRING_H_


#pragma comment(lib, "ZoneString.lib")

//#include <BasicATL.h>

#include <windows.h>
#include <limits.h>
#include <stdio.h>
#include "ZoneDef.h"
#include "ZoneDebug.h"

#ifndef ZONE_MAXSTRING
#define ZONE_MAXSTRING	1024  // Helpful stringlength def
#endif


///////////////////////////////////////////////////////////////////////////////
// Character manipulations and classication
// ASCII (Fast)
//////////////////////////////////////////////////////////////////////////////

#define _UPPER          0x1		// upper case letter
#define _LOWER          0x2		// lower case letter
#define _DIGIT          0x4		// digit[0-9]
#define _SPACE          0x8		// tab, carriage return, newline, vertical tab or form feed
#define _PUNCT          0x10	// punctuation character
#define _CONTROL        0x20	// control character
#define _BLANK          0x40	// space char
#define _HEX            0x80	// hexadecimal digit

extern unsigned char g_IsTypeLookupTableA[];
extern WCHAR 		 g_IsTypeLookupTableW[];

#define ISALPHA(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & (_UPPER|_LOWER) )
#define ISUPPER(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & _UPPER )
#define ISLOWER(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & _LOWER )
#define ISDIGIT(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & _DIGIT )
#define ISXDIGIT(_c)    ( g_IsTypeLookupTableA[(BYTE)(_c)] & _HEX )


#define ISSPACEA(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & _SPACE )
#define ISSPACEW(_c)     ( g_IsTypeLookupTableW[(_c & 0xFF)] & _SPACE )

#ifdef UNICODE
#define ISSPACE ISSPACEW
#else
#define ISSPACE ISSPACEA
#endif

#define ISPUNCT(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & _PUNCT )
#define ISALNUM(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & (_UPPER|_LOWER|_DIGIT) )
#define ISPRINT(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & (_BLANK|_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define ISGRAPH(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & (_PUNCT|_UPPER|_LOWER|_DIGIT) )
#define ISCNTRL(_c)     ( g_IsTypeLookupTableA[(BYTE)(_c)] & _CONTROL )

extern char g_ToLowerLookupTable[];
#define TOLOWER(_c)		( g_ToLowerLookupTable[(BYTE)(_c)] )


///////////////////////////////////////////////////////////////////////////////
// ASCII
///////////////////////////////////////////////////////////////////////////////

// Trims trailing spaces
char* ZONECALL strrtrimA(char* str);
WCHAR* ZONECALL strrtrimW(WCHAR* str);


#ifdef UNICODE
#define strrtrim strrtrimW
#else
#define strrtrim strrtrimA
#endif

// Trims leading spaces, returns pointer to first non space.
char* ZONECALL strltrimA(char* str);
WCHAR* ZONECALL strltrimW(WCHAR* str);


#ifdef UNICODE
#define strltrim strltrimW
#else
#define strltrim strltrimA
#endif


// Return whether a string is empty or not
bool ZONECALL stremptyA(char *str);
bool ZONECALL stremptyW(WCHAR *str);


#ifdef UNICODE
#define strempty stremptyW
#else
#define strempty stremptyA
#endif

// Trims leading and trailing spaces, returns pointer to first non space.
char* ZONECALL strtrimA(char* str);
WCHAR* ZONECALL strtrimW(WCHAR* str);

#ifdef UNICODE
#define strtrim strtrimW
#else
#define strtrim strtrimA
#endif


// Convert string to long
long ZONECALL zatolW(LPCWSTR nptr);
long ZONECALL zatolA(LPCSTR nptr);

#ifdef UNICODE
#define zatol zatolW
#else
#define zatol zatolA
#endif


// Converts a comma delimited list into an array of pointers.
bool ZONECALL StringToArrayA( char* szInput, char** arItems, DWORD* pnElts );
bool ZONECALL StringToArrayW( WCHAR* szInput, WCHAR** arItems, DWORD* pnElts );


#ifdef UNICODE
#define StringToArray StringToArrayW
#else
#define StringToArray StringToArrayA
#endif


///////////////////////////////////////////////////////////////////////////////
// Make Format Message Useful
///////////////////////////////////////////////////////////////////////////////

inline DWORD __cdecl ZoneFormatMessage(LPCTSTR pszFormat, LPTSTR pszBuffer,DWORD size,  ...)
    {
    	va_list vl;
		va_start(vl,size);
		DWORD result=FormatMessage(FORMAT_MESSAGE_FROM_STRING,pszFormat,0,GetUserDefaultLangID(),pszBuffer,size,&vl);
		va_end(vl);

		return result;			
    }


///////////////////////////////////////////////////////////////////////////////
// User Name manipulateion (ASCII)
///////////////////////////////////////////////////////////////////////////////

// returns group id based on user name prefix
long ZONECALL ClassIdFromUserNameA( const char* szUserName );
long ZONECALL ClassIdFromUserNameW( const WCHAR* szUserName );
#ifdef UNICODE
#define ClassIdFromUserName ClassIdFromUserNameW
#else
#define ClassIdFromUserName ClassIdFromUserNameA
#endif


// Get username without leading special chars
const char* ZONECALL GetActualUserNameA( const char *str );
const WCHAR* ZONECALL GetActualUserNameW( const WCHAR *str );
#ifdef UNICODE
#define GetActualUserName GetActualUserNameW
#else
#define GetActualUserName GetActualUserNameA
#endif


// Hashes user name, ignoring leading character
DWORD ZONECALL HashUserName( const char* szUserName );

// Compares user name, ignoring leading character
bool ZONECALL CompareUserNamesA( const char* szUserName1, const char* szUserName2 );
bool ZONECALL CompareUserNamesW( const WCHAR* szUserName1, const WCHAR* szUserName2 );

#ifdef UNICODE
#define CompareUserNames CompareUserNamesW
#else
#define CompareUserNames CompareUserNamesA
#endif




///////////////////////////////////////////////////////////////////////////////
// ASCII, UNICODE
///////////////////////////////////////////////////////////////////////////////

// Find first occurance of ch in pString
CHAR* ZONECALL FindCharA(CHAR* pString, const CHAR ch);
WCHAR* ZONECALL FindCharW(WCHAR* pString, const WCHAR ch);


#ifdef UNICODE
#define FindChar FindCharW
#else
#define FindChar FindCharA
#endif

// Find last occurance of ch in pString
CHAR* ZONECALL FindLastCharA(CHAR* pString, const CHAR ch);
WCHAR* ZONECALL FindLastCharW(WCHAR* pString, const WCHAR ch);



#ifdef UNICODE
#define FindLastChar FindCharW
#else
#define FindLastChar FindCharA
#endif


// Find substring, case insensitive
const TCHAR* ZONECALL StrInStrI(const TCHAR* mainStr, const TCHAR* subStr);

inline void StrToLowerA( char* str )
{
    while ( *str )
        *str++ = TOLOWER(*str);
}


// Converts IP address in x86 byte order to XXX.XXX.XXX.XXX format.  szOut needs to
// be at least 16 characters wide.
TCHAR* ZONECALL AddressToString( DWORD dwAddress, TCHAR* szOut );

// load string resource
int ZONECALL ZResLoadString(HINSTANCE hInstance, UINT nID, LPTSTR lpszBuf, UINT nMaxBuf);

// Parse string of form key1=<data1>key2=<data2>.
bool ZONECALL TokenGetKeyValue(const TCHAR* szKey, const TCHAR* szInput, TCHAR* szOut, int cchOut );
bool ZONECALL TokenGetKeyValueA(const char* szKey, const char* szInput, char* szOut, int cchOut );


// Given a token data (must contain substring of "server=<server adress : server port>"),
// returns the server address string (null terminated) and the server port.
bool ZONECALL TokenGetServer(const TCHAR* szInput, TCHAR* szServer, DWORD cchServer, DWORD* pdwPort );


int CopyW2A( LPSTR pszDst, LPCWSTR pszSrc );
int CopyA2W( LPWSTR pszDst, LPCSTR pszStr );

#ifdef UNICODE
#define lstrcpyW2T( dst, src )     lstrcpy( dst, src )
#define lstrcpyT2W( dst, src )     lstrcpy( dst, src )

#define lstrcpyW2A( dst, src )     CopyW2A( dst, src )
#define lstrcpyT2A( dst, src )     CopyW2A( dst, src )

#else
#define lstrcpyW2T( dst, src )     CopyW2A( dst, src )
#define lstrcpyT2W( dst, src )     CopyA2W( dst, src )

#define lstrcpyW2A( dst, src )     CopyW2A( dst, src )
#define lstrcpyT2A( dst, src )     lstrcpy( dst, src )

#endif



///////////////////////////////////////////////////////////////////////////////
// DBCS, Locale aware (Slow)
///////////////////////////////////////////////////////////////////////////////

// character types
bool ZONECALL IsWhitespace( TCHAR c, LCID Locale = LOCALE_SYSTEM_DEFAULT );
bool ZONECALL IsDigit( TCHAR c, LCID Locale = LOCALE_SYSTEM_DEFAULT );
bool ZONECALL IsAlpha(TCHAR c, LCID Locale = LOCALE_SYSTEM_DEFAULT );

// conversion helpers
int ZONECALL WideToMulti(char* mbstr, const wchar_t* wcstr, size_t count);
int ZONECALL MultiToWide(wchar_t* wcstr, const char* mbstr, size_t count);

#ifdef UNICODE
// we don't need to have a wrapper function in UNICODE
#define StringToGuid( wsz, pguid )      CLSIDFromString( wsz, pguid )
#else
HRESULT ZONECALL StringToGuid( const char* mbszString, GUID* pGuid );
#endif



///////////////////////////////////////////////////////////////////////////////
// String validation
// All strings
///////////////////////////////////////////////////////////////////////////////

inline bool ZONECALL ZIsValidString(LPCWSTR lpsz, int nLength)
{
	return (lpsz != NULL && !::IsBadStringPtrW(lpsz, nLength) );
}

inline bool ZONECALL ZIsValidString(LPCSTR lpsz, int nLength)
{
	return ( lpsz != NULL && !::IsBadStringPtrA(lpsz, nLength) );
}

inline bool ZONECALL ZIsValidAddress(const void* lp, UINT nBytes, bool bReadWrite = true)
{
	return ( lp != NULL && !::IsBadReadPtr(lp, nBytes) && (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)) );
}


///////////////////////////////////////////////////////////////////////////////
// ZString class
///////////////////////////////////////////////////////////////////////////////

struct ZoneStringData
{
	long	nRefs;
	int		nDataLength;
	int		nAllocLength;
	
	TCHAR* data() { return (TCHAR*) (this+1); }
};


class ZoneString
{
public:
	// Constructors
	ZoneString(void *pBuffer = NULL, int nLen = 0);
	ZoneString(const ZoneString& stringSrc, void *pBuffer = NULL, int nLen = 0);
	ZoneString(TCHAR ch, int nRepeat = 1, void *pBuffer = NULL, int nLen = 0);
	ZoneString(LPCSTR lpsz, void *pBuffer = NULL, int nLen = 0);
	ZoneString(LPCWSTR lpsz, void *pBuffer = NULL, int nLen = 0);
	ZoneString(LPCTSTR lpch, int nLength, void *pBuffer = NULL, int nLen = 0);
	ZoneString(const unsigned char* psz, void *pBuffer = NULL, int nLen = 0);

	// Destructor
	~ZoneString();

	// Attributes & Operations
	// as an array of characters
	inline int GetAllocLength() const { return GetData()->nAllocLength; }
	inline int GetLength() const { return GetData()->nDataLength; }

	inline bool	IsEmpty() const { return GetData()->nDataLength == 0; }
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	
	// string comparison
	// straight character
	inline int	Compare(LPCTSTR lpsz) const { return lstrcmp(m_pchData, lpsz); }    
	// ignore case
	inline int	CompareNoCase(LPCTSTR lpsz) const{ return lstrcmpi(m_pchData, lpsz); }  
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	ZoneString Mid(int nFirst, int nCount) const;
	ZoneString Mid(int nFirst) const;
	ZoneString Left(int nCount) const;
	ZoneString Right(int nCount) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// Return long conversion of string
	long ToLong(){ return _ttol(m_pchData);}

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();
	
	// Remove directory info from string - leaving only filename
	void RemoveDirInfo();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// Windows support
	bool LoadString(HINSTANCE hInstance, UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

	// Access to string implementation buffer as "C" character array
	void SetBuffer(void *pBuffer, int nLen); // Set buffer for ZoneString to use
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

	inline operator LPCTSTR() const { return m_pchData; } // as a C string
//	inline operator LPSTR() const { return m_pchData; } // as a C string

	// overloaded assignment
	const ZoneString& operator=(const ZoneString& stringSrc);
	const ZoneString& operator=(TCHAR ch);
#ifdef _UNICODE
	const ZoneString& operator=(char ch);
#endif
	const ZoneString& operator=(LPCSTR lpsz);
	const ZoneString& operator=(LPCWSTR lpsz);
	const ZoneString& operator=(const unsigned char* psz);

	// string concatenation
	const ZoneString& operator+=(const ZoneString& string);
	const ZoneString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const ZoneString& operator+=(char ch);
#endif
	const ZoneString& operator+=(LPCTSTR lpsz);

	// Friend operation overloaded functions
#ifdef _UNICODE
	friend inline ZoneString __stdcall operator+(const ZoneString& string, char ch) { return string + (TCHAR)ch; }
	friend inline ZoneString __stdcall operator+(char ch, const ZoneString& string) { return (TCHAR)ch + string; }
#endif

	friend ZoneString __stdcall operator+(const ZoneString& string1, const ZoneString& string2)
	{
		ZoneString s;
		s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
			string2.GetData()->nDataLength, string2.m_pchData);
		return s;
	}
	friend inline ZoneString operator+(const ZoneString& string, LPCTSTR lpsz)
	{
		ASSERT(lpsz == NULL || ZIsValidString(lpsz, FALSE));
		ZoneString s;
		s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
			ZoneString::SafeStrlen(lpsz), lpsz);
		return s;
	}

	friend inline ZoneString operator+(LPCTSTR lpsz, const ZoneString& string)
	{
		ASSERT(lpsz == NULL || ZIsValidString(lpsz, FALSE));
		ZoneString s;
		s.ConcatCopy(ZoneString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
			string.m_pchData);
		return s;
	}

	friend inline ZoneString operator+(const ZoneString& string1, TCHAR ch)
	{
		ZoneString s;
		s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
		return s;
	}

	friend inline ZoneString operator+(TCHAR ch, const ZoneString& string)
	{
		ZoneString s;
		s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
		return s;
	}

protected:
	LPTSTR	m_pchData;   // pointer to ref counted string data
	bool	m_bZoneStringAllocMemory; // TRUE - we allocated memory FALSE - passed in buffer

	// implementation helpers
	ZoneStringData* GetData() const;
	void Init();
	void InitBuffer(void * pBuffer, int nLen);
	void AllocCopy(ZoneString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	bool AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCSTR lpszSrc1Data, int nSrc2Len, LPCSTR lpszSrc2Data);
	void ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data, int nSrc2Len, LPCWSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	bool AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(ZoneStringData* pData, bool bZoneStringAllocMem);
	inline static int PASCAL SafeStrlen(LPCTSTR lpsz) { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

};

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator=		= Operator overload
//
//	Parameters
//		TCHAR ch	Pointer to null terminated string, right side of assignment
//
//	Return Values
//		 ZoneString& Reference to new string
//
//////////////////////////////////////////////////////////////////////////////////////////////
inline const ZoneString& ZoneString::operator=(TCHAR ch)
{
	AssignCopy(1, &ch);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator+=		+= Operator overlaod
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
#ifdef _UNICODE
inline const ZoneString& ZoneString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator+=		+= Operator overlaod
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
inline const ZoneString& ZoneString::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || ZIsValidString(lpsz, false));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator+=		+= Operator overlaod
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
inline const ZoneString& ZoneString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	operator+=		+= Operator overlaod
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
inline const ZoneString& ZoneString::operator+=(const ZoneString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//	ZResLoadString		LoadString wrapper
//
//	Parameters
//		None
//
//	Return Values
//		None
//
//////////////////////////////////////////////////////////////////////////////////////////////
inline int ZONECALL ZResLoadString(HINSTANCE hInstance, UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
	ASSERT(ZIsValidAddress(lpszBuf, nMaxBuf*sizeof(TCHAR)));

	int nLen = ::LoadString(hInstance, nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#endif // ZONESTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zoneutil.h ===
/******************************************************************************
 *
 * Copyright (C) 1998-1999 Microsoft Corporation.  All Rights reserved.
 *
 * File:		ZoneFile.h
 * 
 * Contents:	File manipulation routines.
 *
 *****************************************************************************/


#ifndef __ZONEUTIL_H
#define __ZONEUTIL_H


#include "ZoneDef.h"


#pragma comment(lib, "ZoneUtil.lib")


DWORD ZONECALL GetOSType(void);

///////////////////////////////////////////////////////////////////////////////
//
// ReadLine:
//
//     Provides a simple mechanism for parsing text files
//     with lines terminated by a LineFeed or CarriageReturn / LineFeed pair.
//
//     The function behaves very similar to the Win32 API ReadFile.
//
//     Exceptions:
//       ReadLine returns FALSE and GetLastError() is set to ERROR_INSUFFICIENT_BUFFER
//       if the provided buffer isn't large enough to contain the entire line
//
//       pcbNumBytesRead is set to the number of bytes actually read from the file and
//       corresponds with how far the file pointer has moved forward.
//       Note: this will be 1 or 2 TCHARs larger than then string length of the returned
//       line since this accounts for the LF or CRLF pair.
//
//       The LF or CRLF pair is replaced with a NULL terminator.
//
//
///////////////////////////////////////////////////////////////////////////////
BOOL ZONECALL ReadLine( HANDLE hFile, LPVOID pBuffer, DWORD cbBufferSize, LPDWORD pcbNumBytesRead );


///////////////////////////////////////////////////////////////////////////////
//
// Set/GetDataCenterPath
//
//	Session's data center URL and file site.
//
///////////////////////////////////////////////////////////////////////////////
BOOL ZONECALL SetDataCenterPath(const TCHAR* szStr);
BOOL ZONECALL GetDataCenterPath(TCHAR* szStr, DWORD cbStr );
BOOL ZONECALL SetDataFileSite(const TCHAR* szStr);
BOOL ZONECALL GetDataFileSite(TCHAR* szStr, DWORD cbStr );

//////////////////////////////////////////////////////////////////////////////////////
//	StrVerCmp
//	pszCurrVer		Version string of file
//	pszVersion		Version string to compare to
//
//	Return Values
//	If pszCurrVer is less than the pszStrVer, the return value is negative. 
//	If pszCurrVer is greater than the pszStrVer, the return value is positive. 
//	If pszCurrVer is equal to the pszStrVer, the return value is zero.
//
//////////////////////////////////////////////////////////////////////////////////////
int ZONECALL StrVerCmp(const char * pszCurrVer, const char * pszStrVer);


///////////////////////////////////////////////////////////////////////////////
//
// At top of file somewhere, or in one file to make a stub library, say
//
//      DECLARE_MAYBE_FUNCTION_1(BOOL, GetProcessDefaultLayout, DWORD *);
//
// Alternatively
//
//      inline DECLARE_MAYBE_FUNCTION(DWORD, SetLayout, (HDC hdc, DWORD dwLayout), (hdc, dwLayout), gdi32, GDI_ERROR);
//
// Then later
//
//      ret = CALL_MAYBE(GetProcessDefaultLayout)(&dw);
//
// Currently the simplifying macros only work for user32 functions returning 0 on error.
//
///////////////////////////////////////////////////////////////////////////////
#define DECLARE_MAYBE_FUNCTION(ret, fn, args, argsnt, lib, err)         \
    ret WINAPI _Maybe_##fn args                                         \
    {                                                                   \
        typedef ret (WINAPI* _typeof_##fn ) args ;                      \
        HMODULE hMod;                                                   \
        _typeof_##fn pfn = NULL;                                        \
        hMod = LoadLibraryA(#lib ".dll");                               \
        ret retval;                                                     \
        if(hMod)                                                        \
            pfn = ( _typeof_##fn ) GetProcAddress(hMod, #fn );          \
        if(pfn)                                                         \
            retval = pfn argsnt;                                        \
        else                                                            \
        {                                                               \
            SetLastError(ERROR_INVALID_FUNCTION);                       \
            retval = err;                                               \
        }                                                               \
        if(hMod)                                                        \
            FreeLibrary(hMod);                                          \
        return retval;                                                  \
    }

#define DECLARE_MAYBE_FUNCTION_BASE(ret, fn, args, argsnt)  DECLARE_MAYBE_FUNCTION(ret, fn, args, argsnt, user32, 0)

#define DECLARE_MAYBE_FUNCTION_0(ret, fn)                   DECLARE_MAYBE_FUNCTION_BASE(ret, fn, (), ())
#define DECLARE_MAYBE_FUNCTION_1(ret, fn, a1)               DECLARE_MAYBE_FUNCTION_BASE(ret, fn, (a1 v1), (v1))
#define DECLARE_MAYBE_FUNCTION_2(ret, fn, a1, a2)           DECLARE_MAYBE_FUNCTION_BASE(ret, fn, (a1 v1, a2 v2), (v1, v2))
#define DECLARE_MAYBE_FUNCTION_3(ret, fn, a1, a2, a3)       DECLARE_MAYBE_FUNCTION_BASE(ret, fn, (a1 v1, a2 v2, a3 v3), (v1, v2, v3))
#define DECLARE_MAYBE_FUNCTION_4(ret, fn, a1, a2, a3, a4)   DECLARE_MAYBE_FUNCTION_BASE(ret, fn, (a1 v1, a2 v2, a3 v3, a4 v4), (v1, v2, v3, v4))


#define CALL_MAYBE(fn) _Maybe_##fn


#endif //__ZONEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zonewin.h ===
// over-riding CAxWindow
// first add SendMessageToControl for convenience
// then, also:
// incorporate the leak fix as published in Microsoft Systems Journal April 1999
// article: Write ActiveX Controls Using Custom Interfaces Provided by ATL 3.0, Part III
// can be found in MSDN


#ifndef __ZONE_WIN__
#define __ZONE_WIN__


template <typename TBase = CWindow>
class CZoneAxWindowT : public CAxWindowT<TBase>
{
public:
	LRESULT SendMessageToControl(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
	   // pass the message on to children
		LRESULT lRes = 0;
		HRESULT hr = S_FALSE;

		CComPtr<IOleInPlaceObjectWindowless> pWindowless;
		QueryControl(&pWindowless);
		if ( pWindowless )
		{
			hr = pWindowless->OnWindowMessage(uMsg, wParam, lParam, &lRes);
		}
	
		if ( hr != S_OK )
			bHandled = FALSE;

		return lRes;
	}


public:
    CZoneAxWindowT(HWND hwnd = 0) : CAxWindowT<TBase>(hwnd) {}

    HRESULT CreateControl(LPCOLESTR lpszName, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
    {
        return CreateControlEx(lpszName, pStream, ppUnkContainer);
    }
    
    HRESULT CreateControl(DWORD dwResID, IStream* pStream = NULL, IUnknown** ppUnkContainer = NULL)
    {
        return CreateControlEx(dwResID, pStream, ppUnkContainer);
    }
    
    HRESULT CreateControlEx(DWORD dwResID,  IStream* pStream = NULL, 
                            IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                            REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
    {
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_Module.GetModuleInstance(), szModule, _MAX_PATH);
        
        CComBSTR bstrURL(OLESTR("res://"));
        bstrURL.Append(szModule);
        bstrURL.Append(OLESTR("/"));
        TCHAR szResID[11];
        wsprintf(szResID, _T("%0d"), dwResID);
        bstrURL.Append(szResID);
        
        return CreateControlEx(bstrURL, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
    }
    
    HRESULT CreateControlEx(LPCOLESTR lpszName, IStream* pStream = NULL, 
                            IUnknown** ppUnkContainer = NULL, IUnknown** ppUnkControl = NULL,
                            REFIID iidSink = IID_NULL, IUnknown* punkSink = NULL)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        
        HRESULT hr = E_FAIL;
        CComPtr<IAxWinHostWindow> spAxWindow;
        
        // Reuse existing CAxHostWindow
        hr = QueryHost(&spAxWindow);
        if( SUCCEEDED(hr) )
        {
            CComPtr<IUnknown> spunkControl;
            hr = spAxWindow->CreateControlEx(lpszName, m_hWnd, pStream, &spunkControl, iidSink, punkSink);
            if( FAILED(hr) ) return hr;
        
            if( ppUnkControl ) (*ppUnkControl = spunkControl)->AddRef();
            if( ppUnkContainer ) (*ppUnkContainer = spAxWindow)->AddRef();
        }
        // Create a new CAxHostWindow
        else
        {
    		return AtlAxCreateControlEx(lpszName, m_hWnd, pStream, ppUnkContainer, ppUnkControl, iidSink, punkSink);
        }

        return S_OK;
    }
    
    HRESULT AttachControl(IUnknown* pControl, IUnknown** ppUnkContainer = 0)
    {
        ATLASSERT(::IsWindow(m_hWnd));
        
        HRESULT hr = E_FAIL;
        CComPtr<IAxWinHostWindow> spAxWindow;
        
        // Reuse existing CAxHostWindow
        hr = QueryHost(&spAxWindow);
        if( SUCCEEDED(hr) )
        {
            hr = spAxWindow->AttachControl(pControl, m_hWnd);
            if( FAILED(hr) ) return hr;
        
            if( ppUnkContainer ) (*ppUnkContainer = spAxWindow)->AddRef();
        }
        // Create a new CAxHostWindow
        else
        {
    		return AtlAxAttachControl(pControl, m_hWnd, ppUnkContainer);
        }

        return S_OK;
    }
};

typedef CZoneAxWindowT<CWindow> CZoneAxWindow;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zverp.h ===
/****************************************************************************
 *                                                                          *
 *      ntverp.H        -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

#include <winver.h>

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */

#define VER_PRODUCTMAJORVER             1
#define VER_PRODUCTMINORVER             2
#define VER_PRODUCTBUILD                614
#define VER_PRODUCTBUILDINCR            1

// the last number should be set to one for a new build
#define VER_PRODUCTVERSION              VER_PRODUCTMAJORVER,VER_PRODUCTMINORVER,VER_PRODUCTBUILD,VER_PRODUCTBUILDINCR
#define VER_PRODUCTVERSION_STR          "1.2.614.1"
#define VER_PRODUCTVERSION_COMMA_STR    "1,2,614,1"

// needed for unicode projects
#define LVER_PRODUCTVERSION_STR         L"1.2.614.1"
#define LVER_PRODUCTVERSION_COMMA_STR   L"1,2,614,1"

#define VER_DWORD ((1 << 24) | (2 << 18) | (614 << 4) | (1))

/*--------------------------------------------------------------*/

#define VER_PRODUCTBETA_STR             "Internal"
#define LVER_PROCUCTBETA_STR            L"Internal"

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK

#define VER_FILEOS                  VOS_NT_WINDOWS32

#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_FILESUBTYPE             0 /* unknown */

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Zone.com"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation."
#define VER_LEGALCOPYRIGHT_YEARS    "1995-2001"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zservcon.h ===
/*******************************************************************************

    zservcon.h
    
        ZSConnection object methods.
    
    Copyright  Electric Gravity, Inc. 1994. All rights reserved.
    Written by Kevin Binkley, Hoon Im
    Created on Saturday, November 12, 1994 03:51:47 PM
    
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    4        10/15/96    JWS        Added userdata parameter to  function type
                                ZSConnectionMessageFunc
    3        05/08/96    HI        Added ZSConnectionCloseServer().
    2        05/07/96    HI        Added zSConnectionNoTimeout constant.
    1        05/01/96    HI        Changed ZSConnectionLibraryGetNetworkInfo() to
                                ZSConnectionLibraryGetGlobalInfo(). Also added
                                ZSConnectionGetTimeoutRemaining().
    0        03/07/95    KJB        Created.
     
*******************************************************************************/


#ifndef _ZSERVCON_
#define _ZSERVCON_

#include "network.h"

#ifdef __cplusplus
extern "C" {
#endif


/* performs one time initialization */
ZError ZSConnectionLibraryInit();
ZError ZSConnectionLibraryInitClientOnly();


/* closes all connections, cleans up all resources */
void ZSConnectionLibraryCleanUp();

void ZSConnectionLibrarySetOptions( ZNETWORK_OPTIONS* opt );
void ZSConnectionLibraryGetOptions( ZNETWORK_OPTIONS* opt );

void ZSConnectionLibraryEnterCS();
void ZSConnectionLibraryLeaveCS();



/*
    Open connection as a client to the the given host and port.
*/

ZSConnection ZSConnectionOpen(char* hostname, int32 port, ZSConnectionMessageFunc func, void* serverClass, void* userData);
void ZSConnectionClose(ZSConnection connection);
void ZSConnectionDelayedClose(ZSConnection connection, uint32 delay);
void ZSConnectionDelete(ZSConnection connection);
void ZSConnectionSuspend(ZSConnection connection);
void ZSConnectionResume(ZSConnection connection);
BOOL ZSConnectionIsDisabled(ZSConnection connection);
BOOL ZSConnectionIsServer(ZSConnection connection);


void ZSConnectionAddRef(ZSConnection connection);
void ZSConnectionRelease(ZSConnection connection);


ZError ZSConnectionSetTimeout(ZSConnection connection, uint32 timeout);
void ZSConnectionClearTimeout(ZSConnection connection);
uint32 ZSConnectionGetTimeoutRemaining(ZSConnection connection);

void ZSConnectionSetUserData(ZSConnection connection, void* userData);
void* ZSConnectionGetUserData(ZSConnection connection);

void ZSConnectionSetClass(ZSConnection connection, void* serverClass);
void* ZSConnectionGetClass(ZSConnection connection);

/*
    The ZSConnectionSendFilterFunc is passed into ZSConnectionSetSendFilter
    Data is sent to the connection if TRUE is returned.
*/
typedef BOOL (*ZSConnectionSendFilterFunc)(ZSConnection connection, void* userData, uint32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel);
void ZSConnectionSetSendFilter(ZSConnection connection, ZSConnectionSendFilterFunc);
ZSConnectionSendFilterFunc ZSConnectionGetSendFilter(ZSConnection connection);
ZError ZSConnectionSend(ZSConnection connection, uint32 messageType, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel = 0);

void* ZSConnectionReceive(ZSConnection connection, uint32 *type, int32 *len, uint32 *pdwSignature, uint32 *pdwChannel);


/*
* DEPENDENCY: THE CLIENT MUST IMMEDIATELY SEND A MESSAGE BACK
* TO THE SERVER AFTER RECEIVE THE KEY MESSAGE FOR THIS TIME
* TO BE ACCURATE
*/
uint32 ZSConnectionGetLatency(ZSConnection connection);

uint32 ZSConnectionGetAcceptTick(ZSConnection connection);

char* ZSConnectionGetLocalName(ZSConnection connection);
uint32 ZSConnectionGetLocalAddress(ZSConnection connection);
char* ZSConnectionGetRemoteName(ZSConnection connection);
uint32 ZSConnectionGetRemoteAddress(ZSConnection connection);

uint32 ZSConnectionGetHostAddress();

char* ZSConnectionAddressToStr(uint32 address);
uint32 ZSConnectionAddressFromStr( char* pszAddr );


/* 
    Call this function to enter an infinite loop waiting for connections 
    and data
*/
void ZSConnectionWait();

BOOL ZSConnectionQueueAPCResult( ZSConnectionAPCFunc func, void* data );

/*
    Call this function to exit the wait loop.

    Closes all connections.
*/
void ZSConnectionExit(ZBool immediate);

/* 
    send to all connections of a particular class.  can be used to broadcast 
*/
ZError ZSConnectionSendToClass(void* serverClass, int32 type, void* buffer, int32 len, uint32 dwSignature, uint32 dwChannel = 0);

/* 
    enumerate all connections of a particular class
*/
ZError ZSConnectionClassEnumerate(void* serverClass, ZSConnectionEnumFunc func, void* data);


/*
    ZSConnectionHasToken, used to check if user has access to token 
    returns FALSE for non secure connections
*/

BOOL ZSConnectionHasToken(ZSConnection connection, char* token);


GUID* ZSConnectionGetUserGUID(ZSConnection connection);


/*
    ZSConnectionGetUserName, used get user name on secure connections
    returns FALSE for non secure connections
*/

BOOL ZSConnectionGetUserName(ZSConnection connection, char* name);
BOOL ZSConnectionSetUserName(ZSConnection connection, char* name);

/*
    ZSConnectionGetUserId, used to get user id on secure connections
    returns 0 for non secure connections. 
    This user id is unique in the security system
*/

DWORD ZSConnectionGetUserId(ZSConnection connection);


BOOL ZSConnectionGetContextStr(ZSConnection connection, char* buf, DWORD len);

int  ZSConnectionGetAccessError(ZSConnection);


void  ZSConnectionSetParentHWND(HWND hwnd);

#ifdef __cplusplus

/*
    Create a server for this port and receive connections on it 
    connections will be sent to the MessageFunc
*/
ZSConnection ZSConnectionCreateServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* serverClass, void* userData, uint32 saddr = INADDR_ANY);
ZSConnection ZSConnectionCreateSecureServer(uint16* pPort, uint16 range, ZSConnectionMessageFunc func, void* serverClass,
                                            char* serverName, char* serverType, char* odbcRegistry, void* userData,char *SecPkg,uint32 Anonymous, uint32 saddr = INADDR_ANY);

BOOL ZSConnectionStartAccepting( ZSConnection connection, DWORD dwMaxConnections, WORD wOutstandingAccepts = 1);

}

ZError ZSConnectionLibraryInit(BOOL EnablePools);
ZError ZSConnectionLibraryInitClientOnly(BOOL EnablePools);
ZSConnection ZSConnectionOpenSecure(char* hostname, int32 *ports, ZSConnectionMessageFunc func,
                                    void* conClass, void* userData,
                                    char *User,char*Password,char*Domain,int Flags = ZNET_PROMPT_IF_NEEDED, char* pRoute = NULL );


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\ztypes.h ===
/*******************************************************************************

	ZTypes.h
	
		Basic types used by the Zone(tm) libraries.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Hoon Im, Kevin Binkley
	Created on Monday, October 17, 1994 01:14:56 AM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	2		04/25/96	HI		Removed NEW().
	1		10/30/94	HI		Added ZVoidPtr.
	0		10/17/94	HI		Added file header and cleaned up some.
	 
*******************************************************************************/


#ifndef _ZTYPES_
#define _ZTYPES_


/* -------- Unix specific definitions and types. -------- */
#ifdef SVR4PC

#define __ZUnix__

#define LITTLEENDIAN

typedef unsigned int		uint32;
typedef int					int32;
typedef unsigned short		uint16;
typedef short				int16;
typedef unsigned char		uchar;

typedef int32				ZError;

#endif


/* -------- Macintosh specific definitions and types. -------- */
#if defined(__MWERKS__) || defined(THINK_C)

#define __ZMacintosh__

typedef unsigned long		uint32;
typedef long				int32;
typedef unsigned short		uint16;
typedef short				int16;
typedef unsigned char		uchar;

typedef int32				ZError;

#endif


/* -------- Windows specific definitions and types. -------- */
#if defined(_WINDOWS) || defined(_WIN32)

#define __ZWindows__

#ifdef _DEBUG
#define ZASSERT(x) if (!(x)) _asm int 3 
#else
#define ZASSERT(x)
#endif

//#define LITTLEENDIAN

typedef unsigned long		uint32;
typedef long				int32;
typedef unsigned short		uint16;
typedef short				int16;
typedef unsigned char		uchar;

typedef int32				ZError;

// This file is included here so that it does not have to be included
// in the generic .c files.
#include <memory.h>

#endif


typedef void*			ZVoidPtr;

#ifdef FALSE
#undef FALSE
#endif
#define FALSE			0

#ifdef TRUE
#undef TRUE
#endif
#define TRUE			1

typedef uint16			ZBool;
typedef uint32			ZUserID;

#define zTheUser		1				/* UserID of the user running the program. */

/*
	Version has the following format: MMMMmmrr
	where
		MMMM is the major version number,
		mm is the minor version number, and
		rr is the revision number.
*/
typedef uint32			ZVersion;

/*
	Zone(tm) has computer players which are almost equivalent to a human user
	except that they exist only on the server. Hence they don't have real
	connections; so while the human user's userID represents a connection
	file descriptor, a computer player's userID does not represent a connection
	at all.
	
	All computer player userID's have the high bit set.
*/
#define ZIsComputerPlayer(userID) \
		(((userID) & 0x80000000) == 0 ? FALSE : TRUE)

/* Length of user name in the system. */
#define zUserNameLen			31
#define zGameNameLen            63
#define zErrorStrLen            255
#define zPasswordStrLen			31

/* Some other user name things. */
#define zUserStatusExLen        1
#define zUserChatExLen          8  // for things like {Name}>  or  Name>>>

#define zChatNameLen            (zUserNameLen + zUserStatusExLen + zUserChatExLen)   // as in  [+Name]>>>

/* Length of remote host machine name. */ // just an IP address
#define zHostNameLen            16

/* Length of max chat input. */
#define zMaxChatInput           255

/* Game ID length -- internal name. */
#define zGameIDLen              31

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zsecurity.h ===
/*******************************************************************************

    ZSecurity.h
    
        Zone(tm) Internal System API.
    
    Copyright  Electric Gravity, Inc. 1995. All rights reserved.
    Written by Hoon Im, Kevin Binkley
    Created on April 21, 1996 06:26:45 AM
    
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    2        03/17/97    HI        Added ZUnloadSSPS().
    1        11/9/96        JWS        Added SSPI APIs
    0        04/22/96    KJB        Created.
     
*******************************************************************************/


#ifndef _ZSECURITY_
#define _ZSECURITY_


#ifndef _ZTYPES_
#include "ztypes.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define zSecurityDefaultKey 0xF8273645

uint32 ZSecurityGenerateChecksum(uint16 numDataBuffers, char* data[], uint32 len[]);
void ZSecurityEncrypt(char *data, uint32 len, uint32 key);
void ZSecurityDecrypt(char *data, uint32 len, uint32 key);
void ZSecurityEncryptToBuffer(char *data, uint32 len, uint32 key, char* dest);
void ZSecurityDecryptToBuffer(char *data, uint32 len, uint32 key, char* dest);


/*
 * Functions and defines and APIs based on Win32 Normandy Sicily SSPI APIs
*/
#define SECURITY_WIN32
#include <windows.h>
#include <issperr.h>
#include <sspi.h>
//#include <sicapi.h>

#ifndef SICILY_PROTOCOL_VERSION_NUMBER
#define SICILY_PROTOCOL_VERSION_NUMBER  1
#endif

#define SSP_NT_DLL          "security.dll"
#define SSP_WIN95_DLL       "secur32.dll"

#define SSP_DLL_NAME_SIZE   16          // max. length of security DLL names

#define zSecurityCurrentProtocolVersion    1

#define zSecurityNameLen                    SSP_DLL_NAME_SIZE


enum {
    /* Security protocol message types */
    zSecurityMsgReq=1,
    zSecurityMsgResp,
    zSecurityMsgNegotiate,
    zSecurityMsgChallenge,
    zSecurityMsgAuthenticate,
    zSecurityMsgAccessDenied,    
    zSecurityMsgAccessGranted,

};

/* Client -> server */
typedef struct
{
    uint32        protocolSignature;                /* Protocol signature */
    uint32        protocolVersion;                /* Protocol version */
    char        SecBuffer[1];
} ZSecurityMsgReq;

/* Server -> Client */
typedef struct
{
    uint32        protocolVersion;                    /* Server Protocol version */
    char        SecPkg[zSecurityNameLen + 1];
    uchar        UserName[zUserNameLen + 1];
    char        SecBuffer[1];
} ZSecurityMsgResp;

typedef struct
{
    uint32        protocolVersion;                    /* Server Protocol version */
    uint16        reason;
} ZSecurityMsgAccessDenied;


PSecurityFunctionTable ZLoadSSPS (void);
void ZUnloadSSPS(void);

#if 0
void ZSecurityMsgReqEndian(ZSecurityMsgReq* msg);
void ZSecurityMsgRespEndian(ZSecurityMsgResp* msg);
void ZSecurityMsgAccessDeniedEndian(ZSecurityMsgAccessDenied *msg);
#endif

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\games\checklib.h ===
/*
** Checkers Game
*/
#include <tchar.h>

#define zCheckersPieceBlack 0x00
#define zCheckersPieceWhite 0x80

#define zCheckersPieceNone 0
#define zCheckersPiecePawn 1
#define zCheckersPieceKing 2

#define zCheckersPieceWhitePawn 0x81
#define zCheckersPieceWhiteKing 0x82

#define zCheckersPieceBlackPawn 1
#define zCheckersPieceBlackKing 2

#define zCheckersSquareNone 255

enum {
	zCheckersScoreBlackWins = 0,
	zCheckersScoreWhiteWins,
	zCheckersScoreDraw
};

/* these defines zCheckersPlayer must have these values */
#define zCheckersPlayerBlack 0x0
#define zCheckersPlayerWhite 0x1

#define ZCheckersPieceColor(x) (x & zCheckersPieceWhite) 
#define ZCheckersPieceType(x) (x & 0x7f) 
#define ZCheckersPieceOwner(x) (ZCheckersPieceColor(x) == zCheckersPieceWhite ? zCheckersPlayerWhite : \
			zCheckersPlayerBlack)
#define ZCheckersPieceIsWhite(x) (ZCheckersPieceColor(x) == zCheckersPieceWhite)


typedef BYTE ZCheckersPiece;

typedef void* ZCheckers;
typedef struct {
	BYTE col;
	BYTE row;
} ZCheckersSquare;

#define ZCheckersSquareIsNull(x) ((x)->row == zCheckersSquareNone)
#define ZCheckersSquareSetNull(x) ((x)->row = zCheckersSquareNone)

typedef struct {
	ZCheckersSquare start;
	ZCheckersSquare finish;
} ZCheckersMove;

/* 
** ZCheckersFlags
*/
#define zCheckersFlagStalemate		0x0004
#define zCheckersFlagResign			0x0010
#define zCheckersFlagTimeLoss		0x0020
#define zCheckersFlagWasJump		0x0040
#define zCheckersFlagContinueJump	0x0080
#define zCheckersFlagPromote		0x0100
#define zCheckersFlagDraw			0x0200

/*
** Careful to handle:
**
** Enpassant - update of screen, invisisible capture!
** Castle - update all 4 squares.
** Pawn Prompotion - allow user to select type of piece.
*/

ZCheckersPiece ZCheckersPieceAt(ZCheckers checkers, ZCheckersSquare* pSquare);
/* returns id of piece at this square, return 0 if no piece */
int16 ZCheckersIsLegalMove(ZCheckers checkers, ZCheckersMove* pMove);
/* returns true if this is a legal move */

ZCheckersSquare* ZCheckersMakeMove(ZCheckers checkers, ZCheckersMove* pMove, ZCheckersPiece* pPiece, int32* flags);
/* makes the given move, must call IsLegalCheckersMove first */
/* returns array of squares that must be updated */
/* this is a static local array, valid until the next ZCheckersMakeMove call */
/* pPiece will be set to piece captured if any or EMPTY if no */
/* piece was captured */

ZCheckersSquare* ZCheckersFinishMove(ZCheckers checkers, int32* flags);
/* actually increments the move count, ending a players turn */

int32 ZCheckersPlayerToMove(ZCheckers checkers);
/* returns the player to move: zCheckersPlayerWhite or zCheckersPlayerBlack */

void ZCheckersPlacePiece(ZCheckers checkers, ZCheckersSquare* pSquare, ZCheckersPiece nPiece);
/* place a piece on a given square, used to init board or promote pawn */
/* Place EMPTY piece to clear a square */

ZCheckers ZCheckersNew();
void ZCheckersDelete(ZCheckers checkers);

void ZCheckersInit(ZCheckers checkers);
/* call to initilize the checkerslib routines */
/* call before starting a game */

ZCheckersPiece* ZCheckersGetCapturedPieces(ZCheckers checkers);
/* returns an array of pieces, terminated by zCheckersPieceNone */

ZBool ZCheckersGetMove(ZCheckers checkers, ZCheckersMove* move, int16 moveNumber);
/* returns the particular move, fails if there is no such move */

int16 ZCheckersNumMovesMade(ZCheckers checkers);
/* returns the move # we are on, 1. white black 2. white black.. etc */

uint32 ZCheckersGetFlags(ZCheckers checkers);
/* returns the flags for the last move */

void ZCheckersEndGame(ZCheckers checkers, uint32 flags);
/* allow player to resign, store flag in the flags */

ZBool ZCheckersIsGameOver(ZCheckers checkers, int16* score);
/* detect if game is over and return a flag indicating score */

int32 ZCheckersGetStateSize(ZCheckers checkers);
/* gets the size of the buffer needed to store full checkers state */

void ZCheckersGetState(ZCheckers checkers, void* buffer);
/* fills a buffer with the full checkers state */
/* leaves buffer in standard endian format */

ZCheckers ZCheckersSetState(void* buffer);
/* copies the full state from the buffer */
/* buffer assumed to be in standard endian format */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\zverpbase.h ===
/****************************************************************************
 *                                                                          *
 *      ntverp.H        -- Version information for internal builds          *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION, VER_PRODUCTVERSION_STR and             *
 *      VER_PRODUCTBETA_STR values.                                         *
 *                                                                          *
 ****************************************************************************/

#include <winver.h>

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*                                                              */

#define VER_PRODUCTMAJORVER             WWW
#define VER_PRODUCTMINORVER             XXX
#define VER_PRODUCTBUILD                YYY
#define VER_PRODUCTBUILDINCR            ZZZ

// the last number should be set to one for a new build
#define VER_PRODUCTVERSION              VER_PRODUCTMAJORVER,VER_PRODUCTMINORVER,VER_PRODUCTBUILD,VER_PRODUCTBUILDINCR
#define VER_PRODUCTVERSION_STR          "WWW.XXX.YYY.ZZZ"
#define VER_PRODUCTVERSION_COMMA_STR    "WWW,XXX,YYY,ZZZ"

// needed for unicode projects
#define LVER_PRODUCTVERSION_STR         L"WWW.XXX.YYY.ZZZ"
#define LVER_PRODUCTVERSION_COMMA_STR   L"WWW,XXX,YYY,ZZZ"

#define VER_DWORD ((WWW << 24) | (XXX << 18) | (YYY << 4) | (ZZZ))

/*--------------------------------------------------------------*/

#define VER_PRODUCTBETA_STR             "Internal"
#define LVER_PROCUCTBETA_STR            L"Internal"

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK

#define VER_FILEOS                  VOS_NT_WINDOWS32

#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG)

#define VER_FILESUBTYPE             0 /* unknown */

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Zone.com"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation."
#define VER_LEGALCOPYRIGHT_YEARS    "1995-2001"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\bgmsgs.h ===
/*******************************************************************************

	backgammon.h
	
		Backgammon interface protocol.
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		10/30/96	CHB		Created
	 
*******************************************************************************/

#ifndef __BG_MSGS_H__
#define __BG_MSGS_H__

#include "zgame.h"

#ifdef __cplusplus
extern "C" {
#endif

/* table gameroom message protocol */

#define zBackgammonProtocolSignature        'BCKG'
#define zBackgammonProtocolVersion			3

/* -------- Backgammon Message Components -------- */

typedef	int16	ZSeat;

typedef struct
{
	int16	color;
	int16	pieces;
} ZBGMsgPoint;


/* -------- Backgammon Message Types -------- */
enum
{
    zBGMsgTalk = 0x100,         /* chat messages */
    zBGMsgTransaction,          /* shared state transaction */
    zBGMsgTurnNotation,         /* turn notation */
    zBGMsgTimestamp,            /* timestamp from server */
    zBGMsgSavedGameState,       /* saved game restore */
    zBGMsgRollRequest,          /* a client is requesting a roll event*/
    zBGMsgDiceRoll,             /* server is sending roll data*/
    zBGMsgEndLog,               /* end of match results */
    zBGMsgNewMatch,             /* start of new match */
    zBGMsgFirstMove,             /* initial roll complete */
	zBGMsgMoveTimeout,           /* players move has timed out*/
	zBGMsgEndTurn,				/* players move has timed out*/
	zBGMsgEndGame,				/* game not match has ended*/
    zBGMsgGoFirstRoll,				/* game not match has ended*/
    zBGMsgTieRoll,				/* game not match has ended*/
	zBGMsgCheater				/* one client is cheating by manipulating the dic rule*/
};

/* -------- Backgammon Message Structures -------- */
typedef struct
{
	ZUserID	userID;
	ZSeat	seat;
	uint16	messageLen;
	// message body
} ZBGMsgTalk;


typedef struct
{
	ZSeat seat;
	int16 transCnt;
	int32 transTag;
	// transaction array
} ZBGMsgTransaction;


typedef struct
{
	ZSeat	seat;
	int16	type;
	int32	nChars;
	// null terminated string
} ZBGMsgTurnNotation;


typedef struct
{
	int32	dwLoTime;
	int32	dwHiTime;
} ZBGMsgTimestamp;

//Bug fix: Moving backgammon shuffle code to server
//new messages required 

//roll request structure is sent by the rolling client
//to initiate the start of a game.
typedef struct
{
	ZSeat seat;
} ZBGMsgRollRequest;



typedef struct tagDICEINFO
{	
	int16 Value;
	int32 EncodedValue;
	int16 EncoderMul;
	int16 EncoderAdd;
	int32 numUses;	
}DICEINFO, *LPDICEINFO;


//roll structure, sent to both clients for the dice roll itself
typedef struct
{
	ZSeat seat;
 	DICEINFO d1, d2;
} ZBGMsgDiceRoll;


/* -------- Backgammon End Log Reasons-------- */
enum
{
	zBGEndLogReasonTimeout=1,
	zBGEndLogReasonForfeit, 
	zBGEndLogReasonGameOver,
};

typedef struct
{
	int32 numPoints;	// Number of points in match
	int16 reason;
	int16 seatLosing;	// Match loser
	int16 seatQuitting;
	int16 rfu;
} ZBGMsgEndLog;

typedef struct
{
	int32 numPoints;    // Number of points in match.  needed in advance in case of abandon.  otherwise, amount sent in ZBGMsgEndLog overrides.
	int16 seat;
} ZBGMsgFirstMove;

typedef struct
{
	int32 userID;    
	int16 seat;
	int16 timeout;
	WCHAR  userName[zUserNameLen + 1];
} ZBGMsgMoveTimeout;

typedef struct
{
	int16 seat;
} ZBGMsgEndTurn;


typedef struct
{
	int16 seat;
	DICEINFO dice1;
	DICEINFO dice2;
	int16 move;
} ZBGMsgCheater;



/* -------- Backgammon Endian Prototypes -------- */
void ZBGMsgTalkEndian( ZBGMsgTalk* m );
void ZBGMsgTurnNotationEndian( ZBGMsgTurnNotation* m );
void ZBGMsgTimestampEndian( ZBGMsgTimestamp* m );
void ZBGMsgRollRequestEndian(ZBGMsgRollRequest *m);
void ZBGMsgDiceRollEndian(ZBGMsgDiceRoll *m);
void ZBGMsgEndLogEndian(ZBGMsgEndLog *m);
void ZBGMsgFirstMoveEndian(ZBGMsgFirstMove *m);
void ZBGMsgCheaterEndian(ZBGMsgCheater *m);

DICEINFO EncodeDice(int16 Dice);
int32 DecodeDice(LPDICEINFO pDiceInfo);

void ClientNewEncode(LPDICEINFO pDice, int16 newValue);
int32 ClientNewDecode(LPDICEINFO pDice);

BOOL  DiceValid(LPDICEINFO pDiceInfo);

BOOL IsValidUses(LPDICEINFO pDice);
void EncodeUses(LPDICEINFO pDice, int32 numUses);
int32 DecodeUses( LPDICEINFO pDice );
int32 EncodedUsesAdd(LPDICEINFO pDice);
int32 EncodedUsesSub(LPDICEINFO pDice);





#ifdef __cplusplus
};
#endif

#endif //!__BG_MSGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\include\games\reverlib.h ===
/*
** Reversi Game
*/
#include <tchar.h>

#define zReversiPieceNone 0
#define zReversiPieceWhite 0x81
#define zReversiPieceBlack 0x01

#define zReversiSquareNone ((BYTE)-1)

enum {
	zReversiScoreBlackWins = 0,
	zReversiScoreWhiteWins,
	zReversiScoreDraw
};

/* these defines zReversiPlayer must have these values */
#define zReversiPlayerWhite 0x0
#define zReversiPlayerBlack 0x1

#define ZReversiPieceOwner(x) ((x) == zReversiPieceWhite ? zReversiPlayerWhite : \
			zReversiPlayerBlack)
#define ZReversiPieceIsWhite(x) ((x) == zReversiPieceWhite)


typedef BYTE ZReversiPiece;

typedef void* ZReversi;
typedef struct {
	BYTE col;
	BYTE row;
} ZReversiSquare;

#define ZReversiSquareIsNull(x) ((x)->row == zReversiSquareNone)
#define ZReversiSquareSetNull(x) ((x)->row = zReversiSquareNone)

typedef struct {
	ZReversiSquare square;
} ZReversiMove;

/* 
** ZReversiFlags
*/
#define zReversiFlagWhiteWins 0x0001
#define zReversiFlagBlackWins 0x0002
#define zReversiFlagDraw 0x0004
#define zReversiFlagResign 0x0010
#define zReversiFlagTimeLoss 0x0020

ZReversiPiece ZReversiPieceAt(ZReversi reversi, ZReversiSquare* pSquare);
/* returns id of piece at this square, return 0 if no piece */
ZBool ZReversiIsLegalMove(ZReversi reversi, ZReversiMove* pMove);
/* returns true if this is a legal move */

ZBool ZReversiMakeMove(ZReversi reversi, ZReversiMove* pMove);
/* makes the given move, must call IsLegalReversiMove first */
/* returns true if legal move */

void ZReversiFinishMove(ZReversi reversi);
/* actually increments the move count, ending a players turn */

int16 ZReversiPlayerToMove(ZReversi reversi);
/* returns the player to move: zReversiPlayerWhite or zReversiPlayerBlack */

void ZReversiPlacePiece(ZReversi reversi, ZReversiSquare* pSquare, BYTE nPiece);
/* place a piece on a given square, used to init board or promote pawn */
/* Place EMPTY piece to clear a square */

ZReversi ZReversiNew();
void ZReversiDelete(ZReversi reversi);

void ZReversiInit(ZReversi reversi);
/* call to initilize the reversilib routines */
/* call before starting a game */

ZBool ZReversiGetLastMove(ZReversi reversi, ZReversiMove* move);
/* returns the particular move, fails if there is no such move */

int16 ZReversiNumMovesMade(ZReversi reversi);
/* returns the move # we are on, 1. white black 2. white black.. etc */

uint32 ZReversiGetFlags(ZReversi reversi);
/* returns the flags for the last move */

void ZReversiEndGame(ZReversi reversi, uint32 flags);
/* allow player to resign, store flag in the flags */

ZBool ZReversiIsGameOver(ZReversi reversi, int16* score, int16* whiteScore, int16* blackScore);
/* detect if game is over and return a flag indicating score */

int32 ZReversiGetStateSize(ZReversi reversi);
/* gets the size of the buffer needed to store full reversi state */

void ZReversiGetState(ZReversi reversi, void* buffer);
/* fills a buffer with the full reversi state */
/* leaves buffer in standard endian format */

ZReversi ZReversiSetState(void* buffer);
/* copies the full state from the buffer */
/* buffer assumed to be in standard endian format */

ZBool ZReversiPlayerCanMove(ZReversi reversi, BYTE player);
ZReversiSquare* ZReversiGetNextSquaresChanged(ZReversi reversi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\chatmsg.h ===
/*******************************************************************************

	ChatMsg.h
	
	Modified version of zroom.h for chat servers	
	 
*******************************************************************************/


#ifndef _CHATMSG_H_
#define _CHATMSG_H_

#ifdef __cplusplus
extern "C" {
#endif



#define zChatRoomProtocolSignature		'chat'
#define zChatRoomProtocolVersion		23
#define zChatClientVersion				0x00010000

#define zRoomAllPlayers					0
#define zRoomAllSeats					(-1)
#define zRoomToPlayer					(-2)
#define zRoomToRoom                     (-3)

#define zGameNameLen                    63
#define zDataFileNameLen				63

#define zMaxNumInfoTexts				12
#define zInfoTextLen					63

#define zRegistryKeyLen					1023
#define zRegistryValueLen				127
#define zPlayerInfoStrLen				31
#define zGameVersionLen					15
#define zURLLen							255
#define zErrorStrLen					255

#define zMaxNumLatencyRanges            10

#define zLatencyUnknown                 0xFFFFFFFF

#define zRoomGameLabelLen               15
#define zRoomGamePasswordLen            31
#define zDPlayGameNameLen               31

#define zFileNameLen					31
#define zMaxNumFilesToCheck				10
#define zMaxFileNameLen					255


enum
{
	/* -------- Game Experience Types -------- */
	zGameExpHost = 1,			/* Latency to host only. */
	zGameExpWorst,				/* Worst latency in the group. */
	zGameExpOwn,				/* Player's latency to host/server. */

	/* -------- Game Genre -------- */
	zGameGenreBasic = 0,		/* Command line format. */
	zGameGenreDirectPlay3,
	zGameGenreVXD,
	zGameGenreDirectPlayHack,	/* MSGolf,FlightSim version of directPlay */
	zGameGenreGenericDPlay,		/* Generic DPlay Lobby. */
};


typedef void*			ZSGame;
typedef void*			ZCGame;
typedef void*			ZSGameComputer;


/* Table state information. */
/* For tables which don't have the maximum number of players, sending this structure */
/* for every table wastes data space BUT we'll deal with it later when it becomes necessary. */
typedef struct
{
	int16		tableID;
	int16		status;
	uint32		options;			/* Table options */
    int16       maxNumPlayers;
    ZUserID     players[1]; // runtimed sized by ZRoomMsgAccessed.maxNumPlayersPerTable
} ZChatRoomTableInfo;

typedef struct
{
	ZUserID		userID;							/* UserID of new player */
	char		userName[zUserNameLen + 1];		/* User's name */
    uint32      hostAddr;                       /* User's machine name */
    uint32      timeSuspended;                  /* Measurement in ms of how long the user's connection has been suspended */
    uint32      latency;                        /* User's latency */
} ZChatRoomUserInfo;

typedef struct
{
	ZUserID		userID;
	int16		table;
	int16		seat;
} ZChatRoomKibitzerInfo;


typedef struct
{
    uint32                  numKibitzers;           /* Number of kibitzing instances in the room */
    ZChatRoomKibitzerInfo   kibitzers[1];           /* Variable length */
} ZChatRoomKibitzers;



/* -------- Room Message Structures -------- */

/* Server --> Client */
typedef struct
{
	ZUserID			userID;				/* UserID in room */
    uint32          groupID;
    uint16          numTables;          /* Number of tables in room */
    uint16          maxNumPlayersPerTable;
    uint32          options;
    /* protocol 23 */
    uint32          maskRoomCmdPrivs; 
} ZChatRoomMsgAccessed;

/* Server --> Client */
/*
	With protocol 3, this message is sent after the zRoomMsgAccessed. ZRoomMsgAccessed
	messages contains the first few fields of this message. Hence, the duplicate fields
	in this messages can be ignored.
*/
typedef struct
{
    uint16          maxNumPlayersPerTable;  /* for convience */
    uint16          numPlayers;         /* Number of players in the room. */
	uint16			numTableInfos;		/* Number of table infos sent in tables field. */
    ZChatRoomUserInfo   players[1];         /* Variable length. */
    ZChatRoomTableInfo  tables[1];          /* Variable length. */
} ZChatRoomMsgRoomInfo;

/* Server --> Client */
typedef ZChatRoomUserInfo ZChatRoomMsgEnter;

/* Client <--> Server */
typedef struct
{
	ZUserID		userID;				/* UserID of the player */
	int16		table;				/* Table of interest */
	int16		seat;				/* Seat of interest */
	int16		action;				/* Interested action or status */
	int16		rfu;
} ZChatRoomMsgSeatRequest;
	/*
        ZRoomMsgSeatRequest is used for all user requests on the seat
	*/

/* Server --> Client */
typedef struct
{
	int16		table;				/* Table of interest */
	int16		status;				/* Table status */
    uint32      options;            /* Table options */

} ZChatRoomMsgTableStatus;


/* Client <-> Server */
typedef struct
{
    DWORD       cbBuf;    // size of date buffer
    BYTE        pBuf[1];  // message sized appropriately
} ZChatRoomMsgLaunchCmd;

/*
	Server sends this msg to the client whenever the host of the
	table changes. Change of the host is determined within the
	game/launchpad.
*/
/* Server -> Client */
typedef struct
{
	ZUserID		userID;
	int16		table;
} ZChatRoomMsgNewHost;


/*
	Server -> Client

	Variable length msg containing list of app guids. Client does not allow users
	to select for play any app in this list.
*/
typedef BYTE	GuidStr[40];
typedef struct
{
	DWORD		numGuids;		// number of guid strings.
	GuidStr		guidStrs[1];	// variable array of guid strings.
} ZChatRoomMsgAppExclude;




typedef struct
{
	char*				gameName;
	char*				gameDir;
	char*				gameLobbyName;
	char*				gameExecName;
	char*				gameExecVersion;
	char*				gameExecVersionErrStr;
	char*				gameExecNotInstalledErrStr;
	uint32				gameGenre;
	int16				gameMinNumPlayersPerTable;
	int16				gameMaxNumPlayersPerTable;
	char*				gameRegistryKey;
	char*				gameRegistryVersionValue;
	char*				gameRegistryPathValue;
	uint32				gameOptions;
	uint16*				gameLatencyTimes;
	uint32				gameLatencyInterval;
	char*				gameLaunchDatafileName;
	uint32				gameNumLatencyTimes;

	// Generic DPlay lobby fields.
	char*				gameDisplayName;
} LobbyGameInfo;

typedef struct
{
	ZUserID		userID;
	uint32		groupID; /* user's group ID */
	char		userName[zUserNameLen + 1];
	uint32		userAddr; /* user's IP address */
	uint32		latency;
	uint32		timeSuspended;
} LobbyPlayerInfoType, *LobbyPlayerInfo;


//#ifdef _ROOM_
#define ZRoomTableInfo      ZChatRoomTableInfo
#define ZRoomUserInfo       ZChatRoomUserInfo
#define ZRoomKibitzerInfo   ZChatRoomKibitzerInfo
#define ZRoomKibitzers      ZChatRoomKibitzers

#define ZRoomMsgEnter       ZChatRoomMsgEnter
#define ZRoomMsgAccessed    ZChatRoomMsgAccessed
#define ZRoomMsgRoomInfo    ZChatRoomMsgRoomInfo
#define ZRoomMsgSeatRequest ZChatRoomMsgSeatRequest
#define ZRoomMsgTableStatus ZChatRoomMsgTableStatus
#define ZRoomMsgLaunchCmd   ZChatRoomMsgLaunchCmd
#define ZRoomMsgNewHost     ZChatRoomMsgNewHost
#define ZRoomMsgAppExclude  ZChatRoomMsgAppExclude
//#endif //def _ROOM_


///////////////////////////////////////////////////////////////////////////////
// Theater Chat Messages
///////////////////////////////////////////////////////////////////////////////

enum
{
	/* -------- Theater User State -------- */
	zTheaterWatching = 0,
	zTheaterWaiting,
	zTheaterAsking,
	zTheaterGuest,
	zTheaterModerator,
	zTheaterSysop,				// This is really a psuedo-state
    zTheaterMaxState
};


enum
{
	/* -------- Theater Room Message Types -------- */
	//Client --> Server from ordinary user
	//Use ZRoomMsgTheaterUser for data structure.
	zRoomMsgTheaterUserStateChange=1024,

	//Client --> Server from sysop or moderator
	//Use ZRoomMsgTheaterUser for data structure.
	zRoomMsgTheaterModStateChange,

	//Server --> Client to enumerate 
	//ordered list of people who are waiting to ask question, moderators, guests, etc.
    //only for initialization of new client
	zRoomMsgTheaterList,

    //Server --> Client to inform 
	//usre of change of user from  moderator to guest, waiting to asking etc.
	zRoomMsgTheaterStateChange
};


typedef struct
{
	ZUserID			userID;
	uint32			state;
	uint32			index;
} ZRoomMsgTheaterUser;


typedef struct
{
	uint16		numUsers;
	uint32		stateType;
	ZRoomMsgTheaterUser	list[1];
} ZRoomMsgTheaterList;


#include "CommonMsg.h"

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\gamemsg.h ===
/*******************************************************************************

	GameMsg.h
	
	Modified zroom.h from cardboard services
	
*******************************************************************************/

#ifndef _GAMEMSG_H_
#define _GAMEMSG_H_

#ifdef __cplusplus
extern "C" {
#endif

#define zGameRoomProtocolSignature          'game'
#define zGameRoomProtocolVersion            17

#define zMaxNumPlayersPerTable			8
#define zRoomGameLabelLen               15
#define zRoomGamePasswordLen            31

#define zDPlayGameNameLen               31

#define zInvalTable						(-1)


/* -------- Room Image Types -------- */
enum
{
	zRoomObjectTable = 0,
	zRoomObjectGameMarker,
	zRoomObjectEmptySeat,
	zRoomObjectComputerPlayer,
	zRoomObjectHumanPlayer,
	zRoomObjectVote,
	zRoomObjectStart,
	zRoomObjectTableID,
	zRoomObjectPending,
	zRoomObjectName,
	
	zRoomObjectUp,
	zRoomObjectDown,
	
	zRoomObjectIdle,
	zRoomObjectGaming
};


enum
{
	/* -------- Game Message Blocking Options -------- */
	zRoomBlockAllMessages = 0,
	zRoomFilterAllMessages = -1,
	zRoomFilterThisMessage = 1,
};


typedef void*			ZCGame;



/* Table state information. */
/* For tables which don't have the maximum number of players, sending this structure */
/* for every table wastes data space BUT we'll deal with it later when it becomes necessary. */
typedef struct
{
	int16		tableID;
	int16		status;
	ZUserID		players[zMaxNumPlayersPerTable];
	ZBool		votes[zMaxNumPlayersPerTable];
} ZGameRoomTableInfo;

typedef struct
{
	ZUserID		userID;							/* UserID of new player */
	char		userName[zUserNameLen + 1];		/* User's name */
    uint32      hostAddr;                       /* User's machine name */
    uint32      timeSuspended;                  /* Measurement in ms of how long the user's connection has been suspended */
    uint32      latency;
	int16		rating;							/* User's rating, <0 is unknown */
	int16		gamesPlayed;					/* number of games user has played, <0 is unknown */
	int16		gamesAbandoned;					/* number of games user has abandoned, <0 is unknown */
	int16		rfu;
} ZGameRoomUserInfo;

typedef struct
{
	ZUserID		userID;
	int16		table;
	int16		seat;
} ZGameRoomKibitzerInfo;


typedef struct
{
	uint32				numKibitzers;			/* Number of kibitzing instances in the room */
    ZGameRoomKibitzerInfo   kibitzers[1];           /* Variable length */
} ZGameRoomKibitzers;


typedef struct
{
	ZUserID		userID;
	int16		rating;							/* User's rating, <0 is unknown */
	int16		gamesPlayed;					/* number of games user has played */
	int16		gamesAbandoned;					/* number of games user has abandoned */
	int16		rfu;
} ZGameRoomUserRating;

/* -------- Room Message Structures -------- */

/* Server --> Client */
typedef struct
{
	ZUserID			userID;				/* UserID in room */
	uint16			numTables;			/* Number of tables in room */
	uint16			numSeatsPerTable;	/* Number of seats per table */
	uint32			gameOptions;		/* Particular game's options. */
    uint32          groupID;            /* User's group ID */
    /* protocol 17 */
    uint32          maskRoomCmdPrivs;   /* User's chat command privileges */
} ZGameRoomMsgAccessed;



/* Server --> Client */
/*
	With protocol 3, this message is sent after the zRoomMsgAccessed. ZRoomMsgAccessed
	messages contains the first few fields of this message. Hence, the duplicate fields
	in this messages can be ignored.
*/
typedef struct
{
	ZUserID			userID;				/* UserID in room */
	uint16			numTables;			/* Number of tables in room */
	uint16			numSeatsPerTable;	/* Number of seats per table */
	uint32			gameOptions;		/* Particular game's options. */
	uint16			numPlayers;			/* Number of players in the room. */
	uint16			numTableInfos;		/* Number of table infos sent in tables field. */
    ZGameRoomUserInfo   players[1];         /* Variable length. */
    ZGameRoomTableInfo  tables[1];          /* Variable length. */
	
	/* Protocol 2 */
    ZGameRoomKibitzers  kibitzers;          /* Variable length. */
} ZGameRoomMsgRoomInfo;

/* Server --> Client */
typedef ZGameRoomUserInfo ZGameRoomMsgEnter;

/* Client --> Server */
typedef ZGameRoomUserInfo ZGameRoomMsgEnter;

typedef struct
{
	ZUserID		userID;				/* UserID of the player */
    int16       table;              /* Table of interest */
	int16		seat;				/* Seat of interest */
	int16		action;				/* Interested action or status */
	int16		rfu;
} ZGameRoomMsgSeatRequest;
	/*
        ZGameRoomMsgSeatRequest is used for all user requests on the seat
	*/


/* Server --> Client */
typedef struct
{
	int16		table;				/* Table of interest */
	int16		status;				/* Table status */
	
	/* Protocol 2 */
	uint32		options;			/* Table options */
} ZGameRoomMsgTableStatus;

typedef struct
{
	uint16				numUsers;
	uint16				rfu;
    ZGameRoomUserRating     players[1]; /* Variable length. */
} ZGameRoomMsgUserRatings;


#ifdef _ROOM_
#define ZRoomTableInfo      ZGameRoomTableInfo
#define ZRoomUserInfo       ZGameRoomUserInfo
#define ZRoomKibitzerInfo   ZGameRoomKibitzerInfo
#define ZRoomKibitzers      ZGameRoomKibitzers
#define ZRoomUserRating     ZGameRoomUserRating

#define ZRoomMsgEnter       ZGameRoomMsgEnter
#define ZRoomMsgAccessed    ZGameRoomMsgAccessed
#define ZRoomMsgRoomInfo    ZGameRoomMsgRoomInfo
#define ZRoomMsgSeatRequest ZGameRoomMsgSeatRequest
#define ZRoomMsgTableStatus ZGameRoomMsgTableStatus
#define ZRoomMsgUserRatings ZGameRoomMsgUserRatings
#endif //def _ROOM_


#include "CommonMsg.h"


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\checkers.h ===
#ifndef _CHECKERS_H_
#define _CHECKERS_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "zgame.h"

/* Table Gameroom Message Protocol */

#define zCheckersProtocolSignature      'CHKR'
#define zCheckersProtocolVersion        2

typedef int16 ZSeat;

/* -------- Player Info -------- */
typedef struct
{
	ZUserID			userID;
	TCHAR			name[zUserNameLen + 1];
	TCHAR			host[zHostNameLen + 1];
} TPlayerInfo, *TPlayerInfoPtr;



/*
	Checkers Game Message Types
*/
enum {
	/* client -> server */
    zCheckersMsgNewGame = 0x100,
	zCheckersMsgMovePiece,
	zCheckersMsgTalk,
	zCheckersMsgEndGame,
	zCheckersMsgEndLog,
	zCheckersMsgFinishMove,
	zCheckersMsgDraw,
	
	zCheckersMsgPlayers,			/* Uses the same message NewGame */

    zCheckersMsgGameStateReq,
    zCheckersMsgGameStateResp,
	zCheckersMsgMoveTimeout,
	zCheckersMsgVoteNewGame,
};

enum{
	zAcceptDraw = 1,  // to match millennium protocol
	zRefuseDraw
	};

/*
	Message definitions: server -> client
*/

/*
	Message definitions: client -> server
*/

/*
	ZCheckersMsgNewGame

	The client program on launch is expected to check in immediately
	with the server.  All clients send their seat to the server indicating
	they are successfully launched and ready to begin.
*/
typedef struct {

    int32 protocolSignature;        /* client -> server */
	int32 protocolVersion;			/* client -> server */
	int32 clientVersion;			/* client -> server */
    ZUserID playerID;               /* server -> client */
    ZSeat seat;
    int16 rfu;

} ZCheckersMsgNewGame;

/*
	ZCheckersMsgMovePiece

	Indicates the card played.
*/
typedef struct {
	ZSeat	seat;
	int16	rfu;
	ZCheckersMove move;
} ZCheckersMsgMovePiece;

/*
	ZCheckersMsgTalk
	
	Sent by client to server whenever a user talks on the table. The server in turn
	broadcasts this message to all players on the table.
*/
typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	uint16		messageLen;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZCheckersMsgTalk;

/*
	The following message structure is used by the game server to inform
	of a game client on the current state of the game. Primarily used for
	adding kibitzers to the game.
*/
typedef struct
{
	/* Game options. */
	uint32		gameOptions;

	/* Game state. */
} ZCheckersMsgGameState;

typedef struct
{
	int16		seat;
	int16		rfu;
	uint32		flags;
} ZCheckersMsgEndGame;


enum
{
	zCheckersEndLogReasonTimeout=1,
	zCheckersEndLogReasonForfeit, 
	zCheckersEndLogReasonWontPlay,
	zCheckersEndLogReasonGameOver,
};

typedef struct
{
	int16 reason;
	int16 seatLosing;	// Match loser
	int16 seatQuitting;
	int16 rfu;
} ZCheckersMsgEndLog;

typedef struct
{
	ZSeat	seat;
	ZSeat	drawSeat;
	uint32 time;
	ZCheckersPiece piece;
} ZCheckersMsgFinishMove;

typedef struct
{
	int32 userID;    
	int16 seat;
	int16 timeout;
	WCHAR  userName[zUserNameLen + 1];
} ZCheckersMsgMoveTimeout;


typedef struct {

	int16 seat;
	int16 vote;
}ZCheckersMsgDraw;


typedef struct
{
	ZUserID			userID;
	int16			seat;
	int16			rfu;
} ZCheckersMsgGameStateReq;

typedef struct
{
	ZUserID			userID;
	int16			seat;
	int16			rfu;
	/*
		game states ...
	*/
	int16			gameState;
	ZBool			newGameVote[2];
	int16			finalScore;
	TPlayerInfo		players[2];
} ZCheckersMsgGameStateResp;

typedef struct
{
	int16			seat;
}ZCheckersMsgVoteNewGame;

/* -------- Endian Conversion Routines -------- */
void ZCheckersMsgGameStateReqEndian(ZCheckersMsgGameStateReq* msg);
void ZCheckersMsgGameStateRespEndian(ZCheckersMsgGameStateResp* msg);

/* -------- Endian Conversion Routines -------- */
void ZCheckersMsgMovePieceEndian(ZCheckersMsgMovePiece* m);
void ZCheckersMsgTalkEndian(ZCheckersMsgTalk* m);
void ZCheckersMsgNewGameEndian(ZCheckersMsgNewGame* m);
void ZCheckersMsgGameStateEndian(ZCheckersMsgGameState* m);
void ZCheckersMsgEndGameEndian(ZCheckersMsgEndGame* m);
void ZCheckersMsgEndLogEndian(ZCheckersMsgEndLog* m);
void ZCheckersMsgFinishMoveEndian(ZCheckersMsgFinishMove* m);
void ZCheckersMsgOfferDrawEndian(ZCheckersMsgDraw*m);
void ZCheckersMsgVoteNewGameEndian(ZCheckersMsgVoteNewGame*m);

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\commonmsg.h ===
/*******************************************************************************

	CommonMsg.h
	
	Shared messages between cardboard, retail, and chat services
		 
*******************************************************************************/


#ifndef _CommonMsg_H_
#define _CommonMsg_H_

#pragma once



enum
{
    /* note the high word is reserved for game specific settings */

    /* -------- Player Types -------- */
    zGamePlayer = 1,
    zGamePlayerJoiner,
    zGamePlayerKibitzer,

    /* -------- Table States -------- */
    zRoomTableStateIdle = 0,
    zRoomTableStateGaming,
    zRoomTableStateLaunching,
    
    /* -------- Table Options -------- */
    zRoomTableOptionNoKibitzing			= 0x00000001,
        /*
            If set, kibitzers are not allowed on the table.
        */
    zRoomTableOptionNoJoining			= 0x00000002,
        /*
            If set, joining is not allowed on the table.
        */
    zRoomTableOptionSilentKibitzing		= 0x00000004,
        /*
            If set, kibitzers are not allowed to talk on the table.
        */
    zRoomTableOptionsPasswordProtected	= 0x00000008,
		/*
			If set, the game is password protected
		*/
	zRoomTableOptionsNoQuickJoiners		= 0x00000010,
		/*
			If set, the game does not allow quick joiners
		*/
    zRoomTableOptionTurnedOff			= 0x80000000,
        /*
            If set, then the game clients should not allow the users to
            modify the table options.
        */
};


enum
{
    /* -------- Seat Actions and Status -------- */
    zRoomSeatActionSitDown = 0,
        /*
            Client --> Server: Request for the seat.
            Server --> Client: Confirmation of the seat.
            Server --> Client: Broadcast of a player sitting down in seat.
            Unless the server returns this action, the client should not
            allow the user to sit down in the seat.
        */
    zRoomSeatActionLeaveTable,
        /*
            Client --> Server: Notification of departure of player from table
                for both player and kibitzer.
            Server --> Client: Broadcast of a player's departure from table.
        */
    zRoomSeatActionStartGame,
        /*
            Client --> Server: Request to start game by the player.
            Server --> Client: Broadcast of other player's vote status.
        */
    zRoomSeatActionReplacePlayer,
        /*
            Server --> Client: Replace current player with the given player.
        */
    zRoomSeatActionAddKibitzer,
        /*
            Client --> Server: Request to kibitz on the seat.
            Server --> Client: Confirmation kibitz request.
            Unless the server returns this action, the client should not
            allow the user to kibitz on the seat.
        */
    zRoomSeatActionRemoveKibitzer,
        /*
            Client --> Server: Request to remove user as kibitzer from seat.
            Server --> Client: Broadcast.
        */
    zRoomSeatActionNoKibitzing,
        /*
            Server --> Client: Rejection of the kibitz request.
        */
    zRoomSeatActionLockOutJoin,
        /*
            Server --> Client: Rejection of the join game request.
        */
    zRoomSeatActionJoin,
        /*
            Client --> Server: Request to join a game at the table and seat.
        */
    zRoomSeatActionChangeSettings,
        /*
            Client --> Server: Request to change table settings.
            Server handles this message and sends TableStatus message to
            all clients.
        */
	zRoomSeatActionQuickHost,
		/*
			Client --> Server: Request to quick host a game.
		*/
	zRoomSeatActionQuickJoin,
		/*
			Client --> Server: Request to quick joing a game
		*/
    zRoomSeatActionDenied = 0x8000,
        /*
            This message is ORed with the requested seat action.
            
            Server --> Client: The requested seat action is denied.
        */
};


enum
{
    zRemoveUnknown			= 0x0000,
    zRemoveConnectionClose	= 0x0001,
    zRemoveExitSeat			= 0x0002,
    zRemoveExitClient		= 0x0004,
    zRemoveBlocked			= 0x0008,

    zRemoveKibitzer			= 0x0100,
    zRemoveWaiting			= 0x0200,
    zRemovePlayer			= 0x0400,
};


enum
{
    /* -------- Room Message Types -------- */
    zRoomMsgUserInfo = 0,
    zRoomMsgRoomInfo,
    zRoomMsgEnter,
    zRoomMsgLeave,
    NotUsed_zRoomMsgSeat,
    zRoomMsgStartGame,
    zRoomMsgTableStatus,
    zRoomMsgTalkRequest,
    zRoomMsgTalkResponse,
    zRoomMsgGameMessage,
    NotUsed_zRoomMsgSpecialUserInfo,
    zRoomMsgAccessed,
    zRoomMsgDisconnect,
    zRoomMsgTalkResponseID,
    zRoomMsgSuspend,
    zRoomMsgLaunchCmd,  // lobby only
    zRoomMsgNewHost,    // lobby only
    zRoomMsgLatency,
    zRoomMsgAppExclude, // lobby only -- generic dplay lobby
    zRoomMsgUserRatings,
    zRoomMsgServerInfoRequest,
    zRoomMsgServerInfoResponse,
    zRoomMsgZUserIDRequest,
    zRoomMsgZUserIDResponse,
    zRoomMsgSeatRequest,
    zRoomMsgSeatResponse,
    zRoomMsgClearAllTables,
	zRoomMsgTableDescription,
	zRoomMsgTableSettings,
    zRoomMsgCommandResponse,// generic formatted text response (used currently by sysmon)

    zRoomMsgClientConfig,
    zRoomMsgServerStatus,
	zRoomMsgStartGameM,
    zRoomMsgChatSwitch,
    zRoomMsgPlayerReplaced,

    zRoomMsgPing = 64,

	zRoomMsg = 127,
    
	/* -------- Server Messages  -------- */
//    zRoomMsgServerBaseID = 128,

};

//Millenniumm constants
#define SIZE_MAX_CLIENT_CONFIG 255

#define VERSION_MROOM_SIGNATURE 'dude'
#define VERSION_MROOM_PROTOCOL	 1


/* Room Privileges --used in the ZRoomAccessed message*/
enum 
{
    /* Chat Commands */
    zRoomPrivCmd                = 0x1,
    zRoomPrivCmdMsg             = 0x2,
    zRoomPrivCmdWarn            = 0x4,      
    zRoomPrivCmdGag             = 0x8,      
    zRoomPrivCmdBoot            = 0x10,
    zRoomPrivCmdGagList         = 0x20,
    zRoomPrivCmdBootList        = 0x40,
    zRoomPrivCmdGetIP           = 0x80,
    zRoomPrivCmdGetAllIP        = 0x100,
    zRoomPrivCmdTable           = 0x200,
    zRoomPrivCmdSilence         = 0x400,
    zRoomPrivCmdGreet           = 0x800,
    zRoomPrivCmdInfo            = 0x1000,
    zRoomPrivCmdSuperBoot       = 0x2000,
    zRoomPrivCmdAsheronsCall    = 0x4000,
    zRoomPrivCmdTheaterModerator= 0x8000,
    // extend the enumeration to 32 bits
    zRoomPrivMax                = 0xFFFFFFFF
};


/* Client --> Server */
typedef struct
{
    uint32		protocolSignature;				/* Protocol signature */
    uint32		protocolVersion;				/* Current protocol version */
    uint32		clientVersion;					/* Client version */
    char		internalName[zGameIDLen + 1];
    char		userName[zUserNameLen + 1];
} ZRoomMsgUserInfo;


/* Server --> Client */
typedef struct
{
    ZUserID       userID;		/* UserID of player leaving room */
} ZRoomMsgLeave;


/* Client --> Server */
typedef struct
{
    ZUserID		userID;			/* UserID of player */
    int16		suspend;		/* Non-zero to stop server from sending data.  0 to reactivate */
    int16		rfu;			/* was future use */
} ZRoomMsgSuspend;


/* Server --> Client */
typedef struct
{
    uint32		gameID;			/* New gameID */
    int16		table;			/* Table of the new game */
    int16		seat;
} ZRoomMsgStartGame;

typedef struct
{
    uint32		gameID;			/* New gameID */
    int16		table;			/* Table of the new game */
    int16		seat;
    int16 		numseats;
    struct tagUserInfo
    {
        ZUserID		userID;
        LCID        lcid;
        bool        fChat;
        int16       eSkill;
    }           rgUserInfo[1];         //variable sized array
} ZRoomMsgStartGameM;


/* Server --> Client */
typedef struct
{
	ZUserID		userID;			/* UserID of the player */
    uint32      gameID;
    int16       table;			/* Table of interest */
	int16		seat;			/* Seat of interest */
    int16       action;			/* Interested status */
	int16		rfu;
} ZRoomMsgSeatResponse;
	/*
        ZRoomMsgSeatResponse is used for reporting
        current status of the seat to other players. The action field defines
        the status.
	*/


/* Client --> Server : Variable Length */
typedef struct
{
    ZUserID		senderID;				/* UserID of the sender */
    uint16		messageLen;				/* Message length */
//	char        message[messageLen];	/* Message body - sized as necessary */
} ZRoomMsgTalkRequest;

/* Server --> Client : Variable Length */
/*
    The senderName field is used because sometimes the sender of the message is not
    in the room anymore.
*/
typedef struct
{
    char        senderName[zUserNameLen + 1];
    uint16      messageLen;                     /* Message length */
//	char        message[messageLen];			/* Message body - sized as necessary
} ZRoomMsgTalkResponse;


typedef struct
{
    ZUserID     senderID;
    uint16      messageLen;				/* Message length */
//	char        message[messageLen];	/* Message body - sized as necessary */
} ZRoomMsgTalkResponseID;


/* Client <--> Server : Variable Length */
typedef struct
{
    uint32      messageType;            /* Message type. */
    uint32      messageLen;             /* Message length. */
//	char        message;
} ZRoomMsg;


/* Client <--> Server : Variable Length */


#define ZRoomMsgGameUnfilteredBit ((DWORD)0x80000000)   /* set this bit to allow message to pass through suspend filter */

typedef struct
{
	uint32		gameID;			/* Game ID. */
    uint32		messageType;	/* Message type. */
    uint16		messageLen;		/* Message length. */
    int16		rfu;
//	char        message;
} ZRoomMsgGameMessage;


typedef struct
{
    ZUserID		userID;
    uint32		pingTime;			/* Client->Server: current client's ping time */
                                    /* Server->Client: minimum ping interval; 0 = no ping */
} ZRoomMsgPing;


enum
{
    /* -------- Disconnect Reasons -------- */
    zDisconnectReasonNone = 0,
    zDisconnectReasonGameNameMismatch,
    zDisconnectReasonProhibitedName,
    zDisconnectReasonBanned,
    zDisconnectReasonDupUser,
    zDisconnectReasonOutOfDate,
    zDisconnectReasonRoomFull,
    zDisconnectReasonOldServer,
    zDisconnectReasonServicePaused,
    zDisconnectReasonBooted,
    zDisconnectReasonBooted5Min,
    zDisconnectReasonBootedDay,
    zDisconnectReasonNoToken,
};


typedef struct
{
    uint32		reason;
    int32		msgLen;
//	char		msg[msgLen];        // Null terminated.
} ZRoomMsgDisconnect;


typedef struct
{
    ZUserID userID;
    uint32  latency;
} ZUserLatency;


typedef struct
{
    uint16			numLatencies;
    ZUserLatency	latency[1];  // sized as needed
} ZRoomMsgLatency;


typedef struct
{
    uint32      reserved;
} ZRoomMsgServerInfoRequest;


typedef struct
{
    uint32      protocolSignature;              /* server protocol signature */
    uint32      protocolVersion;                /* server protocol version */
    char        info[256];                      /* text description of server */
} ZRoomMsgServerInfoResponse;


typedef struct
{
    char        userName[zUserNameLen + 1];
} ZRoomMsgZUserIDRequest;


typedef struct
{
    ZUserID     userID;
    char        userName[zUserNameLen + 1];
    LCID        lcid;
} ZRoomMsgZUserIDResponse;

typedef struct
{
    ZUserID     userID;
    bool        fChat;
} ZRoomMsgChatSwitch;

typedef struct
{
    ZUserID     userIDOld;
    ZUserID     userIDNew;
} ZRoomMsgPlayerReplaced;


// Client --> Server 

struct ZRoomMsgClientConfig
{
    uint32		protocolSignature;				/* Protocol signature */
    uint32		protocolVersion;				/* Current protocol version */
    char		config[SIZE_MAX_CLIENT_CONFIG + 1];
};

// Server --> Client 
struct ZRoomMsgServerStatus
{
    uint32		status;
    uint32		playersWaiting;

};

/* -------- More Types -------- */
typedef struct
{
    ZUserID		playerID;
    uint32		groupID;
    TCHAR		userName[zUserNameLen + 1];		/* User's name */
    TCHAR		hostName[zHostNameLen + 1];		/* User's machine name */
    uint32		hostAddr;                       /* User's machine name */
} ZPlayerInfoType, *ZPlayerInfo;
 

#endif // _CommonMsg_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\hearts.h ===
/*******************************************************************************

	ZHearts.h
	
		ZHearts Message definitions.  For use between the hearts client
		and server.
	
	Copyright  Electric Gravity, Inc. 1994. All rights reserved.
	Written by Kevin Binkley, Hoon Im
	Created on Saturday, November 12, 1994 03:51:47 PM
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	0		03/09/95	KJB		Created.
	 
*******************************************************************************/


#ifndef _ZHEARTS_
#define _ZHEARTS_

#ifdef __cplusplus
extern "C" {
#endif

#define zHeartsProtocolSignature            'hrtz'
#define zHeartsProtocolVersion              5

/*
        Things that could be typedefs... but are not public outside of hearts
*/
#define ZCard char
#define ZSeat int16

/*
        Server States
*/
#define zHeartsStateNone 0
#define zHeartsStatePassCards 1
#define zHeartsStatePlayCards 2
#define zHeartsStateEndGame 3

/*
	Definitions.
*/
#define zHeartsMaxNumCardsInHand 18
#define zHeartsMaxNumCardsInPass 5
#define zHeartsMaxNumPlayers 6
#define zHeartsNumCardsInDeck 52
#define zHeartsNumPointsInGame 100

//#define zHeartsMaxNumScores                 20

/*
	Card Definitions 
*/
#define zCard2C 0
#define zCardQS 36
#define zCardKS 37
#define zCardAS 38

#define zCardNone 127
#define zHeartsPlayerNone (-1)
#define zHeartsPlayerAll zHeartsMaxNumPlayers

/*
        Suit Definitions
*/
#define zSuitClubs 0
#define zSuitDiamonds 1
#define zSuitSpades 2
#define zSuitHearts 3

#define zDeckNumSuits 4
#define zDeckNumCardsInSuit (zHeartsNumCardsInDeck/zDeckNumSuits)

#define ZCardMake(suit,card) (zDeckNumCardsInSuit*suit + card)

enum{
zRatingsUnrated,  //this in an unrated lobby.
zRatingsEnabled,
zRatingsDisabled,
zRatingsGameOver     //for reseting the ratings after a game is over
};
/*
        Usefull Macros
*/
#define ZSuit(x) ((x)/13)
#define ZRank(x) ((x)%13)

/*#define ZSeatPassingToMe(dir,me) (((me)-(dir)+4)%4)*/

/*
	Pass Directions.
*/

#define zHeartsNumPassDir 4
enum {
	zHeartsPassLeft = 1,
	zHeartsPassRight = 3,
	zHeartsPassAcross = 2,
	zHeartsPassHold = 0
};

/*
        Game Options
*/
enum {
    zHeartsLeftOfDealerLead = 1,
    zHeartsPointsOnFirstTrick = 2,
    zHeartsJackOfDiamonds = 4, /* jack is -10 points */
    zHeartsTenOfClubs = 8, /* ten is 2 * points */
    zHeartsChineseScoring = 16, 
    /* QS = 100, JD = -100, AH = 50 .. TH = 10, others their value */
    /* TC = 2* points, TC alone -50, if run? JD and TC are + 100 and +50 ? */
    zHeartsAceOfHearts = 32,
    zHeartsTeamOfJDandJC = 64,
    zHeartsOppositeSeatsPartners = 128,
    
    zHeartsOptionsHideCards = 0x00010000
};

/* -------- Hearts Game States -------- */
enum
{
	zHeartsGameStartGame = 0,
	zHeartsGameStartHand,
	zHeartsGamePassCards,
	zHeartsGamePlayCard,
	zHeartsGameEndHand,
	zHeartsGameEndGame
};

/*
	Hearts Game Message Types
*/
enum {
	/* server -> client */
    zHeartsMsgStartGame = 0x100,
	zHeartsMsgReplacePlayer,
	zHeartsMsgStartHand,
	zHeartsMsgStartPlay,
	zHeartsMsgEndHand,
	zHeartsMsgEndGame,
	
	/* client -> server */
	zHeartsMsgClientReady,
	zHeartsMsgPassCards,
	zHeartsMsgPlayCard,
	zHeartsMsgNewGame,
	zHeartsMsgTalk,

	zHeartsMsgGameStateRequest,
	zHeartsMsgGameStateResponse,
	
	/* Debugging Messages */
	zHeartsMsgDumpHand,
	
	zHeartsMsgOptions,
	zHeartsMsgCheckIn,
	
	zHeartsMsgRemovePlayerRequest,
	zHeartsMsgRemovePlayerResponse,

	//dossier code
	zHeartsMsgDossierData,  //prompt the client to display UI data
	zHeartsMsgDossierVote,

	//close code
	zHeartsMsgCloseRequest,
	zHeartsMsgCloseDenied
};

//dossier data constants
enum
{
    zNotVoted,
    zVotedNo,
    zVotedYes
};

enum{
	zDossierBotDetected,
	zDossierAbandonNoStart,
	zDossierAbandonStart,
	zDossierMultiAbandon,   
	zDossierRatingsReEnabled,
	zDossierVoteCompleteWait,
	zDossierVoteCompleteCont,
	zDossierHeartsRejoin,  //send when the new player rejoins remove the dialog box
	zDossierMoveTimeout
};

enum
{
	zCloseNone = 0,    // needs to be 0

	zCloseRegular,
	zCloseForfeit,
	zCloseTimeout,
	zCloseWaiting,

	zCloseAbandon,
	zCloseClosing,

	zNumCloseTypes
};

/*
        Message Sequencing

	The room will call ZSGameNew to initialize the server before
	the client games are launched.  Each client game will next send
	a zHeartsClientReady message to the server indicating the client
	is alive and ready.

	On receiving all zHeartsClientReady messages, the server will
	send a zHeartsmsgStartGame to all clients perhaps indicating
	any game options to the clients (right now, it does not have any
	important data in it).

	Immediately and for each hand following, the server will send 
	a zHeartsStartHand message to the clients.  This indicates the pass
	direction and each clients hand.  If this is a passing hand, then
	the server waits for all passes to come in.  It broadcasts all passes
	back to all clients (a bit of a waste... but we'll see how it goes).
	Note: The client does not need to know about its own pass.  Later
	it might want to know who it is waiting for to pass so it can display
	information about who has/has not passed.

	When all passes are in, the server will send a zHeartsMsgStartPlay
	to all computers.  The seat in this message indicates the player
	expected to play.  The server will wait for this player to send a
	ZHeartsMsgPlayCard message and subsequently broadcast this message
	to all other clients indicating the card played.  These
	ZHeartsMsgPlayCard messages will continue until the whole hand
	has been played.  Throughout this process, the client is expected to
	sense who is to play next and play when appropriate.  This will reduce
	traffic and make the game seem more instantaneous for the users.

	When the hand ends, the scores will be sent to all clients with the
	zHeartsMsgEndHand message.  The clients sould update the display and
	wait for the next zHeartsMsgStartHand.  The sequence repeats now
	until the game is over as determined by the server.

	When the game is over a zHeartsMsgGameOver will be sent.  The clients
	should display the winners to the users and prompt to play again.
	A zHeartsMsgNew game should be sent from client to server to indicate
	willingness to play in a new game.  The client sould exit if a new
	game is not desired.  The server will wait for all players to send
	in the new game message.

	When all new games are in or the client has exited, a zHeartsNewGame
	message is sent.  The message sequence repeats above.

	Notes about computer players:
	There will always be four players willing to play.  The room will
	replace any non-existent human players will computer players.  The
	computer players will be created with the ZSGameComputerNew functions
	and will send and respond to messages just like the real clients.

	Unlike real players, computers can take over a players position at
	anytime.  They know to total game state and will be able to fill in
	for a player who has left.  Real human player kibitzers will be able
	to join only between hands (they can't see what has been played and
	probably will mess up).
*/

/*
	Message definitions: server -> client
*/

/*
	ZHeartsMsgStartGame

	Send player his seat id for future record. 
*/
typedef struct
{
	uint16		numCardsInHand; /* number of cards per hand */
	uint16		numCardsInPass; /* number of cards to be passed */
	uint16		numPointsInGame; /* number of points a game is played to */
	int16		rfu1;
	uint32		gameOptions; /* misc options like J of diamonds or 2 C lead, etc */
	uint32		rfu2;
	/* for future use, define game options like: */
	/* ten of clubs, jack of diamonds, hearts scoreing A=5?, etc. */
	
	/* Protocol 2 */
	ZUserID		players[zHeartsMaxNumPlayers];
} ZHeartsMsgStartGame;

/*
	ZHeartsMsgReplacePlayer

	Send player his seat id for future record. 
*/
typedef struct
{
	ZUserID		playerID; /* the players id so people can request player info */
	ZSeat		seat;
	int16 		fPrompt; //display the alert to the user.
} ZHeartsMsgReplacePlayer;

/*
	ZHeartsMsgStartHand

	Send player hand and direction passing 
*/
typedef struct
{
	ZSeat		passDir;
	ZCard		cards[zHeartsMaxNumCardsInHand]; /* keep cards as last field for alignment purposes */
} ZHeartsMsgStartHand;

/*
	ZHeartsMsgStartPlay

	Sent after all cards have been passed (if there is a pass round).
	Send info on player to start play (the one with 2 c, or depending
	on the rules, the left of dealer)
*/
typedef struct
{
	ZSeat		seat; /* seat to start play */
	int16		rfu;
} ZHeartsMsgStartPlay;

typedef struct
{
	int16		score[zHeartsMaxNumPlayers];
	ZSeat		runPlayer; /* seat of player who ran */
} ZHeartsMsgEndHand;

/*
	ZHeartsMsgEndGame

	Sent to inform client that a game has ended.  Client should
	prompt player to see if a new game is desired
*/

/*
	Message definitions: client -> server
*/

/*
	ZHeartsMsgPassCards

	Indicates the cards passed.
*/
typedef struct
{
	ZSeat		seat;
	ZCard		pass[zHeartsMaxNumCardsInPass];
} ZHeartsMsgPassCards;

/*
	ZHeartsMsgClientReady

	The client program on launch is expected to check in immediately
	with the server.  All clients send their seat to the server indicating
	they are successfully launched and ready to begin.
*/
typedef struct
{
    uint32      protocolSignature;          /* Will be 0x4321 for Protocol 2 and above. */
	uint32		protocolVersion;
	uint32		version;
    ZSeat       seat;
    int16       rfu;
} ZHeartsMsgClientReady;

/*
	ZHeartsMsgPlayCard

	Indicates the card played.
*/
typedef struct
{
	ZSeat		seat;
	ZCard		card;
	uchar		rfu;
} ZHeartsMsgPlayCard;


typedef struct
{
	int16 forfeiter;
	ZBool timeout;
} ZHeartsMsgEndGame;


/*
	ZHeartsMsgNewGame

	After a game over occurs, each player may request to start a new game.
	If a new game is requested the ZHeartsNewGame message is sent.  If no
	new game is requested, then the player merely exits.

	A request for a new game is sent through this mechanism.  A vote of 
	no new game is just indicated by exiting the game client.
*/
typedef struct
{
	ZSeat		seat;
} ZHeartsMsgNewGame;

/*
	ZHeartsMsgTalk
	
	Sent by client to server whenever a user talks on the table. The server in turn
	broadcasts this message to all players on the table.
*/
typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	uint16		messageLen;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZHeartsMsgTalk;

typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	int16		rfu;
} ZHeartsMsgGameStateRequest;

/*
	The following message structure is used by the game server to inform
	of a game client on the current state of the game. Primarily used for
	adding kibitzers to the game.
*/
typedef struct
{
	/* Game options. */
	uint32		gameOptions;
	int16		numCardsToPass;
	int16		numCardsInDeal;
	int16		numPointsForGame;

	/* Game state. */
	ZSeat		playerToPlay;
	int16		passDirection;
	int16		numCardsInHand;
	ZSeat		leadPlayer;
	int16		pointsBroken;
	int16       state;
	ZCard		cardsInHand[zHeartsMaxNumCardsInHand];
	ZCard		cardsPlayed[zHeartsMaxNumPlayers];
	int16		scores[zHeartsMaxNumPlayers];
	int16		playerPassed[zHeartsMaxNumPlayers];
	ZCard		cardsPassed[zHeartsMaxNumCardsInPass];
	int16		tricksWon[zHeartsMaxNumPlayers];
	
	/* Protocol 2 */
	ZUserID		players[zHeartsMaxNumPlayers];
	ZUserID		playersToJoin[zHeartsMaxNumPlayers];
	uint32		tableOptions[zHeartsMaxNumPlayers];
	int16		newGameVotes[zHeartsMaxNumPlayers];
    int16       numHandsPlayed;

	ZBool		fRatings;
	int16		nCloseStatus;
	int16		nCloserSeat;

    /* Protocol 3 - changed from p2 */
    int16       scoreHistory[1];  // sized as needed

} ZHeartsMsgGameStateResponse;

typedef struct
{
	int16		seat;
	int16		rfu;
	uint32		options;
} ZHeartsMsgOptions;


/*
	A joining player checks in with the server. Once checked in, the
	server sends to the client the current game state. The client is
	considered like a kibitzer until included into the game. When
	the player is included into the game, ZHeartsMsgReplacePlayer
	message is sent to all the clients.
*/
typedef struct
{
	ZUserID		userID;
	int16		seat;
} ZHeartsMsgCheckIn;

typedef struct
{
	int16		seat;
	int16		targetSeat;
	int16		ratedGame;
	int16		rfu;
} ZHeartsMsgRemovePlayerRequest;

typedef struct
{
	int16		seat;
	int16		requestSeat;
	int16		targetSeat;
	int16		response;				/* 0 = no, 1 = yes, -1 = clear pending request */
} ZHeartsMsgRemovePlayerResponse;


//dossier messages
typedef struct
{
	int16 		seat;  
	ZUserID		user;
	char 		userName[zUserNameLen + 1];
	int16		message;
}ZHeartsMsgDossierData;


typedef struct
{
	int16 seat;
	int16 vote;
} ZHeartsMsgDossierVote;


typedef struct
{
	int16 seat;
	int16 nClose;
} ZHeartsMsgCloseRequest;


typedef struct
{
	int16 seat;
	int16 reason;
} ZHeartsMsgCloseDenied;


/* -------- Endian Conversion Routines -------- */
void ZHeartsMsgReplacePlayerEndian(ZHeartsMsgReplacePlayer* m);
void ZHeartsMsgStartGameEndian(ZHeartsMsgStartGame* m);
void ZHeartsMsgClientReadyEndian(ZHeartsMsgClientReady* m);
void ZHeartsMsgStartHandEndian(ZHeartsMsgStartHand* m);
void ZHeartsMsgNewGameEndian(ZHeartsMsgNewGame* m);
void ZHeartsMsgPlayCardEndian(ZHeartsMsgPlayCard* m);
void ZHeartsMsgPassCardsEndian(ZHeartsMsgPassCards* m);
void ZHeartsMsgEndHandEndian(ZHeartsMsgEndHand* m);
void ZHeartsMsgEndGameEndian(ZHeartsMsgEndGame *m);
void ZHeartsMsgStartPlayEndian(ZHeartsMsgStartPlay* m);
void ZHeartsMsgTalkEndian(ZHeartsMsgTalk* m);
void ZHeartsMsgGameStateRequestEndian(ZHeartsMsgGameStateRequest* m);
void ZHeartsMsgGameStateResponseEndian(ZHeartsMsgGameStateResponse* m, int16 conversion);
void ZHeartsMsgOptionsEndian(ZHeartsMsgOptions* m);
void ZHeartsMsgCheckInEndian(ZHeartsMsgCheckIn* m);
void ZHeartsMsgRemovePlayerRequestEndian(ZHeartsMsgRemovePlayerRequest* msg);
void ZHeartsMsgRemovePlayerResponseEndian(ZHeartsMsgRemovePlayerResponse* msg);
void ZHeartsMsgDossierDataEndian(ZHeartsMsgDossierData *msg);
void ZHeartsMsgDossierVoteEndian(ZHeartsMsgDossierVote *msg);
void ZHeartsMsgCloseRequestEndian(ZHeartsMsgCloseRequest *msg);
void ZHeartsMsgCloseDeniedEndian(ZHeartsMsgCloseDenied *msg);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\protocol.h ===
/**************************************************************************

    protocol.h

    Contains global Zone protocol information.  No more than the
    protocol signature of any individual protocol should be defined here.

    Copyright (C) 1999  Microsoft Corporation

**************************************************************************/


#ifndef _PROTOCOL_
#define _PROTOCOL_


#define zPortZoneProxy       28803
#define zPortMillenniumProxy 28805


#define zProductSigZone       'ZoNe'
#define zProductSigMillennium 'FREE'


#define zProtocolSigProxy           'rout'
#define zProtocolSigLobby           'lbby'
#define zProtocolSigSecurity        'zsec'
#define zProtocolSigInternalApp     'zsys'  // messages the connection layer sends as application messages - should be phased out


// context of various URL navigation attempts, usu. indicated as "?ID=4"
enum
{
    ZONE_ContextOfAdRequest = 1,
    ZONE_ContextOfAd = 2,
    ZONE_ContextOfEvergreen = 3,
    ZONE_ContextOfMenu = 4
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\proxymsg.h ===
/*******************************************************************************

	ProxyMsg.h
	
	Protocol for the Proxy
		 
*******************************************************************************/


#ifndef _ProxyMsg_H_
#define _ProxyMsg_H_


#include "zgameinfo.h"

#pragma pack(push, 4)


#define zProxyProtocolVersion 1


/////////////////////////////////////////////////////////////////////
// Header used on all Proxy messages
//
//
typedef struct
{
    uint16 weType;
    uint16 wLength;
} ZProxyMsgHeader;

enum // weType
{
    zProxyHiMsg = 0,
    zProxyHelloMsg,
    zProxyGoodbyeMsg,
    zProxyWrongVersionMsg,
    zProxyServiceRequestMsg,
    zProxyServiceInfoMsg,
    zProxyNumBasicMessages
};


/////////////////////////////////////////////////////////////////////
// First message sent.
//
// client -> server
typedef struct
{
    ZProxyMsgHeader oHeader;
    uint32 dwProtocolVersion;
    char szSetupToken[GAMEINFO_SETUP_TOKEN_LEN + 1];
    uint32 dwClientVersion;   // version is 8 bits, 6bits, 14 bits, and 4 bits, making the largest version 255.63.16383.15
} ZProxyHiMsg;


/////////////////////////////////////////////////////////////////////
// First message sent back if successful.
//
// server -> client
typedef struct
{
    ZProxyMsgHeader oHeader;
} ZProxyHelloMsg;


/////////////////////////////////////////////////////////////////////
// First message sent back if failed.
//
// server -> client
typedef struct
{
    ZProxyMsgHeader oHeader;
    uint32 dweReason;
} ZProxyGoodbyeMsg;

enum // dweReason (goodbye)
{
    zProxyGoodbyeProtocolVersion = 0,
    zProxyGoodbyeBanned
};


/////////////////////////////////////////////////////////////////////
// First message sent back if client out of date.
//
// server -> client
typedef struct
{
    ZProxyMsgHeader oHeader;
    char szSetupToken[GAMEINFO_SETUP_TOKEN_LEN + 1];
    uint32 dwClientVersionReqd;   // version is 8 bits, 6bits, 14 bits, and 4 bits, making the largest version 255.63.16383.15
    uint32 dweLocationCode;
    char szLocation[1];   // variable
} ZProxyWrongVersionMsg;

enum // dweLocationCode
{
    zProxyLocationUnknown = 0,
    zProxyLocationURLManual,
    zProxyLocationURLZat,
    zProxyLocationWindowsUpdate,
    zProxyLocationPackaged
};


/////////////////////////////////////////////////////////////////////
// Request for service info, connection, disconnection from client.
//
// client -> server
typedef struct
{
    ZProxyMsgHeader oHeader;
    uint32 dweReason;
    char szService[GAMEINFO_INTERNAL_NAME_LEN + 1];
    uint32 dwChannel;
} ZProxyServiceRequestMsg;

enum // dweReason (service request)
{
    zProxyRequestInfo = 0,
    zProxyRequestConnect,
    zProxyRequestDisconnect
};


/////////////////////////////////////////////////////////////////////
// Service information.
//
// server -> client
typedef struct
{
    ZProxyMsgHeader oHeader;
    uint32 dweReason;
    char szService[GAMEINFO_INTERNAL_NAME_LEN + 1];
    uint32 dwChannel;
    uint32 dwFlags;
    union
    {
        uint32 dwMinutesRemaining;  // filled in if dwFlags == 0x0f
        uint32 dwMinutesDowntime;   // filled in if !(dwFlags & 0x01)
        struct
        {
            IN_ADDR ipAddress;
            uint16 wPort;
        } ox;                       // filled in if dwFlags == 0x01
    };
} ZProxyServiceInfoMsg;

enum // dweReason (service info)
{
    zProxyServiceInfo = 0,
    zProxyServiceConnect,
    zProxyServiceDisconnect,
    zProxyServiceStop,
    zProxyServiceBroadcast
};

// dwFlags
#define zProxyServiceAvailable 0x01
#define zProxyServiceLocal     0x02
#define zProxyServiceConnected 0x04
#define zProxyServiceStopping  0x08


// MILLENNIUM SPECIFIC /////////////////////////////////////////////////

enum
{
    zProxyMillIDMsg = zProxyNumBasicMessages,
    zProxyMillSettingsMsg
};


/////////////////////////////////////////////////////////////////////
// Sent immediately after the Hi message (before waiting for Hello)
//
// client -> server
typedef struct
{
    ZProxyMsgHeader oHeader;
    LANGID wSysLang;
    LANGID wUserLang;
    LANGID wAppLang;
    int16 wTimeZoneMinutes;
} ZProxyMillIDMsg;


/////////////////////////////////////////////////////////////////////
// Sent immediately after the Hello message
//
// server -> client
typedef struct
{
    ZProxyMsgHeader oHeader;
    uint16 weChat;
    uint16 weStatistics;
} ZProxyMillSettingsMsg;

enum // weChat
{
    zProxyMillChatUnknown = 0,  // never sent in protocol

    zProxyMillChatFull,
    zProxyMillChatRestricted,
    zProxyMillChatNone
};

enum // weStatistics
{
    zProxyMillStatsUnknown = 0,  // never sent in protocol

    zProxyMillStatsAll,
    zProxyMillStatsMost,
    zProxyMillStatsMinimal
};


#pragma pack(pop)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\spades.h ===
/*******************************************************************************

	spades.h
	
		Spades interface protocol.
	
	Copyright  Electric Gravity, Inc. 1996. All rights reserved.
	Written by Kevin Binkley, Hoon Im
	Created on Monday January 8, 1996
	
	Change History (most recent first):
	----------------------------------------------------------------------------
	Rev	 |	Date	 |	Who	 |	What
	----------------------------------------------------------------------------
	1		07/11/97	leonp	Added new constants and macros from AI enhancements.
	0		01/06/96	HI		Created.
	 
*******************************************************************************/


#ifndef _SPADES_
#define _SPADES_

#ifdef __cplusplus
extern "C" {
#endif


//dossier
enum{
zRatingsUnrated,  //this in an unrated lobby.
zRatingsEnabled,
zRatingsDisabled,
zRatingsGameOver,
};

#define zSpadesProtocolSignature            'shvl'
#define zSpadesProtocolVersion				4

#define zSpadesNumCardsInHand				13
#define zSpadesNumCardsInPass				3
#define zSpadesNoCard						127

#define zCardNone							127
#define zDeckNumCards						52
#define zDeckNumSuits						4
#define zDeckNumCardsInSuit					13

#define zSpadesNumPlayers					4
#define zNumPlayersPerTable					4
#define zSpadesNumTeams						2
#define zSpadesNoPlayer						(-1)

#define zSpadesMaxNumScores					50

//leonp AI enhancements
#define zAceDiamonds						12
#define zAceClubs							25
#define zAceHearts							38
#define zAceSpades							51
#define zNotCutting							127
#define zNoLowSuit							127

#define zAceRank							12
#define zKingRank							11
#define zQueenRank							10
#define zJackRank							9

#define z


/* -------- Bids -------- */
#define zSpadesBidNone						((char) -1)
#define zSpadesBidDoubleNil					((char) 0x80)

/* -------- Usefull Macros -------- */
//leonp - made functions with error checking

//#ifndef _SPADES_SERVER_

#define ZSuit(x)							((x) / 13)
#define ZRank(x)							((x) % 13) 

//#endif


//int16 ZRank(char x);
//int16 ZSuit(char x);


#define ZCardMake(suit, rank)				(13 * (suit) + (rank))
#define ZGetPartner(seat)					(((seat) + 2) % zSpadesNumPlayers)
#define ZGetTeam(seat)						((seat) % zSpadesNumTeams)


/* -------- Suit Order -------- */
enum
{
	zSuitDiamonds = 0,
	zSuitClubs,
	zSuitHearts,
	zSuitSpades
};


enum
{
	/* Game Options */
	zSpadesOptionsHideCards		= 0x00010000,
		/*
			If set, kibitzers cannot see a player's hand. Per player option.
		*/

	/* Server States */
	zSpadesServerStateNone = 0,
	zSpadesServerStateBidding,
	zSpadesServerStatePassing,
	zSpadesServerStatePlaying,
	zSpadesServerStateEndHand,
	zSpadesServerStateEndGame,
	
	/* Client Game States */
	zSpadesGameStateInit = 0,
	zSpadesGameStateStartGame,
	zSpadesGameStateBid,
	zSpadesGameStatePass,
	zSpadesGameStatePlay,
	zSpadesGameStateEndHand,
	zSpadesGameStateEndGame,
	
	/* Game Messages */
    zSpadesMsgClientReady = 0x100,
	zSpadesMsgStartGame,
	zSpadesMsgReplacePlayer,
	zSpadesMsgStartBid,
	zSpadesMsgStartPass,
	zSpadesMsgStartPlay,
	zSpadesMsgEndHand,
	zSpadesMsgEndGame,
	zSpadesMsgBid,
	zSpadesMsgPass,
	zSpadesMsgPlay,
	zSpadesMsgNewGame,
	zSpadesMsgTalk,
	zSpadesMsgGameStateRequest,
	zSpadesMsgGameStateResponse,
	zSpadesMsgOptions,
	zSpadesMsgCheckIn,
	zSpadesMsgTeamName,
	zSpadesMsgRemovePlayerRequest,
	zSpadesMsgRemovePlayerResponse,
	zSpadesMsgRemovePlayerEndGame,

	//dossier code
	zSpadesMsgDossierData,  //prompt the client to display UI data
	zSpadesMsgDossierVote,

	zSpadesMsgShownCards,
	
	zSpadesMsgDumpHand = 1024
};


//dossier data constants
enum
{
    zNotVoted,
    zVotedNo,
    zVotedYes
};

enum{
	zDossierBotDetected,
	zDossierAbandonNoStart,
	zDossierAbandonStart,
	zDossierMultiAbandon,   
	zDossierRatingsReEnabled,
	zDossierRatingsEnabled,
	zDossierVoteCompleteWait,
	zDossierVoteCompleteCont,
	zDossierMoveTimeout,   
	zDossierSpadesRejoin,  //send when the new player rejoins remove the dialog box
	zDossierEndGameTimeout,
	zDossierEndGameForfeit, 
};

typedef struct
{
	int16		boardNumber;
	int16		rfu;
	char		bids[zSpadesNumPlayers];
	int16		scores[zSpadesNumTeams];
	int16		bonus[zSpadesNumTeams];

    // new for new Hand Result dialog
    int16       base[zSpadesNumTeams];
    int16       bagbonus[zSpadesNumTeams];
    int16       nil[zSpadesNumTeams];
    int16       bagpenalty[zSpadesNumTeams];
} ZHandScore;


typedef struct
{
	int16		numScores;
	int16		rfu;
	int16		totalScore[zSpadesNumTeams];
	ZHandScore	scores[zSpadesMaxNumScores];
} ZTotalScore;


typedef struct
{
	int16		numGames;
	int16		rfu;
	int16		wins[zSpadesNumTeams];
	int16		gameScores[zSpadesMaxNumScores][zSpadesNumTeams];
} ZWins;


typedef struct
{
    uint32      protocolSignature;
	uint32		protocolVersion;
	uint32		version;
    ZUserID     playerID;
    int16       seat;
    int16       rfu;
} ZSpadesMsgClientReady;

/*
	Use gameOptions for game variations and features.
	Specific game features are available then all the
	clients have the capability. Hence, the server
	checks whether all clients can support the feature
	before enabling it.
*/
typedef struct
{
	ZUserID		players[zSpadesNumPlayers];
	uint32		gameOptions;
	int16		numPointsInGame;
	int16		minPointsInGame;
} ZSpadesMsgStartGame;

typedef struct
{
	ZUserID		playerID;
	int16		seat;
	int16 		fPrompt;
} ZSpadesMsgReplacePlayer;

typedef struct
{
	int16		boardNumber;
	int16		dealer;							/* Opens bidding */
	char		hand[zSpadesNumCardsInHand];
} ZSpadesMsgStartBid;

typedef struct
{
	char		seat[zSpadesNumPlayers];		/* boolean */
} ZSpadesMsgStartPass;

typedef struct
{
	int16		leader;
} ZSpadesMsgStartPlay;

typedef struct
{
	int16		bags[zSpadesNumTeams];
    ZHandScore  score;
} ZSpadesMsgEndHand;

typedef struct
{
	char		winners[zSpadesNumPlayers];
} ZSpadesMsgEndGame;

typedef struct
{
	int16		seat;
	int16		nextBidder;
	char		bid;
} ZSpadesMsgBid;

typedef struct
{
	int16		seat;
	char		pass[zSpadesNumCardsInPass];
} ZSpadesMsgPass;

typedef struct
{
	int16		seat;
	int16		nextPlayer;
	char		card;
} ZSpadesMsgPlay;

typedef struct
{
	int16		seat;
} ZSpadesMsgNewGame;

typedef struct
{
	ZUserID		playerID;
	uint16		messageLen;
	int16		rfu;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZSpadesMsgTalk;

typedef struct
{
	ZUserID		playerID;
	int16		seat;
	int16		rfu;
} ZSpadesMsgGameStateRequest;

typedef struct
{
	ZUserID		players[zSpadesNumPlayers];
	WCHAR		teamNames[zSpadesNumTeams][zUserNameLen + 1];
	ZUserID		playersToJoin[zSpadesNumPlayers];
	uint32		tableOptions[zSpadesNumPlayers];
	uint32		gameOptions;
	int16		numPointsInGame;
	int16		minPointsInGame;
	int16		numHandsPlayed;
	int16		numGamesPlayed;
	int16		playerToPlay;
	int16		numCardsInHand;
	int16		leadPlayer;
	int16       state;
	int16		dealer;
	int16		trumpsBroken;
	char		cardsInHand[zSpadesNumCardsInHand];
	char		cardsPlayed[zSpadesNumPlayers];
	char		playerPassed[zSpadesNumPlayers];
	char		cardsPassed[zSpadesNumCardsInPass];
	char		bids[zSpadesNumPlayers];
	int16		tricksWon[zSpadesNumPlayers];
	char		newGameVotes[zSpadesNumPlayers];
	int16		toPass[zSpadesNumPlayers];
	int16		bags[zSpadesNumTeams];
	ZTotalScore	totalScore;
	ZWins		wins;
    ZBool       rated;
	ZBool		fShownCards[zNumPlayersPerTable];
} ZSpadesMsgGameStateResponse;

typedef struct
{
	int16 seat;
}ZSpadesMsgShownCards;

//dossier messages
typedef struct
{
	int16 		seat;  
	int16		timeout;
	ZUserID		user;
	int16		message;
	WCHAR 		userName[zUserNameLen + 1];
}ZSpadesMsgDossierData;


typedef struct
{
	int16 seat;
	int16 vote;
} ZSpadesMsgDossierVote;

typedef struct
{
	int16		seat;
	int16		rfu;
	uint32		options;
} ZSpadesMsgOptions;

typedef struct
{
	ZUserID		playerID;
	int16		seat;
} ZSpadesMsgCheckIn;

typedef struct
{
	int16		seat;
	int16		rfu;
	WCHAR		name[zUserNameLen + 1];
} ZSpadesMsgTeamName;

typedef struct
{
	int16		seat;
	int16		targetSeat;
	int16		ratedGame;
	int16		rfu;
} ZSpadesMsgRemovePlayerRequest;

typedef struct
{
	int16		seat;
	int16		requestSeat;
	int16		targetSeat;
	int16		response;				/* 0 = no, 1 = yes, -1 = clear pending request */
} ZSpadesMsgRemovePlayerResponse;

typedef struct
{
	int16		seatLosing;
	int16		seatQuitting;
	int16		reason;					/* 0 = quit, 1  = timeout*/
} ZSpadesMsgRemovePlayerEndGame;


/* -------- Endian Conversion Routines -------- */
void ZSpadesMsgClientReadyEndian(ZSpadesMsgClientReady* msg);
void ZSpadesMsgStartGameEndian(ZSpadesMsgStartGame* msg);
void ZSpadesMsgReplacePlayerEndian(ZSpadesMsgReplacePlayer* msg);
void ZSpadesMsgStartBidEndian(ZSpadesMsgStartBid* msg);
void ZSpadesMsgStartPassEndian(ZSpadesMsgStartPass* msg);
void ZSpadesMsgStartPlayEndian(ZSpadesMsgStartPlay* msg);
void ZSpadesMsgEndHandEndian(ZSpadesMsgEndHand* msg);
void ZSpadesMsgEndGameEndian(ZSpadesMsgEndGame* msg);
void ZSpadesMsgBidEndian(ZSpadesMsgBid* msg);
void ZSpadesMsgPassEndian(ZSpadesMsgPass* msg);
void ZSpadesMsgPlayEndian(ZSpadesMsgPlay* msg);
void ZSpadesMsgNewGameEndian(ZSpadesMsgNewGame* msg);
void ZSpadesMsgTalkEndian(ZSpadesMsgTalk* msg);
void ZSpadesMsgGameStateRequestEndian(ZSpadesMsgGameStateRequest* msg);
void ZSpadesMsgGameStateResponseEndian(ZSpadesMsgGameStateResponse* msg, int16 conversion);
void ZSpadesMsgOptionsEndian(ZSpadesMsgOptions* msg);
void ZSpadesMsgCheckInEndian(ZSpadesMsgCheckIn* msg);
void ZSpadesMsgTeamNameEndian(ZSpadesMsgTeamName* msg);
void ZSpadesMsgRemovePlayerRequestEndian(ZSpadesMsgRemovePlayerRequest* msg);
void ZSpadesMsgRemovePlayerResponseEndian(ZSpadesMsgRemovePlayerResponse* msg);
void ZSpadesMsgDossierDataEndian(ZSpadesMsgDossierData *msg);
void ZSpadesMsgDossierVoteEndian(ZSpadesMsgDossierVote *msg);
void ZSpadesMsgShownCardsEndian(ZSpadesMsgShownCards *msg);


#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\reversi.h ===
#ifndef _REVERSI_H_
#define _REVERSI_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "zgame.h"

/* Table Gameroom Message Protocol */

#define zReversiProtocolSignature       'rvse'
#define zReversiProtocolVersion			3

typedef int16 ZSeat;

/* -------- Player Info -------- */
typedef struct
{
	ZUserID			userID;
	TCHAR			name[zUserNameLen + 1];
	TCHAR			host[zHostNameLen + 1];
} TPlayerInfo, *TPlayerInfoPtr;


/*
	Reversi Game Message Types
*/
enum {
	/* client -> server */
    zReversiMsgNewGame = 0x100,
	zReversiMsgMovePiece,
	zReversiMsgTalk,
	zReversiMsgEndGame,
	zReversiMsgEndLog,
	zReversiMsgFinishMove,
	
	zReversiMsgPlayers,			/* Uses the same message NewGame */

    zReversiMsgGameStateReq,
    zReversiMsgGameStateResp,
	zReversiMsgMoveTimeout,
	zReversiMsgVoteNewGame,
};

/*
	Message definitions: server -> client
*/

/*
	Message definitions: client -> server
*/

/*
	ZReversiMsgNewGame

	The client program on launch is expected to check in immediately
	with the server.  All clients send their seat to the server indicating
	they are successfully launched and ready to begin.
*/
typedef struct {

	/* Protocol 2 */
    int32 protocolSignature;        /* client -> server */
	int32 protocolVersion;			/* client -> server */
	int32 clientVersion;			/* client -> server */
	ZUserID playerID;				/* server -> client */
    ZSeat seat;
    int16 rfu;
} ZReversiMsgNewGame;

/*
	ZReversiMsgMovePiece

	Indicates the card played.
*/
typedef struct {
	ZSeat seat;
	int16 rfu;
	ZReversiMove move;
} ZReversiMsgMovePiece;

/*
	ZReversiMsgTalk
	
	Sent by client to server whenever a user talks on the table. The server in turn
	broadcasts this message to all players on the table.
*/
typedef struct
{
	ZUserID		userID;
	ZSeat		seat;
	uint16		messageLen;
	/*
	uchar		message[messageLen];	// Message body
	*/
} ZReversiMsgTalk;

/*
	The following message structure is used by the game server to inform
	of a game client on the current state of the game. Primarily used for
	adding kibitzers to the game.
*/
typedef struct
{
	/* Game options. */
	uint32		gameOptions;

	/* Game state. */
} ZReversiMsgGameState;

typedef struct
{
	int16		seat;
	int16		rfu;
	uint32		flags;
} ZReversiMsgEndGame;

enum
{
	zReversiEndLogReasonTimeout=1,
	zReversiEndLogReasonForfeit, 
	zReversiEndLogReasonWontPlay,
	zReversiEndLogReasonGameOver,
};

typedef struct
{
	int32 numPoints;	// Number of points in match
	int16 reason;
	int16 seatLosing;	// Match loser
	int16 seatQuitting;
	int16 rfu;
	int16 pieceCount[2];
} ZReversiMsgEndLog;

typedef struct
{
	int16 seat;
	int16 rfu;
	uint32 time;
	ZReversiPiece piece;
} ZReversiMsgFinishMove;

typedef struct
{
	int32 userID;    
	int16 seat;
	int16 timeout;
	WCHAR  userName[zUserNameLen + 1];
} ZReversiMsgMoveTimeout;

typedef struct
{
	ZUserID			userID;
	int16			seat;
	int16			rfu;
} ZReversiMsgGameStateReq;

typedef struct
{
	ZUserID			userID;
	int16			seat;
	int16			rfu;
	/*
		game states ...
	*/
	int16			gameState;
	ZBool			newGameVote[2];
	int16			finalScore;
	int16			whiteScore;
	int16			blackScore;
	TPlayerInfo		players[2];
} ZReversiMsgGameStateResp;

typedef struct
{
	int16			seat;
}ZReversiMsgVoteNewGame;

/* -------- Endian Conversion Routines -------- */
void ZReversiMsgGameStateReqEndian(ZReversiMsgGameStateReq* msg);
void ZReversiMsgGameStateRespEndian(ZReversiMsgGameStateResp* msg);

/* -------- Endian Conversion Routines -------- */
void ZReversiMsgMovePieceEndian(ZReversiMsgMovePiece* m);
void ZReversiMsgTalkEndian(ZReversiMsgTalk* m);
void ZReversiMsgNewGameEndian(ZReversiMsgNewGame* m);
void ZReversiMsgGameStateEndian(ZReversiMsgGameState* m);
void ZReversiMsgEndGameEndian(ZReversiMsgEndGame* m);
void ZReversiMsgEndLogEndian(ZReversiMsgEndLog* m);
void ZReversiMsgFinishMoveEndian(ZReversiMsgFinishMove* m);
void ZReversiMsgVoteNewGameEndian(ZReversiMsgVoteNewGame*m);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\common.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-96
#   All Rights Reserved.
#
##########################################################################
#
# Common include file 'sources' files in the getconn project.
#
#
# Required definitions:
#
#     GETCONN_DIR
#        Path to root containing this inc file.
#
#     FREEBUILD
#        Set by makefile.def file.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#     USE_LEGO
#        Define lego macros
#
#     TARGET_WIN95
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT.
#
#     TARGET_BOTH
#        Build component so it will run in both environments.
#

!if !defined(GETCONN_DIR)
!error  GETCONN_DIR must be defined in sources file
!endif

# Set the IE version
#WIN32_IE_VERSION=0x0500

#
# In case you have an old makefile.def
#
!if "$(_OBJ_DIR)" == ""
_OBJ_DIR        = obj
!endif
!if "$(O)" == ""
O               = $(_OBJ_DIR)\$(TARGET_DIRECTORY)
!endif

#
# Set private paths
#

INCLUDES        = .;$(GETCONN_DIR)\inc;$(GETCONN_DIR)\mapi\inc;$(SDK_INC_PATH);$(INCLUDES)

#
# Set common options
#

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN= 1

# Don't link to NT libs
# USE_NOLIBS      = 1
NO_NTDLL =1

!if !defined(SXS_MANIFEST)
#!if defined(TARGET_WIN95)
#  Don't define WINNT
CHICAGO_PRODUCT = 0

#  Since CHICAGO_PRODUCT is defined, we need to define WIN32_DEFINE correctly
#WIN32_DEFINE    = -DWIN32=100 -D_WIN32_WINNT=0x0400
!endif

#CBSTRING        = -cbstring
# RegisB, 05/30/97:  BryanT strongly recommends to remove the CBSTRING entry

UMTYPE          = windows
#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif
#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DNT

!  if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif
!endif

# Backwards compatibility with some personal command files
!if "$(SHELLDBG)" == "1"
C_DEFINES       = $(C_DEFINES) -DDEBUG -DFULL_DEBUG

!elseif "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG

!endif

# Assume we're building for Nashville only right now
C_DEFINES       = $(C_DEFINES) -DNASHVILLE

# This define helps us distinguish our development environment
C_DEFINES       = $(C_DEFINES) -DWINNT_ENV

# IE40-only features
!ifdef FEATURE_IE40
C_DEFINES       = $(C_DEFINES) -DFEATURE_IE40 -DNASH
!endif
# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

#
# Additional linker flags
#
#Not Needed

LINKER_FLAGS    = $(LINKER_FLAGS) -map
!if !$(IA64)
386_STDCALL     = 2
!endif

DEFBASEADDR     = 0x60000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\zone_internetgames\src\shared\protocols\zconnint.h ===
/*******************************************************************************

    ZConnInt.h
    
        Internal connection protocol.
        
        Internal connection data header format:
            0    Signature ('ZoNe')
            4    Data Len
            8    SequenceID
            12    Checksum of Data
            16    Data - Quadbyte aligned
        The whole data packet is encrypted with the key.
    
    Copyright  Electric Gravity, Inc. 1996. All rights reserved.
    Written by Hoon Im
    Created on Monday, April 22, 1996
    
    Change History (most recent first):
    ----------------------------------------------------------------------------
    Rev     |    Date     |    Who     |    What
    ----------------------------------------------------------------------------
    1        01/10/00    JDB       Changed a lot.
    0        04/22/96    HI        Created.
     
*******************************************************************************/


/*
 @doc ZCONNECTION

 @topic Zone Platform Connection Layer Protocol |
 Defines protocol which uses TCP/IP to create a secure message (not stream)
 based transport for the application level protocol to use.
 @comm 
 Zone utilizes a proprietary data format for sending and receiving data 
 via TCP/IP sockets to prevent system attacks through random connections 
 by non-Zone systems. All messages are sequenced, checksummed, and keyed 
 (encrypted) before they are written out onto a socket and all messages 
 are unkeyed (decrypted), and checksum and sequence verified after 
 they are read from a socket. The Connection Layer (client and server) 
 encapsulates this whole process tightly such that applications using 
 the Connection Layer protocol do not realize its existence.
 Connection Layer places, as part of this encapsulation, 
 a 16 byte header  <t ZConnInternalHeaderType> 
 to every message sent out through Connection Layer.
 This header and the message data <t ZConnMessageHeaderType>
 are then keyed (encrypted) with a 
 connection key before being written out to the socket.
 The encryption key is generated during connection 
 handshaking at initialization where the server, 
 upon receiving a 'Hi' message <t ZConnInternalHiMsgType> from the client, 
 sends a 'Hey' <t ZConnInternalKeyMsgType> message to the client with 
 a randomly selected encryption key.
<bmp zconnint\.bmp>
<nl><nl>
All communication, server-client and server-server, 
use a simple numerical value message system to which 
variable length data may be attached. A message is of the form
<t ZConnMessageHeaderType> where length may equal 0.
Messages (or also called message types) are unsigned 32bit values. 
Values in the 0x80000000 to 0xFFFFFFFF range are reserved for system 
level messages. Server and client programs may use values in the 
0x00000000 to 0x7FFFFFFF range.
<nl><nl>

As a convention, a communication is initiated by the client by 
registering with the server.
All messages are converted into big-endian format before they are written out to the network and are converted into system endian format after reading a message from the network. Hence, for every message, there is a corresponding endian conversion ro
utine. For example, for the zSampleMessage, ZSampleMessageEndian() routine exists to convert the message into the proper format; this routine is called everytime before writing and after reading to and from the network.

 @index | ZCONNECTION ZONE

 @normal Created by Hoon Im, Copyright (c)1996 Microsoft Corporation, All Rights Reserved
*/

#ifndef _ZCONNINT_
#define _ZCONNINT_


#pragma pack( push, 4 )


#ifdef __cplusplus
extern "C" {
#endif


//@msg zInternalConnectionSig | A unsigned integer which equals 'LiNk'
#define zConnInternalProtocolSig            'LiNk'
#define zConnInternalProtocolVersion        3

#define zConnInternalInitialSequenceID      1


// internal protocol message types
enum
{
    zConnInternalGenericMsg = 0,
    zConnInternalHiMsg,
    zConnInternalHelloMsg,
    zConnInternalGoodbyeMsg,
    zConnInternalKeepAliveMsg,
    zConnInternalPingMsg
};


// header used for all Internal messages
typedef struct
{
    uint32 dwSignature;
    uint32 dwTotalLength;
    uint16 weType;
    uint16 wIntLength;
} ZConnInternalHeader;


// Hi message - the first message sent
// client -> server
typedef struct
{
    ZConnInternalHeader oHeader;
    uint32 dwProtocolVersion;
    uint32 dwProductSignature;
    uint32 dwOptionFlagsMask;
    uint32 dwOptionFlags;
    uint32 dwClientKey;
    GUID uuMachine;   // machine ID stored by the network layer in the registry - better than IP in identifying a particular machine
//  ... application messages  (not currently implemented and not checksummed)
} ZConnInternalHiMsg;


// Hello message - the response to Hi indicating success
// server -> client
typedef struct
{
    ZConnInternalHeader oHeader;
    uint32 dwFirstSequenceID;
    uint32 dwKey;
    uint32 dwOptionFlags;
    GUID uuMachine;   // machine ID stored by the network layer in the registry - better than IP in identifying a particular machine
//  ... application messages  (not currently implemented and not checksummed)
} ZConnInternalHelloMsg;

// option flags - if bit set in options flags mask, then setting of bit in options flags is requirement for client.
// server sends negotiated options or disconnects if unreasonable.
#define zConnInternalOptionAggGeneric 0x01  // if set, generic messages may contain multiple application messages
#define zConnInternalOptionClientKey  0x02  // if set, the client-specified key sent in the Hi message is used (otherwise server creates a key)

// Goodbye message - the response to Hi indicating failure (not currently implemented)
// server -> client
typedef struct
{
    ZConnInternalHeader oHeader;
    uint32 dweReason;
} ZConnInternalGoodbyeMsg;

// goodbye reasons
enum
{
    zConnInternalGoodbyeGeneric = 0,
    zConnInternalGoodbyeFailVersion,
    zConnInternalGoodbyeFailProduct,
    zConnInternalGoodbyeBusy,
    zConnInternalGoodbyeForever
};


// Generic message - used for all subsequent application communication
// both directions
typedef struct
{
    ZConnInternalHeader oHeader;
    uint32 dwSequenceID;
    uint32 dwChecksum;
//  ... application messages
//  ZConnInternalGenericFooter
} ZConnInternalGenericMsg;

// footer used for all Generic messages (NEVER checksummed or encrypted)
typedef struct
{
    uint32 dweStatus;
} ZConnInternalGenericFooter;

enum // dweStatus - Footer
{
    zConnInternalGenericCancelled = 0,  // must be zero
    zConnInternalGenericOk
};


#if 0

    // - Not currently implemented - the existing network layer implements these as application messages
    // - changing that would be too much effort right now though it should be done

    // Keepalive message - used to periodically verify that connection is alive
    // both directions
    typedef struct
    {
        ZConnInternalHeader oHeader;
    } ZConnInternalKeepaliveMsg;


    // Ping request - used to test the latency of a connection
    //
    // If dwMyClk is not zero, implies that a ping reply is requested - set dwYourClk = dwMyClk + <processing time>
    //
    // If dwYourClk is not zero, GetTickCount() - dwYourClk is the round trip time.
    //
    // for each, make sure to change 0 to 0xffffffff if you mean for it to have a value
    //
    // both directions
    typedef struct
    {
        ZConnInternalHeader oHeader;
        uint32 dwYourClk;
        uint32 dwMyClk;
    } ZConnInternalPingMsg;

#else

    // The old way, using special application messages as pings and keepalives
    enum
    {
        zConnectionKeepAlive		= 0x80000000,
        zConnectionPing				= 0x80000001,
        zConnectionPingResponse		= 0x80000002
    };

#endif


// Application header - all application messages must begin with this header
// Multiple application messages, seperated only by this header, may be present in a single Internal-layer message
typedef struct
{
    uint32 dwSignature;
    uint32 dwChannel;
    uint32 dwType;
    uint32 dwDataLength;
//  ... application data
} ZConnInternalAppHeader;


#ifdef __cplusplus
}
#endif


#pragma pack( pop )


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icfgnt5\tapi.cpp ===
#include <windows.h>
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <tapi.h>


//
// The code below is stolen from private/net/ras/src/ui/setup/src/tapiconf.cxx
//

#define REGISTRY_INSTALLED_TAPI  SZ("HARDWARE\\DEVICEMAP\\TAPI DEVICES\\")
#define REGISTRY_ALTERNATE_TAPI  SZ("SOFTWARE\\MICROSOFT\\TAPI DEVICES\\")

// note that this definition DOES NOT have trailing \\, because DeleteTree
// doesn't like it.
#define REGISTRY_CONFIGURED_TAPI SZ("SOFTWARE\\MICROSOFT\\RAS\\TAPI DEVICES")

#define TAPI_MEDIA_TYPE          SZ("Media Type")
#define TAPI_PORT_ADDRESS        SZ("Address")
#define TAPI_PORT_NAME           SZ("Friendly Name")
#define TAPI_PORT_USAGE          SZ("Usage")

#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)

#define MAX_DEVICE_TYPES 64

VOID FAR PASCAL RasTapiCallback (HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD);
DWORD EnumerateTapiModemPorts(DWORD dwBytes, LPTSTR szPortsBuf, 
								BOOL bWithDelay = FALSE);



DWORD
EnumerateTapiModemPorts(DWORD dwBytes, LPTSTR szPortsBuf, BOOL bWithDelay) {
    LINEINITIALIZEEXPARAMS params;
    LINEADDRESSCAPS        *lineaddrcaps ;
    LINEDEVCAPS            *linedevcaps ;
    LINEEXTENSIONID        extensionid ;
    HLINEAPP               RasLine ;
    HINSTANCE              RasInstance = GetModuleHandle(TEXT("ICFGNT.DLL"));
    DWORD                  NegotiatedApiVersion ;
    DWORD                  NegotiatedExtVersion = 0;
    WORD                   i, k ;
    DWORD                  lines = 0 ;
    BYTE                   buffer[1000] ;
    DWORD                  totaladdress = 0;
    TCHAR                  *address ;
    TCHAR                  szregkey[512];
    LONG                   lerr;
    DWORD                  dwApiVersion = HIGH_VERSION;
    LPTSTR                 szPorts = szPortsBuf;

    *szPorts = '\0';
    dwBytes--;

    ZeroMemory(&params, sizeof(params));

    params.dwTotalSize = sizeof(params);
    params.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;

    /* the sleep is necessary here because if this routine is called just after a modem
    ** has been added from modem.cpl & unimdm.tsp is running,
    ** then a new modem added doesn't show up in the tapi enumeration.
    */

    //
	// We should not always sleep here - should sleep only if ModemWizard was
	// launched recently  -- VetriV
	//
	if (bWithDelay)
		Sleep(1000L);

    if (lerr = lineInitializeExW (&RasLine,
                                 RasInstance,
                                 (LINECALLBACK) RasTapiCallback,
                                 NULL,
                                 &lines,
                                 &dwApiVersion,
                                 &params))
    {
         return lerr;
    }

    // Go through all lines to see if we can find a modem
    for (i=0; i<lines; i++)
    {  // for all lines we are interested in get the addresses -> ports

       if (lineNegotiateAPIVersion(RasLine, i, LOW_VERSION, HIGH_VERSION, &NegotiatedApiVersion, &extensionid))
       {
           continue ;
       }

       memset (buffer, 0, sizeof(buffer)) ;

       linedevcaps = (LINEDEVCAPS *)buffer ;
       linedevcaps->dwTotalSize = sizeof (buffer) ;

       // Get a count of all addresses across all lines
       //
       if (lineGetDevCapsW (RasLine, i, NegotiatedApiVersion, NegotiatedExtVersion, linedevcaps))
       {
           continue ;
       }

       // is this a modem?
       if ( linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM )  {
            // first convert all nulls in the device class string to non nulls.
            //
            DWORD  j ;
            WCHAR *temp ;

            for (j=0, temp = (WCHAR*)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset); j<linedevcaps->dwDeviceClassesSize; j++, temp++)
            {
              if (*temp == L'\0')
                 *temp = L' ' ;
            }

            //
            // select only those devices that have comm/datamodem as a device class
            //

            LPWSTR wszClassString = wcsstr((WCHAR*)((CHAR *)linedevcaps+linedevcaps->dwDeviceClassesOffset), L"comm/datamodem");
            if(wszClassString == NULL)
                continue;
        }

        LONG lRet;
        HLINE lhLine = 0;

        lRet = lineOpen(RasLine, i, &lhLine, dwApiVersion, 0, 0, LINECALLPRIVILEGE_NONE, 0, NULL);
        if(lRet != 0)
            continue;

        LPVARSTRING lpVarString;
        TCHAR buf[1000];
        lpVarString = (LPVARSTRING) buf;
        lpVarString->dwTotalSize = 1000;

        lRet = lineGetID(lhLine, 0, 0, LINECALLSELECT_LINE,
                (LPVARSTRING) lpVarString, TEXT("comm/datamodem/portname"));

        if(lRet != 0)
            continue;

        LPTSTR szPortName;

        if (lpVarString->dwStringSize)
            szPortName = (LPTSTR) ((LPBYTE) lpVarString + ((LPVARSTRING) lpVarString) -> dwStringOffset);
        //
        // Append port name to port list
        //

        UINT len = lstrlen(szPortName) + 1;
        if(dwBytes < len)
            return(ERROR_SUCCESS);

        lstrcpy(szPorts, szPortName);
        szPorts += len;
        *szPorts = '\0';

        if (lhLine) lineClose(lhLine);
    }

    lineShutdown(RasLine);
    return ERROR_SUCCESS ;
}

VOID FAR PASCAL
RasTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
   // dummy callback routine because the full blown TAPI now demands that
   // lineinitialize provide this routine.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icfgnt5\cfgapi.h ===
//*******************************************************************
//
//  Copyright(c) Microsoft Corporation, 1996
//
//  FILE: CFGAPI.H
//
//  PURPOSE:  Contains API's exported from icfg32.dll and structures
//            required by those functions.
//
//*******************************************************************

#ifndef _CFGAPI_H_
#define _CFGAPI_H_

// Maximum buffer size for error messages.
#define MAX_ERROR_TEXT  512

// Flags for dwfOptions

// install TCP (if needed)
#define ICFG_INSTALLTCP            0x00000001

// install RAS (if needed)
#define ICFG_INSTALLRAS            0x00000002

// install exchange and internet mail
#define ICFG_INSTALLMAIL           0x00000004


// DRIVERTYPE_ defines for TCP/IP configuration apis
#define DRIVERTYPE_NET  0x0001
#define DRIVERTYPE_PPP  0x0002


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus


//*******************************************************************
//
//  FUNCTION:   IcfgNeedInetComponents
//
//  PURPOSE:    Detects whether the specified system components are
//              installed or not.
//
//  PARAMETERS: dwfOptions - a combination of ICFG_ flags that specify
//              which components to detect as follows:
//
//                ICFG_INSTALLTCP - is TCP/IP needed?
//                ICFG_INSTALLRAS - is RAS needed?
//                ICFG_INSTALLMAIL - is exchange or internet mail needed?
//
//              lpfNeedComponents - TRUE if any specified component needs
//              to be installed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents);


//*******************************************************************
//
//  FUNCTION:   IcfgInstallInetComponents
//
//  PURPOSE:    Install the specified system components.
//
//  PARAMETERS: hwndParent - Parent window handle.
//              dwfOptions - a combination of ICFG_ flags that controls
//              the installation and configuration as follows:
//
//                ICFG_INSTALLTCP - install TCP/IP (if needed)
//                ICFG_INSTALLRAS - install RAS (if needed)
//                ICFG_INSTALLMAIL - install exchange and internet mail
//
//              lpfNeedsRestart - if non-NULL, then on return, this will be
//              TRUE if windows must be restarted to complete the installation.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions,
  LPBOOL lpfNeedsRestart);


//*******************************************************************
//
//  FUNCTION:   IcfgGetLastInstallErrorText
//
//  PURPOSE:    Get a text string that describes the last installation
//              error that occurred.  The string should be suitable
//              for display in a message box with no further formatting.
//
//  PARAMETERS: lpszErrorDesc - points to buffer to receive the string.
//              cbErrorDesc - size of buffer.
//
//  RETURNS:    The length of the string returned.
//
//*******************************************************************

DWORD WINAPI IcfgGetLastInstallErrorText(LPTSTR lpszErrorDesc, DWORD cbErrorDesc);


//*******************************************************************
//
//  FUNCTION:   IcfgSetInstallSourcePath
//
//  PURPOSE:    Sets the path where windows looks when installing files.
//
//  PARAMETERS: lpszSourcePath - full path of location of files to install.
//              If this is NULL, default path is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgSetInstallSourcePath(LPCSTR lpszSourcePath);


//*******************************************************************
//
//  FUNCTION:   IcfgIsGlobalDNS
//
//  PURPOSE:    Determines whether there is Global DNS set.
//
//  PARAMETERS: lpfGlobalDNS - TRUE if global DNS is set, FALSE otherwise.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS and set lpfGlobalDNS
//              to FALSE in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS);


//*******************************************************************
//
//  FUNCTION:   IcfgRemoveGlobalDNS
//
//  PURPOSE:    Removes global DNS info from registry.
//
//  PARAMETERS: None.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//              NOTE:  This function is for Windows 95 only, and
//              should always return ERROR_SUCCESS in Windows NT.
//
//*******************************************************************

HRESULT WINAPI IcfgRemoveGlobalDNS(void);


//*******************************************************************
//
//  FUNCTION:   IcfgIsFileSharingTurnedOn
//
//  PURPOSE:    Determines if file server (VSERVER) is bound to TCP/IP
//              for specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to check server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//              lpfSharingOn - TRUE if bound once or more, FALSE if not bound
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgIsFileSharingTurnedOn(DWORD dwfDriverType, LPBOOL lpfSharingOn);


//*******************************************************************
//
//  FUNCTION:   IcfgTurnOffFileSharing
//
//  PURPOSE:    Unbinds file server (VSERVER) from TCP/IP for
//              specified driver type (net card or PPP).
//
//  PARAMETERS: dwfDriverType - a combination of DRIVERTYPE_ flags
//              that specify what driver type to remove server-TCP/IP
//              bindings for as follows:
//
//                DRIVERTYPE_NET  - net card
//                DRIVERTYPE_PPP        - PPPMAC
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI IcfgTurnOffFileSharing(DWORD dwfDriverType, HWND hwndParent);


//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetSetAutodial(BOOL fEnable, LPCSTR lpszEntryName);

//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,
                        DWORD cbEntryName);

//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetSetAutodialAddress();

//*******************************************************************
//*******************************************************************

HRESULT WINAPI InetGetSupportedPlatform(LPDWORD pdwPlatform);

//*******************************************************************
//*******************************************************************

HRESULT WINAPI IcfgStartServices();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //_CFGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\acfgnoff.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SERVERR.CPP - Functions for server error page
//

//  HISTORY:
//  
//  08/05/98    vyung     created
//
//*********************************************************************

#include "pre.h"
extern BOOL g_bSkipSelPage;
extern int  iNumOfAutoConfigOffers;
/*******************************************************************

  NAME:    ACfgNoofferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ACfgNoofferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
   
    if (fFirstInit)
    {   
        TCHAR    szTemp[MAX_MESSAGE_LEN];
        // If user selected Other on the previous page.
        if (iNumOfAutoConfigOffers > 0)
        {
            LoadString(ghInstanceResDll, IDS_AUTOCFG_EXPLAIN_OTHER, szTemp, MAX_MESSAGE_LEN);
            SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER1), szTemp);
        }
        else
        {
            if (gpWizardState->bISDNMode)
            {
                LoadString(ghInstanceResDll, IDS_ISDN_AUTOCFG_NOOFFER1, szTemp, MAX_MESSAGE_LEN);
                SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER1), szTemp);

                TCHAR*   pszParagraph = new TCHAR[MAX_MESSAGE_LEN * 2];
                if (pszParagraph)
                {
                    LoadString(ghInstanceResDll, IDS_ISDN_AUTOCFG_NOOFFER2, pszParagraph, MAX_MESSAGE_LEN * 2);
                    LoadString(ghInstanceResDll, IDS_ISDN_AUTOCFG_NOOFFER3, szTemp, ARRAYSIZE(szTemp));
                    lstrcat(pszParagraph, szTemp);
                    SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER2), pszParagraph);
                    delete [] pszParagraph;
                }
            }
            else
            {
                LoadString(ghInstanceResDll, IDS_AUTOCFG_NOOFFER1, szTemp, MAX_MESSAGE_LEN);
                SetWindowText(GetDlgItem(hDlg, IDC_AUTOCFG_NOOFFER1), szTemp);
            }
        }
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER;
    }        
    
    return bRet;
}


/*******************************************************************

  NAME:    ACfgNoofferOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ACfgNoofferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        // go to the manual phone page
        *pfKeepHistory = FALSE;
        if (iNumOfAutoConfigOffers > 0) 
        {
            g_bSkipSelPage = TRUE;
        }
        gpWizardState->cmnStateData.bPhoneManualWiz = TRUE;
        *puNextPage = g_uExternUINext;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icfgnt5\icfg32.cpp ===
/****************************************************************************
 *
 *  icfg32.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the NT specific functionality of inetcfg
 *
 *  6/5/97  ChrisK  Inherited from AmnonH
 *  7/3/97  ShaunCo Modfied for NT5
 *  5/1/98  donaldm Brought over from NT tree to ICW tree as part of NTCFG95.DLL
 ***************************************************************************/
#define INITGUID
#include <wtypes.h>
#include <cfgapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <setupapi.h>
#include <basetyps.h>
#include <devguid.h>
#include <lmsname.h>
#include "debug.h"
#include "icwunicd.h"

#include <netcfgx.h>


#define REG_DATA_EXTRA_SPACE 255

DWORD g_dwLastError = ERROR_SUCCESS;


ULONG ReleaseObj
(
    IUnknown* punk
)
{
    return (punk) ? punk->Release () : 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateAndInitializeINetCfg
//
//  Purpose:    Cocreate and initialize the root INetCfg object.  This will
//              optionally initialize COM for the caller too.
//
//  Arguments:
//      pfInitCom       [in,out]   TRUE to call CoInitialize before creating.
//                                 returns TRUE if COM was successfully
//                                 initialized FALSE if not.  If NULL, means
//                                 don't initialize COM.
//      ppnc            [out]  The returned INetCfg object.
//      fGetWriteLock   [in]   TRUE if a writable INetCfg is needed
//      cmsTimeout      [in]   See INetCfg::AcquireWriteLock
//      szwClientDesc   [in]   See INetCfg::AcquireWriteLock
//      ppszwClientDesc [out]  See INetCfg::AcquireWriteLock
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:
//
HRESULT HrCreateAndInitializeINetCfg
(
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    LPCWSTR     szwClientDesc,
    LPWSTR*     ppszwClientDesc
)
{
    Assert (ppnc);

    // Initialize the output parameter.
    *ppnc = NULL;

    if (ppszwClientDesc)
    {
       *ppszwClientDesc = NULL;
    }

    // Initialize COM if the caller requested.
    HRESULT hr = S_OK;
    if (pfInitCom && *pfInitCom)
    {
        hr = CoInitializeEx( NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_MULTITHREADED );
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            if (pfInitCom)
            {
                *pfInitCom = FALSE;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, reinterpret_cast<void**>(&pnc));
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pnclock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         reinterpret_cast<LPVOID *>(&pnclock));
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    hr = pnclock->AcquireWriteLock(cmsTimeout, szwClientDesc,
                                               ppszwClientDesc);
                    if (S_FALSE == hr)
                    {
                        // Couldn't acquire the lock
                        hr = NETCFG_E_NO_WRITE_LOCK;
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef ();
                }
                else
                {
                    if (pnclock)
                    {
                        pnclock->ReleaseWriteLock();
                    }
                }
                // Transfer reference to caller.
            }
            ReleaseObj(pnclock);

            ReleaseObj(pnc);
        }

        // If we failed anything above, and we've initialized COM,
        // be sure an uninitialize it.
        //
        if (FAILED(hr) && pfInitCom && *pfInitCom)
        {
            CoUninitialize ();
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndUnlockINetCfg
//
//  Purpose:    Uninitializes and unlocks the INetCfg object
//
//  Arguments:
//      pnc [in]    INetCfg to uninitialize and unlock
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
//+---------------------------------------------------------------------------
HRESULT HrUninitializeAndUnlockINetCfg
(
    INetCfg*    pnc
)
{
    HRESULT     hr = S_OK;

    hr = pnc->Uninitialize();
    if (SUCCEEDED(hr))
    {
        INetCfgLock *   pnclock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 reinterpret_cast<LPVOID *>(&pnclock));
        if (SUCCEEDED(hr))
        {
            // Attempt to lock the INetCfg for read/write
            hr = pnclock->ReleaseWriteLock();

            ReleaseObj(pnclock);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUninitializeAndReleaseINetCfg
//
//  Purpose:    Unintialize and release an INetCfg object.  This will
//              optionally uninitialize COM for the caller too.
//
//  Arguments:
//      fUninitCom [in] TRUE to uninitialize COM after the INetCfg is
//                      uninitialized and released.
//      pnc        [in] The INetCfg object.
//      fHasLock   [in] TRUE if the INetCfg was locked for write and
//                          must be unlocked.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   7 May 1997
//
//  Notes:      The return value is the value returned from
//              INetCfg::Uninitialize.  Even if this fails, the INetCfg
//              is still released.  Therefore, the return value is for
//              informational purposes only.  You can't touch the INetCfg
//              object after this call returns.
//
//+---------------------------------------------------------------------------
HRESULT HrUninitializeAndReleaseINetCfg
(
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock
)
{
    Assert (pnc);
    HRESULT hr = S_OK;

    if (fHasLock)
    {
        hr = HrUninitializeAndUnlockINetCfg(pnc);
    }
    else
    {
        hr = pnc->Uninitialize ();
    }

    ReleaseObj (pnc);

    if (fUninitCom)
    {
        CoUninitialize ();
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallComponent
//
//  Purpose:    Install the component with a specified id.
//
//  Arguments:
//      pnc             [in] INetCfg pointer.
//      pguidClass      [in] Class guid of the component to install.
//      pszwComponentId [in] Component id to install.
//      ppncc           [out] (Optional) Returned component that was
//                            installed.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   4 Jan 1998
//
//  Notes:
//
//+---------------------------------------------------------------------------
HRESULT HrInstallComponent
(
    INetCfg*                        pnc,
    const GUID*                     pguidClass,
    LPCWSTR                         pszwComponentId,
    INetCfgComponent**              ppncc
)
{
    Assert (pnc);
    Assert (pszwComponentId);

    // Initialize output parameter.
    //
    if (ppncc)
    {
        *ppncc = NULL;
    }

    // Get the class setup object.
    //
    INetCfgClassSetup* pncclasssetup;
    HRESULT hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                    reinterpret_cast<void**>(&pncclasssetup));
    if (SUCCEEDED(hr))
    {
        OBO_TOKEN OboToken;
        ZeroMemory (&OboToken, sizeof(OboToken));
        OboToken.Type = OBO_USER;


        hr = pncclasssetup->Install (pszwComponentId,
                                     &OboToken, 0, 0, NULL, NULL, ppncc);

        ReleaseObj (pncclasssetup);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgSetInstallSourcePath
//
//  Synopsis:   Set the path that will be used to install system components
//
//  Arguments:  lpszSourcePath - path to be used as install source (ANSI)
//
//  Returns:    HRESULT - S_OK is success
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgSetInstallSourcePath(LPTSTR lpszSourcePath)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgSetInstallSourcePath\n");
    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateProductSuite
//
//  Synopsis:   Check registry for a particular Product Suite string
//
//  Arguments:  SuiteName - name of product suite to look for
//
//  Returns:    TRUE - the suite exists
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
BOOL
ValidateProductSuite(LPTSTR SuiteName)
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPTSTR ProductSuite = NULL;
    LPTSTR p;

    TraceMsg(TF_GENERAL, "ICFGNT: ValidateProductSuite\n");
    //
    // Determine the size required to read registry values
    //
    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );
    if (Rslt != ERROR_SUCCESS)
    {
        goto exit;
    }

    Rslt = RegQueryValueExA(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS)
    {
        goto exit;
    }

    if (!Size)
    {
        goto exit;
    }

    ProductSuite = (LPTSTR) GlobalAlloc( GPTR, Size );
    if (!ProductSuite)
    {
        goto exit;
    }

    //
    // Read ProductSuite information
    //
    Rslt = RegQueryValueExA(
        hKey,
        "ProductSuite",
        NULL,
        &Type,
        (LPBYTE) ProductSuite,
        &Size
        );
    if (Rslt != ERROR_SUCCESS)
    {
        goto exit;
    }

    if (Type != REG_MULTI_SZ)
    {
        goto exit;
    }

    //
    // Look for a particular string in the data returned
    // Note: data is terminiated with two NULLs
    //
    p = ProductSuite;
    while (*p) {
        if (_tcsstr( p, SuiteName ))
        {
            rVal = TRUE;
            break;
        }
        p += (lstrlen( p ) + 1);
    }

exit:
    if (ProductSuite)
    {
        GlobalFree( ProductSuite );
    }

    if (hKey)
    {
        RegCloseKey( hKey );
    }

    return rVal;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRegValue
//
//  Synopsis:   Dynamically allocate memory and read value from registry
//
//  Arguments:  hKey - handle to key to be read
//              lpValueName - pointer to value name to be read
//              lpData - pointer to pointer to data
//
//  Returns:    Win32 error, ERROR_SUCCESS is it worked
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
inline LONG GetRegValue(HKEY hKey, LPTSTR lpValueName, LPBYTE *lpData)
{
    LONG dwError;
    DWORD cbData;

    TraceMsg(TF_GENERAL, "ICFGNT: GetRegValue\n");
    dwError = RegQueryValueEx(hKey,
                              lpValueName,
                              NULL,
                              NULL,
                              NULL,
                              &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        return(dwError);
    }

    //
    // Allocate space and buffer incase we need to add more info later
    // see turn off the printing binding
    //
    *lpData = (LPBYTE) GlobalAlloc(GPTR,cbData + REG_DATA_EXTRA_SPACE);
    if(*lpData == 0)
    {
        return(ERROR_OUTOFMEMORY);
    }

    dwError = RegQueryValueEx(hKey,
                              lpValueName,
                              NULL,
                              NULL,
                              *lpData,
                              &cbData);
    if(dwError != ERROR_SUCCESS)
    {
        GlobalFree(*lpData);
    }

    return(dwError);
}

//+----------------------------------------------------------------------------
//
//  Function:   CallModemInstallWizard
//
//  Synopsis:   Invoke modem install wizard via SetupDi interfaces
//
//  Arguments:  hwnd - handle to parent window
//
//  Returns:    TRUE - success, FALSE - failed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
//
// The following code was stolen from RAS
//

BOOL
CallModemInstallWizard(HWND hwnd)
   /* call the Modem.Cpl install wizard to enable the user to install one or
   ** more modems
   **
   ** Return TRUE if the wizard was successfully invoked, FALSE otherwise
   **
   */
{
   HDEVINFO hdi;
   BOOL     fReturn = FALSE;
   // Create a modem DeviceInfoSet

   TraceMsg(TF_GENERAL, "ICFGNT: CallModemInstallWizard\n");
   hdi = SetupDiCreateDeviceInfoList((LPGUID)&GUID_DEVCLASS_MODEM, hwnd);
   if (hdi)
   {
      SP_INSTALLWIZARD_DATA iwd;

      // Initialize the InstallWizardData

      ZeroMemory(&iwd, sizeof(iwd));
      iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
      iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
      iwd.hwndWizardDlg = hwnd;

      // Set the InstallWizardData as the ClassInstallParams

      if (SetupDiSetClassInstallParams(hdi, NULL,
            (PSP_CLASSINSTALL_HEADER)&iwd, sizeof(iwd)))
      {
         // Call the class installer to invoke the installation
         // wizard.
         if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD, hdi, NULL))
         {
            // Success.  The wizard was invoked and finished.
            // Now cleanup.
            fReturn = TRUE;

            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA, hdi, NULL);
         }
      }

      // Clean up
      SetupDiDestroyDeviceInfoList(hdi);
   }
   return fReturn;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedModem
//
//  Synopsis:   Check system configuration to determine if there is at least
//              one physical modem installed
//
//  Arguments:  dwfOptions - currently not used
//
//  Returns:    HRESULT - S_OK if successfull
//              lpfNeedModem - TRUE if no modems are available
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedModem (DWORD dwfOptions, LPBOOL lpfNeedModem)
{
    //
    // Ras is installed, and ICW wants to know if it needs to
    // install a modem.
    //
    *lpfNeedModem = TRUE;

    // Get the device info set for modems.
    //
    HDEVINFO hdevinfo = SetupDiGetClassDevs((GUID*)&GUID_DEVCLASS_MODEM,
                                            NULL,
                                            NULL,
                                            DIGCF_PRESENT);
    if (hdevinfo)
    {
        SP_DEVINFO_DATA diData;
        diData.cbSize = sizeof(diData);

        // Look for at least one modem.
        //
        if (SetupDiEnumDeviceInfo(hdevinfo, 0, &diData))
        {
            *lpfNeedModem = FALSE;
        }

        SetupDiDestroyDeviceInfoList (hdevinfo);
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallModem
//
//  Synopsis:
//              This function is called when ICW verified that RAS is installed,
//              but no modems are avilable. It needs to make sure a modem is availble.
//              There are two possible scenarios:
//
//              a.  There are no modems installed.  This happens when someone deleted
//                  a modem after installing RAS. In this case we need to run the modem
//                  install wizard, and configure the newly installed modem to be a RAS
//                  dialout device.
//
//              b.  There are modems installed, but non of them is configured as a dial out
//                  device.  In this case, we silently convert them to be DialInOut devices,
//                  so ICW can use them.
//
//  Arguments:  hwndParent - handle to parent window
//              dwfOptions - not used
//
//  Returns:    lpfNeedsStart - not used
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallModem (HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsStart)
{
    //$ BUGBUG (shaunco) 3 Jul 1997: See if we need to install a modem, or
    // just install it?

    //
    // Fire up the modem install wizard
    //
    if (!CallModemInstallWizard(hwndParent))
    {
        return(g_dwLastError = GetLastError());
    }

    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgNeedInetComponets
//
//  Synopsis:   Check to see if the components marked in the options are
//              installed on the system
//
//  Arguements: dwfOptions - set of bit flag indicating which components to
//              check for
//
//  Returns;    HRESULT - S_OK if successfull
//              lpfNeedComponents - TRUE is some components are not installed
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgNeedInetComponents(DWORD dwfOptions, LPBOOL lpfNeedComponents)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgNeedInetComponents\n");

    //
    // Assume we have what we need.
    //
    *lpfNeedComponents = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc,
                FALSE, 0, NULL, NULL);
    }

    // Look for TCP/IP using the INetCfg interface.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        Assert (pnc);

        hr = pnc->FindComponent (NETCFG_TRANS_CID_MS_TCPIP, NULL);
        if (S_FALSE == hr)
        {
            *lpfNeedComponents = TRUE;
        }
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, FALSE);
    }

    if (dwfOptions & ICFG_INSTALLMAIL)
    {
        // How do we do this?
        Assert (0);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgInstallInetComponents
//
//  Synopsis:   Install the components as specified by the dwfOptions values
//
//  Arguments   hwndParent - handle to parent window
//              dwfOptions - set of bit flags indicating which components to
//                  install
//
//  Returns:    HRESULT - S_OK if success
//              lpfNeedsReboot - TRUE if reboot is required
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgInstallInetComponents(HWND hwndParent, DWORD dwfOptions, LPBOOL lpfNeedsRestart)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgInstallInetComponents\n");

    //
    // Assume don't need restart
    //
    *lpfNeedsRestart = FALSE;

    HRESULT     hr          = S_OK;
    INetCfg*    pnc         = NULL;
    BOOL        fInitCom    = TRUE;

    // If the optiona are such that we need an INetCfg interface pointer,
    // get one.
    //
    if ((dwfOptions & ICFG_INSTALLTCP) ||
        (dwfOptions & ICFG_INSTALLRAS))
    {
        BSTR bstrClient;
        hr = HrCreateAndInitializeINetCfg (&fInitCom, &pnc, TRUE,
                0, L"", &bstrClient);
    }

    // Install TCP/IP on behalf of the user.
    //
    if (SUCCEEDED(hr) && (dwfOptions & ICFG_INSTALLTCP))
    {
        hr = HrInstallComponent (pnc, &GUID_DEVCLASS_NETTRANS,
                    NETCFG_TRANS_CID_MS_TCPIP, NULL);
    }

    // We no longer need the INetCfg interface pointer, so release it.
    //
    if (pnc)
    {
        // Apply the changes if everything was successful.
        //
        if (SUCCEEDED(hr))
        {
            hr = pnc->Apply ();

            if (NETCFG_S_REBOOT == hr)
            {
                *lpfNeedsRestart = TRUE;
            }
        }
        (void) HrUninitializeAndReleaseINetCfg (fInitCom, pnc, TRUE);
    }

    if (dwfOptions & ICFG_INSTALLMAIL)
    {
        // How do we do this?
        Assert (0);
    }

    // Normalize the HRESULT.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgGetLastInstallErrorText
//
//  Synopsis:   Format error message for most recent error
//
//  Arguments:  none
//
//  Returns:    DWORD - win32 error code
//              lpszErrorDesc - string containing error message
//              cbErrorDesc - size of lpszErrorDesc
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
DWORD WINAPI
IcfgGetLastInstallErrorText(LPTSTR lpszErrorDesc, DWORD cbErrorDesc)
{
    TraceMsg(TF_GENERAL, "ICFGNT: IcfgGetLastInstallErrorText\n");
    return(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             g_dwLastError,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
                             lpszErrorDesc,
                             cbErrorDesc,
                             NULL));
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgIsFileSharingTurnedOn
//
//  Synopsis:   Always returns false for NT 5 because file sharing is controlled
//              at the RAS connectoid level, and is always turned off for ICW
//              generated connectoids
//
//  Arguments:  dwfDriverType -
//
//  Returns:    HRESULT - S_OK is success
//              lpfSharingOn - TRUE if sharing is bound
//
//  History:    6/5/97  ChrisK  Inherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgIsFileSharingTurnedOn
(
    DWORD dwfDriverType,
    LPBOOL lpfSharingOn
)
{
    HRESULT hr = ERROR_SUCCESS;

    TraceMsg(TF_GENERAL, "ICFGNT: IcfgIsFileSharingTurnedOn\n");
    Assert(lpfSharingOn);
    if (NULL == lpfSharingOn)
    {
        hr = ERROR_INVALID_PARAMETER;
        goto IcfgIsFileSharingTurnedOnExit;
    }

    *lpfSharingOn = FALSE;

IcfgIsFileSharingTurnedOnExit:
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgTurnOffFileSharing
//
//  Synopsis;   For NT 5, this is handed as a RAS property, so we just return
//              success here.
//
//
//  Arguments:  dwfDriverType -
//              hwndParent - parent window
//
//  Returns:    HRESULT - ERROR_SUCCESS
//
//  History:    6/5/97      ChrisK  Inherited
//              07/21/98    donaldm
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgTurnOffFileSharing
(
    DWORD dwfDriverType,
    HWND hwndParent
)
{
    return ERROR_SUCCESS;
}


//+----------------------------------------------------------------------------
//
//  Function:   IcfgStartServices
//
//  Synopsis:   Start all services required by system
//
//  Arguments:  none
//
//  Returns:    HRESULT - S_OK if success
//
//  History:    6/5/97  ChrisK  Iherited
//
//-----------------------------------------------------------------------------
HRESULT WINAPI IcfgStartServices()
{
    //This stuff is handled auto-magically by the RAS API.
    //but since there so much code that calls this function we'll
    //be simple and fake success
    return(ERROR_SUCCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   IcfgIsGlobalDNS
//
//  Note: these functions are not needed on an NT system and it therefore not
//  implemented
//
//-----------------------------------------------------------------------------
HRESULT WINAPI
IcfgIsGlobalDNS(LPBOOL lpfGlobalDNS)
{
    *lpfGlobalDNS = FALSE;
    return(ERROR_SUCCESS);
}

HRESULT WINAPI
IcfgRemoveGlobalDNS()
{
    return(ERROR_SUCCESS);
}

HRESULT WINAPI
InetGetSupportedPlatform(LPDWORD pdwPlatform)
{
    *pdwPlatform = VER_PLATFORM_WIN32_NT;
    return(ERROR_SUCCESS);
}

HRESULT WINAPI
InetSetAutodial(BOOL fEnable, LPCTSTR lpszEntryName) {
    return(ERROR_INVALID_FUNCTION);
}

HRESULT WINAPI
InetGetAutodial(LPBOOL lpfEnable, LPSTR lpszEntryName,  DWORD cbEntryName) {
    return(ERROR_INVALID_FUNCTION);
}

HRESULT WINAPI
InetSetAutodialAddress(DWORD dwDialingLocation, LPTSTR szEntry) {
    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for comma seperated files
class CCSVFile 
{
    
    public: 
        void far * operator new( size_t cb ) { return GlobalAlloc(GPTR,cb); };
        void operator delete( void far * p ) {GlobalFree(p); };

        CCSVFile();
        ~CCSVFile();
        BOOLEAN Open(LPCTSTR pszFileName);
        BOOLEAN ReadToken(LPSTR psz, DWORD cbMax);  // reads up to comma or newline, returns fFalse on EOF
        BOOLEAN SkipTillEOL(void);  // reads up to EOL
        void Close(void);
        inline int ILastRead(void)
            {
            return m_iLastRead;
            }

    private:
        BOOL    FReadInBuffer(void);
        inline int  ChNext(void);
        CHAR    m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
        LPSTR   m_pchBuf;           //pointer to the next item in the buffer to read
        LPSTR   m_pchLast;          //pointer to the last item in the buffer
        int     m_iLastRead;        //the character last read.
        DWORD   m_cchAvail;
        HANDLE  m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ccsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// ############################################################################
// INCLUDES
#include "pre.h"

// ############################################################################
// DEFINES
#define chComma ','
#define chNewline '\n'
#define chReturn '\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
    m_hFile = 0;
    m_iLastRead = 0;
    m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
    if(m_hFile)
        CloseHandle(m_hFile);

    AssertMsg(!m_hFile,"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCTSTR pszFileName)
{
    AssertMsg(!m_hFile, "a file is already open.");
        
    m_hFile = CreateFile((LPCTSTR)pszFileName, 
                            GENERIC_READ, FILE_SHARE_READ, 
                            0, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        return FALSE;
    }
    m_pchLast = m_pchBuf = NULL;
    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPSTR psz, DWORD cbMax)
{
    CHAR*    pszLast;
    int      ch;

    ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    pszLast = psz + (cbMax - 1);
    while ( psz < pszLast &&
            chComma != ch &&
            chNewline != ch &&
            chReturn != ch &&
            -1 != ch)
    {
        *psz++ = (CHAR)ch;
        ch = ChNext(); //Read in the next character
    }

    *psz++ = '\0';

    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::SkipTillEOL()
{
    int ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    while ( chNewline != ch &&
            -1 != ch)
    {
        ch = ChNext(); //Read in the next character
    }
    return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
    if (m_hFile)
        CloseHandle(m_hFile);
#ifdef DEBUG
    if (!m_hFile) TraceMsg(TF_GENERAL, "CCSVFile::Close was called, but m_hFile was already 0\n");
#endif
    m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
    //Read another buffer
   if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
        return FALSE;     //nothing more to read
 
    m_pchBuf = m_rgchBuf;
    m_pchLast = m_pchBuf + m_cchAvail;
    
    return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{
    if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
        return -1;     //nothing more to read

    m_iLastRead = *m_pchBuf++;
    return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\billopt.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  BILLOPT.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"

const TCHAR cszBillOpt[] = TEXT("BILLOPT");

/*******************************************************************

  NAME:   BillingOptInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK BillingOptInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_BILLINGOPT;
    if (!fFirstInit)
    {
        ASSERT(gpWizardState->lpSelectedISPInfo);
        
        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_BILLINGOPT_INTRO), IDS_BILLINGOPT_INTROFMT, NULL);
    
        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_BILLINGOPT_HTML), PAGETYPE_BILLING);
        
        // Navigate to the Billing HTML
        gpWizardState->lpSelectedISPInfo->DisplayHTML(gpWizardState->lpSelectedISPInfo->get_szBillingFormPath());
        
        // Load any previsouly saved state data for this page
        gpWizardState->lpSelectedISPInfo->LoadHistory((BSTR)A2W(cszBillOpt));
    }
    return TRUE;
}


/*******************************************************************

  NAME:    BillingOptOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK BillingOptOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    // Save any data data/state entered by the user
    gpWizardState->lpSelectedISPInfo->SaveHistory((BSTR)A2W(cszBillOpt));

    if (fForward)
    {
        // Need to form Billing Query String
        TCHAR   szBillingOptionQuery [INTERNET_MAX_URL_LENGTH];    
        
        // Clear the Query String.
        memset(szBillingOptionQuery, 0, sizeof(szBillingOptionQuery));
        
        // Attach the walker to the curent page
        // Use the Walker to get the query string
        IWebBrowser2 *lpWebBrowser;
        
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        gpWizardState->pHTMLWalker->AttachToDocument(lpWebBrowser);
        gpWizardState->pHTMLWalker->get_FirstFormQueryString(szBillingOptionQuery);
        
        // Add the billing query to the ISPData object
        gpWizardState->pISPData->PutDataElement(ISPDATA_BILLING_OPTION, szBillingOptionQuery, ISPDATA_Validate_None);    
        
        // detach the walker
        gpWizardState->pHTMLWalker->Detach();
        
       
        DWORD dwFlag = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

        if (ICW_CFGFLAG_SIGNUP_PATH & dwFlag)
        {
            if (ICW_CFGFLAG_PAYMENT & dwFlag)
            {
                *puNextPage = ORD_PAGE_PAYMENT; 
                return TRUE;
            }
            *puNextPage = ORD_PAGE_ISPDIAL; 
            return TRUE;
        }
   }
 
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\connect.h ===
#define DISPID_RasDialStatus       0x1
#define DISPID_DownloadProgress    0x2
#define DISPID_DownloadComplete    0x3
#define DISPID_RasConnectComplete  0x4

class CRefDialEvent : public _RefDialEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CRefDialEvent(HWND  hWnd)
        {
            m_hWnd = hWnd;
            m_cRef = 0;
        };
        ~CRefDialEvent(void)
        {
            assert( m_cRef == 0 );
        };        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void)
        {
            return ++m_cRef;
        };        
        STDMETHODIMP_(DWORD) Release(void)
        {
            return --m_cRef;
        
        };        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId)
            { return ResultFromScode(DISP_E_UNKNOWNNAME); };
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};

#define DISPID_WEBGATE_DownloadComplete 0x1
#define DISPID_WEBGATE_DownloadProgress 0x2
class CWebGateEvent : public _WebGateEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CWebGateEvent(HWND  hWnd)
        {
            m_hWnd = hWnd;
            m_cRef = 0;
        };
        
        ~CWebGateEvent(void)
        {
            assert( m_cRef == 0 );
        };        
        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void)
        {
            return ++m_cRef;
        };        
        STDMETHODIMP_(DWORD) Release(void)
        {
            return --m_cRef;
        
        };        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId)
            { return ResultFromScode(DISP_E_UNKNOWNNAME); };
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};

#define RunningCustomExecutable             0x1
#define DISPID_INSHandler_KillConnection    0x2
class CINSHandlerEvent : public _INSHandlerEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CINSHandlerEvent(HWND  hWnd)
        {
            m_hWnd = hWnd;
            m_cRef = 0;
        };
        
        ~CINSHandlerEvent(void)
        {
            assert( m_cRef == 0 );
        };        
        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void)
        {
            return ++m_cRef;
        };        
        STDMETHODIMP_(DWORD) Release(void)
        {
            return --m_cRef;
        
        };        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo)
            {return E_NOTIMPL;};
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId)
            { return ResultFromScode(DISP_E_UNKNOWNNAME); };
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\connect.cpp ===
//**********************************************************************
// File name: connect.cpp
//
//      Implementation of connection point sink objects
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include <ras.h>

BOOL DoOfferDownload();
extern BOOL g_bWebGateCheck;
extern BOOL g_bConnectionErr;

/*
 * CRefDialEvent::QueryInterface
 * CRefDialEvent::AddRef
 * CRefDialEvent::Release
 *
 * Purpose:
 *  IUnknown members for CRefDialEvent object.
 */

STDMETHODIMP CRefDialEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__RefDialEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//IDispatch
STDMETHODIMP CRefDialEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{
    HRESULT hr = S_OK;

    switch(dispIdMember)
    {
        case DISPID_RasDialStatus:
        {
            ASSERT(pDispParams->rgvarg);
            switch(pDispParams->rgvarg->iVal)
            {
                //Dialing 
                case RASCS_OpenPort:
                case RASCS_PortOpened:
                case RASCS_ConnectDevice: 
                {
                    if(!gpWizardState->iRedialCount)
                        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                                 IDS_ISPDIAL_STATUSDIALINGFMT, NULL);
                    else
                        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                                 IDS_ISPDIAL_STATUSREDIALINGFMT, NULL);
                    break;
                }
                //Connecting to network
                case RASCS_DeviceConnected:
                case RASCS_AllDevicesConnected:
                case RASCS_Authenticate:
                case RASCS_StartAuthentication:
                case RASCS_LogonNetwork:
                {
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                             IDS_ISPDIAL_STATUSCONNECTINGFMT, NULL);
                    break;
                }
                case RASCS_Disconnected:
                {
                    BSTR bstrDialStatus = NULL;
                    gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);
                    SetWindowText(GetDlgItem(m_hWnd, IDC_ISPDIAL_STATUS), W2A(bstrDialStatus));
                    SysFreeString(bstrDialStatus);
                    break;
                }
                default:
                   break;
            }
            break;
        }
    
        case DISPID_RasConnectComplete: /* Incomplete */
        {
            if (pDispParams && !gfISPDialCancel)
            {
                if( gpWizardState->bDoneWebServRAS = pDispParams->rgvarg[0].lVal )
                {
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(m_hWnd,IDC_ISPDIAL_STATUS), 
                                                                         IDS_ISPDIAL_STATUSCONNECTINGFMT, NULL);
                    if (!DoOfferDownload())
                        hr = E_FAIL;
                }
            }
            if( !gfISPDialCancel )
                PropSheet_PressButton(GetParent(m_hWnd),PSBTN_NEXT);
            break;
        }            
    }
    return hr;
}

BOOL DoOfferDownload()
{
    // If Ras is complete 
    if (gpWizardState->bDoneWebServRAS)
    {
        ShowProgressAnimation();
        
        // Download the first page from Webgate
        BSTR    bstrURL = NULL;
        BSTR    bstrQueryURL = NULL;
        BOOL    bRet;

        TCHAR   szTemp[10];      // Big enough to format a WORD
        
        // Add the PID, GIUD, and Offer ID to the ISP data object
        gpWizardState->pRefDial->ProcessSignedPID(&bRet);
        if (bRet)
        {
            BSTR    bstrSignedPID = NULL;
            gpWizardState->pRefDial->get_SignedPID(&bstrSignedPID);
            gpWizardState->pISPData->PutDataElement(ISPDATA_SIGNED_PID, W2A(bstrSignedPID), FALSE);                
            
            SysFreeString(bstrSignedPID);                
        }
        else
        {
            gpWizardState->pISPData->PutDataElement(ISPDATA_SIGNED_PID, NULL, FALSE);                
        }

        // GUID comes from the ISPCSV file
        gpWizardState->pISPData->PutDataElement(ISPDATA_GUID, 
                                                gpWizardState->lpSelectedISPInfo->get_szOfferGUID(),
                                                FALSE);

        // Offer ID comes from the ISPCSV file as a WORD
        // NOTE: This is the last one, so besure AppendQueryPair does not add an Ampersand
        wsprintf (szTemp, TEXT("%d"), gpWizardState->lpSelectedISPInfo->get_wOfferID());
        gpWizardState->pISPData->PutDataElement(ISPDATA_OFFERID, szTemp, FALSE);                

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
        {
            // BUGBUG: If ISDN get the ISDN Autoconfig URL
            if (gpWizardState->bISDNMode)
            {
                gpWizardState->pRefDial->get_ISDNAutoConfigURL(&bstrURL);
            }
            else
            {
                gpWizardState->pRefDial->get_AutoConfigURL(&bstrURL);
            }
        }
        else
        {
            // Get the signup URL
            if (gpWizardState->bISDNMode)
            {
                gpWizardState->pRefDial->get_ISDNURL(&bstrURL);
            }
            else
            {
                gpWizardState->pRefDial->get_SignupURL(&bstrURL);
            }

        }

        //This flag is only to be used by ICWDEBUG.EXE
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_ISPURLOVERRIDE)
            gpWizardState->pISPData->GetQueryString(A2W(gpWizardState->cmnStateData.ispInfo.szIspURL), &bstrQueryURL);
        else
            // Get the full signup url with Query string params added to it
            gpWizardState->pISPData->GetQueryString(bstrURL, &bstrQueryURL);
            
        // Setup WebGate         
        gpWizardState->pWebGate->put_Path(bstrQueryURL);
        gpWizardState->pWebGate->FetchPage(0,0,&bRet);           
        
        // Memory cleanup
        SysFreeString(bstrURL);

        // If the fetch failed, then return the error code
        if (!bRet)
            return FALSE;
            
        // Wait for the fetch to complete                
        WaitForEvent(gpWizardState->hEventWebGateDone);
        
        // Start the Idle Timer
        StartIdleTimer();
        
        // Now that webgate is done with it, free the queryURL
        SysFreeString(bstrQueryURL);
        
        HideProgressAnimation();
        
    }
    return TRUE;
}


/*
 * CWebGateEvent::QueryInterface
 * CWebGateEvent::AddRef
 * CWebGateEvent::Release
 *
 * Purpose:
 *  IUnknown members for CWebGateEvent object.
 */

STDMETHODIMP CWebGateEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__WebGateEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP CWebGateEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{

    switch(dispIdMember)
    {
        case DISPID_WEBGATE_DownloadComplete:
        {
            gpWizardState->bDoneWebServDownload = pDispParams->rgvarg[0].lVal;
            g_bWebGateCheck = FALSE;
            SetEvent(gpWizardState->hEventWebGateDone);
            break;
        }            
        case DISPID_WEBGATE_DownloadProgress:
        {
            if (g_bWebGateCheck)
            {
                BOOL bConnected = FALSE;
                
                //This flag is only to be used by ICWDEBUG.EXE
                if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                    bConnected = TRUE;
                else
                    gpWizardState->pRefDial->get_RasGetConnectStatus(&bConnected);

                if (!bConnected)
                {
                    g_bWebGateCheck = FALSE;
                    g_bConnectionErr = TRUE;
                    SetEvent(gpWizardState->hEventWebGateDone);
                }
            }
            break;
        }            
    }
    return S_OK;
}


/*
 * CINSHandlerEvent::QueryInterface
 * CINSHandlerEvent::AddRef
 * CINSHandlerEvent::Release
 *
 * Purpose:
 *  IUnknown members for CINSHandlerEvent object.
 */

STDMETHODIMP CINSHandlerEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__INSHandlerEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP CINSHandlerEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{

    switch(dispIdMember)
    {
        case DISPID_INSHandler_KillConnection:
        {
            gpWizardState->pRefDial->DoHangup();
            break;
        }            
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\dllentry.cpp ===
/*****************************************************************/
/**          Microsoft                                          **/
/**          Copyright (C) Microsoft Corp., 1991-1998           **/
/*****************************************************************/ 

//
//  DLLENTRY.CPP - 
//

//  HISTORY:
//  
//  05/14/98  donaldm   created
//

#include "pre.h"

// instance handle must be in per-instance data segment
HINSTANCE  ghInstance       = NULL;
HINSTANCE  ghInstanceResDll = NULL;

typedef UINT RETERR;

INT             _convert;               // For string conversion

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

  BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved);

#ifdef __cplusplus
}
#endif // __cplusplus

/*******************************************************************

  NAME:    DllEntryPoint

  SYNOPSIS:  Entry point for DLL.

  NOTES:    Initializes thunk layer to WIZ16.DLL

********************************************************************/
BOOL _stdcall DllEntryPoint(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        ghInstance = hInstDll;
        
        ghInstanceResDll = LoadLibrary(ICW_RESOURCE_ONLY_DLL);
        ASSERT(ghInstanceResDll);
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        ASSERT(ghInstanceResDll);
        FreeLibrary(ghInstanceResDll);
    }
    return TRUE;
}


#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

void __cdecl main() {};

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\dllsrcs.inc ===
GETCONN_DIR     = ..\..

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn

MAJORCOMP=GETCONN
MINORCOMP=ICWCONN

TARGETNAME=ICWCONN
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLENTRY=DllEntryPoint
DLLBASE=0x60000000
DLLDEF=..\icwconn.def

NOT_LEAN_AND_MEAN   =1
RCNOFONTMAP         =1

C_DEFINES           =-DICW32 -DNASHVILLE

!if "$(BUILD_PRODUCT)" == "NT"
C_DEFINES       = $(C_DEFINES) -DNT
!endif

!if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!endif

USE_MSVCRT          = 1

BROWSER_INFO="yes"

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES= \
    ..\icwconn.rc          \
    ..\icwhelp.cpp         \
    ..\icwconn.cpp         \
    ..\dllentry.cpp        \
    ..\icwaprtc.cpp        \
    ..\gendlg.cpp          \
    ..\util.cpp            \
    ..\factory.cpp         \
    ..\ispsel.cpp          \
    ..\nooffer.cpp         \
    ..\userinfo.cpp        \
    ..\billopt.cpp         \
    ..\payment.cpp         \
    ..\ispdial.cpp         \
    ..\isppage.cpp         \
    ..\ccsv.cpp            \
    ..\ispcsv.cpp          \
    ..\paycsv.cpp          \
    ..\connect.cpp         \
    ..\storage.cpp         \
    ..\ols.cpp             \
    ..\dialerr.cpp         \
    ..\serverr.cpp         \
    ..\acfgnoff.cpp        \
    ..\ispasel.cpp         \
    ..\isdnnoff.cpp        \
    ..\oemoffer.cpp        \
    ..\timeout.cpp

TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib      \
    $(SDK_LIB_PATH)\user32.lib        \
    $(SDK_LIB_PATH)\gdi32.lib         \
    $(SDK_LIB_PATH)\advapi32.lib      \
    $(SDK_LIB_PATH)\comctl32.lib      \
    $(SDK_LIB_PATH)\shell32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib      \
    $(SDK_LIB_PATH)\mpr.lib           \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(SDK_LIB_PATH)\htmlhelp.lib      \
    $(SDK_LIB_PATH)\version.lib       \
    $(SDK_LIB_PATH)\vfw32.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\pre.h
PRECOMPILED_PCH=pre.pch
PRECOMPILED_OBJ=pre.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\dialerr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  DIALERR.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

/*******************************************************************

  NAME:    DialErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK DialErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{  
    HideProgressAnimation();

    if (!fFirstInit)
    {
        KillIdleTimer();

        // Show the phone Number
        BSTR    bstrPhoneNum = NULL; 
        gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
        SysFreeString(bstrPhoneNum);

        // Fill in the support number
        BSTR    bstrSupportPhoneNum = NULL; 
       
        //Let the isp file override this in IEAK with SupportPhoneNumber=
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {
            gpWizardState->pRefDial->get_ISPSupportPhoneNumber(&bstrSupportPhoneNum);
        }
        
        if (!bstrSupportPhoneNum)
            gpWizardState->pRefDial->get_ISPSupportNumber(&bstrSupportPhoneNum);

        if (bstrSupportPhoneNum)
        {
            ASSERT(gpWizardState->lpSelectedISPInfo);
            gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_SERVERR_HELP), IDS_DIALERR_HELP, W2A(bstrSupportPhoneNum));
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_SHOW);
            SysFreeString(bstrSupportPhoneNum);
        }
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_HIDE);
        }

        // Display the error text message
        BSTR bstrErrMsg = NULL;
        gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
        SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_TEXT), W2A(bstrErrMsg));;
        SysFreeString(bstrErrMsg);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_DIALERROR;
    }
    return TRUE;
}

/*******************************************************************

  NAME:    DialErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK DialErrorOKProc
(
    HWND hMdmCmb,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    // Set the new phone Number weather the user goes forward or back
    TCHAR   szPhone[MAX_RES_LEN];
    GetWindowText(GetDlgItem(hMdmCmb, IDC_DIALERR_PHONENUMBER), szPhone, ARRAYSIZE(szPhone));
    gpWizardState->pRefDial->put_DialPhoneNumber(A2W(szPhone));
    
    if (fForward)
    {
        // We always dial the exact number that is in the phonenumber field.
        gpWizardState->bDialExact = TRUE;
        *pfKeepHistory = FALSE;
        *puNextPage = ORD_PAGE_ISPDIAL; 
    }
    else
    {
        BOOL bRetVal;
        // Clear the dial Exact state var so that when we get to the dialing
        // page, we will regenerate the dial string
        gpWizardState->bDialExact = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }
    return TRUE;
}






/*******************************************************************

  NAME:    DialErrorCmdProc

  SYNOPSIS:  Called when a command is generated from  page

  ENTRY:    hDlg - dialog window
            wParam - wParam
            lParam - lParam
          
  EXIT: returns TRUE 

********************************************************************/
BOOL CALLBACK DialErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
    {
        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
        { 
            case IDC_DIALERR_PROPERTIES:   
            {
                BOOL    bRetVal;
                gpWizardState->pRefDial->ShowDialingProperties(&bRetVal);
                if (bRetVal)
                {
                    // Show the phone Number as it may be changed after the popup
                    BSTR    bstrPhoneNum = NULL; 
                    gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                    SetWindowText(GetDlgItem(hDlg, IDC_DIALERR_PHONENUMBER), W2A(bstrPhoneNum));
                    SysFreeString(bstrPhoneNum);
                }
                break;
            }
            case IDC_DIAL_HELP:
            {
                HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
                break;
            }
            default:
                break;
        }           
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\gendlg.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"
#include "icwaprtc.h"

#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 458

/*******************************************************************

  NAME:    GetDlgIDFromIndex

  SYNOPSIS:  For a given zero-based page index, returns the
        corresponding dialog ID for the page

  4/24/97    jmazner    When dealing with apprentice pages, we may call
                    this function with dialog IDs (IDD_PAGE_*), rather
                    than an index (ORD_PAGE*).  Added code to check
                    whether the number passed in is an index or dlgID.

********************************************************************/
UINT GetDlgIDFromIndex(UINT uPageIndex)
{
    if( uPageIndex <= MAX_PAGE_INDEX )
    {
        ASSERT(uPageIndex < NUM_WIZARD_PAGES);

        return PageInfo[uPageIndex].uDlgID;
    }
    else
    {
        return(uPageIndex);
    }
}

//
//  GENDLG.C - 
//  Generic DLG proc for common wizard functions
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//


// ############################################################################
HRESULT MakeWizard97Title (HWND hwnd)
{
    HRESULT     hr = ERROR_SUCCESS;
    HFONT       hfont = NULL;
    HFONT       hnewfont = NULL;
    LOGFONT     *plogfont = NULL;
    HDC         hDC;
    
    if (!hwnd) goto MakeWizard97TitleExit;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (!hfont)
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    plogfont = (LOGFONT*)malloc(sizeof(LOGFONT));
    if (!plogfont)
    {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        goto MakeWizard97TitleExit;
    }

    if (!GetObject(hfont,sizeof(LOGFONT),(LPVOID)plogfont))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    // We want 12 PT Veranda for Wizard 97.
    hDC = GetDC(NULL);
    if(hDC)
    {
        plogfont->lfHeight = -MulDiv(WIZ97_TITLE_FONT_PTS, GetDeviceCaps(hDC, LOGPIXELSY), 72); 
        ReleaseDC(NULL, hDC);
    }        
    plogfont->lfWeight = (int) FW_BOLD;
    
    if (!LoadString(ghInstanceResDll, IDS_WIZ97_TITLE_FONT_FACE, plogfont->lfFaceName, LF_FACESIZE))
        lstrcpy(plogfont->lfFaceName, TEXT("Verdana"));

    if (!(hnewfont = CreateFontIndirect(plogfont)))
    {
        hr = ERROR_GEN_FAILURE;
        goto MakeWizard97TitleExit;
    }

    SendMessage(hwnd,WM_SETFONT,(WPARAM)hnewfont,MAKELPARAM(TRUE,0));
    
    free(plogfont);
    
MakeWizard97TitleExit:
    //if (hfont) DeleteObject(hfont);
    // BUG:? Do I need to delete hnewfont at some time?
    // The answer is Yes. ChrisK 7/1/96
    return hr;
}

// ############################################################################
HRESULT ReleaseBold(HWND hwnd)
{
    HFONT hfont = NULL;

    hfont = (HFONT)SendMessage(hwnd,WM_GETFONT,0,0);
    if (hfont) DeleteObject(hfont);
    return ERROR_SUCCESS;
}

/*******************************************************************

    Function:    PaintWithPaletteBitmap

    Arguments:   lprc is the target rectangle.
                 cy is the putative dimensions of hbmpPaint.
                 If the target rectangle is taller than cy, then 
                 fill the rest with the pixel in the upper left 
                 corner of the hbmpPaint.

    Returns:     void

    History:      10-29-98    Vyung    Stole from prsht.c

********************************************************************/

void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, int cy, HBITMAP hbmpPaint)
{
    HDC hdcBmp;

    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);
    BitBlt(hdc, lprc->left, lprc->top, RECTWIDTH(*lprc), cy, hdcBmp, 0, 0, SRCCOPY);

    // StretchBlt does mirroring if you pass a negative height,
    // so do the stretch only if there actually is unpainted space
    if (RECTHEIGHT(*lprc) - cy > 0)
        StretchBlt(hdc, lprc->left, cy,
                   RECTWIDTH(*lprc), RECTHEIGHT(*lprc) - cy,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}
/*******************************************************************
//
//    Function:    Prsht_EraseWizBkgnd
//
//    Arguments:   Draw the background for wizard pages.
//                 hDlg is dialog handle.
//                 hdc is device context
//
//    Returns:     void
//
//    History:     10-29-98    Vyung   - Stole from prsht.c
//
********************************************************************/
LRESULT Prsht_EraseWizBkgnd(HWND hDlg, HDC hdc)
{
    
    HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    RECT rc;
    GetClientRect(hDlg, &rc);
    FillRect(hdc, &rc, hbrWindow);

    rc.right = BITMAP_WIDTH;
    rc.left = 0;

    PaintWithPaletteBitmap(hdc, &rc, BITMAP_HEIGHT, gpWizardState->cmnStateData.hbmWatermark);

    return TRUE;
}

//-----------------------------------------------------------------------------
//  Function    MiscInitProc
//
//    Synopsis    Our generic dialog proc calls this in case any of the wizard
//                dialogs have to do any sneaky stuff.
//
//    Arguments:    hDlg - dialog window
//                fFirstInit - TRUE if this is the first time the dialog
//                    is initialized, FALSE if this InitProc has been called
//                    before (e.g. went past this page and backed up)
//
//    Returns:    TRUE
// 
//    History:    10/28/96    ValdonB    Created
//                11/25/96    Jmazner    copied from icwconn1\psheet.cpp
//                            Normandy #10586
//
//-----------------------------------------------------------------------------
BOOL CALLBACK MiscInitProc
(
    HWND hDlg, 
    BOOL fFirstInit, 
    UINT uDlgID
)
{
//    switch( uDlgID )
//    {
//    }
    return TRUE;
}

/*******************************************************************

  NAME:    GenDlgProc

  SYNOPSIS:  Generic dialog proc for all wizard pages

  NOTES:    This dialog proc provides the following default behavior:
          init:         back and next buttons enabled
          next btn:     switches to page following current page
          back btn:     switches to previous page
          cancel btn:   prompts user to confirm, and cancels the wizard
          dlg ctrl:     does nothing (in response to WM_COMMANDs)
          
        Wizard pages can specify their own handler functions
        (in the PageInfo table) to override default behavior for
        any of the above actions.

********************************************************************/
INT_PTR CALLBACK GenDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    static HCURSOR  hcurOld = NULL;
    PAGEINFO        *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
    ASSERT(pPageInfo);

    switch (uMsg) 
    {
        case WM_ERASEBKGND:
        {
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                // Set ICW completed bit and remove the getconn icon
                if (gpWizardState->cmnStateData.lpfnFillWindowWithAppBackground)
                    (*gpWizardState->cmnStateData.lpfnFillWindowWithAppBackground)(hDlg, (HDC) wParam);

                return TRUE;
            }
            else
            {
                // Only paint the external page 
                if ((!pPageInfo->nIdTitle) && (IDD_PAGE_ISPSELECT != pPageInfo->uDlgID))
                {
                    Prsht_EraseWizBkgnd(hDlg, (HDC) wParam);
                    return TRUE;
                }
            } 
            break;
        }
        
        GENDLG_CTLCOLOR:
        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        {
            // Only paint the external page and except the ISP sel page
            if ((!pPageInfo->nIdTitle) && (IDD_PAGE_ISPSELECT != pPageInfo->uDlgID))
            {

                HBRUSH hbrWindow = GetSysColorBrush(COLOR_WINDOW);
                DefWindowProc(hDlg, uMsg, wParam, lParam);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (LRESULT)hbrWindow;
            }
            break;
        }
        
        // We need to make sure static controls draw transparently
        // on the background bitmap.  This is done by painting in
        // the appropriate portion of the background, and then 
        // returning a NULL brush so the control just draws the text    
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                if (!(GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY))
                {
                    SetBkMode((HDC)wParam, TRANSPARENT);
                    return (INT_PTR) GetStockObject(NULL_BRUSH);   
                }
                break;                    
            }                
            else
            {
                // Not in modeless opperation so just do the default cltcolor
                // handling
                goto GENDLG_CTLCOLOR;
            }

        case WM_INITDIALOG:
        {
            // get propsheet page struct passed in
            LPPROPSHEETPAGE lpsp = (LPPROPSHEETPAGE) lParam;
            ASSERT(lpsp);
            
            // fetch our private page info from propsheet struct
            pPageInfo = (PAGEINFO *)lpsp->lParam;
            ASSERT(pPageInfo);

            // store pointer to private page info in window data for later
            SetWindowLongPtr(hDlg,DWLP_USER,(LPARAM) pPageInfo);

            // initialize 'back' and 'next' wizard buttons, if
            // page wants something different it can fix in init proc below
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

            // Make the title text bold
            MakeWizard97Title(GetDlgItem(hDlg,IDC_LBLTITLE));

            // call init proc for this page if one is specified
            if (pPageInfo->InitProc)
            {
                if (!( pPageInfo->InitProc(hDlg,TRUE, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }

            // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
            // Before we return, lets send another message to ourself so
            // we have a second chance of initializing stuff that the 
            // property sheet wizard doesn't normally let us do.
            PostMessage(hDlg, WM_MYINITDIALOG, 1, lParam);


            return TRUE;
        }
        
        break;  // WM_INITDIALOG

        // 11/25/96    jmazner Normandy #10586 (copied from icwconn1)
        case WM_MYINITDIALOG:
        {
            // reset the state so that we can download data.
            gfUserCancelled = FALSE;

            if (pPageInfo->PostInitProc)
            {
                if (!( pPageInfo->PostInitProc(hDlg,(BOOL)wParam, NULL)))
                {
                    // If a fatal error occured, quit the wizard.
                    // Note: gfQuitWizard is also used to terminate the wizard
                    // for non-error reasons, but in that case TRUE is returned
                    // from the OK proc and the case is handled below.
                    if (gfQuitWizard)
                    {
                        // Don't reboot if error occured.
                        gpWizardState->fNeedReboot = FALSE;

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                    }                      
                }
            }

            // wParam tells whether this is the first initialization or not
            MiscInitProc(hDlg, (BOOL)wParam, pPageInfo->uDlgID);
            return TRUE;
        }


        case WM_DESTROY:
            ReleaseBold(GetDlgItem(hDlg,IDC_LBLTITLE));
            break;

#ifdef HAS_HELP
        case WM_HELP:
        {
            DWORD dwData = 1000;

            WinHelp(hDlg,"connect.hlp>proc4",HELP_CONTEXT, dwData);
            break;
        }
#endif
        
        case WM_NOTIFY:
        {
            BOOL fRet,fKeepHistory=TRUE;
            NMHDR * lpnm = (NMHDR *) lParam;
#define NEXTPAGEUNITIALIZED -1
            int iNextPage = NEXTPAGEUNITIALIZED;
            switch (lpnm->code) 
            {
                case PSN_TRANSLATEACCELERATOR:    
                {
                    // If the WEBOC is active, then we should let if have a crack as
                    // the accelerator
                    if ((pPageInfo->bIsHostingWebOC) || g_bCustomPaymentActive)
                    {     
                        //SUCEEDED macro will not work here cuz ret maybe S_FALSE
                        if (S_OK == gpWizardState->pICWWebView->HandleKey((LPMSG)((PSHNOTIFY*)lParam)->lParam)) 
                             SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_MESSAGEHANDLED);
                        else
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    else
                    {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT, PSNRET_NOERROR);
                    }
                    return TRUE;
                }
                case PSN_SETACTIVE:
                    // If a fatal error occured in first call to init proc
                    // from WM_INITDIALOG, don't call init proc again.
                    if (FALSE == gfQuitWizard)
                    {
                        // For modeless operation, we are suppressing the painting
                        // of the wizard page background to get the effect of
                        // transparency, so we need to for an update of the 
                        // app's client area after hiding the current page.
                        if(gpWizardState->cmnStateData.bOEMCustom)
                        {
                            // Set the position of the page that is being activated
                            SetWindowPos(hDlg, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
                
                            // Set the page title
                            if (pPageInfo->nIdTitle)
                            {
                                SendMessage(gpWizardState->cmnStateData.hWndApp, WUM_SETTITLE, (WPARAM)ghInstanceResDll, MAKELONG(pPageInfo->nIdTitle, 0));
                            }
                        }    
                        // initialize 'back' and 'next' wizard buttons, if
                        // page wants something different it can fix in init proc below
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);

                        // call init proc for this page if one is specified
                        if (pPageInfo->InitProc)
                        {
                            pPageInfo->InitProc(hDlg,FALSE, (UINT*)&iNextPage);
                            if (NEXTPAGEUNITIALIZED != iNextPage)
                            {
                                // Skipping
                                SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                                return (iNextPage);
                            }
                        }
                    }

                    // If we set the wait cursor, set the cursor back
                    if (hcurOld)
                    {
                        SetCursor(hcurOld);
                        hcurOld = NULL;
                    }

                    PostMessage(hDlg, WM_MYINITDIALOG, 0, lParam);


                    return TRUE;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    // Change cursor to an hour glass
                    hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                    // call OK proc for this page if one is specified
                    if (pPageInfo->OKProc) 
                    {
                        if (!pPageInfo->OKProc(hDlg,(lpnm->code != PSN_WIZBACK), (UINT*)&iNextPage,&fKeepHistory))
                        {
                            // If a fatal error occured, quit the wizard.
                            // Note: gfQuitWizard is also used to terminate the wizard
                            // for non-error reasons, but in that case TRUE is returned
                            // from the OK proc and the case is handled below.
                            if (gfQuitWizard)
                            {
                                // Don't reboot if error occured.
                                gpWizardState->fNeedReboot = FALSE;
                
                                // send a 'cancel' message to ourselves (to keep the prop.
                                // page mgr happy)
                                //
                                // ...Unless we're serving as an Apprentice.  In which case, let
                                // the Wizard decide how to deal with this.

                                PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                            }
                            
                            // stay on this page
                            SetPropSheetResult(hDlg,-1);
                            return TRUE;
                        }
                    }
                    
                    if (lpnm->code != PSN_WIZBACK) 
                    {
                        // 'next' pressed
                        ASSERT(gpWizardState->uPagesCompleted < NUM_WIZARD_PAGES);

                        // save the current page index in the page history,
                        // unless this page told us not to when we called
                        // its OK proc above
                        if (fKeepHistory) 
                        {
                            gpWizardState->uPageHistory[gpWizardState->uPagesCompleted] = gpWizardState->uCurrentPage;
                            TraceMsg(TF_GENDLG, "GENDLG: added page %d (IDD %d) to history list",
                                    gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                            gpWizardState->uPagesCompleted++;
                        }
                        else
                        {
                            TraceMsg(TF_GENDLG, "GENDLG: not adding %d (IDD: %d) to the history list",
                            gpWizardState->uCurrentPage, GetDlgIDFromIndex(gpWizardState->uCurrentPage));
                        }


                        // if no next page specified or no OK proc,
                        // advance page by one
                        if (0 > iNextPage)
                            iNextPage = gpWizardState->uCurrentPage + 1;

                    }
                    else
                    {
                        // 'back' pressed
                    
                        // If we have completed no pages, then we are on the first page 
                        // of the DLL process, so back really means go to the
                        // external prev. page.
                        if (0 == gpWizardState->uPagesCompleted)
                        {
                            iNextPage = g_uExternUIPrev;
                        }
                        
                        // See if we need to get the page from the history list
                        if( NEXTPAGEUNITIALIZED == iNextPage )
                        {
                            ASSERT(gpWizardState->uPagesCompleted > 0);

                            // get the last page from the history list
                            gpWizardState->uPagesCompleted --;
                            iNextPage = gpWizardState->uPageHistory[gpWizardState->uPagesCompleted];
                            TraceMsg(TF_GENDLG, "GENDLG:  extracting page %d (IDD %d) from history list",iNextPage, GetDlgIDFromIndex(iNextPage));
                        }
                                                    
                    }

                    // if we need to exit the wizard now (e.g. launching
                    // signup app and want to terminate the wizard), send
                    // a 'cancel' message to ourselves (to keep the prop.
                    // page mgr happy)
                    if (gfQuitWizard) 
                    {
       
                        //
                        // if we are going from manual to conn1 then
                        // then do not show the  REBOOT dialog but
                        // still preserve the gpWizardState -MKarki Bug #404
                        //
                        if (lpnm->code ==  PSN_WIZBACK)
                        {
                            gfBackedUp = TRUE;
                            gfReboot = gpWizardState->fNeedReboot;
                        }

                        // send a 'cancel' message to ourselves (to keep the prop.
                        // page mgr happy)
                        //
                        // ...Unless we're serving as an Apprentice.  In which case, let
                        // the Wizard decide how to deal with this.

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_CANCEL);
                        SetPropSheetResult(hDlg,-1);
                        return TRUE;
                    }

                    // set next page, only if 'next' or 'back' button
                    // was pressed
                    if (lpnm->code != PSN_WIZFINISH) 
                    {

                        // set the next current page index
                        gpWizardState->uCurrentPage = iNextPage;
                        TraceMsg(TF_GENDLG, "GENDLG: going to page %d (IDD %d)", iNextPage, GetDlgIDFromIndex(iNextPage));

                        // tell the prop sheet mgr what the next page to
                        // display is
                        SetPropSheetResult(hDlg,GetDlgIDFromIndex(iNextPage));
                        return TRUE;
                    }
                    break;

                case PSN_QUERYCANCEL:
                    // if global flag to exit is set, then this cancel
                    // is us pretending to push 'cancel' so prop page mgr
                    // will kill the wizard.  Let this through...
                    if (gfQuitWizard) 
                    {
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,FALSE);
                        return TRUE;
                    }

                                    
                    //Dialing is a super special case cuz we wanna skip all the UI and 
                    //go striaght to a dialing error page
                    if (gpWizardState->uCurrentPage == ORD_PAGE_ISPDIAL)
                    {
                        gfISPDialCancel = TRUE;
                        gfUserCancelled = TRUE;  // Just in case 

                        PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                        // if this page has a special cancel proc, call it
                        if (pPageInfo->CancelProc)
                        {
                            SetWindowLongPtr(hDlg,DWLP_MSGRESULT,pPageInfo->CancelProc(hDlg));
                            SetEvent(gpWizardState->hEventWebGateDone);
                        }
                    }
                    else
                    {
                        // default behavior: pop up a message box confirming
                        // the cancel...
                        // ... unless we're serving as an Apprentice, in which case
                        // we should let the Wizard handle things
                        fRet = (MsgBox(hDlg,IDS_QUERYCANCEL,
                                           MB_ICONQUESTION,MB_YESNO |
                                           MB_DEFBUTTON2) == IDYES);
                        gfUserCancelled = fRet;
                        
                        if (gfUserCancelled)
                        {
                            // if this page has a special cancel proc, call it
                            if (pPageInfo->CancelProc)
                                fRet = pPageInfo->CancelProc(hDlg);
                             
                            SetEvent(gpWizardState->hEventWebGateDone);
                        }   
                        // return the value thru window data
                        SetWindowLongPtr(hDlg,DWLP_MSGRESULT,!fRet);
                    }
                    return TRUE;
                    break;
                    
                default:
                    // See if the page has a notify proc
                    if (pPageInfo->NotifyProc) 
                    {
                        pPageInfo->NotifyProc(hDlg,wParam,lParam);
                    }
                    break;                        
            }
            break;
        }

        case WM_COMMAND:
        {
            // if this page has a command handler proc, call it
            if (pPageInfo->CmdProc) 
            {
                pPageInfo->CmdProc(hDlg, wParam, lParam);
            }
        }
        
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\factory.cpp ===
/****************************************************************************
 *
 *  FACTORY.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CFactory class, which is used by COM's CoCreateInstance
 *
 *  The code comes almost verbatim from Chapter 7 of Dale Rogerson's
 *  "Inside COM", and thus is minimally commented.
 *
 *  05/14/98    donaldm     migrated from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include "icwconn.h"
// #include "icwextsn.h"
#include "icwaprtc.h"

// Friendly name of component
const TCHAR g_szFriendlyName[] = TEXT("CLSID_ApprenticeICWCONN") ;

// Version-independent ProgID
const TCHAR g_szVerIndProgID[] = TEXT("ICWCONN.Apprentice") ;

// ProgID
const TCHAR g_szProgID[] = TEXT("ICWCONN.Apprentice.1") ;

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

///////////////////////////////////////////////////////////
//
// Class factory
//
class CFactory : public IClassFactory
{
public:
    // IUnknown
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;         
    virtual ULONG   __stdcall AddRef() ;
    virtual ULONG   __stdcall Release() ;

    // Interface IClassFactory
    virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
                                             const IID& iid,
                                             void** ppv) ;
    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

    // Constructor
    CFactory() : m_cRef(1) {}

    // Destructor
    ~CFactory() { TraceMsg(TF_CLASSFACTORY, "Class factory:\t\tDestroy self.") ;}

private:
    long m_cRef ;
} ;

//
// Class factory IUnknown implementation
//
HRESULT __stdcall CFactory::QueryInterface(const IID& iid, void** ppv)
{    
    TraceMsg(TF_CLASSFACTORY, "CFactory::QueryInterface");
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IClassFactory*>(this) ; 
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall CFactory::AddRef()
{
    TraceMsg(TF_CLASSFACTORY, "CFactory::AddRef %d", m_cRef + 1);
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall CFactory::Release() 
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    TraceMsg(TF_CLASSFACTORY, "CFactory::Release %d", m_cRef);
    return m_cRef ;
}

//
// IClassFactory implementation
//
HRESULT __stdcall CFactory::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance:\t\tCreate component.") ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.  Since there's no direct IUnknown implementation,
    // use CICWApprentice.
    CICWApprentice *pApprentice = new CICWApprentice;
    
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance CICWApprentice->AddRef");
    pApprentice->AddRef();
    
    if( NULL == pApprentice )
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance About to QI on CICWApprentice");
    HRESULT hr = pApprentice->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    TraceMsg(TF_CLASSFACTORY, "CFactory::CreateInstance done with CICWApprentice, releasing (aprtc should have ct of 1)");
    pApprentice->Release() ;
    
    return hr ;
}

// LockServer
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ; 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}


///////////////////////////////////////////////////////////
//
// Exported functions
//
// These are the functions that COM expects to find
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject:\tCreate class factory.") ;

    // Can we create this component?
    if (clsid != CLSID_ApprenticeICWCONN)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    CFactory* pFactory = new CFactory ;  // No AddRef in constructor
    if (pFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject about to QI on CFactory");
    HRESULT hr = pFactory->QueryInterface(iid, ppv) ;
    TraceMsg(TF_CLASSFACTORY, "DllGetClassObject done with CFactory, releasing");
    pFactory->Release() ;



    return hr ;
}


// The following two exported functions are what regsvr32 uses to
// self-register and unregister the dll.  See REGISTRY.CPP for
// actual implementation

//
// Server registration
//

typedef BOOL (WINAPI * REGISTERSERVER)(HMODULE hModule, 
                                       const CLSID& clsid, 
                                       const LPTSTR szFriendlyName,
                                       const LPTSTR szVerIndProgID,
                                       const LPTSTR szProgID);

typedef BOOL (WINAPI * UNREGISTERSERVER)(const CLSID& clsid,
                                         const LPTSTR szVerIndProgID,
                                         const LPTSTR szProgID);

STDAPI DllRegisterServer()
{
    // Use the register server function that is in ICWUTIL.DLL
    HINSTANCE       hInstUtilDLL = LoadLibrary(ICW_UTIL);
    REGISTERSERVER  lpfnRegisterServer = NULL;
    HRESULT         hr = E_FAIL;
    
    if (hInstUtilDLL)
    {
        lpfnRegisterServer = (REGISTERSERVER)GetProcAddress(hInstUtilDLL, "RegisterServer");
        if (NULL != lpfnRegisterServer)
        {
            if (lpfnRegisterServer(ghInstance, 
                                  CLSID_ApprenticeICWCONN,
                                  (LPTSTR)g_szFriendlyName,
                                  (LPTSTR)g_szVerIndProgID,
                                  (LPTSTR)g_szProgID))
                hr = S_OK;                                  
        }
        FreeLibrary(hInstUtilDLL);
    }
    return (hr);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    // Use the un-register server function that is in ICWUTIL.DLL
    HINSTANCE           hInstUtilDLL = LoadLibrary(ICW_UTIL);
    UNREGISTERSERVER    lpfnUnregisterServer = NULL;
    HRESULT             hr = E_FAIL;
    
    if (hInstUtilDLL)
    {
        lpfnUnregisterServer = (UNREGISTERSERVER)GetProcAddress(hInstUtilDLL, "UnregisterServer");
        if (NULL != lpfnUnregisterServer)
        {
            if (lpfnUnregisterServer(CLSID_ApprenticeICWCONN,
                                    (LPTSTR)g_szVerIndProgID,
                                    (LPTSTR)g_szProgID))
                hr = S_OK;                                  
        }
        FreeLibrary(hInstUtilDLL);
    }
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\icwhelp.cpp ===
#include "pre.h"


// Include the interface file for the ICWHELP Dll
#include "..\inc\icwhelp_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\icwres.cpp ===
// Insert your headers here
#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers

#include <windows.h>

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  dwReason, 
                       LPVOID lpReserved
                     )
{
    return TRUE; // ok
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\icwaprtc.h ===
#include "icwconn.h"

extern  IICW50Extension *g_pExternalIICWExtension;
extern  BOOL            g_fConnectionInfoValid;


class CICWApprentice : public IICW50Apprentice
{
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize(IICW50Extension *pExt);
        virtual HRESULT STDMETHODCALLTYPE AddWizardPages(DWORD dwFlags);
        virtual HRESULT STDMETHODCALLTYPE Save(HWND hwnd, DWORD *pdwError);
        virtual HRESULT STDMETHODCALLTYPE SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromExeToDll(LPCMNSTATEDATA lpData);
        virtual HRESULT STDMETHODCALLTYPE SetStateDataFromDllToExe(LPCMNSTATEDATA lpData);
        virtual HRESULT STDMETHODCALLTYPE ProcessCustomFlags(DWORD dwFlags);


        virtual HRESULT STDMETHODCALLTYPE QueryInterface( REFIID theGUID, void** retPtr );
        virtual ULONG   STDMETHODCALLTYPE AddRef( void );
        virtual ULONG   STDMETHODCALLTYPE Release( void );

        CICWApprentice( void );
        ~CICWApprentice( void );

        IICW50Extension     *m_pIICW50Ext;

    private:
        LONG                m_lRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\icwconn.cpp ===
//**********************************************************************
// File name: ICWCONN.cpp
//
//      Main source file for the Internet Connection Wizard extension DLL
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
 
#include "pre.h"
#include "webvwids.h"

// local function prototypes
BOOL AllocDialogIDList( void );
BOOL DialogIDAlreadyInUse( UINT uDlgID );
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse );

#pragma data_seg(".data")

WIZARDSTATE     *gpWizardState=NULL;   // pointer to global wizard state struct
IICWWebView     *gpICWWebView[2];

#ifdef NEED_EXTENSION
DWORD           *g_pdwDialogIDList = NULL;
DWORD           g_dwDialogIDListSize = 0;
UINT            g_uICWCONN1UIFirst, g_uICWCONN1UILast; 
BOOL            g_fICWCONN1UILoaded = FALSE;
CICWExtension   *g_pCICW50Extension = NULL;
#endif

//
// Table of data for each wizard page
//
// This includes the dialog template ID and pointers to functions for
// each page.  Pages need only provide pointers to functions when they
// want non-default behavior for a certain action (init,next/back,cancel,
// dlg ctrl).
//

PAGEINFO PageInfo[NUM_WIZARD_PAGES] =
{
    { IDD_PAGE_ISPSELECT,    TRUE,  ISPSelectInitProc,          NULL,                   ISPSelectOKProc,    NULL,               NULL,              ISPSelectNotifyProc,     0,                      0, IDA_ISPSELECT, NULL, NULL },
    { IDD_PAGE_NOOFFER,      TRUE,  NoOfferInitProc,            NULL,                   NoOfferOKProc,      NULL,               NULL,              NULL,                    0,                      0, 0, NULL, NULL },
    { IDD_PAGE_USERINFO,     FALSE, UserInfoInitProc,           NULL,                   UserInfoOKProc,     NULL,               NULL,              NULL,                    IDS_STEP2_TITLE,        0, 0, NULL, NULL },
    { IDD_PAGE_BILLINGOPT,   TRUE,  BillingOptInitProc,         NULL,                   BillingOptOKProc,   NULL,               NULL,              NULL,                    IDS_STEP2_TITLE,        0, IDA_BILLINGOPT, NULL, NULL },
    { IDD_PAGE_PAYMENT,      FALSE, PaymentInitProc,            NULL,                   PaymentOKProc,      PaymentCmdProc,     NULL,              NULL,                    IDS_STEP2_TITLE,        0, IDA_PAYMENT, NULL, NULL },
    { IDD_PAGE_ISPDIAL,      FALSE, ISPDialInitProc,            ISPDialPostInitProc,    ISPDialOKProc,      NULL,               ISPDialCancelProc, NULL,                    IDS_STEP2_TITLE,        0, 0, NULL, NULL },
    { IDD_PAGE_ISPDATA,      TRUE,  ISPPageInitProc,            NULL,                   ISPPageOKProc,      ISPCmdProc,         NULL,              NULL,                    IDS_STEP2_TITLE,        0, IDA_ISPDATA, NULL, NULL },
    { IDD_PAGE_OLS,          TRUE,  OLSInitProc,                NULL,                   OLSOKProc,          NULL,               NULL,              NULL,                    IDS_OLS_TITLE,          0, 0, NULL, NULL },
    { IDD_PAGE_DIALERROR,    FALSE, DialErrorInitProc,          NULL,                   DialErrorOKProc,    DialErrorCmdProc,   NULL,              NULL,                    IDS_DIALING_ERROR_TITLE,0, IDA_DIALERROR, NULL, NULL },
    { IDD_PAGE_SERVERROR,    FALSE, ServErrorInitProc,          NULL,                   ServErrorOKProc,    ServErrorCmdProc,   NULL,              NULL,                    IDS_SERVER_ERROR_TITLE, 0, IDA_SERVERROR, NULL, NULL },
    { IDD_PAGE_ACFG_ISP,     TRUE,  ISPAutoSelectInitProc,      NULL,                   ISPAutoSelectOKProc,NULL,               NULL,              ISPAutoSelectNotifyProc, IDS_STEP1_TITLE,        0, IDA_ACFG_ISP, NULL, NULL },
    { IDD_PAGE_ACFG_NOOFFER, TRUE,  ACfgNoofferInitProc,        NULL,                   ACfgNoofferOKProc,  NULL,               NULL,              NULL,                    IDS_MANUAL_TITLE,       0, 0, NULL, NULL },
    { IDD_PAGE_ISDN_NOOFFER, TRUE,  ISDNNoofferInitProc,        NULL,                   ISDNNoofferOKProc,  NULL,               NULL,              NULL,                    0,                      0, 0, NULL, NULL },
    { IDD_PAGE_OEMOFFER,     TRUE,  OEMOfferInitProc,           NULL,                   OEMOfferOKProc,     OEMOfferCmdProc,    NULL,              NULL,                    IDS_STEP1_TITLE,        0, IDA_OEMOFFER, NULL, NULL }
};

BOOL        gfQuitWizard     = FALSE;    // global flag used to signal that we want to terminate the wizard ourselves
BOOL        gfUserCancelled  = FALSE;    // global flag used to signal that the user cancelled
BOOL        gfISPDialCancel  = FALSE;    // global flag used to signal that the user cancelled
BOOL        gfUserBackedOut  = FALSE;    // global flag used to signal that the user pressed Back on the first page
BOOL        gfUserFinished   = FALSE;    // global flag used to signal that the user pressed Finish on the final page
BOOL        gfBackedUp       = FALSE;
BOOL        gfReboot         = FALSE;
BOOL        g_bMalformedPage = FALSE;

#pragma data_seg()

BOOL CleanupWizardState(WIZARDSTATE * pWizardState);

/*******************************************************************

  NAME:    InitWizardState

  SYNOPSIS:  Initializes wizard state structure

********************************************************************/
BOOL InitWizardState(WIZARDSTATE * pWizardState)
{
    HRESULT hr;
    
    ASSERT(pWizardState);

    //register the Native font control so the dialog won't fail
    //although it's registered in the exe this is a "just in case"
    INITCOMMONCONTROLSEX iccex;
    iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    iccex.dwICC  = ICC_NATIVEFNTCTL_CLASS;
    if (!InitCommonControlsEx(&iccex))
        return FALSE;

    // zero out structure
    ZeroMemory(pWizardState,sizeof(WIZARDSTATE));

    // set starting page
    pWizardState->uCurrentPage = ORD_PAGE_ISPSELECT;
    pWizardState->fNeedReboot = FALSE;
    pWizardState->bISDNMode = FALSE;
    pWizardState->himlIspSelect = NULL; 
    pWizardState->uNumTierOffer = 0;
    for (UINT i=0; i < MAX_OEM_MUTI_TIER; i++)
        pWizardState->lpOEMISPInfo[i] = NULL;

    // Instansiate ICWHELP objects
    hr = CoCreateInstance(CLSID_UserInfo,NULL,CLSCTX_INPROC_SERVER,
                     IID_IUserInfo,(LPVOID *)&pWizardState->pUserInfo);
    if (FAILED(hr))
        goto InitWizardStateError;
    
    hr = CoCreateInstance(CLSID_RefDial,NULL,CLSCTX_INPROC_SERVER,
                          IID_IRefDial,(LPVOID *)&pWizardState->pRefDial);
    if (FAILED(hr))
        goto InitWizardStateError;
                          
    hr = CoCreateInstance(CLSID_WebGate,NULL,CLSCTX_INPROC_SERVER,
                          IID_IWebGate,(LPVOID *)&pWizardState->pWebGate);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_INSHandler,NULL,CLSCTX_INPROC_SERVER,
                          IID_IINSHandler,(LPVOID *)&pWizardState->pINSHandler);
    if (FAILED(hr))
        goto InitWizardStateError;
        
    hr = CoCreateInstance(CLSID_ICWWEBVIEW,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWWebView,(LPVOID *)&pWizardState->pICWWebView);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_ICWWALKER,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWWalker,(LPVOID *)&pWizardState->pHTMLWalker);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_ICWGIFCONVERT,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWGifConvert,(LPVOID *)&pWizardState->pGifConvert);
    if (FAILED(hr))
        goto InitWizardStateError;

    hr = CoCreateInstance(CLSID_ICWISPDATA,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWISPData,(LPVOID *)&pWizardState->pISPData);
    if (FAILED(hr))
        goto InitWizardStateError;

    if ( !pWizardState->pUserInfo   ||
         !pWizardState->pWebGate    ||
         !pWizardState->pINSHandler ||
         !pWizardState->pHTMLWalker ||
         !pWizardState->pRefDial    ||
         !pWizardState->pICWWebView ||
         !pWizardState->pGifConvert ||
         !pWizardState->pISPData    ||
         !pWizardState->pHTMLWalker)
    {
        goto InitWizardStateError;
    }

    // Init the walker for use with trident
    hr = pWizardState->pHTMLWalker->InitForMSHTML();
    if (FAILED(hr))
        goto InitWizardStateError;

    if ((pWizardState->pStorage = new CStorage) == NULL)
    {
        goto InitWizardStateError;
    }
    
    pWizardState->hEventWebGateDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!pWizardState->hEventWebGateDone)
        goto InitWizardStateError;
    
    // Success error return path    
    return TRUE;

InitWizardStateError:
    // Free any co-created objects
    CleanupWizardState(pWizardState);
    return FALSE;
}

BOOL CleanupWizardState(WIZARDSTATE * pWizardState)
{
    if (pWizardState->pHTMLWalker)
    {
        pWizardState->pHTMLWalker->TermForMSHTML();
        pWizardState->pHTMLWalker->Release();
        pWizardState->pHTMLWalker = NULL;
    }        

    if (pWizardState->pICWWebView)
    {
        pWizardState->pICWWebView->Release();
        pWizardState->pICWWebView = NULL;
    }
    
    if (gpICWWebView[0])
    {
        gpICWWebView[0]->Release();
        gpICWWebView[0] = NULL;
    }

    if (gpICWWebView[1])
    {
        gpICWWebView[1]->Release();
        gpICWWebView[1] = NULL;
    }

    if (NULL != gpWizardState->himlIspSelect)
    {
        ImageList_Destroy(gpWizardState->himlIspSelect);
        gpWizardState->himlIspSelect = NULL;
    }

    if (pWizardState->pGifConvert)
    {
        pWizardState->pGifConvert->Release();
        pWizardState->pGifConvert = NULL;
    }            

    if (pWizardState->pISPData)
    {
        pWizardState->pISPData->Release();
        pWizardState->pISPData = NULL;
    }            
    
    if (pWizardState->pUserInfo)
    {
        BOOL    bRetVal;
        // Before releasing the userinfo object, we should persist the user data if 
        // necessary
        if (!gfUserCancelled && gpWizardState->bWasNoUserInfo && gpWizardState->bUserEnteredData)
            pWizardState->pUserInfo->PersistRegisteredUserInfo(&bRetVal);
        
        pWizardState->pUserInfo->Release();
        pWizardState->pUserInfo  = NULL;
    }

    if (pWizardState->pRefDial)
    {
        pWizardState->pRefDial->Release();
        pWizardState->pRefDial = NULL;
    }
    
    if (pWizardState->pWebGate)
    {
        pWizardState->pWebGate->Release();
        pWizardState->pWebGate = NULL;
    }
    
    if (pWizardState->pINSHandler)
    {
        pWizardState->pINSHandler->Release();
        pWizardState->pINSHandler = NULL;
    }

    if (pWizardState->pStorage)
    {
        delete pWizardState->pStorage;
    }
    
    for (UINT i=0; i < pWizardState->uNumTierOffer; i++)
    {
        if (pWizardState->lpOEMISPInfo[i])
        {
            // Prevent deleting it twice
            if (pWizardState->lpOEMISPInfo[i] != pWizardState->lpSelectedISPInfo)
            {
                delete pWizardState->lpOEMISPInfo[i];
                pWizardState->lpOEMISPInfo[i] = NULL;
            }
        }
    }

    if (pWizardState->lpSelectedISPInfo)
    {
        delete pWizardState->lpSelectedISPInfo;
    }
    
    if (pWizardState->hEventWebGateDone)
    {
        CloseHandle(pWizardState->hEventWebGateDone);
        pWizardState->hEventWebGateDone = 0;
    }

    // Kill the idle timer just in case.
    KillIdleTimer();
        
    return TRUE;
}

#ifdef NEED_EXTENSION
//+----------------------------------------------------------------------------
//
//    Function    AllocDialogIDList
//
//    Synopsis    Allocates memory for the g_pdwDialogIDList variable large enough
//                to maintain 1 bit for every valid external dialog ID
//
//    Arguments    None
//
//    Returns        TRUE if allocation succeeds
//                FALSE otherwise
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL AllocDialogIDList( void )
{
    ASSERT( NULL == g_pdwDialogIDList );
    if( g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN,"ICWCONN: AllocDialogIDList called with non-null g_pdwDialogIDList!");
        return FALSE;
    }

    // determine maximum number of external dialogs we need to track
    UINT uNumExternDlgs = EXTERNAL_DIALOGID_MAXIMUM - EXTERNAL_DIALOGID_MINIMUM + 1;

    // we're going to need one bit for each dialogID.
    // Find out how many DWORDS it'll take to get this many bits.
    UINT uNumDWORDsNeeded = (uNumExternDlgs / ( 8 * sizeof(DWORD) )) + 1;

    // set global var with length of the array
    g_dwDialogIDListSize = uNumDWORDsNeeded;

    g_pdwDialogIDList = (DWORD *) GlobalAlloc(GPTR, uNumDWORDsNeeded * sizeof(DWORD));

    if( !g_pdwDialogIDList )
    {
        TraceMsg(TF_ICWCONN,"ICWCONN: AllocDialogIDList unable to allocate space for g_pdwDialogIDList!");
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//    Function    DialogIDAlreadyInUse
//
//    Synopsis    Checks whether a given dialog ID is marked as in use in the
//                global array pointed to by g_pdwDialogIDList
//
//    Arguments    uDlgID -- Dialog ID to check
//
//    Returns        TRUE if    -- DialogID is out of range defined by EXTERNAL_DIALOGID_*
//                        -- DialogID is marked as in use
//                FALSE if DialogID is not marked as in use
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------

BOOL DialogIDAlreadyInUse( UINT uDlgID )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN,"ICWCONN: DialogIDAlreadyInUse received an out of range DialogID, %d", uDlgID);
        return TRUE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;

    BOOL fBitSet = g_pdwDialogIDList[baseIndex] & (dwBitMask);

    return( fBitSet );
}

//+----------------------------------------------------------------------------
//
//    Function    SetDialogIDInUse
//
//    Synopsis    Sets or clears the in use bit for a given DialogID
//
//    Arguments    uDlgID -- Dialog ID for which to change status
//                fInUse -- New value for the in use bit.
//
//    Returns        TRUE if status change succeeded.
//                FALSE if DialogID is out of range defined by EXTERNAL_DIALOGID_*
//
//    History        4/23/97    jmazner        created
//
//-----------------------------------------------------------------------------
BOOL SetDialogIDInUse( UINT uDlgID, BOOL fInUse )
{
    if( (uDlgID < EXTERNAL_DIALOGID_MINIMUM) ||
        (uDlgID > EXTERNAL_DIALOGID_MAXIMUM)     )
    {
        // this is an out-of-range ID, don't want to accept it.
        TraceMsg(TF_ICWCONN,"ICWCONN: SetDialogIDInUse received an out of range DialogID, %d", uDlgID);
        return FALSE;
    }
    // find which bit we need
    UINT uBitToCheck = uDlgID - EXTERNAL_DIALOGID_MINIMUM;
    
    UINT bitsInADword = 8 * sizeof(DWORD);

    UINT baseIndex = uBitToCheck / bitsInADword;

    ASSERT( (baseIndex < g_dwDialogIDListSize));

    DWORD dwBitMask = 0x1 << uBitToCheck%bitsInADword;


    if( fInUse )
    {
        g_pdwDialogIDList[baseIndex] |= (dwBitMask);
    }
    else
    {
        g_pdwDialogIDList[baseIndex] &= ~(dwBitMask);
    }


    return TRUE;
}

#endif

DWORD WINAPI GetICWCONNVersion()
{
    return ICW_DOWNLOADABLE_COMPONENT_VERSION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\icwaprtc.cpp ===
/****************************************************************************
 *
 *  ICWAPRTC.cpp
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1992-1997
 *  All rights reserved
 *
 *  This module provides the implementation of the methods for
 *  the CICWApprentice class.
 *
 *  5/13/98     donaldm     adapted from INETCFG
 *
 ***************************************************************************/

#include "pre.h"
#include <vfw.h>
#include "initguid.h"
#include "icwaprtc.h"
#include "icwconn.h"
#include "webvwids.h"

#define PROGRESSANIME_XPOS      10      // Default offset from the left side
#define PROGRESSANIME_YPOS      40      // Default height plus border at bottom
#define PROGRESSANIME_YBORDER   10      // default border at bottom

UINT    g_uExternUIPrev, g_uExternUINext;

//defined/allocated in icwconn.cpp
extern PAGEINFO PageInfo[NUM_WIZARD_PAGES];

// In GENDLG.CPP
extern INT_PTR CALLBACK GenDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern BOOL InitWizardState(WIZARDSTATE * pWizardState);
extern BOOL CleanupWizardState(WIZARDSTATE * pWizardState);
extern DWORD WINAPI GetICWCONNVersion(void);

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::Initialize
//
//  Synopsis    Called by the main Wizard to initialize class members and
//              globals
//
//  Arguments   [in] pExt -- pointer the Wizard's IICW50Extension interface, which
//                          encapsulates the functionality needed to add wizard
//                          pages.
//
//  Returns     E_OUTOFMEMORY -- unable to allocate global vars.
//              S_OK indicates success
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Initialize(IICW50Extension *pExt)
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::Initialize");

    ASSERT( pExt );
    m_pIICW50Ext = pExt;

    m_pIICW50Ext->AddRef();

    if( !gpWizardState)
    {
        gpWizardState = new WIZARDSTATE;
    }

    if( !gpWizardState )
    {
        TraceMsg(TF_APPRENTICE, "CICWApprentice::Initialize couldn't initialize the globals!");
        return E_OUTOFMEMORY;
    }

    // initialize the app state structure
    if (!InitWizardState(gpWizardState))
        return E_FAIL;

    // Since we now have the ISPData object (created during InitWizardState), this is a good time to
    // initialize the ISPData object, since we cannot be sure when it will be
    // used for data validation
    gpWizardState->hWndWizardApp = pExt->GetWizardHwnd();
    gpWizardState->pISPData->Init(gpWizardState->hWndWizardApp);
 
    
    return S_OK;

}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::AddWizardPages
//
//  Synopsis    Creates a series of Property Sheet pages, and adds them to the
//              main wizard via the m_pIICW50Ext interface pointer.  Note that
//              we add every page in the global PageInfo struct, even though the
//              Apprentice may not use some pages (eg, CONNECTEDOK)
//
//  Arguments   [] dwFlags -- currently unused
//
//  Returns     S_OK indicates success
//              E_FAIL indicates failure.  If for any reason all pages can not be
//                      added, we will attempt to remove any pages that had been
//                      added prior to the failure.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::AddWizardPages(DWORD dwFlags)
{
    HPROPSHEETPAGE hWizPage[NUM_WIZARD_PAGES];  // array to hold handles to pages
    PROPSHEETPAGE psPage;    // struct used to create prop sheet pages
    UINT nPageIndex;
    HRESULT hr = S_OK;
    unsigned long ulNumItems = 0;

    TraceMsg(TF_APPRENTICE, "CICWApprentice::AddWizardPages");

    ZeroMemory(&hWizPage,sizeof(hWizPage));   // hWizPage is an array
    ZeroMemory(&psPage,sizeof(PROPSHEETPAGE));

    // fill out common data property sheet page struct
    psPage.dwSize     = sizeof(psPage);
    psPage.hInstance  = ghInstanceResDll;
    psPage.pfnDlgProc = GenDlgProc;

    // create a property sheet page for each page in the wizard
    for (nPageIndex = 0; nPageIndex < NUM_WIZARD_PAGES; nPageIndex++)
    {
        UINT    uDlgID;
        psPage.dwFlags     = PSP_DEFAULT  | PSP_USETITLE;
        psPage.pszTitle    = gpWizardState->cmnStateData.szWizTitle;
        uDlgID             = PageInfo[nPageIndex].uDlgID;
        psPage.pszTemplate = MAKEINTRESOURCE(uDlgID);
                 
        // set a pointer to the PAGEINFO struct as the private data for this
        // page
        psPage.lParam = (LPARAM) &PageInfo[nPageIndex];

        if (PageInfo[nPageIndex].nIdTitle)
        {
            psPage.dwFlags |= PSP_USEHEADERTITLE | (PageInfo[nPageIndex].nIdSubTitle ? PSP_USEHEADERSUBTITLE : 0);
            psPage.pszHeaderTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdTitle);
            psPage.pszHeaderSubTitle = MAKEINTRESOURCE(PageInfo[nPageIndex].nIdSubTitle);
        }
        else
        {
            psPage.dwFlags |= PSP_HIDEHEADER;
        }
        
        hWizPage[nPageIndex] = CreatePropertySheetPage(&psPage);

        if (!hWizPage[nPageIndex])
        {
            ASSERT(0);
            MsgBox(NULL,IDS_ERR_OUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);

            hr = E_FAIL;
            // creating page failed, free any pages already created and bail
            goto AddWizardPagesErrorExit;
        }

        hr = m_pIICW50Ext->AddExternalPage( hWizPage[nPageIndex], uDlgID);

        if( FAILED(hr) )
        {
            // free any pages already created and bail
            goto AddWizardPagesErrorExit;
        }

        // Load the accelerator table for this page if necessary
        if (PageInfo[nPageIndex].idAccel)
            PageInfo[nPageIndex].hAccel = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(PageInfo[nPageIndex].idAccel));      
    }

    // of course, we have no idea what the last page will really be.
    // so make a guess here, and update it later when we know for sure.
    ProcessCustomFlags(dwFlags);

    return S_OK;


AddWizardPagesErrorExit:
    UINT nFreeIndex;
    for (nFreeIndex=0;nFreeIndex<nPageIndex;nFreeIndex++)
    {
        UINT    uDlgID;
        uDlgID = PageInfo[nPageIndex].uDlgID;
    
        DestroyPropertySheetPage(hWizPage[nFreeIndex]);
        m_pIICW50Ext->RemoveExternalPage( hWizPage[nFreeIndex], uDlgID );
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::Save
//
//  Synopsis    Called by the Wizard to commit changes
//
//  Arguments   [in] hwnd -- hwnd of Wizard window, used to display modal msgs
//              [out] pdwError -- implementation specfic error code.  Not used.
//
//  Returns     S_OK indicates success
//              Otherwise, returns E_FAIL.
//
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::Save(HWND hwnd, DWORD *pdwError)
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::Save");
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::SetPrevNextPage
//
//  Synopsis    Lets the apprentice notify the wizard of the dialog IDs of the
//              first and last pages in the apprentice
//
//
//  Arguments   uPrevPageDlgID -- DlgID of wizard page to back up to
//              uNextPageDlgID -- DlgID of wizard page to go forwards into
//
//
//  Returns     FALSE if both parameters are 0
//              TRUE if the update succeeded.
//
//  Notes:      If either variable is set to 0, the function will not update
//              that information, i.e. a value of 0 means "ignore me".  If both
//              variables are 0, the function immediately returns FALSE.
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetPrevNextPage(UINT uPrevPageDlgID, UINT uNextPageDlgID)
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::SetPrevNextPage: updating prev = %d, next = %d",
        uPrevPageDlgID, uNextPageDlgID);

    if( (0 == uPrevPageDlgID) && (0 == uNextPageDlgID) )
    {
        TraceMsg(TF_APPRENTICE, "SetFirstLastPage: both IDs are 0!");
        return( E_INVALIDARG );
    }

    if( 0 != uPrevPageDlgID )
        g_uExternUIPrev = uPrevPageDlgID;
    if( 0 != uNextPageDlgID )
        g_uExternUINext = uNextPageDlgID;


    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::ProcessCustomFlags
//
//  Synopsis    Lets the apprentice know that there is a special modification
//              to this set of apprentice pages after it is loaded
//
//  Arguments   dwFlags -- info needed to pass to the external pages
//
//
//  Returns     FALSE if both parameters are 0
//              TRUE if the update succeeded.
//
//  History     5/23/97 vyung     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::ProcessCustomFlags(DWORD dwFlags)
{
    if( m_pIICW50Ext )
    {
    
        if(dwFlags & ICW_CFGFLAG_IEAKMODE)
        {          
            CISPCSV     *pcISPCSV = new CISPCSV;
            
            if (pcISPCSV == NULL)
            {
                return E_FAIL;
            }

            // Set the Current selected ISP to this one.
            gpWizardState->lpSelectedISPInfo = pcISPCSV;
                
            // Initialize the new Selected ISP info object                
            gpWizardState->lpSelectedISPInfo->set_szISPName(gpWizardState->cmnStateData.ispInfo.szISPName);
            gpWizardState->lpSelectedISPInfo->set_szISPFilePath(gpWizardState->cmnStateData.ispInfo.szISPFile);
            gpWizardState->lpSelectedISPInfo->set_szBillingFormPath(gpWizardState->cmnStateData.ispInfo.szBillHtm);
            gpWizardState->lpSelectedISPInfo->set_szPayCSVPath(gpWizardState->cmnStateData.ispInfo.szPayCsv);
            gpWizardState->lpSelectedISPInfo->set_bCNS(FALSE);
            gpWizardState->lpSelectedISPInfo->set_bIsSpecial(FALSE);
            gpWizardState->lpSelectedISPInfo->set_dwCFGFlag(dwFlags);
            gpWizardState->lpSelectedISPInfo->set_dwRequiredUserInputFlags(gpWizardState->cmnStateData.ispInfo.dwValidationFlags);
            
            // What page do we display first?
            if (dwFlags & ICW_CFGFLAG_USERINFO)
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_USERINFO, IDD_PAGE_USERINFO );
            else if (dwFlags & ICW_CFGFLAG_BILL)
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_BILLINGOPT, IDD_PAGE_BILLINGOPT );
            else if (dwFlags & ICW_CFGFLAG_PAYMENT)
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_PAYMENT, IDD_PAGE_PAYMENT );
            else
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_ISPDIAL, IDD_PAGE_ISPDIAL );
        }
        else
        {
            if (dwFlags & ICW_CFGFLAG_AUTOCONFIG)
            {
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_ACFG_ISP, IDD_PAGE_ACFG_ISP );
            }
            else
            {
                m_pIICW50Ext->SetFirstLastPage( IDD_PAGE_ISPSELECT, IDD_PAGE_ISPSELECT );
            }
        }    
    }

    return S_OK;
}
//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::SetStateData
//
//  Synopsis    Lets the apprentice set wizard state data
//
//  Arguments   LPCMNSTATEDATA Pointer to state data to be set
//
//  Returns     
//  History     5/22/98 donaldm     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::SetStateDataFromExeToDll(LPCMNSTATEDATA lpData) 
{
    TCHAR       szTemp[MAX_RES_LEN];
    HWND        hWndAnimeParent = gpWizardState->hWndWizardApp;
    int         xPosProgress = PROGRESSANIME_XPOS;
    int         yPosProgress = -1;
    RECT        rect;
    LPTSTR      lpszAnimateFile =  MAKEINTRESOURCE(IDA_PROGRESSANIME);
    
    ASSERT(gpWizardState);
    
    memcpy(&gpWizardState->cmnStateData, lpData, sizeof(CMNSTATEDATA));
    
    
    // Set values in the ISP Data object that are part of the cmnstatedata, or are not 
    // specific to user data entry
    wsprintf (szTemp, TEXT("%ld"), gpWizardState->cmnStateData.dwCountryCode);
    gpWizardState->pISPData->PutDataElement(ISPDATA_COUNTRYCODE, szTemp, ISPDATA_Validate_None);
    gpWizardState->pISPData->PutDataElement(ISPDATA_AREACODE, gpWizardState->cmnStateData.szAreaCode, ISPDATA_Validate_None);
    wsprintf (szTemp, TEXT("%ld"), GetICWCONNVersion());
    gpWizardState->pISPData->PutDataElement(ISPDATA_ICW_VERSION, szTemp, ISPDATA_Validate_None);
        
    // If we are in modeless operation, (aka OEM custom) then we need
    // to set the HTML background color for some pages
    if(gpWizardState->cmnStateData.bOEMCustom)
    {
        gpWizardState->pICWWebView->SetHTMLColors(gpWizardState->cmnStateData.szclrHTMLText,
                                                  gpWizardState->cmnStateData.szHTMLBackgroundColor);
        
        if (!gpWizardState->cmnStateData.bHideProgressAnime)
        {
            // Set the progress animation parent to the App window
            hWndAnimeParent = gpWizardState->cmnStateData.hWndApp;
            
            // see if the oem has specified an x Position for the animation
            if (-1 != gpWizardState->cmnStateData.xPosBusy)
                xPosProgress = gpWizardState->cmnStateData.xPosBusy;
               
            // see if the oem has specified an differen animation file            
            if ('\0' != gpWizardState->cmnStateData.szBusyAnimationFile[0])
            {
                PAVIFILE    pFile;
                AVIFILEINFO fi;
                
                lpszAnimateFile = gpWizardState->cmnStateData.szBusyAnimationFile;
                
                // Compute the y-Position based on the height of the AVI file
                // and the size of the parent window
                AVIFileInit();
                AVIFileOpen(&pFile,     
                            gpWizardState->cmnStateData.szBusyAnimationFile,        
                            OF_READ,             
                            NULL);
                AVIFileInfo(pFile, &fi, sizeof(fi));
                AVIFileRelease(pFile);
                AVIFileExit();
                        
                GetClientRect(hWndAnimeParent, &rect);
                yPosProgress = rect.bottom - fi.dwHeight - PROGRESSANIME_YBORDER;
            }            
        }            
    }
    
    // Setup the progress animation
    if (!gpWizardState->hwndProgressAnime && !gpWizardState->cmnStateData.bHideProgressAnime)
    {
        // calculate the y-position of the progress animation
        if (-1 == yPosProgress)
        {
            GetClientRect(hWndAnimeParent, &rect);
            yPosProgress = rect.bottom - PROGRESSANIME_YPOS;
        }
        
        //Create the animation / progress control    
        gpWizardState->hwndProgressAnime = CreateWindow(ANIMATE_CLASS,
                                              TEXT(""),
                                              ACS_TRANSPARENT | WS_CHILD,
                                              xPosProgress, 
                                              yPosProgress,
                                              0, 0,
                                              hWndAnimeParent,
                                              NULL,
                                              ghInstanceResDll,
                                              NULL);  
        //Set the avi
        Animate_Open (gpWizardState->hwndProgressAnime, lpszAnimateFile);
    }    
        
    return (S_OK);
}

//converse of the previous function
HRESULT CICWApprentice::SetStateDataFromDllToExe(LPCMNSTATEDATA lpData) 
{
    ASSERT(gpWizardState);
    
    memcpy(lpData, &gpWizardState->cmnStateData, sizeof(CMNSTATEDATA));
    
    return (S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::QueryInterface
//
//  Synopsis    This is the standard QI, with support for
//              IID_Unknown, IICW_Extension and IID_ICWApprentice
//              (stolen from Inside COM, chapter 7)
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
HRESULT CICWApprentice::QueryInterface( REFIID riid, void** ppv )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::QueryInterface");
    if (ppv == NULL)
        return(E_INVALIDARG);

    *ppv = NULL;

    // IID_IICWApprentice
    if (IID_IICW50Apprentice == riid)
        *ppv = (void *)(IICW50Apprentice *)this;
    // IID_IICW50Extension
    else if (IID_IICW50Extension == riid)
        *ppv = (void *)(IICW50Extension *)this;
    // IID_IUnknown
    else if (IID_IUnknown == riid)
        *ppv = (void *)this;
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN)*ppv)->AddRef();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::AddRef
//
//  Synopsis    This is the standard AddRef
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::AddRef( void )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice::AddRef %d", m_lRefCount + 1);
    return InterlockedIncrement(&m_lRefCount) ;
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::Release
//
//  Synopsis    This is the standard Release
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
ULONG CICWApprentice::Release( void )
{
    ASSERT( m_lRefCount > 0 );

    InterlockedDecrement(&m_lRefCount);

    TraceMsg(TF_APPRENTICE, "CICWApprentice::Release %d", m_lRefCount);
    if( 0 == m_lRefCount )
    {
        m_pIICW50Ext->Release();
        m_pIICW50Ext = NULL;

        delete( this );
        return( 0 );
    }
    else
    {
        return( m_lRefCount );
    }
}

//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::CICWApprentice
//
//  Synopsis    This is the constructor, nothing fancy
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWApprentice::CICWApprentice( void )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice constructor called");
    m_lRefCount = 0;
    m_pIICW50Ext = NULL;

}


//+----------------------------------------------------------------------------
//
//  Function    CICWApprentice::~CICWApprentice
//
//  Synopsis    This is the destructor.  We want to clean up all the memory
//              we allocated in ::Initialize
//
//  History     4/23/97 jmazner     created
//
//-----------------------------------------------------------------------------
CICWApprentice::~CICWApprentice( void )
{
    TraceMsg(TF_APPRENTICE, "CICWApprentice destructor called with ref count of %d", m_lRefCount);
    
    if( m_pIICW50Ext )
    {
        m_pIICW50Ext->Release();
        m_pIICW50Ext = NULL;
    }

    if( gpWizardState)
    {
        CleanupWizardState(gpWizardState);
        delete gpWizardState;
        gpWizardState = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ispasel.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPSEL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "exdisp.h"
#include "shldisp.h"
#include <htiframe.h>
#include <mshtml.h>

const TCHAR cszISPINFOPath[] = TEXT("download\\ispinfo.csv");
int  iNumOfAutoConfigOffers = 0;
BOOL g_bSkipSelPage = FALSE;


// Convert a supplied icon from it's GIF format to an ICO format

extern void ConvertISPIcon(LPTSTR lpszLogoPath, HICON* hIcon);
extern BOOL AddItemToISPList
(
    HWND        hListView,
    int         iItemIndex,
    LPTSTR      lpszIspName,
    int         iIspLogoIndex,
    BOOL        bCNS,
    LPARAM      lParam,
    BOOL        bFilterDupe
);
extern BOOL InitListView(HWND  hListView);
extern BOOL ResetListView(HWND  hListView);
extern BOOL CALLBACK ValidateISP(HWND hDlg);

/*******************************************************************

  NAME:    ParseISPInfo

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ParseISPInfo
(
    HWND hDlg, 
    TCHAR *pszCSVFileName,
    BOOL bCheckDupe
)
{
    // On the first init, we will read the ISPINFO.CSV file, and populate the ISP LISTVIEW

    CCSVFile    far *pcCSVFile;
    CISPCSV     far *pcISPCSV;
    BOOL        bRet = TRUE;
    BOOL        bHaveCNSOffer = FALSE;
    HICON       hISPLogo;
    int         iImage;
    HRESULT     hr;
                

    // Open and process the CSV file
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) 
    {
        // BUGBUG: Show Error Message
    
        return (FALSE);
    }            

    if (!pcCSVFile->Open(pszCSVFileName))
    {
        // BUGBUG: Show Error Message          
        AssertMsg(0,"Can not open ISPINFO.CSV file");
        delete pcCSVFile;
        pcCSVFile = NULL;
    
        return (FALSE);
    }

    // Read the first line, since it contains field headers
    pcISPCSV = new CISPCSV;
    if (!pcISPCSV)
    {
        // BUGBUG Show error message
        delete pcCSVFile;
        //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
        return (FALSE);
    }

    if (ERROR_SUCCESS != (hr = pcISPCSV->ReadFirstLine(pcCSVFile)))
    {
        // Handle the error case
        delete pcCSVFile;
        //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
        pcCSVFile = NULL;
    
        return (FALSE);
    }
    delete pcISPCSV;        // Don't need this one any more

    do {
        // Allocate a new ISP record
        pcISPCSV = new CISPCSV;
        if (!pcISPCSV)
        {
            // BUGBUG Show error message
            bRet = FALSE;
            //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
            break;
        
        }
    
        // Read a line from the ISPINFO file
        hr = pcISPCSV->ReadOneLine(pcCSVFile);
        if (hr == ERROR_SUCCESS)
        {
            // If this line contains a nooffer flag, then leave now
            if (!(pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OFFERS)) 
            {
                //iNumOfAutoConfigOffers = 0;
                break;
            }
            if ((pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_AUTOCONFIG) &&
                (gpWizardState->bISDNMode ? (pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_ISDN_OFFER) : TRUE) )
            {
                    // Convert the ISP logo from a GIF to an ICON, and add it to the Image List
                    ConvertISPIcon(pcISPCSV->get_szISPLogoPath(), &hISPLogo);   
                    iImage =  ImageList_AddIcon(gpWizardState->himlIspSelect, hISPLogo);
            
                    DestroyIcon(hISPLogo);
                    pcISPCSV->set_ISPLogoImageIndex(iImage);

                    // Add the entry to the list view
                    if (AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                      iNumOfAutoConfigOffers, 
                                      pcISPCSV->get_szISPName(), 
                                      pcISPCSV->get_ISPLogoIndex(),
                                      FALSE,
                                      (LPARAM)pcISPCSV,
                                      bCheckDupe))
                    {
                       ++iNumOfAutoConfigOffers;
                    }

            }
            else
            {
                delete pcISPCSV;
            }
        }
        else if (hr == ERROR_NO_MORE_ITEMS)
        {   
            delete pcISPCSV;        // We don't need this one
            break;
        }
        else if (hr == ERROR_FILE_NOT_FOUND) 
        {   
            // do not show this ISP when its data is invalid
            // we don't want to halt everything. Just let it contine
            delete pcISPCSV;
        }
        else
        {
            // Show error message Later
            delete pcISPCSV;
            //iNumOfAutoConfigOffers = ISP_INFO_NO_VALIDOFFER;
            bRet = FALSE;
            break;
        }           
    
    } while (TRUE);

    delete pcCSVFile;

    return bRet;
}
/*******************************************************************

  NAME:    ISPAutoSelectInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPAutoSelectInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        // Initialize the List View
        InitListView(GetDlgItem(hDlg, IDC_ISPLIST));
        gpWizardState->cmnStateData.bParseIspinfo = TRUE;
    }
    else
    {
        gpWizardState->bISDNMode = gpWizardState->cmnStateData.bIsISDNDevice;
        if (g_bSkipSelPage)
        {
            g_bSkipSelPage = FALSE;
            *puNextPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER;
        }
        if (gpWizardState->cmnStateData.bParseIspinfo)
        {
            // If there are items in the list view, clear them
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));

            // Initialize the number of autocfg offers to zero
            iNumOfAutoConfigOffers = 0;
            gpWizardState->lpSelectedISPInfo = NULL;

            // Always try to parse offline folder.  If there is nothing there, 
            // it will simple return FALSE.
            if (gpWizardState->cmnStateData.bOEMOffline)
                ParseISPInfo(hDlg, ICW_OEMINFOPath, TRUE);

            // Read and parse the download folder.
            ParseISPInfo(hDlg, ICW_ISPINFOPath, TRUE);

            // Create a "other" selection in the list view for unlisted ISPs
            if (iNumOfAutoConfigOffers > 0 )
            {
                // Adding Other
                TCHAR szOther  [MAX_RES_LEN+1] = TEXT("\0");
                LoadString(ghInstanceResDll, IDS_ISP_AUTOCONFIG_OTHER, szOther, ARRAYSIZE(szOther));
                AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                  iNumOfAutoConfigOffers, 
                                  szOther, 
                                  -1,
                                  FALSE,
                                  (LPARAM)NULL,
                                  FALSE);                         
                ResetListView(GetDlgItem(hDlg, IDC_ISPLIST));
            }
        }
        // The following 3 Cases can happen at this point:
        // 1) The ispinfo.csv contains a line says no offer, we go to nooffer page
        // 2) The ispinfo.csv contains no line of valid offer and no no-offer entry
        //    This may happen in calling the old referral.dll that ICW 3 client calls
        // 3) There are many offers but no ISDN offers, we go to ISDN offer pages
        // 4) Normal situation, some valid offers where we're in ISDN or not

        if (0 == iNumOfAutoConfigOffers)
        {
            *puNextPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER;
        }
        else if (ISP_INFO_NO_VALIDOFFER == iNumOfAutoConfigOffers)
        {
            // Error in ISPINFO.CSV if there is no offers and no no-offer entry
            // critical error
            *puNextPage = g_uExternUINext;
            gpWizardState->cmnStateData.bParseIspinfo = TRUE;
            return FALSE;
        }
        else
        {
            if (0 == ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_ISPLIST)))
            {
                // Select the First Item in the Listview
                ListView_SetItemState(GetDlgItem(hDlg, IDC_ISPLIST), 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
            }
        }
        
        gpWizardState->cmnStateData.bParseIspinfo = FALSE;
        gpWizardState->uCurrentPage = ORD_PAGE_ISP_AUTOCONFIG;

    }
    return TRUE;
}



/*******************************************************************

  NAME:    ISPAutoSelectOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPAutoSelectOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        if (gpWizardState->lpSelectedISPInfo == NULL)
        {
            *puNextPage = ORD_PAGE_ISP_AUTOCONFIG_NOOFFER; 
            return TRUE;
        }
        *puNextPage = ORD_PAGE_ISPDIAL;
    }
    return TRUE;
}


BOOL CALLBACK ISPAutoSelectNotifyProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CISPCSV     *pcISPCSV;

    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
            TraceMsg(TF_ISPSELECT, "ISPSELECT: WM_NOTIFY - NM_DBLCLK");
            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
            break;

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            break;

        case LVN_ITEMCHANGED:
            TraceMsg(TF_ISPSELECT, "ISPSELECT: WM_NOTIFY - LVN_ITEMCHANGED");

            if((((NM_LISTVIEW *)lParam)->uChanged & LVIF_STATE) &&
                ((NM_LISTVIEW *)lParam)->uNewState & (LVIS_FOCUSED | LVIS_SELECTED))
            {
                // IF an Item just became selected, then render it's HTML content
                pcISPCSV = (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;

                // Remember the selected item for later use
                gpWizardState->lpSelectedISPInfo = pcISPCSV;
            }
            break;
        // The listview is being emptied, or destroyed, either way, our lpSelectedISPInfo 
        // is no longer valid, since the list view underlying data will be freed.
        case LVN_DELETEALLITEMS:
            gpWizardState->lpSelectedISPInfo = NULL;
            SetPropSheetResult(hDlg,TRUE);
            break;
        
        case LVN_DELETEITEM:
            // We were notified that an item was deleted.
            // so delete the underlying data that it is pointing
            // to.
            if (((NM_LISTVIEW*)lParam)->lParam)
                delete  (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;
            break;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ispcsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"
#include "perhist.h"
#include "shlobj.h"

const VARIANT c_vaEmpty = {0};
const LARGE_INTEGER c_li0 = { 0, 0 };


CHAR szTempBuffer[TEMP_BUFFER_LENGTH];

#define ReadVerifyDW(x)     if (!ReadDW(&(x),pcCSVFile))                        \
                            {                                                   \
                                AssertMsg(0,"Invalid DWORD in CSV file");       \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyW(x)      if (!ReadW(&(x),pcCSVFile))                         \
                            {                                                   \
                                AssertMsg(0,"Invalid WORD in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
#define ReadVerifyWEx(x)    if (!ReadWEx(&(x),pcCSVFile))                       \
                            {                                                   \
                                AssertMsg(0,"Invalid WORD in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyB(x)      if (!ReadB(&(x),pcCSVFile))                         \
                            {                                                   \
                                AssertMsg(0,"Invalid BYTE in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifyBOOL(x)   if (!ReadBOOL(&(x),pcCSVFile))                      \
                            {                                                   \
                                AssertMsg(0,"Invalid BOOL in CSV file");        \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifySPECIAL(x, y, z) if (!ReadSPECIAL(&(x), &(y), &(z), pcCSVFile))   \
                            {                                                   \
                                AssertMsg(0,"Invalid SPECIAL in CSV file");     \
                                goto ReadOneLineError;                          \
                            }
#define ReadVerifySZ(x,y)   if (!ReadSZ(&x[0],y+sizeof('\0'),pcCSVFile))        \
                            {                                                   \
                                AssertMsg(0,"Invalid STRING in CSV file");      \
                                goto ReadOneLineError;                          \
                            }

CISPCSV::~CISPCSV(void)
{
    if(m_lpStgHistory)
    {
        // Release the storage
        m_lpStgHistory->Release();
        m_lpStgHistory = NULL;
    }
    
    if (hbmTierIcon)
        DeleteObject(hbmTierIcon);
    
    CleanupISPPageCache(TRUE);
}

// Do an strip of Single Quotes from a source string.  The source is formatted as:
// 'some text', and the dest string ends up being
// some text
void CISPCSV::StripQuotes
(
    LPSTR   lpszDst,
    LPSTR   lpszSrc
)
{
    //strcpy(lpszDst, lpszSrc + 1, strlen(lpszSrc) - 1);
    strcpy(lpszDst, lpszSrc + 1);
    lpszDst[strlen(lpszDst) - 1] = '\0';
}


BOOL CISPCSV::ValidateFile(TCHAR* pszFile)
{
    ASSERT(pszFile);
  
    if (!lstrlen(pszFile))
        return FALSE;

    if (GetFileAttributes(pszFile) == 0xFFFFFFFF)
        return FALSE;

    return TRUE;
}

// ############################################################################
BOOL CISPCSV::ReadDW(DWORD far *pdw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2Dw(szTempBuffer,pdw));
}

// ############################################################################
BOOL CISPCSV::ReadW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL CISPCSV::ReadWEx(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2WEx(szTempBuffer,pw));
}

// ############################################################################
BOOL CISPCSV::ReadB(BYTE far *pb, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2B(szTempBuffer,pb));
}

// ############################################################################
BOOL CISPCSV::ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2BOOL(szTempBuffer,pbool));
}

// ############################################################################
// A special int can be either a BOOL (TRUE,FALSE) or a int, 0 or -1
// if the value is 0 or -1, then the pbIsSpecial bool is set to TRUE
BOOL CISPCSV::ReadSPECIAL(BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2SPECIAL(szTempBuffer,pbool, pbIsSpecial, pInt));
}

// ############################################################################
BOOL CISPCSV::ReadSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CISPCSV::ReadToEOL(CCSVFile far *pcCSVFile)
{
    return pcCSVFile->SkipTillEOL();
}

HRESULT CISPCSV::ReadOneLine
(
    CCSVFile    far *pcCSVFile
)
{
    HRESULT     hr = ERROR_SUCCESS;
    CHAR    szTemp                [MAX_ISP_NAME];
    CHAR    szISPLogoPath         [MAX_PATH] = "\0";
    CHAR    szISPTierLogoPath     [MAX_PATH];
    CHAR    szISPTeaserPath       [MAX_PATH];
    CHAR    szISPMarketingHTMPath [MAX_PATH];
    CHAR    szISPFilePath         [MAX_PATH];
    CHAR    szISPName             [MAX_ISP_NAME];
    //CHAR    szCNSIconPath         [MAX_PATH];
    CHAR    szBillingFormPath     [MAX_PATH];
    CHAR    szPayCSVPath          [MAX_PATH];
    CHAR    szOfferGUID           [MAX_GUID];
    CHAR    szMir                 [MAX_ISP_NAME];

    if (!ReadSZ(szTemp, sizeof(szTemp), pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto ReadOneLineExit;
    }
    // Strip the single quotes from the isp Name
    StripQuotes(szISPName, szTemp);
    
    ReadVerifyW(wOfferID);   
    ReadVerifySZ(szISPLogoPath, sizeof(szISPLogoPath));
    ReadVerifySZ(szISPMarketingHTMPath, sizeof(szISPMarketingHTMPath));
    ReadVerifySZ(szISPTierLogoPath, sizeof(szISPTierLogoPath));
    ReadVerifySZ(szISPTeaserPath, sizeof(szISPTeaserPath));
    ReadVerifySZ(szISPFilePath, sizeof(szISPFilePath)); 
    ReadVerifyDW(dwCfgFlag);
    ReadVerifyDW(dwRequiredUserInputFlags);
    ReadVerifySZ(szBillingFormPath, sizeof(szBillingFormPath));
    ReadVerifySZ(szPayCSVPath, sizeof(szPayCSVPath));
    ReadVerifySZ(szOfferGUID, sizeof(szOfferGUID));
    ReadVerifySZ(szMir, sizeof(szMir));   
    ReadVerifyWEx(wLCID);   //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
    ReadToEOL(pcCSVFile);

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPName,              MAX_ISP_NAME,   m_szISPName,            MAX_ISP_NAME);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPLogoPath,          MAX_PATH,       m_szISPLogoPath,        MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPMarketingHTMPath,  MAX_PATH,       m_szISPMarketingHTMPath,MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPTierLogoPath,      MAX_PATH,       m_szISPTierLogoPath,    MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPTeaserPath,        MAX_PATH,       m_szISPTeaserPath,      MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szISPFilePath,          MAX_PATH,       m_szISPFilePath,        MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szBillingFormPath,      MAX_PATH,       m_szBillingFormPath,    MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szPayCSVPath,           MAX_PATH,       m_szPayCSVPath,         MAX_PATH);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szOfferGUID,            MAX_GUID,       m_szOfferGUID,          MAX_GUID);
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szMir,                  MAX_ISP_NAME,   m_szMir,                MAX_ISP_NAME);
#else

    lstrcpy(m_szISPName, szISPName);
    lstrcpy(m_szISPLogoPath, szISPLogoPath);
    lstrcpy(m_szISPMarketingHTMPath, szISPMarketingHTMPath);
    lstrcpy(m_szISPTierLogoPath, szISPTierLogoPath);
    lstrcpy(m_szISPTeaserPath, szISPTeaserPath);
    lstrcpy(m_szISPFilePath, szISPFilePath);
    lstrcpy(m_szBillingFormPath, szBillingFormPath);
    lstrcpy(m_szPayCSVPath, szPayCSVPath);
    lstrcpy(m_szOfferGUID, szOfferGUID);
    lstrcpy(m_szMir, szMir);
#endif


    bCNS = (ICW_CFGFLAG_CNS & dwCfgFlag) ? TRUE : FALSE;
    bSecureConnection = (ICW_CFGFLAG_SECURE & dwCfgFlag) ? TRUE : FALSE;

    //If this is nooffer we won't try to validate
    if (!(dwCfgFlag & ICW_CFGFLAG_OFFERS))
    {
        if (!ValidateFile(m_szISPMarketingHTMPath))
            hr = ERROR_FILE_NOT_FOUND;
        return hr;
    }

    if (!(dwCfgFlag & ICW_CFGFLAG_AUTOCONFIG))
    {
        if (!ValidateFile(m_szISPMarketingHTMPath))
            return ERROR_FILE_NOT_FOUND;
    }

    if (dwCfgFlag & ICW_CFGFLAG_OEM_SPECIAL)
    {
        if (!ValidateFile(m_szISPTierLogoPath) || !ValidateFile(m_szISPTeaserPath))
            dwCfgFlag &= ~ICW_CFGFLAG_OEM_SPECIAL ;
    }

    //Try and validate the integrity of various offers
    //based on type.

    //OLS, CNS, NO-CNS   
    if (!ValidateFile(m_szISPLogoPath))
        return ERROR_FILE_NOT_FOUND;
    if (!ValidateFile(m_szISPFilePath))
        return ERROR_FILE_NOT_FOUND;

    // Validate the billing path only when billing option is set
    if (dwCfgFlag & ICW_CFGFLAG_BILL)
    {
        if(!ValidateFile(m_szBillingFormPath))
            return ERROR_FILE_NOT_FOUND;
    }

    // Validate the payment path only when payment option is set
    if (dwCfgFlag & ICW_CFGFLAG_PAYMENT)
    {
        if(!ValidateFile(m_szPayCSVPath))
            return ERROR_FILE_NOT_FOUND;
    }        
ReadOneLineExit:
    return hr;
    
ReadOneLineError:
    hr = ERROR_INVALID_DATA;
    goto ReadOneLineExit;
}

HRESULT CISPCSV::ReadFirstLine
(
    CCSVFile    far *pcCSVFile
)
{
    CHAR   szTemp[TEMP_BUFFER_LENGTH];

    for (int i = 0; i < NUM_ISPCSV_FIELDS; i++)
    {
        if (!ReadSZ(szTemp, sizeof(szTemp), pcCSVFile))
        {
            return(ERROR_INVALID_DATA);
        }            
    }          
    ReadToEOL(pcCSVFile);
    return (ERROR_SUCCESS);
}

void CISPCSV::MakeCompleteURL(LPTSTR   lpszURL, LPTSTR  lpszSRC)    
{
    TCHAR   szCurrentDir[MAX_PATH] = TEXT("\0");

    // Form the URL
    GetCurrentDirectory(ARRAYSIZE(szCurrentDir), szCurrentDir);
    wsprintf (lpszURL, TEXT("FILE://%s\\%s"), szCurrentDir, lpszSRC);        

}

// Display this object's HTML page
HRESULT CISPCSV::DisplayHTML(LPTSTR szFile)
{    
    TCHAR           szURL[INTERNET_MAX_URL_LENGTH];
    HRESULT         hr;
            
    // Make the URL
    MakeCompleteURL(szURL, szFile);
    hr = gpWizardState->pICWWebView->DisplayHTML(szURL);

    return (hr);
}

//Takes RES ID
HRESULT CISPCSV::DisplayTextWithISPName
(
    HWND    hDlgCtrl, 
    int     iMsgString,
    TCHAR*  pszExtra    //sticks something on the very end of the string if needed.
)
{
    TCHAR   szFinal [MAX_MESSAGE_LEN*3] = TEXT("\0");
    TCHAR   szFmt   [MAX_MESSAGE_LEN];
    TCHAR   *args   [1];
    LPVOID  pszIntro = NULL;

    args[0] = (LPTSTR) m_szISPName;
    
    // BUGBUG should probably check for error return from LoadString
    LoadString(ghInstanceResDll, iMsgString, szFmt, ARRAYSIZE(szFmt));
                
    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                      szFmt, 
                      0, 
                      0, 
                      (LPTSTR)&pszIntro, 
                      0,
                      (va_list*)args))
    {
                  
        lstrcpy(szFinal, (LPTSTR)pszIntro);
        if (pszExtra)
            lstrcat(szFinal, pszExtra);
        
        SetWindowText(hDlgCtrl, szFinal);
    }

    if (pszIntro)
    {
        LocalFree(pszIntro);
    }

    return(S_OK);
}

#if 0
// Delete a Persisted History stream
HRESULT CISPCSV::DeleteHistory
(
    BSTR    bstrStreamName
)
{
    // No persistence if we don't have a storage object
    ASSERT(m_lpStgHistory);
    if (!m_lpStgHistory)
        return E_FAIL;

    // Delete the stream
    return (m_lpStgHistory->DestroyElement(bstrStreamName));
}
#endif

// Save the history of current lpBrowser using the provided name
HRESULT CISPCSV::SaveHistory
(
    BSTR bstrStreamName
)
{
    IStream         *lpStream;
    IPersistHistory *pHist;
    IWebBrowser2    *lpWebBrowser;
    HRESULT         hr = S_OK;
    
    // No persistence if we don't have a storage object
    ASSERT(m_lpStgHistory);
    if (!m_lpStgHistory)
        return E_FAIL;
            
    // Create a new Stream
    if (SUCCEEDED(hr = m_lpStgHistory->CreateStream(bstrStreamName, 
                                                    STGM_DIRECT | 
                                                    STGM_READWRITE | 
                                                    STGM_SHARE_EXCLUSIVE | 
                                                    STGM_CREATE,
                                                    0, 
                                                    0, 
                                                    &lpStream)))
    {
        // Get an IPersistHistory interface pointer on the current WebBrowser object
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        if ( SUCCEEDED(lpWebBrowser->QueryInterface(IID_IPersistHistory, (LPVOID*) &pHist)))
        {
            // Save the history
            pHist->SaveHistory(lpStream);
            pHist->Release();
            
            // Reset the stream pointer to the beginning
            lpStream->Seek(c_li0, STREAM_SEEK_SET, NULL);
        }
        lpStream->Release();
    }
    
    return (hr);
}

HRESULT CISPCSV::LoadHistory
(
    BSTR   bstrStreamName
)
{
    IStream         *lpStream;
    IPersistHistory *pHist;
    IWebBrowser2    *lpWebBrowser;
    HRESULT         hr = S_OK;
    
    // No persistence if we don't have a storage object
    ASSERT(m_lpStgHistory);
    if (!m_lpStgHistory)
        return E_FAIL;
        
    // Open the Stream
    if (SUCCEEDED(hr = m_lpStgHistory->OpenStream(bstrStreamName, 
                                                  NULL, 
                                                  STGM_DIRECT | 
                                                  STGM_READWRITE | 
                                                  STGM_SHARE_EXCLUSIVE,
                                                  0, 
                                                  &lpStream)))
    {
        // Get an IPersistHistory interface pointer on the current WebBrowser object
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        if ( SUCCEEDED(lpWebBrowser->QueryInterface(IID_IPersistHistory, (LPVOID*) &pHist)))
        {
            // Save the history
            pHist->LoadHistory(lpStream, NULL);
            pHist->Release();
            
            // Reset the stream pointer to the beginning
            lpStream->Seek(c_li0, STREAM_SEEK_SET, NULL);
        }
        lpStream->Release();
    }
    return (hr);
}


// This funtion will get the name of a ISP page cache filen from the page's ID
HRESULT CISPCSV::GetCacheFileNameFromPageID
(
    BSTR    bstrPageID,
    LPTSTR  lpszCacheFile,
    ULONG   cbszCacheFile
)
{
    HRESULT     hr = S_OK;
    IStream     *lpStream;
    ULONG       cbRead;
    
    if (!m_lpStgIspPages)
        return E_FAIL;
        
    // Open the stream
    if (SUCCEEDED(hr = m_lpStgIspPages->OpenStream(bstrPageID, 
                                                   NULL, 
                                                   STGM_DIRECT | 
                                                   STGM_READWRITE | 
                                                   STGM_SHARE_EXCLUSIVE,
                                                   0, 
                                                   &lpStream)))
    {
        // Read the file name
        lpStream->Read(lpszCacheFile, cbszCacheFile, &cbRead);
        
        // release the stream
        lpStream->Release();
    }   
    
    return hr;
}

// This function will cleanup the ISP Page cache.  This means deleting all temp files created
// and cleaning up the structured storage object used to store the file names
void CISPCSV::CleanupISPPageCache(BOOL bReleaseStorage)
{
    IEnumSTATSTG    *pEnum;
    STATSTG         StreamInfo;
    IMalloc         *pMalloc = NULL;
    
    // If we have a storage object already created, then enumerate the streams
    // in it, and free the underlying cache files.
    if (m_lpStgIspPages)
    {
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            if (SUCCEEDED(m_lpStgIspPages->EnumElements(0, NULL, 0, &pEnum)))
            {
                while(S_OK == pEnum->Next(1, &StreamInfo, NULL))
                {
                    if (StreamInfo.pwcsName)
                    {
                        TCHAR       szPath[MAX_PATH];
                        
                        if (SUCCEEDED(GetCacheFileNameFromPageID(StreamInfo.pwcsName,
                                                                 szPath,
                                                                 sizeof(szPath))))
                        {    
                            // delete the file
                            DeleteFile(szPath);

                            m_lpStgIspPages->DestroyElement(StreamInfo.pwcsName);
                            if(m_lpStgHistory)
                                m_lpStgHistory->DestroyElement(StreamInfo.pwcsName);
                            
                            // Free the memory allocated by the enumerator
                            pMalloc->Free (StreamInfo.pwcsName);
                        }   
                    }                        
                }
                // Release the enumerator
                pEnum->Release();
            }   
            // release the Shell Memory allocator
            pMalloc->Release ();
        }            
        
        if (bReleaseStorage)
        {
            // Release the storage
            m_lpStgIspPages->Release();
            m_lpStgIspPages= NULL;
        }            
    }
}

// This function will create a new page cache entry if necessary using the PageID as an
// index.  If an entry does not exists, and temp file will be create, then name stored,
// and the data in lpszTempFile will be copied into the new file.
// If the page already exists, this function will just return.
HRESULT CISPCSV::CopyFiletoISPPageCache
(
    BSTR    bstrPageID,
    LPTSTR  lpszTempFile
)
{
    HRESULT hr = S_OK;
    TCHAR   szTempPath[MAX_PATH];
    TCHAR   szISPCacheFile[MAX_PATH];
    IStream *lpStream;
    ULONG   cbWritten;
        
    if (!m_lpStgIspPages)
        return E_FAIL;
    
    if (SUCCEEDED(GetCacheFileNameFromPageID(bstrPageID,
                                             szISPCacheFile,
                                             sizeof(szISPCacheFile))))
    {
        // The pageID already has a file in the cache, so we can just return success
        return S_OK;
    }      

    if (!GetTempPath(ARRAYSIZE(szTempPath), szTempPath))
        return E_FAIL;
    
    // No file yet, so we have to create one
    if (!GetTempFileName(szTempPath, TEXT("ICW"), 0, szISPCacheFile))
        return E_FAIL;
        
    // Create a stream using the passed in page ID
    if (SUCCEEDED(hr = m_lpStgIspPages->CreateStream(bstrPageID, 
                                                     STGM_DIRECT | 
                                                     STGM_READWRITE | 
                                                     STGM_SHARE_EXCLUSIVE | 
                                                     STGM_CREATE,
                                                     0, 
                                                     0, 
                                                     &lpStream)))
    {
        // Write the file name to the stream, including the NULL terminator
#ifdef UNICODE
        DWORD dwSize = (lstrlen(szISPCacheFile)+1) * sizeof(TCHAR);
        if (SUCCEEDED(hr = lpStream->Write(szISPCacheFile, dwSize, &cbWritten)))
#else

        if (SUCCEEDED(hr = lpStream->Write(szISPCacheFile, lstrlen(szISPCacheFile)+1, &cbWritten)))
#endif
        {
            // Copy the passed in temp file
            if (!CopyFile(lpszTempFile, szISPCacheFile, FALSE))
                hr = E_FAIL;
        }
        // Release the stream
        lpStream->Release();
    }            
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\isdnnoff.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISDNNOFF.CPP - Functions for ISDN nooffer page
//

//  HISTORY:
//  
//  08/05/98    vyung     created
//
//*********************************************************************

#include "pre.h"

/*******************************************************************

  NAME:    ISDNNoofferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISDNNoofferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        TCHAR    szTemp[MAX_MESSAGE_LEN];

        LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER1, szTemp, MAX_MESSAGE_LEN);
        SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER1), szTemp);

        TCHAR*   pszPageIntro = new TCHAR[MAX_MESSAGE_LEN * 2];
        if (pszPageIntro)
        {
            LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER2, pszPageIntro, MAX_MESSAGE_LEN * 2);
            LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER3, szTemp, ARRAYSIZE(szTemp));
            lstrcat(pszPageIntro, szTemp);
            SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER2), pszPageIntro);
            delete [] pszPageIntro;
        }
        LoadString(ghInstanceResDll, IDS_ISDN_NOOFFER4, szTemp, MAX_MESSAGE_LEN);
        SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER3), szTemp);

    }

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_ISDN_NOOFFER;

    //Twiddle the buttons to do a finish page
    HWND hwndSheet = GetParent(hDlg);
    PropSheet_SetWizButtons(hwndSheet, PSWIZB_FINISH | PSWIZB_BACK);
    PropSheet_Changed(hDlg, hwndSheet);    
    
    return TRUE;
}


/*******************************************************************

  NAME:    ISDNNoofferOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ISDNNoofferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ispcsv.h ===
//**********************************************************************
// File name: ISPCSV.H
//
//      Definition of CISPCSV
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _ISPCSV_H_ )
#define _ISPCSV_H_

#define MAX_GUID            50
#define MAX_ISP_NAME        100
#define TEMP_BUFFER_LENGTH  1024

#define NUM_ISPCSV_FIELDS   14

class CISPCSV
{
    private:
        int     iISPLogoIndex;
        
        // The following members represent the content of a single line from the CSV file.

        int     iSpecialVal;                        // if bIsSpecial is TRUE, then 0 = NO Offers and -1 = OLS offer
        BOOL    bCNS;
        BOOL    bIsSpecial;                         // If true, then CNS value was "special"
        BOOL    bSecureConnection;
        WORD    wOfferID;
        DWORD   dwCfgFlag;
        DWORD   dwRequiredUserInputFlags;
        TCHAR   m_szISPLogoPath         [MAX_PATH];
        TCHAR   m_szISPTierLogoPath     [MAX_PATH];
        TCHAR   m_szISPTeaserPath       [MAX_PATH];
        TCHAR   m_szISPMarketingHTMPath [MAX_PATH];
        TCHAR   m_szISPFilePath         [MAX_PATH];
        TCHAR   m_szISPName             [MAX_ISP_NAME];
        TCHAR   m_szCNSIconPath         [MAX_PATH];
        TCHAR   m_szBillingFormPath     [MAX_PATH];
        TCHAR   m_szPayCSVPath          [MAX_PATH];
        TCHAR   m_szOfferGUID           [MAX_GUID];
        TCHAR   m_szMir                 [MAX_ISP_NAME];
        WORD    wLCID;
        HICON   hbmTierIcon;
        
        IStorage    *m_lpStgHistory;      // Pointer to stuctured storage object
                                          // for storing page history information
           
        IStorage    *m_lpStgIspPages;     // Pointer to stuctured storage object
                                          // that will be used to track the ISP page cache
                                                 
    public:

        CISPCSV(void) 
        {
            memset(this, 0, sizeof(CISPCSV));            
            
            // Allocate a temporary structured storage object
            StgCreateDocfile(NULL, 
                             STGM_DIRECT | 
                             STGM_READWRITE | 
                             STGM_SHARE_EXCLUSIVE | 
                             STGM_DELETEONRELEASE |
                             STGM_CREATE,
                             0, 
                             &m_lpStgHistory);
                             
            // Attempt to allocate a new storage object for the page cache
            StgCreateDocfile(NULL, 
                             STGM_DIRECT | 
                             STGM_READWRITE | 
                             STGM_SHARE_EXCLUSIVE | 
                             STGM_DELETEONRELEASE |
                             STGM_CREATE,
                             0, 
                             &m_lpStgIspPages);
        }
        
        ~CISPCSV(void);
         
        HRESULT ReadOneLine             (CCSVFile far *pcCSVFile);      
        HRESULT ReadFirstLine           (CCSVFile far *pcCSVFile);
        HRESULT DisplayHTML             (LPTSTR szFile);
        HRESULT DisplayTextWithISPName  (HWND hDlgCtrl, int iMsgString,  TCHAR* pszExtra);
        void    StripQuotes             (LPSTR   lpszDst, LPSTR   lpszSrc);
        BOOL    ReadDW                  (DWORD far *pdw, CCSVFile far *pcCSVFile);
        BOOL    ReadW                   (WORD far *pw, CCSVFile far *pcCSVFile);
        BOOL    ReadWEx                 (WORD far *pw, CCSVFile far *pcCSVFile); //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
        BOOL    ReadB                   (BYTE far *pb, CCSVFile far *pcCSVFile);
        BOOL    ReadBOOL                (BOOL far *pbool, CCSVFile far *pcCSVFile);
        BOOL    ReadSPECIAL             (BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt, CCSVFile far *pcCSVFile);
        BOOL    ReadSZ                  (LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
        BOOL    ReadToEOL               (CCSVFile far *pcCSVFile);
        BOOL    ValidateFile            (TCHAR* pszFile);
        void    MakeCompleteURL         (LPTSTR lpszURL, LPTSTR  lpszSRC);

        // Functions for managing IPersistHistory streams
        HRESULT SaveHistory(BSTR  bstrStreamName);
        HRESULT LoadHistory(BSTR  bstrStreamName);
        
//        HRESULT DeleteHistory(BSTR  bstrStreamName);
        
        // functions for managing the ISP Page cache
        HRESULT GetCacheFileNameFromPageID(BSTR bstrPageID, LPTSTR lpszCacheFile, ULONG cbszCacheFile);
        void    CleanupISPPageCache(BOOL bReleaseStorage);
        HRESULT CopyFiletoISPPageCache(BSTR bstrPageID, LPTSTR lpszTempFile);
        
        
        LPTSTR   get_szISPLogoPath(void)
        {
            return m_szISPLogoPath;
        }   

        LPTSTR   get_szISPTierLogoPath(void)
        {
            return m_szISPTierLogoPath;
        } 
        
        void set_ISPTierLogoIcon(HICON hIcon)
        {
            hbmTierIcon = hIcon;
        }   

        HICON get_ISPTierLogoIcon(void)
        {
            return hbmTierIcon;
        }   
      
        LPTSTR   get_szISPTeaserPath(void)
        {
            return m_szISPTeaserPath;
        } 

        LPTSTR   get_szISPMarketingHTMPath(void)
        {
            return m_szISPMarketingHTMPath;
        }   

        DWORD get_dwCFGFlag() 
        {
            return dwCfgFlag;
        }

        void set_dwCFGFlag(DWORD dwNewCfgFlag) 
        {
            dwCfgFlag = dwNewCfgFlag;
        }

        DWORD get_dwRequiredUserInputFlags() 
        {
            return dwRequiredUserInputFlags;
        }

        void set_dwRequiredUserInputFlags(DWORD dwFlags) 
        {
            dwRequiredUserInputFlags = dwFlags;
        }

        void set_szBillingFormPath(TCHAR* pszFile)
        {
            lstrcpy(m_szBillingFormPath, pszFile);
        }   
        
        LPTSTR   get_szBillingFormPath(void)
        {
            return m_szBillingFormPath;
        }   

        void set_ISPLogoImageIndex(int iImage)  
        {
            iISPLogoIndex = iImage;
        }

        void set_szISPName(TCHAR* pszName)
        {
            lstrcpy(m_szISPName, pszName);
        }
        
        LPTSTR   get_szISPName()
        {
            return m_szISPName;
        }
        
        int get_ISPLogoIndex()
        {
            return iISPLogoIndex;
        }
        
        void set_bCNS(BOOL bVal)
        {
            bCNS = bVal;
        }
        
        BOOL get_bCNS()
        {
            return bCNS;
        }

        void set_bIsSpecial(BOOL bVal) 
        {
            bIsSpecial = bVal;
        }
       
        
        BOOL get_bIsSpecial() 
        {
            return bIsSpecial;
        }
        
        int get_iSpecial()
        {
            return iSpecialVal;
        }
        
        void set_szPayCSVPath(TCHAR* pszFile)
        {
            lstrcpy(m_szPayCSVPath, pszFile);
        }            
        

        LPTSTR get_szPayCSVPath()
        {
            return m_szPayCSVPath;
        }            
        
         
        void set_szISPFilePath(TCHAR* pszFile)
        {
            lstrcpy(m_szISPFilePath, pszFile);
        }

        LPTSTR get_szISPFilePath()
        {
            return m_szISPFilePath;
        }
        
        LPTSTR get_szOfferGUID()
        {
            return m_szOfferGUID;
        }
        
        WORD    get_wOfferID()
        {
            return wOfferID;
        }

        LPTSTR  get_szMir()
        {
            return m_szMir;
        }

        WORD    get_wLCID()
        {
            return wLCID;
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\isppage.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPPAGE.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "shlobj.h"
#include "webvwids.h"

TCHAR   szHTMLFile[MAX_PATH]; //Name of html file
BOOL    bOKToPersist = TRUE;
DWORD   g_dwPageType = 0;
BOOL    g_bWebGateCheck = TRUE;
BOOL    g_bConnectionErr = FALSE;

//PROTOTYPES
BOOL SaveISPFile( HWND hwndParent, TCHAR* szSrcFileName, DWORD dwFileType);

#if defined (DBG)
BOOL HtmlSaveAs( HWND hwndParent, TCHAR* szFileName, TCHAR* szTargetFileName);
void AskSaveISPHTML(HWND hWnd, LPTSTR lpszHTMLFile)
{
    HKEY hKey = NULL;
    DWORD dwTemp = 0;
    DWORD dwType = 0;
    DWORD dwSize = sizeof(dwTemp);

    RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ISignup\\Debug"), &hKey);
    if (hKey)
    {
        RegQueryValueEx(hKey,TEXT("SaveIspHtmLocally"),0,&dwType,(LPBYTE)&dwTemp, &dwSize);
    
        if (dwTemp)
        {        
            if (IDYES == MessageBox(hWnd, TEXT("Would you like to save this ISP HTML file?"), TEXT("ICW -- DEBUG"), MB_YESNO | MB_ICONQUESTION | MB_APPLMODAL))
                HtmlSaveAs(hWnd, lpszHTMLFile, NULL);
        }
    }
}
#endif      // dbg

void  InitPageControls
(
    HWND hDlg, 
    DWORD dwPageType,
    DWORD dwPageFlag
)
{
    TCHAR    szTemp[MAX_MESSAGE_LEN];
    switch (dwPageType)    
    {
        // TOS, has the Accept, Don't Accept UI
        case PAGETYPE_ISP_TOS:
        {    
            // Show the TOS controls
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSINSTRT),     SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML),       SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),       SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),     SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),    SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_TOS_TOSSAVE),           SW_SHOW);
            //hide "normal weboc"
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_HTML),          SW_HIDE);
            //hide the save check box controls
            ShowWindow(GetDlgItem(hDlg, IDC_SAVE_DESKTOP_TEXT),     SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML),      SW_HIDE);
            // Reset the TOS page
            Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), BST_UNCHECKED);
            Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),BST_UNCHECKED);

            // Set tab focus
            SetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), GWL_STYLE, GetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),GWL_STYLE)|WS_TABSTOP);            
            EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),  TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),   TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),     TRUE);
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            break;
        }    
        
        // Finish, Custom Finish, and Normal are the same from a UI perspective (Also default)            
        case PAGETYPE_ISP_CUSTOMFINISH:
        case PAGETYPE_ISP_FINISH:
        case PAGETYPE_ISP_NORMAL:
        default:
        {
            BOOL bIsQuickFinish = FALSE;
            // Need to see if this is a Quick Finish page
            gpWizardState->pHTMLWalker->get_IsQuickFinish(&bIsQuickFinish);
        
            // Hide the TOS controls
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSINSTRT),     SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML),       SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),     SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE),    SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_TOS_TOSSAVE),           SW_HIDE);
    
            if (dwPageFlag & PAGEFLAG_SAVE_CHKBOX)
            {
                // Show check box controls 
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML),  SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_SAVE_DESKTOP_TEXT), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),   SW_SHOW);
                // Hide the normal controls
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_HTML),      SW_HIDE);
                //Reenable the UI
                EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE), TRUE);
            }
            else
            {
                //show "normal" web oc
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_HTML),      SW_SHOW);
                // Hide the Checkbox controls
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),   SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_SAVE_DESKTOP_TEXT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML),  SW_HIDE);
            }
            
            //set the wizard buttons
            // If we are on a Custom Finish, or Quick finish page then
            // use Active the Finish button
            PropSheet_SetWizButtons(GetParent(hDlg), 
                                   ((bIsQuickFinish || (PAGETYPE_ISP_CUSTOMFINISH == dwPageType)) ? PSWIZB_FINISH : PSWIZB_NEXT) | PSWIZB_BACK);
            break;
        }
    }

    // Change the title for the finish page
    if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
    {
        LoadString(ghInstanceResDll, IDS_STEP3_TITLE, szTemp, MAX_MESSAGE_LEN);
    }
    else
    {
        if((PAGETYPE_ISP_CUSTOMFINISH == dwPageType ) || (PAGETYPE_ISP_FINISH == dwPageType))
            LoadString(ghInstanceResDll, IDS_STEP3_TITLE, szTemp, MAX_MESSAGE_LEN);
        else
            LoadString(ghInstanceResDll, IDS_STEP2_TITLE, szTemp, MAX_MESSAGE_LEN);
    }
    PropSheet_SetHeaderTitle(GetParent(hDlg), EXE_NUM_WIZARD_PAGES + ORD_PAGE_ISPDATA, szTemp);
}    


HRESULT InitForPageType
(
    HWND    hDlg
)
{
    DWORD   dwPageType = 0;
    DWORD   dwPageFlag = 0;
    BOOL    bRetVal    = FALSE;
    HRESULT hRes       = E_FAIL;
    BSTR    bstrPageID = NULL;
    BSTR    bstrHTMLFile = NULL;
    
    //make sure these are disabled here incase getpagetype fails
    EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),  FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE),    FALSE);

    // Get webgate to dump the HTML into a file            
    gpWizardState->pWebGate->DumpBufferToFile(&bstrHTMLFile, &bRetVal);

    // Use the Walker to get the page type
    gpWizardState->pHTMLWalker->AttachToMSHTML(bstrHTMLFile);
    gpWizardState->pHTMLWalker->Walk();
    
    // Setup the controls based on the page type
    if (FAILED(hRes = gpWizardState->pHTMLWalker->get_PageType(&dwPageType)))
    {
        gpWizardState->pRefDial->DoHangup();
        g_bMalformedPage = TRUE; //used by server error to get correct msg
    }
    else
    {    
        if (dwPageType == PAGETYPE_ISP_TOS)
        {
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(NULL, NULL);
            }
            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML), PAGETYPE_ISP_TOS);
        }
        else        
        {
            RECT    rcHTML;
            HWND    hWndHTML;
            
            gpWizardState->pHTMLWalker->get_PageFlag(&dwPageFlag);
    
            if (dwPageFlag & PAGEFLAG_SAVE_CHKBOX) 
            {
                hWndHTML = GetDlgItem(hDlg, IDC_ISPDATA_CUSTHTML);
                // See if we need to display the app background bitmap in the HTML
                // window
                if(gpWizardState->cmnStateData.bOEMCustom)
                {
                    GetWindowRect(hWndHTML, &rcHTML);
                    MapWindowPoints(NULL, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcHTML, 2);
                    gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(gpWizardState->cmnStateData.hbmBkgrnd, &rcHTML);
                }
                gpWizardState->pICWWebView->ConnectToWindow(hWndHTML, PAGETYPE_ISP_NORMAL);
            }
            else
            {
                hWndHTML = GetDlgItem(hDlg, IDC_ISPDATA_HTML);
                // See if we need to display the app background bitmap in the HTML
                // window
                if(gpWizardState->cmnStateData.bOEMCustom)
                {
                    GetWindowRect(hWndHTML, &rcHTML);
                    MapWindowPoints(NULL, gpWizardState->cmnStateData.hWndApp, (LPPOINT)&rcHTML, 2);
                    gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(gpWizardState->cmnStateData.hbmBkgrnd, &rcHTML);
                }
                gpWizardState->pICWWebView->ConnectToWindow(hWndHTML, PAGETYPE_ISP_NORMAL);
            }
        }

        // Custom finish means that the ISP wants us to show some special text
        // and then finish the wizard
        if (dwPageType == PAGETYPE_ISP_CUSTOMFINISH)
        {
            BOOL bRetVal;
            
            // Show the page. no need to cache it    
            bOKToPersist = FALSE;
            lstrcpy(szHTMLFile, W2A(bstrHTMLFile));
            gpWizardState->pICWWebView->DisplayHTML(szHTMLFile);
            
            // Kill the idle timer and connection, since there are no more pages
            ASSERT(gpWizardState->pRefDial);
            
            KillIdleTimer();
            gpWizardState->pRefDial->DoHangup();
            gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
            gpWizardState->bDialExact = FALSE;
                
        }
        else
        {
            // In order to persist data entered by the user, we have to 
            // effectivly "cache" the pages, so that when the user goes back
            // we make MSHTML think that we are loading a page that it has seen
            // before, and it will then reload the persisted history.
            
            // This will be done by using the PAGEID value in the HTML to form a
            // temp file name, so that we can re-load the page date from that file
            // each time we see the same page ID value.
            
            // Get the Page ID.
            gpWizardState->pHTMLWalker->get_PageID(&bstrPageID);
            if (bOKToPersist && SUCCEEDED( gpWizardState->lpSelectedISPInfo->CopyFiletoISPPageCache(bstrPageID, W2A(bstrHTMLFile))))
            {
                // We have a "cache" file, so we can use it and persist data
                // Get the cache file name now, since we will need it later
                gpWizardState->lpSelectedISPInfo->GetCacheFileNameFromPageID(bstrPageID, szHTMLFile, sizeof(szHTMLFile));
            }        
            else
            {
                bOKToPersist = FALSE;
                lstrcpy(szHTMLFile, W2A(bstrHTMLFile));
            }
            
            // Display the page we just "cached"
            gpWizardState->pICWWebView->DisplayHTML(szHTMLFile);
            
            if (bOKToPersist)
            {
                // Restore any persisted data on this page.
                gpWizardState->lpSelectedISPInfo->LoadHistory(bstrPageID);
            }
            
            // Cleanup
            SysFreeString(bstrPageID);
        }
        
#if defined(DBG)
        AskSaveISPHTML(hDlg, szHTMLFile);
#endif

        InitPageControls(hDlg, dwPageType, dwPageFlag);
        g_dwPageType = dwPageType;
    }                                                
    // Detach the walker
    gpWizardState->pHTMLWalker->Detach();

    HideProgressAnimation();
    
    SysFreeString(bstrHTMLFile);
    
    return hRes;
}


/*******************************************************************

  NAME:    ISPPageInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPPageInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (fFirstInit)
    {
        // Setup an Event Handler for RefDial and Webgate
        CINSHandlerEvent *pINSHandlerEvent;
        pINSHandlerEvent = new CINSHandlerEvent(hDlg);
        if (NULL != pINSHandlerEvent)
        {
            HRESULT hr;
            gpWizardState->pINSHandlerEvents = pINSHandlerEvent;
            gpWizardState->pINSHandlerEvents->AddRef();
    
            hr = ConnectToConnectionPoint((IUnknown *)gpWizardState->pINSHandlerEvents, 
                                            DIID__INSHandlerEvents,
                                            TRUE,
                                            (IUnknown *)gpWizardState->pINSHandler, 
                                            &gpWizardState->pINSHandlerEvents->m_dwCookie, 
                                            NULL);     
        }    
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else
    {      

        if (FAILED(InitForPageType(hDlg)))    
        {
            //The page type isn't recognized which means there's a problem
            //with the data. goto the serverr page
            gpWizardState->pRefDial->DoHangup();
            *puNextPage = ORD_PAGE_SERVERR;
        }
        
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISPDATA;
    }
    return TRUE;
}


// Returns FALSE if we should stay on this page, TRUE if we should change pages
// the param bError indicates we should proceed to the server Error Page.
BOOL ProcessNextBackPage
(
    HWND    hDlg,
    BOOL    fForward,
    BOOL    *pfError
)
{           
    BOOL    bRet = FALSE;
    TCHAR   szURL[2*INTERNET_MAX_URL_LENGTH + 1] = TEXT("\0");
    
    *pfError = FALSE;
    
    gpWizardState->pHTMLWalker->get_URL(szURL, fForward);
         
    // See if a URL is Specified        
    if (lstrcmp(szURL, TEXT("")) == 0)
    {
        //Stop the animation
        HideProgressAnimation();
    
        //Reenable the UI
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
        
        // If forward, we want to force our way to the server error page,
        // since we cannot go forward to a blank URL
        if (fForward)
        {
            KillIdleTimer();
            gpWizardState->pRefDial->DoHangup();
            *pfError = TRUE;
        }
        else
        {
            // We are backing out of ISP page land, so lets hangup.
            if(gpWizardState->pRefDial)
            {
                BOOL bRetVal;
                KillIdleTimer();
                gpWizardState->pRefDial->DoHangup();
                gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
                gpWizardState->bDialExact = FALSE;
            }                
        }
        // We will need to navigate away from the ISP page
        bRet = TRUE;
    }
    else
    {
        
        BOOL    bRetWebGate;
        BOOL    bConnected = FALSE;
        g_bWebGateCheck = TRUE;
        g_bConnectionErr = FALSE;
        
        // Do not go to the next page. Also valid for the cancel case
        bRet = FALSE;
    
        // Kill the idle Timer
        KillIdleTimer();
        
        // Tell webgate to go fetch the page
        gpWizardState->pWebGate->put_Path(A2W(szURL));
        gpWizardState->pWebGate->FetchPage(0,0,&bRetWebGate);
    
        //This flag is only to be used by ICWDEBUG.EXE
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
            bConnected = TRUE;
        else
            gpWizardState->pRefDial->get_RasGetConnectStatus(&bConnected);
        
        if (bConnected)
        {
            WaitForEvent(gpWizardState->hEventWebGateDone);
        }
        else
        {
            g_bConnectionErr = TRUE;
        }
        // See if the user canceled.  If so we want to force the wizard to bail.
        // this can be hacked by forcing the return value to be FALSE and
        // setting the gfQuitWizard flag to TRUE. Gendlg will check this flag
        // when the OK proc returns, and process appropriatly
        if (!gfUserCancelled)
        {
            if (g_bConnectionErr)
            {
                // Make it go to server error page
                bRet = TRUE;
                *pfError = TRUE;
            }
            else
            {

                // Restart the Idle Timer
                StartIdleTimer();
            
                // detach the walker, since Init for page type needs it
                gpWizardState->pHTMLWalker->Detach();
            
                // Setup for this page
                if (FAILED(InitForPageType(hDlg)))    
                {
                    //The page type isn't recognized which means there's a problem
                    //with the data. goto the serverr page
                    *pfError = TRUE;
                     bRet    = TRUE;
                }
            }

        }
        else
        {
            // Force the wizard to quit, since the user canceled
            gfQuitWizard = TRUE;
        }                    
    }
    
    return bRet;
}    
/*******************************************************************

  NAME:    ISPPageOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPPageOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    DWORD           dwPageType;
    TCHAR           szURL[2*INTERNET_MAX_URL_LENGTH + 1] = TEXT("\0");
    BOOL            bRetVal = TRUE;
    BSTR            bstrPageID = NULL;
    IWebBrowser2    *lpWebBrowser;

    // We don't want to keep any of the ISP pages in the history list
    *pfKeepHistory = FALSE;
    
    // If we are going forward, and if the user has been autodisconnected, then
    // we want to automatically navigate to the server error page.
    if (fForward && gpWizardState->bAutoDisconnected)
    {
        gpWizardState->bAutoDisconnected = FALSE;
        *puNextPage = ORD_PAGE_SERVERR;
        return TRUE;
    }
    
    // Attach the walker to the curent page to get the page type
    gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
    gpWizardState->pHTMLWalker->AttachToDocument(lpWebBrowser);
    gpWizardState->pHTMLWalker->Walk();
    gpWizardState->pHTMLWalker->get_PageType(&dwPageType);
    
    // Custom finish means we just exit, so we just need to return TRUE
    if (PAGETYPE_ISP_CUSTOMFINISH == dwPageType)
    {
        gpWizardState->pHTMLWalker->Detach();
        return TRUE;
    }
    
    // Check the TOS settings. If the users decline, don't allow them to proceed
    if (IsWindowVisible(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE)) )
    {
        if (fForward)
        {
            if (Button_GetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE)))
            {
                if (MsgBox(hDlg,IDS_ERR_TOS_DECLINE,MB_ICONSTOP,MB_OKCANCEL) != IDOK)
                {
                    gfQuitWizard = TRUE;
                }
                Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), 0);
                Button_SetCheck(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE), 0);
                // Set tab focus
                SetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), GWL_STYLE, GetWindowLong(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT),GWL_STYLE)|WS_TABSTOP);            
                SetFocus(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML));
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                return FALSE;
            }
        }
        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSDECLINE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSACCEPT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE), FALSE);
    }    


    //Show the progress animation 
    ShowProgressAnimation();
    
    //Disable the UI
    PropSheet_SetWizButtons(GetParent(hDlg), 0);

    if (bOKToPersist)
    {
        // Persist any data on this page.
        gpWizardState->pHTMLWalker->get_PageID(&bstrPageID);
        gpWizardState->lpSelectedISPInfo->SaveHistory(bstrPageID);
        SysFreeString(bstrPageID);
    }
    
    // User going back?
    if (fForward)
    {
        // Depending on the page type, we do different things
        switch (dwPageType)    
        {
            // The finish page types, mean that what we fetch next is an INS file
            case PAGETYPE_ISP_FINISH:
            {
                BSTR    bstrINSFile;
                BSTR    bstrStartURL;
                BOOL    bRet;
                BOOL    bIsQuickFinish = FALSE;
                long    lBrandingFlags;
            
                gpWizardState->pHTMLWalker->get_URL(szURL, TRUE);
            
                // Kill the idle timer
                KillIdleTimer();
            
                gpWizardState->pHTMLWalker->get_IsQuickFinish(&bIsQuickFinish);
                
                if(!bIsQuickFinish)
                {
                    BOOL bConnected = FALSE;
                    g_bWebGateCheck = TRUE;
                    g_bConnectionErr = FALSE;

                    // Tell webgate to go fetch the page
                    gpWizardState->pWebGate->put_Path(A2W(szURL));
                    gpWizardState->pWebGate->FetchPage(1,0,&bRet);
        
                    //This flag is only to be used by ICWDEBUG.EXE
                    if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                        bConnected = TRUE;
                    else
                        // Check for connection status before proceed
                        gpWizardState->pRefDial->get_RasGetConnectStatus(&bConnected);
                    
                    if (bConnected)
                    {
                        WaitForEvent(gpWizardState->hEventWebGateDone);
                    }
                    else
                    {
                        bConnected = TRUE;
                    }

                    if (g_bConnectionErr)
                    {
                        gpWizardState->pRefDial->DoHangup();
                        *puNextPage = ORD_PAGE_SERVERR;
                        break;
                    }
            
                    // Can't allow the user to cancel now
                    PropSheet_CancelToClose(GetParent(hDlg));       
                    PropSheet_SetWizButtons(GetParent(hDlg),0);
                    UpdateWindow(GetParent(hDlg));
                
                     //Stop the animation
                     HideProgressAnimation();

                    // See if the user canceled while downloading the INS file
                    if (!gfUserCancelled)
                    {   
                        // OK process the INS file.
                        gpWizardState->pWebGate->get_DownloadFname(&bstrINSFile);
                
                        // Get the Branding flags
                        gpWizardState->pRefDial->get_BrandingFlags(&lBrandingFlags);
                
                        // Tell the INSHandler about the branding flags
                        gpWizardState->pINSHandler->put_BrandingFlags(lBrandingFlags);

                        // Process the inf file.
                        gpWizardState->pINSHandler->ProcessINS(bstrINSFile, &bRet);

                        //hang on to whether or not this failed.
                        gpWizardState->cmnStateData.ispInfo.bFailedIns = !bRet;

                        // Get the Start URL from INS file.
                        gpWizardState->pINSHandler->get_DefaultURL(&bstrStartURL);
                        lstrcpy(gpWizardState->cmnStateData.ispInfo.szStartURL, 
                                 W2A(bstrStartURL));
                    
                        // Time to retun to the main wizard
                        *puNextPage = g_uExternUINext;
                
                        // Detach the walker before we go
                        gpWizardState->pHTMLWalker->Detach();
                
                        //Copy over the isp name and support number for the last page.
                        lstrcpy(gpWizardState->cmnStateData.ispInfo.szISPName, 
                                 gpWizardState->lpSelectedISPInfo->get_szISPName());
                    
                        BSTR bstrSupportPhoneNum;
                        gpWizardState->pRefDial->get_ISPSupportNumber(&bstrSupportPhoneNum);
                    
                        lstrcpy(gpWizardState->cmnStateData.ispInfo.szSupportNumber, 
                                 W2A(bstrSupportPhoneNum));
                             
                    }
                    else
                    {
                        // The user canceled while we were donwloading the INS, so lets bail
                        gpWizardState->pHTMLWalker->Detach();
                        gfQuitWizard = TRUE;
                        bRetVal = FALSE;
                    } 
                }
                else
                    HideProgressAnimation();

                // Let the wizard Continue/Finish
                break;
            }
           
            // These page types mean that we need to form a new URL, and get the next page
            case PAGETYPE_ISP_TOS:
            case PAGETYPE_ISP_NORMAL:
            {
                BOOL    bError;
                
                bRetVal = ProcessNextBackPage(hDlg, TRUE, &bError);
                
                if (bError)
                {
                    // Go to the server error page
                    gpWizardState->pRefDial->DoHangup();
                    *puNextPage = ORD_PAGE_SERVERR;
                }
                break;
            }
            default:
            {
                //Stop the animation
                HideProgressAnimation();

                gpWizardState->pRefDial->DoHangup();
                // Goto the server error page, since we surely did not recognize this page type
                *puNextPage = ORD_PAGE_SERVERR;
                break;        
            }
        }            
    }
    else
    {
        // Going Backwards.
        BOOL    bError;
                
        bRetVal = ProcessNextBackPage(hDlg, FALSE, &bError);
                
        if (bError)
        {
            // Go to the server error page
            *puNextPage = ORD_PAGE_SERVERR;
        }
    }
    
    return bRetVal;
}

/*******************************************************************

  NAME:    ISPCmdProc

********************************************************************/
BOOL CALLBACK ISPCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_CLICKED:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_ISPDATA_TOSACCEPT: 
                case IDC_ISPDATA_TOSDECLINE:
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
                    break;
                }
                case IDC_ISPDATA_TOSSAVE:
                {
                    if  (SaveISPFile(hDlg, szHTMLFile, g_dwPageType))
                    {        
                        SetFocus(GetDlgItem(hDlg, IDC_ISPDATA_TOSHTML));
                        EnableWindow(GetDlgItem(hDlg, IDC_ISPDATA_TOSSAVE), FALSE);
                    }
                    break;
                }
                default:
                    break;
            }
            break;
        }
        case BN_DBLCLK:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_ISPDATA_TOSACCEPT: 
                case IDC_ISPDATA_TOSDECLINE:
                {
                    // somebody double-clicked a radio button
                    // auto-advance to the next page
                    PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                    break;
                }
                default:
                    break;
            }
            break;
        }
        case BN_SETFOCUS:
        {
            if ((GET_WM_COMMAND_ID(wParam, lParam) == IDC_ISPDATA_TOSACCEPT) )
            {
                CheckDlgButton(hDlg, IDC_ISPDATA_TOSACCEPT, BST_CHECKED);

                // Uncheck the decline checkbox make sure no two radio button
                // selected at the same time.
                CheckDlgButton(hDlg, IDC_ISPDATA_TOSDECLINE, BST_UNCHECKED);
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            }
            break;
        }
        default:
            break;
    }
    return 1;
}



/*******************************************************************

  NAME:     DisplayConfirmationDialog

  SYNOPSIS: Display a confirmation dialog for the file being written

  ENTRY:    hwndParent - dialog window
            dwFileType - current isp page type
            szFileName - source file name

  EXIT:     returns TRUE when save successfully; FALSE otherwise.

********************************************************************/
BOOL DisplayConfirmationDialog(HWND hwndParent, DWORD dwFileType, TCHAR* szFileName)
{
    TCHAR   szFinal [MAX_MESSAGE_LEN] = TEXT("\0");
    TCHAR   szFmt   [MAX_MESSAGE_LEN];
    TCHAR   *args   [1];
    LPVOID  pszIntro;
    BOOL    bRet = TRUE;
    UINT    uMsgID;

    args[0] = (LPTSTR) szFileName;
    
    if (PAGETYPE_ISP_TOS == dwFileType)
    {
        uMsgID = IDS_SAVE_COPY_CONFIRM_MSG;
    }
    else 
    {
        uMsgID = IDS_SAVE_ISP_CONFIRM_MSG;
    }

    LoadString(ghInstanceResDll, uMsgID, szFmt, ARRAYSIZE(szFmt));
                
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                  szFmt, 
                  0, 
                  0, 
                  (LPTSTR)&pszIntro, 
                  0,
                  (va_list*)args);
                  
    lstrcpy(szFinal, (LPTSTR)pszIntro);
        
    LoadString(ghInstanceResDll, IDS_APPNAME, szFmt, ARRAYSIZE(szFmt));

    MessageBox(hwndParent, szFinal, szFmt, MB_OK | MB_ICONINFORMATION | MB_APPLMODAL);

    LocalFree(pszIntro);
    
    return(bRet);
}



/*******************************************************************

  NAME:     SaveISPFile

  SYNOPSIS: Called want to save html file to desktop without dialog

  ENTRY:    hwndParent - dialog window
            szSrcFileName - source file name
            uFileType - Type of files embedded in the htm file

  EXIT:     returns TRUE when save successfully; FALSE otherwise.

********************************************************************/
BOOL SaveISPFile( HWND hwndParent, TCHAR* szSrcFileName, DWORD dwFileType)
{
    
    TCHAR         szNewFileBuff [MAX_PATH + 1];
    TCHAR         szWorkingDir  [MAX_PATH + 1];     
    TCHAR         szDesktopPath [MAX_PATH + 1];     
    TCHAR         szLocalFile   [MAX_PATH + 1];   
    TCHAR         szISPName     [MAX_ISP_NAME + 1];  
    TCHAR         szFmt         [MAX_MESSAGE_LEN];
    TCHAR         szNumber      [MAX_MESSAGE_LEN];
    TCHAR         *args         [2];
    DWORD         dwFileFormatOrig;
    DWORD         dwFileFormatCopy;
    LPTSTR        pszInvalideChars             = TEXT("\\/:*?\"<>|");
    LPVOID        pszIntro                     = NULL;
    LPITEMIDLIST  lpItemDList                  = NULL;
    HRESULT       hr                           = E_FAIL; //don't assume success
    IMalloc      *pMalloc                      = NULL;
    BOOL          ret                          = FALSE;
    
    ASSERT(hwndParent);
    ASSERT(szFileName);

    // Validate page type, return false if page type is unknown
    if (PAGETYPE_ISP_TOS == dwFileType)
    {
        dwFileFormatOrig = IDS_TERMS_FILENAME;
        dwFileFormatCopy = IDS_TERMS_FILENAME_COPY;
    }
    else if ((PAGETYPE_ISP_CUSTOMFINISH == dwFileType) ||
          (PAGETYPE_ISP_FINISH == dwFileType) ||
          (PAGETYPE_ISP_NORMAL == dwFileType))
    {
        dwFileFormatOrig = IDS_ISPINFO_FILENAME;
        dwFileFormatCopy = IDS_ISPINFO_FILENAME_COPY;
    }
    else
    {
        return FALSE;
    }

    GetCurrentDirectory(ARRAYSIZE(szWorkingDir), szWorkingDir);
    
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList);
 
    //Get the "DESKTOP" dir 
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))  
    {
        SHGetPathFromIDList(lpItemDList, szDesktopPath);
        
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }


    // Replace invalid file name char in ISP name with underscore
    lstrcpy(szISPName, gpWizardState->lpSelectedISPInfo->get_szISPName());
    for( int i = 0; szISPName[i]; i++ )
    {
        if(_tcschr(pszInvalideChars, szISPName[i])) 
        {
            szISPName[i] = '_';
        }
    }

    // Load the default file name
    args[0] = (LPTSTR) szISPName;
    args[1] = NULL;
    LoadString(ghInstanceResDll, dwFileFormatOrig, szFmt, ARRAYSIZE(szFmt));
        
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                  szFmt, 
                  0, 
                  0, 
                  (LPTSTR)&pszIntro, 
                  0,
                  (va_list*)args);

    lstrcat(szDesktopPath, TEXT("\\"));
    wsprintf(szLocalFile, TEXT("\"%s\""), (LPTSTR)pszIntro);
    lstrcpy(szNewFileBuff, szDesktopPath);
    lstrcat(szNewFileBuff, (LPTSTR)pszIntro);
    LocalFree(pszIntro);

    // Check if file already exists
    if (0xFFFFFFFF != GetFileAttributes(szNewFileBuff))
    {
        // If file exists, create new filename with paranthesis
        int     nCurr = 1;
        do
        {
            wsprintf(szNumber, TEXT("%d"), nCurr++);
            args[1] = (LPTSTR) szNumber;

            LoadString(ghInstanceResDll, dwFileFormatCopy, szFmt, ARRAYSIZE(szFmt));
                
            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                          szFmt, 
                          0, 
                          0, 
                          (LPTSTR)&pszIntro, 
                          0,
                          (va_list*)args);
            lstrcpy(szNewFileBuff, szDesktopPath);
            wsprintf(szLocalFile, TEXT("\"%s\""), (LPTSTR)pszIntro);
            lstrcat(szNewFileBuff, (LPTSTR)pszIntro);
            LocalFree(pszIntro);
        } while ((0xFFFFFFFF != GetFileAttributes(szNewFileBuff)) && (nCurr <= 100));

    }

    // Copy the file to permanent location
    HANDLE hFile = CreateFile(szNewFileBuff, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        IICWWalker* pHTMLWalker = NULL;
        BSTR bstrText           = NULL;
        DWORD dwByte            = 0;

        if (SUCCEEDED(CoCreateInstance(CLSID_ICWWALKER,NULL,CLSCTX_INPROC_SERVER,
                                       IID_IICWWalker,(LPVOID*)&pHTMLWalker)))
        {
            pHTMLWalker->InitForMSHTML();
            pHTMLWalker->AttachToMSHTML(A2W(szSrcFileName));
            if (SUCCEEDED(pHTMLWalker->ExtractUnHiddenText(&bstrText)) && bstrText)
            {
                #ifdef UNICODE
                BYTE UNICODE_BYTE_ORDER_MARK[] = {0xFF, 0xFE};
                WriteFile(hFile, 
                          UNICODE_BYTE_ORDER_MARK,
                          sizeof(UNICODE_BYTE_ORDER_MARK),
                          &dwByte,
                          NULL);
                #endif
                ret = WriteFile(hFile, W2A(bstrText), lstrlen(W2A(bstrText))* sizeof(TCHAR), &dwByte, NULL);  
                SysFreeString(bstrText);
            }
            pHTMLWalker->TermForMSHTML();
            pHTMLWalker->Release();
        }
        CloseHandle(hFile);
    
    }

    // Display message according to the state of CopyFile
    if (!ret)
    {
        DeleteFile(szNewFileBuff);

        //let the user know there was not enough disk space
        TCHAR szTemp    [MAX_RES_LEN] = TEXT("\0"); 
        TCHAR szCaption [MAX_RES_LEN] = TEXT("\0"); 

        LoadString(ghInstanceResDll, IDS_NOT_ENOUGH_DISKSPACE, szTemp, ARRAYSIZE(szTemp));
        LoadString(ghInstanceResDll, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption));
        MessageBox(hwndParent, szTemp, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
    }
    else
    {
        // Display the confirmation
        DisplayConfirmationDialog(hwndParent, dwFileType, szLocalFile);
    }

    return ret;
}

#if defined (DBG)
BOOL HtmlSaveAs( HWND hwndParent, TCHAR* szFileName, TCHAR* szTargetFileName)
{
    ASSERT(hwndParent);
    ASSERT(szFileName);
    
    OPENFILENAME  ofn;                                              
    TCHAR         szNewFileBuff [MAX_PATH + 1];
    TCHAR         szDesktopPath [MAX_PATH + 1] = TEXT("\0");     
    TCHAR         szWorkingDir  [MAX_PATH + 1] = TEXT("\0");     
    TCHAR         szFilter      [255]          = TEXT("\0");
    LPITEMIDLIST  lpItemDList                  = NULL;
    HRESULT       hr                           = E_FAIL; //don't assume success
    IMalloc      *pMalloc                      = NULL;
    BOOL          ret = TRUE;
    
    GetCurrentDirectory(ARRAYSIZE(szWorkingDir), szWorkingDir);
    
    hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP,&lpItemDList);
 
    //Get the "DESKTOP" dir 
       ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))  
    {
        SHGetPathFromIDList(lpItemDList, szDesktopPath);
        
        // Free up the memory allocated for LPITEMIDLIST
        if (SUCCEEDED (SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }

    if (szTargetFileName != NULL)
    {
        lstrcpy(szNewFileBuff, szDesktopPath);
        lstrcat(szNewFileBuff, TEXT("\\"));
        lstrcat(szNewFileBuff, szTargetFileName);
       
        // Copy temporary file to permanent location
        ret = CopyFile(szFileName, szNewFileBuff, FALSE);
    }
    else
    {
        //Setup the filter
        LoadString(ghInstanceResDll, IDS_DEFAULT_TOS_FILTER, szFilter, ARRAYSIZE(szFilter)); // "HTML Files"
        
        //Setup the default file name
        if(!LoadString(ghInstanceResDll, IDS_DEFAULT_TOS_FILENAME, szNewFileBuff, ARRAYSIZE(szNewFileBuff))) // "terms"
            lstrcpy(szNewFileBuff, TEXT("terms"));
        lstrcat(szNewFileBuff, TEXT(".htm"));

        //init the filename struct
        ofn.lStructSize       = sizeof(OPENFILENAME); 
        ofn.hwndOwner         = hwndParent; 
        ofn.lpstrFilter       = szFilter; 
        ofn.lpstrFile         = szNewFileBuff;  
        ofn.nMaxFile          = sizeof(szNewFileBuff); 
        ofn.lpstrFileTitle    = NULL; 
        ofn.lpstrInitialDir   = szDesktopPath; 
        ofn.lpstrTitle        = NULL;
        ofn.lpstrCustomFilter = (LPTSTR) NULL;
        ofn.nMaxCustFilter    = 0L;
        ofn.nFileOffset       = 0;
        ofn.nFileExtension    = 0;
        ofn.lpstrDefExt       = TEXT("*.htm");
        ofn.lCustData         = 0;
        ofn.nFilterIndex      = 1L;
        ofn.nMaxFileTitle     = 0;
        ofn.Flags             = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY |
                                OFN_EXPLORER      | OFN_LONGNAMES | OFN_OVERWRITEPROMPT;  
   
        //Call the SaveAs common dlg
        if(TRUE == GetSaveFileName(&ofn))
        {
            HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                IICWWalker* pHTMLWalker = NULL;
                BSTR bstrText           = NULL;
                DWORD dwByte            = 0;

                if (SUCCEEDED(CoCreateInstance(CLSID_ICWWALKER,NULL,CLSCTX_INPROC_SERVER,
                                               IID_IICWWalker,(LPVOID*)&pHTMLWalker)))
                {
                    pHTMLWalker->InitForMSHTML();
                    pHTMLWalker->AttachToMSHTML(A2W(szFileName));
                    if (SUCCEEDED(pHTMLWalker->ExtractUnHiddenText(&bstrText)) && bstrText)
                    {
                        ret = WriteFile(hFile, W2A(bstrText), lstrlen(W2A(bstrText)), &dwByte, NULL);  
                        SysFreeString(bstrText);
                    }
                    pHTMLWalker->TermForMSHTML();
                    pHTMLWalker->Release();
                }
                CloseHandle(hFile);
            
            }
            if (!ret)
            {
                DeleteFile(ofn.lpstrFile);

                //let the user know there was not enough disk space
                TCHAR szTemp    [MAX_RES_LEN] = TEXT("\0"); 
                TCHAR szCaption [MAX_RES_LEN] = TEXT("\0"); 

                LoadString(ghInstanceResDll, IDS_NOT_ENOUGH_DISKSPACE, szTemp, ARRAYSIZE(szTemp));
                LoadString(ghInstanceResDll, IDS_APPNAME, szCaption, ARRAYSIZE(szCaption));
                MessageBox(hwndParent, szTemp, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
            }
        }
    }    
    SetCurrentDirectory(szWorkingDir);
    return ret;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ispsel.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  ISPSEL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "exdisp.h"
#include "shldisp.h"
#include <htiframe.h>
#include <mshtml.h>

#define FIRST_CTL_OFFSET    1      // offset of the first control
                                   // in DLUs. This is used when in 
                                   // OEM custom mode to determin how 
                                   // much to shift up the other controls
BOOL    gbHaveCNSOffer = FALSE;
int     g_nIndex = 0;

/*******************************************************************

  NAME:         SetHeaderFonts

  SYNOPSIS:     Set the font of the header title

  ENTRY:        hDlg - dialog window
                phFont - font we needed

********************************************************************/
BOOL SetHeaderFonts(HWND hDlg, HFONT *phFont)
{
    HFONT   hFont;
    LOGFONT LogFont;

    GetObject(GetWindowFont(hDlg), sizeof(LogFont), &LogFont);

    LogFont.lfWeight = FW_BOLD;
    if ((hFont = CreateFontIndirect(&LogFont)) == NULL)
    {
        *phFont = NULL;
        return FALSE;
    }
    *phFont = hFont;
    return TRUE;
}


/*******************************************************************

  NAME:         WriteISPHeaderTitle

  SYNOPSIS:     Write the header on the ISP sel page

  ENTRY:        hDlg - dialog window
                hdc - device context
                uTitle - IDS constant for the title

********************************************************************/
void WriteISPHeaderTitle(HWND hDlg, UINT uDlgItem)
{
    HGDIOBJ     hFontOld = NULL;
    HFONT       hFont = NULL;

    if (!SetHeaderFonts(hDlg, &hFont))
    {
        hFont = GetWindowFont(hDlg);
    }

    HDC hdc = GetDC(hDlg);
    if (hdc)
    {
        hFontOld = SelectObject(hdc, hFont);

        SendMessage(GetDlgItem(hDlg, uDlgItem),WM_SETFONT,(WPARAM)hFont,MAKELPARAM(TRUE,0));
    
        if (hFontOld)
            SelectObject(hdc, hFontOld);
        ReleaseDC(hDlg, hdc);
    }

    return;
}

// Convert a supplied icon from it's GIF format to an ICO format
void ConvertISPIcon(LPTSTR lpszLogoPath, HICON* hIcon)
{
    ASSERT(gpWizardSatet->pGifConvert);
    
    TCHAR szPath[MAX_PATH+1] = TEXT("\0");
    GetCurrentDirectory(MAX_PATH+1, szPath);
    lstrcat(szPath, TEXT("\\"));
    lstrcat(szPath, lpszLogoPath);

    gpWizardState->pGifConvert->GifToIcon(szPath, 16, hIcon);
}    

// Insert an element into the ISP select list view
BOOL AddItemToISPList
(
    HWND        hListView,
    int         iItemIndex,
    LPTSTR      lpszIspName,
    int         iIspLogoIndex,
    BOOL        bCNS,
    LPARAM      lParam,
    BOOL        bFilterDupe
)
{

    LVITEM  LVItem;
    LVItem.mask         = LVIF_IMAGE | LVIF_TEXT | LVIF_PARAM;
    LVItem.iItem        = iItemIndex;
    LVItem.iSubItem     = 0;
    LVItem.iImage       = iIspLogoIndex;
    LVItem.pszText      = lpszIspName;
    LVItem.lParam       = lParam;
    BOOL bOKToAdd       = TRUE;
    int  nMatch         = 0;

    if (bFilterDupe)
    {
        // Find the duplicate
        LVITEM     CurLVItem;
        CISPCSV     *pcISPCSV;
        int iNum = ListView_GetItemCount(hListView);
        LPTSTR szMirCode = ((CISPCSV*)lParam)->get_szMir();
        WORD   wLCID = ((CISPCSV*)lParam)->get_wLCID();
        memset(&CurLVItem, 0, sizeof(CurLVItem));
        for ( int i = 0; i < iNum; i++)
        {
            CurLVItem.mask         = LVIF_TEXT | LVIF_PARAM;
            CurLVItem.iItem        = i;
            if (ListView_GetItem(hListView, &CurLVItem))
            {
                if (NULL != (pcISPCSV = (CISPCSV*) CurLVItem.lParam) )
                {
                    // check for Mir code for duplicate
                    if (0 == lstrcmp(pcISPCSV->get_szMir(), szMirCode))
                    {
                        // Check for LCID, if different LCID, show both offers
                        if (pcISPCSV->get_wLCID() == wLCID)
                        {
                            bOKToAdd = FALSE;
                            // Replace this one with the current one
                            nMatch = i; 
                            if (gpWizardState->lpSelectedISPInfo == pcISPCSV)
                            {
                                gpWizardState->lpSelectedISPInfo = (CISPCSV*)lParam;
                            }
                            delete pcISPCSV;
                            break;
                        }
                    }
                }
            }
        }

    }

    
    // Insert the Item if it is not a dupe
    if (bOKToAdd)
    {
        ListView_InsertItem(hListView, &LVItem);
    }
    else
    {
        iItemIndex = nMatch;
        LVItem.iItem = iItemIndex;
        ListView_SetItem(hListView, &LVItem);
    }

    // Set the ISP name into column 1
    ListView_SetItemText(hListView, iItemIndex, 1, lpszIspName);

    // If this dude is click and surf, then turn on the CNS graphic, in column 2
    if (bCNS)
    {  
        LVItem.mask        = LVIF_IMAGE;
        LVItem.iItem       = iItemIndex;
        LVItem.iSubItem    = 2;
        LVItem.iImage      = 0;
        ListView_SetItem(hListView, &LVItem);
    }
    
    return bOKToAdd;
}        
    
/*******************************************************************

  NAME:         ParseISPCSV

  SYNOPSIS:     Called when page is displayed

  ENTRY:        hDlg - dialog window
                fFirstInit - TRUE if this is the first time the dialog
                is initialized, FALSE if this InitProc has been called
                before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ParseISPCSV
(
    HWND hDlg, 
    TCHAR *pszCSVFileName,
    BOOL bCheckDupe
)
{
    // we will read the ISPINFO.CSV file, and populate the ISP LISTVIEW

    CCSVFile    far *pcCSVFile;
    CISPCSV     far *pcISPCSV;
    BOOL        bRet = TRUE;
    HICON       hISPLogo;
    int         iImage;
    HRESULT     hr;

    // Open and process the CSV file
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) 
    {
        // BUGBUG: Show Error Message
    
        goto ISPFileParseError;
    }            

    if (!pcCSVFile->Open(pszCSVFileName))
    {
        // BUGBUG: Show Error Message          
        AssertMsg(0,"Can not open ISPINFO.CSV file");
        delete pcCSVFile;
        pcCSVFile = NULL;
        goto ISPFileParseError; 
    }

    // Read the first line, since it contains field headers
    pcISPCSV = new CISPCSV;
    if (!pcISPCSV)
    {
        // BUGBUG Show error message
        delete pcCSVFile;
        goto ISPFileParseError;
    }

    if (ERROR_SUCCESS != (hr = pcISPCSV->ReadFirstLine(pcCSVFile)))
    {
        // Handle the error case
        delete pcCSVFile;
        pcCSVFile = NULL;
        gpWizardState->iNumOfValidOffers = 0;
        //*puNextPage = g_uExternUINext;
        bRet = TRUE;
        goto ISPFileParseError;
    }
    delete pcISPCSV;        // Don't need this one any more

    do 
    {
        // Allocate a new ISP record
        pcISPCSV = new CISPCSV;
        if (!pcISPCSV)
        {
            // BUGBUG Show error message
            bRet = FALSE;
            break;               
        }

        // Read a line from the ISPINFO file
        hr = pcISPCSV->ReadOneLine(pcCSVFile);

        if (hr == ERROR_SUCCESS)               
        { 
            // If this line contains a nooffer flag, then leave now
            if (!(pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OFFERS)) 
            {
                // Empty the list view, in case this is not the first line.
                // This should always be the first line
                ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));

                // Add the entry to the list view
                AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                  0, 
                                  pcISPCSV->get_szISPName(), 
                                  -1,
                                  FALSE,
                                  (LPARAM)pcISPCSV,
                                  bCheckDupe);

                // Set the Current selected ISP to this one.  We need this because
                // this contains the path to no-offer htm
                gpWizardState->lpSelectedISPInfo = pcISPCSV;

                // Assigning ISP_INFO_NO_VALIDOFFER means the ispinfo.csv
                // contains a no-offer line pointing to the ISP no-offer htm
                gpWizardState->iNumOfValidOffers = ISP_INFO_NO_VALIDOFFER;
                break;
            }

            // Increments the number of offers htm
            gpWizardState->iNumOfValidOffers++;

            if (gpWizardState->bISDNMode ? (pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_ISDN_OFFER) : TRUE)
            {
        
                // See if this is an OEM tier 1 offer, and if we don't already have
                // an OEM tier 1 offer, then set it.
                if ((NULL == gpWizardState->lpOEMISPInfo[gpWizardState->uNumTierOffer]) && 
                    (gpWizardState->uNumTierOffer < MAX_OEM_MUTI_TIER) &&
                    pcISPCSV->get_dwCFGFlag() & ICW_CFGFLAG_OEM_SPECIAL )
                {
                    gpWizardState->lpOEMISPInfo[gpWizardState->uNumTierOffer] = pcISPCSV;
                    gpWizardState->uNumTierOffer++;

                    // Add the Tier logo to the image list
                    if (pcISPCSV->get_szISPTierLogoPath())
                    {
                        TCHAR   szURL[INTERNET_MAX_URL_LENGTH];

                        // Form the URL
                        pcISPCSV->MakeCompleteURL(szURL, pcISPCSV->get_szISPTierLogoPath());

                        // Convert GIF to ICON 
                        gpWizardState->pGifConvert->GifToIcon(szURL, 0, &hISPLogo);
                        pcISPCSV->set_ISPTierLogoIcon(hISPLogo);                   
                    }
                }
                else
                {
                    // Convert the ISP logo from a GIF to an ICON, and add it to the Image List
                    ConvertISPIcon(pcISPCSV->get_szISPLogoPath(), &hISPLogo);   
                    iImage =  ImageList_AddIcon(gpWizardState->himlIspSelect, hISPLogo);
        
                    DestroyIcon(hISPLogo);
                    pcISPCSV->set_ISPLogoImageIndex(iImage);
    
                    // Add the entry to the list view
                    if (AddItemToISPList( GetDlgItem(hDlg, IDC_ISPLIST), 
                                      g_nIndex, 
                                      pcISPCSV->get_szISPName(), 
                                      pcISPCSV->get_ISPLogoIndex(),
                                      pcISPCSV->get_bCNS(),
                                      (LPARAM)pcISPCSV,
                                      bCheckDupe))
                    {
                        g_nIndex++;
                        if (pcISPCSV->get_bCNS())
                            gbHaveCNSOffer = TRUE;
        
                        // Assign a default selection
                        if (NULL == gpWizardState->lpSelectedISPInfo)
                        {
                            gpWizardState->lpSelectedISPInfo = pcISPCSV;
                        }
                    }

                }       
            
                // if we are in ISDN mode, then increment the ISDN offer count
                if (gpWizardState->bISDNMode)
                    gpWizardState->iNumOfISDNOffers++;
                                 
            }
            else
            {
                // Since this obj is not added to the listview, we need to free
                // it here. Listview items are free when message LVN_DELETEITEM
                // is posted
                delete pcISPCSV;
            }

        }
        else if (hr == ERROR_FILE_NOT_FOUND) 
        {   
            // do not show this  ISP when its data is invalid
            // we don't want to halt everything. Just let it contine
            delete pcISPCSV;      
        }
        else if (hr == ERROR_NO_MORE_ITEMS)
        {   
            // There is no more to read.  No an error condition.
            delete pcISPCSV;        
            break;
        }
        else if (hr != ERROR_INVALID_DATA)
        {
            // Show error message later.
            // This should not happen unless we called ICW3's referral or
            // a corrupted copy of ispinfo.csv
            gpWizardState->iNumOfValidOffers = 0;
            delete pcISPCSV;
            bRet = FALSE;               
            break;  
        }

    } while (TRUE);

    pcCSVFile->Close();

    delete pcCSVFile;

    return bRet;

ISPFileParseError:

    // Set bParseIspinfo so next time, we'll reparse the CSV file
    gpWizardState->cmnStateData.bParseIspinfo = TRUE;
    return bRet;
}
    
// Initialize the ISP select list view
BOOL InitListView(HWND  hListView)
{
    LV_COLUMN   col;
    
    // Set the necessary extended style bits
    ListView_SetExtendedListViewStyle(hListView, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES);
    
    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    for(int i=0; i<3; i++)
    {
        if(ListView_InsertColumn(hListView, i, &col) == (-1))
            return(FALSE);
    }

    if (NULL == gpWizardState->himlIspSelect)
    {
        // Setup the image list
        if((gpWizardState->himlIspSelect = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                                            GetSystemMetrics(SM_CYSMICON), 
                                                            ILC_COLORDDB  , 0, 8)) == (HIMAGELIST)NULL)
            return(FALSE);
    }

    ListView_SetImageList(hListView, gpWizardState->himlIspSelect, LVSIL_SMALL);
    
    // Add the CNS graphic.  We add it first, so that it is always image index 0
    ImageList_AddIcon(gpWizardState->himlIspSelect, LoadIcon(ghInstanceResDll, MAKEINTRESOURCE(IDI_CNS)));
    
    return(TRUE);
}

    
// Reset the column size of the ISP select list view
BOOL ResetListView(HWND  hListView)
{
    LV_COLUMN   col;
    RECT        rc;
    
    // reset 3 columns. ISP LOGO, ISP Name, CNS
    GetClientRect(hListView, &rc);
    
    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = GetSystemMetrics(SM_CXSMICON) + 2;
    if(ListView_SetColumn(hListView, 0, &col) == (-1))
        return(FALSE);

    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = (rc.right - rc.left) - (2*GetSystemMetrics(SM_CXSMICON)) - 4;
    if(ListView_SetColumn(hListView, 1, &col) == (-1))
        return(FALSE);

    ZeroMemory(&col, SIZEOF(LV_COLUMN));
    col.mask = LVCF_FMT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = GetSystemMetrics(SM_CXSMICON) + 2;
    if(ListView_SetColumn(hListView, 2, &col) == (-1))
        return(FALSE);
    return TRUE;
}

/*******************************************************************

  NAME:    ISPSelectInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPSelectInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL bRet = TRUE;
    if (fFirstInit)
    {
        // If we are in modeless operation, then we want the app
        // to show the title, not the dialog
        SetWindowLongPtr(GetDlgItem(hDlg, IDC_ISPLIST_CNSICON), GWLP_USERDATA, 202);

        if(gpWizardState->cmnStateData.bOEMCustom)
        {
            TCHAR   szTitle[MAX_RES_LEN];
            RECT    rcCtl, rcDLU;
            HWND    hWndCtl = GetDlgItem(hDlg, IDC_ISP_SEL_TITLE);
            int     iCtlIds[7] = { IDC_ISPSELECT_INTRO,
                                   IDC_ISPLIST_CNSICON,
                                   IDC_ISPLIST_CNSINFO,
                                   IDC_ISPSELECT_LBLISPLIST,
                                   IDC_ISPLIST,
                                   IDC_ISPSELECT_LBLMARKET,
                                   IDC_ISPMARKETING };
            int     i, iOffset;            
            
            // Get the Title
            GetWindowText(hWndCtl, szTitle, ARRAYSIZE(szTitle));
            
            // Hide the title
            ShowWindow(hWndCtl, SW_HIDE);
            
            // The offset to shift will be based on the number of DLU's from
            // top that the controls should be.  That amount is converted to 
            // pixels, and then the top of the first controls is used to compute
            // the final offset
            rcDLU.top = rcDLU.left = 0;
            rcDLU.bottom = rcDLU.right = FIRST_CTL_OFFSET;
            MapDialogRect(hDlg, &rcDLU);
            
            // Get the window of the 1st control
            hWndCtl = GetDlgItem(hDlg, iCtlIds[0]);
            // Get its screen position
            GetWindowRect(hWndCtl, &rcCtl);
            // Map to client coordinates for the parent
            MapWindowPoints(NULL, hDlg, (LPPOINT)&rcCtl, 2);
            // compute the offset
            iOffset = rcCtl.top - rcDLU.bottom;
            
            // for each control, move the window up by iOffset           
            for (i = 0; i < ARRAYSIZE(iCtlIds); i++)            
            {
                // Get the window of the control to move
                hWndCtl = GetDlgItem(hDlg, iCtlIds[i]);
                
                // Get its screen position
                GetWindowRect(hWndCtl, &rcCtl);
                
                // Map to client coordinates for the parent
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rcCtl, 2);
                
                // Compute the new position
                rcCtl.top -= iOffset;
                rcCtl.bottom -= iOffset;
                
                // Move the control window
                MoveWindow(hWndCtl,
                           rcCtl.left,
                           rcCtl.top,
                           RECTWIDTH(rcCtl),
                           RECTHEIGHT(rcCtl),
                           FALSE);
            }
            
            // Set the title
            SendMessage(gpWizardState->cmnStateData.hWndApp, WUM_SETTITLE, 0, (LPARAM)szTitle);
        }
        else
        {
            WriteISPHeaderTitle(hDlg, IDC_ISP_SEL_TITLE);
        }
        
        // Initialize the List View
        InitListView(GetDlgItem(hDlg, IDC_ISPLIST));
        gpWizardState->cmnStateData.bParseIspinfo = TRUE;
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISPSELECT;

        gpWizardState->bISDNMode = gpWizardState->cmnStateData.bIsISDNDevice;
        

        if (gpWizardState->cmnStateData.bParseIspinfo)
        {
            TCHAR       szTemp[MAX_RES_LEN];

            // If there are items in the list view, clear them
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));

            for (UINT i=0; i < gpWizardState->uNumTierOffer; i++)
            {
                if (gpWizardState->lpOEMISPInfo[i])
                {
                    delete gpWizardState->lpOEMISPInfo[i];
                    gpWizardState->lpOEMISPInfo[i] = NULL;
                }
            }
            gpWizardState->lpSelectedISPInfo = NULL;

            // Initialize the number of offers
            gpWizardState->iNumOfValidOffers = 0;
            gpWizardState->iNumOfISDNOffers = 0;
            gpWizardState->uNumTierOffer = 0;
            g_nIndex = 0;

            // Do not need to reparse next time
            gpWizardState->cmnStateData.bParseIspinfo = FALSE;

            // When we are in OEM mode, we need to read offline folder no matter where
            // we are launched from.
            if (gpWizardState->cmnStateData.bOEMOffline)
                ParseISPCSV(hDlg, ICW_OEMINFOPath, TRUE);

            // Not running from OEM Entry and not offline in oeminfo.ini means we didn't call 
            // Referral server.  We can skip parsing of CSV.
            if (!(gpWizardState->cmnStateData.bOEMOffline && gpWizardState->cmnStateData.bOEMEntryPt))
                ParseISPCSV(hDlg, ICW_ISPINFOPath, TRUE);
            
            if( gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SBS )
                LoadString(ghInstanceResDll, IDS_ISPSELECT_ONLISTSIGNUP, szTemp, MAX_RES_LEN);
            else
                LoadString(ghInstanceResDll, IDS_ISPSELECT_CNS, szTemp, MAX_RES_LEN);

            SetWindowText(GetDlgItem(hDlg, IDC_ISPLIST_CNSINFO), szTemp);
            // Hide the CNS legend if there are no CNSoffers
            if (!gbHaveCNSOffer)
            {
                ShowWindow(GetDlgItem(hDlg, IDC_ISPLIST_CNSINFO), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_ISPLIST_CNSICON), SW_HIDE);
            }

            ResetListView(GetDlgItem(hDlg, IDC_ISPLIST));
        }

        // The following 4 Cases can happen at this point:
        // 1) The ispinfo.csv contains a line says no offer, we go to nooffer page
        // 2) The ispinfo.csv contains no line of valid offer and no no-offer entry
        //    This may happen in calling the old referral.dll that ICW 3 client calls
        // 3) There are many offers but no ISDN offers, and we are in ISDN mode
        //    we go to ISDN offer pages
        // 4) Normal situation, some valid offers where we're in ISDN or not
        
        if (ISP_INFO_NO_VALIDOFFER == gpWizardState->iNumOfValidOffers)
        {
            // ISPINFO CSV contains a line saying NOOFFER!
            // if there are no offers, then we can just go directly to the NoOffers page
            ASSERT(gpWizardState->lpSelectedISPInfo);
            *puNextPage = ORD_PAGE_NOOFFER;
            bRet = TRUE;
        }
        else if (0 == gpWizardState->iNumOfValidOffers)
        {
            // Error in ISPINFO.CSV if there is no valid offers and no no-offer entry
            // critical error
            ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_ISPLIST));
            *puNextPage = g_uExternUINext;
            gpWizardState->cmnStateData.bParseIspinfo = TRUE;
            bRet = TRUE;
        }
        else if ((0 == gpWizardState->iNumOfISDNOffers) && gpWizardState->bISDNMode)
        {
            // if we are in ISDN mode and there is no ISDN offers
            // go to the ISDN nooffer age
            *puNextPage = ORD_PAGE_ISDN_NOOFFER;
            bRet = TRUE;
        }
        else
        {
            // See if we have an OEM tier 1 offer, and if we should NOT be showing
            // the "more" list, then jump to the OEM offer page
            if ((gpWizardState->uNumTierOffer > 0) && !gpWizardState->bShowMoreOffers)
            {
                *puNextPage = ORD_PAGE_OEMOFFER;
            }
            else
            {
                gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_ISPMARKETING), PAGETYPE_MARKETING);
                
                // If there are no selected items, select the first one, otherwise just navigate
                // the marketing window to the selected one
                if (0 == ListView_GetSelectedCount(GetDlgItem(hDlg, IDC_ISPLIST)))
                {
                    ASSERT(gpWizardState->lpSelectedISPInfo);
                    // Select the First Item in the Listview
                    ListView_SetItemState(GetDlgItem(hDlg, IDC_ISPLIST), 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                }
                else
                {
                    CISPCSV     *pcISPCSV = NULL;
                    int         nCurrSel = ListView_GetSelectionMark(GetDlgItem(hDlg, IDC_ISPLIST));
                    if (-1 != nCurrSel)
                    {
                        LVITEM     CurLVItem;

                        memset(&CurLVItem, 0, sizeof(CurLVItem));
                        CurLVItem.mask         = LVIF_TEXT | LVIF_PARAM;
                        CurLVItem.iItem        = nCurrSel;
                        if (ListView_GetItem(GetDlgItem(hDlg, IDC_ISPLIST), &CurLVItem))
                        {
                            if (NULL != (pcISPCSV = (CISPCSV*) CurLVItem.lParam) )
                            {
                                gpWizardState->lpSelectedISPInfo = pcISPCSV;

                                // Navigate, since we are re-activating
                                pcISPCSV->DisplayHTML(pcISPCSV->get_szISPMarketingHTMPath());
                            }
                        }
                    }
        
                }                

                // Clear the dial Exact state var so that when we get to the dialing
                // page, we will regenerate the dial string
                gpWizardState->bDialExact = FALSE;
            }   
            
            // Set the return code
            bRet = TRUE;
        }
    }
    return bRet;
}

/*******************************************************************

  NAME:         ValidateISP

  SYNOPSIS:     checks if the ISP provides a valid offer by checking
                the existence of the CSV file
  ENTRY:        hDlg - Window handle

  EXIT:         returns TRUE if the ISP provides valid CSP, 
                FALSE otherwise
                
********************************************************************/
BOOL CALLBACK ValidateISP(HWND hDlg)
{
    CCSVFile    far *pcCSVFile;
    BOOL        bRet = TRUE;
        
    // Read the payment .CSV file.
    pcCSVFile = new CCSVFile;
    if (!pcCSVFile) 
    {
        return FALSE;
    }          

    if (!pcCSVFile->Open(gpWizardState->lpSelectedISPInfo->get_szPayCSVPath()))
    {
        TCHAR szErrMsg      [MAX_RES_LEN+1] = TEXT("\0");
        TCHAR szCaption     [MAX_RES_LEN+1] = TEXT("\0");
        LPVOID  pszErr;
        TCHAR   *args[1];
        args[0] = (LPTSTR) gpWizardState->lpSelectedISPInfo->get_szISPName();

        if (!LoadString(ghInstanceResDll, IDS_ISPSELECT_INVALID, szErrMsg,  ARRAYSIZE(szErrMsg)  ))
            return FALSE;
        if (!LoadString(ghInstanceResDll, IDS_APPNAME,           szCaption, ARRAYSIZE(szCaption) ))
            return FALSE;
        
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                      szErrMsg, 
                      0, 
                      0, 
                      (LPTSTR)&pszErr, 
                      0,
                      (va_list*)args);
        // Show Error Message
        MessageBox(hDlg, (LPTSTR)pszErr, szCaption, MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL);
        LocalFree(pszErr);
    
        delete pcCSVFile;
        pcCSVFile = NULL;
        bRet = FALSE;
    }

    if (pcCSVFile)
    {
        pcCSVFile->Close();
        delete pcCSVFile;
    }
    return bRet;
   
}


/*******************************************************************

  NAME:    ISPSelectOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPSelectOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        DWORD dwFlag = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

        if (ICW_CFGFLAG_SIGNUP_PATH & dwFlag)
        {           
            if (ICW_CFGFLAG_USERINFO & dwFlag)
            {
                *puNextPage = ORD_PAGE_USERINFO; 
                return TRUE;
            }
            if (ICW_CFGFLAG_BILL & dwFlag)
            {
                *puNextPage = ORD_PAGE_BILLINGOPT; 
                return TRUE;
            }
            if (ICW_CFGFLAG_PAYMENT & dwFlag)
            {
                *puNextPage = ORD_PAGE_PAYMENT; 
                return TRUE;
            }
            *puNextPage = ORD_PAGE_ISPDIAL; 
            return TRUE;           
        }
        else
        {
            *puNextPage = ORD_PAGE_OLS; 
        }
       
    }
    return TRUE;
}

/*******************************************************************

  NAME:    ISPSElectNotifyProc

********************************************************************/
BOOL CALLBACK ISPSelectNotifyProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CISPCSV     *pcISPCSV;

    // Process ListView notifications
    switch(((LV_DISPINFO *)lParam)->hdr.code)
    {
        case NM_DBLCLK:
            PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
            break;

        case NM_SETFOCUS:
        case NM_KILLFOCUS:
            // update list view
            break;

        case LVN_ITEMCHANGED:
            TraceMsg(TF_ISPSELECT, "ISPSELECT: WM_NOTIFY - LVN_ITEMCHANGED");

            if((((NM_LISTVIEW *)lParam)->uChanged & LVIF_STATE) &&
                ((NM_LISTVIEW *)lParam)->uNewState & (LVIS_FOCUSED | LVIS_SELECTED))
            {
                // IF an Item just became selected, then render it's HTML content
                pcISPCSV = (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;
                pcISPCSV->DisplayHTML(pcISPCSV->get_szISPMarketingHTMPath());

                // Remember the selected item for later use
                gpWizardState->lpSelectedISPInfo = pcISPCSV;
                
                //Set the intro text based on the number of isp'
                int iNum = ListView_GetItemCount(GetDlgItem(hDlg,IDC_ISPLIST));
                if (iNum > 1)
                   gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPSELECT_INTRO), IDS_ISPSELECT_INTROFMT_MULTIPLE, NULL);
                else if (iNum > 0)
                   gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPSELECT_INTRO), IDS_ISPSELECT_INTROFMT_SINGLE, NULL);
               
            }
            break;
            
        // The listview is being emptied, or destroyed, either way, our lpSelectedISPInfo 
        // is no longer valid, since the list view underlying data will be freed.
        case LVN_DELETEALLITEMS:
            gpWizardState->lpSelectedISPInfo = NULL;
            SetPropSheetResult(hDlg,TRUE);
            break;
        
        case LVN_DELETEITEM:
            // We were notified that an item was deleted.
            // so delete the underlying data that it is pointing
            // to.
            if (((NM_LISTVIEW*)lParam)->lParam)
                delete  (CISPCSV *)((NM_LISTVIEW *)lParam)->lParam;
            break;

    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ispdial.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
 
//
//  ISPDIAL.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include <raserror.h>

BOOL            DoOfferDownload();

/*******************************************************************

  NAME:    ISPDialInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPDialInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // Disable Back and Next
    PropSheet_SetWizButtons(GetParent(hDlg), 0);
    gpWizardState->bRefDialTerminate = FALSE;
    gfISPDialCancel = FALSE;

    if (fFirstInit)
    {
      //Are we in IEAK Mode
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {          
            // Do the system config checks
            if (!gpWizardState->cmnStateData.bSystemChecked && !(*gpWizardState->cmnStateData.lpfnConfigSys)(hDlg))
            {
                // gfQuitWizard will be set in ConfigureSystem if we need to quit
                return FALSE;
            }
        }
        
        CRefDialEvent *pRefDialEvent;
        CWebGateEvent *pWebGateEvent;
    
        // Blank out the status text initially
        SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_STATUS), TEXT(""));
        
        gpWizardState->iRedialCount = 0;

        // Setup an Event Handler for RefDial and Webgate
        pRefDialEvent = new CRefDialEvent(hDlg);
        if (NULL != pRefDialEvent)
        {
            HRESULT hr;
            gpWizardState->pRefDialEvents = pRefDialEvent;
            gpWizardState->pRefDialEvents->AddRef();
    
            hr = ConnectToConnectionPoint((IUnknown *)gpWizardState->pRefDialEvents, 
                                            DIID__RefDialEvents,
                                            TRUE,
                                            (IUnknown *)gpWizardState->pRefDial, 
                                            &gpWizardState->pRefDialEvents->m_dwCookie, 
                                            NULL);     
        }    
        pWebGateEvent = new CWebGateEvent(hDlg);
        if (NULL != pWebGateEvent)
        {
            HRESULT hr;
            gpWizardState->pWebGateEvents = pWebGateEvent;
            gpWizardState->pWebGateEvents->AddRef();
    
            hr = ConnectToConnectionPoint((IUnknown *)gpWizardState->pWebGateEvents, 
                                            DIID__WebGateEvents,
                                            TRUE,
                                            (IUnknown *)gpWizardState->pWebGate, 
                                            &gpWizardState->pWebGateEvents->m_dwCookie, 
                                            NULL);     
        }    
    }
    else
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ISPDIAL;

        ResetEvent(gpWizardState->hEventWebGateDone);
        // Cleanup the ISPPageCache for this ISP, since we are about to connect
        gpWizardState->lpSelectedISPInfo->CleanupISPPageCache(FALSE);
        
        TCHAR    szTemp[MAX_MESSAGE_LEN];
        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
        {
            // hide this text for autoconfig
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDIAL_INSTRUCT),  SW_HIDE);
            LoadString(ghInstanceResDll, IDS_STEP2A_TITLE, szTemp, MAX_MESSAGE_LEN);
        }
        else
        {
            // show this text for new signup
            ShowWindow(GetDlgItem(hDlg, IDC_ISPDIAL_INSTRUCT),  SW_SHOW);
            LoadString(ghInstanceResDll, IDS_STEP2_TITLE, szTemp, MAX_MESSAGE_LEN);
        }
        PropSheet_SetHeaderTitle(GetParent(hDlg), EXE_NUM_WIZARD_PAGES +  ORD_PAGE_ISPDIAL, szTemp);


        // Initialize the RefDial Object before we dial
        gpWizardState->pRefDial->DoInit();
    }     
    return TRUE;
}

/*******************************************************************

  NAME:    ISPDialPostInitProc

  SYNOPSIS:  

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ISPDialPostInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet;
    
    if (!fFirstInit)
    {
        // Force the Window to update
        UpdateWindow(GetParent(hDlg));

        if(!gpWizardState->iRedialCount)
        {
            // Clear the phone number and status fields
            SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_STATUS), TEXT(""));    
            SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_PHONENUM), TEXT(""));
        }
            
        // Set the intro text
        ASSERT(gpWizardState->lpSelectedISPInfo);
        gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPDIAL_INTRO), IDS_ISPDIAL_INTROFMT, NULL);

        
        if (!gpWizardState->bDialExact)
        {
            BSTR    bstrPhoneNum = NULL;
            BOOL    bRetVal;

           
            // Setup for Dialing.  This will ensure that we are ready to dial.
            gpWizardState->pRefDial->SetupForDialing(A2W(gpWizardState->lpSelectedISPInfo->get_szISPFilePath()), //
                                                     gpWizardState->cmnStateData.dwCountryCode,
                                                     A2W(gpWizardState->cmnStateData.szAreaCode),
                                                     0,
                                                     &bRetVal);
            if (bRetVal)
            {            
                // Show the phone Number
                gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
                SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_PHONENUM), W2A(bstrPhoneNum));

                // Initialize all the variables
                gpWizardState->bDoneWebServDownload = FALSE;
                gpWizardState->bDoneWebServRAS = FALSE;
            
                // Show the Initial Status
            
                if(!gpWizardState->iRedialCount)
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPDIAL_STATUS), 
                                                                             IDS_ISPDIAL_STATUSDIALINGFMT, NULL);
                else
                    gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_ISPDIAL_STATUS), 
                                                                             IDS_ISPDIAL_STATUSREDIALINGFMT, NULL);
               
                //This flag is only to be used by ICWDEBUG.EXE
                if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                    gpWizardState->pRefDial->put_ModemOverride(TRUE);
                    
                gpWizardState->pRefDial->DoConnect(&bRetVal);
            }
            else 
            {
                gpWizardState->pRefDial->get_QuitWizard(&bRetVal);
                if (bRetVal)
                {
                    gfQuitWizard = TRUE;
                   bRet = FALSE;

                }
                else 
                {
                    gpWizardState->pRefDial->get_TryAgain(&bRetVal);
                    if (bRetVal)
                    {
                        PropSheet_PressButton(GetParent(hDlg),PSBTN_BACK);
                    }
                    else
                    {
                        PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                    }
                }
            }   
            SysFreeString(bstrPhoneNum);
        }
        else // Dialing exact.  We get here if the user changes the number on the dial error page
        {
            BSTR    bstrPhoneNum = NULL; 
            BOOL    bRet;
            int     iCurrent = 0;
          
            // Show the phone Number
            gpWizardState->pRefDial->get_DialPhoneNumber(&bstrPhoneNum);
            SetWindowText(GetDlgItem(hDlg, IDC_ISPDIAL_PHONENUM), W2A(bstrPhoneNum));
            SysFreeString(bstrPhoneNum);

            //This flag is only to be used by ICWDEBUG.EXE
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_MODEMOVERRIDE)
                    gpWizardState->pRefDial->put_ModemOverride(TRUE);
                
            gpWizardState->pRefDial->DoConnect(&bRet);
        }
    }
    return bRet;
}

/*******************************************************************

  NAME:    ISPDialOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK ISPDialOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    *pfKeepHistory  = FALSE;

    if (fForward)
    {
        if (!gpWizardState->bDoneWebServRAS)
        {          
            //OK so we had a dialing error but let's figure out which one...
            HRESULT hrDialErr;
            
            gpWizardState->pRefDial->get_DialError(&hrDialErr);
                
            switch (hrDialErr)
            {
                case ERROR_LINE_BUSY: //Line is engaged
                {     
                    if (gpWizardState->iRedialCount < NUM_MAX_REDIAL)
                    {   
                        //Redial
                        *puNextPage = ORD_PAGE_ISPDIAL;
                        gpWizardState->iRedialCount++;
                        break;
                    }
                    gpWizardState->iRedialCount = 0;
                }
                default:
                {
                    // nothing special just goto the dialing error page
                    *puNextPage = ORD_PAGE_DIALERROR;
                    break;
                }
            }              
        }
        else if (!gpWizardState->bDoneWebServDownload)
        {           
            gpWizardState->pRefDial->DoHangup();
            *puNextPage = ORD_PAGE_SERVERR;
        }
    }
    else // a retry is simulated when BACK is pressed
    {
        *puNextPage = ORD_PAGE_ISPDIAL;
    }
    return TRUE;
}

BOOL CALLBACK ISPDialCancelProc(HWND hDlg)
{
    //User has canceled so reset the redial count
    gpWizardState->iRedialCount = 0;
              
    if (gpWizardState->pRefDial)
    {
        gpWizardState->pRefDial->DoHangup();
        //We should make sure the wiz thinks it's a dialerr to avoid
        //the server error page
        gpWizardState->bDoneWebServDownload = FALSE;
        gpWizardState->bDoneWebServRAS      = FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\nooffer.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  NOOFFER.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"

/*******************************************************************

  NAME:    NoOfferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK NoOfferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_NOOFFER;

    TCHAR    szTemp[MAX_MESSAGE_LEN * 2];
    LoadString(ghInstanceResDll, IDS_NOOFFER, szTemp, MAX_MESSAGE_LEN * 2);
    SetWindowText(GetDlgItem(hDlg, IDC_NOOFFER), szTemp);

    //Twiddle the buttons to do a finish page
    HWND hwndSheet = GetParent(hDlg);
    PropSheet_SetWizButtons(hwndSheet, PSWIZB_FINISH | PSWIZB_BACK);
    PropSheet_Changed(hDlg, hwndSheet);    

    return TRUE;
}

BOOL CALLBACK NoOfferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    if (!fForward)
    {
        //If were going backward we want to trick the
        //wizard into thinking we were the isp select page
        gpWizardState->uCurrentPage = ORD_PAGE_ISPSELECT;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\oemoffer.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  OEMOFFER.CPP - Functions for 
//

//  HISTORY:
//  
//  09/03/98  donaldm  Created.
//
//*********************************************************************

#include "pre.h"
#include "webvwids.h"

#define  NO_TIER_SELECT -1
UINT IDC_OEM_TIER[] =
{
    IDC_OEM_TIER1,
    IDC_OEM_TIER2,
    IDC_OEM_TIER3
};
UINT IDC_OEM_TEASER_HTML[] =
{
    IDC_OEM_TEASER_HTML1,
    IDC_OEM_TEASER_HTML2,
    IDC_OEM_TEASER_HTML3
};

int g_nCurrOEMTier = NO_TIER_SELECT;
extern IICWWebView         *gpICWWebView[2];


/*******************************************************************

  NAME:         DoCreateTooltip

  SYNOPSIS:     creates a tooltip control

  ENTRY:        hDlg - dialog window

********************************************************************/
void DoCreateTooltip(HWND hWnd) 
{ 
    HWND hwndToolTip;       // handle of tooltip 
    TOOLINFO ti;            // tool information 

    //  create a tooltip control. 
    hwndToolTip = CreateWindowEx(   0, 
                                    TOOLTIPS_CLASS, 
                                    NULL, 
                                    WS_POPUP | TTS_ALWAYSTIP, 
                                    CW_USEDEFAULT, 
                                    CW_USEDEFAULT, 
                                    10, 
                                    10, 
                                    hWnd, 
                                    NULL, 
                                    ghInstanceResDll, //g_hInst, 
                                    NULL);

    // add the OK button to the tooltip. TTF_SUBCLASS causes the 
    // tooltip to automatically subclass the window and look for the 
    // messages it is interested in. 
    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize = sizeof(ti);
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = hWnd;

    TCHAR    szTemp[MAX_MESSAGE_LEN];
    LoadString(ghInstanceResDll, IDS_OEM_TIER_TOOLTIP, szTemp, MAX_MESSAGE_LEN);
    ti.lpszText = szTemp;

    ti.uId = (UINT_PTR)GetDlgItem(hWnd, IDC_OEM_TIER1);
    SendMessage(hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
    ti.uId = (UINT_PTR)GetDlgItem(hWnd, IDC_OEM_TIER2);
    SendMessage(hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);
    ti.uId = (UINT_PTR)GetDlgItem(hWnd, IDC_OEM_TIER3);
    SendMessage(hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

}

/*******************************************************************

  NAME:         DisplayTierOffer

  SYNOPSIS:     Display Current controls for the tier page

  ENTRY:        hDlg - dialog window

********************************************************************/
void DisplayTierOffer(HWND    hDlg)
{

    if (NO_TIER_SELECT == g_nCurrOEMTier)
    {
        // Hide the marketing page
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_OFFER_HTML), SW_HIDE);

        // Show Teaser htm
        for(UINT i = 0 ; i < gpWizardState->uNumTierOffer; i++)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML[i]), TRUE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TEASER_HTML[i]), SW_SHOW);
        }

        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML1), PAGETYPE_ISP_NORMAL);
        gpWizardState->lpOEMISPInfo[0]->DisplayHTML(gpWizardState->lpOEMISPInfo[0]->get_szISPTeaserPath());

        TCHAR           szURL[INTERNET_MAX_URL_LENGTH];

        
        if (gpWizardState->uNumTierOffer > 1)
        {
            // Make the URL
            gpWizardState->lpOEMISPInfo[1]->MakeCompleteURL(szURL, gpWizardState->lpOEMISPInfo[1]->get_szISPTeaserPath());
            gpICWWebView[0]->DisplayHTML(szURL);
        }
    
        if (gpWizardState->uNumTierOffer > 2)
        {
            gpWizardState->lpOEMISPInfo[2]->MakeCompleteURL(szURL, gpWizardState->lpOEMISPInfo[2]->get_szISPTeaserPath());
            gpICWWebView[1]->DisplayHTML(szURL);
        }
    
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else
    {
        // Hide all the teaser htmls
        for(UINT i = 0 ; i < gpWizardState->uNumTierOffer; i++)
        {
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML[i]), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TEASER_HTML[i]), SW_HIDE);
        }

        // Show the marketing page
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), TRUE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_OFFER_HTML), SW_SHOW);

        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), PAGETYPE_MARKETING);

        CISPCSV *pISPInfo;
        pISPInfo = gpWizardState->lpOEMISPInfo[g_nCurrOEMTier];
        pISPInfo->DisplayHTML(pISPInfo->get_szISPMarketingHTMPath());
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
    }


}

/*******************************************************************

  NAME:    OEMOfferInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK OEMOfferInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_OEMOFFER;
    if (fFirstInit)
    {
        DoCreateTooltip(hDlg);
        if (gpWizardState->uNumTierOffer > 1)
        {
            HRESULT hr;
            for(UINT i = 0; i < MAX_OEM_MUTI_TIER - 1; i++)
            {
                hr = CoCreateInstance(CLSID_ICWWEBVIEW,NULL,CLSCTX_INPROC_SERVER,
                          IID_IICWWebView,(LPVOID *)&gpICWWebView[i]);
                if (FAILED(hr))
                    return FALSE;
            }
        }
    }
    else
    {
        // initialize this state variable
        gpWizardState->bShowMoreOffers = FALSE;
        
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER1), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER1), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER2), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER2), SW_HIDE);
        EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER3), FALSE);
        ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER3), SW_HIDE);

        // If more than one tier offer, show the multi tier page
        if (1 == gpWizardState->uNumTierOffer)
        {

            // Hide multi tier controls
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_INTRO), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_INTRO), SW_HIDE);

            EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_OFFER_HTML), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_OFFER_HTML), SW_HIDE);
            
            // Show Tier one controls
            EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_HTML), TRUE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEMOFFER_HTML), SW_SHOW);

            CISPCSV FAR *lpISP;
            g_nCurrOEMTier = 0;
      
            // Use a local reference for convienience
            lpISP = gpWizardState->lpOEMISPInfo[0];
            ASSERT(lpISP);
        
            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEMOFFER_HTML), PAGETYPE_MARKETING);
        
            // Navigate to the OEM offer marketing HTML
            lpISP->DisplayHTML(lpISP->get_szISPMarketingHTMPath());

            // Set the text for the instructions
            if ((gpWizardState->bISDNMode && (1 == gpWizardState->iNumOfISDNOffers)) ||
                (1 == gpWizardState->iNumOfValidOffers) )
            {
                lpISP->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_OEMOFFER_INSTRUCTION), IDS_OEMOFFER_INSTFMT_SINGLE, NULL);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_HIDE);
            }
            else
            {
                lpISP->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_OEMOFFER_INSTRUCTION), IDS_OEMOFFER_INSTFMT_MULTIPLE, NULL);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_SHOW);
            }
        }
        else
        {

            // Hide Tier one controls
            EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_HTML), FALSE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEMOFFER_HTML), SW_HIDE);

            // Show common multi tier controls - intro text
            EnableWindow(GetDlgItem(hDlg, IDC_OEM_MULTI_TIER_INTRO), TRUE);
            ShowWindow(GetDlgItem(hDlg,   IDC_OEM_MULTI_TIER_INTRO), SW_SHOW);
            for(UINT i = 0 ; i < gpWizardState->uNumTierOffer; i++)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_OEM_TIER[i]), TRUE);
                ShowWindow(GetDlgItem(hDlg,   IDC_OEM_TIER[i]), SW_SHOW);

                SendMessage(GetDlgItem(hDlg, IDC_OEM_TIER[i]), 
                            BM_SETIMAGE, 
                            IMAGE_ICON, 
                            (LPARAM)gpWizardState->lpOEMISPInfo[i]->get_ISPTierLogoIcon());

            }

            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML1), PAGETYPE_ISP_NORMAL);

            switch (gpWizardState->uNumTierOffer)
            {
                case 3:
                    gpICWWebView[1]->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML3), PAGETYPE_ISP_NORMAL);
                case 2:
                    gpICWWebView[0]->ConnectToWindow(GetDlgItem(hDlg, IDC_OEM_TEASER_HTML2), PAGETYPE_ISP_NORMAL);
                    break;
            }

            DisplayTierOffer(hDlg);

            if ((gpWizardState->bISDNMode && (gpWizardState->iNumOfISDNOffers <= (int)gpWizardState->uNumTierOffer)) ||
                (gpWizardState->iNumOfValidOffers <= (int)gpWizardState->uNumTierOffer) )
            {
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_INSTRUCTION), SW_HIDE);
                EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), FALSE);
            }
            else
            {
                TCHAR szTemp    [MAX_RES_LEN];
                LoadString(ghInstanceResDll, IDS_OEMOFFER_INSTR_MULTITIER, szTemp, ARRAYSIZE(szTemp));
                SetWindowText(GetDlgItem(hDlg,IDC_OEMOFFER_INSTRUCTION), szTemp);
                ShowWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), SW_SHOW);
                EnableWindow(GetDlgItem(hDlg, IDC_OEMOFFER_MORE), TRUE);
            }

        }

    }

    return TRUE;
}

BOOL CALLBACK OEMOfferOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    if (fForward)
    {
        // We will keep this page in the history
        *pfKeepHistory = TRUE;
        
        // We either need to go to the true ISP select page because the more button was pressed
        // or we move on based on the selected ISP settings
        if (gpWizardState->bShowMoreOffers)
        {
            *puNextPage = ORD_PAGE_ISPSELECT;
        }
        else
        {
            // Get the config flags, and figure out where to go next
            gpWizardState->lpSelectedISPInfo = gpWizardState->lpOEMISPInfo[g_nCurrOEMTier];

            DWORD dwFlags = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

            if (ICW_CFGFLAG_SIGNUP_PATH & dwFlags)
            {           
                if (ICW_CFGFLAG_USERINFO & dwFlags)
                {
                    *puNextPage = ORD_PAGE_USERINFO; 
                    return TRUE;
                }
                if (ICW_CFGFLAG_BILL & dwFlags)
                {
                    *puNextPage = ORD_PAGE_BILLINGOPT; 
                    return TRUE;
                }
                if (ICW_CFGFLAG_PAYMENT & dwFlags)
                {
                    *puNextPage = ORD_PAGE_PAYMENT; 
                    return TRUE;
                }
                *puNextPage = ORD_PAGE_ISPDIAL; 
                return TRUE;           
            }
            else
            {
                *puNextPage = ORD_PAGE_OLS; 
            }
        }
    }
    else
    {
        // Reset the current selection
        g_nCurrOEMTier = NO_TIER_SELECT;
    }
    return  TRUE;
}

/*******************************************************************

  NAME:    OEMOfferCmdProc

********************************************************************/
BOOL CALLBACK OEMOfferCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	switch (GET_WM_COMMAND_CMD(wParam, lParam)) 
    {
        case BN_CLICKED:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) 
            { 
                case IDC_OEMOFFER_MORE: 
                {
                    // Set the state variable so that we can shore more offers
                    gpWizardState->bShowMoreOffers = TRUE;
        
                    // Fake a press of the next button
                    PropSheet_PressButton(GetParent(hDlg),PSBTN_NEXT);
                    break;
                }
                case IDC_OEM_TIER1: 
                {
                    g_nCurrOEMTier = 0;
                    DisplayTierOffer(hDlg);
                    break;
                }
                case IDC_OEM_TIER2: 
                {
                    g_nCurrOEMTier = 1;
                    DisplayTierOffer(hDlg);
                    break;
                }
                case IDC_OEM_TIER3: 
                {
                    g_nCurrOEMTier = 2;
                    DisplayTierOffer(hDlg);
                    break;
                }
            }
		    break;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\paycsv.h ===
//**********************************************************************
// File name: PAYCSV.H
//
//      Definition of CISPCSV
//
// Copyright (c) 1992 - 1996 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _PAYCSV_H_ )
#define _PAYCSV_H_

#define MAX_DISPLAY_NAME    100

#define NUM_PAYCSV_FIELDS   4           // Might only be 3


#define PAYMENT_TYPE_INVALID        0
#define PAYMENT_TYPE_CREDITCARD     1
#define PAYMENT_TYPE_INVOICE        2
#define PAYMENT_TYPE_PHONEBILL      3
#define PAYMENT_TYPE_CUSTOM         4


class CPAYCSV
{
    private:
        // The following members represent the content of a single line from the CSV file.
        TCHAR   m_szDisplayName[MAX_DISPLAY_NAME];
        WORD    m_wPaymentType;
        TCHAR   m_szCustomPayURLPath[MAX_PATH];
        BOOL    m_bLUHNCheck;                      
                
    public:

         CPAYCSV(void) 
         {
            memset(this, 0, sizeof(CPAYCSV));            
         }
         ~CPAYCSV(void) {}
         
        HRESULT ReadOneLine(CCSVFile far *pcCSVFile,BOOL bLUHNFormat);      
        HRESULT ReadFirstLine(CCSVFile far *pcCSVFile, BOOL far *pbLUHNFormat);
       
        void StripQuotes(LPSTR   lpszDst, LPSTR   lpszSrc);
        BOOL    ReadW(WORD far *pw, CCSVFile far *pcCSVFile);
        BOOL    ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile);
        BOOL    ReadSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile);
        BOOL    ReadToEOL(CCSVFile far *pcCSVFile);
   
        LPTSTR   get_szDisplayName(void)
        {
            return m_szDisplayName;
        }   

        LPTSTR   get_szCustomPayURLPath(void)
        {
            return m_szCustomPayURLPath;
        }  

        WORD   get_wPaymentType()
        {
            return m_wPaymentType;
        }
        BOOL   get_bLUHNCheck()
        {
            return m_bLUHNCheck;
        }
        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ols.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  OLS.CPP - Functions for 
//

//  HISTORY:
//  
//  06/02/98  vyung  Created.
//
//*********************************************************************

#include "pre.h"


/*******************************************************************

  NAME:   OLSInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg        - dialog window
            fFirstInit  - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK OLSInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{

    // This is the very last page
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK|PSWIZB_FINISH);

    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_OLS;
    if (!fFirstInit)
    {
        ASSERT(gpWizardState->lpSelectedISPInfo);

        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_OLS_HTML), PAGETYPE_OLS_FINISH);
        
        // Navigate to the Billing HTML
        gpWizardState->lpSelectedISPInfo->DisplayHTML(gpWizardState->lpSelectedISPInfo->get_szBillingFormPath());
           
    }    
    return TRUE;
}

BOOL CALLBACK OLSOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)   
{
    if (fForward)
    {
        IWebBrowser2 *lpWebBrowser;
        
        // Get the Browser Object
        gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
        
        // Process the OLS file items (like registry update, and short cut creation
        gpWizardState->pHTMLWalker->ProcessOLSFile(lpWebBrowser);

        // Set ICW completed bit and remove the getconn icon
        if (gpWizardState->cmnStateData.lpfnCompleteOLS)
            (*gpWizardState->cmnStateData.lpfnCompleteOLS)();
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\pre.h ===
//**********************************************************************
// File name: pre.h
//
//      Used for precompiled headers
//
// Copyright (c) 1993-1996 Microsoft Corporation. All rights reserved.
//**********************************************************************

#if !defined( _PRE_H_)
#define _PRE_H_

#include <windows.h>
#include <windowsx.h>
#include <wchar.h>
#include <ole2.h>
#include <assert.h>
#include <string.h>
#include <ccstock.h>

#include <malloc.h>
#include <wininet.h>
#include <regstr.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <exdisp.h>
#include <mshtmdid.h>

#include "icwunicd.h"
#include "webview.h"
#include "icwcmn.h"
#include "icwhelp.h"
#include "connect.h"
#include "ccsv.h"
#include "ispcsv.h"
#include "paycsv.h"
#include "resource.h"
#include "storage.h"
#include "wizdef.h"
#include "wizard.h"
#include "pagefcns.h"
#include "appdefs.h"
#include "debug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\paycsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

#include "pre.h"

extern CHAR szTempBuffer[];

const CHAR cszLUHN[]    = "LUHN";
const CHAR cszCustURL[] = "CustURL";

#define ReadVerifyW(x)      if (!ReadW(&(x),pcCSVFile))                         \
                            {                                                   \
                                AssertMsg(0,"Invalid WORD in CSV file");        \
                                goto PAYCSVReadOneLineError;                    \
                            }
#define ReadVerifyBOOL(x)   if (!ReadBOOL(&(x),pcCSVFile))                      \
                            {                                                   \
                                AssertMsg(0,"Invalid BOOL in CSV file");        \
                                goto PAYCSVReadOneLineError;                    \
                            }
#define ReadVerifySZ(x,y)   if (!ReadSZ(&x[0],y+sizeof('\0'),pcCSVFile))        \
                            {                                                   \
                                AssertMsg(0,"Invalid STRING in CSV file");      \
                                goto PAYCSVReadOneLineError;                    \
                            }

// Do an strip of Single Quotes from a source string.  The source is formatted as:
// 'some text', and the dest string ends up being
// some text
void CPAYCSV::StripQuotes
(
    LPSTR   lpszDst,
    LPSTR   lpszSrc
)
{
    //lstrcpyn(lpszDst, lpszSrc + 1, lstrlen(lpszSrc) - 1);
    strcpy(lpszDst, lpszSrc + 1);
    lpszDst[strlen(lpszDst) - 1] = '\0';
}

// ############################################################################
BOOL CPAYCSV::ReadW(WORD far *pw, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2W(szTempBuffer,pw));
}

// ############################################################################
BOOL CPAYCSV::ReadBOOL(BOOL far *pbool, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(szTempBuffer,TEMP_BUFFER_LENGTH))
            return FALSE;
    return (FSz2BOOL(szTempBuffer,pbool));
}

// ############################################################################
BOOL CPAYCSV::ReadSZ(LPSTR psz, DWORD dwSize, CCSVFile far *pcCSVFile)
{
    if (!pcCSVFile->ReadToken(psz,dwSize))
            return FALSE;
    return TRUE;
}

// ############################################################################
BOOL CPAYCSV::ReadToEOL(CCSVFile far *pcCSVFile)
{
    return pcCSVFile->SkipTillEOL();
}

HRESULT CPAYCSV::ReadOneLine
(
    CCSVFile    far *pcCSVFile,
    BOOL        bLUHNFormat
)
{
    HRESULT     hr = ERROR_SUCCESS;
    CHAR        szTemp[MAX_ISP_NAME] = "\0";
    WORD        wLUHN;
    CHAR        szDisplayName[MAX_DISPLAY_NAME] = "\0";
    CHAR        szCustomPayURLPath[MAX_PATH] = "\0";

    if (!ReadSZ(szTemp, MAX_ISP_NAME, pcCSVFile))
    {
        hr = ERROR_NO_MORE_ITEMS; // no more enteries
        goto PAYCSVReadOneLineExit;
    }

    if ('\0' == *szTemp)
    {
        hr = ERROR_FILE_NOT_FOUND; // no more enteries
        goto PAYCSVReadOneLineExit;
    }

    // Strip the single quotes from the isp Name
    StripQuotes(szDisplayName, szTemp);

#ifdef UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szDisplayName, MAX_DISPLAY_NAME, m_szDisplayName, MAX_DISPLAY_NAME);
#else
    lstrcpy(m_szDisplayName, szDisplayName);
#endif

    ReadVerifyW(m_wPaymentType);
    
    // If this NOT a LUHN format file, then the next field is the payment custom URL
    if (!bLUHNFormat)
    {
        if (ReadSZ(szTemp, MAX_ISP_NAME, pcCSVFile))
        {
            StripQuotes(szCustomPayURLPath, szTemp);
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szCustomPayURLPath, MAX_PATH, m_szCustomPayURLPath, MAX_PATH);
#else
            lstrcpy(m_szCustomPayURLPath, szCustomPayURLPath);
#endif
        }
        else
        {
            goto PAYCSVReadOneLineError;
        }
    }
    else
    {
        // BUGBUG: The format of the PAYMENT CSV file is not clear, so I am coding this for
        // now to just consume the entry, and move on.  Once the format is clarified, and FORBIN
        // updated, then the real code can be turned on, which should just be a ReadBOOL, followed
        // by the readSZ.
        
        ReadVerifyW(wLUHN);
        m_bLUHNCheck = FALSE;
        
        if (wLUHN == (WORD)1)
        {
            m_bLUHNCheck = TRUE;
        }
        
        // There may now also be a URL
        if (ReadSZ(szTemp, MAX_ISP_NAME, pcCSVFile))
        {
            StripQuotes(szCustomPayURLPath, szTemp);
#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szCustomPayURLPath, MAX_PATH, m_szCustomPayURLPath, MAX_PATH);
#else
            lstrcpy(m_szCustomPayURLPath, szCustomPayURLPath);
#endif
        }
    }        

    ReadToEOL(pcCSVFile);

PAYCSVReadOneLineExit:
    return hr;
    
PAYCSVReadOneLineError:
    hr = ERROR_INVALID_DATA;
    goto PAYCSVReadOneLineExit;
}

HRESULT CPAYCSV::ReadFirstLine
(
    CCSVFile    far *pcCSVFile,
    BOOL        far *pbLUHNFormat
)
{
    CHAR   szTemp[TEMP_BUFFER_LENGTH];
    int     i = 0;
    
    while (TRUE)
    {
        if (!ReadSZ(szTemp, TEMP_BUFFER_LENGTH, pcCSVFile))
            return(ERROR_INVALID_DATA);
            
        if (_strcmpi(szTemp, cszLUHN) == 0)
            *pbLUHNFormat = TRUE;

        if (_strcmpi(szTemp, cszCustURL) == 0)
            break;
            
        // Safety check
        if (i++ > NUM_PAYCSV_FIELDS)
            return (ERROR_INVALID_DATA);
    }
    ReadToEOL(pcCSVFile);
    return (ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\pagefcns.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PAGEFCNS.H - Prototypes for wizard page handler functions
//

//  HISTORY:
//  
//  05/18/98  donaldm  Created.
//
 
#ifndef _PAGEFCNS_H_
#define _PAGEFCNS_H_

// Functions in ISPSEL.CPP
BOOL CALLBACK ISPSelectInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPSelectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPSelectNotifyProc(HWND hDlg, WPARAM   wParam, LPARAM    lParam);

// Functions in ISPASEL.CPP
BOOL CALLBACK ISPAutoSelectInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPAutoSelectOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPAutoSelectNotifyProc(HWND hDlg, WPARAM   wParam, LPARAM    lParam);

// Functions in NOOFFER.CPP
BOOL CALLBACK NoOfferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK NoOfferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in USERINFO.CPP
BOOL CALLBACK UserInfoInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK UserInfoOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in BILLOPT.CPP
BOOL CALLBACK BillingOptInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK BillingOptOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in PAYMENT.CPP
BOOL CALLBACK PaymentInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK PaymentOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK PaymentCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in ISPDIAL.CPP
BOOL CALLBACK ISPDialInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPDialPostInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPDialOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPDialCancelProc(HWND hDlg);

// Functions in ISPPAGE.CPP
BOOL CALLBACK ISPPageInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISPPageOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ISPCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in OLS.CPP
BOOL CALLBACK OLSInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK OLSOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in DIALERR.CPP
BOOL CALLBACK DialErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK DialErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK DialErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in SERVERR.CPP
BOOL CALLBACK ServErrorInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ServErrorOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK ServErrorCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);

// Functions in ACFGNOFF.CPP
BOOL CALLBACK ACfgNoofferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ACfgNoofferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in ISDNNOFF.CPP
BOOL CALLBACK ISDNNoofferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK ISDNNoofferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);

// Functions in NOOFFER.CPP
BOOL CALLBACK OEMOfferInitProc(HWND hDlg,BOOL fFirstInit, UINT *puNextPage);
BOOL CALLBACK OEMOfferOKProc(HWND hDlg,BOOL fForward,UINT * puNextPage, BOOL * pfKeepHistory);
BOOL CALLBACK OEMOfferCmdProc(HWND hDlg, WPARAM wParam, LPARAM lParam);


#endif // _PAGEFCNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\ressrcs.inc ===
GETCONN_DIR     = ..\..\

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn

MAJORCOMP=GETCONN
MINORCOMP=ICWRES

RESOURCE_ONLY_DLL=1

TARGETNAME=ICWRES
TARGETTYPE=DYNLINK
TARGETPATH=obj

#SET THE ICWRES FLAG FOR THE IFDEFs
C_DEFINES = -DICWRES -DNASHVILLE

DLLDEF=..\icwres.def

# Make sure this is built before we continue
SYNCHRONIZE_BLOCK = 1

SOURCES=                \
	..\icwconn.rc       \
    ..\icwres.cpp
    
TARGETLIBS= \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\payment.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  PAYMENT.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98    donaldm     Created.
//  08/19/98    donaldm     BUGBUG: The code to collect and save the user
//                          entered data is not optimal in terms of size
//                          and can/should be cleaned up at some future time
//
//*********************************************************************


#include "pre.h"

// Dialog handles for the different payment methods, which will be nested into our mail dialog
HWND hDlgCreditCard         = NULL;
HWND hDlgInvoice            = NULL;
HWND hDlgPhoneBill          = NULL;
HWND hDlgCustom             = NULL;
HWND hDlgCurrentPaymentType = NULL;
BOOL g_bCustomPaymentActive = FALSE;
WORD wCurrentPaymentType    = PAYMENT_TYPE_INVALID;  // NOTE: this must be initialize to a value 
       
HACCEL hAccelCreditCard         = NULL;
HACCEL hAccelInvoice            = NULL;
HACCEL hAccelPhoneBill          = NULL;

#define NUM_EXPIRE_YEARS  38
#define BASE_YEAR         1998
#define MAX_YEAR_LEN      5
#define NUM_EXPIRE_MONTHS 12

const TCHAR cszCustomPayment[] = TEXT("CUSTOMPAYMENT");

INT_PTR CALLBACK CreditCardPaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    // Create a local reference for the ISPData object
    IICWISPData     *pISPData = gpWizardState->pISPData;    
     // in order not to corrupt mem this guy must be big enough to hold 
    // fmax_firstname + "" + max last name
    TCHAR           szTemp[MAX_RES_LEN*2 + 4] = TEXT("\0");
    
    switch (uMsg) 
    {
        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;
    
        case WM_INITDIALOG:
        {
            int i;
                            
            // Initialize the fields we know about
            SYSTEMTIME SystemTime;   // system time structure
            GetLocalTime(&SystemTime);

            // Populate the Expires year listbox
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR));
            TCHAR   szYear[MAX_YEAR_LEN];
            for (i = 0; i < NUM_EXPIRE_YEARS; i++)
            {
                wsprintf (szYear, TEXT("%4d"), i + BASE_YEAR);
                ComboBox_AddString(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR), szYear);
            }                
            // Select the first year in the list if unselected
            if (ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR)) == -1)
            {
                ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_PAYMENT_EXPIREYEAR), 
                                    SystemTime.wYear - BASE_YEAR);
            }
            
            // Populate the Expires Month listbox
            ComboBox_ResetContent(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH));
            for (i = 0; i < NUM_EXPIRE_MONTHS; i++)
            {
                LoadString(ghInstanceResDll, IDS_JANUARY + i, szTemp, ARRAYSIZE(szTemp));
                ComboBox_AddString(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH), szTemp);
            }    
            // Select the first Month in the list if unselected               
            if (ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH)) == -1)
            {
                ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH), SystemTime.wMonth - 1);
            }
            
            if (pISPData->GetDataElement(ISPDATA_USER_FE_NAME))
            {
                lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_FE_NAME));
                SetDlgItemText(hDlg, IDC_PAYMENT_CCNAME, szTemp);
            }
            else
            {
                lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_FIRSTNAME));
                lstrcat(szTemp, TEXT(" "));
                lstrcat(szTemp, pISPData->GetDataElement(ISPDATA_USER_LASTNAME));
                SetDlgItemText(hDlg, IDC_PAYMENT_CCNAME, szTemp);
            }
            
            lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_ADDRESS));
            
            if (LCID_JPN != GetUserDefaultLCID())
            {
                lstrcat(szTemp, TEXT(" "));
                lstrcat(szTemp, pISPData->GetDataElement(ISPDATA_USER_MOREADDRESS));
            } 
            SetDlgItemText(hDlg, IDC_PAYMENT_CCADDRESS, szTemp);

            SetDlgItemText(hDlg, IDC_PAYMENT_CCZIP, pISPData->GetDataElement(ISPDATA_USER_ZIP));
            
            break;
        }
        
        // User clicked next, so we need to collect and validate dat
        case WM_USER_NEXT:
        {
            CPAYCSV far *pcPAYCSV = (CPAYCSV far *)lParam;
            UINT        uCtrlID;
    
            // If the ISP support LUHN, validate the content
            if (pcPAYCSV->get_bLUHNCheck())
            {
                uCtrlID = IDC_PAYMENT_CCNUMBER;
                GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
                if (!pISPData->PutDataElement(ISPDATA_PAYMENT_CARDNUMBER, szTemp, ISPDATA_Validate_Content))
                    goto CreditCardPaymentOKError;
            }
            else
            {
                // no content validate, so just do data present validation
                uCtrlID = IDC_PAYMENT_CCNUMBER;
                GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
                if (!pISPData->PutDataElement(ISPDATA_PAYMENT_CARDNUMBER, szTemp, ISPDATA_Validate_DataPresent))
                    goto CreditCardPaymentOKError;
            }
            
            uCtrlID = IDC_PAYMENT_CCNAME;                    
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_CARDHOLDER, szTemp, ISPDATA_Validate_DataPresent))
                goto CreditCardPaymentOKError;

            uCtrlID = IDC_PAYMENT_CCADDRESS;
            GetDlgItemText(hDlg, IDC_PAYMENT_CCADDRESS, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLADDRESS, szTemp, ISPDATA_Validate_DataPresent))
                goto CreditCardPaymentOKError;
            
            uCtrlID = IDC_PAYMENT_CCZIP;
            GetDlgItemText(hDlg, IDC_PAYMENT_CCZIP, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLZIP, szTemp , ISPDATA_Validate_DataPresent))
                goto CreditCardPaymentOKError;

            // Month must be converted into numeric equivalent
            _itot(ComboBox_GetCurSel(GetDlgItem(hDlg, IDC_PAYMENT_EXPIREMONTH)) + 1, szTemp, 10);
            pISPData->PutDataElement(ISPDATA_PAYMENT_EXMONTH, szTemp , ISPDATA_Validate_None);

            uCtrlID = IDC_PAYMENT_EXPIREYEAR;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_EXYEAR, szTemp , ISPDATA_Validate_Content))
                goto CreditCardPaymentOKError;

            // OK to move on
            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
            
CreditCardPaymentOKError:
            SetFocus(GetDlgItem(hDlg, uCtrlID));            
            SetPropSheetResult(hDlg, FALSE);
            return TRUE;
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

INT_PTR CALLBACK InvoicePaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    // Create a local reference for the ISPData object
    IICWISPData     *pISPData = gpWizardState->pISPData;    
    TCHAR           szTemp[MAX_RES_LEN] = TEXT("\0");
    
    switch (uMsg) 
    {

        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;
        case WM_INITDIALOG:
        {
            SetDlgItemText(hDlg, IDC_PAYMENT_IVADDRESS1, pISPData->GetDataElement(ISPDATA_USER_ADDRESS));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVADDRESS2, pISPData->GetDataElement(ISPDATA_USER_MOREADDRESS));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVCITY, pISPData->GetDataElement(ISPDATA_USER_CITY));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVSTATE, pISPData->GetDataElement(ISPDATA_USER_STATE));
            SetDlgItemText(hDlg, IDC_PAYMENT_IVZIP, pISPData->GetDataElement(ISPDATA_USER_ZIP));
            
            break;
        }
        
        
        // User clicked next, so we need to collect entered data
        case WM_USER_NEXT:
        {   
            UINT    uCtrlID;
            
            uCtrlID = IDC_PAYMENT_IVADDRESS1;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLADDRESS, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            uCtrlID = IDC_PAYMENT_IVADDRESS2;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLEXADDRESS, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            uCtrlID = IDC_PAYMENT_IVCITY;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLCITY, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;
          
            uCtrlID = IDC_PAYMENT_IVSTATE;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLSTATE, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            uCtrlID = IDC_PAYMENT_IVZIP;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLZIP, szTemp, ISPDATA_Validate_DataPresent))
                goto InvoicePaymentOKError;

            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
            
InvoicePaymentOKError:
            SetFocus(GetDlgItem(hDlg, uCtrlID));            
            SetPropSheetResult(hDlg, FALSE);
            return TRUE;
            
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

INT_PTR CALLBACK PhoneBillPaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    // Create a local reference for the ISPData object
    IICWISPData     *pISPData = gpWizardState->pISPData;    
    TCHAR           szTemp[MAX_RES_LEN] = TEXT("\0");
    
    switch (uMsg) 
    {

        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;

        case WM_INITDIALOG:
        {
            TCHAR    szTemp[MAX_RES_LEN];
               
            lstrcpy(szTemp, pISPData->GetDataElement(ISPDATA_USER_FIRSTNAME));
            lstrcat(szTemp, TEXT(" "));
            lstrcat(szTemp, pISPData->GetDataElement(ISPDATA_USER_LASTNAME));
            SetDlgItemText(hDlg, IDC_PAYMENT_PHONEIV_BILLNAME, szTemp);
                
            SetDlgItemText(hDlg, IDC_PAYMENT_PHONEIV_ACCNUM, pISPData->GetDataElement(ISPDATA_USER_PHONE));
            break;
        }
        // User clicked next, so we need to collect and validate dat
        case WM_USER_NEXT:
        {       
            UINT    uCtrlID;
            
            uCtrlID = IDC_PAYMENT_PHONEIV_BILLNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLNAME, szTemp, ISPDATA_Validate_DataPresent))
                goto PhoneBillPaymentOKError;

            uCtrlID = IDC_PAYMENT_PHONEIV_ACCNUM;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_PAYMENT_BILLPHONE, szTemp, ISPDATA_Validate_DataPresent))
                goto PhoneBillPaymentOKError;

            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
            
PhoneBillPaymentOKError:
            SetFocus(GetDlgItem(hDlg, uCtrlID));            
            SetPropSheetResult(hDlg, FALSE);
            return TRUE;
            
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

INT_PTR CALLBACK CustomPaymentDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg) 
    {     
        // This is custom, because for the custom page, we must connect to the window
        // and browse everytime the custom pay page is activated, since an intervening
        // step may have connected the browser to a different window
        case WM_USER_CUSTOMINIT:
        {
            CPAYCSV     far *pcPAYCSV = (CPAYCSV far *)lParam;
            
            gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_PAYMENT_CUSTOM_INV), PAGETYPE_CUSTOMPAY);

            // Navigate to the Custom Payment HTML
            gpWizardState->lpSelectedISPInfo->DisplayHTML(pcPAYCSV->get_szCustomPayURLPath());
            
            // Load any persisted data
            gpWizardState->lpSelectedISPInfo->LoadHistory((BSTR)A2W(cszCustomPayment));
            return TRUE;
        }            
        
        // User clicked next, so we need to collect and validate dat
        case WM_USER_NEXT:
        {
            TCHAR   szQuery[INTERNET_MAX_URL_LENGTH];

            memset(szQuery, 0, sizeof(szQuery));

            // Attach the walker to the curent page
            // Use the Walker to get the query string
            IWebBrowser2 *lpWebBrowser;
        
            gpWizardState->pICWWebView->get_BrowserObject(&lpWebBrowser);
            gpWizardState->pHTMLWalker->AttachToDocument(lpWebBrowser);
            
            gpWizardState->pHTMLWalker->get_FirstFormQueryString(szQuery);
            
            gpWizardState->pISPData->PutDataElement(ISPDATA_PAYMENT_CUSTOMDATA, szQuery, ISPDATA_Validate_None);    
            
            // detach the walker
            gpWizardState->pHTMLWalker->Detach();
                
            SetPropSheetResult(hDlg,TRUE);
            return TRUE;
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            


/*******************************************************************

  NAME:    SwitchPaymentType

********************************************************************/

void SwitchPaymentType
(
    HWND    hDlg, 
    WORD    wPaymentType
)
{
    TCHAR       szTemp[MAX_RES_LEN];
    PAGEINFO    *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
    

    // nothing to do if the payment type has not changed
    if (wPaymentType == wCurrentPaymentType)
        return;
    
    // set the current payment type    
    wCurrentPaymentType = wPaymentType;
            
    // If the custom payment DLG is currently active, then we
    // need to persist any data the user may have entered.
    if (g_bCustomPaymentActive && IsWindowVisible(hDlgCurrentPaymentType))
    {
        gpWizardState->lpSelectedISPInfo->SaveHistory((BSTR)A2W(cszCustomPayment));
    }

    // Hide the current payment type window if there is one
    if (hDlgCurrentPaymentType)
    {
        ShowWindow(hDlgCurrentPaymentType, SW_HIDE);
    }
    //assume false for the weboc event handling
    g_bCustomPaymentActive = FALSE;
    gpWizardState->pISPData->PutDataElement(ISPDATA_PAYMENT_CUSTOMDATA, NULL, ISPDATA_Validate_None);    

    // Create a new payment type DLG if necessary
    switch (wPaymentType)
    {
        case PAYMENT_TYPE_CREDITCARD:
        {
            if (NULL == hDlgCreditCard)
            {
                hDlgCreditCard = CreateDialog(ghInstanceResDll, 
                                              MAKEINTRESOURCE(IDD_PAYMENTTYPE_CREDITCARD), 
                                              hDlg, 
                                              CreditCardPaymentDlgProc);
                // Also load the accelerator
                hAccelCreditCard = LoadAccelerators(ghInstanceResDll, 
                                                    MAKEINTRESOURCE(IDA_PAYMENTTYPE_CREDITCARD));      
            }            
            hDlgCurrentPaymentType = hDlgCreditCard;
            // Set the acclerator table to the nested dialog
            pPageInfo->hAccelNested = hAccelCreditCard;
            LoadString(ghInstanceResDll, IDS_PAYMENT_CREDITCARD, szTemp, ARRAYSIZE(szTemp));
            break;
        }
        
        case PAYMENT_TYPE_INVOICE:
        {
            if (NULL == hDlgInvoice)
            {
                hDlgInvoice = CreateDialog(ghInstanceResDll, 
                                           MAKEINTRESOURCE(IDD_PAYMENTTYPE_INVOICE), 
                                           hDlg, 
                                           InvoicePaymentDlgProc);
                // Also load the accelerator
                hAccelInvoice = LoadAccelerators(ghInstanceResDll, 
                                                 MAKEINTRESOURCE(IDA_PAYMENTTYPE_INVOICE));      
                                           
            }
            hDlgCurrentPaymentType = hDlgInvoice;
            // Set the acclerator table to the nested dialog
            pPageInfo->hAccelNested = hAccelInvoice;
            LoadString(ghInstanceResDll, IDS_PAYMENT_INVOICE, szTemp, ARRAYSIZE(szTemp));
            break;
        }

        case PAYMENT_TYPE_PHONEBILL:
        {
            if (NULL == hDlgPhoneBill)
            {
                hDlgPhoneBill = CreateDialog(ghInstanceResDll, 
                                             MAKEINTRESOURCE(IDD_PAYMENTTYPE_PHONEBILL), 
                                             hDlg, 
                                             PhoneBillPaymentDlgProc);
                // Also load the accelerator
                hAccelPhoneBill = LoadAccelerators(ghInstanceResDll, 
                                                   MAKEINTRESOURCE(IDA_PAYMENTTYPE_PHONEBILL));      
            }                
            hDlgCurrentPaymentType = hDlgPhoneBill;
            // Set the acclerator table to the nested dialog
            pPageInfo->hAccelNested = hAccelPhoneBill;
            LoadString(ghInstanceResDll, IDS_PAYMENT_PHONE, szTemp, ARRAYSIZE(szTemp));
            break;
        }

        case PAYMENT_TYPE_CUSTOM:
        {
            g_bCustomPaymentActive = TRUE;

            if (NULL == hDlgCustom)
            {
                hDlgCustom = CreateDialog(ghInstanceResDll, 
                                          MAKEINTRESOURCE(IDD_PAYMENTTYPE_CUSTOM), 
                                          hDlg, 
                                          CustomPaymentDlgProc);
            }
            hDlgCurrentPaymentType = hDlgCustom;
            // Set the acclerator table to the nested dialog. There is not one
            // in this case
            pPageInfo->hAccelNested = NULL;
            
            // We must force the custom payment type dialog to connect and browse
            CPAYCSV     far *pcPAYCSV;
            HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
                
            // Get the currently selected item's PAYCSV obhect
            pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, ComboBox_GetCurSel( hWndPayment ));
            ASSERT(pcPAYCSV);
            
            SendMessage(hDlgCustom, WM_USER_CUSTOMINIT, 0, (LPARAM)pcPAYCSV);            
            LoadString(ghInstanceResDll, IDS_PAYMENT_CUSTOM, szTemp, ARRAYSIZE(szTemp));
            break;
        }
    }
    
    // Set the combo box string
    SetDlgItemText(hDlg, IDC_PAYMENT_GROUP, szTemp);
    
    // Show the new payment type window
    ShowWindowWithParentControl(hDlgCurrentPaymentType);
}

/*******************************************************************

  NAME:   PaymentInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK PaymentInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL        bRet = TRUE;
    BOOL        bLUHN = FALSE;
    HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
    CPAYCSV     far *pcPAYCSV;
    
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_PAYMENT;
    ASSERT(gpWizardState->lpSelectedISPInfo);
    
    // invalidate the current payment type, so that we refresh everthing
    // in the event that we are reloading this page
    wCurrentPaymentType    = PAYMENT_TYPE_INVALID;
    
    if (fFirstInit || !(gpWizardState->pStorage->Compare(ICW_PAYMENT, 
                                                         gpWizardState->lpSelectedISPInfo->get_szPayCSVPath(), 
                                                         MAX_PATH)))
    {
        CCSVFile    far *pcCSVFile;
        HRESULT     hr;
        int         iIndex;

        // Read the payment .CSV file.
        pcCSVFile = new CCSVFile;
        if (!pcCSVFile) 
        {
            MsgBox(hDlg, IDS_ERR_OUTOFMEMORY, MB_ICONEXCLAMATION,MB_OK);
            return (FALSE);
        }          
        
        gpWizardState->pStorage->Set(ICW_PAYMENT, gpWizardState->lpSelectedISPInfo->get_szPayCSVPath(), MAX_PATH);

        if (!pcCSVFile->Open(gpWizardState->lpSelectedISPInfo->get_szPayCSVPath()))
        {          
            AssertMsg(0, "Cannot open payment .CSV file");
            delete pcCSVFile;
            pcCSVFile = NULL;
            
            return (FALSE);
        }

        // Read the first line, since it contains field headers
        pcPAYCSV = new CPAYCSV;
        if (!pcPAYCSV)
        {
            // BUGBUG Show error message
            return (FALSE);
        }
        
        // Reading the first line also determines whether the csv file is contains
        // the LUHN format.  If it does, we need to keep a record of bLUHN so that the
        // subsequent line can be read correctly.
        if (ERROR_SUCCESS != (hr = pcPAYCSV->ReadFirstLine(pcCSVFile, &bLUHN)))
        {
            // Handle the error case
            delete pcCSVFile;
            pcCSVFile = NULL;
            
            return (FALSE);
        }
        
        delete pcPAYCSV;        // Don't need this one any more
        
        ComboBox_ResetContent(hWndPayment);

        // Read the Payment CSV file
        do {
            // Allocate a new Payment record
            pcPAYCSV = new CPAYCSV;
            if (!pcPAYCSV)
            {
                // BUGBUG Show error message
                bRet = FALSE;
                break;
                
            }
            
            // Read a line from the ISPINFO file
            hr = pcPAYCSV->ReadOneLine(pcCSVFile, bLUHN);
            if (hr == ERROR_NO_MORE_ITEMS)
            {   
                delete pcPAYCSV;        // We don't need this one
                break;
            }
            else if (hr == ERROR_FILE_NOT_FOUND)
            {
                // BUGBUG Show error message
                delete pcPAYCSV;
                pcPAYCSV = NULL;
            }
            else if (hr != ERROR_SUCCESS)
            {
                // BUGBUG Show error message
                delete pcPAYCSV;
                bRet = FALSE;
                break;
            }
            
            // Add the entry to the comboBox
            if (pcPAYCSV)
            {
                iIndex = ComboBox_AddString(hWndPayment, pcPAYCSV->get_szDisplayName());
                ComboBox_SetItemData(hWndPayment, iIndex, pcPAYCSV);
            }
        } while (TRUE);

        // Select the first payment type in the list
        ComboBox_SetCurSel(hWndPayment, 0);

        pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, 0);
        ASSERT(pcPAYCSV);
        SwitchPaymentType(hDlg, pcPAYCSV->get_wPaymentType());

        pcCSVFile->Close();
        delete pcCSVFile;
        pcCSVFile = NULL;
    }
    else
    {
        // Get the currently selected item
        int         iIndex = ComboBox_GetCurSel( hWndPayment );
     
        // Get the payment type, and update the payment area
        pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, iIndex);
        
        ASSERT(pcPAYCSV);

        SwitchPaymentType(hDlg, pcPAYCSV->get_wPaymentType());
     
        // Setup the ISPData object so that is can apply proper validation based on the selected ISP
        // this is necessary here, because the user info page might have been skiped
        gpWizardState->pISPData->PutValidationFlags(gpWizardState->lpSelectedISPInfo->get_dwRequiredUserInputFlags());
        
    } 

    if (!fFirstInit)
    {
        TCHAR       szTemp[MAX_RES_LEN];
        if (LoadString(ghInstanceResDll,
                       ((gpWizardState->lpSelectedISPInfo->get_dwCFGFlag() & ICW_CFGFLAG_SECURE) ? IDS_PAYMENT_SECURE : IDS_PAYMENT_UNSECURE),
                       szTemp,
                       MAX_RES_LEN))
        {
            SetWindowText (GetDlgItem(hDlg,IDC_PAYMENT_SECURE), szTemp);
        }
    }   
    
    return bRet;
}


/*******************************************************************

  NAME:    PaymentOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK PaymentOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)   
{
    // If the custom payment DLG has been shown, then we
    // need to persist any data the user may have entered.
    // We have shown the custom payment DLG, it hDlgCustom is not NULL
    if (NULL != hDlgCustom && IsWindowVisible(hDlgCustom))
    {
        gpWizardState->lpSelectedISPInfo->SaveHistory((BSTR)A2W(cszCustomPayment));
    }
    
    // NOTE that we are leaving the payment page, so the custom payment
    // WEBOC is no longer active
    g_bCustomPaymentActive = FALSE;
    
    if (fForward)
    {
        TCHAR       szTemp[MAX_RES_LEN];
        HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
        CPAYCSV     far *pcPAYCSV;
        int         iIndex;
        
        // Create a local reference for the ISPData object
        IICWISPData *pISPData = gpWizardState->pISPData;    
        
        // Get the payment type
        iIndex = ComboBox_GetCurSel(hWndPayment);
        pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, iIndex);
        wsprintf (szTemp, TEXT("%d"), pcPAYCSV->get_wPaymentType());
        pISPData->PutDataElement(ISPDATA_PAYMENT_TYPE, szTemp, ISPDATA_Validate_None);
        
        // Set the display name
        pISPData->PutDataElement(ISPDATA_PAYMENT_DISPLAYNAME, pcPAYCSV->get_szDisplayName(), ISPDATA_Validate_None);
   
        switch(pcPAYCSV->get_wPaymentType())
        {
            case PAYMENT_TYPE_CREDITCARD:
                if (!SendMessage(hDlgCreditCard, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;
                
            case PAYMENT_TYPE_INVOICE:
                if (!SendMessage(hDlgInvoice, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;

            case PAYMENT_TYPE_PHONEBILL:
                if (!SendMessage(hDlgPhoneBill, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;

            case PAYMENT_TYPE_CUSTOM:
                if (!SendMessage(hDlgCustom, WM_USER_NEXT, 0, (LPARAM)pcPAYCSV))
                    return FALSE;
                break;
        }     
    }
    return TRUE;
}

/*******************************************************************

  NAME:    PaymentCmdProc

********************************************************************/
BOOL CALLBACK PaymentCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    WORD wNotifyCode = HIWORD (wParam);
            
    switch(LOWORD(wParam))
    {
        case IDC_PAYMENTTYPE:
        {
            if (wNotifyCode == CBN_SELENDOK || wNotifyCode == CBN_CLOSEUP)
            {
                // Get the currently selected item
                CPAYCSV     far *pcPAYCSV;
                HWND        hWndPayment = GetDlgItem(hDlg, IDC_PAYMENTTYPE);
                int         iIndex = ComboBox_GetCurSel( hWndPayment );

                // Get the payment type, and update the payment are
                pcPAYCSV = (CPAYCSV *)ComboBox_GetItemData(hWndPayment, iIndex);
                ASSERT(pcPAYCSV);
                SwitchPaymentType(hDlg, pcPAYCSV->get_wPaymentType());
            }
            break;
        }
        default:
            break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\storage.h ===
//**********************************************************************
// File name: STORAGE.H
//
//      Definition of CStorage
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************
#if !defined( _STORAGE_H_ )
#define _STORAGE_H_





// Key to set and get elements from the storage 
typedef enum tagSTORAGEKEY
{
    ICW_PAYMENT = 0,
    
    // MUST LEAVE THIS ITEM AS LAST!!!
    MAX_STORGE_ITEM
} STORAGEKEY;

typedef struct Item 
{
    void*   pData;  // Data  
    DWORD   dwSize; // Size of data
} ITEM;

class CStorage
{
    private:
        ITEM   *m_pItem[MAX_STORGE_ITEM]; // list of items in storage
        
        
    public:

        CStorage(void);
        ~CStorage(void);
         
        BOOL    Set(STORAGEKEY key, void far * pData, DWORD dwSize);
        void*   Get(STORAGEKEY key);
        BOOL    Compare(STORAGEKEY key, void far * pData, DWORD dwSize);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\storage.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1998                   **
//*********************************************************************


#include "pre.h"


CStorage::CStorage(void) 
{
    // initialize all items
    for (int i=0; i<MAX_STORGE_ITEM; i++)
    {
        m_pItem[i] = NULL;
    }
}

CStorage::~CStorage(void) 
{
    // Clean up
    for (int i=0; i<MAX_STORGE_ITEM; i++)
    {
        if (m_pItem[i])
        {
            if (m_pItem[i]->pData)
            {
                delete [] m_pItem[i]->pData;
            }
            delete m_pItem[i];
        }
    }
}

// Associate the data with a key and puts it in storage
BOOL CStorage::Set(
    STORAGEKEY  key,
    void far *  pData,
    DWORD       dwSize
)
{

    // checks for existence of previous item
    if (m_pItem[key])
    {
        // Checks if a new allocation is necessary
        if (m_pItem[key]->dwSize < dwSize )
        {
            // Too small, new reallocation
            if (m_pItem[key]->pData)
            {
                delete [] m_pItem[key]->pData;
                m_pItem[key]->pData = (void*) new CHAR[dwSize];
            }
        }
    }
    else
    {
        // Allocate a new item
        m_pItem[key] = new ITEM;
        if (m_pItem[key])
        {
            m_pItem[key]->pData = (void*) new CHAR[dwSize];
        }
        else
        {
            return FALSE;
        }
    }

    if (m_pItem[key]->pData)
    {
        memcpy( m_pItem[key]->pData, pData, dwSize );
        m_pItem[key]->dwSize = dwSize;
        return TRUE;
    }

    return FALSE;
}



// Get the data with the specified key 
void* CStorage::Get(STORAGEKEY key)
{
    if (key < MAX_STORGE_ITEM)
    {
        if (m_pItem[key])
        {
            return m_pItem[key]->pData;
        }
    }
    return NULL;
}

// Compare the data with the specified key with the data
// pointed by pData with size dwSize
BOOL CStorage::Compare
(
    STORAGEKEY  key,
    void far *  pData,
    DWORD       dwSize
)
{
    // Make sure key is within our range
    if (key < MAX_STORGE_ITEM)
    {
        // make sure item is non-null
        if (m_pItem[key])
        {
            // make sure item has data 
            if (m_pItem[key]->pData && pData)
            {
                if (m_pItem[key]->dwSize == dwSize)
                {
                    if (memcmp(m_pItem[key]->pData,
                        pData,
                        dwSize) == 0)
                    {
                        return TRUE;
                    }
                }
            }
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by icwconn.rc
//
/******************************************
*** THIS FILE IS FOR THE SHARED RES ID  *** 
*** BETWEEN ICWCONN.DLL AND ICWRES.DLL  ***
*******************************************/

#define IDI_CNS                         100

#define IDD_PAGE_ISPSELECT              2300
#define IDD_PAGE_NOOFFER                2301
#define IDD_PAGE_USERINFO               2302
#define IDD_PAGE_BILLINGOPT             2303
#define IDD_PAGE_PAYMENT                2304
#define IDD_PAGE_ISPDIAL                2305
#define IDD_PAGE_ISPDATA                2306
#define IDD_PAGE_OLS                    2307
#define IDD_PAGE_DIALERROR              2308
#define IDD_PAGE_SERVERROR              2309
#define IDD_PAGE_ACFG_ISP               2310
#define IDD_PAGE_ACFG_NOOFFER           2311
#define IDD_PAGE_ISDN_NOOFFER           2312
#define IDD_PAGE_OEMOFFER               2313

#define IDD_PAYMENTTYPE_CREDITCARD      2400
#define IDD_PAYMENTTYPE_INVOICE         2401
#define IDD_PAYMENTTYPE_PHONEBILL       2402
#define IDD_PAYMENTTYPE_CUSTOM          2403

#define IDD_AUTODISCONNECT              2410

#define IDC_STATIC                      -1
#define IDC_LBLTITLE                    999
#define IDC_PAYMENT_CUSTOM_INV          1053
#define IDC_PAYMENT_CCNUMBER_LABEL      1025
#define IDC_PAYMENT_EXPIREMONTH_LABEL   1026
#define IDC_PAYMENT_EXPIREYEAR_LABEL    1027
#define IDC_PAYMENT_CCNAME_LABEL        1028
#define IDC_PAYMENT_CCADDRESS_LABEL     1029
#define IDC_PAYMENT_CCZIP_LABEL         1030
#define IDC_PAYMENT_SECURE              1031
#define IDC_PAYMENT_GROUP               1032
#define IDC_USERINFO_INTRO              1006
#define IDC_ISPLIST_CNSINFO             1003
#define IDC_ISPLIST_CNSICON             1004
#define IDC_BILLINGOPT_INTRO            1016
#define IDC_ISPDIAL_INTRO               1033
#define IDC_ISPDIAL_PHONENUM            1034
#define IDC_ISPDIAL_STATUS              1035
#define IDC_ISPDATA_HTML                1036
#define IDC_PAYMENT_IVADDRESS_LABEL1    1039
#define IDC_PAYMENT_IVADDRESS_LABEL2    1041
#define IDC_PAYMENT_IVCITY_LABEL        1043
#define IDC_PAYMENT_IVSTATE_LABEL       1045
#define IDC_PAYMENT_IVZIP_LABEL         1047
#define IDC_PAYMENT_PHONEIV_BILLNAME_LABEL 1049
#define IDC_PAYMENT_PHONEIV_ACCNUM_LABEL   1051
#define IDC_OLS_HTML                    1054
#define IDC_OLS_TITLE_LABEL             1055
#define IDC_OLS_GROUP                   1056
#define IDC_SERVERR_HELP                1058
#define IDC_DIALERR_HELP                1059
#define IDC_SERVERR_TEXT                1060
#define IDC_DIALERR_TEXT                1061
#define IDC_DIALING_PROPERTIES          1064
#define IDC_ISPDATA_TOSHTML             1066
#define IDC_ISPDATA_CUSTHTML            1068
#define IDC_ISPDATA_TOSINSTRT           1069
#define IDC_ISPSELECT_INTRO             1070
#define IDC_ISPSELECT_LBLISPLIST        1072
#define IDC_ISPSELECT_LBLMARKET         1073
#define IDC_USERINFO_LBLFIRSTNAME       1074
#define IDC_USERINFO_LBLLASTNAME        1075
#define IDC_USERINFO_LBLADDRESS1        1076
#define IDC_USERINFO_LBLADDRESS2        1077
#define IDC_USERINFO_LBLCITY            1078
#define IDC_USERINFO_LBLSTATE           1079
#define IDC_USERINFO_LBLZIP             1080
#define IDC_USERINFO_LBLPHONE           1081
#define IDC_LBLPAYMENTTYPE              1082
#define IDC_PAYMENT_INSTRUCT            1083
#define IDC_ISPDIAL_INSTRUCT            1084
#define IDC_ISPDIAL_LBLPHONENUM         1085
#define IDC_DIALERR_LBLPHONENUMBER      1086
#define IDC_DIALERR_LBLPROPERTIES       1087
#define IDC_DIALERR_LBLHELP             1089
#define IDC_ACFG_INSTRUCT               1090
#define IDC_ACFG_LBLISPLIST             1091
#define IDC_USERINFO_LBLCOMPANYNAME     1092
#define IDC_USERINFO_LBL_FENAME         1093
#define IDC_SAVE_DESKTOP_TEXT           1094

#define IDD_USERINFO_US                 1095
#define IDD_USERINFO_US_NO_COMPANY      1096
#define IDD_USERINFO_FE                 1097
#define IDD_USERINFO_FE_NO_COMPANY      1098
#define IDD_USERINFO_JPN                1099
#define IDD_USERINFO_JPN_NO_COMPANY     1100

#define IDC_NOOFFER1                    1101
#define IDC_NOOFFER2                    1102
#define IDC_NOOFFER3                    1103
#define IDC_AUTOCFG_NOOFFER1            1104
#define IDC_AUTOCFG_NOOFFER2            1105


#define IDC_OEMOFFER_HTML               1200
#define IDC_OEMOFFER_INSTRUCTION        1201

#define IDI_PHONE                       1210
#define IDC_IDLE_TEXT                   1211
#define IDC_DISCONNECT_TEXT             1212
#define IDC_SECONDS                     1213
#define IDC_SEC_TEXT                    1214
#define IDC_ISP_SEL_TITLE               1215
#define IDC_OEM_MULTI_TIER_INTRO        1216
#define IDC_OEM_MULTI_TIER_OFFER_HTML   1217
#define IDC_OEM_TIER1                   1218
#define IDC_OEM_TIER2                   1219
#define IDC_OEM_TIER3                   1220

#define IDA_PROGRESSANIME               1221
#define IDC_OEM_TEASER_HTML1            1222
#define IDC_OEM_TEASER_HTML2            1223
#define IDC_OEM_TEASER_HTML3            1224
#define IDC_TOS_TOSSAVE                 1225
#define IDC_NOOFFER                     1226

#define IDB_WATERMARK256                100
#define IDB_WATERMARK16                 101
#define IDB_BANNER256                   102
#define IDB_BANNER16                    103

#define IDS_APPNAME                     500
#define IDS_QUERYCANCEL                 501
#define IDS_ERR_OUTOFMEMORY             502
#define IDS_ISPSELECT_INTROFMT_MULTIPLE 504
#define IDS_ISPSELECT_INTROFMT_SINGLE   505
#define IDS_USERINFO_TITLE              506
#define IDS_USERINFO_INTROFMT           507
#define IDS_ISPSELECT_CNS               508
#define IDS_ISPSELECT_ONLISTSIGNUP      509
#define IDS_BILLINGOPT_INTROFMT         510
#define IDS_PAYMENT_SECURE              512
#define IDS_PAYMENT_UNSECURE            513
#define IDS_PAYMENT_CREDITCARD          514
#define IDS_ISPDIAL_INTROFMT            516
#define IDS_ISPDIAL_STATUSDIALINGFMT    517
#define IDS_ISPDIAL_STATUSREDIALINGFMT  518
#define IDS_ISPDIAL_STATUSCONNECTINGFMT 519
#define IDS_PAYMENT_INVOICE             521  
#define IDS_PAYMENT_PHONE               522  
#define IDS_PAYMENT_CUSTOM              600

#define IDS_JANUARY                   601  
#define IDS_FEBRUARY                  602  
#define IDS_MARCH                     603  
#define IDS_APRIL                     604  
#define IDS_MAY                       605  
#define IDS_JUNE                      606  
#define IDS_JULY                      607  
#define IDS_AUGUST                    608  
#define IDS_SEPTEMBER                 609  
#define IDS_OCTOBER                   610  
#define IDS_NOVEMBER                  611  
#define IDS_DECEMBER                  612

#define IDS_ISPSELECT_INVALID         634
#define IDS_ERR_TOS_DECLINE           637
#define IDS_DEFAULT_TOS_FILTER        638
#define IDS_DEFAULT_TOS_FILENAME      639

#define IDS_STEP1_TITLE               641
#define IDS_STEP2_TITLE               642
#define IDS_DIALERR_HELP              643
#define IDS_OLS_TITLE                 644
#define IDS_ISPASELECT_TITLE          648

#define IDS_ISP_AUTOCONFIG_OTHER      650

#define IDS_DEFAULT_ISPHTML_FILENAME  652

#define IDS_MOREADDRESS_JPN           653
#define IDS_MOREADDRESS_US            654
#define IDS_ISDN_NOOFFER1             655
#define IDS_ISDN_NOOFFER2             656
#define IDS_ISDN_NOOFFER3             657
#define IDS_ISDN_NOOFFER4             658
#define IDS_AUTOCFG_NOOFFER1          659
#define IDS_ISDN_AUTOCFG_NOOFFER1     660
#define IDS_ISDN_AUTOCFG_NOOFFER2     661
#define IDS_ISDN_AUTOCFG_NOOFFER3     662

#define IDS_OEMOFFER_INSTFMT_MULTIPLE 670
#define IDS_OEMOFFER_INSTFMT_SINGLE   671
#define IDS_DIALING_ERROR_TITLE       672
#define IDS_SERVER_ERROR_TITLE        673
#define IDS_SERVER_ERROR_BADPAGE      674
#define IDS_STEP3_TITLE               675

#define IDS_WIZ97_TITLE_FONT_FACE     676
#define IDS_MANUAL_TITLE              678
#define IDS_STEP2A_TITLE              679
#define IDS_NOT_ENOUGH_DISKSPACE      680
#define IDS_AUTOCFG_EXPLAIN_OTHER     681
#define IDS_SAVE_COPY_CONFIRM_MSG     682
#define IDS_TERMS_FILENAME            683
#define IDS_TERMS_FILENAME_COPY       684
#define IDS_ISPINFO_FILENAME          685
#define IDS_ISPINFO_FILENAME_COPY     686
#define IDS_OEMOFFER_INSTR_MULTITIER  687
#define IDS_OEM_TIER_TOOLTIP          688
#define IDS_NOOFFER                   689
#define IDS_SAVE_ISP_CONFIRM_MSG      690
#define IDS_START_MENU_INFOTIP        20001
#define IDS_START_MENU_NAME           20002
#define IDS_INS_FILE_FRIENDLYNAME     20003

#define IDA_ISPSELECT                   2000 
#define IDA_ACFG_ISP                    2001
#define IDA_USERINFO_US                 2002
#define IDA_USERINFO_FE                 2003
#define IDA_USERINFO_JPN                2004
#define IDA_BILLINGOPT                  2005
#define IDA_PAYMENT                     2006
#define IDA_PAYMENTTYPE_CREDITCARD      2007
#define IDA_PAYMENTTYPE_INVOICE         2008
#define IDA_PAYMENTTYPE_PHONEBILL       2009
#define IDA_ISPDATA                     2010
#define IDA_DIALERROR                   2011
#define IDA_SERVERROR                   2012
#define IDA_OEMOFFER                    2013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\serverr.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  SERVERR.CPP - Functions for server error page
//

//  HISTORY:
//  
//  06/14/98    vyung     created
//
//*********************************************************************

#include "pre.h"
#include "htmlhelp.h"

/*******************************************************************

  NAME:    ServErrorInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
            fFirstInit - TRUE if this is the first time the dialog
            is initialized, FALSE if this InitProc has been called
            before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK ServErrorInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;
   
    HideProgressAnimation();

    if (fFirstInit)
    {   
        if (g_bMalformedPage)
        {
            TCHAR szMsg[MAX_MESSAGE_LEN] = TEXT("\0");
            LoadString(ghInstanceResDll, IDS_SERVER_ERROR_BADPAGE, szMsg, MAX_MESSAGE_LEN);
            SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), szMsg);
            g_bMalformedPage = FALSE;
        }
        else
        {
            BSTR    bstrErrMsg = NULL;
            gpWizardState->pRefDial->get_DialErrorMsg(&bstrErrMsg);
            SetWindowText(GetDlgItem(hDlg, IDC_SERVERR_TEXT), W2A(bstrErrMsg));
            SysFreeString(bstrErrMsg);
        }

         // Fill in the support number
        BSTR bstrSupportPhoneNum     = NULL; 
        
        //Let the isp file override this in IEAK with SupportPhoneNumber=
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {
            gpWizardState->pRefDial->get_ISPSupportPhoneNumber(&bstrSupportPhoneNum);
        }
        
        if (!bstrSupportPhoneNum)
            gpWizardState->pRefDial->get_ISPSupportNumber(&bstrSupportPhoneNum);

        if (bstrSupportPhoneNum)
        {
            ASSERT(gpWizardState->lpSelectedISPInfo);
            gpWizardState->lpSelectedISPInfo->DisplayTextWithISPName(GetDlgItem(hDlg,IDC_SERVERR_HELP), IDS_DIALERR_HELP, W2A(bstrSupportPhoneNum));
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_SHOW);
            SysFreeString(bstrSupportPhoneNum);
        }
        else
        {
            ShowWindow(GetDlgItem(hDlg, IDC_SERVERR_HELP), SW_HIDE);
        }
    }
    else
    {
        KillIdleTimer();
            
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_SERVERR;
    }        
    
    return bRet;
}


/*******************************************************************

  NAME:    ServErrorOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
            fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
            puNextPage - if 'Next' was pressed,
            proc can fill this in with next page to go to.  This
            parameter is ingored if 'Back' was pressed.
            pfKeepHistory - page will not be kept in history if
            proc fills this in with FALSE.

  EXIT:     returns TRUE to allow page to be turned, FALSE
            to keep the same page.

********************************************************************/
BOOL CALLBACK ServErrorOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    if (fForward)
    {
        *pfKeepHistory = FALSE;
        gpWizardState->bDialExact = TRUE;
        *puNextPage = ORD_PAGE_ISPDIAL;
    }
    else
    {
        BOOL bRetVal;
        // Clear the dial Exact state var so that when we get to the dialing
        // page, we will regenerate the dial string
        gpWizardState->bDialExact = FALSE;
        gpWizardState->pRefDial->RemoveConnectoid(&bRetVal);
    }
    return TRUE;
}

BOOL CALLBACK ServErrorCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{

    if ((GET_WM_COMMAND_CMD (wParam, lParam) == BN_CLICKED) &&
        (GET_WM_COMMAND_ID  (wParam, lParam) == IDC_DIAL_HELP))
    {
        HtmlHelp(NULL, ICW_HTML_HELP_TROUBLE_TOPIC, HH_DISPLAY_TOPIC, NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\timeout.cpp ===
//**********************************************************************
// File name: timeout.cpp
//
//      Implementation of idle timer
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"

const DWORD cdwIdleMinsTimeout = 5; // 5 minute timeout after a page has been fetched


INT_PTR CALLBACK DisconnectDlgProc (HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HWND s_hwndSecs;
    static DWORD s_dwStartTicks;
    const DWORD cdwSecsTimeout = 30; // Timeout of 30 seconds
    const UINT cuTimerID = 812U;
    int iSecsRemaining;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // Start a one second timer
            s_hwndSecs = GetDlgItem(hwndDlg, IDC_SECONDS);
            SetTimer(hwndDlg, cuTimerID, 1000U, NULL);
            s_dwStartTicks = GetTickCount();
            return TRUE;

        case WM_TIMER:

            iSecsRemaining = cdwSecsTimeout - (int)(GetTickCount() - s_dwStartTicks) / 1000;
            if (iSecsRemaining <= 0)
            {
                KillTimer(hwndDlg, cuTimerID);
                EndDialog(hwndDlg, IDCANCEL);
                return TRUE;
            }

            if (NULL != s_hwndSecs)
            {
                TCHAR szSeconds[16];
                wsprintf(szSeconds, TEXT("%d"), iSecsRemaining);
                SetWindowText(s_hwndSecs, szSeconds);
            }
            return TRUE;

        case WM_COMMAND:
            // IDOK == Stay connected, IDCANCEL == Disconnect
            if (IDOK == wParam || IDCANCEL == wParam)
            {
                KillTimer(hwndDlg, cuTimerID);
                EndDialog(hwndDlg, wParam);
            }

        default:
            return 0;
    }
}

void CALLBACK IdleTimerProc (HWND hWnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
    KillTimer(NULL, gpWizardState->nIdleTimerID);
    gpWizardState->nIdleTimerID = 0;

    if (gpWizardState->hWndMsgBox)
        EnableWindow(gpWizardState->hWndMsgBox,FALSE);

    int iResult = (int)DialogBox(ghInstanceResDll,
                                 MAKEINTRESOURCE(IDD_AUTODISCONNECT),
                                 gpWizardState->hWndWizardApp,
                                 DisconnectDlgProc);

    if (gpWizardState->hWndMsgBox)
    {
        EnableWindow(gpWizardState->hWndMsgBox,TRUE);
        SetActiveWindow(gpWizardState->hWndMsgBox);
    }

    if (iResult == IDCANCEL)
    {
        // Disconnect, and setup so that the user goes to the dial error page
        gpWizardState->pRefDial->DoHangup();

        // Simulate the pressing of the NEXT button.  The ISPPAGE will see that
        // bAutoDisconnected is TRUE, and automatically goto the server error page
        gpWizardState->bAutoDisconnected = TRUE;
        PropSheet_PressButton(gpWizardState->hWndWizardApp,PSBTN_NEXT);

    }
    else
    {
        gpWizardState->nIdleTimerID = SetTimer(NULL, 0, cdwIdleMinsTimeout * 60 * 1000, IdleTimerProc);
    }
}


void StartIdleTimer()
{
   // Start the 5 min inactivity timer
    if (gpWizardState->nIdleTimerID)
    {
       KillTimer(NULL, gpWizardState->nIdleTimerID);
    }
    gpWizardState->nIdleTimerID = SetTimer(NULL, 0, cdwIdleMinsTimeout * 60 * 1000, IdleTimerProc);
}

void KillIdleTimer()
{
    if (gpWizardState->nIdleTimerID)
    {
       KillTimer(NULL, gpWizardState->nIdleTimerID);
       gpWizardState->nIdleTimerID = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\wizard.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  WIZARD.H - central header file for ICWCONN
//

//  HISTORY:
//  
//  05/14/98    donaldm     created it
//

#ifndef _WIZARD_H_
#define _WIZARD_H_

#define WIZ97_TITLE_FONT_PTS    12

#define WM_MYINITDIALOG         WM_USER

#define WM_USER_NEXT            (WM_USER + 100)
#define WM_USER_CUSTOMINIT      (WM_USER + 101)
#define WM_USER_BACK            (WM_USER + 102)

#define MAX_RES_LEN         255
#define SMALL_BUF_LEN       48

extern const VARIANT c_vaEmpty;
//
// BUGBUG: Remove this ugly const to non-const casting if we can
//  figure out how to put const in IDL files.
//
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)


// Globals used by multiple files.
extern WIZARDSTATE* gpWizardState;
extern HINSTANCE    ghInstance;
extern HINSTANCE    ghInstanceResDll;
extern PAGEINFO     PageInfo[];
extern INT          _convert;
extern UINT         g_uExternUIPrev;
extern UINT         g_uExternUINext;
extern BOOL         gfQuitWizard;
extern BOOL         gfUserCancelled;
extern BOOL         gfUserBackedOut;
extern BOOL         gfUserFinished;
extern BOOL         gfBackedUp;
extern BOOL         gfReboot;
extern BOOL         g_bMalformedPage;
extern BOOL         g_bCustomPaymentActive;
extern BOOL         gfISPDialCancel;
// Trace flags
#define TF_APPRENTICE       0x00000010
#define TF_CLASSFACTORY     0x00000020
#define TF_ICWCONN          0x00000040
#define TF_GENDLG           0x00000080
#define TF_ISPSELECT        0x00000100

// Function avalable in UTIL.CPP
LPTSTR  LoadSz                       (UINT idString,LPTSTR lpszBuf,UINT cbBuf);
int     MsgBox                       (HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int     MsgBoxSz                     (HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
void    ShowWindowWithParentControl  (HWND hwndChild);

BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw);
BOOL FSz2W(LPCSTR pSz,WORD far *w);    
BOOL FSz2WEx(LPCSTR pSz,WORD far *w);    //Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2B(LPCSTR pSz,BYTE far *pb);
BOOL FSz2BOOL(LPCSTR pSz,BOOL far *pbool);
BOOL FSz2SPECIAL(LPCSTR pSz,BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt);

HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
);

void WaitForEvent(HANDLE hEvent);

void StartIdleTimer();
void KillIdleTimer();
void ShowProgressAnimation();
void HideProgressAnimation();

// String conversion in UTIL.CPP
LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa,  int nChars);
LPSTR  WINAPI W2AHelper(LPSTR lpa,  LPCWSTR lpw, int nChars);

#ifndef A2WHELPER
#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper
#endif

#ifdef UNICODE
// In this module, A2W and W2A are not required.
#define A2W(lpa)       (lpa)
#define W2A(lpw)       (lpw)
#else  // UNICODE
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA(lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPTSTR) alloca(_convert), lpw, _convert)))
#endif // UNICODE

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#endif  // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94  jeremys  Created.
//  96/03/24  markdu  Replaced memset with ZeroMemory for consistency.
//  96/04/06  markdu  NASH BUG 15653 Use exported autodial API.
//            Need to keep a modified SetInternetConnectoid to set the
//            MSN backup connectoid.
//  96/05/14  markdu  NASH BUG 21706 Removed BigFont functions.
//

#include "pre.h"

HHOOK     g_hhookCBT;              // CBT hook identifier

// function prototypes
VOID _cdecl FormatErrorMessage(LPTSTR pszMsg,DWORD cbMsg,LPTSTR pszFmt,LPTSTR szArg);

/*******************************************************************

  NAME:    ShowWindowWithParentControl

  SYNOPSIS:  Shows a dialog box with the WS_EX_CONTROLPARENT style.

********************************************************************/
void ShowWindowWithParentControl(HWND hwndChild)
{
    // Parent should control us, so the user can tab out of our property sheet
    DWORD dwStyle = GetWindowLong(hwndChild, GWL_EXSTYLE);
    dwStyle = dwStyle | WS_EX_CONTROLPARENT;
    SetWindowLong(hwndChild, GWL_EXSTYLE, dwStyle);
    ShowWindow(hwndChild, SW_SHOW);
}

//****************************************************************************
// Function: CBTProc
//
// Purpose: Callback function of WH_CBT hook
//
// Parameters and return value:
//    See documentation for CBTProc. 
//
// Comments: This function is used to get a copy of the window handle for
// modal message boxes created while ICW is running, so we can make the
// connection timeout dialog be "super modal" in that it can disable even
// these modal message boxes.  This is necessary because the connection timeout
// dialog can popup at any time.
//
//****************************************************************************

LRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam)
{
   LPCBT_CREATEWND lpcbtcreate;
   
   if (nCode < 0)
       return CallNextHookEx(g_hhookCBT, nCode, wParam, lParam); 

   // If a window is being created, and we don't have a copy of the handle yet
   // then we want to make a copy of the handle.
   if (nCode == HCBT_CREATEWND && (NULL == gpWizardState->hWndMsgBox))     
   {
       lpcbtcreate = (LPCBT_CREATEWND)lParam;
       
       // Check if the window being created is a message box. The class name of
       //   a message box is WC_DIALOG since message boxes are just special dialogs.
       //   We can't subclass the message box right away because the window 
       //   procedure of the message box is not set when this hook is called. So
       //   we wait till the hook is called again when one of the message box 
       //   controls are created and then we subclass. This will happen because
       //   the message box has at least one control.
       if (WC_DIALOG == lpcbtcreate->lpcs->lpszClass) 
       {
           gpWizardState->hWndMsgBox = (HWND)wParam;
       }
   }
   else if (nCode == HCBT_DESTROYWND && (HWND)wParam == gpWizardState->hWndMsgBox)
   {
       gpWizardState->hWndMsgBox = NULL;      
   }   
   return 0;          
}

/*******************************************************************

  NAME:    MsgBox

  SYNOPSIS:  Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    TCHAR       szMsgBuf[MAX_RES_LEN+1];
    TCHAR       szSmallBuf[SMALL_BUF_LEN+1];
    HOOKPROC    hkprcCBT;
    int         nResult;
        
    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    LoadSz(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    hkprcCBT = (HOOKPROC)MakeProcInstance((FARPROC)CBTProc, ghInstance);
    
    // Set a task specific CBT hook before calling MessageBox. The CBT hook will
    //    be called when the message box is created and will give us access to 
    //    the window handle of the MessageBox.
    g_hhookCBT = SetWindowsHookEx(WH_CBT, hkprcCBT, ghInstance, GetCurrentThreadId());

    nResult = MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons);
    
    UnhookWindowsHookEx(g_hhookCBT);
    
    FreeProcInstance(hkprcCBT);
    return nResult;
    
}

/*******************************************************************

  NAME:    MsgBoxSz

  SYNOPSIS:  Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
    LoadSz(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

  NAME:    LoadSz

  SYNOPSIS:  Loads specified string resource into buffer

  EXIT:    returns a pointer to the passed-in buffer

  NOTES:    If this function fails (most likely due to low
        memory), the returned buffer will have a leading NULL
        so it is generally safe to use this without checking for
        failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    ASSERT(lpszBuf);

    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        LoadString( ghInstanceResDll, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}


LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    ASSERT(lpa != NULL);
    ASSERT(lpw != NULL);\
    
    // verify that no illegal character present
    // since lpw was allocated based on the size of lpa
    // don't worry about the number of chars
    lpw[0] = '\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    ASSERT(lpw != NULL);
    ASSERT(lpa != NULL);
    
    // verify that no illegal character present
    // since lpa was allocated based on the size of lpw
    // don't worry about the number of chars
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}


// ############################################################################
//inline BOOL FSz2Dw(PCSTR pSz,DWORD *dw)
BOOL FSz2Dw(LPCSTR pSz,DWORD far *dw)
{
    DWORD val = 0;
    while (*pSz)
    {
        if (*pSz >= '0' && *pSz <= '9')
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2DwEx(PCSTR pSz,DWORD *dw)
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2DwEx(LPCSTR pSz,DWORD far *dw)
{
    DWORD val = 0;
    BOOL    bNeg = FALSE;
    while (*pSz)
    {
        if( *pSz == '-' )
        {
            bNeg = TRUE;
            pSz++;
        }
        else if ((*pSz >= '0' && *pSz <= '9'))
        {
            val *= 10;
            val += *pSz++ - '0';
        }
        else
        {
            return FALSE;  //bad number
        }
    }
    if(bNeg)
        val = 0 - val;
        
    *dw = val;
    return (TRUE);
}

// ############################################################################
//inline BOOL FSz2WEx(PCSTR pSz,WORD *w)
//Accepts -1 as a valid number. currently this is used for LCID, since all langs has a LDID == -1
BOOL FSz2WEx(LPCSTR pSz,WORD far *w)
{
    DWORD dw;
    if (FSz2DwEx(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2W(PCSTR pSz,WORD *w)
BOOL FSz2W(LPCSTR pSz,WORD far *w)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *w = (WORD)dw;
        return TRUE;
    }
    return FALSE;
}

// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2B(LPCSTR pSz,BYTE far *pb)
{
    DWORD dw;
    if (FSz2Dw(pSz,&dw))
    {
        *pb = (BYTE)dw;
        return TRUE;
    }
    return FALSE;
}

const CHAR cszFALSE[] = "FALSE";
const CHAR cszTRUE[]  = "TRUE";
// ############################################################################
//inline BOOL FSz2B(PCSTR pSz,BYTE *pb)
BOOL FSz2BOOL(LPCSTR pSz,BOOL far *pbool)
{
    if (_strcmpi(cszFALSE, pSz) == 0)
    {
        *pbool = (BOOL)FALSE;
    }
    else
    {
        *pbool = (BOOL)TRUE;
    }
    return TRUE;
}

BOOL FSz2SPECIAL(LPCSTR pSz,BOOL far *pbool, BOOL far *pbIsSpecial, int far *pInt)
{
    // See if the value is a BOOL (TRUE or FALSE)
    if (_strcmpi(cszFALSE, pSz) == 0)
    {
        *pbool = FALSE;
        *pbIsSpecial = FALSE;
    }
    else if (_strcmpi(cszTRUE, pSz) == 0)
    {
        *pbool = (BOOL)TRUE;
        *pbIsSpecial = FALSE;
    }
    else
    {
        // Not a BOOL, so it must be special
        *pbool = (BOOL)FALSE;
        *pbIsSpecial = TRUE;
        *pInt = atol(pSz); //_ttoi(pSz); 
    }
    return TRUE;
}

HRESULT ConnectToConnectionPoint
(
    IUnknown            *punkThis, 
    REFIID              riidEvent, 
    BOOL                fConnect, 
    IUnknown            *punkTarget, 
    DWORD               *pdwCookie, 
    IConnectionPoint    **ppcpOut
)
{
    // We always need punkTarget, we only need punkThis on connect
    if (!punkTarget || (fConnect && !punkThis))
    {
        return E_FAIL;
    }

    if (ppcpOut)
        *ppcpOut = NULL;

    HRESULT hr;
    IConnectionPointContainer *pcpContainer;

    if (SUCCEEDED(hr = punkTarget->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpContainer)))
    {
        IConnectionPoint *pcp;
        if(SUCCEEDED(hr = pcpContainer->FindConnectionPoint(riidEvent, &pcp)))
        {
            if(fConnect)
            {
                // Add us to the list of people interested...
                hr = pcp->Advise(punkThis, pdwCookie);
                if (FAILED(hr))
                    *pdwCookie = 0;
            }
            else
            {
                // Remove us from the list of people interested...
                hr = pcp->Unadvise(*pdwCookie);
                *pdwCookie = 0;
            }

            if (ppcpOut && SUCCEEDED(hr))
                *ppcpOut = pcp;
            else
                pcp->Release();
                pcp = NULL;    
        }
        pcpContainer->Release();
        pcpContainer = NULL;
    }
    return hr;
}

void WaitForEvent(HANDLE hEvent)
{
    MSG     msg;
    DWORD   dwRetCode;
    HANDLE  hEventList[1];
    hEventList[0] = hEvent;

    while (TRUE)
    {
        // We will wait on window messages and also the named event.
        dwRetCode = MsgWaitForMultipleObjects(1, 
                                          &hEventList[0], 
                                          FALSE, 
                                          300000,            // 5 minutes
                                          QS_ALLINPUT);

        // Determine why we came out of MsgWaitForMultipleObjects().  If
        // we timed out then let's do some TrialWatcher work.  Otherwise
        // process the message that woke us up.
        if (WAIT_TIMEOUT == dwRetCode)
        {
            break;
        }
        else if (WAIT_OBJECT_0 == dwRetCode)
        {
            break;
        }
        else if (WAIT_OBJECT_0 + 1 == dwRetCode)
        {
            while (TRUE)
            {   
                if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    if (WM_QUIT == msg.message)
                    {
                        break;
                    }
                    else if ((msg.message == WM_KEYDOWN) && (msg.wParam == VK_ESCAPE))
                    {
                        PropSheet_PressButton(gpWizardState->hWndWizardApp,PSBTN_CANCEL);
                    }                        
                    else
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }                                
                } 
                else
                {
                    break;
                }                   
            }
        }
    }
}

void ShowProgressAnimation()
{
    if (gpWizardState->hwndProgressAnime)
    {
        ShowWindow(gpWizardState->hwndProgressAnime, SW_SHOWNORMAL);  
        Animate_Play (gpWizardState->hwndProgressAnime,0, -1, -1);
    }
}

void HideProgressAnimation()
{
    if (gpWizardState->hwndProgressAnime)
    {
        Animate_Stop(gpWizardState->hwndProgressAnime);        
        ShowWindow(gpWizardState->hwndProgressAnime, SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\userinfo.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  USERINFO.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98    donaldm     Created.
//  08/19/98    donaldm     BUGBUG: The code to collect and save the user
//                          entered data is not optimal in terms of size
//                          and can/should be cleaned up at some future time
//
//*********************************************************************

#include "pre.h"

#define BACK 0
#define NEXT 1

enum DlgLayout
{
    LAYOUT_FE = 0,
    LAYOUT_JPN,
    LAYOUT_US
};

HWND hDlgUserInfoCompany   = NULL;
HWND hDlgUserInfoNoCompany = NULL;
HWND hDlgCurrentUserInfo   = NULL;
WORD g_DlgLayout;

// This function will initialize the data in the user information dialog edit controls.
// The data used to initalize comes from the UserInfo object in ICWHELP.DLL
void InitUserInformation
(
    HWND    hDlg
)
{    
    BOOL        bRetVal;
    IUserInfo   *pUserInfo = gpWizardState->pUserInfo;
    BSTR        bstr;        
        
        
    // Get initial user info data values from the ICWHELP user info object, and
    // set the value in the ISPDATA object
    // we only need to do this 1 time per ICW session
    if(!gpWizardState->bUserEnteredData)
    {
        
        pUserInfo->CollectRegisteredUserInfo(&bRetVal);
        // Set this state varialbe, since the user has seen the user info page
        gpWizardState->bUserEnteredData = TRUE;
    
    }
    // The return value from CollectRegisteredUserInfo is FALSE if there is no data in the
    // registry. In this case we set bWasNoUserInfo so that we can persist it later.  We
    // only want to persis the user info it we complete sucessfully, and if there was
    // no user info.
    gpWizardState->bWasNoUserInfo = !bRetVal;
    
    // Put all the initial values, with no validation
    pUserInfo->get_FirstName(&bstr);
    if (GetDlgItem(hDlg, IDC_USERINFO_FE_NAME))
    {
        SetDlgItemText(hDlg,IDC_USERINFO_FE_NAME, W2A(bstr));
    }
    else
    {
        SetDlgItemText(hDlg, IDC_USERINFO_FIRSTNAME, W2A(bstr));
        SysFreeString(bstr);
        
        pUserInfo->get_LastName(&bstr);
        SetDlgItemText(hDlg, IDC_USERINFO_LASTNAME, W2A(bstr));
    }
    SysFreeString(bstr);
    
    if (GetDlgItem(hDlg, IDC_USERINFO_COMPANYNAME))
    {
        pUserInfo->get_Company(&bstr);
        SetDlgItemText(hDlg, IDC_USERINFO_COMPANYNAME, W2A(bstr));
        SysFreeString(bstr);
    }        
    
    pUserInfo->get_Address1(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_ADDRESS1, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_Address2(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_ADDRESS2, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_City(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_CITY, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_State(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_STATE, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_ZIPCode(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_ZIP, W2A(bstr));
    SysFreeString(bstr);
    
    
    pUserInfo->get_PhoneNumber(&bstr);
    SetDlgItemText(hDlg, IDC_USERINFO_PHONE, W2A(bstr));
    SysFreeString(bstr);
}        

BOOL bValidateSaveUserInformation (HWND hDlg, BOOL fForward)
{
    UINT        uCtrlID;
    BOOL        bValid = FALSE;
    IUserInfo   *pUserInfo = gpWizardState->pUserInfo;
    IICWISPData *pISPData = gpWizardState->pISPData;    
    TCHAR       szTemp[MAX_RES_LEN] = TEXT("\0");
    WORD        wPrevValidationValue = 0;

    if (fForward)
        wPrevValidationValue = ISPDATA_Validate_DataPresent;
    else
        wPrevValidationValue = ISPDATA_Validate_None;

    while (1)
    {
        if (GetDlgItem(hDlg, IDC_USERINFO_FE_NAME))
        {
            uCtrlID = IDC_USERINFO_FE_NAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_FE_NAME, szTemp, wPrevValidationValue))
                break;
               
            // Set the input data into the pUserInfo object
            pUserInfo->put_FirstName(A2W(szTemp));
            
            // Since we used FE_NAME, we need to clear FIRSTNAME and LASTNAME, so they are not sent in the
            // query string
            pISPData->PutDataElement(ISPDATA_USER_FIRSTNAME, NULL, ISPDATA_Validate_None);
            pISPData->PutDataElement(ISPDATA_USER_LASTNAME, NULL, ISPDATA_Validate_None);
        }
        else
        {
            uCtrlID = IDC_USERINFO_FIRSTNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_FIRSTNAME, szTemp, wPrevValidationValue))
                break;
            pUserInfo->put_FirstName(A2W(szTemp));
            
            uCtrlID = IDC_USERINFO_LASTNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_LASTNAME, szTemp, wPrevValidationValue))
                break;
            pUserInfo->put_LastName(A2W(szTemp));
            
            // Since we did not use FE_NAME, we need to clear it
            pISPData->PutDataElement(ISPDATA_USER_FE_NAME, NULL, ISPDATA_Validate_None);
        }
        
        if (GetDlgItem(hDlg, IDC_USERINFO_COMPANYNAME))
        {
            uCtrlID = IDC_USERINFO_COMPANYNAME;
            GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
            if (!pISPData->PutDataElement(ISPDATA_USER_COMPANYNAME, szTemp, wPrevValidationValue))
                break;
            pUserInfo->put_Company(A2W(szTemp));
        }
        else
        {
            pISPData->PutDataElement(ISPDATA_USER_COMPANYNAME, NULL, ISPDATA_Validate_None);
        }
        
        uCtrlID = IDC_USERINFO_ADDRESS1;
        GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_ADDRESS, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_Address1(A2W(szTemp));
        
        // Only validate address 2 if we are in Japanese layout, since FE and US layout
        // have this an on optional field
        uCtrlID = IDC_USERINFO_ADDRESS2;
        GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_MOREADDRESS, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_Address2(A2W(szTemp));
        
        uCtrlID = IDC_USERINFO_CITY;
        GetDlgItemText(hDlg, uCtrlID , szTemp, ARRAYSIZE(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_CITY, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_City(A2W(szTemp));

        uCtrlID = IDC_USERINFO_STATE;
        GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_STATE, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_State(A2W(szTemp));

        uCtrlID = IDC_USERINFO_ZIP;
        GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_ZIP, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_ZIPCode(A2W(szTemp));
        
        uCtrlID = IDC_USERINFO_PHONE;
        GetDlgItemText(hDlg, uCtrlID, szTemp, ARRAYSIZE(szTemp));
        if (!pISPData->PutDataElement(ISPDATA_USER_PHONE, szTemp, wPrevValidationValue))
            break;
        pUserInfo->put_PhoneNumber(A2W(szTemp));
        
        // If we get here, then all fields are valid
        bValid = TRUE;
        break;
    }    
    if (!bValid)    
        SetFocus(GetDlgItem(hDlg, uCtrlID));            
        
    return (bValid);
}

INT_PTR CALLBACK UserInfoDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    switch (uMsg) 
    {
        case WM_CTLCOLORDLG:     
        case WM_CTLCOLORSTATIC:
            if(gpWizardState->cmnStateData.bOEMCustom)
            {
                SetTextColor((HDC)wParam, gpWizardState->cmnStateData.clrText);
                SetBkMode((HDC)wParam, TRANSPARENT);
                return (INT_PTR) GetStockObject(NULL_BRUSH);    
            }
            break;
    
        case WM_SHOWWINDOW:
        {
            if((BOOL)wParam)
                InitUserInformation(hDlg);
            break;
        }
        
        // User clicked next, so we need to collect and validate dat
        case WM_USER_BACK:
        {
            if (bValidateSaveUserInformation(hDlg, BACK))
                SetPropSheetResult(hDlg,TRUE);
            else                
                SetPropSheetResult(hDlg, FALSE);
            return TRUE;
       
        }
        case WM_USER_NEXT:
        {
            if (bValidateSaveUserInformation(hDlg, NEXT))
                SetPropSheetResult(hDlg,TRUE);
            else                
                SetPropSheetResult(hDlg, FALSE);
            return TRUE;
        }
    }
    
    // Default return value if message is not handled
    return FALSE;
}            

/*******************************************************************

  NAME:    SwitchUserInfoType

********************************************************************/
void SwitchUserInfoDlg
(
    HWND    hDlg, 
    BOOL    bNeedCompanyName
)
{
    UINT    idDlg;
    // Hide the current userinfo window if there is one
    if (hDlgCurrentUserInfo)
        ShowWindow(hDlgCurrentUserInfo, SW_HIDE);
    
    // Figure out which template to use
    switch(g_DlgLayout)
    {
        case LAYOUT_FE:
            if (bNeedCompanyName)
                idDlg = IDD_USERINFO_FE;
            else
                idDlg = IDD_USERINFO_FE_NO_COMPANY;
            break;
            
            
        case LAYOUT_JPN:
            if (bNeedCompanyName)
                idDlg = IDD_USERINFO_JPN;
            else
                idDlg = IDD_USERINFO_JPN_NO_COMPANY;
            break;
        
        case LAYOUT_US:
            if (bNeedCompanyName)
                idDlg = IDD_USERINFO_US;
            else
                idDlg = IDD_USERINFO_US_NO_COMPANY;
            break;
    }        
    
    // Create the necessary dialog
    if (bNeedCompanyName)
    {
        if (NULL == hDlgUserInfoCompany)
        {
            hDlgUserInfoCompany = CreateDialog(ghInstanceResDll, 
                                               MAKEINTRESOURCE(idDlg), 
                                               hDlg, 
                                               UserInfoDlgProc);
        }            
        hDlgCurrentUserInfo = hDlgUserInfoCompany;
    }
    else
    {
        if (NULL == hDlgUserInfoNoCompany)
        {
            hDlgUserInfoNoCompany = CreateDialog(ghInstanceResDll, 
                                                   MAKEINTRESOURCE(idDlg), 
                                                   hDlg, 
                                                   UserInfoDlgProc);
        }            
        hDlgCurrentUserInfo = hDlgUserInfoNoCompany;
    }
    
    
    // Show the new payment type window
    ShowWindowWithParentControl(hDlgCurrentUserInfo);
}

/*******************************************************************

  NAME:    UserInfoInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK UserInfoInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // Create a local reference for the ISPData object
    IICWISPData        *pISPData = gpWizardState->pISPData;    
    PAGEINFO            *pPageInfo = (PAGEINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
    
    if (fFirstInit)
    {
        // Figure out which dialog layout to use, FE or US
        // This is a 1 time calculation, since the user cannot change locales while running ICW
        switch (GetUserDefaultLCID())
        {
            case LCID_JPN:
                g_DlgLayout = LAYOUT_JPN;
                // Load the appropriate nested dialog accelerator table
                pPageInfo->hAccelNested = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(IDA_USERINFO_JPN));      
                break;
                
            case LCID_CHT:
            case LCID_S_KOR:
            case LCID_N_KOR:
            case LCID_CHS:
                g_DlgLayout = LAYOUT_FE;
                pPageInfo->hAccelNested = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(IDA_USERINFO_FE));      
                break;
                                
            default:
                g_DlgLayout = LAYOUT_US;            
                pPageInfo->hAccelNested = LoadAccelerators(ghInstanceResDll, 
                                                           MAKEINTRESOURCE(IDA_USERINFO_US));      
                break;
        }
    }
    else
    {
        ASSERT(gpWizardState->lpSelectedISPInfo);

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_USERINFO;
        
        DWORD   dwConfigFlags = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

        // Setup the ISPData object so that is can apply proper validation based on the selected ISP
        pISPData->PutValidationFlags(gpWizardState->lpSelectedISPInfo->get_dwRequiredUserInputFlags());

        // Switch in the correct User Info Dialog template
        SwitchUserInfoDlg(hDlg, dwConfigFlags & ICW_CFGFLAG_USE_COMPANYNAME);

    }    
    return TRUE;
}

/*******************************************************************

  NAME:    UserInfoOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/

BOOL CALLBACK UserInfoOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    // Create a local reference for the ISPData object
    IICWISPData* pISPData      = gpWizardState->pISPData;    
    DWORD        dwConfigFlags = gpWizardState->lpSelectedISPInfo->get_dwCFGFlag();

    if (fForward)
    {
        // Collect, valicate, and save user entered information
        if (dwConfigFlags & ICW_CFGFLAG_USE_COMPANYNAME)
        {
            if (!SendMessage(hDlgUserInfoCompany, WM_USER_NEXT, 0, 0l))
                return FALSE;
        }
        else
        {
            if (!SendMessage(hDlgUserInfoNoCompany, WM_USER_NEXT, 0, 0l))
                return FALSE;
        }        
        // Figure out which page to goto next, based on the config flags
        while (1)
        {           
            if (ICW_CFGFLAG_BILL & dwConfigFlags)
            {
                *puNextPage = ORD_PAGE_BILLINGOPT; 
                break;
            }            
            
            if (ICW_CFGFLAG_PAYMENT & dwConfigFlags)
            {
                *puNextPage = ORD_PAGE_PAYMENT; 
                break;
            }         
            
            // We need to skip both billing and payment pages, so goto the dial page
            *puNextPage = ORD_PAGE_ISPDIAL; 
            break;
        }            
    }
    else
    {
        // Collect, valicate, and save user entered information
        if (dwConfigFlags & ICW_CFGFLAG_USE_COMPANYNAME)
        {
            if (!SendMessage(hDlgUserInfoCompany, WM_USER_BACK, 0, 0l))
                return FALSE;
        }
        else
        {
            if (!SendMessage(hDlgUserInfoNoCompany, WM_USER_BACK, 0, 0l))
                return FALSE;
        }        
    
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn\wizdef.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  WIZDEF.H -   data structures and constants for Internet setup/signup wizard
//

//  HISTORY:
//  
//  05/13/98    donaldm     new for ICW 5.0

#ifndef _WIZDEF_H_
#define _WIZDEF_H_


// Defines
#define MAX_REG_LEN         2048    // max length of registry entries
#define MAX_RES_LEN         255     // max length of string resources
#define SMALL_BUF_LEN       48      // convenient size for small text buffers


#define NUM_WIZARD_PAGES    14      // total number of pages in wizard
#define MAX_PAGE_INDEX      13
#define ISP_INFO_NO_VALIDOFFER   -1
#define MAX_OEM_MUTI_TIER   3

// Data structures

// structure to hold information about wizard state
typedef struct tagWIZARDSTATE  
{
    UINT    uCurrentPage;    // index of current page wizard is on
    
    // keeps a history of which pages were visited, so user can
    // back up and we know the last page completed in case of reboot.
    UINT    uPageHistory[NUM_WIZARD_PAGES]; // array of page #'s we visited
    UINT    uPagesCompleted;         // # of pages in uPageHistory

    BOOL    fNeedReboot;    // reboot needed at end
    BOOL    bDoneWebServDownload;
    BOOL    bDoneWebServRAS;
    BOOL    bDialExact;
    BOOL    bRefDialTerminate;
    BOOL    bParseIspinfo;
    BOOL    bISDNMode;

    int     iRedialCount;

    // Number of different offers types available
    int     iNumOfValidOffers;
    int     iNumOfISDNOffers;
    
    // Image list for ISP select list view
    HIMAGELIST  himlIspSelect;

    CISPCSV FAR *lpSelectedISPInfo;
    
    // Pointer to an OEM tier 1 offer, max of 3
    CISPCSV FAR *lpOEMISPInfo[MAX_OEM_MUTI_TIER];
    UINT    uNumTierOffer;

    BOOL    bShowMoreOffers;            // TRUE if we should show more offers
    
    UINT_PTR nIdleTimerID;
    BOOL     bAutoDisconnected;
    
    HWND    hWndWizardApp;
    HWND    hWndMsgBox;
    
    // ICWHELP objects
    IUserInfo           *pUserInfo;
    IRefDial            *pRefDial;
    IWebGate            *pWebGate;
    IINSHandler         *pINSHandler;
        
    CRefDialEvent       *pRefDialEvents;
    CWebGateEvent       *pWebGateEvents;
    CINSHandlerEvent    *pINSHandlerEvents;

    // ICWWebView Object
    IICWWebView         *pICWWebView;
    IICWWalker          *pHTMLWalker;
    IICWGifConvert      *pGifConvert;
    IICWISPData         *pISPData;    
    CStorage            *pStorage;

    BOOL                bWasNoUserInfo;     // TRUE if there was no user info in the registry
    BOOL                bUserEnteredData;   // TRUE if the user sees the user info page
    
    HANDLE              hEventWebGateDone;
    
    HWND                hwndProgressAnime;
    // State data that is common to both sides of the WIZARD
    CMNSTATEDATA        cmnStateData;
} WIZARDSTATE;


#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\branded.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  BRANDED.C - Functions for OEM/ISP branded first Wizard pages
//

//  HISTORY:
//  
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"
#include "webvwids.h"           // Needed to create an instance of the ICW WebView object

extern UINT GetDlgIDFromIndex(UINT uPageIndex);

// This function is in intro.cpp
BOOL WINAPI ConfigureSystem(HWND hDlg);

/*******************************************************************

  NAME:    BrandedIntroInitProc

  SYNOPSIS:  Called when "Intro" page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK BrandedIntroInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // This is the very first page, so no back is needed
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);

    if (!fFirstInit)
    {
        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_BRANDEDINTRO;
    }
        
    return TRUE;
}

BOOL CALLBACK BrandedIntroPostInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    BOOL    bRet = TRUE;

    if (fFirstInit)
    {
        BOOL bFail = FALSE;
    
        // For the window to paint itself
        UpdateWindow(GetParent(hDlg));
    
        // Co-Create the browser object
        if (FAILED(CoCreateInstance(CLSID_ICWWEBVIEW,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IICWWebView,
                              (LPVOID *)&gpWizardState->pICWWebView)))
        {
            bFail = TRUE;
        }

        // Co-Create the browser object
        if(FAILED(CoCreateInstance(CLSID_ICWWALKER,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IICWWalker,
                              (LPVOID *)&gpWizardState->pHTMLWalker)))
        {
            bFail = TRUE;
        }
        
        if (bFail)
        {
            MsgBox(NULL,IDS_LOADLIB_FAIL,MB_ICONEXCLAMATION,MB_OK);
            bRet = FALSE;
            gfQuitWizard = TRUE;            // Quit the wizard
        }                       
    }
    else
    {
        TCHAR   szURL[INTERNET_MAX_URL_LENGTH];
        
        ASSERT(gpWizardState->pICWWebView);            
        gpWizardState->pICWWebView->ConnectToWindow(GetDlgItem(hDlg, IDC_BRANDEDWEBVIEW), PAGETYPE_BRANDED);

        // Form the URL
        wsprintf (szURL, TEXT("FILE://%s"), g_szBrandedHTML);        

        gpWizardState->pICWWebView->DisplayHTML(szURL);
        PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
    }
    
    return bRet;
}

BOOL CALLBACK BrandedIntroOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);

    if (fForward)
    {
        //Are we in some special branding mode?
        if(gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_IEAKMODE)
        {
            TCHAR         szTemp[MAX_PATH]   = TEXT("\0");
            IWebBrowser2* pIWebBrowser2      = NULL;

            gpWizardState->pICWWebView->get_BrowserObject(&pIWebBrowser2);
            
            ASSERT(pIWebBrowser2);

            gpWizardState->pHTMLWalker->AttachToDocument(pIWebBrowser2);
            gpWizardState->pHTMLWalker->get_IeakIspFile(szTemp);

            if(lstrlen(szTemp) != 0)
            {                
                TCHAR szDrive [_MAX_DRIVE]    = TEXT("\0");
                TCHAR szDir   [_MAX_DIR]      = TEXT("\0");
                _tsplitpath(gpWizardState->cmnStateData.ispInfo.szISPFile, szDrive, szDir, NULL, NULL);
                _tmakepath (gpWizardState->cmnStateData.ispInfo.szISPFile, szDrive, szDir, szTemp, NULL);   
            }
          
            //OK make sure we don't try and download something, JIC.
            gpWizardState->bDoneRefServDownload  = TRUE;
            gpWizardState->bDoneRefServRAS       = TRUE;
            gpWizardState->bStartRefServDownload = TRUE;
            
            // BUGBUG, need to set a legit last page, maybe!
            if (LoadICWCONNUI(GetParent(hDlg), 
                              GetDlgIDFromIndex(ORD_PAGE_BRANDEDINTRO), 
                              gpWizardState->cmnStateData.bOEMCustom ? IDD_PAGE_ENDOEMCUSTOM : IDD_PAGE_END,
                              gpWizardState->cmnStateData.dwFlags))
            {
                if( DialogIDAlreadyInUse( g_uICWCONNUIFirst) )
                {
                    // we're about to jump into the external apprentice, and we don't want
                    // this page to show up in our history list, infact, we need to back
                    // the history up 1, because we are going to come back here directly
                    // from the DLL, not from the history list.
                    
                    *pfKeepHistory = FALSE;
                    *puNextPage = g_uICWCONNUIFirst;
                    
                    // Backup 1 in the history list, since we the external pages navigate back
                    // here, we want this history list to be in the correct spot
                    gpWizardState->uPagesCompleted --;
                }
            }
        }
    }   
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\button.h ===
// This class will implement an owner draw button for the ICW when
// running in Customized App mode. 

#define MAX_BUTTON_TITLE    50

class CICWButton
{
    public:
    
        void DrawButton(HDC hdc, UINT itemState, LPPOINT lppt);
        
        void SetButtonText(LPTSTR   lpszText)
        {
            lstrcpyn(m_szButtonText, lpszText, MAX_BUTTON_TITLE);
        };
        
        void SetYPos(long yPos)
        {
            m_yPos = yPos;
        };
        
        void SetButtonDisplay(BOOL bDisplay)
        {
            m_bDisplayButton = bDisplay;
        };
                    
        HRESULT Enable( BOOL bEnable );
        HRESULT Show( int nShowCmd );
        
        HRESULT GetClientRect( LPRECT lpRect );
        HRESULT CreateButtonWindow(HWND hWndParent, UINT uiCtlID);
        HRESULT SetButtonParams(long        xPos,
                                LPTSTR      lpszPressedBmp,
                                LPTSTR      lpszUnpressedBmp,
                                LPTSTR      lpszFontFace,
                                long        lFontSize,
                                long        lFontWeight,
                                COLORREF    clrFontColor,
                                COLORREF    clrTransparentColor,
                                COLORREF    clrDisabled,
                                long        vAlign);
                
        CICWButton( void );
        ~CICWButton( void );

        HWND        m_hWndButton;             // Window Handle of the button
        long        m_xPos;
        long        m_yPos;
    private:
        
        HBITMAP     m_hbmPressed;
        HBITMAP     m_hbmUnpressed;
        TCHAR       m_szButtonText[MAX_BUTTON_TITLE+1];
        COLORREF    m_clrTransparent;
        COLORREF    m_clrText;
        COLORREF    m_clrDisabledText;
        HFONT       m_hfont;
        
        RECT        m_rcBtnClient;
        UINT        m_vAlign;        
        BOOL        m_bDisplayButton;
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\connect.cpp ===
//**********************************************************************
// File name: connect.cpp
//
//      Implementation of connection point sink objects
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "icwextsn.h"

/*
 * CRefDialEvent::CRefDialEvent
 * CRefDialEvent::~CRefDialEvent
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CRefDialEvent::CRefDialEvent( HWND  hWnd )
{
    m_hWnd = hWnd;
    m_cRef = 0;
}

CRefDialEvent::~CRefDialEvent( void )
{
    assert( m_cRef == 0 );
}


/*
 * CRefDialEvent::QueryInterface
 * CRefDialEvent::AddRef
 * CRefDialEvent::Release
 *
 * Purpose:
 *  IUnknown members for CRefDialEvent object.
 */

STDMETHODIMP CRefDialEvent::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;


    if ( IID_IDispatch == riid || DIID__RefDialEvents == riid )
    {
        *ppv = this;
    }
    
    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CRefDialEvent::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CRefDialEvent::Release(void)
{
    return --m_cRef;
}


//IDispatch
STDMETHODIMP CRefDialEvent::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRefDialEvent::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRefDialEvent::GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ OLECHAR** rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID* rgDispId)
{
    HRESULT hr = ResultFromScode(DISP_E_UNKNOWNNAME);
    return hr;
}

STDMETHODIMP CRefDialEvent::Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID /*riid*/,
            /* [in] */ LCID /*lcid*/,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS* pDispParams,
            /* [out] */ VARIANT* pVarResult,
            /* [out] */ EXCEPINFO* /*pExcepInfo*/,
            /* [out] */ UINT* puArgErr)
{

    switch(dispIdMember)
    {
        case DISPID_RasDialStatus:
        {
            BSTR    bstrDialStatus = NULL;
            
            // Get the Status Text
            if (gpWizardState->iRedialCount > 0)
                gpWizardState->pRefDial->put_Redial(TRUE);
            else
                gpWizardState->pRefDial->put_Redial(FALSE);

            gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);

            SetWindowText(GetDlgItem(m_hWnd, IDC_REFSERV_DIALSTATUS), W2A(bstrDialStatus));
            SysFreeString(bstrDialStatus);
             
            break;
        }
                    
        case DISPID_DownloadProgress:
        {
            long    lNewPos;
            if (pDispParams)
            {
                lNewPos =  pDispParams->rgvarg[0].lVal;
                if (!gpWizardState->bStartRefServDownload)
                {
                    BSTR    bstrDialStatus = NULL;
                    gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);
                    SetWindowText(GetDlgItem(m_hWnd, IDC_REFSERV_DIALSTATUS), W2A(bstrDialStatus));
                    SysFreeString(bstrDialStatus);
                }   
                gpWizardState->bStartRefServDownload = TRUE;

                // Set the Progress Position
                SendDlgItemMessage(m_hWnd, IDC_REFSERV_DIALPROGRESS, PBM_SETPOS, (WORD)lNewPos, 0l);
            }
            
            break;
        }
        case DISPID_DownloadComplete:
        {
            ASSERT(pDispParams);

            if(gpWizardState->lRefDialTerminateStatus != ERROR_CANCELLED)
            {

                if ((gpWizardState->lRefDialTerminateStatus = pDispParams->rgvarg[0].lVal) == ERROR_SUCCESS)
                {
                    gpWizardState->bDoneRefServDownload = TRUE; 

                    BSTR    bstrDialStatus = NULL;
                    gpWizardState->pRefDial->get_DialStatusString(&bstrDialStatus);
                    SetWindowText(GetDlgItem(m_hWnd, IDC_REFSERV_DIALSTATUS), W2A(bstrDialStatus));
                    SysFreeString(bstrDialStatus);
                }

                // Hangup
                gpWizardState->pRefDial->DoHangup();
            
                
                PropSheet_PressButton(GetParent(m_hWnd),PSBTN_NEXT);
            }
            break;
        }
        case DISPID_RasConnectComplete:
        {
            BOOL    bRetVal;
            
            if(gpWizardState->lRefDialTerminateStatus != ERROR_CANCELLED)
            {
                if (pDispParams && pDispParams->rgvarg[0].bVal)
                {
                    // Show the progress bar
                    ShowWindow(GetDlgItem(m_hWnd, IDC_REFSERV_DIALPROGRESS), SW_SHOW);
                
                    gpWizardState->bDoneRefServRAS = TRUE;

                    // Start the Offer Download
                    gpWizardState->pRefDial->DoOfferDownload(&bRetVal);
            
                }
                else
                {
                    // Simulate the press of the NEXT button
                    gpWizardState->pRefDial->DoHangup();

                    PropSheet_PressButton(GetParent(m_hWnd),PSBTN_NEXT);
                }
            }
            
            break;
        }            
        
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\appwnd.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "pre.h"
#include "tutor.h"

extern HWND     RunSignupWizard(HWND hWndOwner);
extern TCHAR    g_szICWStatic[];
extern CICWTutorApp* g_pICWTutorApp; 


#define MIN_WIZARD_WIDTH        686     // Size needed for Large fonts
#define MIN_WIZARD_HEIGHT       470     // This is the default fallback


#define MAX_BORDER_HEIGHT       30      // MAX total height of border above and
                                        // below the wizard buttons

#define DEFAULT_TITLE_TOP       10      // Default top/left position for titles
#define DEFAULT_TITLE_LEFT      10
#include "icwextsn.h"
#include "webvwids.h"           // Needed to create an instance of the ICW WebView object

INT_PTR CALLBACK SizerDlgProc
(
    HWND hDlg, 
    UINT uMsg, 
    WPARAM wParam,
    LPARAM lParam
)
{
    return FALSE;
}            

CICWApp::CICWApp
( 
    void
)
{
    HWND    hDlgSizer;
    RECT    rcDlg;
    
    m_haccel = NULL;
    
    // Use Default wizard page placement
    m_iWizardTop = -1;
    m_iWizardLeft = -1;
    m_hTitleFont = NULL;
    m_clrTitleFont = (COLORREF)GetSysColor(COLOR_WINDOWTEXT);
    m_clrBusyBkGnd = (COLORREF)GetSysColor(COLOR_WINDOW);
    m_hbmFirstPageBkgrnd = NULL;

    hDlgSizer = CreateDialog(g_hInstance, 
                             MAKEINTRESOURCE(IDD_PAGE_SIZER), 
                             GetDesktopWindow(), 
                             SizerDlgProc);
    if (hDlgSizer)
    {   
        GetClientRect(hDlgSizer, &rcDlg);                          
        DestroyWindow(hDlgSizer);
        m_wMinWizardWidth = (WORD)RECTWIDTH(rcDlg);
        m_wMinWizardHeight = (WORD)RECTHEIGHT(rcDlg);
    }
    else
    {
        m_wMinWizardWidth = MIN_WIZARD_WIDTH;
        m_wMinWizardHeight = MIN_WIZARD_HEIGHT;
    }        
}

CICWApp::~CICWApp
( 
    void
)
{
    if (m_hTitleFont)
        DeleteObject(m_hTitleFont);
    
    if (m_hbmFirstPageBkgrnd)    
        DeleteObject(m_hbmFirstPageBkgrnd);
}

// Enumerator proc used to disable the children windows in the
// wizard control
BOOL CALLBACK EnumChildProc
(
    HWND hwnd,      // handle to child window
    LPARAM lParam   // application-defined value
)
{
    // We are only interested in immediate children of the wizard, but
    // not the wizard page DLG, which is a child of the wizard. The 
    // PropSheet_GetCurrentPagehwnd will return the window handle of the
    // current Wizard page, so we can compare against the windows being
    // enumerated
    if ((hwnd != PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages)) 
         && GetParent(hwnd) == (HWND)lParam)
    {
        // Remove the DEFPUSHBITTON style if the child has it
        DWORD dwStyle = GetWindowLong(hwnd,GWL_STYLE);
        SendMessage(hwnd,BM_SETSTYLE,dwStyle & (~BS_DEFPUSHBUTTON),0);

        // Hide and disable the window
        ShowWindow(hwnd, SW_HIDE);
        EnableWindow(hwnd, FALSE);
    }        
    return TRUE;
}

BOOL CICWApp::CreateWizardPages
(
    HWND    hWnd
)
{
    DWORD   dwStyle;
    RECT    rcWizardPage;
    int     iTop = m_iWizardTop;
    int     iLeft = m_iWizardLeft;
    
    gpWizardState->cmnStateData.bOEMCustom = TRUE;
    gpWizardState->cmnStateData.hWndWizardPages = RunSignupWizard(hWnd);
    
     // Parent should control us, so the user can tab out of our property sheet
    dwStyle = GetWindowLong(gpWizardState->cmnStateData.hWndWizardPages, GWL_EXSTYLE);
    dwStyle = dwStyle | WS_EX_CONTROLPARENT;
    SetWindowLong(gpWizardState->cmnStateData.hWndWizardPages, GWL_EXSTYLE, dwStyle);

    // Disable the standard Wizard control windows
    EnumChildWindows(gpWizardState->cmnStateData.hWndWizardPages, 
                    EnumChildProc, 
                    (LPARAM)gpWizardState->cmnStateData.hWndWizardPages);
 
    // Get the client rectangle of the Wizard page.  We will use this
    // for the width and height.  The top/left corner is either specified
    // or computed
    m_hWndFirstWizardPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
    
    // Update the wizard dialog position
    GetWindowRect(m_hWndFirstWizardPage, &rcWizardPage);
    if (-1 == iTop)
    {
        // Start out by allowing for the page and the buttons, going from
        // the bottom up...
        iTop = RECTHEIGHT(m_rcClient) - 
               RECTHEIGHT(rcWizardPage) - 
               GetButtonAreaHeight();
        // If there is still room, leave a border between the buttons
        // and the page               
        if (iTop > 0)
        {
            iTop -= m_iBtnBorderHeight/2;
        }
                    
        // Make sure the top is not in negative space               
        if (iTop < 0)
            iTop = 0;
    }
    
    if (-1 == iLeft)
    {
        if (RECTWIDTH(m_rcClient) > RECTWIDTH(rcWizardPage))
            iLeft = (RECTWIDTH(m_rcClient) - RECTWIDTH(rcWizardPage)) / 2;
        else            
            iLeft = 0;
    }    
   
    MoveWindow(gpWizardState->cmnStateData.hWndWizardPages,
               iLeft,
               iTop, 
               RECTWIDTH(rcWizardPage),
               RECTHEIGHT(rcWizardPage),
               TRUE);

    ShowWindow(gpWizardState->cmnStateData.hWndWizardPages, SW_SHOW);
    return TRUE;
}

void CICWApp::DisplayHTML( void )
{
    if (m_hbmFirstPageBkgrnd)
        gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(m_hbmFirstPageBkgrnd, &m_rcHTML);
    else
        gpWizardState->pICWWebView->SetHTMLBackgroundBitmap(gpWizardState->cmnStateData.hbmBkgrnd, &m_rcHTML);
        
    gpWizardState->pICWWebView->ConnectToWindow(m_hwndHTML, PAGETYPE_BRANDED);

    gpWizardState->pICWWebView->DisplayHTML(m_szOEMHTML);
    

    // We are currently displaying the OEM HTML page
    m_bOnHTMLIntro = TRUE;
}

BOOL CICWApp::InitAppHTMLWindows
( 
    HWND hWnd 
) 
{ 
    // Co-Create the browser object
    if (FAILED(CoCreateInstance(CLSID_ICWWEBVIEW,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IICWWebView,
                              (LPVOID *)&gpWizardState->pICWWebView)))
    {
        return FALSE;
    }

    m_hwndHTML = CreateWindow(TEXT("WebOC"), 
                                    NULL, 
                                    WS_VISIBLE | WS_CHILD, 
                                    m_rcHTML.left,
                                    m_rcHTML.top,
                                    RECTWIDTH(m_rcHTML),
                                    RECTHEIGHT(m_rcHTML),
                                    hWnd, 
                                    NULL, 
                                    g_hInstance, 
                                    NULL); 

    ASSERT(gpWizardState->pICWWebView);            
    
    DisplayHTML();
    return TRUE; 
}

// compute that height of the button area. 
// The button area height will be the height of the largest button plus
// a border (15 pixels above and below.)
// Additionally, the overall client height - the button area must be <= 354 pixels
// which is the area required for the wizard pages in large font mode.
// We can loose the border if necessary, but we will fail if 
// client height - max button is < 354.  In this case this function will return -1
int CICWApp::GetButtonAreaHeight
(
    void
)
{
    RECT    rcBtn;
    int     iWizHeight;
    
    m_iBtnAreaHeight = 0;

    // Go Through each button
    m_BtnBack.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);

    m_BtnNext.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);
            
    m_BtnCancel.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);

    m_BtnFinish.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);
            
    m_BtnTutorial.GetClientRect(&rcBtn);
    if (RECTHEIGHT(rcBtn) > m_iBtnAreaHeight)
        m_iBtnAreaHeight = RECTHEIGHT(rcBtn);
            
    // See if there is enough room for the buttons.
    iWizHeight = RECTHEIGHT(m_rcClient) - m_iBtnAreaHeight;
    if ( iWizHeight < m_wMinWizardHeight)
        return -1;
            
    // Compute the border height.            
    m_iBtnBorderHeight = iWizHeight - m_wMinWizardHeight;
    if (m_iBtnBorderHeight > MAX_BORDER_HEIGHT)
        m_iBtnBorderHeight = MAX_BORDER_HEIGHT;
                    
    // Add the border height to the ret value                    
    m_iBtnAreaHeight += m_iBtnBorderHeight;
    return (m_iBtnAreaHeight);    
}    

BOOL CICWApp::InitAppButtons
(
    HWND    hWnd
)
{
    int     iTopOfButtons;
    TCHAR   szButtonText[MAX_BUTTON_TITLE];

    iTopOfButtons = RECTHEIGHT(m_rcClient) - GetButtonAreaHeight();
    iTopOfButtons += m_iBtnBorderHeight/2;
        
    // Setup the Back button
    LoadString(g_hInstance, IDS_BACK, szButtonText, MAX_BUTTON_TITLE);
    m_BtnBack.SetButtonText(szButtonText);
    m_BtnBack.SetYPos(iTopOfButtons);
    m_BtnBack.CreateButtonWindow(hWnd, IDC_BACK);

    // Setup the Next button
    LoadString(g_hInstance, IDS_NEXT, szButtonText, MAX_BUTTON_TITLE);
    m_BtnNext.SetButtonText(szButtonText);
    m_BtnNext.SetYPos(iTopOfButtons);
    m_BtnNext.CreateButtonWindow(hWnd, IDC_NEXT);

    // Setup the Cancel button
    LoadString(g_hInstance, IDS_CANCEL, szButtonText, MAX_BUTTON_TITLE);
    m_BtnCancel.SetButtonText(szButtonText);
    m_BtnCancel.SetYPos(iTopOfButtons);
    m_BtnCancel.CreateButtonWindow(hWnd, IDC_CANCEL);

    // Setup the Finish button
    LoadString(g_hInstance, IDS_FINISH, szButtonText, MAX_BUTTON_TITLE);
    m_BtnFinish.SetButtonText(szButtonText);
    m_BtnFinish.SetYPos(iTopOfButtons);
    m_BtnFinish.CreateButtonWindow(hWnd, IDC_FINISH);
    m_BtnFinish.Show(SW_HIDE);
    m_BtnFinish.Enable(FALSE);

    // Setup the Tutorial button
    LoadString(g_hInstance, IDS_TUTORIAL, szButtonText, MAX_BUTTON_TITLE);
    m_BtnTutorial.SetButtonText(szButtonText);
    m_BtnTutorial.SetYPos(iTopOfButtons);
    m_BtnTutorial.CreateButtonWindow(hWnd, IDC_TUTORIAL);

    // Disable the back button by default, since we are initially on the first
    // page
    m_BtnBack.Enable(FALSE);

    return TRUE;
}    

void CICWApp::SetWizButtons
(
    HWND hDlg, 
    LPARAM lParam
)
{
    BOOL    bEnabled;

    bEnabled = (lParam & PSWIZB_BACK) != 0;
    m_BtnBack.Enable(bEnabled);

    // Enable/Disable the IDD_NEXT button, and Next gets shown by default
    // bEnabled remembers whether hwndShow should be enabled or not
    bEnabled = (lParam & PSWIZB_NEXT) != 0;
    m_BtnNext.Show(SW_SHOW);
    m_BtnNext.Enable(bEnabled);
    
    // Hide/Disable Finish (this is the default case, and can be overridden below)
    m_BtnFinish.Show(SW_HIDE);
    m_BtnFinish.Enable(FALSE);
    

    // Enable/Disable Show/Hide the IDD_FINISH button
    if (lParam & (PSWIZB_FINISH | PSWIZB_DISABLEDFINISH)) 
    {
        bEnabled = (lParam & PSWIZB_FINISH) != 0;
        m_BtnFinish.Show(SW_SHOW);
        m_BtnFinish.Enable(bEnabled);
        
        m_BtnNext.Show(SW_HIDE);
        m_BtnNext.Enable(FALSE);
    }
}

BOOL CICWApp::CheckButtonFocus
(
    void 
)
{
    int                 i;
    HWND                hwndFocus = GetFocus();
    BOOL                bRet = FALSE;
    const CICWButton    *Btnids[5] = { &m_BtnBack, 
                                        &m_BtnNext, 
                                        &m_BtnFinish, 
                                        &m_BtnCancel,
                                        &m_BtnTutorial };

    for (i = 0; i < ARRAYSIZE(Btnids); i++) 
    {
        if (hwndFocus == Btnids[i]->m_hWndButton)
        {
            bRet = TRUE;
            break;
        }
    }
    return bRet;                    
}

// Determine if any of the ICW buttons have focus, and cycle focus through
// appropriatly.
BOOL CICWApp::CycleButtonFocus
(
    BOOL    bForward
)
{
    int                 i, x;
    HWND                hwndFocus = GetFocus();
    BOOL                bFocusSet = FALSE;
    BOOL                bWrapped = FALSE;
    const CICWButton    *Btnids[5] = { &m_BtnBack, 
                                        &m_BtnNext, 
                                        &m_BtnFinish, 
                                        &m_BtnCancel,
                                        &m_BtnTutorial };


    for (i = 0; i < ARRAYSIZE(Btnids); i++) 
    {
        if (hwndFocus == Btnids[i]->m_hWndButton)
        {
            // Find the next button that can take focus starting with
            // the next button in the list
            if (bForward)
            {
                for (x = i + 1; x < ARRAYSIZE(Btnids); x++)
                {
                    if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                        IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                    {
                        SetFocus(Btnids[x]->m_hWndButton);
                        bFocusSet = TRUE;
                        break;
                    }
                } 
                
                if (!bFocusSet)
                {
                    // Wrap around to the the beginning of the button order
                    bWrapped = TRUE;
                    
                    for (x = 0; x < i; x++)
                    {
                        if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                            IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                        {
                            bFocusSet = TRUE;
                            SetFocus(Btnids[x]->m_hWndButton);
                            break;
                        }
                    }                
                }                
            }
            else
            {
                for (x = i - 1; x >= 0; x--)
                {
                    if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                        IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                    {
                        SetFocus(Btnids[x]->m_hWndButton);
                        bFocusSet = TRUE;
                        break;
                    }
                } 
                
                if (!bFocusSet)
                {
                    bWrapped = TRUE;
                    // Wrap around to the the end of the button order
                    for (x = ARRAYSIZE(Btnids) - 1; x > i; x--)
                    {
                        if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                            IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                        {
                            bFocusSet = TRUE;
                            SetFocus(Btnids[x]->m_hWndButton);
                            break;
                        }
                    }                
                }                
            }                
        }
    }  
    
    // If focus is not on the buttons, and was not set, then set it to the first/last
    // button
    if (!bFocusSet)
    {
        if (bForward)
        {
            // Start at the beginning
            for (x = 0; x < ARRAYSIZE(Btnids); x++)
            {
                if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                    IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                {
                    SetFocus(Btnids[x]->m_hWndButton);
                    break;
                }
            }                
        }
        else
        {
            // Start at the beginning
            for (x = ARRAYSIZE(Btnids) - 1; x >= 0; x--)
            {
                if ((GetWindowLong(Btnids[x]->m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                    IsWindowEnabled(Btnids[x]->m_hWndButton)) 
                {
                    SetFocus(Btnids[x]->m_hWndButton);
                    break;
                }
            }                
        }            
    }
    
    return bWrapped;
}


BOOL CICWApp::InitWizAppWindow
(
    HWND    hWnd
)
{
    if (!InitAppHTMLWindows(hWnd))
        return FALSE;
    
    if (!InitAppButtons(hWnd))
        return FALSE;
 
    // Setup the window that will display the page titles
    m_hwndTitle = CreateWindow(g_szICWStatic, 
                               NULL, 
                               WS_VISIBLE | WS_CHILD, 
                               m_rcTitle.left,
                               m_rcTitle.top,
                               RECTWIDTH(m_rcTitle),
                               RECTHEIGHT(m_rcTitle),
                               hWnd, 
                               NULL, 
                               g_hInstance, 
                               NULL); 
        
    if (NULL == m_hwndTitle)
        return FALSE;
    
    SendMessage(m_hwndTitle, WM_SETFONT, (WPARAM)m_hTitleFont, 0l);    
    ShowWindow(m_hwndTitle, SW_HIDE);        
        
    return TRUE;
}

HWND GetControl
(
    int     iCtlId
)
{
    HWND    hWndCtrl = NULL;
    
    // We should never call GetControl unless we translate a wizard page accelerator
    // which implies that hWndWizardPages must be set
    Assert(gpWizardState->cmnStateData.hWndWizardPages);
    
    HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
    hWndCtrl = GetDlgItem(hWndPage, iCtlId);
       
    // If the control exist, but is not visible, or not enabled, then return NULL
    if (hWndCtrl &&
        (!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_VISIBLE) ||
         !IsWindowEnabled(hWndCtrl))) 
    {
        hWndCtrl = NULL;
    }
    return hWndCtrl;
}

#define MAX_CHILDREN        100         // Reasonable number of children to search
HWND GetNestedControl
(
    int     iCtlId
)
{
    HWND    hWndCtrl = NULL;
    WORD    wCnt = 0;
    
    // We should never call GetControl unless we translate a wizard page accelerator
    // which implies that hWndWizardPages must be set
    Assert(gpWizardState->cmnStateData.hWndWizardPages);
    
    HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
    HWND    hWndNested = GetWindow(hWndPage, GW_CHILD);

    // Search for the child window of the current page that contains the
    // dialog controls    
    do
    {
        wCnt++;             // Prevent infinite looping.
        if (NULL != (hWndCtrl = GetDlgItem(hWndNested, iCtlId)))
            break;          // Found it!!!
            
    }while ((wCnt < MAX_CHILDREN) && 
            (NULL != (hWndNested = GetWindow(hWndNested, GW_HWNDNEXT))));            
       
    // If the control exist, but is not visible, or not enabled, then return NULL
    if (hWndCtrl &&
        (!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_VISIBLE) ||
         !IsWindowEnabled(hWndCtrl))) 
    {
        hWndCtrl = NULL;
    }
    return hWndCtrl;
}

LRESULT CALLBACK CICWApp::ICWAppWndProc
( 
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
)
{
    LPCREATESTRUCT  lpcs;
    LRESULT         lRet = 0l;
    CICWApp         *pICWApp = (CICWApp *)GetWindowLongPtr(hWnd, GWLP_USERDATA);        
    HICON           hIcon;
        
    switch (uMessage)
    {
        case WM_CREATE:
            lpcs = (LPCREATESTRUCT) lParam;

            // Get the Class instance pointer for this window
            pICWApp = (CICWApp *) lpcs->lpCreateParams;
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pICWApp);           
            
            if (!pICWApp->InitWizAppWindow(hWnd))
                lRet = -1;

            hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICWCONN1_ICON));
            SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
            SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
            break;

        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
        {
            // See if the control is an ES_READONLY style edit box, and if
            // so then don't make it transparent
            if (!(GetWindowLong((HWND)lParam, GWL_STYLE) & ES_READONLY))
            {
                HDC hdc = (HDC)wParam;
                
                // If this is the animation control, then set the color to the
                // animation control solid color
                if (ID_BUSY_ANIMATION_WINDOW == GetWindowLong((HWND)lParam, GWL_ID))
                {
                    SetBkColor(hdc, pICWApp->m_clrBusyBkGnd); 
                }
                                    
                SetBkMode(hdc, TRANSPARENT);
                lRet = (LRESULT) GetStockObject(NULL_BRUSH);    
                
                // If this is the Title control, set the color
                if ( pICWApp->m_hwndTitle == (HWND)lParam)
                {
                    SetTextColor(hdc, pICWApp->m_clrTitleFont);
                }
            }                
            break;
        }
        
        case WM_DRAWITEM:
        {
            LPDRAWITEMSTRUCT    lpdis = (LPDRAWITEMSTRUCT)lParam;
            CICWButton          *pBtn;
            POINT               pt;            
            
            pt.x = lpdis->rcItem.left;
            pt.y = lpdis->rcItem.top;
            
            switch (wParam)
            {
                case IDC_BACK:
                    pBtn = &pICWApp->m_BtnBack;
                    break;
                    
                case IDC_NEXT:
                    pBtn = &pICWApp->m_BtnNext;
                    break;
                
                case IDC_FINISH:
                    pBtn = &pICWApp->m_BtnFinish;
                    break;
                    
                case IDC_CANCEL:
                    pBtn = &pICWApp->m_BtnCancel;
                    break;
                    
                case IDC_TUTORIAL:
                    pBtn = &pICWApp->m_BtnTutorial;
                    break;
                    
            }    
            pBtn->DrawButton(lpdis->hDC,    
                             lpdis->itemState,
                             &pt);
            
            break;
        }   
        
        case WM_ERASEBKGND: 
        {
            // Fill in the App Window's update rect with the background bitmap
            FillWindowWithAppBackground(hWnd, (HDC)wParam);
            lRet  = 1L;
            break;
        }          

        case WM_CLOSE:
        {
            if (MsgBox(hWnd,IDS_QUERYCANCEL,
                       MB_ICONQUESTION,MB_YESNO |
                       MB_DEFBUTTON2) == IDYES)
            {
                DestroyWindow(hWnd);
            }   
            break;
        }
        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        // Set the wizard page title
        case WUM_SETTITLE:
        {
            TCHAR   szTitle[MAX_RES_LEN];
            
            if (wParam)
            {
                LoadString((HINSTANCE)wParam, LOWORD(lParam), szTitle, MAX_RES_LEN);
                SetWindowText(pICWApp->m_hwndTitle, szTitle);        
            }                
            else
            {
                SetWindowText(pICWApp->m_hwndTitle, (LPTSTR)lParam);        
            }
            break;
        }        
        
        case WM_COMMAND:
        {
            int     iCtlId = GET_WM_COMMAND_ID(wParam, lParam);
            HWND    hWndCtrl;
            
            switch (iCtlId)
            {
                case IDC_BACK:
                    if ((GetWindowLong(pICWApp->m_BtnBack.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnBack.m_hWndButton)) 
                    {
                        if (pICWApp->m_hWndFirstWizardPage == PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages))
                        {
                            // Hide the wizard pages
                            ShowWindow(gpWizardState->cmnStateData.hWndWizardPages, SW_HIDE);
                            ShowWindow(pICWApp->m_hwndTitle, SW_HIDE);
                            
                            // Show and re-display the HTML page
                            pICWApp->DisplayHTML();
                            ShowWindow(pICWApp->m_hwndHTML, SW_SHOW);
                            pICWApp->m_bOnHTMLIntro = TRUE;
                            
                            // Show the tutorial button
                            pICWApp->m_BtnTutorial.Show(SW_SHOW);
                            pICWApp->m_BtnTutorial.Enable(TRUE);
                            
                            
                            // Disable the Back button
                            pICWApp->m_BtnBack.Enable(FALSE);
                        }
                        else
                        {
                            // Go to the previous page            
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_BACK);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                
                case IDC_NEXT:
                    if ((GetWindowLong(pICWApp->m_BtnNext.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnNext.m_hWndButton)) 
                    {
                    
                        if (pICWApp->m_bOnHTMLIntro)
                        {
                            // Hide the HTML window
                            ShowWindow(pICWApp->m_hwndHTML, SW_HIDE);
                            pICWApp->m_bOnHTMLIntro = FALSE;
                            
                            // Hide the tutorial button
                            pICWApp->m_BtnTutorial.Show(SW_HIDE);
                            pICWApp->m_BtnTutorial.Enable(FALSE);
                            
                            // Show the Title window
                            ShowWindow(pICWApp->m_hwndTitle, SW_SHOW);
                            // Create and Show, or just show the Wizard pages
                            if (!gpWizardState->cmnStateData.hWndWizardPages)
                                pICWApp->CreateWizardPages(hWnd);
                            else
                                ShowWindow(gpWizardState->cmnStateData.hWndWizardPages, SW_SHOW);
                                
                            // Enable the Back button
                            pICWApp->m_BtnBack.Enable(TRUE);
                            
                        }                        
                        else
                        {
                            // Go to the Next page            
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_NEXT);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                     
                case IDC_FINISH:
                    if ((GetWindowLong(pICWApp->m_BtnFinish.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnFinish.m_hWndButton)) 
                    {                         
                    
                        if (pICWApp->m_bOnHTMLIntro)
                        {
                            DestroyWindow(hWnd);
                        }
                        else
                        {
                            // Go to the Next page            
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_FINISH);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                     
                
                case IDC_CANCEL:
                    if ((GetWindowLong(pICWApp->m_BtnCancel.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnCancel.m_hWndButton)) 
                    {                         
                    
                        if (pICWApp->m_bOnHTMLIntro)
                        {
                            if (MsgBox(hWnd,IDS_QUERYCANCEL,
                                               MB_ICONQUESTION,MB_YESNO |
                                               MB_DEFBUTTON2) == IDYES)
                            {
                                DestroyWindow(hWnd);
                            }                                           
                        }                                           
                        else
                        {
                            PropSheet_PressButton(gpWizardState->cmnStateData.hWndWizardPages,PSBTN_CANCEL);
                        }                        
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                    
#ifndef ICWDEBUG
                case IDC_TUTORIAL:
                {
                    // If the Tutorial button is enabled/Visible then run
                    // the tutorial
                    if ((GetWindowLong(pICWApp->m_BtnTutorial.m_hWndButton, GWL_STYLE) & WS_VISIBLE) &&
                         IsWindowEnabled(pICWApp->m_BtnTutorial.m_hWndButton)) 
                    {                                        
                        g_pICWTutorApp->LaunchTutorApp();
                    }                        
                    else
                    {
                        MessageBeep(0);
                    }
                    break;
                }                    
#endif
                                    
                case ID_NEXT_FIELD:
                {
                    if (pICWApp->m_bOnHTMLIntro)
                    {
                        pICWApp->CycleButtonFocus(TRUE);
                    }
                    else
                    {                        
                        HWND    hWndFocus = GetFocus();
                        HWND    hWndTabItem;
                        HWND    hWndFirstTabItem;
                        HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
                        BOOL    bButtonsHaveFocus = pICWApp->CheckButtonFocus();
                        
                        hWndFirstTabItem = GetNextDlgTabItem(hWndPage, 
                                                        NULL, 
                                                        FALSE);
                                                 
                        // If we are on the last item in the tab order, cycle
                        // focus to the buttons
                        hWndTabItem = GetNextDlgTabItem(hWndPage, hWndFirstTabItem, TRUE);
                        if ((hWndFocus == hWndTabItem) ||
                            IsChild(hWndTabItem, hWndFocus))
                        {
                            pICWApp->CycleButtonFocus(TRUE);
                        }
                        else
                        {
                            
                            if (bButtonsHaveFocus)
                            {
                                // Cycle the button focus. If the focus
                                // wraps, this function will fail
                                if (pICWApp->CycleButtonFocus(TRUE))
                                {
                                    // Set focus to the First item in the tab order
                                    SetFocus(hWndFirstTabItem);
                                }
                            }
                            else
                            {
                                // Set focus to the next item in the tab order
                                SetFocus(GetNextDlgTabItem(hWndPage,
                                                           hWndFocus, 
                                                           FALSE));
                            }
                        }                            
                    }                        
                    break;
                }    
                case ID_PREV_FIELD:                                                        
                    if (pICWApp->m_bOnHTMLIntro)
                    {
                        pICWApp->CycleButtonFocus(FALSE);
                    }
                    else
                    {                        
                        HWND    hWndFocus = GetFocus();
                        HWND    hWndFirstTabItem;
                        HWND    hWndPage = PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages);
                        BOOL    bButtonsHaveFocus = pICWApp->CheckButtonFocus();
                        
                        hWndFirstTabItem = GetNextDlgTabItem(hWndPage, 
                                                        NULL, 
                                                        FALSE);
                                                 
                        // If we are on the first item in the tab order, cycle
                        // focus to the buttons
                        if ((hWndFocus == hWndFirstTabItem) ||
                            IsChild(hWndFirstTabItem, hWndFocus))
                        {
                            pICWApp->CycleButtonFocus(FALSE);
                        }
                        else
                        {
                            
                            if (bButtonsHaveFocus)
                            {
                                // Cycle the button focus. If the focus
                                // wraps, this function will fail
                                if (pICWApp->CycleButtonFocus(FALSE))
                                {
                                    // Set focus to the last item in the tab order
                                    SetFocus(GetNextDlgTabItem(hWndPage, hWndFirstTabItem, TRUE));
                                }
                            }
                            else
                            {
                                // Set focus to the prev item in the tab order
                                SetFocus(GetNextDlgTabItem(hWndPage,
                                                           hWndFocus, 
                                                           TRUE));
                            }
                        }                            
                    }                        
                    break;
                
                
                // Radio button group
                case IDC_RUNNEW:
                case IDC_RUNAUTO:
                case IDC_ICWMAN:
                {
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        CheckRadioButton(PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages), 
                                         IDC_RUNNEW, 
                                         IDC_ICWMAN, 
                                         iCtlId);
                        SetFocus(hWndCtrl);
                    }
                    else
                    {
                        MessageBeep(0);
                    }        
                    break;
                }
                
                // Check box. Needs to be toggled
                case IDC_CHECK_BROWSING:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        // Toggle the button check state
                        if (BST_CHECKED == Button_GetCheck(hWndCtrl))
                            Button_SetCheck(hWndCtrl, BST_UNCHECKED);
                        else
                            Button_SetCheck(hWndCtrl, BST_CHECKED);
                            
                        SetFocus(hWndCtrl);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                                            
                // Pushbutton type controls
                case IDC_OEMOFFER_MORE:
                case IDC_DIALERR_PROPERTIES:
                case IDC_ISPDATA_TOSSAVE:
                case IDC_CHANGE_NUMBER:
                case IDC_DIALING_PROPERTIES:
                case IDC_DIAL_HELP:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        HWND    hWndFocus = GetFocus();
                        SendMessage(hWndCtrl, BM_CLICK, 0, 0l);
                        SetFocus(hWndFocus);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                
                // Edit Text and drop down controls. Need to be selected and focused
                case IDC_DIAL_FROM:
                case IDC_DIALERR_PHONENUMBER:
                case IDC_DIALERR_MODEM:
                case IDC_BILLINGOPT_HTML:
                case IDC_PAYMENTTYPE:
                case IDC_ISPMARKETING:
                case IDC_ISPLIST:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        Edit_SetSel(hWndCtrl, 0, -1);
                        SetFocus(hWndCtrl);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                
                // Nested controls
                case IDC_USERINFO_FIRSTNAME:
                case IDC_USERINFO_LASTNAME:
                case IDC_USERINFO_COMPANYNAME:
                case IDC_USERINFO_ADDRESS1:
                case IDC_USERINFO_ADDRESS2:
                case IDC_USERINFO_CITY:
                case IDC_USERINFO_STATE:
                case IDC_USERINFO_ZIP:
                case IDC_USERINFO_PHONE:
                case IDC_USERINFO_FE_NAME:
                case IDC_PAYMENT_CCNUMBER:
                case IDC_PAYMENT_EXPIREMONTH:
                case IDC_PAYMENT_EXPIREYEAR:
                case IDC_PAYMENT_CCNAME:
                case IDC_PAYMENT_CCADDRESS:
                case IDC_PAYMENT_CCZIP:
                case IDC_PAYMENT_IVADDRESS1:
                case IDC_PAYMENT_IVADDRESS2:
                case IDC_PAYMENT_IVCITY:
                case IDC_PAYMENT_IVSTATE:
                case IDC_PAYMENT_IVZIP:
                case IDC_PAYMENT_PHONEIV_BILLNAME:
                case IDC_PAYMENT_PHONEIV_ACCNUM:
                    if (NULL != (hWndCtrl = GetNestedControl(iCtlId)))
                    {
                        Edit_SetSel(hWndCtrl, 0, -1);
                        SetFocus(hWndCtrl);
                    }                        
                    else
                        MessageBeep(0);
                    break;
                
                // Radio button select group    
                case IDC_ISPDATA_TOSACCEPT:
                case IDC_ISPDATA_TOSDECLINE:
                    if (NULL != (hWndCtrl = GetControl(iCtlId)))
                    {
                        CheckRadioButton(PropSheet_GetCurrentPageHwnd(gpWizardState->cmnStateData.hWndWizardPages), 
                                         IDC_ISPDATA_TOSACCEPT, 
                                         IDC_ISPDATA_TOSDECLINE, 
                                         iCtlId);
                        // simulate a button click, so the right WM_COMMAND
                        // gets to the isppage proc                                         
                        SendMessage(hWndCtrl, BM_CLICK, 0, 0l);
                        SetFocus(hWndCtrl);
                    }
                    else
                    {
                        MessageBeep(0);
                    }        
                    break;
                
                default:
                    break;
            
            }
            lRet = 1L;
            break;
        }                   // WM_COMMAND
        
        default:
            return DefWindowProc(hWnd, uMessage, wParam, lParam);
    }
    return lRet;
}

void  CICWApp::CenterWindow
(
    void
) 
{    
    RECT  rcScreen;                         // Screen rect    
    RECT  rcApp;                            // window rect    
    int   nLeft, nTop;                      // Top-left coordinates    
    
    // Get frame window client rect in screen coordinates    
    rcScreen.top = rcScreen.left = 0;       
    rcScreen.right = GetSystemMetrics(SM_CXFULLSCREEN);       
    rcScreen.bottom = GetSystemMetrics(SM_CYFULLSCREEN);    
    
    // Determine the top-left point for the window to be centered    
    GetWindowRect(m_hWndApp, &rcApp);    
    nLeft   = rcScreen.left + ((RECTWIDTH(rcScreen) - RECTWIDTH(rcApp)) / 2);    
    nTop    = rcScreen.top  + ((RECTHEIGHT(rcScreen) - RECTHEIGHT(rcApp)) / 2);    
    if (nLeft < 0) 
        nLeft = 0;    
    if (nTop  < 0) 
        nTop  = 0;     
    
    // Place the dialog    
    MoveWindow(m_hWndApp, nLeft, nTop, RECTWIDTH(rcApp), RECTHEIGHT(rcApp), TRUE);
    return;
}    

HRESULT CICWApp::Initialize
(
    void
)
{   
    HRESULT hr = S_OK;
         
    // Create the Application Window
    WNDCLASSEX  wc; 
    
    //Register the Application window class
    ZeroMemory (&wc, sizeof(WNDCLASSEX));
    wc.style         = CS_GLOBALCLASS;
    wc.cbSize        = sizeof(wc);
    wc.lpszClassName = TEXT("ICWApp");
    wc.hInstance     = g_hInstance;
    wc.lpfnWndProc   = ICWAppWndProc;
    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;
    RegisterClassEx (&wc);
    
    // Compute the HTML rectangle area based on the OEM customizations
    // that have been previously applied
    m_rcHTML.left = 0;
    m_rcHTML.top = 0;
    m_rcHTML.right = m_rcClient.right;
    m_rcHTML.bottom = m_rcClient.bottom - m_iBtnAreaHeight;
   
    // Load the accelerator table
    m_haccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDA_ACCEL));      
    
    // Create the Application Window
    m_hWndApp = CreateWindow( TEXT("ICWApp"), 
                              m_szAppTitle, 
                              WS_BORDER | WS_CAPTION | WS_SYSMENU, 
                              CW_USEDEFAULT, 
                              CW_USEDEFAULT, 
                              RECTWIDTH(m_rcClient) +
                                2*GetSystemMetrics(SM_CXFIXEDFRAME),
                              RECTHEIGHT(m_rcClient) + 
                                GetSystemMetrics(SM_CYCAPTION) +
                                2*GetSystemMetrics(SM_CYFIXEDFRAME),
                              NULL, 
                              NULL, 
                              g_hInstance, 
                              (LPVOID) this); 
    if (m_hWndApp)
    {
        gpWizardState->cmnStateData.hWndApp = m_hWndApp;
        
        // Center the Window
        CenterWindow();                              
        
        // Show the window and paint its contents. 
        ShowWindow(m_hWndApp, SW_SHOW); 
        UpdateWindow(m_hWndApp); 
    }
    else
    {
        hr = E_FAIL;
    }        
    
    return hr;
}

HRESULT CICWApp::SetBackgroundBitmap
(
    LPTSTR lpszBkgrndBmp
)
{
    BITMAP  bmInfo;
    HRESULT hr = E_FAIL;
        
    // Load the Background Bitmap
    if (NULL != (gpWizardState->cmnStateData.hbmBkgrnd = (HBITMAP)LoadImage(g_hInstance, 
                                                               lpszBkgrndBmp, 
                                                               IMAGE_BITMAP, 
                                                               0, 
                                                               0, 
                                                               LR_LOADFROMFILE)))
    {
        
        GetObject(gpWizardState->cmnStateData.hbmBkgrnd, sizeof(BITMAP), (LPVOID) &bmInfo);
        
        // Compute some usefull Rectangles.
        // The client will be the size of the background bitmap
        m_rcClient.left = 0;
        m_rcClient.top = 0;
        m_rcClient.right = bmInfo.bmWidth;
        m_rcClient.bottom = bmInfo.bmHeight;
        
        hr = S_OK;
    }
    
    return hr;
}

HRESULT CICWApp::SetFirstPageBackgroundBitmap
(
    LPTSTR lpszBkgrndBmp
)
{
    BITMAP  bmInfo;
    HRESULT hr = E_FAIL;
        
    // Load the Background Bitmap
    if (NULL != (m_hbmFirstPageBkgrnd = (HBITMAP)LoadImage(g_hInstance, 
                                                           lpszBkgrndBmp, 
                                                           IMAGE_BITMAP, 
                                                           0, 
                                                           0, 
                                                           LR_LOADFROMFILE)))
    {
        
        GetObject(m_hbmFirstPageBkgrnd, sizeof(BITMAP), (LPVOID) &bmInfo);
        
        // Make sure the bitmap is the same size as the main one
        
        if ((RECTWIDTH(m_rcClient) == bmInfo.bmWidth) &&
            (RECTHEIGHT(m_rcClient) == bmInfo.bmHeight))
        {
            hr = S_OK;
        }            
    }
    return hr;
}

HRESULT CICWApp::SetTitleParams
(
    int iTitleTop,
    int iTitleLeft,
    LPTSTR lpszFontFace,
    long lFontPts,
    long lFontWeight,
    COLORREF clrFont
)
{
    LOGFONT     lfTitle;
    HFONT       hOldFont;
    TEXTMETRIC  tm;
    HDC         hdc;
        
    // Fill in the log font for the title
    lfTitle.lfHeight = -MulDiv(lFontPts, GetDeviceCaps(GetDC(NULL), LOGPIXELSY), 72);
    lfTitle.lfWidth = 0; 
    lfTitle.lfEscapement = 0; 
    lfTitle.lfOrientation = 0; 
    lfTitle.lfWeight = lFontWeight; 
    lfTitle.lfItalic = FALSE; 
    lfTitle.lfUnderline = FALSE; 
    lfTitle.lfStrikeOut = FALSE; 
    lfTitle.lfCharSet = DEFAULT_CHARSET; 
    lfTitle.lfOutPrecision = OUT_DEFAULT_PRECIS; 
    lfTitle.lfClipPrecision = CLIP_DEFAULT_PRECIS; 
    lfTitle.lfQuality = DEFAULT_QUALITY; 
    lfTitle.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE; 
    lstrcpy(lfTitle.lfFaceName, lpszFontFace); 
    
    if (NULL == (m_hTitleFont = CreateFontIndirect(&lfTitle)))
        return E_FAIL;
    
    // Compute the area for the title
    if (-1 != iTitleTop)
        m_rcTitle.top = iTitleTop;
    else
        m_rcTitle.top = DEFAULT_TITLE_TOP;

    if (-1 != iTitleLeft)
        m_rcTitle.left = iTitleLeft;
    else
        m_rcTitle.left = DEFAULT_TITLE_LEFT;
    // The right side will be the width of the client, minus the left border        
    m_rcTitle.right = RECTWIDTH(m_rcClient) - m_rcTitle.left;
    
    // The bottom will be the top plus the char height for the font
    if (NULL != (hdc = GetDC(NULL)))
    {
        hOldFont = (HFONT)SelectObject(hdc, m_hTitleFont);
        GetTextMetrics(hdc, &tm);
        SelectObject(hdc, hOldFont);
        ReleaseDC(NULL, hdc);
    }
    else
    {
        return E_FAIL;        
    }
    m_rcTitle.bottom = m_rcTitle.top + tm.tmHeight;
    
    
    // Set the font color
    m_clrTitleFont = clrFont;
    
    return S_OK;
    
}

HRESULT CICWApp::SetWizardWindowTop
(
    int iTop
)
{
    m_iWizardTop = iTop;

    // If default positioning is not selected, then ensure the ICW wizard
    // page will fit
    if (-1 != iTop)    
    {
        if ((m_iWizardTop +  m_wMinWizardHeight) > (RECTHEIGHT(m_rcClient) - m_iBtnAreaHeight))
            return E_FAIL;
    }
    return S_OK;
}

HRESULT CICWApp::SetWizardWindowLeft
(
    int iLeft
)
{
    m_iWizardLeft = iLeft;
    if (-1 != iLeft)    
    {
        if ((iLeft +  m_wMinWizardWidth) > RECTWIDTH(m_rcClient))
            return E_FAIL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\button.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************
#include "pre.h"

// Local private function for drawing transparent bitmaps
static void DrawTransparentBitmap
(
    HDC hdc,                    // Destination DC
    HBITMAP hBitmap,            // The Bitmap to Draw
    long xStart,               // Upper Left starting point
    long yStart,               // Upport Left Starting Point
    COLORREF cTransparentColor
)
{
    BITMAP     bm;
    COLORREF   cColor;
    HBITMAP    bmAndBack, bmAndObject, bmAndMem, bmSave;
    HBITMAP    bmBackOld, bmObjectOld, bmMemOld, bmSaveOld;
    HDC        hdcMem, hdcBack, hdcObject, hdcTemp, hdcSave;
    POINT      ptSize;

    hdcTemp = CreateCompatibleDC(hdc);
    SelectObject(hdcTemp, hBitmap);   // Select the bitmap

    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm);
    ptSize.x = bm.bmWidth;            // Get width of bitmap
    ptSize.y = bm.bmHeight;           // Get height of bitmap
    DPtoLP(hdcTemp, &ptSize, 1);      // Convert from device
                                      // to logical points

    // Create some DCs to hold temporary data.
    hdcBack   = CreateCompatibleDC(hdc);
    hdcObject = CreateCompatibleDC(hdc);
    hdcMem    = CreateCompatibleDC(hdc);
    hdcSave   = CreateCompatibleDC(hdc);

    // Create a bitmap for each DC. DCs are required for a number of
    // GDI functions.

    // Monochrome DC
    bmAndBack   = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    // Monochrome DC
    bmAndObject = CreateBitmap(ptSize.x, ptSize.y, 1, 1, NULL);

    bmAndMem    = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);
    bmSave      = CreateCompatibleBitmap(hdc, ptSize.x, ptSize.y);

    // Each DC must select a bitmap object to store pixel data.
    bmBackOld   = (HBITMAP)SelectObject(hdcBack, bmAndBack);
    bmObjectOld = (HBITMAP)SelectObject(hdcObject, bmAndObject);
    bmMemOld    = (HBITMAP)SelectObject(hdcMem, bmAndMem);
    bmSaveOld   = (HBITMAP)SelectObject(hdcSave, bmSave);

    // Set proper mapping mode.
    SetMapMode(hdcTemp, GetMapMode(hdc));

    // Save the bitmap sent here, because it will be overwritten.
    BitBlt(hdcSave, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC to the color.
    // contained in the parts of the bitmap that should be transparent
    cColor = SetBkColor(hdcTemp, cTransparentColor);

    // Create the object mask for the bitmap by performing a BitBlt
    // from the source bitmap to a monochrome bitmap.
    BitBlt(hdcObject, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCCOPY);

    // Set the background color of the source DC back to the original
    // color.
    SetBkColor(hdcTemp, cColor);

    // Create the inverse of the object mask.
    BitBlt(hdcBack, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, NOTSRCCOPY);

    // Copy the background of the main DC to the destination.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdc, xStart, yStart,
           SRCCOPY);

    // Mask out the places where the bitmap will be placed.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcObject, 0, 0, SRCAND);

    // Mask out the transparent colored pixels on the bitmap.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcBack, 0, 0, SRCAND);

    // XOR the bitmap with the background on the destination DC.
    BitBlt(hdcMem, 0, 0, ptSize.x, ptSize.y, hdcTemp, 0, 0, SRCPAINT);

    // Copy the destination to the screen.
    BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, hdcMem, 0, 0, SRCCOPY);

    // Place the original bitmap back into the bitmap sent here.
    BitBlt(hdcTemp, 0, 0, ptSize.x, ptSize.y, hdcSave, 0, 0, SRCCOPY);

    // Delete the memory bitmaps.
    DeleteObject(SelectObject(hdcBack, bmBackOld));
    DeleteObject(SelectObject(hdcObject, bmObjectOld));
    DeleteObject(SelectObject(hdcMem, bmMemOld));
    DeleteObject(SelectObject(hdcSave, bmSaveOld));

    // Delete the memory DCs.
    DeleteDC(hdcMem);
    DeleteDC(hdcBack);
    DeleteDC(hdcObject);
    DeleteDC(hdcSave);
    DeleteDC(hdcTemp);
}        

CICWButton::CICWButton(void)
{
    m_vAlign = DT_VCENTER;
    m_bDisplayButton = TRUE;
}

CICWButton::~CICWButton( void )
{
    if (m_hbmPressed)
        DeleteObject(m_hbmPressed);

    if (m_hbmUnpressed)        
        DeleteObject(m_hbmUnpressed);
        
    if (m_hfont)
        DeleteObject(m_hfont);
}


HRESULT CICWButton::SetButtonParams
(
    long        xPos,
    LPTSTR      lpszPressedBmp,
    LPTSTR      lpszUnpressedBmp,
    LPTSTR      lpszFontFace,
    long        lFontSize,
    long        lFontWeight,
    COLORREF    clrFontColor,
    COLORREF    clrTransparentColor,
    COLORREF    clrDisabled,
    long        vAlign
)
{
    BITMAP      bmInfo;
    LOGFONT     lfButtonText;

    // Set the Button's xPosition
    m_xPos = xPos;
    
    if (NULL == (m_hbmPressed = (HBITMAP)LoadImage(g_hInstance, 
                                                   lpszPressedBmp, 
                                                   IMAGE_BITMAP, 
                                                   0, 
                                                   0, 
                                                   LR_LOADFROMFILE)))
    {                                                   
        return E_FAIL;
    }        
    if (NULL == (m_hbmUnpressed = (HBITMAP)LoadImage(g_hInstance, 
                                                   lpszUnpressedBmp, 
                                                   IMAGE_BITMAP, 
                                                   0, 
                                                   0, 
                                                   LR_LOADFROMFILE)))
    {                                                   
        return E_FAIL;
    }        
    
    // Set the transparent color
    m_clrTransparent = clrTransparentColor;
    
    // Set the text color
    m_clrText = clrFontColor;

    // Set the Disabled color
    m_clrDisabledText = clrDisabled;
       
    // Set the vertical alignment
    if (-1 != vAlign)
        m_vAlign = vAlign;        
        
    // Fill in the default text log font
    lfButtonText.lfHeight = -lFontSize;
    lfButtonText.lfWidth = 0; 
    lfButtonText.lfEscapement = 0; 
    lfButtonText.lfOrientation = 0; 
    lfButtonText.lfWeight = lFontWeight; 
    lfButtonText.lfItalic = FALSE; 
    lfButtonText.lfUnderline = FALSE; 
    lfButtonText.lfStrikeOut = FALSE; 
    lfButtonText.lfCharSet = DEFAULT_CHARSET; 
    lfButtonText.lfOutPrecision = OUT_DEFAULT_PRECIS; 
    lfButtonText.lfClipPrecision = CLIP_DEFAULT_PRECIS; 
    lfButtonText.lfQuality = DEFAULT_QUALITY; 
    lfButtonText.lfPitchAndFamily = VARIABLE_PITCH | FF_DONTCARE; 
    lstrcpy(lfButtonText.lfFaceName, lpszFontFace); 
    
    // Create the font for drawing the button
    if (NULL == (m_hfont = CreateFontIndirect(&lfButtonText)))
        return E_FAIL;
    
    // Compute the client button area
    if (GetObject(m_hbmUnpressed, sizeof(BITMAP), (LPVOID) &bmInfo))
    {
        m_rcBtnClient.left = 0;
        m_rcBtnClient.top = 0;
        m_rcBtnClient.right = bmInfo.bmWidth;
        m_rcBtnClient.bottom = bmInfo.bmHeight;
        return S_OK;
    }    
    else
    {
        return E_FAIL;
    }
}

HRESULT CICWButton::CreateButtonWindow(HWND hWndParent, UINT uiCtlID)
{
    HRESULT hr = S_OK;
            
    m_hWndButton = CreateWindow( TEXT("Button"), 
                                 NULL, 
                                 BS_OWNERDRAW | WS_VISIBLE | WS_CHILD | WS_TABSTOP, 
                                 m_xPos, 
                                 m_yPos, 
                                 RECTWIDTH(m_rcBtnClient),
                                 RECTHEIGHT(m_rcBtnClient),
                                 hWndParent, 
                                 (HMENU) UlongToPtr(uiCtlID), 
                                 g_hInstance, 
                                 NULL); 
    if (m_hWndButton)
    {   
        ShowWindow(m_hWndButton, m_bDisplayButton ? SW_SHOW : SW_HIDE);
        UpdateWindow(m_hWndButton);                                 
    }
    else
    {
        hr = E_FAIL;
    }        
    return (hr);
}

void CICWButton::DrawButton(HDC hdc, UINT itemState, LPPOINT lppt)
{
    HFONT       hOldFont;
    COLORREF    clrOldColor;
    COLORREF    clrText;
    HBITMAP     hbmUsed;
    DWORD       dwStyle=GetWindowLong(m_hWndButton,GWL_STYLE);
    RECT        rcFocus;
    
    if (itemState & ODS_SELECTED)
        hbmUsed = m_hbmPressed;
    else
        hbmUsed = m_hbmUnpressed;
    
    if (itemState & ODS_DISABLED)
        clrText = m_clrDisabledText;
    else
        clrText = m_clrText;        
    
    DrawTransparentBitmap(hdc,
                          hbmUsed,
                          lppt->x,
                          lppt->y,
                          m_clrTransparent);
    
    hOldFont = (HFONT)SelectObject(hdc, m_hfont);

    clrOldColor = SetTextColor(hdc, clrText);
    
    DrawText(hdc, m_szButtonText, -1, &m_rcBtnClient, m_vAlign | DT_CENTER | DT_SINGLELINE);
    
    SetTextColor(hdc, clrOldColor);
    SelectObject(hdc, hOldFont);
    
    if (itemState & ODS_FOCUS)
    {
        CopyRect(&rcFocus, &m_rcBtnClient);
        DrawText(hdc, m_szButtonText, -1, &rcFocus, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_TOP);
        OffsetRect(&rcFocus, (m_rcBtnClient.left + m_rcBtnClient.right - rcFocus.right) /
                2, (m_rcBtnClient.top + m_rcBtnClient.bottom - rcFocus.bottom) / 2);
        InflateRect(&rcFocus, 10, 1);                
        DrawFocusRect(hdc, &rcFocus);
    }        
    
};

HRESULT CICWButton::GetClientRect
(
    LPRECT lpRect
)
{
    if (!lpRect)
        return E_POINTER;
        
    memcpy(lpRect, &m_rcBtnClient, sizeof(RECT));
        
    return (S_OK);        
}    

HRESULT CICWButton::Enable
(
    BOOL bEnable
)
{
    EnableWindow(m_hWndButton, bEnable);
    return S_OK;

}    

HRESULT CICWButton::Show
(
    int nShowCmd 
)
{
    ShowWindow(m_hWndButton, m_bDisplayButton ? nShowCmd : SW_HIDE);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\clntsrcs.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..

TARGET_BOTH     = 1
USE_MSVCRT      = 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn1;$(SHELL_INC_PATH)

# USE cdecl calling
386_STDCALL = 0
#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = icwconn1
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =
PRECOMPILED_CXX = 1

# Conditional compilation

LINKLIBS =  $(LIBRARY_PATH)\gdi32.lib                   \
            $(LIBRARY_PATH)\kernel32.lib                \
            $(LIBRARY_PATH)\advapi32.lib                \
            $(LIBRARY_PATH)\mpr.lib                     \
            $(LIBRARY_PATH)\comctl32.lib                \
            $(LIBRARY_PATH)\shell32.lib                 \
            $(LIBRARY_PATH)\uuid.lib                    \
            $(LIBRARY_PATH)\ole32.lib                   \
            $(SDK_LIB_PATH)\oleaut32.lib                \
            $(SDK_LIB_PATH)\oledlg.lib                  \
            $(SDK_LIB_PATH)\urlmon.lib                  \
            $(SDK_LIB_PATH)\shlwapi.lib                 \
            $(SHELL_LIB_PATH)\shlwapip.lib              \
            $(SDK_LIB_PATH)\htmlhelp.lib                \
!if defined(NOT_UNICODE)
            $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib     \
!else
            $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib  \
!endif

!if $(386)
UMENTRYABS      = ModuleEntry@0
!else
UMENTRYABS      = ModuleEntry
!endif

#
# List of sources.
#
SOURCES=                   \
        ..\icwconn1.rc     \
        ..\icwconn1.cpp    \
        ..\icwextsn.cpp    \
        ..\icwext.cpp      \
        ..\debug.cpp       \
        ..\intro.cpp       \
        ..\manual.cpp      \
        ..\areacode.cpp    \
        ..\gendlg.cpp      \
        ..\desktop.cpp     \
        ..\reboot.cpp      \
        ..\refdial.cpp     \
        ..\icwhelp.cpp     \
        ..\connect.cpp     \
        ..\end.cpp         \
        ..\dialerr.cpp     \
        ..\multinum.cpp    \
        ..\serverr.cpp     \
        ..\util.cpp        \
        ..\branded.cpp     \
        ..\isperr.cpp     \
        ..\tutor.cpp     \
        ..\sbsintro.cpp \
        ..\appwnd.cpp   \
        ..\button.cpp   \
        ..\icwsupr.cpp


PRECOMPILED_INCLUDE = ..\pre.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\areacode.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  AREACODE.CPP - Functions for 
//

//  HISTORY:
//  
//  05/13/98  donaldm  Created.
//
//*********************************************************************


#include "pre.h"
#include "icwextsn.h"

long lLastLocationID = -1;

void CleanupCombo(HWND hDlg)
{
    HWND hCombo = GetDlgItem(hDlg, IDC_DIAL_FROM);
    for (int i=0; i < ComboBox_GetCount(hCombo); i++)
    {
        DWORD *pdwTemp = (DWORD*)ComboBox_GetItemData(hCombo, i);
        if (pdwTemp)
            delete pdwTemp;
    }
    ComboBox_ResetContent(GetDlgItem(hDlg, IDC_DIAL_FROM));
}

/*******************************************************************

  NAME:    AreaCodeInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
BOOL CALLBACK AreaCodeInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    if (!fFirstInit)
    {   
        short   wNumLocations;
        long    lCurrLocIndex;
        DWORD   dwCountryCode;
        TCHAR   szTemp[MAX_MESSAGE_LEN];
        BOOL    bRetVal;

        if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
            LoadString(g_hInstance, IDS_MANUALOPTS_TITLE, szTemp, MAX_MESSAGE_LEN);
        else
            LoadString(g_hInstance, IDS_STEP1_TITLE, szTemp, MAX_MESSAGE_LEN);

        PropSheet_SetHeaderTitle(GetParent(hDlg), ORD_PAGE_AREACODE, (LPCSTR)szTemp);

        // We can skip the page if we have already downloaded
        gpWizardState->pTapiLocationInfo->GetTapiLocationInfo(&bRetVal);
        gpWizardState->pTapiLocationInfo->get_wNumberOfLocations(&wNumLocations, &lCurrLocIndex);
        
        // Ensure that we only have only 1 location and we never shwon the areacode page
        // Second part of this check is for case where user had more than 1 location and deleted
        // down to one location.  That case, our history told us to come to areacode page but 
        // since wNumLocations == 1, we would go back to refdial page.
        if ((1 == wNumLocations) && (-1 == lLastLocationID))
        {
            // We are happy, so advance to the next page
            BSTR    bstrAreaCode = NULL;

            *puNextPage = ORD_PAGE_REFSERVDIAL;
            
            gpWizardState->pTapiLocationInfo->get_lCountryCode((long *)&dwCountryCode);
            gpWizardState->pTapiLocationInfo->get_bstrAreaCode(&bstrAreaCode);
            
            gpWizardState->cmnStateData.dwCountryCode = dwCountryCode;
            lstrcpy(gpWizardState->cmnStateData.szAreaCode, W2A(bstrAreaCode));
            SysFreeString(bstrAreaCode);
        }
        else
        {
            // We need to have the user enter the area code
            if (wNumLocations)
            {
                int iIndex = 0;
                CleanupCombo(hDlg);
                for (long lIndex=0; lIndex < (long)wNumLocations; lIndex++)
                {
                    BSTR bstr = NULL;
                    if (S_OK == gpWizardState->pTapiLocationInfo->get_LocationName(lIndex, &bstr))
                    {
                       iIndex = ComboBox_InsertString(GetDlgItem(hDlg, IDC_DIAL_FROM), lIndex, W2A(bstr));
                    }
                    SysFreeString(bstr);
                }

                BSTR bstrCountry = NULL;
                BSTR bstrAreaCode = NULL;
                long lCountryCode = 0;
                ComboBox_SetCurSel( GetDlgItem(hDlg, IDC_DIAL_FROM), lCurrLocIndex );
                if (S_OK == gpWizardState->pTapiLocationInfo->get_LocationInfo(lCurrLocIndex, &gpWizardState->lLocationID, &bstrCountry, &lCountryCode, &bstrAreaCode))
                {
                    if (gpWizardState->lLocationID != lLastLocationID)
                    {
                        gpWizardState->bDoneRefServDownload = FALSE;
                    }
                    if (-1 == gpWizardState->lDefaultLocationID)
                    {
                        gpWizardState->lDefaultLocationID = gpWizardState->lLocationID;
                    }
                    lLastLocationID = gpWizardState->lLocationID;
                    gpWizardState->cmnStateData.dwCountryCode = (DWORD) lCountryCode;
                    SetWindowText(GetDlgItem(hDlg, IDC_AREACODE), W2A(bstrAreaCode));
                    SetWindowText(GetDlgItem(hDlg, IDC_COUNTRY), W2A(bstrCountry));
                }

                SysFreeString(bstrCountry);
                SysFreeString(bstrAreaCode);
             
            }
        }
    }
    // if we've travelled through external apprentice pages,
    // it's easy for our current page pointer to get munged,
    // so reset it here for sanity's sake.
    gpWizardState->uCurrentPage = ORD_PAGE_AREACODE;
    
    return TRUE;
}

/*******************************************************************

  NAME:    AreaCodeOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from  page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK AreaCodeOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    ASSERT(puNextPage);
    // Extract the data entered by the user and save it.
    if (fForward)
    {
        //BUGBUG - if we are in auto config, we need to change the title of the next page
        GetWindowText(GetDlgItem(hDlg, IDC_AREACODE), gpWizardState->cmnStateData.szAreaCode, MAX_AREA_CODE);
        gpWizardState->pTapiLocationInfo->put_LocationId(gpWizardState->lLocationID);
        if (gpWizardState->lLocationID != lLastLocationID)
        {
            lLastLocationID = gpWizardState->lLocationID;
            gpWizardState->bDoneRefServDownload = FALSE;
        }
    }

    return TRUE;
}

/*******************************************************************

  NAME:    AreaCodeCmdProc

********************************************************************/
BOOL CALLBACK AreaCodeCmdProc
(
    HWND    hDlg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
            
    switch(GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_DIAL_FROM:
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
            {
                // Get the currently selected item
                HWND        hWndDialFrom    = GetDlgItem(hDlg, IDC_DIAL_FROM);
                int         iIndex          = ComboBox_GetCurSel( hWndDialFrom );

                BSTR bstrCountry = NULL;
                BSTR bstrAreaCode = NULL;
                long lCountryCode = 0;

                if (S_OK == gpWizardState->pTapiLocationInfo->get_LocationInfo( iIndex, 
                                                                                &gpWizardState->lLocationID,
                                                                                &bstrCountry, 
                                                                                &lCountryCode, 
                                                                                &bstrAreaCode))
                {
                    gpWizardState->cmnStateData.dwCountryCode = lCountryCode;
                    if (bstrAreaCode)
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_AREACODE), W2A(bstrAreaCode));
                    }
                    else
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_AREACODE), NULL);
                    }
                    if (bstrCountry)
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_COUNTRY), W2A(bstrCountry));
                    }
                    else
                    {
                        SetWindowText(GetDlgItem(hDlg, IDC_COUNTRY), NULL);
                    }
                }
            }
            break;
        }
        default:
            break;
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\appwnd.h ===
// This class will implement

class CICWApp
{
    public:
        // Data    
        HWND        m_hWndApp;             // Window Handle of the Application
        HACCEL      m_haccel;
        TCHAR       m_szOEMHTML[INTERNET_MAX_URL_LENGTH];
        TCHAR       m_szAppTitle[MAX_TITLE];
        COLORREF    m_clrBusyBkGnd;
        CICWButton  m_BtnBack;
        CICWButton  m_BtnNext;
        CICWButton  m_BtnCancel;
        CICWButton  m_BtnFinish;
        CICWButton  m_BtnTutorial;
        
        CICWApp( void );
        ~CICWApp( void );

        HRESULT Initialize( void );
        static LRESULT CALLBACK ICWAppWndProc(HWND hWnd,
                                       UINT uMessage,
                                       WPARAM wParam,
                                       LPARAM lParam);

        void SetWizButtons(HWND hDlg, LPARAM lParam);
        
        HRESULT SetBackgroundBitmap(LPTSTR szBkgrndBmp);
        HRESULT SetFirstPageBackgroundBitmap(LPTSTR szBkgrndBmp);
        HRESULT SetTitleParams(int iTitleTop,
                               int iTitleLeft,
                               LPTSTR lpszFontFace,
                               long lFontPts,
                               long lFontWeight,
                               COLORREF clrFont);
        
        int     GetButtonAreaHeight();

        // Use Default wizard page placement
        HRESULT SetWizardWindowTop(int iTop);
        HRESULT SetWizardWindowLeft(int iLeft);
        
    private:
        // Fuctions
        BOOL    InitWizAppWindow(HWND hWnd);
        BOOL    InitAppButtons(HWND hWnd);
        BOOL    InitAppHTMLWindows(HWND hWnd);
        BOOL    CreateWizardPages(HWND hWnd);
        BOOL    CycleButtonFocus(BOOL bForward);
        BOOL    CheckButtonFocus( void );
        
        void    DisplayHTML( void );
        void    CenterWindow( void );
        
        // Data    
        HWND        m_hwndHTML;
        HWND        m_hwndTitle;
        HFONT       m_hTitleFont;
        COLORREF    m_clrTitleFont;
        
        int         m_iWizardTop;           // Top left corner of where the
        int         m_iWizardLeft;          // wizard dialogs will be placed
        RECT        m_rcClient;             // Client area of the Application
        RECT        m_rcHTML;               // Size of the OEM HTML area (first page)
        RECT        m_rcTitle;
        
        int         m_iBtnBorderHeight;     // Total border above and below the wizard
                                            // buttons
        int         m_iBtnAreaHeight;           // Overall button area height                                            
        BOOL        m_bOnHTMLIntro;
        HWND        m_hWndFirstWizardPage;
        
        HBITMAP     m_hbmFirstPageBkgrnd;
        
        WORD        m_wMinWizardHeight;
        WORD        m_wMinWizardWidth;
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\debug.cpp ===
//
//
//
#include "pre.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "icwconn1"
#define SZ_MODULE           "icwconn1"
#define DECLARE_DEBUG

#include <ccstock.h>
#include "..\inc\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\connect.h ===
#define DISPID_RasDialStatus       0x1
#define DISPID_DownloadProgress    0x2
#define DISPID_DownloadComplete    0x3
#define DISPID_RasConnectComplete  0x4

class CRefDialEvent : public _RefDialEvents
{    
    private:        
        ULONG       m_cRef;     //Reference count        
        UINT        m_uID;      //Sink identifier    
        HWND        m_hWnd;
    public:        
    //Connection key, public for CApp's usage        
        DWORD       m_dwCookie;    
    public:        
        CRefDialEvent(HWND  hWnd);
        ~CRefDialEvent(void);        
        
        //IUnknown members        
        STDMETHODIMP         QueryInterface(REFIID, void **);        
        STDMETHODIMP_(DWORD) AddRef(void);        
        STDMETHODIMP_(DWORD) Release(void);        
        
        //IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(/* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        STDMETHODIMP Invoke(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS  *pDispParams,
            /* [out] */ VARIANT  *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\desktop.cpp ===
//**********************************************************************
// File name: desktop.cpp
//
//      Desktop manipulation functions
//
// Functions:
//
// Copyright (c) 1992 - 1998 Microsoft Corporation. All rights reserved.
//**********************************************************************

#include "pre.h"
#include "regstr.h"
#include "inetreg.h"
#include <shlobj.h>
#include <shfolder.h>   // latest platform SDK has this

#define MAX_USER_NAME             255
#define REGSTR_PATH_SETUPKEY      REGSTR_PATH_SETUP REGSTR_KEY_SETUP
#define REGSTR_PATH_IEONDESKTOP   REGSTR_PATH_IEXPLORER TEXT("\\AdvancedOptions\\BROWSE\\IEONDESKTOP")
#define InternetConnectionWiz     "Internet Connection Wizard"
#define NOICWICON                 "NoICWIcon"

static const TCHAR g_szRegPathWelcomeICW[]  = TEXT("Welcome\\ICW");
static const TCHAR g_szAllUsers[]           = TEXT("All Users");
static const TCHAR g_szConnectApp[]         = TEXT("ICWCONN1.EXE");
static const TCHAR g_szConnectLink[]        = TEXT("Connect to the Internet");
static const TCHAR g_szOEApp[]              = TEXT("MSINM.EXE");
static const TCHAR g_szOELink[]             = TEXT("Outlook Express");
static const TCHAR g_szRegPathICWSettings[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
static const TCHAR g_szRegValICWCompleted[] = TEXT("Completed");
static const TCHAR g_szRegValNoIcon[]       = TEXT("NoIcon");

extern BOOL MyIsSmartStartEx(LPTSTR lpszConnectionName, DWORD dwBufLen);
extern BOOL IsNT();
extern BOOL IsNT5();

void QuickCompleteSignup()
{
    // Set the welcome state
    UpdateWelcomeRegSetting(TRUE);

    // Restore the desktop
    UndoDesktopChanges(g_hInstance);

    // Mark the ICW as being complete
    SetICWComplete();
}


void UpdateWelcomeRegSetting
(
    BOOL    bSetBit
)
{
    HKEY    hkey;
    HKEY    hkeyCurVer;
    DWORD   dwValue = bSetBit;
         
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_SETUP,         // ...\Windows\CurrentVersion
                     0,
                     KEY_ALL_ACCESS,
                     &hkeyCurVer) == ERROR_SUCCESS)
    {
                        
        DWORD dwDisposition;
        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCurVer,
                                            g_szRegPathWelcomeICW,
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE, 
                                            KEY_ALL_ACCESS, 
                                            NULL, 
                                            &hkey, 
                                            &dwDisposition))
        {
            RegSetValueEx(hkey,
                          TEXT("@"),
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwValue,
                          sizeof(DWORD));                              

            RegCloseKey(hkey);
        }       
        RegCloseKey(hkeyCurVer);
    }        
}

BOOL GetCompletedBit( )
{
    HKEY    hkey;
    DWORD   dwValue;
    DWORD   dwRet = ERROR_GEN_FAILURE;
    DWORD   dwType = REG_DWORD;
    BOOL    bBit = FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     g_szRegPathICWSettings,         // ...Software\\Microsoft\\Internet Connection Wizard
                     0,
                     KEY_ALL_ACCESS,
                     &hkey) == ERROR_SUCCESS)
    {
        DWORD dwDataSize = sizeof (dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, g_szRegValICWCompleted, NULL, &dwType, (LPBYTE) &dwValue, &dwDataSize))
        {
            bBit = (1 == dwValue);
        }
        RegCloseKey(hkey);
    }        
    return bBit;
}

// shlwapi!StrCatBuff is not be available in Win95/NT without IE5. Not sure
// if ICW has to run in these environment or not.
//
// return pszDestination. always NULL terminated.
void MyStrCatBuff(
  LPTSTR pszDestination,        // in/out. null terminated string
  LPCTSTR pszSource,            // in. null terminated string
  int cchDestBuffSize           // in. size of pzDestination in TCHAR
)
{
    int nDestLen = lstrlen(pszDestination);
    int nRemainLen = cchDestBuffSize - nDestLen;

    if (nRemainLen > 1)
    {
        // has room in additional to '\0'
        lstrcpyn(&(pszDestination[nDestLen]), pszSource, nRemainLen);
    }
}


void GetDesktopDirectory(TCHAR* pszPath)
{
    LPITEMIDLIST lpItemDList = NULL;
    IMalloc*     pMalloc     = NULL;
    HRESULT      hr          = E_FAIL;
    
    if(IsNT5()) // Bug 81444 in IE DB
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &lpItemDList);
    else if (IsNT())
        hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &lpItemDList);
    else
    {


        TCHAR pszFolder[MAX_PATH];
        *pszFolder = 0;
        HRESULT hRet = S_FALSE;

        HMODULE hmod = LoadLibrary(TEXT("shfolder.dll"));
        PFNSHGETFOLDERPATH pfn = NULL;
        if (hmod)
        {
            pfn = (PFNSHGETFOLDERPATH)GetProcAddress(hmod, "SHGetFolderPathA"); // or W if you are unicode
            if (pfn)
            {
                hRet = pfn(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, NULL, 0, pszFolder);
                if (S_OK != hRet)
                    hRet = pfn(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, pszFolder);
                if (S_OK == hRet)
                    lstrcpy(pszPath ,pszFolder);
            }
            FreeLibrary(hmod);
        }

        if (S_OK != hRet)
        {

            FARPROC hShell32VersionProc = NULL;
            HMODULE hShell32Mod = (HMODULE)LoadLibrary(TEXT("shell32.dll"));
    
            if (hShell32Mod)
                hShell32VersionProc = GetProcAddress(hShell32Mod, "DllGetVersion");

            if(hShell32VersionProc)
            {
                TCHAR szDir [MAX_PATH] = TEXT("\0");

                //ok, we're not NT, but we may be multiuser windows.
                GetWindowsDirectory(szDir, MAX_PATH);
                if (szDir)
                {
                    MyStrCatBuff(szDir, TEXT("\\"), MAX_PATH);
                    MyStrCatBuff(szDir, g_szAllUsers, MAX_PATH);
            
                    TCHAR szTemp [MAX_MESSAGE_LEN] = TEXT("\0");      
            
                    LoadString(g_hInstance, IDS_DESKTOP, szTemp, MAX_MESSAGE_LEN);
                    if (szTemp)
                    {
                        MyStrCatBuff(szDir, TEXT("\\"), MAX_PATH);
                        MyStrCatBuff(szDir, szTemp, MAX_PATH);
                        lstrcpy(pszPath ,szDir);
                    }
                }
            }
            else
                hr = SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOPDIRECTORY, &lpItemDList);
        }
    }

    if (SUCCEEDED(hr))  
    {
        SHGetPathFromIDList(lpItemDList, pszPath);
    
        if (SUCCEEDED(SHGetMalloc (&pMalloc)))
        {
            pMalloc->Free (lpItemDList);
            pMalloc->Release ();
        }
    }
}


void RemoveDesktopShortCut
(
    LPTSTR lpszShortcutName    
)
{
    TCHAR szShortcutPath[MAX_PATH] = TEXT("\0");
    
    GetDesktopDirectory(szShortcutPath);
    
    if(szShortcutPath[0] != TEXT('\0'))
    {
        lstrcat(szShortcutPath, TEXT("\\"));
        lstrcat(szShortcutPath, lpszShortcutName);
        lstrcat(szShortcutPath, TEXT(".LNK"));
        DeleteFile(szShortcutPath);
    }
}

// This function will add a desktop shortcut
void AddDesktopShortCut
(
    LPTSTR lpszAppName,
    LPTSTR lpszLinkName
)
{
    TCHAR       szConnectPath     [MAX_PATH]   = TEXT("\0");
    TCHAR       szAppPath         [MAX_PATH]   = TEXT("\0");
    TCHAR       szConnectLinkPath [MAX_PATH]   = TEXT("\0");        // Path the where the Shortcut file will livE 
    TCHAR       szdrive           [_MAX_DRIVE] = TEXT("\0");   
    TCHAR       szdir             [_MAX_DIR]   = TEXT("\0");
    TCHAR       szfname           [_MAX_FNAME] = TEXT("\0");   
    TCHAR       szext             [_MAX_EXT]   = TEXT("\0");
    TCHAR       szRegPath         [MAX_PATH]   = TEXT("\0");
    HRESULT     hres                           = E_FAIL; 
    IShellLink* psl                            = NULL;
    HKEY        hkey                           = NULL;
    
    // first get the app path
    lstrcpy(szRegPath, REGSTR_PATH_APPPATHS);
    lstrcat(szRegPath, TEXT("\\"));
    lstrcat(szRegPath, lpszAppName);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     szRegPath,
                     0,
                     IsNT5()? KEY_QUERY_VALUE : KEY_ALL_ACCESS,
                     &hkey) == ERROR_SUCCESS)
    {
        DWORD dwTmp = sizeof(szConnectPath);
        DWORD dwType = 0;
        if(RegQueryValueEx(hkey, 
                           NULL, 
                           NULL,
                           &dwType,
                           (LPBYTE) szConnectPath, 
                           &dwTmp) != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return;
        }
        RegQueryValueEx(hkey, 
                           TEXT("Path"), 
                           NULL,
                           &dwType,
                           (LPBYTE) szAppPath, 
                           &dwTmp);

        RegCloseKey(hkey);
    }
    else
    {
        return;
    }

    GetDesktopDirectory(szConnectLinkPath);
    
    if(szConnectLinkPath[0] != TEXT('\0'))
    {
        // Append on the connect EXE name
        lstrcat(szConnectLinkPath, TEXT("\\"));
        lstrcat(szConnectLinkPath, lpszAppName);

        //
        int nLastChar = lstrlen(szAppPath)-1;
        if ((nLastChar > 0) && (';' == szAppPath[nLastChar]))
            szAppPath[nLastChar] = 0;

        // Split the path, and the reassemble with the .LNK extension
        _tsplitpath( szConnectLinkPath, szdrive, szdir, szfname, szext );
        _tmakepath(szConnectLinkPath, szdrive, szdir, lpszLinkName, TEXT(".LNK"));

        // Create an IShellLink object and get a pointer to the IShellLink 
        // interface (returned from CoCreateInstance).
        hres = CoCreateInstance (CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IShellLink, (void **)&psl);
        if (SUCCEEDED (hres))
        {
            IPersistFile *ppf;

            // Query IShellLink for the IPersistFile interface for 
            // saving the shortcut in persistent storage.
            hres = psl->QueryInterface (IID_IPersistFile, (void **)&ppf);
            if (SUCCEEDED (hres))
            { 
                WORD wsz [MAX_PATH]; // buffer for Unicode string

                do
                {  

                    // Set the path to the shortcut target.
                    if (!SUCCEEDED(psl->SetPath (szConnectPath)))
                        break;

                    // Set the working dir to the shortcut target.
                    if (!SUCCEEDED(psl->SetWorkingDirectory (szAppPath)))
                        break;

                    // Set the args.
                    if (!SUCCEEDED(psl->SetArguments (SHORTCUTENTRY_CMD)))
                        break;

                    // Set the description of the shortcut.
                    TCHAR   szDescription[MAX_MESSAGE_LEN];
                    if (!LoadString(g_hInstance, IDS_SHORTCUT_DESC, szDescription, MAX_MESSAGE_LEN))
                        lstrcpy(szDescription, lpszLinkName);

                    if (!SUCCEEDED(psl->SetDescription (szDescription)))
                        break;
                
                    // Ensure that the string consists of ANSI TCHARacters.
#ifdef UNICODE
                    lstrcpy(wsz, szConnectLinkPath);
#else
                    MultiByteToWideChar (CP_ACP, 0, szConnectLinkPath, -1, wsz, MAX_PATH);
#endif
        
                    // Save the shortcut via the IPersistFile::Save member function.
                    if (!SUCCEEDED(ppf->Save (wsz, TRUE)))
                        break;
                    
                    // Release the pointer to IPersistFile.
                    ppf->Release ();
                    break;
                
                } while (1);
            }
            // Release the pointer to IShellLink.
            psl->Release ();
        }
    }        
} 

// This function will apply the appropriate desktop changes based on the following
// algorithm.  This code below assumes that the machine is NOT internet capable.
// If the machine was upgraded from a previous OS, then
//      Add the connect to the internet ICON
//  ELSE (clean install or OEM pre install)
//      Add the connect to the internet ICON
//
void DoDesktopChanges
(
    HINSTANCE   hAppInst
)
{
    TCHAR    szAppName[MAX_PATH];
    TCHAR    szLinkName[MAX_PATH];
    HKEY    hkey;

    if (!LoadString(hAppInst, IDS_CONNECT_FNAME, szAppName, ARRAYSIZE(szAppName)))
        lstrcpy(szAppName, g_szConnectApp);
                    
    if (!LoadString(hAppInst, IDS_CONNECT_DESKTOP_TITLE, szLinkName, ARRAYSIZE(szLinkName)))
        lstrcpy(szLinkName, g_szConnectLink);

    // We always add the connect shortcut
    AddDesktopShortCut(szAppName, szLinkName);                
                                
    // Set a registry value indicating that we messed with the desktop
    DWORD dwDisposition;
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                        ICWSETTINGSPATH,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE, 
                                        KEY_ALL_ACCESS, 
                                        NULL, 
                                        &hkey, 
                                        &dwDisposition))
    {
        DWORD   dwDesktopChanged = 1;    
        RegSetValueEx(hkey, 
                      ICWDESKTOPCHANGED, 
                      0, 
                      REG_DWORD,
                      (LPBYTE)&dwDesktopChanged, 
                      sizeof(DWORD));
        RegCloseKey(hkey);
    }
}

// This undoes what DoDesktopChanges did
void UndoDesktopChanges
(
    HINSTANCE   hAppInst
)
{

    TCHAR    szConnectTotheInternetTitle[MAX_PATH];
    HKEY    hkey;

    // Verify that we really changed the desktop
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      ICWSETTINGSPATH,
                                      0,
                                      KEY_ALL_ACCESS,
                                      &hkey))
    {
        DWORD   dwDesktopChanged = 0;    
        DWORD   dwTmp = sizeof(DWORD);
        DWORD   dwType = 0;
        
        RegQueryValueEx(hkey, 
                        ICWDESKTOPCHANGED, 
                        NULL, 
                        &dwType,
                        (LPBYTE)&dwDesktopChanged, 
                        &dwTmp);
        RegCloseKey(hkey);
        
        // Bail if the desktop was not changed by us
        if(!dwDesktopChanged)
            return;
    }
        
    // Always nuke the Connect to the internet icon
    if (!LoadString(hAppInst, 
                    IDS_CONNECT_DESKTOP_TITLE, 
                    szConnectTotheInternetTitle, 
                    ARRAYSIZE(szConnectTotheInternetTitle)))
    {
        lstrcpy(szConnectTotheInternetTitle, g_szConnectLink);
    }
    
    RemoveDesktopShortCut(szConnectTotheInternetTitle);    
}    

void UpdateDesktop
(
    HINSTANCE   hAppInst
)
{
    if(MyIsSmartStartEx(NULL, 0))
    {
        // VYUNG NT5 bug See if IEAK wants to stop GETCONN icon creation
        //if (!SHGetRestriction(NULL, TEXT("Internet Connection Wizard"), TEXT("NoICWIcon")))
        // CHUNHOC NT5.1 bug Don't create icon at desktop in any case.
        /*
        if (!SHGetRestriction(NULL, L"Internet Connection Wizard", L"NoICWIcon"))
            DoDesktopChanges(hAppInst);
        */
    }
    else
    {
        // We are internet ready, so set the appropriate Welcome show bit
        // and replace the IE and OE links
        UpdateWelcomeRegSetting(TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\fdi.cpp ===
//#include <stdio.h>
//
//#include <string.h>

#include "pre.h"

#include "fdi.h"
#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>


/*
 * Function prototypes 
 */
BOOL	fdi(char *cabinet_file, char *dir);
int		get_percentage(unsigned long a, unsigned long b);
char   *return_fdi_error_string(int err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[256];


/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read((int)hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write((int)hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close((int)hf);
}


FNSEEK(file_seek)
{
	return _lseek((int)hf, dist, seektype);
}


FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
            /*
			printf(
				"fdintCABINET_INFO\n"
				"  next cabinet     = %s\n"
				"  next disk        = %s\n"
				"  cabinet path     = %s\n"
				"  cabinet set ID   = %d\n"
				"  cabinet # in set = %d (zero based)\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3,
				pfdin->setID,
				pfdin->iCabinet
			);
            */
			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
            /*
			printf(
				"fdintPARTIAL_FILE\n"
				"   name of continued file            = %s\n"
				"   name of cabinet where file starts = %s\n"
				"   name of disk where file starts    = %s\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
            */
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
        	INT_PTR	handle;
            //int		response;
			char	destination[256];
            /*
			printf(
				"fdintCOPY_FILE\n"
				"  file name in cabinet = %s\n"
				"  uncompressed file size = %d\n"
				"  copy this file? (y/n): ",
				pfdin->psz1,
				pfdin->cb
			);

			do
			{
				response = getc(stdin);
				response = toupper(response);
			} while (response != 'Y' && response != 'N');

			printf("\n");

			if (response == 'Y')
			{
				sprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);

				handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

				return handle;
			}
			else
			{
				return 0;
			}
            */
            sprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);

            handle = file_open(
					destination,
					_O_BINARY | _O_CREAT | _O_WRONLY | _O_SEQUENTIAL,
					_S_IREAD | _S_IWRITE 
				);

            return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
        {
            HANDLE  handle;
            DWORD   attrs;
            char    destination[256];
            /*
 			printf(
				"fdintCLOSE_FILE_INFO\n"
				"   file name in cabinet = %s\n"
				"\n",
				pfdin->psz1
			);

            sprintf(
                destination, 
                "%s%s",
                dest_dir,
                pfdin->psz1
            );
            */
            sprintf(
					destination, 
					"%s%s",
					dest_dir,
					pfdin->psz1
				);
			file_close(pfdin->hf);


            handle = CreateFileA(
                destination,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );

            if (handle != INVALID_HANDLE_VALUE)
            {
                FILETIME    datetime;

                if (TRUE == DosDateTimeToFileTime(
                    pfdin->date,
                    pfdin->time,
                    &datetime))
                {
                    FILETIME    local_filetime;

                    if (TRUE == LocalFileTimeToFileTime(
                        &datetime,
                        &local_filetime))
                    {
                        (void) SetFileTime(
                            handle,
                            &local_filetime,
                            NULL,
                            &local_filetime
                        );
                     }
                }

                CloseHandle(handle);
            }

            attrs = pfdin->attribs;

            attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

            (void) SetFileAttributesA(
                destination,
                attrs
            );

			return TRUE;
        }

		case fdintNEXT_CABINET:	// file continued to next cabinet
            /*
			printf(
				"fdintNEXT_CABINET\n"
				"   name of next cabinet where file continued = %s\n"
                "   name of next disk where file continued    = %s\n"
				"   cabinet path name                         = %s\n"
				"\n",
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3
			);
            */
			return 0;
        
	}
	return 0;
}


BOOL fdi(char *cabinet_fullpath, char * directory)
{
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	INT_PTR			hf;
	char			*p;
	char			cabinet_name[256];
	char			cabinet_path[256];

    strcpy(dest_dir, directory);

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
        char szErr[255];
		sprintf(szErr, "FDICreate() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		return FALSE;
	}


	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		cabinet_fullpath,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		char szErr[255];
		sprintf(szErr, "Unable to open '%s' for input\n", cabinet_fullpath);
        MessageBoxA(NULL, szErr, "", MB_OK);

		return FALSE;
	}

	if (FALSE == FDIIsCabinet(
			hfdi,
			hf,
			&fdici))
	{
		/*
		 * No, it's not a cabinet!
		 */
		_close((int)hf);

        char szErr[255];
		sprintf(szErr, "FDIIsCabinet() failed: '%s' is not a cabinet\n",
			cabinet_fullpath
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}
	else
	{
		_close((int)hf);

        /*
        char szErr[255];
		sprintf(szErr, "Information on cabinet file '%s'\n"
			"   Total length of cabinet file : %d\n"
			"   Number of folders in cabinet : %d\n"
			"   Number of files in cabinet   : %d\n"
			"   Cabinet set ID               : %d\n"
			"   Cabinet number in set        : %d\n"
			"   RESERVE area in cabinet?     : %s\n"
			"   Chained to prev cabinet?     : %s\n"
			"   Chained to next cabinet?     : %s\n"
			"\n",
			cabinet_fullpath,
			fdici.cbCabinet,
			fdici.cFolders,
			fdici.cFiles,
			fdici.setID,
			fdici.iCabinet,
			fdici.fReserve == TRUE ? "yes" : "no",
			fdici.hasprev == TRUE ? "yes" : "no",
			fdici.hasnext == TRUE ? "yes" : "no"
		);
        MessageBox(NULL, szErr, "", MB_OK);
        */
	}

	p = strrchr(cabinet_fullpath, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, cabinet_fullpath);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		strncpy(cabinet_path, cabinet_fullpath, (int) (p-cabinet_fullpath)+1);
		cabinet_path[ (int) (p-cabinet_fullpath)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
        char szErr[255];
		sprintf(szErr, "FDICopy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		(void) FDIDestroy(hfdi);
		return FALSE;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
        char szErr[255];
		sprintf(szErr, "FDIDestroy() failed: code %d [%s]\n",
			erf.erfOper, return_fdi_error_string(erf.erfOper)
		);
        MessageBoxA(NULL, szErr, "", MB_OK);

		return FALSE;
	}

	return TRUE;
}


char *return_fdi_error_string(int err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return "No error";

		case FDIERROR_CABINET_NOT_FOUND:
			return "Cabinet not found";
			
		case FDIERROR_NOT_A_CABINET:
			return "Not a cabinet";
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return "Unknown cabinet version";
			
		case FDIERROR_CORRUPT_CABINET:
			return "Corrupt cabinet";
			
		case FDIERROR_ALLOC_FAIL:
			return "Memory allocation failed";
			
		case FDIERROR_BAD_COMPR_TYPE:
			return "Unknown compression type";
			
		case FDIERROR_MDI_FAIL:
			return "Failure decompressing data";
			
		case FDIERROR_TARGET_FILE:
			return "Failure writing to target file";
			
		case FDIERROR_RESERVE_MISMATCH:
			return "Cabinets in set have different RESERVE sizes";
			
		case FDIERROR_WRONG_CABINET:
			return "Cabinet returned on fdintNEXT_CABINET is incorrect";
			
		case FDIERROR_USER_ABORT:
			return "User aborted";
			
		default:
			return "Unknown error";
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\end.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  END.CPP - Functions for final Wizard pages
//

//  HISTORY:
//  
//  05/28/98    donaldm     created
//
//*********************************************************************

#include "pre.h"
#include "icwextsn.h"


/*******************************************************************

  NAME:    EndInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/

BOOL CALLBACK EndInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    HWND  hwndPropsheet    = GetParent(hDlg);

    SetWindowLongPtr(GetDlgItem(hDlg, IDC_STATIC_ICON), GWLP_USERDATA, 201);

    // This is the very last page, so no back is not possible
    if (!g_bAllowCancel)
    {
        PropSheet_CancelToClose(hwndPropsheet);

        // Get the main frame window's style
        LONG window_style = GetWindowLong(hwndPropsheet, GWL_STYLE);

        //Remove the system menu from the window's style
        window_style &= ~WS_SYSMENU;

        //set the style attribute of the main frame window
        SetWindowLong(hwndPropsheet, GWL_STYLE, window_style);
    }
    
    if (!fFirstInit)
    {
        HWND  hwndBtn                     = GetDlgItem(hDlg, IDC_CHECK_BROWSING);
        TCHAR szTemp  [MAX_MESSAGE_LEN*2] = TEXT("\0");
            
        if (gpICWCONNApprentice)
            gpICWCONNApprentice->SetStateDataFromDllToExe( &gpWizardState->cmnStateData);

        PropSheet_SetWizButtons(hwndPropsheet, PSWIZB_FINISH); 

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
#ifndef ICWDEBUG
        // NOTE: No ORD_PAGE_ENDOEMCUSTOM for ICWDEBUG
        if (gpWizardState->cmnStateData.bOEMCustom)
            gpWizardState->uCurrentPage = ORD_PAGE_ENDOEMCUSTOM;
        else            
#endif  
            gpWizardState->uCurrentPage = ORD_PAGE_END;

        //the ins has failed let's display the special message.
        if (gpWizardState->cmnStateData.ispInfo.bFailedIns)
        {
            TCHAR szErrTitle   [MAX_MESSAGE_LEN] = TEXT("\0");
            TCHAR szErrMsg1    [MAX_RES_LEN]     = TEXT("\0");    
            TCHAR szErrMsg2    [MAX_RES_LEN]     = TEXT("\0");  
            TCHAR szErrMsg3    [MAX_RES_LEN]     = TEXT("\0");    
            TCHAR szErrMsgTmp1 [MAX_RES_LEN]     = TEXT("\0");    
            TCHAR szErrMsgTmp2 [MAX_RES_LEN]     = TEXT("\0");    

            LoadString(g_hInstance, IDS_INSCONFIG_ERROR_TITLE, szErrTitle, MAX_MESSAGE_LEN);
           
            SetWindowText(GetDlgItem(hDlg, IDC_LBLTITLE), szErrTitle);
            
            if(*(gpWizardState->cmnStateData.ispInfo.szISPName))
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_1, szErrMsg1, ARRAYSIZE(szErrMsg1));
                wsprintf(szErrMsgTmp1, szErrMsg1, gpWizardState->cmnStateData.ispInfo.szISPName); 
                lstrcpy(szTemp,szErrMsgTmp1);
            }
            else
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_1_NOINFO, szErrMsg1, ARRAYSIZE(szErrMsg1));
                lstrcpy(szTemp, szErrMsg1);
            }
            
            if(*(gpWizardState->cmnStateData.ispInfo.szSupportNumber))
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_2, szErrMsg2, ARRAYSIZE(szErrMsg2));
                wsprintf(szErrMsgTmp2, szErrMsg2, gpWizardState->cmnStateData.ispInfo.szSupportNumber); 
                lstrcat(szTemp, szErrMsgTmp2);
            }
            else
            {
                LoadString(g_hInstance, IDS_PRECONFIG_ERROR_2_NOINFO, szErrMsg2, ARRAYSIZE(szErrMsg2));
                lstrcat(szTemp, szErrMsg2);
            }

            LoadString(g_hInstance, IDS_INSCONFIG_ERROR_INSTRUCT, szErrMsg3, ARRAYSIZE(szErrMsg3));                
            lstrcat(szTemp, szErrMsg3);

            SetWindowText(GetDlgItem(hDlg, IDC_INSERROR_FINISH_TEXT), szTemp);

            ShowWindow(GetDlgItem(hDlg, IDC_FINISH_TEXT), SW_HIDE); 
            ShowWindow(GetDlgItem(hDlg, IDC_FINISH_SUPPORT_TEXT), SW_HIDE); 
            ShowWindow(GetDlgItem(hDlg, IDC_STATIC_ICON), SW_HIDE); 
            ShowWindow(GetDlgItem(hDlg, IDC_CLOSE_WIZ_CLICK_FINISH), SW_HIDE); 
            ShowWindow(hwndBtn, SW_HIDE); 
        }
        else
        {       
            if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_AUTOCONFIG)
                LoadString(g_hInstance, IDS_END_AUTOCFG_FINISH, szTemp, MAX_MESSAGE_LEN);
            else if (gpWizardState->cmnStateData.dwFlags & ICW_CFGFLAG_SMARTREBOOT_NEWISP)
                LoadString(g_hInstance, IDS_END_SIGNUP_FINISH, szTemp, MAX_MESSAGE_LEN);
            else
                LoadString(g_hInstance, IDS_END_MANUAL_FINISH, szTemp, MAX_MESSAGE_LEN);
            
            SetWindowText(GetDlgItem(hDlg, IDC_FINISH_TEXT), szTemp);
        }

        // IDC_CHECK_BROWSING is now permanently unchecked and hidden
        // (can't modify resources so we do it in code)
        ShowWindow(hwndBtn, SW_HIDE);
    }
    
    return TRUE;
}


/*******************************************************************

  NAME:    EndOKProc

  SYNOPSIS:  Called when Next or Back btns pressed from "Intro" page

  ENTRY:    hDlg - dialog window
        fForward - TRUE if 'Next' was pressed, FALSE if 'Back'
        puNextPage - if 'Next' was pressed,
          proc can fill this in with next page to go to.  This
          parameter is ingored if 'Back' was pressed.
        pfKeepHistory - page will not be kept in history if
          proc fills this in with FALSE.

  EXIT:    returns TRUE to allow page to be turned, FALSE
        to keep the same page.

********************************************************************/
BOOL CALLBACK EndOKProc
(
    HWND hDlg,
    BOOL fForward,
    UINT *puNextPage,
    BOOL *pfKeepHistory
)
{
    // If connection info is not saved, save it
    if (gpINETCFGApprentice)
    {
        DWORD dwStatus;
        gpINETCFGApprentice->Save(hDlg, &dwStatus);
    }
   
    return TRUE;
}
/*******************************************************************

  NAME:    EndOlsInitProc

  SYNOPSIS:  Called when page is displayed

  ENTRY:    hDlg - dialog window
        fFirstInit - TRUE if this is the first time the dialog
        is initialized, FALSE if this InitProc has been called
        before (e.g. went past this page and backed up)

********************************************************************/
#ifndef ICWDEBUG
BOOL CALLBACK EndOlsInitProc
(
    HWND hDlg,
    BOOL fFirstInit,
    UINT *puNextPage
)
{
    // This is a finish page
    PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_FINISH);

    if (!fFirstInit)
    {

        // if we've travelled through external apprentice pages,
        // it's easy for our current page pointer to get munged,
        // so reset it here for sanity's sake.
        gpWizardState->uCurrentPage = ORD_PAGE_ENDOLS;
    }        
    
    return TRUE;
}
#endif  //ICWDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\connectionwizard\icwconn1\dbgsrcs.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

GETCONN_DIR     = ..\..\

TARGET_BOTH     = 1
USE_MSVCRT      = 1

#
# Include our common makefile
#

!include $(GETCONN_DIR)\common.inc

INCLUDES = $(INCLUDES);$(GETCONN_DIR)\icwconn1;$(SHELL_INC_PATH)

# USE cdecl calling
386_STDCALL = 0
#
# Common settings required by build.exe and makefile.def
#

TARGETNAME      = icwdebug
TARGETPATH      = obj
TARGETTYPE      = PROGRAM
TARGETLIBS      =
PRECOMPILED_CXX = 1

#SET THE ICWDEBUG FLAG FOR THE IFDEFs
C_DEFINES = $(C_DEFINES) -DICWDEBUG -DNASHVILLE

LINKLIBS =      $(SDK_LIB_PATH)\kernel32.lib                    \
                $(SDK_LIB_PATH)\user32.lib                      \
                $(SDK_LIB_PATH)\gdi32.lib                       \
                $(SDK_LIB_PATH)\advapi32.lib                    \
                $(SDK_LIB_PATH)\comctl32.lib                    \
                $(SDK_LIB_PATH)\shell32.lib                     \
                $(SDK_LIB_PATH)\comdlg32.lib                    \
                $(SDK_LIB_PATH)\mpr.lib                         \
                $(SDK_LIB_PATH)\ole32.lib                       \
                $(SDK_LIB_PATH)\oleaut32.lib                    \
                $(SDK_LIB_PATH)\uuid.lib                        \
                $(SDK_LIB_PATH)\shlwapi.lib                     \
                $(SHELL_LIB_PATH)\shlwapip.lib                  \
                $(SDK_LIB_PATH)\fdi.lib                         \
!if defined(NOT_UNICODE)
                  $(GETCONN_DIR)\lib\ansi\$O\stocklib.lib       \
!else
                  $(GETCONN_DIR)\lib\unicode\$O\stocklib.lib    \
!endif


!if $(386)
UMENTRYABS      = ModuleEntry@0
!else
UMENTRYABS      = ModuleEntry
!endif

#
# List of sources
#
SOURCES=                   \
        ..\icwconn1.rc     \
        ..\icwconn1.cpp    \
        ..\icwextsn.cpp    \
        ..\icwext.cpp      \
        ..\debug.cpp       \
        ..\gendlg.cpp      \
        ..\desktop.cpp     \
        ..\reboot.cpp      \
        ..\icwhelp.cpp     \
        ..\end.cpp         \
        ..\util.cpp        \
      